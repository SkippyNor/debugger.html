var Inspector =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var Services = __webpack_require__(1);
	var promise = __webpack_require__(4);
	var defer = __webpack_require__(5);
	var EventEmitter = __webpack_require__(6);
	const {executeSoon} = __webpack_require__(8);
	var {KeyShortcuts} = __webpack_require__(15);
	var {Task} = __webpack_require__(17);
	const {initCssProperties} = __webpack_require__(18);
	const nodeConstants = __webpack_require__(33);
	const Telemetry = __webpack_require__(34);

	const Menu = __webpack_require__(35);
	const MenuItem = __webpack_require__(36);

	const {CommandUtils} = __webpack_require__(11);
	const {ComputedViewTool} = __webpack_require__(37);
	const {FontInspector} = __webpack_require__(164);
	const {HTMLBreadcrumbs} = __webpack_require__(165);
	const {InspectorSearch} = __webpack_require__(166);
	const {MarkupView} = __webpack_require__(167);
	const {RuleViewTool} = __webpack_require__(149);
	const {ToolSidebar} = __webpack_require__(194);
	const {ViewHelpers} = __webpack_require__(201);
	const clipboardHelper = __webpack_require__(158);

	const {LocalizationHelper} = __webpack_require__(39);
	const INSPECTOR_L10N = new LocalizationHelper("devtools/locale/inspector.properties");
	const TOOLBOX_L10N = new LocalizationHelper("devtools/locale/toolbox.properties");

	const { Selection } = __webpack_require__(202);
	const { InspectorFront } = __webpack_require__(204);
	const { getHighlighterUtils } = __webpack_require__(211);

	/**
	 * Represents an open instance of the Inspector for a tab.
	 * The inspector controls the breadcrumbs, the markup view, and the sidebar
	 * (computed view, rule view, font view and layout view).
	 *
	 * Events:
	 * - ready
	 *      Fired when the inspector panel is opened for the first time and ready to
	 *      use
	 * - new-root
	 *      Fired after a new root (navigation to a new page) event was fired by
	 *      the walker, and taken into account by the inspector (after the markup
	 *      view has been reloaded)
	 * - markuploaded
	 *      Fired when the markup-view frame has loaded
	 * - breadcrumbs-updated
	 *      Fired when the breadcrumb widget updates to a new node
	 * - layoutview-updated
	 *      Fired when the layoutview (box model) updates to a new node
	 * - markupmutation
	 *      Fired after markup mutations have been processed by the markup-view
	 * - computed-view-refreshed
	 *      Fired when the computed rules view updates to a new node
	 * - computed-view-property-expanded
	 *      Fired when a property is expanded in the computed rules view
	 * - computed-view-property-collapsed
	 *      Fired when a property is collapsed in the computed rules view
	 * - computed-view-sourcelinks-updated
	 *      Fired when the stylesheet source links have been updated (when switching
	 *      to source-mapped files)
	 * - computed-view-filtered
	 *      Fired when the computed rules view is filtered
	 * - rule-view-refreshed
	 *      Fired when the rule view updates to a new node
	 * - rule-view-sourcelinks-updated
	 *      Fired when the stylesheet source links have been updated (when switching
	 *      to source-mapped files)
	 */
	function InspectorPanel(iframeWindow, toolbox) {
	  this._toolbox = toolbox;
	  this._target = toolbox.target;
	  this.panelDoc = iframeWindow.document;
	  this.panelWin = iframeWindow;
	  this.panelWin.inspector = this;

	  this.telemetry = new Telemetry();

	  this.nodeMenuTriggerInfo = null;

	  this._handleRejectionIfNotDestroyed = this._handleRejectionIfNotDestroyed.bind(this);
	  this._onBeforeNavigate = this._onBeforeNavigate.bind(this);
	  this.onNewRoot = this.onNewRoot.bind(this);
	  this._onContextMenu = this._onContextMenu.bind(this);
	  this._updateSearchResultsLabel = this._updateSearchResultsLabel.bind(this);
	  this.onNewSelection = this.onNewSelection.bind(this);
	  this.onBeforeNewSelection = this.onBeforeNewSelection.bind(this);
	  this.onDetached = this.onDetached.bind(this);
	  this.onPaneToggleButtonClicked = this.onPaneToggleButtonClicked.bind(this);
	  this._onMarkupFrameLoad = this._onMarkupFrameLoad.bind(this);

	  this._target.on("will-navigate", this._onBeforeNavigate);
	  this._detectingActorFeatures = this._detectActorFeatures();

	  EventEmitter.decorate(this);
	}

	exports.InspectorPanel = InspectorPanel;

	InspectorPanel.prototype = {
	  /**
	   * open is effectively an asynchronous constructor
	   */
	  open: Task.async(function* () {
	    this._cssPropertiesLoaded = initCssProperties(this.toolbox);
	    yield this._cssPropertiesLoaded;

	    this._inspector = InspectorFront(this._target.client, this._target.form);
	    this._walker = yield this.inspector.getWalker(
	      {showAllAnonymousContent: Services.prefs.getBoolPref("devtools.inspector.showAllAnonymousContent")}
	    );
	    console.log("Walker", this.walker, this.walker.on);
	    this._selection = new Selection(this.walker);
	    this._highlighter = yield this.inspector.getHighlighter(false);

	    yield this.target.makeRemote();
	    yield this._getPageStyle();
	    let defaultSelection = yield this._getDefaultNodeForSelection();
	    return yield this._deferredOpen(defaultSelection);
	  }),

	  get toolbox() {
	    return this._toolbox;
	  },

	  get inspector() {
	    return this._inspector;
	  },

	  get walker() {
	    return this._walker;
	  },

	  get selection() {
	    return this._selection;
	  },

	  get isOuterHTMLEditable() {
	    return this._target.client.traits.editOuterHTML;
	  },

	  get hasUrlToImageDataResolver() {
	    return this._target.client.traits.urlToImageDataResolver;
	  },

	  get canGetUniqueSelector() {
	    return this._target.client.traits.getUniqueSelector;
	  },

	  get canGetUsedFontFaces() {
	    return this._target.client.traits.getUsedFontFaces;
	  },

	  get canPasteInnerOrAdjacentHTML() {
	    return this._target.client.traits.pasteHTML;
	  },

	  /**
	   * Handle promise rejections for various asynchronous actions, and only log errors if
	   * the inspector panel still exists.
	   * This is useful to silence useless errors that happen when the inspector is closed
	   * while still initializing (and making protocol requests).
	   */
	  _handleRejectionIfNotDestroyed: function (e) {
	    if (!this._panelDestroyer) {
	      console.error(e);
	    }
	  },

	  /**
	   * Figure out what features the backend supports
	   */
	  _detectActorFeatures: function () {
	    this._supportsDuplicateNode = false;
	    this._supportsScrollIntoView = false;
	    this._supportsResolveRelativeURL = false;

	    // Use getActorDescription first so that all actorHasMethod calls use
	    // a cached response from the server.
	    return this._target.getActorDescription("domwalker").then(desc => {
	      return promise.all([
	        this._target.actorHasMethod("domwalker", "duplicateNode").then(value => {
	          this._supportsDuplicateNode = value;
	        }).catch(e => console.error(e)),
	        this._target.actorHasMethod("domnode", "scrollIntoView").then(value => {
	          this._supportsScrollIntoView = value;
	        }).catch(e => console.error(e)),
	        this._target.actorHasMethod("inspector", "resolveRelativeURL").then(value => {
	          this._supportsResolveRelativeURL = value;
	        }).catch(e => console.error(e)),
	      ]);
	    });
	  },

	  _deferredOpen: function (defaultSelection) {
	    let deferred = defer();

	    this.walker.on("new-root", this.onNewRoot);

	    this.selection.on("new-node-front", this.onNewSelection);
	    this.selection.on("before-new-node-front", this.onBeforeNewSelection);
	    this.selection.on("detached-front", this.onDetached);

	    this.breadcrumbs = new HTMLBreadcrumbs(this);

	    if (this.target.isLocalTab) {
	      // Show a warning when the debugger is paused.
	      // We show the warning only when the inspector
	      // is selected.
	      this.updateDebuggerPausedWarning = () => {
	        let notificationBox = this._toolbox.getNotificationBox();
	        let notification =
	          notificationBox.getNotificationWithValue("inspector-script-paused");
	        if (!notification && this._toolbox.currentToolId == "inspector" &&
	            this._toolbox.threadClient.paused) {
	          let message = INSPECTOR_L10N.getStr("debuggerPausedWarning.message");
	          notificationBox.appendNotification(message,
	            "inspector-script-paused", "", notificationBox.PRIORITY_WARNING_HIGH);
	        }

	        if (notification && this._toolbox.currentToolId != "inspector") {
	          notificationBox.removeNotification(notification);
	        }

	        if (notification && !this._toolbox.threadClient.paused) {
	          notificationBox.removeNotification(notification);
	        }
	      };
	      this.target.on("thread-paused", this.updateDebuggerPausedWarning);
	      this.target.on("thread-resumed", this.updateDebuggerPausedWarning);
	      this._toolbox.on("select", this.updateDebuggerPausedWarning);
	      this.updateDebuggerPausedWarning();
	    }

	    this._initMarkup();
	    this.isReady = false;

	    this.once("markuploaded", () => {
	      this.isReady = true;

	      // All the components are initialized. Let's select a node.
	      this.selection.setNodeFront(defaultSelection, "inspector-open");
	      this.markup.expandNode(this.selection.nodeFront);

	      // And setup the toolbar only now because it may depend on the document.
	      this.setupToolbar();

	      this.emit("ready");
	      deferred.resolve(this);
	    });

	    this.setupSearchBox();
	    this.setupSidebar();

	    return deferred.promise;
	  },

	  _onBeforeNavigate: function () {
	    this._defaultNode = null;
	    this.selection.setNodeFront(null);
	    this._destroyMarkup();
	    this.isDirty = false;
	    this._pendingSelection = null;
	  },

	  _getPageStyle: function () {
	    return this.inspector.getPageStyle().then(pageStyle => {
	      this.pageStyle = pageStyle;
	    }, this._handleRejectionIfNotDestroyed);
	  },

	  /**
	   * Return a promise that will resolve to the default node for selection.
	   */
	  _getDefaultNodeForSelection: function () {
	    if (this._defaultNode) {
	      return this._defaultNode;
	    }
	    let walker = this.walker;
	    let rootNode = null;
	    let pendingSelection = this._pendingSelection;

	    // A helper to tell if the target has or is about to navigate.
	    // this._pendingSelection changes on "will-navigate" and "new-root" events.
	    let hasNavigated = () => pendingSelection !== this._pendingSelection;

	    // If available, set either the previously selected node or the body
	    // as default selected, else set documentElement
	    return walker.getRootNode().then(node => {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }

	      rootNode = node;
	      if (this.selectionCssSelector) {
	        return walker.querySelector(rootNode, this.selectionCssSelector);
	      }
	      return null;
	    }).then(front => {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }

	      if (front) {
	        return front;
	      }
	      return walker.querySelector(rootNode, "body");
	    }).then(front => {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }

	      if (front) {
	        return front;
	      }
	      return this.walker.documentElement();
	    }).then(node => {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }
	      this._defaultNode = node;
	      return node;
	    });
	  },

	  /**
	   * Target getter.
	   */
	  get target() {
	    return this._target;
	  },

	  /**
	   * Target setter.
	   */
	  set target(value) {
	    this._target = value;
	  },

	  /**
	   * Indicate that a tool has modified the state of the page.  Used to
	   * decide whether to show the "are you sure you want to navigate"
	   * notification.
	   */
	  markDirty: function () {
	    this.isDirty = true;
	  },

	  /**
	   * Hooks the searchbar to show result and auto completion suggestions.
	   */
	  setupSearchBox: function () {
	    this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
	    this.searchClearButton = this.panelDoc.getElementById("inspector-searchinput-clear");
	    this.searchResultsLabel = this.panelDoc.getElementById("inspector-searchlabel");

	    this.search = new InspectorSearch(this, this.searchBox, this.searchClearButton);
	    this.search.on("search-cleared", this._updateSearchResultsLabel);
	    this.search.on("search-result", this._updateSearchResultsLabel);

	    let shortcuts = new KeyShortcuts({
	      window: this.panelDoc.defaultView,
	    });
	    let key = INSPECTOR_L10N.getStr("inspector.searchHTML.key");
	    shortcuts.on(key, (name, event) => {
	      // Prevent overriding same shortcut from the computed/rule views
	      if (event.target.closest("#sidebar-panel-ruleview") ||
	          event.target.closest("#sidebar-panel-computedview")) {
	        return;
	      }
	      event.preventDefault();
	      this.searchBox.focus();
	    });
	  },

	  get searchSuggestions() {
	    return this.search.autocompleter;
	  },

	  _updateSearchResultsLabel: function (event, result) {
	    let str = "";
	    if (event !== "search-cleared") {
	      if (result) {
	        str = INSPECTOR_L10N.getFormatStr(
	          "inspector.searchResultsCount2", result.resultsIndex + 1, result.resultsLength);
	      } else {
	        str = INSPECTOR_L10N.getStr("inspector.searchResultsNone");
	      }
	    }

	    this.searchResultsLabel.textContent = str;
	  },

	  get React() {
	    return this._toolbox.React;
	  },

	  get ReactDOM() {
	    return this._toolbox.ReactDOM;
	  },

	  get browserRequire() {
	    return this._toolbox.browserRequire;
	  },

	  /**
	   * Build the sidebar.
	   */
	  setupSidebar: function () {
	    let tabbox = this.panelDoc.querySelector("#inspector-sidebar");
	    this.sidebar = new ToolSidebar(tabbox, this, "inspector", {
	      showAllTabsMenu: true
	    });

	    let defaultTab = Services.prefs.getCharPref("devtools.inspector.activeSidebar");

	    if (!Services.prefs.getBoolPref("devtools.fontinspector.enabled") &&
	       defaultTab == "fontinspector") {
	      defaultTab = "ruleview";
	    }

	    // Append all side panels
	    this.sidebar.addExistingTab(
	      "ruleview",
	      INSPECTOR_L10N.getStr("inspector.sidebar.ruleViewTitle"),
	      defaultTab == "ruleview");

	    this.sidebar.addExistingTab(
	      "computedview",
	      INSPECTOR_L10N.getStr("inspector.sidebar.computedViewTitle"),
	      defaultTab == "computedview");

	    this._setDefaultSidebar = (event, toolId) => {
	      Services.prefs.setCharPref("devtools.inspector.activeSidebar", toolId);
	    };

	    this.sidebar.on("select", this._setDefaultSidebar);

	    this.ruleview = new RuleViewTool(this, this.panelWin);
	    this.computedview = new ComputedViewTool(this, this.panelWin);

	    if (this.target.form.animationsActor) {
	      this.sidebar.addFrameTab(
	        "animationinspector",
	        INSPECTOR_L10N.getStr("inspector.sidebar.animationInspectorTitle"),
	        "chrome://devtools/content/animationinspector/animation-inspector.xhtml",
	        defaultTab == "animationinspector");
	    }

	    if (Services.prefs.getBoolPref("devtools.fontinspector.enabled") &&
	        this.canGetUsedFontFaces) {
	      this.sidebar.addExistingTab(
	        "fontinspector",
	        INSPECTOR_L10N.getStr("inspector.sidebar.fontInspectorTitle"),
	        defaultTab == "fontinspector");

	      this.fontInspector = new FontInspector(this, this.panelWin);
	      this.sidebar.toggleTab(true, "fontinspector");
	    }

	    this.setupSidebarSize();

	    this.sidebar.show(defaultTab);
	  },

	  /**
	   * Sidebar size is currently driven by vbox.inspector-sidebar-container
	   * element, which is located at the left/bottom side of the side bar splitter.
	   * Its size is changed by the splitter and stored into preferences.
	   * As soon as bug 1260552 is fixed and new HTML based splitter in place
	   * the size can be driven by div.inspector-sidebar element. This element
	   * represents the ToolSidebar and so, the entire logic related to size
	   * persistence can be done inside the ToolSidebar.
	   */
	  setupSidebarSize: function () {
	    let sidePaneContainer = this.panelDoc.querySelector(
	      "#inspector-sidebar-container");

	    this.sidebar.on("show", () => {
	      try {
	        sidePaneContainer.width = Services.prefs.getIntPref(
	          "devtools.toolsidebar-width.inspector");
	        sidePaneContainer.height = Services.prefs.getIntPref(
	          "devtools.toolsidebar-height.inspector");
	      } catch (e) {
	        // The default width is the min-width set in CSS
	        // for #inspector-sidebar-container
	        // Set width and height of the sidebar container. Only one
	        // value is really useful at a time depending on the current
	        // toolbox orientation and having both doesn't break anything.
	        sidePaneContainer.width = 450;
	        sidePaneContainer.height = 450;
	      }
	    });

	    this.sidebar.on("hide", () => {
	      Services.prefs.setIntPref("devtools.toolsidebar-width.inspector",
	        sidePaneContainer.width);
	      Services.prefs.setIntPref("devtools.toolsidebar-height.inspector",
	        sidePaneContainer.height);
	    });

	    this.sidebar.on("destroy", () => {
	      Services.prefs.setIntPref("devtools.toolsidebar-width.inspector",
	        sidePaneContainer.width);
	      Services.prefs.setIntPref("devtools.toolsidebar-height.inspector",
	        sidePaneContainer.height);
	    });
	  },

	  setupToolbar: function () {
	    this.teardownToolbar();

	    // Setup the sidebar toggle button.
	    let SidebarToggle = this.React.createFactory(__webpack_require__(
	      212));

	    let sidebarToggle = SidebarToggle({
	      onClick: this.onPaneToggleButtonClicked,
	      collapsed: false,
	      expandPaneTitle: INSPECTOR_L10N.getStr("inspector.expandPane"),
	      collapsePaneTitle: INSPECTOR_L10N.getStr("inspector.collapsePane"),
	    });

	    let parentBox = this.panelDoc.getElementById("inspector-sidebar-toggle-box");
	    this._sidebarToggle = this.ReactDOM.render(sidebarToggle, parentBox);

	    // Setup the add-node button.
	    this.addNode = this.addNode.bind(this);
	    this.addNodeButton = this.panelDoc.getElementById("inspector-element-add-button");
	    this.addNodeButton.addEventListener("click", this.addNode);

	    // Setup the eye-dropper icon if we're in an HTML document and we have actor support.
	    if (this.selection.nodeFront && this.selection.nodeFront.isInHTMLDocument) {
	      this.toolbox.target.actorHasMethod("inspector", "pickColorFromPage").then(value => {
	        if (!value) {
	          return;
	        }

	        this.onEyeDropperDone = this.onEyeDropperDone.bind(this);
	        this.onEyeDropperButtonClicked = this.onEyeDropperButtonClicked.bind(this);
	        this.eyeDropperButton = this.panelDoc
	                                    .getElementById("inspector-eyedropper-toggle");
	        this.eyeDropperButton.style.display = "initial";
	        this.eyeDropperButton.addEventListener("click", this.onEyeDropperButtonClicked);
	      }, e => console.error(e));
	    } else {
	      this.panelDoc.getElementById("inspector-eyedropper-toggle").style.display = "none";
	    }
	  },

	  teardownToolbar: function () {
	    this._sidebarToggle = null;

	    if (this.addNodeButton) {
	      this.addNodeButton.removeEventListener("click", this.addNode);
	      this.addNodeButton = null;
	    }

	    if (this.eyeDropperButton) {
	      this.eyeDropperButton.removeEventListener("click", this.onEyeDropperButtonClicked);
	      this.eyeDropperButton = null;
	    }
	  },

	  /**
	   * Reset the inspector on new root mutation.
	   */
	  onNewRoot: function () {
	    this._defaultNode = null;
	    this.selection.setNodeFront(null);
	    this._destroyMarkup();
	    this.isDirty = false;

	    let onNodeSelected = defaultNode => {
	      // Cancel this promise resolution as a new one had
	      // been queued up.
	      if (this._pendingSelection != onNodeSelected) {
	        return;
	      }
	      this._pendingSelection = null;
	      this.selection.setNodeFront(defaultNode, "navigateaway");

	      this._initMarkup();
	      this.once("markuploaded", () => {
	        if (!this.markup) {
	          return;
	        }
	        this.markup.expandNode(this.selection.nodeFront);
	        this.emit("new-root");
	      });

	      // Setup the toolbar again, since its content may depend on the current document.
	      this.setupToolbar();
	    };
	    this._pendingSelection = onNodeSelected;
	    this._getDefaultNodeForSelection()
	        .then(onNodeSelected, this._handleRejectionIfNotDestroyed);
	  },

	  _selectionCssSelector: null,

	  /**
	   * Set the currently selected node unique css selector.
	   * Will store the current target url along with it to allow pre-selection at
	   * reload
	   */
	  set selectionCssSelector(cssSelector) {
	    if (this._panelDestroyer) {
	      return;
	    }

	    this._selectionCssSelector = {
	      selector: cssSelector || null,
	      url: this._target.url
	    };
	  },

	  /**
	   * Get the current selection unique css selector if any, that is, if a node
	   * is actually selected and that node has been selected while on the same url
	   */
	  get selectionCssSelector() {
	    if (this._selectionCssSelector &&
	        this._selectionCssSelector.url === this._target.url) {
	      return this._selectionCssSelector.selector;
	    }
	    return null;
	  },

	  /**
	   * Can a new HTML element be inserted into the currently selected element?
	   * @return {Boolean}
	   */
	  canAddHTMLChild: function () {
	    let selection = this.selection;

	    // Don't allow to insert an element into these elements. This should only
	    // contain elements where walker.insertAdjacentHTML has no effect.
	    let invalidTagNames = ["html", "iframe"];

	    return selection.isHTMLNode() &&
	           selection.isElementNode() &&
	           !selection.isPseudoElementNode() &&
	           !selection.isAnonymousNode() &&
	           invalidTagNames.indexOf(
	            selection.nodeFront.nodeName.toLowerCase()) === -1;
	  },

	  /**
	   * When a new node is selected.
	   */
	  onNewSelection: function (event, value, reason) {
	    if (reason === "selection-destroy") {
	      return;
	    }

	    // Wait for all the known tools to finish updating and then let the
	    // client know.
	    let selection = this.selection.nodeFront;

	    // Update the state of the add button in the toolbar depending on the
	    // current selection.
	    let btn = this.panelDoc.querySelector("#inspector-element-add-button");
	    if (this.canAddHTMLChild()) {
	      btn.removeAttribute("disabled");
	    } else {
	      btn.setAttribute("disabled", "true");
	    }

	    // On any new selection made by the user, store the unique css selector
	    // of the selected node so it can be restored after reload of the same page
	    if (this.canGetUniqueSelector &&
	        this.selection.isElementNode()) {
	      selection.getUniqueSelector().then(selector => {
	        this.selectionCssSelector = selector;
	      }, this._handleRejectionIfNotDestroyed);
	    }

	    let selfUpdate = this.updating("inspector-panel");
	    executeSoon(() => {
	      try {
	        selfUpdate(selection);
	      } catch (ex) {
	        console.error(ex);
	      }
	    });
	  },

	  /**
	   * Delay the "inspector-updated" notification while a tool
	   * is updating itself.  Returns a function that must be
	   * invoked when the tool is done updating with the node
	   * that the tool is viewing.
	   */
	  updating: function (name) {
	    if (this._updateProgress && this._updateProgress.node != this.selection.nodeFront) {
	      this.cancelUpdate();
	    }

	    if (!this._updateProgress) {
	      // Start an update in progress.
	      let self = this;
	      this._updateProgress = {
	        node: this.selection.nodeFront,
	        outstanding: new Set(),
	        checkDone: function () {
	          if (this !== self._updateProgress) {
	            return;
	          }
	          // Cancel update if there is no `selection` anymore.
	          // It can happen if the inspector panel is already destroyed.
	          if (!self.selection || (this.node !== self.selection.nodeFront)) {
	            self.cancelUpdate();
	            return;
	          }
	          if (this.outstanding.size !== 0) {
	            return;
	          }

	          self._updateProgress = null;
	          self.emit("inspector-updated", name);
	        },
	      };
	    }

	    let progress = this._updateProgress;
	    let done = function () {
	      progress.outstanding.delete(done);
	      progress.checkDone();
	    };
	    progress.outstanding.add(done);
	    return done;
	  },

	  /**
	   * Cancel notification of inspector updates.
	   */
	  cancelUpdate: function () {
	    this._updateProgress = null;
	  },

	  /**
	   * When a new node is selected, before the selection has changed.
	   */
	  onBeforeNewSelection: function (event, node) {
	    if (this.breadcrumbs.indexOf(node) == -1) {
	      // only clear locks if we'd have to update breadcrumbs
	      this.clearPseudoClasses();
	    }
	  },

	  /**
	   * When a node is deleted, select its parent node or the defaultNode if no
	   * parent is found (may happen when deleting an iframe inside which the
	   * node was selected).
	   */
	  onDetached: function (event, parentNode) {
	    this.breadcrumbs.cutAfter(this.breadcrumbs.indexOf(parentNode));
	    this.selection.setNodeFront(parentNode ? parentNode : this._defaultNode, "detached");
	  },

	  /**
	   * Destroy the inspector.
	   */
	  destroy: function () {
	    if (this._panelDestroyer) {
	      return this._panelDestroyer;
	    }

	    if (this.walker) {
	      this.walker.off("new-root", this.onNewRoot);
	      this.pageStyle = null;
	    }

	    this.cancelUpdate();

	    this.target.off("will-navigate", this._onBeforeNavigate);

	    this.target.off("thread-paused", this.updateDebuggerPausedWarning);
	    this.target.off("thread-resumed", this.updateDebuggerPausedWarning);
	    this._toolbox.off("select", this.updateDebuggerPausedWarning);

	    if (this.ruleview) {
	      this.ruleview.destroy();
	    }

	    if (this.computedview) {
	      this.computedview.destroy();
	    }

	    if (this.fontInspector) {
	      this.fontInspector.destroy();
	    }

	    let cssPropertiesDestroyer = this._cssPropertiesLoaded.then(({front}) => {
	      if (front) {
	        front.destroy();
	      }
	    });

	    this.sidebar.off("select", this._setDefaultSidebar);
	    let sidebarDestroyer = this.sidebar.destroy();
	    this.sidebar = null;

	    this.teardownToolbar();
	    this.breadcrumbs.destroy();
	    this.selection.off("new-node-front", this.onNewSelection);
	    this.selection.off("before-new-node-front", this.onBeforeNewSelection);
	    this.selection.off("detached-front", this.onDetached);
	    let markupDestroyer = this._destroyMarkup();
	    this.panelWin.inspector = null;
	    this.target = null;
	    this.panelDoc = null;
	    this.panelWin = null;
	    this.breadcrumbs = null;
	    this._toolbox = null;
	    this.search.destroy();
	    this.search = null;
	    this.searchBox = null;

	    this._panelDestroyer = promise.all([
	      sidebarDestroyer,
	      markupDestroyer,
	      cssPropertiesDestroyer
	    ]);

	    return this._panelDestroyer;
	  },

	  /**
	   * Returns the clipboard content if it is appropriate for pasting
	   * into the current node's outer HTML, otherwise returns null.
	   */
	  _getClipboardContentForPaste: function () {
	    let flavors = clipboardHelper.getCurrentFlavors();
	    if (flavors.indexOf("text") != -1 ||
	        (flavors.indexOf("html") != -1 && flavors.indexOf("image") == -1)) {
	      let content = clipboardHelper.getData();
	      if (content && content.trim().length > 0) {
	        return content;
	      }
	    }
	    return null;
	  },

	  _onContextMenu: function (e) {
	    e.preventDefault();
	    this._openMenu({
	      screenX: e.screenX,
	      screenY: e.screenY,
	      target: e.target,
	    });
	  },

	  _openMenu: function ({ target, screenX = 0, screenY = 0 } = { }) {
	    let markupContainer = this.markup.getContainer(this.selection.nodeFront);

	    this.contextMenuTarget = target;
	    this.nodeMenuTriggerInfo = markupContainer &&
	      markupContainer.editor.getInfoAtNode(target);

	    let isSelectionElement = this.selection.isElementNode() &&
	                             !this.selection.isPseudoElementNode();
	    let isEditableElement = isSelectionElement &&
	                            !this.selection.isAnonymousNode();
	    let isDuplicatableElement = isSelectionElement &&
	                                !this.selection.isAnonymousNode() &&
	                                !this.selection.isRoot();
	    let isScreenshotable = isSelectionElement &&
	                           this.canGetUniqueSelector &&
	                           this.selection.nodeFront.isTreeDisplayed;

	    let menu = new Menu();
	    menu.append(new MenuItem({
	      id: "node-menu-edithtml",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLEdit.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorHTMLEdit.accesskey"),
	      disabled: !isEditableElement || !this.isOuterHTMLEditable,
	      click: () => this.editHTML(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-add",
	      label: INSPECTOR_L10N.getStr("inspectorAddNode.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorAddNode.accesskey"),
	      disabled: !this.canAddHTMLChild(),
	      click: () => this.addNode(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-duplicatenode",
	      label: INSPECTOR_L10N.getStr("inspectorDuplicateNode.label"),
	      hidden: !this._supportsDuplicateNode,
	      disabled: !isDuplicatableElement,
	      click: () => this.duplicateNode(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-delete",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLDelete.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorHTMLDelete.accesskey"),
	      disabled: !isEditableElement,
	      click: () => this.deleteNode(),
	    }));

	    menu.append(new MenuItem({
	      label: INSPECTOR_L10N.getStr("inspectorAttributesSubmenu.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorAttributesSubmenu.accesskey"),
	      submenu: this._getAttributesSubmenu(isEditableElement),
	    }));

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    // Set the pseudo classes
	    for (let name of ["hover", "active", "focus"]) {
	      let menuitem = new MenuItem({
	        id: "node-menu-pseudo-" + name,
	        label: name,
	        type: "checkbox",
	        click: this.togglePseudoClass.bind(this, ":" + name),
	      });

	      if (isSelectionElement) {
	        let checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
	        menuitem.checked = checked;
	      } else {
	        menuitem.disabled = true;
	      }

	      menu.append(menuitem);
	    }

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    let copySubmenu = new Menu();
	    copySubmenu.append(new MenuItem({
	      id: "node-menu-copyinner",
	      label: INSPECTOR_L10N.getStr("inspectorCopyInnerHTML.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorCopyInnerHTML.accesskey"),
	      disabled: !isSelectionElement,
	      click: () => this.copyInnerHTML(),
	    }));
	    copySubmenu.append(new MenuItem({
	      id: "node-menu-copyouter",
	      label: INSPECTOR_L10N.getStr("inspectorCopyOuterHTML.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorCopyOuterHTML.accesskey"),
	      disabled: !isSelectionElement,
	      click: () => this.copyOuterHTML(),
	    }));
	    copySubmenu.append(new MenuItem({
	      id: "node-menu-copyuniqueselector",
	      label: INSPECTOR_L10N.getStr("inspectorCopyCSSSelector.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorCopyCSSSelector.accesskey"),
	      disabled: !isSelectionElement,
	      hidden: !this.canGetUniqueSelector,
	      click: () => this.copyUniqueSelector(),
	    }));
	    copySubmenu.append(new MenuItem({
	      id: "node-menu-copyimagedatauri",
	      label: INSPECTOR_L10N.getStr("inspectorImageDataUri.label"),
	      disabled: !isSelectionElement || !markupContainer ||
	                !markupContainer.isPreviewable(),
	      click: () => this.copyImageDataUri(),
	    }));

	    menu.append(new MenuItem({
	      label: INSPECTOR_L10N.getStr("inspectorCopyHTMLSubmenu.label"),
	      submenu: copySubmenu,
	    }));

	    menu.append(new MenuItem({
	      label: INSPECTOR_L10N.getStr("inspectorPasteHTMLSubmenu.label"),
	      submenu: this._getPasteSubmenu(isEditableElement),
	    }));

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    let isNodeWithChildren = this.selection.isNode() &&
	                             markupContainer.hasChildren;
	    menu.append(new MenuItem({
	      id: "node-menu-expand",
	      label: INSPECTOR_L10N.getStr("inspectorExpandNode.label"),
	      disabled: !isNodeWithChildren,
	      click: () => this.expandNode(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-collapse",
	      label: INSPECTOR_L10N.getStr("inspectorCollapseNode.label"),
	      disabled: !isNodeWithChildren || !markupContainer.expanded,
	      click: () => this.collapseNode(),
	    }));

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    menu.append(new MenuItem({
	      id: "node-menu-scrollnodeintoview",
	      label: INSPECTOR_L10N.getStr("inspectorScrollNodeIntoView.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorScrollNodeIntoView.accesskey"),
	      hidden: !this._supportsScrollIntoView,
	      disabled: !isSelectionElement,
	      click: () => this.scrollNodeIntoView(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-screenshotnode",
	      label: INSPECTOR_L10N.getStr("inspectorScreenshotNode.label"),
	      disabled: !isScreenshotable,
	      click: () => this.screenshotNode(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-useinconsole",
	      label: INSPECTOR_L10N.getStr("inspectorUseInConsole.label"),
	      click: () => this.useInConsole(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-showdomproperties",
	      label: INSPECTOR_L10N.getStr("inspectorShowDOMProperties.label"),
	      click: () => this.showDOMProperties(),
	    }));

	    let nodeLinkMenuItems = this._getNodeLinkMenuItems();
	    if (nodeLinkMenuItems.filter(item => item.visible).length > 0) {
	      menu.append(new MenuItem({
	        id: "node-menu-link-separator",
	        type: "separator",
	      }));
	    }

	    for (let menuitem of nodeLinkMenuItems) {
	      menu.append(menuitem);
	    }

	    menu.popup(screenX, screenY, this._toolbox);
	    return menu;
	  },

	  _getPasteSubmenu: function (isEditableElement) {
	    let isPasteable = isEditableElement && this._getClipboardContentForPaste();
	    let disableAdjacentPaste = !isPasteable ||
	          !this.canPasteInnerOrAdjacentHTML || this.selection.isRoot() ||
	          this.selection.isBodyNode() || this.selection.isHeadNode();
	    let disableFirstLastPaste = !isPasteable ||
	          !this.canPasteInnerOrAdjacentHTML || (this.selection.isHTMLNode() &&
	          this.selection.isRoot());

	    let pasteSubmenu = new Menu();
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pasteinnerhtml",
	      label: INSPECTOR_L10N.getStr("inspectorPasteInnerHTML.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorPasteInnerHTML.accesskey"),
	      disabled: !isPasteable || !this.canPasteInnerOrAdjacentHTML,
	      click: () => this.pasteInnerHTML(),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pasteouterhtml",
	      label: INSPECTOR_L10N.getStr("inspectorPasteOuterHTML.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorPasteOuterHTML.accesskey"),
	      disabled: !isPasteable || !this.isOuterHTMLEditable,
	      click: () => this.pasteOuterHTML(),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pastebefore",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLPasteBefore.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorHTMLPasteBefore.accesskey"),
	      disabled: disableAdjacentPaste,
	      click: () => this.pasteAdjacentHTML("beforeBegin"),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pasteafter",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLPasteAfter.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorHTMLPasteAfter.accesskey"),
	      disabled: disableAdjacentPaste,
	      click: () => this.pasteAdjacentHTML("afterEnd"),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pastefirstchild",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLPasteFirstChild.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorHTMLPasteFirstChild.accesskey"),
	      disabled: disableFirstLastPaste,
	      click: () => this.pasteAdjacentHTML("afterBegin"),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pastelastchild",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLPasteLastChild.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorHTMLPasteLastChild.accesskey"),
	      disabled: disableFirstLastPaste,
	      click: () => this.pasteAdjacentHTML("beforeEnd"),
	    }));

	    return pasteSubmenu;
	  },

	  _getAttributesSubmenu: function (isEditableElement) {
	    let attributesSubmenu = new Menu();
	    let nodeInfo = this.nodeMenuTriggerInfo;
	    let isAttributeClicked = isEditableElement && nodeInfo &&
	                              nodeInfo.type === "attribute";

	    attributesSubmenu.append(new MenuItem({
	      id: "node-menu-add-attribute",
	      label: INSPECTOR_L10N.getStr("inspectorAddAttribute.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorAddAttribute.accesskey"),
	      disabled: !isEditableElement,
	      click: () => this.onAddAttribute(),
	    }));
	    attributesSubmenu.append(new MenuItem({
	      id: "node-menu-edit-attribute",
	      label: INSPECTOR_L10N.getFormatStr("inspectorEditAttribute.label",
	                                        isAttributeClicked ? `"${nodeInfo.name}"` : ""),
	      accesskey: INSPECTOR_L10N.getStr("inspectorEditAttribute.accesskey"),
	      disabled: !isAttributeClicked,
	      click: () => this.onEditAttribute(),
	    }));

	    attributesSubmenu.append(new MenuItem({
	      id: "node-menu-remove-attribute",
	      label: INSPECTOR_L10N.getFormatStr("inspectorRemoveAttribute.label",
	                                        isAttributeClicked ? `"${nodeInfo.name}"` : ""),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorRemoveAttribute.accesskey"),
	      disabled: !isAttributeClicked,
	      click: () => this.onRemoveAttribute(),
	    }));

	    return attributesSubmenu;
	  },

	  /**
	   * Link menu items can be shown or hidden depending on the context and
	   * selected node, and their labels can vary.
	   *
	   * @return {Array} list of visible menu items related to links.
	   */
	  _getNodeLinkMenuItems: function () {
	    let linkFollow = new MenuItem({
	      id: "node-menu-link-follow",
	      visible: false,
	      click: () => this.onFollowLink(),
	    });
	    let linkCopy = new MenuItem({
	      id: "node-menu-link-copy",
	      visible: false,
	      click: () => this.onCopyLink(),
	    });

	    // Get information about the right-clicked node.
	    let popupNode = this.contextMenuTarget;
	    if (!popupNode || !popupNode.classList.contains("link")) {
	      return [linkFollow, linkCopy];
	    }

	    let type = popupNode.dataset.type;
	    if (this._supportsResolveRelativeURL &&
	        (type === "uri" || type === "cssresource" || type === "jsresource")) {
	      // Links can't be opened in new tabs in the browser toolbox.
	      if (type === "uri" && !this.target.chrome) {
	        linkFollow.visible = true;
	        linkFollow.label = INSPECTOR_L10N.getStr(
	          "inspector.menu.openUrlInNewTab.label");
	      } else if (type === "cssresource") {
	        linkFollow.visible = true;
	        linkFollow.label = TOOLBOX_L10N.getStr(
	          "toolbox.viewCssSourceInStyleEditor.label");
	      } else if (type === "jsresource") {
	        linkFollow.visible = true;
	        linkFollow.label = TOOLBOX_L10N.getStr(
	          "toolbox.viewJsSourceInDebugger.label");
	      }

	      linkCopy.visible = true;
	      linkCopy.label = INSPECTOR_L10N.getStr(
	        "inspector.menu.copyUrlToClipboard.label");
	    } else if (type === "idref") {
	      linkFollow.visible = true;
	      linkFollow.label = INSPECTOR_L10N.getFormatStr(
	        "inspector.menu.selectElement.label", popupNode.dataset.link);
	    }

	    return [linkFollow, linkCopy];
	  },

	  _initMarkup: function () {
	    let doc = this.panelDoc;

	    this._markupBox = doc.getElementById("markup-box");

	    // create tool iframe
	    this._markupFrame = doc.createElement("iframe");
	    this._markupFrame.setAttribute("flex", "1");
	    this._markupFrame.setAttribute("tooltip", "aHTMLTooltip");
	    this._markupFrame.addEventListener("contextmenu", this._onContextMenu, true);


	    this._markupBox.setAttribute("collapsed", true);
	    this._markupBox.appendChild(this._markupFrame);
	    this._markupFrame.setAttribute("src", "markup.xhtml");
	    // This is needed to enable tooltips inside the iframe document.
	    this._markupFrame.addEventListener("load", this._onMarkupFrameLoad, true);
	    this._markupFrame.setAttribute("aria-label",
	      INSPECTOR_L10N.getStr("inspector.panelLabel.markupView"));
	  },

	  _onMarkupFrameLoad: function () {
	    this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);

	    this._markupFrame.contentWindow.focus();

	    this._markupBox.removeAttribute("collapsed");

	    this.markup = new MarkupView(this, this._markupFrame, this._toolbox.win);

	    this.emit("markuploaded");
	  },

	  _destroyMarkup: function () {
	    let destroyPromise;

	    if (this._markupFrame) {
	      this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);
	      this._markupFrame.removeEventListener("contextmenu", this._onContextMenu, true);
	    }

	    if (this.markup) {
	      destroyPromise = this.markup.destroy();
	      this.markup = null;
	    } else {
	      destroyPromise = promise.resolve();
	    }

	    if (this._markupFrame) {
	      this._markupFrame.parentNode.removeChild(this._markupFrame);
	      this._markupFrame = null;
	    }

	    this._markupBox = null;

	    return destroyPromise;
	  },

	  /**
	   * When the pane toggle button is clicked or pressed, toggle the pane, change the button
	   * state and tooltip.
	   */
	  onPaneToggleButtonClicked: function (e) {
	    let sidePaneContainer = this.panelDoc.querySelector("#inspector-sidebar-container");
	    let isVisible = !this._sidebarToggle.state.collapsed;

	    // Make sure the sidebar has width and height attributes before collapsing
	    // because ViewHelpers needs it.
	    if (isVisible) {
	      let rect = sidePaneContainer.getBoundingClientRect();
	      if (!sidePaneContainer.hasAttribute("width")) {
	        sidePaneContainer.setAttribute("width", rect.width);
	      }
	      // always refresh the height attribute before collapsing, it could have
	      // been modified by resizing the container.
	      sidePaneContainer.setAttribute("height", rect.height);
	    }

	    let onAnimationDone = () => {
	      if (isVisible) {
	        this._sidebarToggle.setState({collapsed: true});
	      } else {
	        this._sidebarToggle.setState({collapsed: false});
	      }
	    };

	    ViewHelpers.togglePane({
	      visible: !isVisible,
	      animated: true,
	      delayed: true,
	      callback: onAnimationDone
	    }, sidePaneContainer);
	  },

	  onEyeDropperButtonClicked: function () {
	    this.eyeDropperButton.hasAttribute("checked")
	      ? this.hideEyeDropper()
	      : this.showEyeDropper();
	  },

	  startEyeDropperListeners: function () {
	    this.inspector.once("color-pick-canceled", this.onEyeDropperDone);
	    this.inspector.once("color-picked", this.onEyeDropperDone);
	    this.walker.once("new-root", this.onEyeDropperDone);
	  },

	  stopEyeDropperListeners: function () {
	    this.inspector.off("color-pick-canceled", this.onEyeDropperDone);
	    this.inspector.off("color-picked", this.onEyeDropperDone);
	    this.walker.off("new-root", this.onEyeDropperDone);
	  },

	  onEyeDropperDone: function () {
	    this.eyeDropperButton.removeAttribute("checked");
	    this.stopEyeDropperListeners();
	  },

	  /**
	   * Show the eyedropper on the page.
	   * @return {Promise} resolves when the eyedropper is visible.
	   */
	  showEyeDropper: function () {
	    // The eyedropper button doesn't exist, most probably because the actor doesn't
	    // support the pickColorFromPage, or because the page isn't HTML.
	    if (!this.eyeDropperButton) {
	      return null;
	    }

	    this.telemetry.toolOpened("toolbareyedropper");
	    this.eyeDropperButton.setAttribute("checked", "true");
	    this.startEyeDropperListeners();
	    return this.inspector.pickColorFromPage(this.toolbox, {copyOnSelect: true})
	                         .catch(e => console.error(e));
	  },

	  /**
	   * Hide the eyedropper.
	   * @return {Promise} resolves when the eyedropper is hidden.
	   */
	  hideEyeDropper: function () {
	    // The eyedropper button doesn't exist, most probably because the actor doesn't
	    // support the pickColorFromPage, or because the page isn't HTML.
	    if (!this.eyeDropperButton) {
	      return null;
	    }

	    this.eyeDropperButton.removeAttribute("checked");
	    this.stopEyeDropperListeners();
	    return this.inspector.cancelPickColorFromPage()
	                         .catch(e => console.error(e));
	  },

	  /**
	   * Create a new node as the last child of the current selection, expand the
	   * parent and select the new node.
	   */
	  addNode: Task.async(function* () {
	    if (!this.canAddHTMLChild()) {
	      return;
	    }

	    let html = "<div></div>";

	    // Insert the html and expect a childList markup mutation.
	    let onMutations = this.once("markupmutation");
	    let {nodes} = yield this.walker.insertAdjacentHTML(this.selection.nodeFront,
	                                                       "beforeEnd", html);
	    yield onMutations;

	    // Select the new node (this will auto-expand its parent).
	    this.selection.setNodeFront(nodes[0], "node-inserted");
	  }),

	  /**
	   * Toggle a pseudo class.
	   */
	  togglePseudoClass: function (pseudo) {
	    if (this.selection.isElementNode()) {
	      let node = this.selection.nodeFront;
	      if (node.hasPseudoClassLock(pseudo)) {
	        return this.walker.removePseudoClassLock(node, pseudo, {parents: true});
	      }

	      let hierarchical = pseudo == ":hover" || pseudo == ":active";
	      return this.walker.addPseudoClassLock(node, pseudo, {parents: hierarchical});
	    }
	    return promise.resolve();
	  },

	  /**
	   * Show DOM properties
	   */
	  showDOMProperties: function () {
	    this._toolbox.openSplitConsole().then(() => {
	      let panel = this._toolbox.getPanel("webconsole");
	      let jsterm = panel.hud.jsterm;

	      jsterm.execute("inspect($0)");
	      jsterm.focus();
	    });
	  },

	  /**
	   * Use in Console.
	   *
	   * Takes the currently selected node in the inspector and assigns it to a
	   * temp variable on the content window.  Also opens the split console and
	   * autofills it with the temp variable.
	   */
	  useInConsole: function () {
	    this._toolbox.openSplitConsole().then(() => {
	      let panel = this._toolbox.getPanel("webconsole");
	      let jsterm = panel.hud.jsterm;

	      let evalString = `{ let i = 0;
	        while (window.hasOwnProperty("temp" + i) && i < 1000) {
	          i++;
	        }
	        window["temp" + i] = $0;
	        "temp" + i;
	      }`;

	      let options = {
	        selectedNodeActor: this.selection.nodeFront.actorID,
	      };
	      jsterm.requestEvaluation(evalString, options).then((res) => {
	        jsterm.setInputValue(res.result);
	        this.emit("console-var-ready");
	      });
	    });
	  },

	  /**
	   * Clear any pseudo-class locks applied to the current hierarchy.
	   */
	  clearPseudoClasses: function () {
	    if (!this.walker) {
	      return promise.resolve();
	    }
	    return this.walker.clearPseudoClassLocks().catch(this._handleRejectionIfNotDestroyed);
	  },

	  /**
	   * Edit the outerHTML of the selected Node.
	   */
	  editHTML: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }
	    if (this.markup) {
	      this.markup.beginEditingOuterHTML(this.selection.nodeFront);
	    }
	  },

	  /**
	   * Paste the contents of the clipboard into the selected Node's outer HTML.
	   */
	  pasteOuterHTML: function () {
	    let content = this._getClipboardContentForPaste();
	    if (!content) {
	      return promise.reject("No clipboard content for paste");
	    }

	    let node = this.selection.nodeFront;
	    return this.markup.getNodeOuterHTML(node).then(oldContent => {
	      this.markup.updateNodeOuterHTML(node, content, oldContent);
	    });
	  },

	  /**
	   * Paste the contents of the clipboard into the selected Node's inner HTML.
	   */
	  pasteInnerHTML: function () {
	    let content = this._getClipboardContentForPaste();
	    if (!content) {
	      return promise.reject("No clipboard content for paste");
	    }

	    let node = this.selection.nodeFront;
	    return this.markup.getNodeInnerHTML(node).then(oldContent => {
	      this.markup.updateNodeInnerHTML(node, content, oldContent);
	    });
	  },

	  /**
	   * Paste the contents of the clipboard as adjacent HTML to the selected Node.
	   * @param position
	   *        The position as specified for Element.insertAdjacentHTML
	   *        (i.e. "beforeBegin", "afterBegin", "beforeEnd", "afterEnd").
	   */
	  pasteAdjacentHTML: function (position) {
	    let content = this._getClipboardContentForPaste();
	    if (!content) {
	      return promise.reject("No clipboard content for paste");
	    }

	    let node = this.selection.nodeFront;
	    return this.markup.insertAdjacentHTMLToNode(node, position, content);
	  },

	  /**
	   * Copy the innerHTML of the selected Node to the clipboard.
	   */
	  copyInnerHTML: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }
	    this._copyLongString(this.walker.innerHTML(this.selection.nodeFront));
	  },

	  /**
	   * Copy the outerHTML of the selected Node to the clipboard.
	   */
	  copyOuterHTML: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }
	    let node = this.selection.nodeFront;

	    switch (node.nodeType) {
	      case nodeConstants.ELEMENT_NODE :
	        this._copyLongString(this.walker.outerHTML(node));
	        break;
	      case nodeConstants.COMMENT_NODE :
	        this._getLongString(node.getNodeValue()).then(comment => {
	          clipboardHelper.copyString("<!--" + comment + "-->");
	        });
	        break;
	      case nodeConstants.DOCUMENT_TYPE_NODE :
	        clipboardHelper.copyString(node.doctypeString);
	        break;
	    }
	  },

	  /**
	   * Copy the data-uri for the currently selected image in the clipboard.
	   */
	  copyImageDataUri: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    if (container && container.isPreviewable()) {
	      container.copyImageDataUri();
	    }
	  },

	  /**
	   * Copy the content of a longString (via a promise resolving a
	   * LongStringActor) to the clipboard
	   * @param  {Promise} longStringActorPromise
	   *         promise expected to resolve a LongStringActor instance
	   * @return {Promise} promise resolving (with no argument) when the
	   *         string is sent to the clipboard
	   */
	  _copyLongString: function (longStringActorPromise) {
	    return this._getLongString(longStringActorPromise).then(string => {
	      clipboardHelper.copyString(string);
	    }).catch(e => console.error(e));
	  },

	  /**
	   * Retrieve the content of a longString (via a promise resolving a LongStringActor)
	   * @param  {Promise} longStringActorPromise
	   *         promise expected to resolve a LongStringActor instance
	   * @return {Promise} promise resolving with the retrieved string as argument
	   */
	  _getLongString: function (longStringActorPromise) {
	    return longStringActorPromise.then(longStringActor => {
	      return longStringActor.string().then(string => {
	        longStringActor.release().catch(e => console.error(e));
	        return string;
	      });
	    }).catch(e => console.error(e));
	  },

	  /**
	   * Copy a unique selector of the selected Node to the clipboard.
	   */
	  copyUniqueSelector: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }

	    this.selection.nodeFront.getUniqueSelector().then((selector) => {
	      clipboardHelper.copyString(selector);
	    }).then(null, console.error);
	  },

	  /**
	   * Initiate gcli screenshot command on selected node
	   */
	  screenshotNode: function () {
	    CommandUtils.createRequisition(this._target, {
	      environment: CommandUtils.createEnvironment(this, "_target")
	    }).then(requisition => {
	      // Bug 1180314 -  CssSelector might contain white space so need to make sure it is
	      // passed to screenshot as a single parameter.  More work *might* be needed if
	      // CssSelector could contain escaped single- or double-quotes, backslashes, etc.
	      requisition.updateExec("screenshot --selector '" + this.selectionCssSelector + "'");
	    });
	  },

	  /**
	   * Scroll the node into view.
	   */
	  scrollNodeIntoView: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }

	    this.selection.nodeFront.scrollIntoView();
	  },

	  /**
	   * Duplicate the selected node
	   */
	  duplicateNode: function () {
	    let selection = this.selection;
	    if (!selection.isElementNode() ||
	        selection.isRoot() ||
	        selection.isAnonymousNode() ||
	        selection.isPseudoElementNode()) {
	      return;
	    }
	    this.walker.duplicateNode(selection.nodeFront).catch(e => console.error(e));
	  },

	  /**
	   * Delete the selected node.
	   */
	  deleteNode: function () {
	    if (!this.selection.isNode() ||
	         this.selection.isRoot()) {
	      return;
	    }

	    // If the markup panel is active, use the markup panel to delete
	    // the node, making this an undoable action.
	    if (this.markup) {
	      this.markup.deleteNode(this.selection.nodeFront);
	    } else {
	      // remove the node from content
	      this.walker.removeNode(this.selection.nodeFront);
	    }
	  },

	  /**
	   * Add attribute to node.
	   * Used for node context menu and shouldn't be called directly.
	   */
	  onAddAttribute: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    container.addAttribute();
	  },

	  /**
	   * Edit attribute for node.
	   * Used for node context menu and shouldn't be called directly.
	   */
	  onEditAttribute: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    container.editAttribute(this.nodeMenuTriggerInfo.name);
	  },

	  /**
	   * Remove attribute from node.
	   * Used for node context menu and shouldn't be called directly.
	   */
	  onRemoveAttribute: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    container.removeAttribute(this.nodeMenuTriggerInfo.name);
	  },

	  expandNode: function () {
	    this.markup.expandAll(this.selection.nodeFront);
	  },

	  collapseNode: function () {
	    this.markup.collapseNode(this.selection.nodeFront);
	  },

	  /**
	   * This method is here for the benefit of the node-menu-link-follow menu item
	   * in the inspector contextual-menu.
	   */
	  onFollowLink: function () {
	    let type = this.contextMenuTarget.dataset.type;
	    let link = this.contextMenuTarget.dataset.link;

	    this.followAttributeLink(type, link);
	  },

	  /**
	   * Given a type and link found in a node's attribute in the markup-view,
	   * attempt to follow that link (which may result in opening a new tab, the
	   * style editor or debugger).
	   */
	  followAttributeLink: function (type, link) {
	    if (!type || !link) {
	      return;
	    }

	    if (type === "uri" || type === "cssresource" || type === "jsresource") {
	      // Open link in a new tab.
	      // When the inspector menu was setup on click (see _getNodeLinkMenuItems), we
	      // already checked that resolveRelativeURL existed.
	      this.inspector.resolveRelativeURL(
	        link, this.selection.nodeFront).then(url => {
	          if (type === "uri") {
	            let browserWin = this.target.tab.ownerDocument.defaultView;
	            browserWin.openUILinkIn(url, "tab");
	          } else if (type === "cssresource") {
	            return this.toolbox.viewSourceInStyleEditor(url);
	          } else if (type === "jsresource") {
	            return this.toolbox.viewSourceInDebugger(url);
	          }
	          return null;
	        }).catch(e => console.error(e));
	    } else if (type == "idref") {
	      // Select the node in the same document.
	      this.walker.document(this.selection.nodeFront).then(doc => {
	        return this.walker.querySelector(doc, "#" + CSS.escape(link)).then(node => {
	          if (!node) {
	            this.emit("idref-attribute-link-failed");
	            return;
	          }
	          this.selection.setNodeFront(node);
	        });
	      }).catch(e => console.error(e));
	    }
	  },

	  /**
	   * This method is here for the benefit of the node-menu-link-copy menu item
	   * in the inspector contextual-menu.
	   */
	  onCopyLink: function () {
	    let link = this.contextMenuTarget.dataset.link;

	    this.copyAttributeLink(link);
	  },

	  /**
	   * This method is here for the benefit of copying links.
	   */
	  copyAttributeLink: function (link) {
	    // When the inspector menu was setup on click (see _getNodeLinkMenuItems), we
	    // already checked that resolveRelativeURL existed.
	    this.inspector.resolveRelativeURL(link, this.selection.nodeFront).then(url => {
	      clipboardHelper.copyString(url);
	    }, console.error);
	  }
	};


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* globals localStorage, window, document, NodeFilter */

	// Some constants from nsIPrefBranch.idl.
	const PREF_INVALID = 0;
	const PREF_STRING = 32;
	const PREF_INT = 64;
	const PREF_BOOL = 128;
	const NS_PREFBRANCH_PREFCHANGE_TOPIC_ID = "nsPref:changed";

	// We prefix all our local storage items with this.
	const PREFIX = "Services.prefs:";

	/**
	 * Create a new preference branch.  This object conforms largely to
	 * nsIPrefBranch and nsIPrefService, though it only implements the
	 * subset needed by devtools.  A preference branch can hold child
	 * preferences while also holding a preference value itself.
	 *
	 * @param {PrefBranch} parent the parent branch, or null for the root
	 *        branch.
	 * @param {String} name the base name of this branch
	 * @param {String} fullName the fully-qualified name of this branch
	 */
	function PrefBranch(parent, name, fullName) {
	  this._parent = parent;
	  this._name = name;
	  this._fullName = fullName;
	  this._observers = {};
	  this._children = {};

	  // Properties used when this branch has a value as well.
	  this._defaultValue = null;
	  this._hasUserValue = false;
	  this._userValue = null;
	  this._type = PREF_INVALID;
	}

	PrefBranch.prototype = {
	  PREF_INVALID: PREF_INVALID,
	  PREF_STRING: PREF_STRING,
	  PREF_INT: PREF_INT,
	  PREF_BOOL: PREF_BOOL,

	  /** @see nsIPrefBranch.root.  */
	  get root() {
	    return this._fullName;
	  },

	  /** @see nsIPrefBranch.getPrefType.  */
	  getPrefType: function (prefName) {
	    return this._findPref(prefName)._type;
	  },

	  /** @see nsIPrefBranch.getBoolPref.  */
	  getBoolPref: function (prefName) {
	    let thePref = this._findPref(prefName);
	    if (thePref._type !== PREF_BOOL) {
	      throw new Error(`${prefName} does not have bool type`);
	    }
	    return thePref._get();
	  },

	  /** @see nsIPrefBranch.setBoolPref.  */
	  setBoolPref: function (prefName, value) {
	    if (typeof value !== "boolean") {
	      throw new Error("non-bool passed to setBoolPref");
	    }
	    let thePref = this._findOrCreatePref(prefName, value, true, value);
	    if (thePref._type !== PREF_BOOL) {
	      throw new Error(`${prefName} does not have bool type`);
	    }
	    thePref._set(value);
	  },

	  /** @see nsIPrefBranch.getCharPref.  */
	  getCharPref: function (prefName) {
	    let thePref = this._findPref(prefName);
	    if (thePref._type !== PREF_STRING) {
	      throw new Error(`${prefName} does not have string type`);
	    }
	    return thePref._get();
	  },

	  /** @see nsIPrefBranch.setCharPref.  */
	  setCharPref: function (prefName, value) {
	    if (typeof value !== "string") {
	      throw new Error("non-string passed to setCharPref");
	    }
	    let thePref = this._findOrCreatePref(prefName, value, true, value);
	    if (thePref._type !== PREF_STRING) {
	      throw new Error(`${prefName} does not have string type`);
	    }
	    thePref._set(value);
	  },

	  /** @see nsIPrefBranch.getIntPref.  */
	  getIntPref: function (prefName) {
	    let thePref = this._findPref(prefName);
	    if (thePref._type !== PREF_INT) {
	      throw new Error(`${prefName} does not have int type`);
	    }
	    return thePref._get();
	  },

	  /** @see nsIPrefBranch.setIntPref.  */
	  setIntPref: function (prefName, value) {
	    if (typeof value !== "number") {
	      throw new Error("non-number passed to setIntPref");
	    }
	    let thePref = this._findOrCreatePref(prefName, value, true, value);
	    if (thePref._type !== PREF_INT) {
	      throw new Error(`${prefName} does not have int type`);
	    }
	    thePref._set(value);
	  },

	  /** @see nsIPrefBranch.clearUserPref */
	  clearUserPref: function (prefName) {
	    let thePref = this._findPref(prefName);
	    thePref._clearUserValue();
	  },

	  /** @see nsIPrefBranch.prefHasUserValue */
	  prefHasUserValue: function (prefName) {
	    let thePref = this._findPref(prefName);
	    return thePref._hasUserValue;
	  },

	  /** @see nsIPrefBranch.addObserver */
	  addObserver: function (domain, observer, holdWeak) {
	    if (holdWeak) {
	      throw new Error("shim prefs only supports strong observers");
	    }

	    if (!(domain in this._observers)) {
	      this._observers[domain] = [];
	    }
	    this._observers[domain].push(observer);
	  },

	  /** @see nsIPrefBranch.removeObserver */
	  removeObserver: function (domain, observer) {
	    if (!(domain in this._observers)) {
	      return;
	    }
	    let index = this._observers[domain].indexOf(observer);
	    if (index >= 0) {
	      this._observers[domain].splice(index, 1);
	    }
	  },

	  /** @see nsIPrefService.savePrefFile */
	  savePrefFile: function (file) {
	    if (file) {
	      throw new Error("shim prefs only supports null file in savePrefFile");
	    }
	    // Nothing to do - this implementation always writes back.
	  },

	  /** @see nsIPrefService.getBranch */
	  getBranch: function (prefRoot) {
	    if (!prefRoot) {
	      return this;
	    }
	    if (prefRoot.endsWith(".")) {
	      prefRoot = prefRoot.slice(0, -1);
	    }
	    // This is a bit weird since it could erroneously return a pref,
	    // not a pref branch.
	    return this._findPref(prefRoot);
	  },

	  /**
	   * Return this preference's current value.
	   *
	   * @return {Any} The current value of this preference.  This may
	   *         return a string, a number, or a boolean depending on the
	   *         preference's type.
	   */
	  _get: function () {
	    if (this._hasUserValue) {
	      return this._userValue;
	    }
	    return this._defaultValue;
	  },

	  /**
	   * Set the preference's value.  The new value is assumed to be a
	   * user value.  After setting the value, this function emits a
	   * change notification.
	   *
	   * @param {Any} value the new value
	   */
	  _set: function (value) {
	    if (!this._hasUserValue || value !== this._userValue) {
	      this._userValue = value;
	      this._hasUserValue = true;
	      this._saveAndNotify();
	    }
	  },

	  /**
	   * Set the default value for this preference, and emit a
	   * notification if this results in a visible change.
	   *
	   * @param {Any} value the new default value
	   */
	  _setDefault: function (value) {
	    if (this._defaultValue !== value) {
	      this._defaultValue = value;
	      if (!this._hasUserValue) {
	        this._saveAndNotify();
	      }
	    }
	  },

	  /**
	   * If this preference has a user value, clear it.  If a change was
	   * made, emit a change notification.
	   */
	  _clearUserValue: function () {
	    if (this._hasUserValue) {
	      this._userValue = null;
	      this._hasUserValue = false;
	      this._saveAndNotify();
	    }
	  },

	  /**
	   * Helper function to write the preference's value to local storage
	   * and then emit a change notification.
	   */
	  _saveAndNotify: function () {
	    let store = {
	      type: this._type,
	      defaultValue: this._defaultValue,
	      hasUserValue: this._hasUserValue,
	      userValue: this._userValue,
	    };

	    localStorage.setItem(PREFIX + this.fullName, JSON.stringify(store));
	    this._parent._notify(this._name);
	  },

	  /**
	   * Change this preference's value without writing it back to local
	   * storage.  This is used to handle changes to local storage that
	   * were made externally.
	   *
	   * @param {Number} type one of the PREF_* values
	   * @param {Any} userValue the user value to use if the pref does not exist
	   * @param {Any} defaultValue the default value to use if the pref
	   *        does not exist
	   * @param {Boolean} hasUserValue if a new pref is created, whether
	   *        the default value is also a user value
	   * @param {Object} store the new value of the preference.  It should
	   *        be of the form {type, defaultValue, hasUserValue, userValue};
	   *        where |type| is one of the PREF_* type constants; |defaultValue|
	   *        and |userValue| are the default and user values, respectively;
	   *        and |hasUserValue| is a boolean indicating whether the user value
	   *        is valid
	   */
	  _storageUpdated: function (type, userValue, hasUserValue, defaultValue) {
	    this._type = type;
	    this._defaultValue = defaultValue;
	    this._hasUserValue = hasUserValue;
	    this._userValue = userValue;
	    // There's no need to write this back to local storage, since it
	    // came from there; and this avoids infinite event loops.
	    this._parent._notify(this._name);
	  },

	  /**
	   * Helper function to find either a Preference or PrefBranch object
	   * given its name.  If the name is not found, throws an exception.
	   *
	   * @param {String} prefName the fully-qualified preference name
	   * @return {Object} Either a Preference or PrefBranch object
	   */
	  _findPref: function (prefName) {
	    let branchNames = prefName.split(".");
	    let branch = this;

	    for (let branchName of branchNames) {
	      branch = branch._children[branchName];
	      if (!branch) {
	        throw new Error("could not find pref branch " + prefName);
	      }
	    }

	    return branch;
	  },

	  /**
	   * Helper function to notify any observers when a preference has
	   * changed.  This will also notify the parent branch for further
	   * reporting.
	   *
	   * @param {String} relativeName the name of the updated pref,
	   *        relative to this branch
	   */
	  _notify: function (relativeName) {
	    for (let domain in this._observers) {
	      if (relativeName === domain || domain === "" ||
	          (domain.endsWith(".") && relativeName.startsWith(domain))) {
	        // Allow mutation while walking.
	        let localList = this._observers[domain].slice();
	        for (let observer of localList) {
	          try {
	            observer.observe(this, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID,
	                             relativeName);
	          } catch (e) {
	            console.error(e);
	          }
	        }
	      }
	    }

	    if (this._parent) {
	      this._parent._notify(this._name + "." + relativeName);
	    }
	  },

	  /**
	   * Helper function to create a branch given an array of branch names
	   * representing the path of the new branch.
	   *
	   * @param {Array} branchList an array of strings, one per component
	   *        of the branch to be created
	   * @return {PrefBranch} the new branch
	   */
	  _createBranch: function (branchList) {
	    let parent = this;
	    for (let branch of branchList) {
	      if (!parent._children[branch]) {
	        parent._children[branch] = new PrefBranch(parent, branch,
	                                                  parent.root + "." + branch);
	      }
	      parent = parent._children[branch];
	    }
	    return parent;
	  },

	  /**
	   * Create a new preference.  The new preference is assumed to be in
	   * local storage already, and the new value is taken from there.
	   *
	   * @param {String} keyName the full-qualified name of the preference.
	   *        This is also the name of the key in local storage.
	   * @param {Any} userValue the user value to use if the pref does not exist
	   * @param {Any} defaultValue the default value to use if the pref
	   *        does not exist
	   * @param {Boolean} hasUserValue if a new pref is created, whether
	   *        the default value is also a user value
	   */
	  _findOrCreatePref: function (keyName, userValue, hasUserValue, defaultValue) {
	    let branch = this._createBranch(keyName.split("."));

	    if (hasUserValue && typeof (userValue) !== typeof (defaultValue)) {
	      throw new Error("inconsistent values when creating " + keyName);
	    }

	    let type;
	    switch (typeof (defaultValue)) {
	      case "boolean":
	        type = PREF_BOOL;
	        break;
	      case "number":
	        type = PREF_INT;
	        break;
	      case "string":
	        type = PREF_STRING;
	        break;
	      default:
	        throw new Error("unhandled argument type: " + typeof (defaultValue));
	    }

	    if (branch._type === PREF_INVALID) {
	      branch._storageUpdated(type, userValue, hasUserValue, defaultValue);
	    } else if (branch._type !== type) {
	      throw new Error("attempt to change type of pref " + keyName);
	    }

	    return branch;
	  },

	  /**
	   * Helper function that is called when local storage changes.  This
	   * updates the preferences and notifies pref observers as needed.
	   *
	   * @param {StorageEvent} event the event representing the local
	   *        storage change
	   */
	  _onStorageChange: function (event) {
	    if (event.storageArea !== localStorage) {
	      return;
	    }
	    // Ignore delete events.  Not clear what's correct.
	    if (event.key === null || event.newValue === null) {
	      return;
	    }

	    let {type, userValue, hasUserValue, defaultValue} =
	        JSON.parse(event.newValue);
	    if (event.oldValue === null) {
	      this._findOrCreatePref(event.key, userValue, hasUserValue, defaultValue);
	    } else {
	      let thePref = this._findPref(event.key);
	      thePref._storageUpdated(type, userValue, hasUserValue, defaultValue);
	    }
	  },

	  /**
	   * Helper function to initialize the root PrefBranch.
	   */
	  _initializeRoot: function () {
	    if (localStorage.length === 0 && Services._defaultPrefsEnabled) {
	      /* eslint-disable no-eval */
	      let devtools = __webpack_require__(2);
	      eval(devtools);
	      let all = __webpack_require__(3);
	      eval(all);
	      /* eslint-enable no-eval */
	    }

	    // Read the prefs from local storage and create the local
	    // representations.
	    for (let i = 0; i < localStorage.length; ++i) {
	      let keyName = localStorage.key(i);
	      if (keyName.startsWith(PREFIX)) {
	        let {userValue, hasUserValue, defaultValue} =
	            JSON.parse(localStorage.getItem(keyName));
	        this._findOrCreatePref(keyName.slice(PREFIX.length), userValue,
	                               hasUserValue, defaultValue);
	      }
	    }

	    this._onStorageChange = this._onStorageChange.bind(this);
	    window.addEventListener("storage", this._onStorageChange);
	  },
	};

	const Services = {
	  _prefs: null,

	  // For use by tests.  If set to false before Services.prefs is used,
	  // this will disable the reading of the default prefs.
	  _defaultPrefsEnabled: true,

	  /**
	   * An implementation of nsIPrefService that is based on local
	   * storage.  Only the subset of nsIPrefService that is actually used
	   * by devtools is implemented here.  This is lazily instantiated so
	   * that the tests have a chance to disable the loading of default
	   * prefs.
	   */
	  get prefs() {
	    if (!this._prefs) {
	      this._prefs = new PrefBranch(null, "", "");
	      this._prefs._initializeRoot();
	    }
	    return this._prefs;
	  },

	  /**
	   * An implementation of Services.appinfo that holds just the
	   * properties needed by devtools.
	   */
	  appinfo: {
	    get OS() {
	      const os = window.navigator.userAgent;
	      if (os) {
	        if (os.includes("Linux")) {
	          return "Linux";
	        } else if (os.includes("Windows")) {
	          return "WINNT";
	        } else if (os.includes("Mac")) {
	          return "Darwin";
	        }
	      }
	      return "Unknown";
	    },

	    // It's fine for this to be an approximation.
	    get name() {
	      return window.navigator.userAgent;
	    },

	    // It's fine for this to be an approximation.
	    get version() {
	      return window.navigator.appVersion;
	    },

	    // This is only used by telemetry, which is disabled for the
	    // content case.  So, being totally wrong is ok.
	    get is64Bit() {
	      return true;
	    },
	  },

	  /**
	   * A no-op implementation of Services.telemetry.  This supports just
	   * the subset of Services.telemetry that is used by devtools.
	   */
	  telemetry: {
	    getHistogramById: function (name) {
	      return {
	        add: () => {}
	      };
	    },

	    getKeyedHistogramById: function (name) {
	      return {
	        add: () => {}
	      };
	    },
	  },

	  /**
	   * An implementation of Services.focus that holds just the
	   * properties and methods needed by devtools.
	   * @see nsIFocusManager.idl for details.
	   */
	  focus: {
	    // These values match nsIFocusManager in order to make testing a
	    // bit simpler.
	    MOVEFOCUS_FORWARD: 1,
	    MOVEFOCUS_BACKWARD: 2,

	    get focusedElement() {
	      if (!document.hasFocus()) {
	        return null;
	      }
	      return document.activeElement;
	    },

	    moveFocus: function (window, startElement, type, flags) {
	      if (flags !== 0) {
	        throw new Error("shim Services.focus.moveFocus only accepts flags===0");
	      }
	      if (type !== Services.focus.MOVEFOCUS_FORWARD
	          && type !== Services.focus.MOVEFOCUS_BACKWARD) {
	        throw new Error("shim Services.focus.moveFocus only supports " +
	                        " MOVEFOCUS_FORWARD and MOVEFOCUS_BACKWARD");
	      }

	      if (!startElement) {
	        startElement = document.activeElement || document;
	      }

	      let iter = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, {
	        acceptNode: function (node) {
	          let tabIndex = node.getAttribute("tabindex");
	          if (tabIndex === "-1") {
	            return NodeFilter.FILTER_SKIP;
	          }
	          node.focus();
	          if (document.activeElement == node) {
	            return NodeFilter.FILTER_ACCEPT;
	          }
	          return NodeFilter.FILTER_SKIP;
	        }
	      });

	      iter.currentNode = startElement;

	      // Sets the focus via side effect in the filter.
	      if (type === Services.focus.MOVEFOCUS_FORWARD) {
	        iter.nextNode();
	      } else {
	        iter.previousNode();
	      }
	    },
	  },
	};

	/**
	 * Create a new preference.  This is used during startup (see
	 * devtools/client/preferences/devtools.js) to install the
	 * default preferences.
	 *
	 * @param {String} name the name of the preference
	 * @param {Any} value the default value of the preference
	 */
	function pref(name, value) {
	  let thePref = Services.prefs._findOrCreatePref(name, value, true, value);
	  thePref._setDefault(value);
	}

	module.exports = Services;
	// This is exported to silence eslint.
	exports.pref = pref;


/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = "pref(\"devtools.devedition.promo.shown\", false);\npref(\"devtools.devedition.promo.url\", \"https://www.mozilla.org/firefox/developer/?utm_source=firefox-dev-tools&utm_medium=firefox-browser&utm_content=betadoorhanger\");\n  pref(\"devtools.devedition.promo.enabled\", false);\npref(\"devtools.loader.hotreload\", false);\npref(\"devtools.toolbar.enabled\", true);\npref(\"devtools.toolbar.visible\", false);\npref(\"devtools.webide.enabled\", true);\npref(\"devtools.toolbox.footer.height\", 250);\npref(\"devtools.toolbox.sidebar.width\", 500);\npref(\"devtools.toolbox.host\", \"bottom\");\npref(\"devtools.toolbox.previousHost\", \"side\");\npref(\"devtools.toolbox.selectedTool\", \"webconsole\");\npref(\"devtools.toolbox.toolbarSpec\", '[\"splitconsole\", \"paintflashing toggle\",\"scratchpad\",\"resize toggle\",\"screenshot --fullpage\", \"rulers\", \"measure\"]');\npref(\"devtools.toolbox.sideEnabled\", true);\npref(\"devtools.toolbox.zoomValue\", \"1\");\npref(\"devtools.toolbox.splitconsoleEnabled\", false);\npref(\"devtools.toolbox.splitconsoleHeight\", 100);\npref(\"devtools.command-button-pick.enabled\", true);\npref(\"devtools.command-button-frames.enabled\", true);\npref(\"devtools.command-button-splitconsole.enabled\", true);\npref(\"devtools.command-button-paintflashing.enabled\", false);\npref(\"devtools.command-button-scratchpad.enabled\", false);\npref(\"devtools.command-button-responsive.enabled\", true);\npref(\"devtools.command-button-screenshot.enabled\", false);\npref(\"devtools.command-button-rulers.enabled\", false);\npref(\"devtools.command-button-measure.enabled\", false);\npref(\"devtools.command-button-noautohide.enabled\", false);\npref(\"devtools.inspector.enabled\", true);\npref(\"devtools.inspector.activeSidebar\", \"ruleview\");\npref(\"devtools.inspector.remote\", false);\npref(\"devtools.inspector.show_pseudo_elements\", false);\npref(\"devtools.inspector.imagePreviewTooltipSize\", 300);\npref(\"devtools.inspector.showUserAgentStyles\", false);\npref(\"devtools.inspector.showAllAnonymousContent\", false);\npref(\"devtools.inspector.mdnDocsTooltip.enabled\", true);\npref(\"devtools.markup.collapseAttributes\", true);\npref(\"devtools.markup.collapseAttributeLength\", 120);\npref(\"devtools.defaultColorUnit\", \"authored\");\npref(\"devtools.responsiveUI.no-reload-notification\", false);\npref(\"devtools.debugger.enabled\", true);\npref(\"devtools.debugger.chrome-debugging-host\", \"localhost\");\npref(\"devtools.debugger.chrome-debugging-port\", 6080);\npref(\"devtools.debugger.chrome-debugging-websocket\", false);\npref(\"devtools.debugger.remote-host\", \"localhost\");\npref(\"devtools.debugger.remote-timeout\", 20000);\npref(\"devtools.debugger.pause-on-exceptions\", false);\npref(\"devtools.debugger.ignore-caught-exceptions\", true);\npref(\"devtools.debugger.source-maps-enabled\", true);\npref(\"devtools.debugger.pretty-print-enabled\", true);\npref(\"devtools.debugger.auto-pretty-print\", false);\npref(\"devtools.debugger.auto-black-box\", true);\npref(\"devtools.debugger.workers\", false);\npref(\"devtools.debugger.promise\", false);\npref(\"devtools.debugger.new-debugger-frontend\", false);\npref(\"devtools.debugger.ui.panes-workers-and-sources-width\", 200);\npref(\"devtools.debugger.ui.panes-instruments-width\", 300);\npref(\"devtools.debugger.ui.panes-visible-on-startup\", false);\npref(\"devtools.debugger.ui.variables-sorting-enabled\", true);\npref(\"devtools.debugger.ui.variables-only-enum-visible\", false);\npref(\"devtools.debugger.ui.variables-searchbox-visible\", false);\npref(\"devtools.memory.enabled\", true);\npref(\"devtools.memory.custom-census-displays\", \"{}\");\npref(\"devtools.memory.custom-label-displays\", \"{}\");\npref(\"devtools.memory.custom-tree-map-displays\", \"{}\");\npref(\"devtools.memory.max-individuals\", 1000);\npref(\"devtools.memory.max-retaining-paths\", 10);\npref(\"devtools.performance.enabled\", true);\npref(\"devtools.performance.memory.sample-probability\", \"0.05\");\npref(\"devtools.performance.memory.max-log-length\", 125000);\npref(\"devtools.performance.timeline.hidden-markers\",\n  \"[\\\"Composite\\\",\\\"CompositeForwardTransaction\\\"]\");\npref(\"devtools.performance.profiler.buffer-size\", 10000000);\npref(\"devtools.performance.profiler.sample-frequency-khz\", 1);\npref(\"devtools.performance.ui.invert-call-tree\", true);\npref(\"devtools.performance.ui.invert-flame-graph\", false);\npref(\"devtools.performance.ui.flatten-tree-recursion\", true);\npref(\"devtools.performance.ui.show-platform-data\", false);\npref(\"devtools.performance.ui.show-idle-blocks\", true);\npref(\"devtools.performance.ui.enable-memory\", false);\npref(\"devtools.performance.ui.enable-allocations\", false);\npref(\"devtools.performance.ui.enable-framerate\", true);\npref(\"devtools.performance.ui.show-jit-optimizations\", false);\npref(\"devtools.performance.ui.show-triggers-for-gc-types\",\n  \"TOO_MUCH_MALLOC ALLOC_TRIGGER LAST_DITCH EAGER_ALLOC_TRIGGER\");\npref(\"devtools.performance.ui.enable-memory-flame\", false);\npref(\"devtools.performance.ui.experimental\", false);\npref(\"devtools.cache.disabled\", false);\npref(\"devtools.serviceWorkers.testing.enabled\", false);\npref(\"devtools.netmonitor.enabled\", true);\npref(\"devtools.netmonitor.panes-network-details-width\", 550);\npref(\"devtools.netmonitor.panes-network-details-height\", 450);\npref(\"devtools.netmonitor.statistics\", true);\npref(\"devtools.netmonitor.filters\", \"[\\\"all\\\"]\");\npref(\"devtools.netmonitor.har.defaultLogDir\", \"\");\npref(\"devtools.netmonitor.har.defaultFileName\", \"Archive %y-%m-%d %H-%M-%S\");\npref(\"devtools.netmonitor.har.jsonp\", false);\npref(\"devtools.netmonitor.har.jsonpCallback\", \"\");\npref(\"devtools.netmonitor.har.includeResponseBodies\", true);\npref(\"devtools.netmonitor.har.compress\", false);\npref(\"devtools.netmonitor.har.forceExport\", false);\npref(\"devtools.netmonitor.har.pageLoadedTimeout\", 1500);\npref(\"devtools.netmonitor.har.enableAutoExportToFile\", false);\npref(\"devtools.scratchpad.recentFilesMax\", 10);\npref(\"devtools.scratchpad.lineNumbers\", true);\npref(\"devtools.scratchpad.wrapText\", false);\npref(\"devtools.scratchpad.showTrailingSpace\", false);\npref(\"devtools.scratchpad.editorFontSize\", 12);\npref(\"devtools.scratchpad.enableAutocompletion\", true);\npref(\"devtools.storage.enabled\", false);\npref(\"devtools.styleeditor.enabled\", true);\npref(\"devtools.styleeditor.source-maps-enabled\", true);\npref(\"devtools.styleeditor.autocompletion-enabled\", true);\npref(\"devtools.styleeditor.showMediaSidebar\", true);\npref(\"devtools.styleeditor.mediaSidebarWidth\", 238);\npref(\"devtools.styleeditor.navSidebarWidth\", 245);\npref(\"devtools.styleeditor.transitions\", true);\npref(\"devtools.shadereditor.enabled\", false);\npref(\"devtools.canvasdebugger.enabled\", false);\npref(\"devtools.webaudioeditor.enabled\", false);\npref(\"devtools.scratchpad.enabled\", false);\npref(\"devtools.dom.enabled\", false);\npref(\"devtools.webaudioeditor.inspectorWidth\", 300);\npref(\"devtools.theme\", \"light\");\npref(\"devtools.webconsole.filter.network\", true);\npref(\"devtools.webconsole.filter.networkinfo\", false);\npref(\"devtools.webconsole.filter.netwarn\", true);\npref(\"devtools.webconsole.filter.netxhr\", false);\npref(\"devtools.webconsole.filter.csserror\", true);\npref(\"devtools.webconsole.filter.cssparser\", false);\npref(\"devtools.webconsole.filter.csslog\", false);\npref(\"devtools.webconsole.filter.exception\", true);\npref(\"devtools.webconsole.filter.jswarn\", true);\npref(\"devtools.webconsole.filter.jslog\", false);\npref(\"devtools.webconsole.filter.error\", true);\npref(\"devtools.webconsole.filter.warn\", true);\npref(\"devtools.webconsole.filter.info\", true);\npref(\"devtools.webconsole.filter.log\", true);\npref(\"devtools.webconsole.filter.secerror\", true);\npref(\"devtools.webconsole.filter.secwarn\", true);\npref(\"devtools.webconsole.filter.serviceworkers\", true);\npref(\"devtools.webconsole.filter.sharedworkers\", false);\npref(\"devtools.webconsole.filter.windowlessworkers\", false);\npref(\"devtools.webconsole.filter.servererror\", false);\npref(\"devtools.webconsole.filter.serverwarn\", false);\npref(\"devtools.webconsole.filter.serverinfo\", false);\npref(\"devtools.webconsole.filter.serverlog\", false);\npref(\"devtools.browserconsole.filter.network\", true);\npref(\"devtools.browserconsole.filter.networkinfo\", false);\npref(\"devtools.browserconsole.filter.netwarn\", true);\npref(\"devtools.browserconsole.filter.netxhr\", false);\npref(\"devtools.browserconsole.filter.csserror\", true);\npref(\"devtools.browserconsole.filter.cssparser\", false);\npref(\"devtools.browserconsole.filter.csslog\", false);\npref(\"devtools.browserconsole.filter.exception\", true);\npref(\"devtools.browserconsole.filter.jswarn\", true);\npref(\"devtools.browserconsole.filter.jslog\", true);\npref(\"devtools.browserconsole.filter.error\", true);\npref(\"devtools.browserconsole.filter.warn\", true);\npref(\"devtools.browserconsole.filter.info\", true);\npref(\"devtools.browserconsole.filter.log\", true);\npref(\"devtools.browserconsole.filter.secerror\", true);\npref(\"devtools.browserconsole.filter.secwarn\", true);\npref(\"devtools.browserconsole.filter.serviceworkers\", true);\npref(\"devtools.browserconsole.filter.sharedworkers\", true);\npref(\"devtools.browserconsole.filter.windowlessworkers\", true);\npref(\"devtools.browserconsole.filter.servererror\", false);\npref(\"devtools.browserconsole.filter.serverwarn\", false);\npref(\"devtools.browserconsole.filter.serverinfo\", false);\npref(\"devtools.browserconsole.filter.serverlog\", false);\npref(\"devtools.webconsole.inputHistoryCount\", 50);\npref(\"devtools.webconsole.persistlog\", false);\npref(\"devtools.webconsole.timestampMessages\", false);\npref(\"devtools.webconsole.autoMultiline\", true);\npref(\"devtools.webconsole.new-frontend-enabled\", false);\npref(\"devtools.sourcemap.locations.enabled\", false);\npref(\"devtools.hud.loglimit\", 1000);\npref(\"devtools.hud.loglimit.network\", 1000);\npref(\"devtools.hud.loglimit.cssparser\", 1000);\npref(\"devtools.hud.loglimit.exception\", 1000);\npref(\"devtools.hud.loglimit.console\", 1000);\npref(\"devtools.eyedropper.zoom\", 6);\npref(\"devtools.editor.tabsize\", 2);\npref(\"devtools.editor.expandtab\", true);\npref(\"devtools.editor.keymap\", \"default\");\npref(\"devtools.editor.autoclosebrackets\", true);\npref(\"devtools.editor.detectindentation\", true);\npref(\"devtools.editor.enableCodeFolding\", true);\npref(\"devtools.editor.autocomplete\", true);\npref(\"devtools.fontinspector.enabled\", true);\npref(\"devtools.telemetry.tools.opened.version\", \"{}\");\npref(\"devtools.jsonview.enabled\", false);"

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = "pref(\"devtools.errorconsole.deprecation_warnings\", true);\npref(\"devtools.chrome.enabled\", false);\npref(\"devtools.debugger.log\", false);\npref(\"devtools.debugger.log.verbose\", false);\npref(\"devtools.debugger.remote-enabled\", false);\npref(\"devtools.debugger.remote-port\", 6000);\npref(\"devtools.debugger.remote-websocket\", false);\npref(\"devtools.debugger.force-local\", true);\npref(\"devtools.debugger.prompt-connection\", true);\npref(\"devtools.debugger.forbid-certified-apps\", true);\npref(\"devtools.apps.forbidden-permissions\", \"embed-apps,embed-widgets\");\npref(\"devtools.defaultColorUnit\", \"authored\");\npref(\"devtools.dump.emit\", false);\npref(\"devtools.discovery.log\", false);\npref(\"devtools.remote.wifi.scan\", true);\npref(\"devtools.remote.wifi.visible\", true);\npref(\"devtools.remote.tls-handshake-timeout\", 10000);\npref(\"devtools.devices.url\", \"https://code.cdn.mozilla.net/devices/devices.json\");\npref(\"devtools.gcli.hideIntro\", false);\npref(\"devtools.gcli.eagerHelper\", 2);\npref(\"devtools.gcli.jquerySrc\", \"https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.1/jquery.min.js\");\npref(\"devtools.gcli.lodashSrc\", \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.6.1/lodash.min.js\");\npref(\"devtools.gcli.underscoreSrc\", \"https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js\");\npref(\"devtools.gcli.imgurClientID\", '0df414e888d7240');\npref(\"devtools.gcli.imgurUploadURL\", \"https://api.imgur.com/3/image\");\npref(\"devtools.commands.dir\", \"\");\npref(\"devtools.telemetry.supported_performance_marks\", \"contentInteractive,navigationInteractive,navigationLoaded,visuallyLoaded,fullyLoaded,mediaEnumerated,scanEnd\");\npref(\"devtools.migration.warnings\", true);"

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = Promise;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// See bug 1273941 to understand this choice of promise.
	const Promise = __webpack_require__(4);

	/**
	 * Returns a deferred object, with a resolve and reject property.
	 * https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred
	 */
	module.exports = function defer() {
	  let resolve, reject;
	  let promise = new Promise(function () {
	    resolve = arguments[0];
	    reject = arguments[1];
	  });
	  return {
	    resolve: resolve,
	    reject: reject,
	    promise: promise
	  };
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	  // ⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠
	  // After this point the code may not use Cu.import, and should only
	  // require() modules that are "clean-for-content".
	  let EventEmitter = this.EventEmitter = function () {};
	  module.exports = EventEmitter;

	  // See comment in JSM module boilerplate when adding a new dependency.
	  const Services = __webpack_require__(1);
	  const defer = __webpack_require__(5);
	  const { describeNthCaller } = __webpack_require__(7);
	  let loggingEnabled = true;

	  if (true) {
	    loggingEnabled = Services.prefs.getBoolPref("devtools.dump.emit");
	    Services.prefs.addObserver("devtools.dump.emit", {
	      observe: () => {
	        loggingEnabled = Services.prefs.getBoolPref("devtools.dump.emit");
	      }
	    }, false);
	  }

	  /**
	   * Decorate an object with event emitter functionality.
	   *
	   * @param Object objectToDecorate
	   *        Bind all public methods of EventEmitter to
	   *        the objectToDecorate object.
	   */
	  EventEmitter.decorate = function (objectToDecorate) {
	    let emitter = new EventEmitter();
	    objectToDecorate.on = emitter.on.bind(emitter);
	    objectToDecorate.off = emitter.off.bind(emitter);
	    objectToDecorate.once = emitter.once.bind(emitter);
	    objectToDecorate.emit = emitter.emit.bind(emitter);
	  };

	  EventEmitter.prototype = {
	    /**
	     * Connect a listener.
	     *
	     * @param string event
	     *        The event name to which we're connecting.
	     * @param function listener
	     *        Called when the event is fired.
	     */
	    on(event, listener) {
	      if (!this._eventEmitterListeners) {
	        this._eventEmitterListeners = new Map();
	      }
	      if (!this._eventEmitterListeners.has(event)) {
	        this._eventEmitterListeners.set(event, []);
	      }
	      this._eventEmitterListeners.get(event).push(listener);
	    },

	    /**
	     * Listen for the next time an event is fired.
	     *
	     * @param string event
	     *        The event name to which we're connecting.
	     * @param function listener
	     *        (Optional) Called when the event is fired. Will be called at most
	     *        one time.
	     * @return promise
	     *        A promise which is resolved when the event next happens. The
	     *        resolution value of the promise is the first event argument. If
	     *        you need access to second or subsequent event arguments (it's rare
	     *        that this is needed) then use listener
	     */
	    once(event, listener) {
	      let deferred = defer();

	      let handler = (_, first, ...rest) => {
	        this.off(event, handler);
	        if (listener) {
	          listener.apply(null, [event, first, ...rest]);
	        }
	        deferred.resolve(first);
	      };

	      handler._originalListener = listener;
	      this.on(event, handler);

	      return deferred.promise;
	    },

	    /**
	     * Remove a previously-registered event listener.  Works for events
	     * registered with either on or once.
	     *
	     * @param string event
	     *        The event name whose listener we're disconnecting.
	     * @param function listener
	     *        The listener to remove.
	     */
	    off(event, listener) {
	      if (!this._eventEmitterListeners) {
	        return;
	      }
	      let listeners = this._eventEmitterListeners.get(event);
	      if (listeners) {
	        this._eventEmitterListeners.set(event, listeners.filter(l => {
	          return l !== listener && l._originalListener !== listener;
	        }));
	      }
	    },

	    /**
	     * Emit an event.  All arguments to this method will
	     * be sent to listener functions.
	     */
	    emit(event) {
	      this.logEvent(event, arguments);

	      if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(event)) {
	        return;
	      }

	      let originalListeners = this._eventEmitterListeners.get(event);
	      for (let listener of this._eventEmitterListeners.get(event)) {
	        // If the object was destroyed during event emission, stop
	        // emitting.
	        if (!this._eventEmitterListeners) {
	          break;
	        }

	        // If listeners were removed during emission, make sure the
	        // event handler we're going to fire wasn't removed.
	        if (originalListeners === this._eventEmitterListeners.get(event) ||
	          this._eventEmitterListeners.get(event).some(l => l === listener)) {
	          try {
	            listener.apply(null, arguments);
	          } catch (ex) {
	            // Prevent a bad listener from interfering with the others.
	            let msg = ex + ": " + ex.stack;
	            console.error(msg);
	            (console.log)(msg + "\n");
	          }
	        }
	      }
	    },

	    logEvent(event, args) {
	      if (!loggingEnabled) {
	        return;
	      }

	      let description = describeNthCaller(2);

	      let argOut = "(";
	      if (args.length === 1) {
	        argOut += event;
	      }

	      let out = "EMITTING: ";

	      // We need this try / catch to prevent any dead object errors.
	      try {
	        for (let i = 1; i < args.length; i++) {
	          if (i === 1) {
	            argOut = "(" + event + ", ";
	          } else {
	            argOut += ", ";
	          }

	          let arg = args[i];
	          argOut += arg;

	          if (arg && arg.nodeName) {
	            argOut += " (" + arg.nodeName;
	            if (arg.id) {
	              argOut += "#" + arg.id;
	            }
	            if (arg.className) {
	              argOut += "." + arg.className;
	            }
	            argOut += ")";
	          }
	        }
	      } catch (e) {
	        // Object is dead so the toolbox is most likely shutting down,
	        // do nothing.
	      }

	      argOut += ")";
	      out += "emit" + argOut + " from " + description + "\n";

	      (console.log)(out);
	    },
	  };


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// A few wrappers for stack-manipulation.  This version of the module
	// is used in content code.  Note that this particular copy of the
	// file can only be loaded via require(), because Cu.import doesn't
	// exist in the content case.  So, we don't need the code to handle
	// both require and import here.

	"use strict";

	/**
	 * Looks like Cu.callFunctionWithAsyncStack, but just calls the callee.
	 */
	function callFunctionWithAsyncStack(callee, stack, id) {
	  return callee();
	}

	/**
	 * Return a description of the Nth caller, suitable for logging.
	 *
	 * @param {Number} n the caller to describe
	 * @return {String} a description of the nth caller.
	 */
	function describeNthCaller(n) {
	  if (false) {
	    return "";
	  }

	  let stack = new Error().stack.split("\n");
	  // Add one here to skip this function.
	  return stack[n + 1];
	}

	/**
	 * Return a stack object that can be serialized and, when
	 * deserialized, passed to callFunctionWithAsyncStack.
	 */
	function getStack() {
	  // There's no reason for this to do anything fancy, since it's only
	  // used to pass back into callFunctionWithAsyncStack, which we can't
	  // implement.
	  return null;
	}

	exports.callFunctionWithAsyncStack = callFunctionWithAsyncStack;
	exports.describeNthCaller = describeNthCaller;
	exports.getStack = getStack;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* General utilities used throughout devtools. */

	var { Ci, Cu, Cc, components } = __webpack_require__(11);
	var Services = __webpack_require__(1);
	var promise = __webpack_require__(4);
	var defer = __webpack_require__(5);
	var flags = __webpack_require__(12);
	var {getStack, callFunctionWithAsyncStack} = __webpack_require__(7);

	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "FileUtils",
	                         "resource://gre/modules/FileUtils.jsm", true);

	// Re-export the thread-safe utils.
	const ThreadSafeDevToolsUtils = __webpack_require__(13);
	for (let key of Object.keys(ThreadSafeDevToolsUtils)) {
	  exports[key] = ThreadSafeDevToolsUtils[key];
	}

	/**
	 * Waits for the next tick in the event loop to execute a callback.
	 */
	exports.executeSoon = function executeSoon(aFn) {
	  // XXX: Move setImmmediate chrome implementation to loader
	  if (typeof setImmediate !== "undefined") {
	    setImmediate(aFn);
	  } else {
	    let executor;
	    // Only enable async stack reporting when DEBUG_JS_MODULES is set
	    // (customized local builds) to avoid a performance penalty.
	    if (({ DEBUG: true, DEBUG_JS_MODULES: true }).DEBUG_JS_MODULES || flags.testing) {
	      let stack = getStack();
	      executor = () => {
	        callFunctionWithAsyncStack(aFn, stack, "DevToolsUtils.executeSoon");
	      };
	    } else {
	      executor = aFn;
	    }
	    Services.tm.mainThread.dispatch({
	      run: exports.makeInfallible(executor)
	    }, Ci.nsIThread.DISPATCH_NORMAL);
	  }
	};

	/**
	 * Waits for the next tick in the event loop.
	 *
	 * @return Promise
	 *         A promise that is resolved after the next tick in the event loop.
	 */
	exports.waitForTick = function waitForTick() {
	  let deferred = defer();
	  exports.executeSoon(deferred.resolve);
	  return deferred.promise;
	};

	/**
	 * Waits for the specified amount of time to pass.
	 *
	 * @param number aDelay
	 *        The amount of time to wait, in milliseconds.
	 * @return Promise
	 *         A promise that is resolved after the specified amount of time passes.
	 */
	exports.waitForTime = function waitForTime(aDelay) {
	  let deferred = defer();
	  setTimeout(deferred.resolve, aDelay);
	  return deferred.promise;
	};

	/**
	 * Like Array.prototype.forEach, but doesn't cause jankiness when iterating over
	 * very large arrays by yielding to the browser and continuing execution on the
	 * next tick.
	 *
	 * @param Array aArray
	 *        The array being iterated over.
	 * @param Function aFn
	 *        The function called on each item in the array. If a promise is
	 *        returned by this function, iterating over the array will be paused
	 *        until the respective promise is resolved.
	 * @returns Promise
	 *          A promise that is resolved once the whole array has been iterated
	 *          over, and all promises returned by the aFn callback are resolved.
	 */
	exports.yieldingEach = function yieldingEach(aArray, aFn) {
	  const deferred = defer();

	  let i = 0;
	  let len = aArray.length;
	  let outstanding = [deferred.promise];

	  (function loop() {
	    const start = Date.now();

	    while (i < len) {
	      // Don't block the main thread for longer than 16 ms at a time. To
	      // maintain 60fps, you have to render every frame in at least 16ms; we
	      // aren't including time spent in non-JS here, but this is Good
	      // Enough(tm).
	      if (Date.now() - start > 16) {
	        exports.executeSoon(loop);
	        return;
	      }

	      try {
	        outstanding.push(aFn(aArray[i], i++));
	      } catch (e) {
	        deferred.reject(e);
	        return;
	      }
	    }

	    deferred.resolve();
	  }());

	  return promise.all(outstanding);
	};

	/**
	 * Like XPCOMUtils.defineLazyGetter, but with a |this| sensitive getter that
	 * allows the lazy getter to be defined on a prototype and work correctly with
	 * instances.
	 *
	 * @param Object aObject
	 *        The prototype object to define the lazy getter on.
	 * @param String aKey
	 *        The key to define the lazy getter on.
	 * @param Function aCallback
	 *        The callback that will be called to determine the value. Will be
	 *        called with the |this| value of the current instance.
	 */
	exports.defineLazyPrototypeGetter =
	function defineLazyPrototypeGetter(aObject, aKey, aCallback) {
	  Object.defineProperty(aObject, aKey, {
	    configurable: true,
	    get: function () {
	      const value = aCallback.call(this);

	      Object.defineProperty(this, aKey, {
	        configurable: true,
	        writable: true,
	        value: value
	      });

	      return value;
	    }
	  });
	};

	/**
	 * Safely get the property value from a Debugger.Object for a given key. Walks
	 * the prototype chain until the property is found.
	 *
	 * @param Debugger.Object aObject
	 *        The Debugger.Object to get the value from.
	 * @param String aKey
	 *        The key to look for.
	 * @return Any
	 */
	exports.getProperty = function getProperty(aObj, aKey) {
	  let root = aObj;
	  try {
	    do {
	      const desc = aObj.getOwnPropertyDescriptor(aKey);
	      if (desc) {
	        if ("value" in desc) {
	          return desc.value;
	        }
	        // Call the getter if it's safe.
	        return exports.hasSafeGetter(desc) ? desc.get.call(root).return : undefined;
	      }
	      aObj = aObj.proto;
	    } while (aObj);
	  } catch (e) {
	    // If anything goes wrong report the error and return undefined.
	    exports.reportException("getProperty", e);
	  }
	  return undefined;
	};

	/**
	 * Determines if a descriptor has a getter which doesn't call into JavaScript.
	 *
	 * @param Object aDesc
	 *        The descriptor to check for a safe getter.
	 * @return Boolean
	 *         Whether a safe getter was found.
	 */
	exports.hasSafeGetter = function hasSafeGetter(aDesc) {
	  // Scripted functions that are CCWs will not appear scripted until after
	  // unwrapping.
	  try {
	    let fn = aDesc.get.unwrap();
	    return fn && fn.callable && fn.class == "Function" && fn.script === undefined;
	  } catch (e) {
	    // Avoid exception 'Object in compartment marked as invisible to Debugger'
	    return false;
	  }
	};

	/**
	 * Check if it is safe to read properties and execute methods from the given JS
	 * object. Safety is defined as being protected from unintended code execution
	 * from content scripts (or cross-compartment code).
	 *
	 * See bugs 945920 and 946752 for discussion.
	 *
	 * @type Object aObj
	 *       The object to check.
	 * @return Boolean
	 *         True if it is safe to read properties from aObj, or false otherwise.
	 */
	exports.isSafeJSObject = function isSafeJSObject(aObj) {
	  // If we are running on a worker thread, Cu is not available. In this case,
	  // we always return false, just to be on the safe side.
	  if (false) {
	    return false;
	  }

	  if (Cu.getGlobalForObject(aObj) ==
	      Cu.getGlobalForObject(exports.isSafeJSObject)) {
	    return true; // aObj is not a cross-compartment wrapper.
	  }

	  let principal = Cu.getObjectPrincipal(aObj);
	  if (Services.scriptSecurityManager.isSystemPrincipal(principal)) {
	    return true; // allow chrome objects
	  }

	  return Cu.isXrayWrapper(aObj);
	};

	exports.dumpn = function dumpn(str) {
	  if (flags.wantLogging) {
	    (console.log)("DBG-SERVER: " + str + "\n");
	  }
	};

	/**
	 * A verbose logger for low-level tracing.
	 */
	exports.dumpv = function (msg) {
	  if (flags.wantVerbose) {
	    exports.dumpn(msg);
	  }
	};

	/**
	 * Defines a getter on a specified object that will be created upon first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject.
	 * @param aLambda
	 *        A function that returns what the getter should return.  This will
	 *        only ever be called once.
	 */
	exports.defineLazyGetter = function defineLazyGetter(aObject, aName, aLambda) {
	  Object.defineProperty(aObject, aName, {
	    get: function () {
	      delete aObject[aName];
	      return aObject[aName] = aLambda.apply(aObject);
	    },
	    configurable: true,
	    enumerable: true
	  });
	};

	exports.defineLazyGetter(this, "AppConstants", () => {
	  if (false) {
	    return {};
	  }
	  const scope = {};
	  Cu.import("resource://gre/modules/AppConstants.jsm", scope);
	  return scope.AppConstants;
	});

	/**
	 * No operation. The empty function.
	 */
	exports.noop = function () { };

	let assertionFailureCount = 0;

	Object.defineProperty(exports, "assertionFailureCount", {
	  get() {
	    return assertionFailureCount;
	  }
	});

	function reallyAssert(condition, message) {
	  if (!condition) {
	    assertionFailureCount++;
	    const err = new Error("Assertion failure: " + message);
	    exports.reportException("DevToolsUtils.assert", err);
	    throw err;
	  }
	}

	/**
	 * DevToolsUtils.assert(condition, message)
	 *
	 * @param Boolean condition
	 * @param String message
	 *
	 * Assertions are enabled when any of the following are true:
	 *   - This is a DEBUG_JS_MODULES build
	 *   - This is a DEBUG build
	 *   - flags.testing is set to true
	 *
	 * If assertions are enabled, then `condition` is checked and if false-y, the
	 * assertion failure is logged and then an error is thrown.
	 *
	 * If assertions are not enabled, then this function is a no-op.
	 */
	Object.defineProperty(exports, "assert", {
	  get: () => (({ DEBUG: true, DEBUG_JS_MODULES: true }).DEBUG || ({ DEBUG: true, DEBUG_JS_MODULES: true }).DEBUG_JS_MODULES || flags.testing)
	    ? reallyAssert
	    : exports.noop,
	});

	/**
	 * Defines a getter on a specified object for a module.  The module will not
	 * be imported until first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject for the module.
	 * @param aResource
	 *        The URL used to obtain the module.
	 * @param aSymbol
	 *        The name of the symbol exported by the module.
	 *        This parameter is optional and defaults to aName.
	 */
	exports.defineLazyModuleGetter = function defineLazyModuleGetter(aObject, aName,
	                                                                 aResource,
	                                                                 aSymbol)
	{
	  this.defineLazyGetter(aObject, aName, function XPCU_moduleLambda() {
	    var temp = {};
	    Cu.import(aResource, temp);
	    return temp[aSymbol || aName];
	  });
	};

	exports.defineLazyGetter(this, "NetUtil", () => {
	  return Cu.import("resource://gre/modules/NetUtil.jsm", {}).NetUtil;
	});

	exports.defineLazyGetter(this, "OS", () => {
	  return Cu.import("resource://gre/modules/osfile.jsm", {}).OS;
	});

	exports.defineLazyGetter(this, "TextDecoder", () => {
	  return Cu.import("resource://gre/modules/osfile.jsm", {}).TextDecoder;
	});

	exports.defineLazyGetter(this, "NetworkHelper", () => {
	  return __webpack_require__(14);
	});

	/**
	 * Performs a request to load the desired URL and returns a promise.
	 *
	 * @param aURL String
	 *        The URL we will request.
	 * @param aOptions Object
	 *        An object with the following optional properties:
	 *        - loadFromCache: if false, will bypass the cache and
	 *          always load fresh from the network (default: true)
	 *        - policy: the nsIContentPolicy type to apply when fetching the URL
	 *                  (only works when loading from system principal)
	 *        - window: the window to get the loadGroup from
	 *        - charset: the charset to use if the channel doesn't provide one
	 *        - principal: the principal to use, if omitted, the request is loaded
	 *                     with the system principal
	 *        - cacheKey: when loading from cache, use this key to retrieve a cache
	 *                    specific to a given SHEntry. (Allows loading POST
	 *                    requests from cache)
	 * @returns Promise that resolves with an object with the following members on
	 *          success:
	 *           - content: the document at that URL, as a string,
	 *           - contentType: the content type of the document
	 *
	 *          If an error occurs, the promise is rejected with that error.
	 *
	 * XXX: It may be better to use nsITraceableChannel to get to the sources
	 * without relying on caching when we can (not for eval, etc.):
	 * http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/
	 */
	function mainThreadFetch(aURL, aOptions = { loadFromCache: true,
	                                          policy: Ci.nsIContentPolicy.TYPE_OTHER,
	                                          window: null,
	                                          charset: null,
	                                          principal: null,
	                                          cacheKey: null }) {
	  // Create a channel.
	  let url = aURL.split(" -> ").pop();
	  let channel;
	  try {
	    channel = newChannelForURL(url, aOptions);
	  } catch (ex) {
	    return promise.reject(ex);
	  }

	  // Set the channel options.
	  channel.loadFlags = aOptions.loadFromCache
	    ? channel.LOAD_FROM_CACHE
	    : channel.LOAD_BYPASS_CACHE;

	  // When loading from cache, the cacheKey allows us to target a specific
	  // SHEntry and offer ways to restore POST requests from cache.
	  if (aOptions.loadFromCache &&
	      aOptions.cacheKey && channel instanceof Ci.nsICacheInfoChannel) {
	    channel.cacheKey = aOptions.cacheKey;
	  }

	  if (aOptions.window) {
	    // Respect private browsing.
	    channel.loadGroup = aOptions.window.QueryInterface(Ci.nsIInterfaceRequestor)
	                          .getInterface(Ci.nsIWebNavigation)
	                          .QueryInterface(Ci.nsIDocumentLoader)
	                          .loadGroup;
	  }

	  let deferred = defer();
	  let onResponse = (stream, status, request) => {
	    if (!components.isSuccessCode(status)) {
	      deferred.reject(new Error(`Failed to fetch ${url}. Code ${status}.`));
	      return;
	    }

	    try {
	      // We cannot use NetUtil to do the charset conversion as if charset
	      // information is not available and our default guess is wrong the method
	      // might fail and we lose the stream data. This means we can't fall back
	      // to using the locale default encoding (bug 1181345).

	      // Read and decode the data according to the locale default encoding.
	      let available = stream.available();
	      let source = NetUtil.readInputStreamToString(stream, available);
	      stream.close();

	      // If the channel or the caller has correct charset information, the
	      // content will be decoded correctly. If we have to fall back to UTF-8 and
	      // the guess is wrong, the conversion fails and convertToUnicode returns
	      // the input unmodified. Essentially we try to decode the data as UTF-8
	      // and if that fails, we use the locale specific default encoding. This is
	      // the best we can do if the source does not provide charset info.
	      let charset = channel.contentCharset || aOptions.charset || "UTF-8";
	      let unicodeSource = NetworkHelper.convertToUnicode(source, charset);

	      deferred.resolve({
	        content: unicodeSource,
	        contentType: request.contentType
	      });
	    } catch (ex) {
	      let uri = request.originalURI;
	      if (ex.name === "NS_BASE_STREAM_CLOSED" && uri instanceof Ci.nsIFileURL) {
	        // Empty files cause NS_BASE_STREAM_CLOSED exception. Use OS.File to
	        // differentiate between empty files and other errors (bug 1170864).
	        // This can be removed when bug 982654 is fixed.

	        uri.QueryInterface(Ci.nsIFileURL);
	        let result = OS.File.read(uri.file.path).then(bytes => {
	          // Convert the bytearray to a String.
	          let decoder = new TextDecoder();
	          let content = decoder.decode(bytes);

	          // We can't detect the contentType without opening a channel
	          // and that failed already. This is the best we can do here.
	          return {
	            content,
	            contentType: "text/plain"
	          };
	        });

	        deferred.resolve(result);
	      } else {
	        deferred.reject(ex);
	      }
	    }
	  };

	  // Open the channel
	  try {
	    NetUtil.asyncFetch(channel, onResponse);
	  } catch (ex) {
	    return promise.reject(ex);
	  }

	  return deferred.promise;
	}

	/**
	 * Opens a channel for given URL. Tries a bit harder than NetUtil.newChannel.
	 *
	 * @param {String} url - The URL to open a channel for.
	 * @param {Object} options - The options object passed to @method fetch.
	 * @return {nsIChannel} - The newly created channel. Throws on failure.
	 */
	function newChannelForURL(url, { policy, window, principal }) {
	  var securityFlags = Ci.nsILoadInfo.SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL;
	  if (window) {
	    // Respect private browsing.
	    var req = window.QueryInterface(Ci.nsIInterfaceRequestor)
	                    .getInterface(Ci.nsIWebNavigation)
	                    .QueryInterface(Ci.nsIDocumentLoader)
	                    .loadGroup;
	    if (req) {
	      var nc = req.notificationCallbacks;
	      if (nc) {
	        try {
	          var lc = nc.getInterface(Ci.nsILoadContext);
	          if (lc) {
	            if (lc.usePrivateBrowsing) {
	              securityFlags |= Ci.nsILoadInfo.SEC_FORCE_PRIVATE_BROWSING;
	            }
	          }
	        } catch (ex) {}
	      }
	    }
	  }

	  let channelOptions = {
	    contentPolicyType: policy,
	    securityFlags: securityFlags,
	    uri: url
	  };
	  if (principal) {
	    // contentPolicyType is required when loading with a custom principal
	    if (!channelOptions.contentPolicyType) {
	      channelOptions.contentPolicyType = Ci.nsIContentPolicy.TYPE_OTHER;
	    }
	    channelOptions.loadingPrincipal = principal;
	  } else {
	    channelOptions.loadUsingSystemPrincipal = true;
	  }

	  try {
	    return NetUtil.newChannel(channelOptions);
	  } catch (e) {
	    // In the xpcshell tests, the script url is the absolute path of the test
	    // file, which will make a malformed URI error be thrown. Add the file
	    // scheme to see if it helps.
	    channelOptions.uri = "file://" + url;

	    return NetUtil.newChannel(channelOptions);
	  }
	}

	// Fetch is defined differently depending on whether we are on the main thread
	// or a worker thread.
	if (!this.isWorker) {
	  exports.fetch = mainThreadFetch;
	} else {
	  // Services is not available in worker threads, nor is there any other way
	  // to fetch a URL. We need to enlist the help from the main thread here, by
	  // issuing an rpc request, to fetch the URL on our behalf.
	  exports.fetch = function (url, options) {
	    return rpc("fetch", url, options);
	  };
	}

	/**
	 * Open the file at the given path for reading.
	 *
	 * @param {String} filePath
	 *
	 * @returns Promise<nsIInputStream>
	 */
	exports.openFileStream = function (filePath) {
	  return new Promise((resolve, reject) => {
	    const uri = NetUtil.newURI(new FileUtils.File(filePath));
	    NetUtil.asyncFetch(
	      { uri, loadUsingSystemPrincipal: true },
	      (stream, result) => {
	        if (!components.isSuccessCode(result)) {
	          reject(new Error(`Could not open "${filePath}": result = ${result}`));
	          return;
	        }

	        resolve(stream);
	      }
	    );
	  });
	};

	/*
	 * All of the flags have been moved to a different module. Make sure
	 * nobody is accessing them anymore, and don't write new code using
	 * them. We can remove this code after a while.
	 */
	function errorOnFlag(exports, name) {
	  Object.defineProperty(exports, name, {
	    get: () => {
	      const msg = `Cannot get the flag ${name}. ` +
	            `Use the "devtools/shared/flags" module instead`;
	      console.error(msg);
	      throw new Error(msg);
	    },
	    set: () => {
	      const msg = `Cannot set the flag ${name}. ` +
	            `Use the "devtools/shared/flags" module instead`;
	      console.error(msg);
	      throw new Error(msg);
	    }
	  });
	}

	errorOnFlag(exports, "testing");
	errorOnFlag(exports, "wantLogging");
	errorOnFlag(exports, "wantVerbose");

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).setImmediate))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(10).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).setImmediate, __webpack_require__(9).clearImmediate))

/***/ },
/* 10 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	(function () {
	    try {
	        cachedSetTimeout = setTimeout;
	    } catch (e) {
	        cachedSetTimeout = function () {
	            throw new Error('setTimeout is not defined');
	        }
	    }
	    try {
	        cachedClearTimeout = clearTimeout;
	    } catch (e) {
	        cachedClearTimeout = function () {
	            throw new Error('clearTimeout is not defined');
	        }
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 12 */
/***/ function(module, exports) {

	
	/*
	 * Create a writable property by tracking it with a private variable.
	 * We cannot make a normal property writeable on `exports` because
	 * the module system freezes it.
	 */
	function makeWritableFlag(exports, name) {
	  let flag = false;
	  Object.defineProperty(exports, name, {
	    get: function () { return flag; },
	    set: function (state) { flag = state; }
	  });
	}

	makeWritableFlag(exports, "wantLogging");
	makeWritableFlag(exports, "wantVerbose");

	// When the testing flag is set, various behaviors may be altered from
	// production mode, typically to enable easier testing or enhanced
	// debugging.
	makeWritableFlag(exports, "testing");


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * General utilities used throughout devtools that can also be used in
	 * workers.
	 */

	/**
	 * Immutably reduce the given `...objs` into one object. The reduction is
	 * applied from left to right, so `immutableUpdate({ a: 1 }, { a: 2 })` will
	 * result in `{ a: 2 }`. The resulting object is frozen.
	 *
	 * Example usage:
	 *
	 *     const original = { foo: 1, bar: 2, baz: 3 };
	 *     const modified = immutableUpdate(original, { baz: 0, bang: 4 });
	 *
	 *     // We get the new object that we expect...
	 *     assert(modified.baz === 0);
	 *     assert(modified.bang === 4);
	 *
	 *     // However, the original is not modified.
	 *     assert(original.baz === 2);
	 *     assert(original.bang === undefined);
	 *
	 * @param {...Object} ...objs
	 * @returns {Object}
	 */
	exports.immutableUpdate = function (...objs) {
	  return Object.freeze(Object.assign({}, ...objs));
	};

	/**
	 * Utility function for updating an object with the properties of
	 * other objects.
	 *
	 * DEPRECATED: Just use Object.assign() instead!
	 *
	 * @param aTarget Object
	 *        The object being updated.
	 * @param aNewAttrs Object
	 *        The rest params are objects to update aTarget with. You
	 *        can pass as many as you like.
	 */
	exports.update = function update(target, ...args) {
	  for (let attrs of args) {
	    for (let key in attrs) {
	      let desc = Object.getOwnPropertyDescriptor(attrs, key);

	      if (desc) {
	        Object.defineProperty(target, key, desc);
	      }
	    }
	  }
	  return target;
	};

	/**
	 * Utility function for getting the values from an object as an array
	 *
	 * @param object Object
	 *        The object to iterate over
	 */
	exports.values = function values(object) {
	  return Object.keys(object).map(k => object[k]);
	};

	/**
	 * Report that |who| threw an exception, |exception|.
	 */
	exports.reportException = function reportException(who, exception) {
	  const msg = `${who} threw an exception: ${exports.safeErrorString(exception)}`;
	  (console.log)(msg + "\n");

	  if (typeof console !== "undefined" && console && console.error) {
	    console.error(msg);
	  }
	};

	/**
	 * Given a handler function that may throw, return an infallible handler
	 * function that calls the fallible handler, and logs any exceptions it
	 * throws.
	 *
	 * @param handler function
	 *      A handler function, which may throw.
	 * @param aName string
	 *      A name for handler, for use in error messages. If omitted, we use
	 *      handler.name.
	 *
	 * (SpiderMonkey does generate good names for anonymous functions, but we
	 * don't have a way to get at them from JavaScript at the moment.)
	 */
	exports.makeInfallible = function (handler, name = handler.name) {
	  return function (/* arguments */) {
	    try {
	      return handler.apply(this, arguments);
	    } catch (ex) {
	      let who = "Handler function";
	      if (name) {
	        who += " " + name;
	      }
	      exports.reportException(who, ex);
	      return undefined;
	    }
	  };
	};

	/**
	 * Turn the |error| into a string, without fail.
	 *
	 * @param {Error|any} error
	 */
	exports.safeErrorString = function (error) {
	  try {
	    let errorString = error.toString();
	    if (typeof errorString == "string") {
	      // Attempt to attach a stack to |errorString|. If it throws an error, or
	      // isn't a string, don't use it.
	      try {
	        if (error.stack) {
	          let stack = error.stack.toString();
	          if (typeof stack == "string") {
	            errorString += "\nStack: " + stack;
	          }
	        }
	      } catch (ee) { }

	      // Append additional line and column number information to the output,
	      // since it might not be part of the stringified error.
	      if (typeof error.lineNumber == "number" && typeof error.columnNumber == "number") {
	        errorString += "Line: " + error.lineNumber + ", column: " + error.columnNumber;
	      }

	      return errorString;
	    }
	  } catch (ee) { }

	  // We failed to find a good error description, so do the next best thing.
	  return Object.prototype.toString.call(error);
	};

	/**
	 * Interleaves two arrays element by element, returning the combined array, like
	 * a zip. In the case of arrays with different sizes, undefined values will be
	 * interleaved at the end along with the extra values of the larger array.
	 *
	 * @param Array a
	 * @param Array b
	 * @returns Array
	 *          The combined array, in the form [a1, b1, a2, b2, ...]
	 */
	exports.zip = function (a, b) {
	  if (!b) {
	    return a;
	  }
	  if (!a) {
	    return b;
	  }
	  const pairs = [];
	  for (let i = 0, aLength = a.length, bLength = b.length;
	       i < aLength || i < bLength;
	       i++) {
	    pairs.push([a[i], b[i]]);
	  }
	  return pairs;
	};

	/**
	 * Converts an object into an array with 2-element arrays as key/value
	 * pairs of the object. `{ foo: 1, bar: 2}` would become
	 * `[[foo, 1], [bar 2]]` (order not guaranteed).
	 *
	 * @param object obj
	 * @returns array
	 */
	exports.entries = function entries(obj) {
	  return Object.keys(obj).map(k => [k, obj[k]]);
	};

	/*
	 * Takes an array of 2-element arrays as key/values pairs and
	 * constructs an object using them.
	 */
	exports.toObject = function (arr) {
	  const obj = {};
	  for (let [k, v] of arr) {
	    obj[k] = v;
	  }
	  return obj;
	};

	/**
	 * Composes the given functions into a single function, which will
	 * apply the results of each function right-to-left, starting with
	 * applying the given arguments to the right-most function.
	 * `compose(foo, bar, baz)` === `args => foo(bar(baz(args)))`
	 *
	 * @param ...function funcs
	 * @returns function
	 */
	exports.compose = function compose(...funcs) {
	  return (...args) => {
	    const initialValue = funcs[funcs.length - 1](...args);
	    const leftFuncs = funcs.slice(0, -1);
	    return leftFuncs.reduceRight((composed, f) => f(composed),
	                                 initialValue);
	  };
	};

	/**
	 * Return true if `thing` is a generator function, false otherwise.
	 */
	exports.isGenerator = function (fn) {
	  if (typeof fn !== "function") {
	    return false;
	  }
	  let proto = Object.getPrototypeOf(fn);
	  if (!proto) {
	    return false;
	  }
	  let ctor = proto.constructor;
	  if (!ctor) {
	    return false;
	  }
	  return ctor.name == "GeneratorFunction";
	};

	/**
	 * Return true if `thing` is a Promise or then-able, false otherwise.
	 */
	exports.isPromise = function (p) {
	  return p && typeof p.then === "function";
	};

	/**
	 * Return true if `thing` is a SavedFrame, false otherwise.
	 */
	exports.isSavedFrame = function (thing) {
	  return Object.prototype.toString.call(thing) === "[object SavedFrame]";
	};

	/**
	 * Return true iff `thing` is a `Set` object (possibly from another global).
	 */
	exports.isSet = function (thing) {
	  return Object.prototype.toString.call(thing) === "[object Set]";
	};

	/**
	 * Given a list of lists, flatten it. Only flattens one level; does not
	 * recursively flatten all levels.
	 *
	 * @param {Array<Array<Any>>} lists
	 * @return {Array<Any>}
	 */
	exports.flatten = function (lists) {
	  return Array.prototype.concat.apply([], lists);
	};

	/**
	 * Returns a promise that is resolved or rejected when all promises have settled
	 * (resolved or rejected).
	 *
	 * This differs from Promise.all, which will reject immediately after the first
	 * rejection, instead of waiting for the remaining promises to settle.
	 *
	 * @param values
	 *        Iterable of promises that may be pending, resolved, or rejected. When
	 *        when all promises have settled (resolved or rejected), the returned
	 *        promise will be resolved or rejected as well.
	 *
	 * @return A new promise that is fulfilled when all values have settled
	 *         (resolved or rejected). Its resolution value will be an array of all
	 *         resolved values in the given order, or undefined if values is an
	 *         empty array. The reject reason will be forwarded from the first
	 *         promise in the list of given promises to be rejected.
	 */
	exports.settleAll = values => {
	  if (values === null || typeof (values[Symbol.iterator]) != "function") {
	    throw new Error("settleAll() expects an iterable.");
	  }

	  return new Promise((resolve, reject) => {
	    values = Array.isArray(values) ? values : [...values];
	    let countdown = values.length;
	    let resolutionValues = new Array(countdown);
	    let rejectionValue;
	    let rejectionOccurred = false;

	    if (!countdown) {
	      resolve(resolutionValues);
	      return deferred.promise;
	    }

	    function checkForCompletion() {
	      if (--countdown > 0) {
	        return;
	      }
	      if (!rejectionOccurred) {
	        resolve(resolutionValues);
	      } else {
	        reject(rejectionValue);
	      }
	    }

	    for (let i = 0; i < values.length; i++) {
	      let index = i;
	      let value = values[i];
	      let resolver = result => {
	        resolutionValues[index] = result;
	        checkForCompletion();
	      };
	      let rejecter = error => {
	        if (!rejectionOccurred) {
	          rejectionValue = error;
	          rejectionOccurred = true;
	        }
	        checkForCompletion();
	      };

	      if (value && typeof (value.then) == "function") {
	        value.then(resolver, rejecter);
	      } else {
	        // Given value is not a promise, forward it as a resolution value.
	        resolver(value);
	      }
	    }
	  });
	};


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et: */
	/*
	 * Software License Agreement (BSD License)
	 *
	 * Copyright (c) 2007, Parakey Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use of this software in source and binary forms,
	 * with or without modification, are permitted provided that the
	 * following conditions are met:
	 *
	 * * Redistributions of source code must retain the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer.
	 *
	 * * Redistributions in binary form must reproduce the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer in the documentation and/or other
	 *   materials provided with the distribution.
	 *
	 * * Neither the name of Parakey Inc. nor the names of its
	 *   contributors may be used to endorse or promote products
	 *   derived from this software without specific prior
	 *   written permission of Parakey Inc.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
	 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
	 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
	 * OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	/*
	 * Creator:
	 *  Joe Hewitt
	 * Contributors
	 *  John J. Barton (IBM Almaden)
	 *  Jan Odvarko (Mozilla Corp.)
	 *  Max Stepanov (Aptana Inc.)
	 *  Rob Campbell (Mozilla Corp.)
	 *  Hans Hillen (Paciello Group, Mozilla)
	 *  Curtis Bartley (Mozilla Corp.)
	 *  Mike Collins (IBM Almaden)
	 *  Kevin Decker
	 *  Mike Ratcliffe (Comartis AG)
	 *  Hernan Rodríguez Colmeiro
	 *  Austin Andrews
	 *  Christoph Dorn
	 *  Steven Roussey (AppCenter Inc, Network54)
	 *  Mihai Sucan (Mozilla Corp.)
	 */

	"use strict";

	const {components, Cc, Ci} = __webpack_require__(11);
	({ lazyRequireGetter: () => {} }).lazyImporter(this, "NetUtil", "resource://gre/modules/NetUtil.jsm");
	const DevToolsUtils = __webpack_require__(8);
	const Services = __webpack_require__(1);

	// The cache used in the `nsIURL` function.
	const gNSURLStore = new Map();

	/**
	 * Helper object for networking stuff.
	 *
	 * Most of the following functions have been taken from the Firebug source. They
	 * have been modified to match the Firefox coding rules.
	 */
	var NetworkHelper = {
	  /**
	   * Converts text with a given charset to unicode.
	   *
	   * @param string text
	   *        Text to convert.
	   * @param string charset
	   *        Charset to convert the text to.
	   * @returns string
	   *          Converted text.
	   */
	  convertToUnicode: function (text, charset) {
	    let conv = Cc["@mozilla.org/intl/scriptableunicodeconverter"]
	        .createInstance(Ci.nsIScriptableUnicodeConverter);
	    try {
	      conv.charset = charset || "UTF-8";
	      return conv.ConvertToUnicode(text);
	    } catch (ex) {
	      return text;
	    }
	  },

	  /**
	   * Reads all available bytes from stream and converts them to charset.
	   *
	   * @param nsIInputStream stream
	   * @param string charset
	   * @returns string
	   *          UTF-16 encoded string based on the content of stream and charset.
	   */
	  readAndConvertFromStream: function (stream, charset) {
	    let text = null;
	    try {
	      text = NetUtil.readInputStreamToString(stream, stream.available());
	      return this.convertToUnicode(text, charset);
	    } catch (err) {
	      return text;
	    }
	  },

	   /**
	   * Reads the posted text from request.
	   *
	   * @param nsIHttpChannel request
	   * @param string charset
	   *        The content document charset, used when reading the POSTed data.
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from request
	   *          otherwise null.
	   */
	  readPostTextFromRequest: function (request, charset) {
	    if (request instanceof Ci.nsIUploadChannel) {
	      let iStream = request.uploadStream;

	      let isSeekableStream = false;
	      if (iStream instanceof Ci.nsISeekableStream) {
	        isSeekableStream = true;
	      }

	      let prevOffset;
	      if (isSeekableStream) {
	        prevOffset = iStream.tell();
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }

	      // Read data from the stream.
	      let text = this.readAndConvertFromStream(iStream, charset);

	      // Seek locks the file, so seek to the beginning only if necko hasn't
	      // read it yet, since necko doesn't seek to 0 before reading (at lest
	      // not till 459384 is fixed).
	      if (isSeekableStream && prevOffset == 0) {
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }
	      return text;
	    }
	    return null;
	  },

	  /**
	   * Reads the posted text from the page's cache.
	   *
	   * @param nsIDocShell docShell
	   * @param string charset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          docShell otherwise null.
	   */
	  readPostTextFromPage: function (docShell, charset) {
	    let webNav = docShell.QueryInterface(Ci.nsIWebNavigation);
	    return this.readPostTextFromPageViaWebNav(webNav, charset);
	  },

	  /**
	   * Reads the posted text from the page's cache, given an nsIWebNavigation
	   * object.
	   *
	   * @param nsIWebNavigation webNav
	   * @param string charset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          webNav, otherwise null.
	   */
	  readPostTextFromPageViaWebNav: function (webNav, charset) {
	    if (webNav instanceof Ci.nsIWebPageDescriptor) {
	      let descriptor = webNav.currentDescriptor;

	      if (descriptor instanceof Ci.nsISHEntry && descriptor.postData &&
	          descriptor instanceof Ci.nsISeekableStream) {
	        descriptor.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);

	        return this.readAndConvertFromStream(descriptor, charset);
	      }
	    }
	    return null;
	  },

	  /**
	   * Gets the web appId that is associated with request.
	   *
	   * @param nsIHttpChannel request
	   * @returns number|null
	   *          The appId for the given request, if available.
	   */
	  getAppIdForRequest: function (request) {
	    try {
	      return this.getRequestLoadContext(request).appId;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },

	  /**
	   * Gets the topFrameElement that is associated with request. This
	   * works in single-process and multiprocess contexts. It may cross
	   * the content/chrome boundary.
	   *
	   * @param nsIHttpChannel request
	   * @returns nsIDOMElement|null
	   *          The top frame element for the given request.
	   */
	  getTopFrameForRequest: function (request) {
	    try {
	      return this.getRequestLoadContext(request).topFrameElement;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },

	  /**
	   * Gets the nsIDOMWindow that is associated with request.
	   *
	   * @param nsIHttpChannel request
	   * @returns nsIDOMWindow or null
	   */
	  getWindowForRequest: function (request) {
	    try {
	      return this.getRequestLoadContext(request).associatedWindow;
	    } catch (ex) {
	      // TODO: bug 802246 - getWindowForRequest() throws on b2g: there is no
	      // associatedWindow property.
	    }
	    return null;
	  },

	  /**
	   * Gets the nsILoadContext that is associated with request.
	   *
	   * @param nsIHttpChannel request
	   * @returns nsILoadContext or null
	   */
	  getRequestLoadContext: function (request) {
	    try {
	      return request.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) {
	      // Ignore.
	    }

	    try {
	      return request.loadGroup.notificationCallbacks
	        .getInterface(Ci.nsILoadContext);
	    } catch (ex) {
	      // Ignore.
	    }

	    return null;
	  },

	  /**
	   * Determines whether the request has been made for the top level document.
	   *
	   * @param nsIHttpChannel request
	   * @returns Boolean True if the request represents the top level document.
	   */
	  isTopLevelLoad: function (request) {
	    if (request instanceof Ci.nsIChannel) {
	      let loadInfo = request.loadInfo;
	      if (loadInfo && loadInfo.isTopLevelLoad) {
	        return (request.loadFlags & Ci.nsIChannel.LOAD_DOCUMENT_URI);
	      }
	    }

	    return false;
	  },

	  /**
	   * Loads the content of url from the cache.
	   *
	   * @param string url
	   *        URL to load the cached content for.
	   * @param string charset
	   *        Assumed charset of the cached content. Used if there is no charset
	   *        on the channel directly.
	   * @param function callback
	   *        Callback that is called with the loaded cached content if available
	   *        or null if something failed while getting the cached content.
	   */
	  loadFromCache: function (url, charset, callback) {
	    let channel = NetUtil.newChannel({uri: url,
	                                      loadUsingSystemPrincipal: true});

	    // Ensure that we only read from the cache and not the server.
	    channel.loadFlags = Ci.nsIRequest.LOAD_FROM_CACHE |
	      Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
	      Ci.nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;

	    NetUtil.asyncFetch(
	      channel,
	      (inputStream, statusCode, request) => {
	        if (!components.isSuccessCode(statusCode)) {
	          callback(null);
	          return;
	        }

	        // Try to get the encoding from the channel. If there is none, then use
	        // the passed assumed charset.
	        let requestChannel = request.QueryInterface(Ci.nsIChannel);
	        let contentCharset = requestChannel.contentCharset || charset;

	        // Read the content of the stream using contentCharset as encoding.
	        callback(this.readAndConvertFromStream(inputStream, contentCharset));
	      });
	  },

	  /**
	   * Parse a raw Cookie header value.
	   *
	   * @param string header
	   *        The raw Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name and value.
	   */
	  parseCookieHeader: function (header) {
	    let cookies = header.split(";");
	    let result = [];

	    cookies.forEach(function (cookie) {
	      let equal = cookie.indexOf("=");
	      let name = cookie.substr(0, equal);
	      let value = cookie.substr(equal + 1);
	      result.push({name: unescape(name.trim()),
	                   value: unescape(value.trim())});
	    });

	    return result;
	  },

	  /**
	   * Parse a raw Set-Cookie header value.
	   *
	   * @param string header
	   *        The raw Set-Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name, value, secure (boolean), httpOnly
	   *         (boolean), path, domain and expires (ISO date string).
	   */
	  parseSetCookieHeader: function (header) {
	    let rawCookies = header.split(/\r\n|\n|\r/);
	    let cookies = [];

	    rawCookies.forEach(function (cookie) {
	      let equal = cookie.indexOf("=");
	      let name = unescape(cookie.substr(0, equal).trim());
	      let parts = cookie.substr(equal + 1).split(";");
	      let value = unescape(parts.shift().trim());

	      cookie = {name: name, value: value};

	      parts.forEach(function (part) {
	        part = part.trim();
	        if (part.toLowerCase() == "secure") {
	          cookie.secure = true;
	        } else if (part.toLowerCase() == "httponly") {
	          cookie.httpOnly = true;
	        } else if (part.indexOf("=") > -1) {
	          let pair = part.split("=");
	          pair[0] = pair[0].toLowerCase();
	          if (pair[0] == "path" || pair[0] == "domain") {
	            cookie[pair[0]] = pair[1];
	          } else if (pair[0] == "expires") {
	            try {
	              pair[1] = pair[1].replace(/-/g, " ");
	              cookie.expires = new Date(pair[1]).toISOString();
	            } catch (ex) {
	              // Ignore.
	            }
	          }
	        }
	      });

	      cookies.push(cookie);
	    });

	    return cookies;
	  },

	  // This is a list of all the mime category maps jviereck could find in the
	  // firebug code base.
	  mimeCategoryMap: {
	    "text/plain": "txt",
	    "text/html": "html",
	    "text/xml": "xml",
	    "text/xsl": "txt",
	    "text/xul": "txt",
	    "text/css": "css",
	    "text/sgml": "txt",
	    "text/rtf": "txt",
	    "text/x-setext": "txt",
	    "text/richtext": "txt",
	    "text/javascript": "js",
	    "text/jscript": "txt",
	    "text/tab-separated-values": "txt",
	    "text/rdf": "txt",
	    "text/xif": "txt",
	    "text/ecmascript": "js",
	    "text/vnd.curl": "txt",
	    "text/x-json": "json",
	    "text/x-js": "txt",
	    "text/js": "txt",
	    "text/vbscript": "txt",
	    "view-source": "txt",
	    "view-fragment": "txt",
	    "application/xml": "xml",
	    "application/xhtml+xml": "xml",
	    "application/atom+xml": "xml",
	    "application/rss+xml": "xml",
	    "application/vnd.mozilla.maybe.feed": "xml",
	    "application/vnd.mozilla.xul+xml": "xml",
	    "application/javascript": "js",
	    "application/x-javascript": "js",
	    "application/x-httpd-php": "txt",
	    "application/rdf+xml": "xml",
	    "application/ecmascript": "js",
	    "application/http-index-format": "txt",
	    "application/json": "json",
	    "application/x-js": "txt",
	    "application/x-mpegurl": "txt",
	    "application/vnd.apple.mpegurl": "txt",
	    "multipart/mixed": "txt",
	    "multipart/x-mixed-replace": "txt",
	    "image/svg+xml": "svg",
	    "application/octet-stream": "bin",
	    "image/jpeg": "image",
	    "image/jpg": "image",
	    "image/gif": "image",
	    "image/png": "image",
	    "image/bmp": "image",
	    "application/x-shockwave-flash": "flash",
	    "video/x-flv": "flash",
	    "audio/mpeg3": "media",
	    "audio/x-mpeg-3": "media",
	    "video/mpeg": "media",
	    "video/x-mpeg": "media",
	    "video/vnd.mpeg.dash.mpd": "xml",
	    "audio/ogg": "media",
	    "application/ogg": "media",
	    "application/x-ogg": "media",
	    "application/x-midi": "media",
	    "audio/midi": "media",
	    "audio/x-mid": "media",
	    "audio/x-midi": "media",
	    "music/crescendo": "media",
	    "audio/wav": "media",
	    "audio/x-wav": "media",
	    "text/json": "json",
	    "application/x-json": "json",
	    "application/json-rpc": "json",
	    "application/x-web-app-manifest+json": "json",
	    "application/manifest+json": "json"
	  },

	  /**
	   * Check if the given MIME type is a text-only MIME type.
	   *
	   * @param string mimeType
	   * @return boolean
	   */
	  isTextMimeType: function (mimeType) {
	    if (mimeType.indexOf("text/") == 0) {
	      return true;
	    }

	    // XML and JSON often come with custom MIME types, so in addition to the
	    // standard "application/xml" and "application/json", we also look for
	    // variants like "application/x-bigcorp+xml". For JSON we allow "+json" and
	    // "-json" as suffixes.
	    if (/^application\/\w+(?:[\.-]\w+)*(?:\+xml|[-+]json)$/.test(mimeType)) {
	      return true;
	    }

	    let category = this.mimeCategoryMap[mimeType] || null;
	    switch (category) {
	      case "txt":
	      case "js":
	      case "json":
	      case "css":
	      case "html":
	      case "svg":
	      case "xml":
	        return true;

	      default:
	        return false;
	    }
	  },

	  /**
	   * Takes a securityInfo object of nsIRequest, the nsIRequest itself and
	   * extracts security information from them.
	   *
	   * @param object securityInfo
	   *        The securityInfo object of a request. If null channel is assumed
	   *        to be insecure.
	   * @param object httpActivity
	   *        The httpActivity object for the request with at least members
	   *        { private, hostname }.
	   *
	   * @return object
	   *         Returns an object containing following members:
	   *          - state: The security of the connection used to fetch this
	   *                   request. Has one of following string values:
	   *                    * "insecure": the connection was not secure (only http)
	   *                    * "weak": the connection has minor security issues
	   *                    * "broken": secure connection failed (e.g. expired cert)
	   *                    * "secure": the connection was properly secured.
	   *          If state == broken:
	   *            - errorMessage: full error message from
	   *                            nsITransportSecurityInfo.
	   *          If state == secure:
	   *            - protocolVersion: one of TLSv1, TLSv1.1, TLSv1.2, TLSv1.3.
	   *            - cipherSuite: the cipher suite used in this connection.
	   *            - cert: information about certificate used in this connection.
	   *                    See parseCertificateInfo for the contents.
	   *            - hsts: true if host uses Strict Transport Security,
	   *                    false otherwise
	   *            - hpkp: true if host uses Public Key Pinning, false otherwise
	   *          If state == weak: Same as state == secure and
	   *            - weaknessReasons: list of reasons that cause the request to be
	   *                               considered weak. See getReasonsForWeakness.
	   */
	  parseSecurityInfo: function (securityInfo, httpActivity) {
	    const info = {
	      state: "insecure",
	    };

	    // The request did not contain any security info.
	    if (!securityInfo) {
	      return info;
	    }

	    /**
	     * Different scenarios to consider here and how they are handled:
	     * - request is HTTP, the connection is not secure
	     *   => securityInfo is null
	     *      => state === "insecure"
	     *
	     * - request is HTTPS, the connection is secure
	     *   => .securityState has STATE_IS_SECURE flag
	     *      => state === "secure"
	     *
	     * - request is HTTPS, the connection has security issues
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is an NSS error code.
	     *      => state === "broken"
	     *
	     * - request is HTTPS, the connection was terminated before the security
	     *   could be validated
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is NOT an NSS error code.
	     *   => .errorMessage is not available.
	     *      => state === "insecure"
	     *
	     * - request is HTTPS but it uses a weak cipher or old protocol, see
	     *   http://hg.mozilla.org/mozilla-central/annotate/def6ed9d1c1a/
	     *   security/manager/ssl/nsNSSCallbacks.cpp#l1233
	     * - request is mixed content (which makes no sense whatsoever)
	     *   => .securityState has STATE_IS_BROKEN flag
	     *   => .errorCode is NOT an NSS error code
	     *   => .errorMessage is not available
	     *      => state === "weak"
	     */

	    securityInfo.QueryInterface(Ci.nsITransportSecurityInfo);
	    securityInfo.QueryInterface(Ci.nsISSLStatusProvider);

	    const wpl = Ci.nsIWebProgressListener;
	    const NSSErrorsService = Cc["@mozilla.org/nss_errors_service;1"]
	                               .getService(Ci.nsINSSErrorsService);
	    const SSLStatus = securityInfo.SSLStatus;
	    if (!NSSErrorsService.isNSSErrorCode(securityInfo.errorCode)) {
	      const state = securityInfo.securityState;

	      let uri = null;
	      if (httpActivity.channel && httpActivity.channel.URI) {
	        uri = httpActivity.channel.URI;
	      }
	      if (uri && !uri.schemeIs("https") && !uri.schemeIs("wss")) {
	        // it is not enough to look at the transport security info -
	        // schemes other than https and wss are subject to
	        // downgrade/etc at the scheme level and should always be
	        // considered insecure
	        info.state = "insecure";
	      } else if (state & wpl.STATE_IS_SECURE) {
	        // The connection is secure if the scheme is sufficient
	        info.state = "secure";
	      } else if (state & wpl.STATE_IS_BROKEN) {
	        // The connection is not secure, there was no error but there's some
	        // minor security issues.
	        info.state = "weak";
	        info.weaknessReasons = this.getReasonsForWeakness(state);
	      } else if (state & wpl.STATE_IS_INSECURE) {
	        // This was most likely an https request that was aborted before
	        // validation. Return info as info.state = insecure.
	        return info;
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo",
	          "Security state " + state + " has no known STATE_IS_* flags.");
	        return info;
	      }

	      // Cipher suite.
	      info.cipherSuite = SSLStatus.cipherName;

	      // Protocol version.
	      info.protocolVersion =
	        this.formatSecurityProtocol(SSLStatus.protocolVersion);

	      // Certificate.
	      info.cert = this.parseCertificateInfo(SSLStatus.serverCert);

	      // HSTS and HPKP if available.
	      if (httpActivity.hostname) {
	        const sss = Cc["@mozilla.org/ssservice;1"]
	                      .getService(Ci.nsISiteSecurityService);

	        // SiteSecurityService uses different storage if the channel is
	        // private. Thus we must give isSecureHost correct flags or we
	        // might get incorrect results.
	        let flags = (httpActivity.private) ?
	                      Ci.nsISocketProvider.NO_PERMANENT_STORAGE : 0;

	        let host = httpActivity.hostname;

	        info.hsts = sss.isSecureHost(sss.HEADER_HSTS, host, flags);
	        info.hpkp = sss.isSecureHost(sss.HEADER_HPKP, host, flags);
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo",
	          "Could not get HSTS/HPKP status as hostname is not available.");
	        info.hsts = false;
	        info.hpkp = false;
	      }
	    } else {
	      // The connection failed.
	      info.state = "broken";
	      info.errorMessage = securityInfo.errorMessage;
	    }

	    return info;
	  },

	  /**
	   * Takes an nsIX509Cert and returns an object with certificate information.
	   *
	   * @param nsIX509Cert cert
	   *        The certificate to extract the information from.
	   * @return object
	   *         An object with following format:
	   *           {
	   *             subject: { commonName, organization, organizationalUnit },
	   *             issuer: { commonName, organization, organizationUnit },
	   *             validity: { start, end },
	   *             fingerprint: { sha1, sha256 }
	   *           }
	   */
	  parseCertificateInfo: function (cert) {
	    let info = {};
	    if (cert) {
	      info.subject = {
	        commonName: cert.commonName,
	        organization: cert.organization,
	        organizationalUnit: cert.organizationalUnit,
	      };

	      info.issuer = {
	        commonName: cert.issuerCommonName,
	        organization: cert.issuerOrganization,
	        organizationUnit: cert.issuerOrganizationUnit,
	      };

	      info.validity = {
	        start: cert.validity.notBeforeLocalDay,
	        end: cert.validity.notAfterLocalDay,
	      };

	      info.fingerprint = {
	        sha1: cert.sha1Fingerprint,
	        sha256: cert.sha256Fingerprint,
	      };
	    } else {
	      DevToolsUtils.reportException("NetworkHelper.parseCertificateInfo",
	        "Secure connection established without certificate.");
	    }

	    return info;
	  },

	  /**
	   * Takes protocolVersion of SSLStatus object and returns human readable
	   * description.
	   *
	   * @param Number version
	   *        One of nsISSLStatus version constants.
	   * @return string
	   *         One of TLSv1, TLSv1.1, TLSv1.2, TLSv1.3 if @param version
	   *         is valid, Unknown otherwise.
	   */
	  formatSecurityProtocol: function (version) {
	    switch (version) {
	      case Ci.nsISSLStatus.TLS_VERSION_1:
	        return "TLSv1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_1:
	        return "TLSv1.1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_2:
	        return "TLSv1.2";
	      case Ci.nsISSLStatus.TLS_VERSION_1_3:
	        return "TLSv1.3";
	      default:
	        DevToolsUtils.reportException("NetworkHelper.formatSecurityProtocol",
	          "protocolVersion " + version + " is unknown.");
	        return "Unknown";
	    }
	  },

	  /**
	   * Takes the securityState bitfield and returns reasons for weak connection
	   * as an array of strings.
	   *
	   * @param Number state
	   *        nsITransportSecurityInfo.securityState.
	   *
	   * @return Array[String]
	   *         List of weakness reasons. A subset of { cipher } where
	   *         * cipher: The cipher suite is consireded to be weak (RC4).
	   */
	  getReasonsForWeakness: function (state) {
	    const wpl = Ci.nsIWebProgressListener;

	    // If there's non-fatal security issues the request has STATE_IS_BROKEN
	    // flag set. See http://hg.mozilla.org/mozilla-central/file/44344099d119
	    // /security/manager/ssl/nsNSSCallbacks.cpp#l1233
	    let reasons = [];

	    if (state & wpl.STATE_IS_BROKEN) {
	      let isCipher = state & wpl.STATE_USES_WEAK_CRYPTO;

	      if (isCipher) {
	        reasons.push("cipher");
	      }

	      if (!isCipher) {
	        DevToolsUtils.reportException("NetworkHelper.getReasonsForWeakness",
	          "STATE_IS_BROKEN without a known reason. Full state was: " + state);
	      }
	    }

	    return reasons;
	  },

	  /**
	   * Parse a url's query string into its components
	   *
	   * @param string queryString
	   *        The query part of a url
	   * @return array
	   *         Array of query params {name, value}
	   */
	  parseQueryString: function (queryString) {
	    // Make sure there's at least one param available.
	    // Be careful here, params don't necessarily need to have values, so
	    // no need to verify the existence of a "=".
	    if (!queryString) {
	      return null;
	    }

	    // Turn the params string into an array containing { name: value } tuples.
	    let paramsArray = queryString.replace(/^[?&]/, "").split("&").map(e => {
	      let param = e.split("=");
	      return {
	        name: param[0] ?
	          NetworkHelper.convertToUnicode(unescape(param[0])) : "",
	        value: param[1] ?
	          NetworkHelper.convertToUnicode(unescape(param[1])) : ""
	      };
	    });

	    return paramsArray;
	  },

	  /**
	   * Helper for getting an nsIURL instance out of a string.
	   */
	  nsIURL: function (url, store = gNSURLStore) {
	    if (store.has(url)) {
	      return store.get(url);
	    }

	    let uri = Services.io.newURI(url, null, null).QueryInterface(Ci.nsIURL);
	    store.set(url, uri);
	    return uri;
	  }
	};

	for (let prop of Object.getOwnPropertyNames(NetworkHelper)) {
	  exports[prop] = NetworkHelper[prop];
	}


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);
	const EventEmitter = __webpack_require__(6);
	const isOSX = Services.appinfo.OS === "Darwin";
	const {KeyCodes} = __webpack_require__(16);

	// List of electron keys mapped to DOM API (DOM_VK_*) key code
	const ElectronKeysMapping = {
	  "F1": "DOM_VK_F1",
	  "F2": "DOM_VK_F2",
	  "F3": "DOM_VK_F3",
	  "F4": "DOM_VK_F4",
	  "F5": "DOM_VK_F5",
	  "F6": "DOM_VK_F6",
	  "F7": "DOM_VK_F7",
	  "F8": "DOM_VK_F8",
	  "F9": "DOM_VK_F9",
	  "F10": "DOM_VK_F10",
	  "F11": "DOM_VK_F11",
	  "F12": "DOM_VK_F12",
	  "F13": "DOM_VK_F13",
	  "F14": "DOM_VK_F14",
	  "F15": "DOM_VK_F15",
	  "F16": "DOM_VK_F16",
	  "F17": "DOM_VK_F17",
	  "F18": "DOM_VK_F18",
	  "F19": "DOM_VK_F19",
	  "F20": "DOM_VK_F20",
	  "F21": "DOM_VK_F21",
	  "F22": "DOM_VK_F22",
	  "F23": "DOM_VK_F23",
	  "F24": "DOM_VK_F24",
	  "Space": "DOM_VK_SPACE",
	  "Backspace": "DOM_VK_BACK_SPACE",
	  "Delete": "DOM_VK_DELETE",
	  "Insert": "DOM_VK_INSERT",
	  "Return": "DOM_VK_RETURN",
	  "Enter": "DOM_VK_RETURN",
	  "Up": "DOM_VK_UP",
	  "Down": "DOM_VK_DOWN",
	  "Left": "DOM_VK_LEFT",
	  "Right": "DOM_VK_RIGHT",
	  "Home": "DOM_VK_HOME",
	  "End": "DOM_VK_END",
	  "PageUp": "DOM_VK_PAGE_UP",
	  "PageDown": "DOM_VK_PAGE_DOWN",
	  "Escape": "DOM_VK_ESCAPE",
	  "Esc": "DOM_VK_ESCAPE",
	  "Tab": "DOM_VK_TAB",
	  "VolumeUp": "DOM_VK_VOLUME_UP",
	  "VolumeDown": "DOM_VK_VOLUME_DOWN",
	  "VolumeMute": "DOM_VK_VOLUME_MUTE",
	  "PrintScreen": "DOM_VK_PRINTSCREEN",
	};

	/**
	 * Helper to listen for keyboard events decribed in .properties file.
	 *
	 * let shortcuts = new KeyShortcuts({
	 *   window
	 * });
	 * shortcuts.on("Ctrl+F", event => {
	 *   // `event` is the KeyboardEvent which relates to the key shortcuts
	 * });
	 *
	 * @param DOMWindow window
	 *        The window object of the document to listen events from.
	 * @param DOMElement target
	 *        Optional DOM Element on which we should listen events from.
	 *        If omitted, we listen for all events fired on `window`.
	 */
	function KeyShortcuts({ window, target }) {
	  this.window = window;
	  this.target = target || window;
	  this.keys = new Map();
	  this.eventEmitter = new EventEmitter();
	  this.target.addEventListener("keydown", this);
	}

	/*
	 * Parse an electron-like key string and return a normalized object which
	 * allow efficient match on DOM key event. The normalized object matches DOM
	 * API.
	 *
	 * @param DOMWindow window
	 *        Any DOM Window object, just to fetch its `KeyboardEvent` object
	 * @param String str
	 *        The shortcut string to parse, following this document:
	 *        https://github.com/electron/electron/blob/master/docs/api/accelerator.md
	 */
	KeyShortcuts.parseElectronKey = function (window, str) {
	  let modifiers = str.split("+");
	  let key = modifiers.pop();

	  let shortcut = {
	    ctrl: false,
	    meta: false,
	    alt: false,
	    shift: false,
	    // Set for character keys
	    key: undefined,
	    // Set for non-character keys
	    keyCode: undefined,
	  };
	  for (let mod of modifiers) {
	    if (mod === "Alt") {
	      shortcut.alt = true;
	    } else if (["Command", "Cmd"].includes(mod)) {
	      shortcut.meta = true;
	    } else if (["CommandOrControl", "CmdOrCtrl"].includes(mod)) {
	      if (isOSX) {
	        shortcut.meta = true;
	      } else {
	        shortcut.ctrl = true;
	      }
	    } else if (["Control", "Ctrl"].includes(mod)) {
	      shortcut.ctrl = true;
	    } else if (mod === "Shift") {
	      shortcut.shift = true;
	    } else {
	      console.error("Unsupported modifier:", mod, "from key:", str);
	      return null;
	    }
	  }

	  // Plus is a special case. It's a character key and shouldn't be matched
	  // against a keycode as it is only accessible via Shift/Capslock
	  if (key === "Plus") {
	    key = "+";
	  }

	  if (typeof key === "string" && key.length === 1) {
	    // Match any single character
	    shortcut.key = key.toLowerCase();
	  } else if (key in ElectronKeysMapping) {
	    // Maps the others manually to DOM API DOM_VK_*
	    key = ElectronKeysMapping[key];
	    shortcut.keyCode = KeyCodes[key];
	    // Used only to stringify the shortcut
	    shortcut.keyCodeString = key;
	    shortcut.key = key;
	  } else {
	    console.error("Unsupported key:", key);
	    return null;
	  }

	  return shortcut;
	};

	KeyShortcuts.stringify = function (shortcut) {
	  let list = [];
	  if (shortcut.alt) {
	    list.push("Alt");
	  }
	  if (shortcut.ctrl) {
	    list.push("Ctrl");
	  }
	  if (shortcut.meta) {
	    list.push("Cmd");
	  }
	  if (shortcut.shift) {
	    list.push("Shift");
	  }
	  let key;
	  if (shortcut.key) {
	    key = shortcut.key.toUpperCase();
	  } else {
	    key = shortcut.keyCodeString;
	  }
	  list.push(key);
	  return list.join("+");
	};

	KeyShortcuts.prototype = {
	  destroy() {
	    this.target.removeEventListener("keydown", this);
	    this.keys.clear();
	  },

	  doesEventMatchShortcut(event, shortcut) {
	    if (shortcut.meta != event.metaKey) {
	      return false;
	    }
	    if (shortcut.ctrl != event.ctrlKey) {
	      return false;
	    }
	    if (shortcut.alt != event.altKey) {
	      return false;
	    }
	    if (shortcut.shift != event.shiftKey) {
	      // Shift is a special modifier, it may implicitely be required if the expected key
	      // is a special character accessible via shift.
	      let isAlphabetical = event.key && event.key.match(/[a-zA-Z]/);
	      // OSX: distinguish cmd+[key] from cmd+shift+[key] shortcuts (Bug 1300458)
	      let cmdShortcut = shortcut.meta && !shortcut.alt && !shortcut.ctrl;
	      if (isAlphabetical || cmdShortcut) {
	        return false;
	      }
	    }

	    if (shortcut.keyCode) {
	      return event.keyCode == shortcut.keyCode;
	    } else if (event.key in ElectronKeysMapping) {
	      return ElectronKeysMapping[event.key] === shortcut.key;
	    }

	    // get the key from the keyCode if key is not provided.
	    let key = event.key || String.fromCharCode(event.keyCode);

	    // For character keys, we match if the final character is the expected one.
	    // But for digits we also accept indirect match to please azerty keyboard,
	    // which requires Shift to be pressed to get digits.
	    return key.toLowerCase() == shortcut.key ||
	      (shortcut.key.match(/[0-9]/) &&
	       event.keyCode == shortcut.key.charCodeAt(0));
	  },

	  handleEvent(event) {
	    for (let [key, shortcut] of this.keys) {
	      if (this.doesEventMatchShortcut(event, shortcut)) {
	        this.eventEmitter.emit(key, event);
	      }
	    }
	  },

	  on(key, listener) {
	    if (typeof listener !== "function") {
	      throw new Error("KeyShortcuts.on() expects a function as " +
	                      "second argument");
	    }
	    if (!this.keys.has(key)) {
	      let shortcut = KeyShortcuts.parseElectronKey(this.window, key);
	      // The key string is wrong and we were unable to compute the key shortcut
	      if (!shortcut) {
	        return;
	      }
	      this.keys.set(key, shortcut);
	    }
	    this.eventEmitter.on(key, listener);
	  },

	  off(key, listener) {
	    this.eventEmitter.off(key, listener);
	  },
	};
	exports.KeyShortcuts = KeyShortcuts;


/***/ },
/* 16 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// This was copied (and slightly modified) from
	// devtools/shared/gcli/source/lib/gcli/util/util.js, which in turn
	// says:

	/**
	 * Keyboard handling is a mess. http://unixpapa.com/js/key.html
	 * It would be good to use DOM L3 Keyboard events,
	 * http://www.w3.org/TR/2010/WD-DOM-Level-3-Events-20100907/#events-keyboardevents
	 * however only Webkit supports them, and there isn't a shim on Modernizr:
	 * https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills
	 * and when the code that uses this KeyEvent was written, nothing was clear,
	 * so instead, we're using this unmodern shim:
	 * http://stackoverflow.com/questions/5681146/chrome-10-keyevent-or-something-similar-to-firefoxs-keyevent
	 * See BUG 664991: GCLI's keyboard handling should be updated to use DOM-L3
	 * https://bugzilla.mozilla.org/show_bug.cgi?id=664991
	 */

	exports.KeyCodes = {
	  DOM_VK_CANCEL: 3,
	  DOM_VK_HELP: 6,
	  DOM_VK_BACK_SPACE: 8,
	  DOM_VK_TAB: 9,
	  DOM_VK_CLEAR: 12,
	  DOM_VK_RETURN: 13,
	  DOM_VK_SHIFT: 16,
	  DOM_VK_CONTROL: 17,
	  DOM_VK_ALT: 18,
	  DOM_VK_PAUSE: 19,
	  DOM_VK_CAPS_LOCK: 20,
	  DOM_VK_ESCAPE: 27,
	  DOM_VK_SPACE: 32,
	  DOM_VK_PAGE_UP: 33,
	  DOM_VK_PAGE_DOWN: 34,
	  DOM_VK_END: 35,
	  DOM_VK_HOME: 36,
	  DOM_VK_LEFT: 37,
	  DOM_VK_UP: 38,
	  DOM_VK_RIGHT: 39,
	  DOM_VK_DOWN: 40,
	  DOM_VK_PRINTSCREEN: 44,
	  DOM_VK_INSERT: 45,
	  DOM_VK_DELETE: 46,
	  DOM_VK_0: 48,
	  DOM_VK_1: 49,
	  DOM_VK_2: 50,
	  DOM_VK_3: 51,
	  DOM_VK_4: 52,
	  DOM_VK_5: 53,
	  DOM_VK_6: 54,
	  DOM_VK_7: 55,
	  DOM_VK_8: 56,
	  DOM_VK_9: 57,
	  DOM_VK_SEMICOLON: 59,
	  DOM_VK_EQUALS: 61,
	  DOM_VK_A: 65,
	  DOM_VK_B: 66,
	  DOM_VK_C: 67,
	  DOM_VK_D: 68,
	  DOM_VK_E: 69,
	  DOM_VK_F: 70,
	  DOM_VK_G: 71,
	  DOM_VK_H: 72,
	  DOM_VK_I: 73,
	  DOM_VK_J: 74,
	  DOM_VK_K: 75,
	  DOM_VK_L: 76,
	  DOM_VK_M: 77,
	  DOM_VK_N: 78,
	  DOM_VK_O: 79,
	  DOM_VK_P: 80,
	  DOM_VK_Q: 81,
	  DOM_VK_R: 82,
	  DOM_VK_S: 83,
	  DOM_VK_T: 84,
	  DOM_VK_U: 85,
	  DOM_VK_V: 86,
	  DOM_VK_W: 87,
	  DOM_VK_X: 88,
	  DOM_VK_Y: 89,
	  DOM_VK_Z: 90,
	  DOM_VK_CONTEXT_MENU: 93,
	  DOM_VK_NUMPAD0: 96,
	  DOM_VK_NUMPAD1: 97,
	  DOM_VK_NUMPAD2: 98,
	  DOM_VK_NUMPAD3: 99,
	  DOM_VK_NUMPAD4: 100,
	  DOM_VK_NUMPAD5: 101,
	  DOM_VK_NUMPAD6: 102,
	  DOM_VK_NUMPAD7: 103,
	  DOM_VK_NUMPAD8: 104,
	  DOM_VK_NUMPAD9: 105,
	  DOM_VK_MULTIPLY: 106,
	  DOM_VK_ADD: 107,
	  DOM_VK_SEPARATOR: 108,
	  DOM_VK_SUBTRACT: 109,
	  DOM_VK_DECIMAL: 110,
	  DOM_VK_DIVIDE: 111,
	  DOM_VK_F1: 112,
	  DOM_VK_F2: 113,
	  DOM_VK_F3: 114,
	  DOM_VK_F4: 115,
	  DOM_VK_F5: 116,
	  DOM_VK_F6: 117,
	  DOM_VK_F7: 118,
	  DOM_VK_F8: 119,
	  DOM_VK_F9: 120,
	  DOM_VK_F10: 121,
	  DOM_VK_F11: 122,
	  DOM_VK_F12: 123,
	  DOM_VK_F13: 124,
	  DOM_VK_F14: 125,
	  DOM_VK_F15: 126,
	  DOM_VK_F16: 127,
	  DOM_VK_F17: 128,
	  DOM_VK_F18: 129,
	  DOM_VK_F19: 130,
	  DOM_VK_F20: 131,
	  DOM_VK_F21: 132,
	  DOM_VK_F22: 133,
	  DOM_VK_F23: 134,
	  DOM_VK_F24: 135,
	  DOM_VK_NUM_LOCK: 144,
	  DOM_VK_SCROLL_LOCK: 145,
	  DOM_VK_COMMA: 188,
	  DOM_VK_PERIOD: 190,
	  DOM_VK_SLASH: 191,
	  DOM_VK_BACK_QUOTE: 192,
	  DOM_VK_OPEN_BRACKET: 219,
	  DOM_VK_BACK_SLASH: 220,
	  DOM_VK_CLOSE_BRACKET: 221,
	  DOM_VK_QUOTE: 222,
	  DOM_VK_META: 224,

	  // A few that did not appear in gcli, but that are apparently used
	  // in devtools.
	  DOM_VK_COLON: 58,
	  DOM_VK_VOLUME_MUTE: 181,
	  DOM_VK_VOLUME_DOWN: 182,
	  DOM_VK_VOLUME_UP: 183,
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* eslint-disable spaced-comment */
	/* globals StopIteration */

	/**
	 * This module implements a subset of "Task.js" <http://taskjs.org/>.
	 * It is a copy of toolkit/modules/Task.jsm.  Please try not to
	 * diverge the API here.
	 *
	 * Paraphrasing from the Task.js site, tasks make sequential, asynchronous
	 * operations simple, using the power of JavaScript's "yield" operator.
	 *
	 * Tasks are built upon generator functions and promises, documented here:
	 *
	 * <https://developer.mozilla.org/en/JavaScript/Guide/Iterators_and_Generators>
	 * <http://wiki.commonjs.org/wiki/Promises/A>
	 *
	 * The "Task.spawn" function takes a generator function and starts running it as
	 * a task.  Every time the task yields a promise, it waits until the promise is
	 * fulfilled.  "Task.spawn" returns a promise that is resolved when the task
	 * completes successfully, or is rejected if an exception occurs.
	 *
	 * -----------------------------------------------------------------------------
	 *
	 * const {Task} = require("devtools/shared/task");
	 *
	 * Task.spawn(function* () {
	 *
	 *   // This is our task. Let's create a promise object, wait on it and capture
	 *   // its resolution value.
	 *   let myPromise = getPromiseResolvedOnTimeoutWithValue(1000, "Value");
	 *   let result = yield myPromise;
	 *
	 *   // This part is executed only after the promise above is fulfilled (after
	 *   // one second, in this imaginary example).  We can easily loop while
	 *   // calling asynchronous functions, and wait multiple times.
	 *   for (let i = 0; i < 3; i++) {
	 *     result += yield getPromiseResolvedOnTimeoutWithValue(50, "!");
	 *   }
	 *
	 *   return "Resolution result for the task: " + result;
	 * }).then(function (result) {
	 *
	 *   // result == "Resolution result for the task: Value!!!"
	 *
	 *   // The result is undefined if no value was returned.
	 *
	 * }, function (exception) {
	 *
	 *   // Failure!  We can inspect or report the exception.
	 *
	 * });
	 *
	 * -----------------------------------------------------------------------------
	 *
	 * This module implements only the "Task.js" interfaces described above, with no
	 * additional features to control the task externally, or do custom scheduling.
	 * It also provides the following extensions that simplify task usage in the
	 * most common cases:
	 *
	 * - The "Task.spawn" function also accepts an iterator returned by a generator
	 *   function, in addition to a generator function.  This way, you can call into
	 *   the generator function with the parameters you want, and with "this" bound
	 *   to the correct value.  Also, "this" is never bound to the task object when
	 *   "Task.spawn" calls the generator function.
	 *
	 * - In addition to a promise object, a task can yield the iterator returned by
	 *   a generator function.  The iterator is turned into a task automatically.
	 *   This reduces the syntax overhead of calling "Task.spawn" explicitly when
	 *   you want to recurse into other task functions.
	 *
	 * - The "Task.spawn" function also accepts a primitive value, or a function
	 *   returning a primitive value, and treats the value as the result of the
	 *   task.  This makes it possible to call an externally provided function and
	 *   spawn a task from it, regardless of whether it is an asynchronous generator
	 *   or a synchronous function.  This comes in handy when iterating over
	 *   function lists where some items have been converted to tasks and some not.
	 */

	////////////////////////////////////////////////////////////////////////////////
	//// Globals

	const Promise = __webpack_require__(4);
	const defer = __webpack_require__(5);

	// The following error types are considered programmer errors, which should be
	// reported (possibly redundantly) so as to let programmers fix their code.
	const ERRORS_TO_REPORT = ["EvalError", "RangeError", "ReferenceError",
	                          "TypeError"];

	/**
	 * The Task currently being executed
	 */
	var gCurrentTask = null;

	/**
	 * If `true`, capture stacks whenever entering a Task and rewrite the
	 * stack any exception thrown through a Task.
	 */
	var gMaintainStack = false;

	/**
	 * Iterate through the lines of a string.
	 *
	 * @return Iterator<string>
	 */
	function* linesOf(string) {
	  let reLine = /([^\r\n])+/g;
	  let match;
	  while ((match = reLine.exec(string))) {
	    yield [match[0], match.index];
	  }
	}

	/**
	 * Detect whether a value is a generator.
	 *
	 * @param aValue
	 *        The value to identify.
	 * @return A boolean indicating whether the value is a generator.
	 */
	function isGenerator(value) {
	  return Object.prototype.toString.call(value) == "[object Generator]";
	}

	////////////////////////////////////////////////////////////////////////////////
	//// Task

	/**
	 * This object provides the public module functions.
	 */
	var Task = {
	  /**
	   * Creates and starts a new task.
	   *
	   * @param task
	   *        - If you specify a generator function, it is called with no
	   *          arguments to retrieve the associated iterator.  The generator
	   *          function is a task, that is can yield promise objects to wait
	   *          upon.
	   *        - If you specify the iterator returned by a generator function you
	   *          called, the generator function is also executed as a task.  This
	   *          allows you to call the function with arguments.
	   *        - If you specify a function that is not a generator, it is called
	   *          with no arguments, and its return value is used to resolve the
	   *          returned promise.
	   *        - If you specify anything else, you get a promise that is already
	   *          resolved with the specified value.
	   *
	   * @return A promise object where you can register completion callbacks to be
	   *         called when the task terminates.
	   */
	  spawn: function (task) {
	    return createAsyncFunction(task).call(undefined);
	  },

	  /**
	   * Create and return an 'async function' that starts a new task.
	   *
	   * This is similar to 'spawn' except that it doesn't immediately start
	   * the task, it binds the task to the async function's 'this' object and
	   * arguments, and it requires the task to be a function.
	   *
	   * It simplifies the common pattern of implementing a method via a task,
	   * like this simple object with a 'greet' method that has a 'name' parameter
	   * and spawns a task to send a greeting and return its reply:
	   *
	   * let greeter = {
	   *   message: "Hello, NAME!",
	   *   greet: function(name) {
	   *     return Task.spawn((function* () {
	   *       return yield sendGreeting(this.message.replace(/NAME/, name));
	   *     }).bind(this);
	   *   })
	   * };
	   *
	   * With Task.async, the method can be declared succinctly:
	   *
	   * let greeter = {
	   *   message: "Hello, NAME!",
	   *   greet: Task.async(function* (name) {
	   *     return yield sendGreeting(this.message.replace(/NAME/, name));
	   *   })
	   * };
	   *
	   * While maintaining identical semantics:
	   *
	   * greeter.greet("Mitchell").then((reply) => { ... }); // behaves the same
	   *
	   * @param task
	   *        The task function to start.
	   *
	   * @return A function that starts the task function and returns its promise.
	   */
	  async: function (task) {
	    if (typeof (task) != "function") {
	      throw new TypeError("task argument must be a function");
	    }

	    return createAsyncFunction(task);
	  },

	  /**
	   * Constructs a special exception that, when thrown inside a legacy generator
	   * function (non-star generator), allows the associated task to be resolved
	   * with a specific value.
	   *
	   * Example: throw new Task.Result("Value");
	   */
	  Result: function (value) {
	    this.value = value;
	  }
	};

	function createAsyncFunction(task) {
	  let asyncFunction = function () {
	    let result = task;
	    if (task && typeof (task) == "function") {
	      if (task.isAsyncFunction) {
	        throw new TypeError(
	          "Cannot use an async function in place of a promise. " +
	          "You should either invoke the async function first " +
	          "or use 'Task.spawn' instead of 'Task.async' to start " +
	          "the Task and return its promise.");
	      }

	      try {
	        // Let's call into the function ourselves.
	        result = task.apply(this, arguments);
	      } catch (ex) {
	        if (ex instanceof Task.Result) {
	          return Promise.resolve(ex.value);
	        }
	        return Promise.reject(ex);
	      }
	    }

	    if (isGenerator(result)) {
	      // This is an iterator resulting from calling a generator function.
	      return new TaskImpl(result).deferred.promise;
	    }

	    // Just propagate the given value to the caller as a resolved promise.
	    return Promise.resolve(result);
	  };

	  asyncFunction.isAsyncFunction = true;

	  return asyncFunction;
	}

	////////////////////////////////////////////////////////////////////////////////
	//// TaskImpl

	/**
	 * Executes the specified iterator as a task, and gives access to the promise
	 * that is fulfilled when the task terminates.
	 */
	function TaskImpl(iterator) {
	  if (gMaintainStack) {
	    this._stack = (new Error()).stack;
	  }
	  this.deferred = defer();
	  this._iterator = iterator;
	  this._isStarGenerator = !("send" in iterator);
	  this._run(true);
	}

	TaskImpl.prototype = {
	  /**
	   * Includes the promise object where task completion callbacks are registered,
	   * and methods to resolve or reject the promise at task completion.
	   */
	  deferred: null,

	  /**
	   * The iterator returned by the generator function associated with this task.
	   */
	  _iterator: null,

	  /**
	   * Whether this Task is using a star generator.
	   */
	  _isStarGenerator: false,

	  /**
	   * Main execution routine, that calls into the generator function.
	   *
	   * @param sendResolved
	   *        If true, indicates that we should continue into the generator
	   *        function regularly (if we were waiting on a promise, it was
	   *        resolved). If true, indicates that we should cause an exception to
	   *        be thrown into the generator function (if we were waiting on a
	   *        promise, it was rejected).
	   * @param sendValue
	   *        Resolution result or rejection exception, if any.
	   */
	  _run: function (sendResolved, sendValue) {
	    try {
	      gCurrentTask = this;

	      if (this._isStarGenerator) {
	        try {
	          let result = sendResolved ? this._iterator.next(sendValue)
	                                    : this._iterator.throw(sendValue);

	          if (result.done) {
	            // The generator function returned.
	            this.deferred.resolve(result.value);
	          } else {
	            // The generator function yielded.
	            this._handleResultValue(result.value);
	          }
	        } catch (ex) {
	          // The generator function failed with an uncaught exception.
	          this._handleException(ex);
	        }
	      } else {
	        try {
	          let yielded = sendResolved ? this._iterator.send(sendValue)
	                                     : this._iterator.throw(sendValue);
	          this._handleResultValue(yielded);
	        } catch (ex) {
	          if (ex instanceof Task.Result) {
	            // The generator function threw the special exception that
	            // allows it to return a specific value on resolution.
	            this.deferred.resolve(ex.value);
	          } else if (ex instanceof StopIteration) {
	            // The generator function terminated with no specific result.
	            this.deferred.resolve(undefined);
	          } else {
	            // The generator function failed with an uncaught exception.
	            this._handleException(ex);
	          }
	        }
	      }
	    } finally {
	      //
	      // At this stage, the Task may have finished executing, or have
	      // walked through a `yield` or passed control to a sub-Task.
	      // Regardless, if we still own `gCurrentTask`, reset it. If we
	      // have not finished execution of this Task, re-entering `_run`
	      // will set `gCurrentTask` to `this` as needed.
	      //
	      // We just need to be careful here in case we hit the following
	      // pattern:
	      //
	      //   Task.spawn(foo);
	      //   Task.spawn(bar);
	      //
	      // Here, `foo` and `bar` may be interleaved, so when we finish
	      // executing `foo`, `gCurrentTask` may actually either `foo` or
	      // `bar`. If `gCurrentTask` has already been set to `bar`, leave
	      // it be and it will be reset to `null` once `bar` is complete.
	      //
	      if (gCurrentTask == this) {
	        gCurrentTask = null;
	      }
	    }
	  },

	  /**
	   * Handle a value yielded by a generator.
	   *
	   * @param value
	   *        The yielded value to handle.
	   */
	  _handleResultValue: function (value) {
	    // If our task yielded an iterator resulting from calling another
	    // generator function, automatically spawn a task from it, effectively
	    // turning it into a promise that is fulfilled on task completion.
	    if (isGenerator(value)) {
	      value = Task.spawn(value);
	    }

	    if (value && typeof (value.then) == "function") {
	      // We have a promise object now. When fulfilled, call again into this
	      // function to continue the task, with either a resolution or rejection
	      // condition.
	      value.then(this._run.bind(this, true),
	                  this._run.bind(this, false));
	    } else {
	      // If our task yielded a value that is not a promise, just continue and
	      // pass it directly as the result of the yield statement.
	      this._run(true, value);
	    }
	  },

	  /**
	   * Handle an uncaught exception thrown from a generator.
	   *
	   * @param exception
	   *        The uncaught exception to handle.
	   */
	  _handleException: function (exception) {
	    gCurrentTask = this;

	    if (exception && typeof exception == "object" && "stack" in exception) {
	      let stack = exception.stack;

	      if (gMaintainStack &&
	          exception._capturedTaskStack != this._stack &&
	          typeof stack == "string") {
	        // Rewrite the stack for more readability.

	        let bottomStack = this._stack;

	        stack = Task.Debugging.generateReadableStack(stack);

	        exception.stack = stack;

	        // If exception is reinjected in the same task and rethrown,
	        // we don't want to perform the rewrite again.
	        exception._capturedTaskStack = bottomStack;
	      } else if (!stack) {
	        stack = "Not available";
	      }

	      if ("name" in exception &&
	          ERRORS_TO_REPORT.indexOf(exception.name) != -1) {
	        // We suspect that the exception is a programmer error, so we now
	        // display it using dump().  Note that we do not use Cu.reportError as
	        // we assume that this is a programming error, so we do not want end
	        // users to see it. Also, if the programmer handles errors correctly,
	        // they will either treat the error or log them somewhere.

	        (console.log)("*************************\n");
	        (console.log)("A coding exception was thrown and uncaught in a Task.\n\n");
	        (console.log)("Full message: " + exception + "\n");
	        (console.log)("Full stack: " + exception.stack + "\n");
	        (console.log)("*************************\n");
	      }
	    }

	    this.deferred.reject(exception);
	  },

	  get callerStack() {
	    // Cut `this._stack` at the last line of the first block that
	    // contains task.js, keep the tail.
	    for (let [line, index] of linesOf(this._stack || "")) {
	      if (line.indexOf("/task.js:") == -1) {
	        return this._stack.substring(index);
	      }
	    }
	    return "";
	  }
	};

	Task.Debugging = {

	  /**
	   * Control stack rewriting.
	   *
	   * If `true`, any exception thrown from a Task will be rewritten to
	   * provide a human-readable stack trace. Otherwise, stack traces will
	   * be left unchanged.
	   *
	   * There is a (small but existing) runtime cost associated to stack
	   * rewriting, so you should probably not activate this in production
	   * code.
	   *
	   * @type {bool}
	   */
	  get maintainStack() {
	    return gMaintainStack;
	  },
	  set maintainStack(x) {
	    if (!x) {
	      gCurrentTask = null;
	    }
	    gMaintainStack = x;
	    return x;
	  },

	  /**
	   * Generate a human-readable stack for an error raised in
	   * a Task.
	   *
	   * @param {string} topStack The stack provided by the error.
	   * @param {string=} prefix Optionally, a prefix for each line.
	   */
	  generateReadableStack: function (topStack, prefix = "") {
	    if (!gCurrentTask) {
	      return topStack;
	    }

	    // Cut `topStack` at the first line that contains task.js, keep the head.
	    let lines = [];
	    for (let [line] of linesOf(topStack)) {
	      if (line.indexOf("/task.js:") != -1) {
	        break;
	      }
	      lines.push(prefix + line);
	    }
	    if (!prefix) {
	      lines.push(gCurrentTask.callerStack);
	    } else {
	      for (let [line] of linesOf(gCurrentTask.callerStack)) {
	        lines.push(prefix + line);
	      }
	    }

	    return lines.join("\n");
	  }
	};

	exports.Task = Task;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { FrontClassWithSpec, Front } = __webpack_require__(19);
	const { cssPropertiesSpec } = __webpack_require__(30);
	const { Task } = __webpack_require__(17);
	const { CSS_PROPERTIES_DB } = __webpack_require__(31);
	const { cssColors } = __webpack_require__(32);

	/**
	 * Build up a regular expression that matches a CSS variable token. This is an
	 * ident token that starts with two dashes "--".
	 *
	 * https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	 */
	var NON_ASCII = "[^\\x00-\\x7F]";
	var ESCAPE = "\\\\[^\n\r]";
	var FIRST_CHAR = ["[_a-z]", NON_ASCII, ESCAPE].join("|");
	var TRAILING_CHAR = ["[_a-z0-9-]", NON_ASCII, ESCAPE].join("|");
	var IS_VARIABLE_TOKEN = new RegExp(`^--(${FIRST_CHAR})(${TRAILING_CHAR})*$`,
	                                   "i");
	/**
	 * Check that this is a CSS variable.
	 *
	 * @param {String} input
	 * @return {Boolean}
	 */
	function isCssVariable(input) {
	  return !!input.match(IS_VARIABLE_TOKEN);
	}

	var cachedCssProperties = new WeakMap();

	/**
	 * The CssProperties front provides a mechanism to have a one-time asynchronous
	 * load of a CSS properties database. This is then fed into the CssProperties
	 * interface that provides synchronous methods for finding out what CSS
	 * properties the current server supports.
	 */
	const CssPropertiesFront = FrontClassWithSpec(cssPropertiesSpec, {
	  initialize: function (client, { cssPropertiesActor }) {
	    Front.prototype.initialize.call(this, client, {actor: cssPropertiesActor});
	    this.manage(this);
	  }
	});

	/**
	 * Ask questions to a CSS database. This class does not care how the database
	 * gets loaded in, only the questions that you can ask to it.
	 * Prototype functions are bound to 'this' so they can be passed around as helper
	 * functions.
	 *
	 * @param {Object} db
	 *                 A database of CSS properties
	 * @param {Object} inheritedList
	 *                 The key is the property name, the value is whether or not
	 *                 that property is inherited.
	 */
	function CssProperties(db) {
	  this.properties = db.properties;
	  this.pseudoElements = db.pseudoElements;

	  this.isKnown = this.isKnown.bind(this);
	  this.isInherited = this.isInherited.bind(this);
	  this.supportsType = this.supportsType.bind(this);
	}

	CssProperties.prototype = {
	  /**
	   * Checks to see if the property is known by the browser. This function has
	   * `this` already bound so that it can be passed around by reference.
	   *
	   * @param {String} property The property name to be checked.
	   * @return {Boolean}
	   */
	  isKnown(property) {
	    return !!this.properties[property] || isCssVariable(property);
	  },

	  /**
	   * Checks to see if the property is an inherited one.
	   *
	   * @param {String} property The property name to be checked.
	   * @return {Boolean}
	   */
	  isInherited(property) {
	    return this.properties[property] && this.properties[property].isInherited;
	  },

	  /**
	   * Checks if the property supports the given CSS type.
	   * CSS types should come from devtools/shared/css-properties-db.js' CSS_TYPES.
	   *
	   * @param {String} property The property to be checked.
	   * @param {Number} type One of the type values from CSS_TYPES.
	   * @return {Boolean}
	   */
	  supportsType(property, type) {
	    return this.properties[property] && this.properties[property].supports.includes(type);
	  },

	  /**
	   * Gets the CSS values for a given property name.
	   *
	   * @param {String} property The property to use.
	   * @return {Array} An array of strings.
	   */
	  getValues(property) {
	    return this.properties[property] ? this.properties[property].values : [];
	  },

	  /**
	   * Gets the CSS property names.
	   *
	   * @return {Array} An array of strings.
	   */
	  getNames(property) {
	    return Object.keys(this.properties);
	  }
	};

	/**
	 * Create a CssProperties object with a fully loaded CSS database. The
	 * CssProperties interface can be queried synchronously, but the initialization
	 * is potentially async and should be handled up-front when the tool is created.
	 *
	 * The front is returned only with this function so that it can be destroyed
	 * once the toolbox is destroyed.
	 *
	 * @param {Toolbox} The current toolbox.
	 * @returns {Promise} Resolves to {cssProperties, cssPropertiesFront}.
	 */
	const initCssProperties = Task.async(function* (toolbox) {
	  const client = toolbox.target.client;
	  if (cachedCssProperties.has(client)) {
	    return cachedCssProperties.get(client);
	  }

	  let db, front;

	  // Get the list dynamically if the cssProperties actor exists.
	  if (toolbox.target.hasActor("cssProperties")) {
	    front = CssPropertiesFront(client, toolbox.target.form);
	    const serverDB = yield front.getCSSDatabase(getClientBrowserVersion(toolbox));

	    // The serverDB will be blank if the browser versions match, so use the static list.
	    if (!serverDB.properties && !serverDB.margin) {
	      db = CSS_PROPERTIES_DB;
	    } else {
	      db = serverDB;
	    }
	  } else {
	    // The target does not support this actor, so require a static list of supported
	    // properties.
	    db = CSS_PROPERTIES_DB;
	  }

	  const cssProperties = new CssProperties(normalizeCssData(db));
	  cachedCssProperties.set(client, {cssProperties, front});
	  return {cssProperties, front};
	});

	/**
	 * Synchronously get a cached and initialized CssProperties.
	 *
	 * @param {Toolbox} The current toolbox.
	 * @returns {CssProperties}
	 */
	function getCssProperties(toolbox) {
	  if (!cachedCssProperties.has(toolbox.target.client)) {
	    throw new Error("The CSS database has not been initialized, please make " +
	                    "sure initCssDatabase was called once before for this " +
	                    "toolbox.");
	  }
	  return cachedCssProperties.get(toolbox.target.client).cssProperties;
	}

	/**
	 * Get a client-side CssProperties. This is useful for dependencies in tests, or parts
	 * of the codebase that don't particularly need to match every known CSS property on
	 * the target.
	 * @return {CssProperties}
	 */
	function getClientCssProperties() {
	  return new CssProperties(normalizeCssData(CSS_PROPERTIES_DB));
	}

	/**
	 * Get the current browser version.
	 * @returns {string} The browser version.
	 */
	function getClientBrowserVersion(toolbox) {
	  const regexResult = toolbox.win.navigator
	                             .userAgent.match(/Firefox\/(\d+)\.\d/);
	  return Array.isArray(regexResult) ? regexResult[1] : "0";
	}

	/**
	 * Even if the target has the cssProperties actor, the returned data may not be in the
	 * same shape or have all of the data we need. This normalizes the data and fills in
	 * any missing information like color values.
	 *
	 * @return {Object} The normalized CSS database.
	 */
	function normalizeCssData(db) {
	  if (db !== CSS_PROPERTIES_DB) {
	    // Firefox 49's getCSSDatabase() just returned the properties object, but
	    // now it returns an object with multiple types of CSS information.
	    if (!db.properties) {
	      db = { properties: db };
	    }

	    // Fill in any missing DB information from the static database.
	    db = Object.assign({}, CSS_PROPERTIES_DB, db);

	    // Add "supports" information to the css properties if it's missing.
	    if (!db.properties.color.supports) {
	      for (let name in db.properties) {
	        if (typeof CSS_PROPERTIES_DB.properties[name] === "object") {
	          db.properties[name].supports = CSS_PROPERTIES_DB.properties[name].supports;
	        }
	      }
	    }

	    // Add "values" information to the css properties if it's missing.
	    if (!db.properties.color.values) {
	      for (let name in db.properties) {
	        if (typeof CSS_PROPERTIES_DB.properties[name] === "object") {
	          db.properties[name].values = CSS_PROPERTIES_DB.properties[name].values;
	        }
	      }
	    }
	  }

	  reattachCssColorValues(db);

	  return db;
	}

	/**
	 * Color values are omitted to save on space. Add them back here.
	 * @param {Object} The CSS database.
	 */
	function reattachCssColorValues(db) {
	  if (db.properties.color.values[0] === "COLOR") {
	    const colors = Object.keys(cssColors);

	    for (let name in db.properties) {
	      const property = db.properties[name];
	      if (property.values[0] === "COLOR") {
	        property.values.shift();
	        property.values = property.values.concat(colors).sort();
	      }
	    }
	  }
	}

	module.exports = {
	  CssPropertiesFront,
	  CssProperties,
	  getCssProperties,
	  getClientCssProperties,
	  initCssProperties
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var promise = __webpack_require__(4);
	var defer = __webpack_require__(5);
	var {Class} = __webpack_require__(20);
	var {EventTarget} = __webpack_require__(22);
	var events = __webpack_require__(23);
	var object = __webpack_require__(27);
	var {getStack, callFunctionWithAsyncStack} = __webpack_require__(7);

	exports.emit = events.emit;

	/**
	 * Types: named marshallers/demarshallers.
	 *
	 * Types provide a 'write' function that takes a js representation and
	 * returns a protocol representation, and a "read" function that
	 * takes a protocol representation and returns a js representation.
	 *
	 * The read and write methods are also passed a context object that
	 * represent the actor or front requesting the translation.
	 *
	 * Types are referred to with a typestring.  Basic types are
	 * registered by name using addType, and more complex types can
	 * be generated by adding detail to the type name.
	 */

	var types = Object.create(null);
	exports.types = types;

	var registeredTypes = types.registeredTypes = new Map();
	var registeredLifetimes = types.registeredLifetimes = new Map();

	/**
	 * Return the type object associated with a given typestring.
	 * If passed a type object, it will be returned unchanged.
	 *
	 * Types can be registered with addType, or can be created on
	 * the fly with typestrings.  Examples:
	 *
	 *   boolean
	 *   threadActor
	 *   threadActor#detail
	 *   array:threadActor
	 *   array:array:threadActor#detail
	 *
	 * @param [typestring|type] type
	 *    Either a typestring naming a type or a type object.
	 *
	 * @returns a type object.
	 */
	types.getType = function (type) {
	  if (!type) {
	    return types.Primitive;
	  }

	  if (typeof (type) !== "string") {
	    return type;
	  }

	  // If already registered, we're done here.
	  let reg = registeredTypes.get(type);
	  if (reg) return reg;

	  // New type, see if it's a collection/lifetime type:
	  let sep = type.indexOf(":");
	  if (sep >= 0) {
	    let collection = type.substring(0, sep);
	    let subtype = types.getType(type.substring(sep + 1));

	    if (collection === "array") {
	      return types.addArrayType(subtype);
	    } else if (collection === "nullable") {
	      return types.addNullableType(subtype);
	    }

	    if (registeredLifetimes.has(collection)) {
	      return types.addLifetimeType(collection, subtype);
	    }

	    throw Error("Unknown collection type: " + collection);
	  }

	  // Not a collection, might be actor detail
	  let pieces = type.split("#", 2);
	  if (pieces.length > 1) {
	    return types.addActorDetail(type, pieces[0], pieces[1]);
	  }

	  // Might be a lazily-loaded type
	  if (type === "longstring") {
	    __webpack_require__(29);
	    return registeredTypes.get("longstring");
	  }

	  throw Error("Unknown type: " + type);
	};

	/**
	 * Don't allow undefined when writing primitive types to packets.  If
	 * you want to allow undefined, use a nullable type.
	 */
	function identityWrite(v) {
	  if (v === undefined) {
	    throw Error("undefined passed where a value is required");
	  }
	  // This has to handle iterator->array conversion because arrays of
	  // primitive types pass through here.
	  if (v && typeof (v) === "object" && Symbol.iterator in v) {
	    return [...v];
	  }
	  return v;
	}

	/**
	 * Add a type to the type system.
	 *
	 * When registering a type, you can provide `read` and `write` methods.
	 *
	 * The `read` method will be passed a JS object value from the JSON
	 * packet and must return a native representation.  The `write` method will
	 * be passed a native representation and should provide a JSONable value.
	 *
	 * These methods will both be passed a context.  The context is the object
	 * performing or servicing the request - on the server side it will be
	 * an Actor, on the client side it will be a Front.
	 *
	 * @param typestring name
	 *    Name to register
	 * @param object typeObject
	 *    An object whose properties will be stored in the type, including
	 *    the `read` and `write` methods.
	 * @param object options
	 *    Can specify `thawed` to prevent the type from being frozen.
	 *
	 * @returns a type object that can be used in protocol definitions.
	 */
	types.addType = function (name, typeObject = {}, options = {}) {
	  if (registeredTypes.has(name)) {
	    throw Error("Type '" + name + "' already exists.");
	  }

	  let type = object.merge({
	    toString() { return "[protocol type:" + name + "]";},
	    name: name,
	    primitive: !(typeObject.read || typeObject.write),
	    read: identityWrite,
	    write: identityWrite
	  }, typeObject);

	  registeredTypes.set(name, type);

	  return type;
	};

	/**
	 * Remove a type previously registered with the system.
	 * Primarily useful for types registered by addons.
	 */
	types.removeType = function (name) {
	  // This type may still be referenced by other types, make sure
	  // those references don't work.
	  let type = registeredTypes.get(name);

	  type.name = "DEFUNCT:" + name;
	  type.category = "defunct";
	  type.primitive = false;
	  type.read = type.write = function () { throw new Error("Using defunct type: " + name); };

	  registeredTypes.delete(name);
	};

	/**
	 * Add an array type to the type system.
	 *
	 * getType() will call this function if provided an "array:<type>"
	 * typestring.
	 *
	 * @param type subtype
	 *    The subtype to be held by the array.
	 */
	types.addArrayType = function (subtype) {
	  subtype = types.getType(subtype);

	  let name = "array:" + subtype.name;

	  // Arrays of primitive types are primitive types themselves.
	  if (subtype.primitive) {
	    return types.addType(name);
	  }
	  return types.addType(name, {
	    category: "array",
	    read: (v, ctx) => [...v].map(i => subtype.read(i, ctx)),
	    write: (v, ctx) => [...v].map(i => subtype.write(i, ctx))
	  });
	};

	/**
	 * Add a dict type to the type system.  This allows you to serialize
	 * a JS object that contains non-primitive subtypes.
	 *
	 * Properties of the value that aren't included in the specializations
	 * will be serialized as primitive values.
	 *
	 * @param object specializations
	 *    A dict of property names => type
	 */
	types.addDictType = function (name, specializations) {
	  return types.addType(name, {
	    category: "dict",
	    specializations: specializations,
	    read: (v, ctx) => {
	      let ret = {};
	      for (let prop in v) {
	        if (prop in specializations) {
	          ret[prop] = types.getType(specializations[prop]).read(v[prop], ctx);
	        } else {
	          ret[prop] = v[prop];
	        }
	      }
	      return ret;
	    },

	    write: (v, ctx) => {
	      let ret = {};
	      for (let prop in v) {
	        if (prop in specializations) {
	          ret[prop] = types.getType(specializations[prop]).write(v[prop], ctx);
	        } else {
	          ret[prop] = v[prop];
	        }
	      }
	      return ret;
	    }
	  });
	};

	/**
	 * Register an actor type with the type system.
	 *
	 * Types are marshalled differently when communicating server->client
	 * than they are when communicating client->server.  The server needs
	 * to provide useful information to the client, so uses the actor's
	 * `form` method to get a json representation of the actor.  When
	 * making a request from the client we only need the actor ID string.
	 *
	 * This function can be called before the associated actor has been
	 * constructed, but the read and write methods won't work until
	 * the associated addActorImpl or addActorFront methods have been
	 * called during actor/front construction.
	 *
	 * @param string name
	 *    The typestring to register.
	 */
	types.addActorType = function (name) {
	  let type = types.addType(name, {
	    _actor: true,
	    category: "actor",
	    read: (v, ctx, detail) => {
	      // If we're reading a request on the server side, just
	      // find the actor registered with this actorID.
	      if (ctx instanceof Actor) {
	        return ctx.conn.getActor(v);
	      }

	      // Reading a response on the client side, check for an
	      // existing front on the connection, and create the front
	      // if it isn't found.
	      let actorID = typeof (v) === "string" ? v : v.actor;
	      let front = ctx.conn.getActor(actorID);
	      if (!front) {
	        front = new type.frontClass(ctx.conn);
	        front.actorID = actorID;
	        ctx.marshallPool().manage(front);
	      }

	      v = type.formType(detail).read(v, front, detail);
	      front.form(v, detail, ctx);

	      return front;
	    },
	    write: (v, ctx, detail) => {
	      // If returning a response from the server side, make sure
	      // the actor is added to a parent object and return its form.
	      if (v instanceof Actor) {
	        if (!v.actorID) {
	          ctx.marshallPool().manage(v);
	        }
	        return type.formType(detail).write(v.form(detail), ctx, detail);
	      }

	      // Writing a request from the client side, just send the actor id.
	      return v.actorID;
	    },
	    formType: (detail) => {
	      if (!("formType" in type.actorSpec)) {
	        return types.Primitive;
	      }

	      let formAttr = "formType";
	      if (detail) {
	        formAttr += "#" + detail;
	      }

	      if (!(formAttr in type.actorSpec)) {
	        throw new Error("No type defined for " + formAttr);
	      }

	      return type.actorSpec[formAttr];
	    }
	  });
	  return type;
	};

	types.addNullableType = function (subtype) {
	  subtype = types.getType(subtype);
	  return types.addType("nullable:" + subtype.name, {
	    category: "nullable",
	    read: (value, ctx) => {
	      if (value == null) {
	        return value;
	      }
	      return subtype.read(value, ctx);
	    },
	    write: (value, ctx) => {
	      if (value == null) {
	        return value;
	      }
	      return subtype.write(value, ctx);
	    }
	  });
	};

	/**
	 * Register an actor detail type.  This is just like an actor type, but
	 * will pass a detail hint to the actor's form method during serialization/
	 * deserialization.
	 *
	 * This is called by getType() when passed an 'actorType#detail' string.
	 *
	 * @param string name
	 *   The typestring to register this type as.
	 * @param type actorType
	 *   The actor type you'll be detailing.
	 * @param string detail
	 *   The detail to pass.
	 */
	types.addActorDetail = function (name, actorType, detail) {
	  actorType = types.getType(actorType);
	  if (!actorType._actor) {
	    throw Error("Details only apply to actor types, tried to add detail '" + detail + "'' to " + actorType.name + "\n");
	  }
	  return types.addType(name, {
	    _actor: true,
	    category: "detail",
	    read: (v, ctx) => actorType.read(v, ctx, detail),
	    write: (v, ctx) => actorType.write(v, ctx, detail)
	  });
	};

	/**
	 * Register an actor lifetime.  This lets the type system find a parent
	 * actor that differs from the actor fulfilling the request.
	 *
	 * @param string name
	 *    The lifetime name to use in typestrings.
	 * @param string prop
	 *    The property of the actor that holds the parent that should be used.
	 */
	types.addLifetime = function (name, prop) {
	  if (registeredLifetimes.has(name)) {
	    throw Error("Lifetime '" + name + "' already registered.");
	  }
	  registeredLifetimes.set(name, prop);
	};

	/**
	 * Remove a previously-registered lifetime.  Useful for lifetimes registered
	 * in addons.
	 */
	types.removeLifetime = function (name) {
	  registeredLifetimes.delete(name);
	};

	/**
	 * Register a lifetime type.  This creates an actor type tied to the given
	 * lifetime.
	 *
	 * This is called by getType() when passed a '<lifetimeType>:<actorType>'
	 * typestring.
	 *
	 * @param string lifetime
	 *    A lifetime string previously regisered with addLifetime()
	 * @param type subtype
	 *    An actor type
	 */
	types.addLifetimeType = function (lifetime, subtype) {
	  subtype = types.getType(subtype);
	  if (!subtype._actor) {
	    throw Error("Lifetimes only apply to actor types, tried to apply lifetime '" + lifetime + "'' to " + subtype.name);
	  }
	  let prop = registeredLifetimes.get(lifetime);
	  return types.addType(lifetime + ":" + subtype.name, {
	    category: "lifetime",
	    read: (value, ctx) => subtype.read(value, ctx[prop]),
	    write: (value, ctx) => subtype.write(value, ctx[prop])
	  });
	};

	// Add a few named primitive types.
	types.Primitive = types.addType("primitive");
	types.String = types.addType("string");
	types.Number = types.addType("number");
	types.Boolean = types.addType("boolean");
	types.JSON = types.addType("json");

	/**
	 * Request/Response templates and generation
	 *
	 * Request packets are specified as json templates with
	 * Arg and Option placeholders where arguments should be
	 * placed.
	 *
	 * Reponse packets are also specified as json templates,
	 * with a RetVal placeholder where the return value should be
	 * placed.
	 */

	/**
	 * Placeholder for simple arguments.
	 *
	 * @param number index
	 *    The argument index to place at this position.
	 * @param type type
	 *    The argument should be marshalled as this type.
	 * @constructor
	 */
	var Arg = Class({
	  initialize: function (index, type) {
	    this.index = index;
	    this.type = types.getType(type);
	  },

	  write: function (arg, ctx) {
	    return this.type.write(arg, ctx);
	  },

	  read: function (v, ctx, outArgs) {
	    outArgs[this.index] = this.type.read(v, ctx);
	  },

	  describe: function () {
	    return {
	      _arg: this.index,
	      type: this.type.name,
	    };
	  }
	});
	exports.Arg = Arg;

	/**
	 * Placeholder for an options argument value that should be hoisted
	 * into the packet.
	 *
	 * If provided in a method specification:
	 *
	 *   { optionArg: Option(1)}
	 *
	 * Then arguments[1].optionArg will be placed in the packet in this
	 * value's place.
	 *
	 * @param number index
	 *    The argument index of the options value.
	 * @param type type
	 *    The argument should be marshalled as this type.
	 * @constructor
	 */
	var Option = Class({
	  extends: Arg,
	  initialize: function (index, type) {
	    Arg.prototype.initialize.call(this, index, type);
	  },

	  write: function (arg, ctx, name) {
	    // Ignore if arg is undefined or null; allow other falsy values
	    if (arg == undefined || arg[name] == undefined) {
	      return undefined;
	    }
	    let v = arg[name];
	    return this.type.write(v, ctx);
	  },
	  read: function (v, ctx, outArgs, name) {
	    if (outArgs[this.index] === undefined) {
	      outArgs[this.index] = {};
	    }
	    if (v === undefined) {
	      return;
	    }
	    outArgs[this.index][name] = this.type.read(v, ctx);
	  },

	  describe: function () {
	    return {
	      _option: this.index,
	      type: this.type.name,
	    };
	  }
	});

	exports.Option = Option;

	/**
	 * Placeholder for return values in a response template.
	 *
	 * @param type type
	 *    The return value should be marshalled as this type.
	 */
	var RetVal = Class({
	  initialize: function (type) {
	    this.type = types.getType(type);
	  },

	  write: function (v, ctx) {
	    return this.type.write(v, ctx);
	  },

	  read: function (v, ctx) {
	    return this.type.read(v, ctx);
	  },

	  describe: function () {
	    return {
	      _retval: this.type.name
	    };
	  }
	});

	exports.RetVal = RetVal;

	/* Template handling functions */

	/**
	 * Get the value at a given path, or undefined if not found.
	 */
	function getPath(obj, path) {
	  for (let name of path) {
	    if (!(name in obj)) {
	      return undefined;
	    }
	    obj = obj[name];
	  }
	  return obj;
	}

	/**
	 * Find Placeholders in the template and save them along with their
	 * paths.
	 */
	function findPlaceholders(template, constructor, path = [], placeholders = []) {
	  if (!template || typeof (template) != "object") {
	    return placeholders;
	  }

	  if (template instanceof constructor) {
	    placeholders.push({ placeholder: template, path: [...path] });
	    return placeholders;
	  }

	  for (let name in template) {
	    path.push(name);
	    findPlaceholders(template[name], constructor, path, placeholders);
	    path.pop();
	  }

	  return placeholders;
	}


	function describeTemplate(template) {
	  return JSON.parse(JSON.stringify(template, (key, value) => {
	    if (value.describe) {
	      return value.describe();
	    }
	    return value;
	  }));
	}

	/**
	 * Manages a request template.
	 *
	 * @param object template
	 *    The request template.
	 * @construcor
	 */
	var Request = Class({
	  initialize: function (template = {}) {
	    this.type = template.type;
	    this.template = template;
	    this.args = findPlaceholders(template, Arg);
	  },

	  /**
	   * Write a request.
	   *
	   * @param array fnArgs
	   *    The function arguments to place in the request.
	   * @param object ctx
	   *    The object making the request.
	   * @returns a request packet.
	   */
	  write: function (fnArgs, ctx) {
	    let str = JSON.stringify(this.template, (key, value) => {
	      if (value instanceof Arg) {
	        return value.write(value.index in fnArgs ? fnArgs[value.index] : undefined,
	                           ctx, key);
	      }
	      return value;
	    });
	    return JSON.parse(str);
	  },

	  /**
	   * Read a request.
	   *
	   * @param object packet
	   *    The request packet.
	   * @param object ctx
	   *    The object making the request.
	   * @returns an arguments array
	   */
	  read: function (packet, ctx) {
	    let fnArgs = [];
	    for (let templateArg of this.args) {
	      let arg = templateArg.placeholder;
	      let path = templateArg.path;
	      let name = path[path.length - 1];
	      arg.read(getPath(packet, path), ctx, fnArgs, name);
	    }
	    return fnArgs;
	  },

	  describe: function () { return describeTemplate(this.template); }
	});

	/**
	 * Manages a response template.
	 *
	 * @param object template
	 *    The response template.
	 * @construcor
	 */
	var Response = Class({
	  initialize: function (template = {}) {
	    this.template = template;
	    let placeholders = findPlaceholders(template, RetVal);
	    if (placeholders.length > 1) {
	      throw Error("More than one RetVal specified in response");
	    }
	    let placeholder = placeholders.shift();
	    if (placeholder) {
	      this.retVal = placeholder.placeholder;
	      this.path = placeholder.path;
	    }
	  },

	  /**
	   * Write a response for the given return value.
	   *
	   * @param val ret
	   *    The return value.
	   * @param object ctx
	   *    The object writing the response.
	   */
	  write: function (ret, ctx) {
	    return JSON.parse(JSON.stringify(this.template, function (key, value) {
	      if (value instanceof RetVal) {
	        return value.write(ret, ctx);
	      }
	      return value;
	    }));
	  },

	  /**
	   * Read a return value from the given response.
	   *
	   * @param object packet
	   *    The response packet.
	   * @param object ctx
	   *    The object reading the response.
	   */
	  read: function (packet, ctx) {
	    if (!this.retVal) {
	      return undefined;
	    }
	    let v = getPath(packet, this.path);
	    return this.retVal.read(v, ctx);
	  },

	  describe: function () { return describeTemplate(this.template); }
	});

	/**
	 * Actor and Front implementations
	 */

	/**
	 * A protocol object that can manage the lifetime of other protocol
	 * objects.
	 */
	var Pool = Class({
	  extends: EventTarget,

	  /**
	   * Pools are used on both sides of the connection to help coordinate
	   * lifetimes.
	   *
	   * @param optional conn
	   *   Either a DebuggerServerConnection or a DebuggerClient.  Must have
	   *   addActorPool, removeActorPool, and poolFor.
	   *   conn can be null if the subclass provides a conn property.
	   * @constructor
	   */
	  initialize: function (conn) {
	    if (conn) {
	      this.conn = conn;
	    }
	  },

	  /**
	   * Return the parent pool for this client.
	   */
	  parent: function () { return this.conn.poolFor(this.actorID); },

	  /**
	   * Override this if you want actors returned by this actor
	   * to belong to a different actor by default.
	   */
	  marshallPool: function () { return this; },

	  /**
	   * Pool is the base class for all actors, even leaf nodes.
	   * If the child map is actually referenced, go ahead and create
	   * the stuff needed by the pool.
	   */
	  __poolMap: null,
	  get _poolMap() {
	    if (this.__poolMap) return this.__poolMap;
	    this.__poolMap = new Map();
	    this.conn.addActorPool(this);
	    return this.__poolMap;
	  },

	  /**
	   * Add an actor as a child of this pool.
	   */
	  manage: function (actor) {
	    if (!actor.actorID) {
	      actor.actorID = this.conn.allocID(actor.actorPrefix || actor.typeName);
	    }

	    this._poolMap.set(actor.actorID, actor);
	    return actor;
	  },

	  /**
	   * Remove an actor as a child of this pool.
	   */
	  unmanage: function (actor) {
	    this.__poolMap && this.__poolMap.delete(actor.actorID);
	  },

	  // true if the given actor ID exists in the pool.
	  has: function (actorID) {
	    return this.__poolMap && this._poolMap.has(actorID);
	  },

	  // The actor for a given actor id stored in this pool
	  actor: function (actorID) {
	    return this.__poolMap ? this._poolMap.get(actorID) : null;
	  },

	  // Same as actor, should update debugger connection to use 'actor'
	  // and then remove this.
	  get: function (actorID) {
	    return this.__poolMap ? this._poolMap.get(actorID) : null;
	  },

	  // True if this pool has no children.
	  isEmpty: function () {
	    return !this.__poolMap || this._poolMap.size == 0;
	  },

	  /**
	   * Destroy this item, removing it from a parent if it has one,
	   * and destroying all children if necessary.
	   */
	  destroy: function () {
	    let parent = this.parent();
	    if (parent) {
	      parent.unmanage(this);
	    }
	    if (!this.__poolMap) {
	      return;
	    }
	    for (let actor of this.__poolMap.values()) {
	      // Self-owned actors are ok, but don't need destroying twice.
	      if (actor === this) {
	        continue;
	      }
	      let destroy = actor.destroy;
	      if (destroy) {
	        // Disconnect destroy while we're destroying in case of (misbehaving)
	        // circular ownership.
	        actor.destroy = null;
	        destroy.call(actor);
	        actor.destroy = destroy;
	      }
	    }
	    this.conn.removeActorPool(this, true);
	    this.__poolMap.clear();
	    this.__poolMap = null;
	  },

	  /**
	   * For getting along with the debugger server pools, should be removable
	   * eventually.
	   */
	  cleanup: function () {
	    this.destroy();
	  }
	});
	exports.Pool = Pool;

	/**
	 * An actor in the actor tree.
	 */
	var Actor = Class({
	  extends: Pool,

	  // Will contain the actor's ID
	  actorID: null,

	  /**
	   * Initialize an actor.
	   *
	   * @param optional conn
	   *   Either a DebuggerServerConnection or a DebuggerClient.  Must have
	   *   addActorPool, removeActorPool, and poolFor.
	   *   conn can be null if the subclass provides a conn property.
	   * @constructor
	   */
	  initialize: function (conn) {
	    Pool.prototype.initialize.call(this, conn);

	    // Forward events to the connection.
	    if (this._actorSpec && this._actorSpec.events) {
	      for (let key of this._actorSpec.events.keys()) {
	        let name = key;
	        let sendEvent = this._sendEvent.bind(this, name);
	        this.on(name, (...args) => {
	          sendEvent.apply(null, args);
	        });
	      }
	    }
	  },

	  toString: function () { return "[Actor " + this.typeName + "/" + this.actorID + "]"; },

	  _sendEvent: function (name, ...args) {
	    if (!this._actorSpec.events.has(name)) {
	      // It's ok to emit events that don't go over the wire.
	      return;
	    }
	    let request = this._actorSpec.events.get(name);
	    let packet;
	    try {
	      packet = request.write(args, this);
	    } catch (ex) {
	      console.error("Error sending event: " + name);
	      throw ex;
	    }
	    packet.from = packet.from || this.actorID;
	    this.conn.send(packet);
	  },

	  destroy: function () {
	    Pool.prototype.destroy.call(this);
	    this.actorID = null;
	  },

	  /**
	   * Override this method in subclasses to serialize the actor.
	   * @param [optional] string hint
	   *   Optional string to customize the form.
	   * @returns A jsonable object.
	   */
	  form: function (hint) {
	    return { actor: this.actorID };
	  },

	  writeError: function (error) {
	    console.error(error);
	    if (error.stack) {
	      (console.log)(error.stack);
	    }
	    this.conn.send({
	      from: this.actorID,
	      error: error.error || "unknownError",
	      message: error.message
	    });
	  },

	  _queueResponse: function (create) {
	    let pending = this._pendingResponse || promise.resolve(null);
	    let response = create(pending);
	    this._pendingResponse = response;
	  }
	});
	exports.Actor = Actor;

	/**
	 * Tags a prtotype method as an actor method implementation.
	 *
	 * @param function fn
	 *    The implementation function, will be returned.
	 * @param spec
	 *    The method specification, with the following (optional) properties:
	 *      request (object): a request template.
	 *      response (object): a response template.
	 *      oneway (bool): 'true' if no response should be sent.
	 */
	exports.method = function (fn, spec = {}) {
	  fn._methodSpec = Object.freeze(spec);
	  if (spec.request) Object.freeze(spec.request);
	  if (spec.response) Object.freeze(spec.response);
	  return fn;
	};

	/**
	 * Generates an actor specification from an actor description.
	 */
	var generateActorSpec = function (actorDesc) {
	  let actorSpec = {
	    typeName: actorDesc.typeName,
	    methods: []
	  };

	  // Find method and form specifications attached to properties.
	  for (let name of Object.getOwnPropertyNames(actorDesc)) {
	    let desc = Object.getOwnPropertyDescriptor(actorDesc, name);
	    if (!desc.value) {
	      continue;
	    }

	    if (name.startsWith("formType")) {
	      if (typeof (desc.value) === "string") {
	        actorSpec[name] = types.getType(desc.value);
	      } else if (desc.value.name && registeredTypes.has(desc.value.name)) {
	        actorSpec[name] = desc.value;
	      } else {
	        // Shorthand for a newly-registered DictType.
	        actorSpec[name] = types.addDictType(actorDesc.typeName + "__" + name, desc.value);
	      }
	    }

	    if (desc.value._methodSpec) {
	      let methodSpec = desc.value._methodSpec;
	      let spec = {};
	      spec.name = methodSpec.name || name;
	      spec.request = Request(object.merge({type: spec.name}, methodSpec.request || undefined));
	      spec.response = Response(methodSpec.response || undefined);
	      spec.release = methodSpec.release;
	      spec.oneway = methodSpec.oneway;

	      actorSpec.methods.push(spec);
	    }
	  }

	  // Find additional method specifications
	  if (actorDesc.methods) {
	    for (let name in actorDesc.methods) {
	      let methodSpec = actorDesc.methods[name];
	      let spec = {};

	      spec.name = methodSpec.name || name;
	      spec.request = Request(object.merge({type: spec.name}, methodSpec.request || undefined));
	      spec.response = Response(methodSpec.response || undefined);
	      spec.release = methodSpec.release;
	      spec.oneway = methodSpec.oneway;

	      actorSpec.methods.push(spec);
	    }
	  }

	  // Find event specifications
	  if (actorDesc.events) {
	    actorSpec.events = new Map();
	    for (let name in actorDesc.events) {
	      let eventRequest = actorDesc.events[name];
	      Object.freeze(eventRequest);
	      actorSpec.events.set(name, Request(object.merge({type: name}, eventRequest)));
	    }
	  }

	  if (!registeredTypes.has(actorSpec.typeName)) {
	    types.addActorType(actorSpec.typeName);
	  }
	  registeredTypes.get(actorSpec.typeName).actorSpec = actorSpec;

	  return actorSpec;
	};
	exports.generateActorSpec = generateActorSpec;

	/**
	 * Generates request handlers as described by the given actor specification on
	 * the given actor prototype. Returns the actor prototype.
	 */
	var generateRequestHandlers = function (actorSpec, actorProto) {
	  if (actorProto._actorSpec) {
	    throw new Error("actorProto called twice on the same actor prototype!");
	  }

	  actorProto.typeName = actorSpec.typeName;

	  // Generate request handlers for each method definition
	  actorProto.requestTypes = Object.create(null);
	  actorSpec.methods.forEach(spec => {
	    let handler = function (packet, conn) {
	      try {
	        let args;
	        try {
	          args = spec.request.read(packet, this);
	        } catch (ex) {
	          console.error("Error reading request: " + packet.type);
	          throw ex;
	        }

	        let ret = this[spec.name].apply(this, args);

	        let sendReturn = (ret) => {
	          if (spec.oneway) {
	            // No need to send a response.
	            return;
	          }

	          let response;
	          try {
	            response = spec.response.write(ret, this);
	          } catch (ex) {
	            console.error("Error writing response to: " + spec.name);
	            throw ex;
	          }
	          response.from = this.actorID;
	          // If spec.release has been specified, destroy the object.
	          if (spec.release) {
	            try {
	              this.destroy();
	            } catch (e) {
	              this.writeError(e);
	              return;
	            }
	          }

	          conn.send(response);
	        };

	        this._queueResponse(p => {
	          return p
	            .then(() => ret)
	            .then(sendReturn)
	            .then(null, this.writeError.bind(this));
	        });
	      } catch (e) {
	        this._queueResponse(p => {
	          return p.then(() => this.writeError(e));
	        });
	      }
	    };

	    actorProto.requestTypes[spec.request.type] = handler;
	  });

	  actorProto._actorSpec = actorSpec;

	  return actorProto;
	};

	/**
	 * THIS METHOD IS DEPRECATED, AND PRESERVED ONLY FOR ADD-ONS. IT SHOULD NOT BE
	 * USED INSIDE THE TREE.
	 *
	 * Create an actor class for the given actor prototype.
	 *
	 * @param object actorProto
	 *    The actor prototype.  Must have a 'typeName' property,
	 *    should have method definitions, can have event definitions.
	 */
	exports.ActorClass = function (actorProto) {
	  return ActorClassWithSpec(generateActorSpec(actorProto), actorProto);
	};

	/**
	 * THIS METHOD IS DEPRECATED, AND PRESERVED ONLY FOR ADD-ONS. IT SHOULD NOT BE
	 * USED INSIDE THE TREE.
	 *
	 * Create an actor class for the given actor specification and prototype.
	 *
	 * @param object actorSpec
	 *    The actor specification. Must have a 'typeName' property.
	 * @param object actorProto
	 *    The actor prototype. Should have method definitions, can have event
	 *    definitions.
	 */
	var ActorClassWithSpec = function (actorSpec, actorProto) {
	  if (!actorSpec.typeName) {
	    throw Error("Actor specification must have a typeName member.");
	  }

	  actorProto.extends = Actor;
	  let cls = Class(generateRequestHandlers(actorSpec, actorProto));

	  return cls;
	};
	exports.ActorClassWithSpec = ActorClassWithSpec;

	/**
	 * Base class for client-side actor fronts.
	 */
	var Front = Class({
	  extends: Pool,

	  actorID: null,

	  /**
	   * The base class for client-side actor fronts.
	   *
	   * @param optional conn
	   *   Either a DebuggerServerConnection or a DebuggerClient.  Must have
	   *   addActorPool, removeActorPool, and poolFor.
	   *   conn can be null if the subclass provides a conn property.
	   * @param optional form
	   *   The json form provided by the server.
	   * @constructor
	   */
	  initialize: function (conn = null, form = null, detail = null, context = null) {
	    Pool.prototype.initialize.call(this, conn);
	    this._requests = [];

	    // protocol.js no longer uses this data in the constructor, only external
	    // uses do.  External usage of manually-constructed fronts will be
	    // drastically reduced if we convert the root and tab actors to
	    // protocol.js, in which case this can probably go away.
	    if (form) {
	      this.actorID = form.actor;
	      form = types.getType(this.typeName).formType(detail).read(form, this, detail);
	      this.form(form, detail, context);
	    }
	  },

	  destroy: function () {
	    // Reject all outstanding requests, they won't make sense after
	    // the front is destroyed.
	    while (this._requests && this._requests.length > 0) {
	      let { deferred, to, type, stack } = this._requests.shift();
	      let msg = "Connection closed, pending request to " + to +
	                ", type " + type + " failed" +
	                "\n\nRequest stack:\n" + stack.formattedStack;
	      deferred.reject(new Error(msg));
	    }
	    Pool.prototype.destroy.call(this);
	    this.actorID = null;
	  },

	  manage: function (front) {
	    if (!front.actorID) {
	      throw new Error("Can't manage front without an actor ID.\n" +
	                      "Ensure server supports " + front.typeName + ".");
	    }
	    return Pool.prototype.manage.call(this, front);
	  },

	  /**
	   * @returns a promise that will resolve to the actorID this front
	   * represents.
	   */
	  actor: function () { return promise.resolve(this.actorID); },

	  toString: function () { return "[Front for " + this.typeName + "/" + this.actorID + "]"; },

	  /**
	   * Update the actor from its representation.
	   * Subclasses should override this.
	   */
	  form: function (form) {},

	  /**
	   * Send a packet on the connection.
	   */
	  send: function (packet) {
	    if (packet.to) {
	      this.conn._transport.send(packet);
	    } else {
	      this.actor().then(actorID => {
	        packet.to = actorID;
	        this.conn._transport.send(packet);
	      }).then(null, e => console.error(e));
	    }
	  },

	  /**
	   * Send a two-way request on the connection.
	   */
	  request: function (packet) {
	    let deferred = defer();
	    // Save packet basics for debugging
	    let { to, type } = packet;
	    this._requests.push({
	      deferred,
	      to: to || this.actorID,
	      type,
	      stack: getStack(),
	    });
	    this.send(packet);
	    return deferred.promise;
	  },

	  /**
	   * Handler for incoming packets from the client's actor.
	   */
	  onPacket: function (packet) {
	    // Pick off event packets
	    let type = packet.type || undefined;
	    if (this._clientSpec.events && this._clientSpec.events.has(type)) {
	      let event = this._clientSpec.events.get(packet.type);
	      let args;
	      try {
	        args = event.request.read(packet, this);
	      } catch (ex) {
	        console.error("Error reading event: " + packet.type);
	        console.exception(ex);
	        throw ex;
	      }
	      if (event.pre) {
	        let results = event.pre.map(pre => pre.apply(this, args));

	        // Check to see if any of the preEvents returned a promise -- if so,
	        // wait for their resolution before emitting. Otherwise, emit synchronously.
	        if (results.some(result => result && typeof result.then === "function")) {
	          promise.all(results).then(() => events.emit.apply(null, [this, event.name].concat(args)));
	          return;
	        }
	      }

	      events.emit.apply(null, [this, event.name].concat(args));
	      return;
	    }

	    // Remaining packets must be responses.
	    if (this._requests.length === 0) {
	      let msg = "Unexpected packet " + this.actorID + ", " + JSON.stringify(packet);
	      let err = Error(msg);
	      console.error(err);
	      throw err;
	    }

	    let { deferred, stack } = this._requests.shift();
	    callFunctionWithAsyncStack(() => {
	      if (packet.error) {
	        // "Protocol error" is here to avoid TBPL heuristics. See also
	        // https://dxr.mozilla.org/webtools-central/source/tbpl/php/inc/GeneralErrorFilter.php
	        let message;
	        if (packet.error && packet.message) {
	          message = "Protocol error (" + packet.error + "): " + packet.message;
	        } else {
	          message = packet.error;
	        }
	        deferred.reject(message);
	      } else {
	        deferred.resolve(packet);
	      }
	    }, stack, "DevTools RDP");
	  }
	});
	exports.Front = Front;

	/**
	 * A method tagged with preEvent will be called after recieving a packet
	 * for that event, and before the front emits the event.
	 */
	exports.preEvent = function (eventName, fn) {
	  fn._preEvent = eventName;
	  return fn;
	};

	/**
	 * Mark a method as a custom front implementation, replacing the generated
	 * front method.
	 *
	 * @param function fn
	 *    The front implementation, will be returned.
	 * @param object options
	 *    Options object:
	 *      impl (string): If provided, the generated front method will be
	 *        stored as this property on the prototype.
	 */
	exports.custom = function (fn, options = {}) {
	  fn._customFront = options;
	  return fn;
	};

	function prototypeOf(obj) {
	  return typeof (obj) === "function" ? obj.prototype : obj;
	}

	/**
	 * Generates request methods as described by the given actor specification on
	 * the given front prototype. Returns the front prototype.
	 */
	var generateRequestMethods = function (actorSpec, frontProto) {
	  if (frontProto._actorSpec) {
	    throw new Error("frontProto called twice on the same front prototype!");
	  }

	  frontProto.typeName = actorSpec.typeName;

	  // Generate request methods.
	  let methods = actorSpec.methods;
	  methods.forEach(spec => {
	    let name = spec.name;

	    // If there's already a property by this name in the front, it must
	    // be a custom front method.
	    if (name in frontProto) {
	      let custom = frontProto[spec.name]._customFront;
	      if (custom === undefined) {
	        throw Error("Existing method for " + spec.name + " not marked customFront while processing " + actorType.typeName + ".");
	      }
	      // If the user doesn't need the impl don't generate it.
	      if (!custom.impl) {
	        return;
	      }
	      name = custom.impl;
	    }

	    frontProto[name] = function (...args) {
	      let packet;
	      try {
	        packet = spec.request.write(args, this);
	      } catch (ex) {
	        console.error("Error writing request: " + name);
	        throw ex;
	      }
	      if (spec.oneway) {
	        // Fire-and-forget oneway packets.
	        this.send(packet);
	        return undefined;
	      }

	      return this.request(packet).then(response => {
	        let ret;
	        try {
	          ret = spec.response.read(response, this);
	        } catch (ex) {
	          console.error("Error reading response to: " + name);
	          throw ex;
	        }
	        return ret;
	      });
	    };

	    // Release methods should call the destroy function on return.
	    if (spec.release) {
	      let fn = frontProto[name];
	      frontProto[name] = function (...args) {
	        return fn.apply(this, args).then(result => {
	          this.destroy();
	          return result;
	        });
	      };
	    }
	  });


	  // Process event specifications
	  frontProto._clientSpec = {};

	  let events = actorSpec.events;
	  if (events) {
	    // This actor has events, scan the prototype for preEvent handlers...
	    let preHandlers = new Map();
	    for (let name of Object.getOwnPropertyNames(frontProto)) {
	      let desc = Object.getOwnPropertyDescriptor(frontProto, name);
	      if (!desc.value) {
	        continue;
	      }
	      if (desc.value._preEvent) {
	        let preEvent = desc.value._preEvent;
	        if (!events.has(preEvent)) {
	          throw Error("preEvent for event that doesn't exist: " + preEvent);
	        }
	        let handlers = preHandlers.get(preEvent);
	        if (!handlers) {
	          handlers = [];
	          preHandlers.set(preEvent, handlers);
	        }
	        handlers.push(desc.value);
	      }
	    }

	    frontProto._clientSpec.events = new Map();

	    for (let [name, request] of events) {
	      frontProto._clientSpec.events.set(request.type, {
	        name: name,
	        request: request,
	        pre: preHandlers.get(name)
	      });
	    }
	  }

	  frontProto._actorSpec = actorSpec;

	  return frontProto;
	};

	/**
	 * Create a front class for the given actor class and front prototype.
	 *
	 * @param ActorClass actorType
	 *    The actor class you're creating a front for.
	 * @param object frontProto
	 *    The front prototype.  Must have a 'typeName' property,
	 *    should have method definitions, can have event definitions.
	 */
	exports.FrontClass = function (actorType, frontProto) {
	  return FrontClassWithSpec(prototypeOf(actorType)._actorSpec, frontProto);
	};

	/**
	 * Create a front class for the given actor specification and front prototype.
	 *
	 * @param object actorSpec
	 *    The actor specification you're creating a front for.
	 * @param object proto
	 *    The object prototype.  Must have a 'typeName' property,
	 *    should have method definitions, can have event definitions.
	 */
	var FrontClassWithSpec = function (actorSpec, frontProto) {
	  frontProto.extends = Front;
	  let cls = Class(generateRequestMethods(actorSpec, frontProto));

	  if (!registeredTypes.has(actorSpec.typeName)) {
	    types.addActorType(actorSpec.typeName);
	  }
	  registeredTypes.get(actorSpec.typeName).frontClass = cls;

	  return cls;
	};
	exports.FrontClassWithSpec = FrontClassWithSpec;

	exports.dumpActorSpec = function (type) {
	  let actorSpec = type.actorSpec;
	  let ret = {
	    category: "actor",
	    typeName: type.name,
	    methods: [],
	    events: {}
	  };

	  for (let method of actorSpec.methods) {
	    ret.methods.push({
	      name: method.name,
	      release: method.release || undefined,
	      oneway: method.oneway || undefined,
	      request: method.request.describe(),
	      response: method.response.describe()
	    });
	  }

	  if (actorSpec.events) {
	    for (let [name, request] of actorSpec.events) {
	      ret.events[name] = request.describe();
	    }
	  }


	  JSON.stringify(ret);

	  return ret;
	};

	exports.dumpProtocolSpec = function () {
	  let ret = {
	    types: {},
	  };

	  for (let [name, type] of registeredTypes) {
	    // Force lazy instantiation if needed.
	    type = types.getType(name);
	    let category = type.category || undefined;
	    if (category === "dict") {
	      ret.types[name] = {
	        category: "dict",
	        typeName: name,
	        specializations: type.specializations
	      };
	    } else if (category === "actor") {
	      ret.types[name] = exports.dumpActorSpec(type);
	    }
	  }

	  return ret;
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	'use strict';

	module.metadata = {
	  "stability": "unstable"
	};

	var getPrototypeOf = Object.getPrototypeOf;
	var getNames = x => [...Object.getOwnPropertyNames(x),
	                     ...Object.getOwnPropertySymbols(x)];
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var create = Object.create;
	var freeze = Object.freeze;
	var unbind = Function.call.bind(Function.bind, Function.call);

	// This shortcut makes sure that we do perform desired operations, even if
	// associated methods have being overridden on the used object.
	var owns = unbind(Object.prototype.hasOwnProperty);
	var apply = unbind(Function.prototype.apply);
	var slice = Array.slice || unbind(Array.prototype.slice);
	var reduce = Array.reduce || unbind(Array.prototype.reduce);
	var map = Array.map || unbind(Array.prototype.map);
	var concat = Array.concat || unbind(Array.prototype.concat);

	// Utility function to get own properties descriptor map.
	function getOwnPropertyDescriptors(object) {
	  return reduce(getNames(object), function(descriptor, name) {
	    descriptor[name] = getOwnPropertyDescriptor(object, name);
	    return descriptor;
	  }, {});
	}

	function isDataProperty(property) {
	  var value = property.value;
	  var type = typeof(property.value);
	  return "value" in property &&
	         (type !== "object" || value === null) &&
	         type !== "function";
	}

	function getDataProperties(object) {
	  var properties = getOwnPropertyDescriptors(object);
	  return getNames(properties).reduce(function(result, name) {
	    var property = properties[name];
	    if (isDataProperty(property)) {
	      result[name] = {
	        value: property.value,
	        writable: true,
	        configurable: true,
	        enumerable: false
	      };
	    }
	    return result;
	  }, {})
	}

	/**
	 * Takes `source` object as an argument and returns identical object
	 * with the difference that all own properties will be non-enumerable
	 */
	function obscure(source) {
	  var descriptor = reduce(getNames(source), function(descriptor, name) {
	    var property = getOwnPropertyDescriptor(source, name);
	    property.enumerable = false;
	    descriptor[name] = property;
	    return descriptor;
	  }, {});
	  return create(getPrototypeOf(source), descriptor);
	}
	exports.obscure = obscure;

	/**
	 * Takes arbitrary number of source objects and returns fresh one, that
	 * inherits from the same prototype as a first argument and implements all
	 * own properties of all argument objects. If two or more argument objects
	 * have own properties with the same name, the property is overridden, with
	 * precedence from right to left, implying, that properties of the object on
	 * the left are overridden by a same named property of the object on the right.
	 */
	var mix = function(source) {
	  var descriptor = reduce(slice(arguments), function(descriptor, source) {
	    return reduce(getNames(source), function(descriptor, name) {
	      descriptor[name] = getOwnPropertyDescriptor(source, name);
	      return descriptor;
	    }, descriptor);
	  }, {});

	  return create(getPrototypeOf(source), descriptor);
	};
	exports.mix = mix;

	/**
	 * Returns a frozen object with that inherits from the given `prototype` and
	 * implements all own properties of the given `properties` object.
	 */
	function extend(prototype, properties) {
	  return create(prototype, getOwnPropertyDescriptors(properties));
	}
	exports.extend = extend;

	/**
	 * Returns a constructor function with a proper `prototype` setup. Returned
	 * constructor's `prototype` inherits from a given `options.extends` or
	 * `Class.prototype` if omitted and implements all the properties of the
	 * given `option`. If `options.implemens` array is passed, it's elements
	 * will be mixed into prototype as well. Also, `options.extends` can be
	 * a function or a prototype. If function than it's prototype is used as
	 * an ancestor of the prototype, if it's an object that it's used directly.
	 * Also `options.implements` may contain functions or objects, in case of
	 * functions their prototypes are used for mixing.
	 */
	var Class = new function() {
	  function prototypeOf(input) {
	    return typeof(input) === 'function' ? input.prototype : input;
	  }
	  var none = freeze([]);

	  return function Class(options) {
	    // Create descriptor with normalized `options.extends` and
	    // `options.implements`.
	    var descriptor = {
	      // Normalize extends property of `options.extends` to a prototype object
	      // in case it's constructor. If property is missing that fallback to
	      // `Type.prototype`.
	      extends: owns(options, 'extends') ?
	               prototypeOf(options.extends) : Class.prototype,
	      // Normalize `options.implements` to make sure that it's array of
	      // prototype objects instead of constructor functions.
	      implements: owns(options, 'implements') ?
	                  freeze(map(options.implements, prototypeOf)) : none
	    };

	    // Create array of property descriptors who's properties will be defined
	    // on the resulting prototype. Note: Using reflection `concat` instead of
	    // method as it may be overridden.
	    var descriptors = concat(descriptor.implements, options, descriptor, {
	      constructor: constructor
	    });

	    // Note: we use reflection `apply` in the constructor instead of method
	    // call since later may be overridden.
	    function constructor() {
	      var instance = create(prototype, attributes);
	      if (initialize) apply(initialize, instance, arguments);
	      return instance;
	    }
	    // Create `prototype` that inherits from given ancestor passed as
	    // `options.extends`, falling back to `Type.prototype`, implementing all
	    // properties of given `options.implements` and `options` itself.
	    var prototype = extend(descriptor.extends, mix.apply(mix, descriptors));
	    var initialize = prototype.initialize;

	    // Combine ancestor attributes with prototype's attributes so that
	    // ancestors attributes also become initializeable.
	    var attributes = mix(descriptor.extends.constructor.attributes || {},
	                         getDataProperties(prototype));

	    constructor.attributes = attributes;
	    Object.defineProperty(constructor, 'prototype', {
	      configurable: false,
	      writable: false,
	      value: prototype
	    });
	    return constructor;
	  };
	}
	Class.prototype = extend(null, obscure({
	  constructor: function constructor() {
	    this.initialize.apply(this, arguments);
	    return this;
	  },
	  initialize: function initialize() {
	    // Do your initialization logic here
	  },
	  // Copy useful properties from `Object.prototype`.
	  toString: Object.prototype.toString,
	  toLocaleString: Object.prototype.toLocaleString,
	  toSource: Object.prototype.toSource,
	  valueOf: Object.prototype.valueOf,
	  isPrototypeOf: Object.prototype.isPrototypeOf
	}));
	exports.Class = freeze(Class);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module)))

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	'use strict';

	module.metadata = {
	  "stability": "stable"
	};

	const { on, once, off, setListeners } = __webpack_require__(23);
	const { method, chainable } = __webpack_require__(25);
	const { Class } = __webpack_require__(20);

	/**
	 * `EventTarget` is an exemplar for creating an objects that can be used to
	 * add / remove event listeners on them. Events on these objects may be emitted
	 * via `emit` function exported by 'event/core' module.
	 */
	const EventTarget = Class({
	  /**
	   * Method initializes `this` event source. It goes through properties of a
	   * given `options` and registers listeners for the ones that look like an
	   * event listeners.
	   */
	  /**
	   * Method initializes `this` event source. It goes through properties of a
	   * given `options` and registers listeners for the ones that look like an
	   * event listeners.
	   */
	  initialize: function initialize(options) {
	    setListeners(this, options);
	  },
	  /**
	   * Registers an event `listener` that is called every time events of
	   * specified `type` are emitted.
	   * @param {String} type
	   *    The type of event.
	   * @param {Function} listener
	   *    The listener function that processes the event.
	   * @example
	   *      worker.on('message', function (data) {
	   *        console.log('data received: ' + data)
	   *      })
	   */
	  on: chainable(method(on)),
	  /**
	   * Registers an event `listener` that is called once the next time an event
	   * of the specified `type` is emitted.
	   * @param {String} type
	   *    The type of the event.
	   * @param {Function} listener
	   *    The listener function that processes the event.
	   */
	  once: chainable(method(once)),
	  /**
	   * Removes an event `listener` for the given event `type`.
	   * @param {String} type
	   *    The type of event.
	   * @param {Function} listener
	   *    The listener function that processes the event.
	   */
	  removeListener: function removeListener(type, listener) {
	    // Note: We can't just wrap `off` in `method` as we do it for other methods
	    // cause skipping a second or third argument will behave very differently
	    // than intended. This way we make sure all arguments are passed and only
	    // one listener is removed at most.
	    off(this, type, listener);
	    return this;
	  },
	  // but we can wrap `off` here, as the semantics are the same
	  off: chainable(method(off))

	});
	exports.EventTarget = EventTarget;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module)))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const UNCAUGHT_ERROR = 'An error event was emitted for which there was no listener.';
	const BAD_LISTENER = 'The event listener must be a function.';

	const { ns } = __webpack_require__(24);

	const event = ns();

	const EVENT_TYPE_PATTERN = /^on([A-Z]\w+$)/;
	exports.EVENT_TYPE_PATTERN = EVENT_TYPE_PATTERN;

	// Utility function to access given event `target` object's event listeners for
	// the specific event `type`. If listeners for this type does not exists they
	// will be created.
	const observers = function observers(target, type) {
	  if (!target) throw TypeError("Event target must be an object");
	  let listeners = event(target);
	  return type in listeners ? listeners[type] : listeners[type] = [];
	};

	/**
	 * Registers an event `listener` that is called every time events of
	 * specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function on(target, type, listener) {
	  if (typeof(listener) !== 'function')
	    throw new Error(BAD_LISTENER);

	  let listeners = observers(target, type);
	  if (!~listeners.indexOf(listener))
	    listeners.push(listener);
	}
	exports.on = on;


	var onceWeakMap = new WeakMap();


	/**
	 * Registers an event `listener` that is called only the next time an event
	 * of the specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of the event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function once(target, type, listener) {
	  let replacement = function observer(...args) {
	    off(target, type, observer);
	    onceWeakMap.delete(listener);
	    listener.apply(target, args);
	  };
	  onceWeakMap.set(listener, replacement);
	  on(target, type, replacement);
	}
	exports.once = once;

	/**
	 * Execute each of the listeners in order with the supplied arguments.
	 * All the exceptions that are thrown by listeners during the emit
	 * are caught and can be handled by listeners of 'error' event. Thrown
	 * exceptions are passed as an argument to an 'error' event listener.
	 * If no 'error' listener is registered exception will be logged into an
	 * error console.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @params {Object|Number|String|Boolean} args
	 *    Arguments that will be passed to listeners.
	 */
	function emit (target, type, ...args) {
	  emitOnObject(target, type, target, ...args);
	}
	exports.emit = emit;

	/**
	 * A variant of emit that allows setting the this property for event listeners
	 */
	function emitOnObject(target, type, thisArg, ...args) {
	  let all = observers(target, '*').length;
	  let state = observers(target, type);
	  let listeners = state.slice();
	  let count = listeners.length;
	  let index = 0;

	  // If error event and there are no handlers (explicit or catch-all)
	  // then print error message to the console.
	  if (count === 0 && type === 'error' && all === 0)
	    console.exception(args[0]);
	  while (index < count) {
	    try {
	      let listener = listeners[index];
	      // Dispatch only if listener is still registered.
	      if (~state.indexOf(listener))
	        listener.apply(thisArg, args);
	    }
	    catch (error) {
	      // If exception is not thrown by a error listener and error listener is
	      // registered emit `error` event. Otherwise dump exception to the console.
	      if (type !== 'error') emit(target, 'error', error);
	      else console.exception(error);
	    }
	    index++;
	  }
	   // Also emit on `"*"` so that one could listen for all events.
	  if (type !== '*') emit(target, '*', type, ...args);
	}
	exports.emitOnObject = emitOnObject;

	/**
	 * Removes an event `listener` for the given event `type` on the given event
	 * `target`. If no `listener` is passed removes all listeners of the given
	 * `type`. If `type` is not passed removes all the listeners of the given
	 * event `target`.
	 * @param {Object} target
	 *    The event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function off(target, type, listener) {
	  let length = arguments.length;
	  if (length === 3) {
	    if (onceWeakMap.has(listener)) {
	      listener = onceWeakMap.get(listener);
	      onceWeakMap.delete(listener);
	    }

	    let listeners = observers(target, type);
	    let index = listeners.indexOf(listener);
	    if (~index)
	      listeners.splice(index, 1);
	  }
	  else if (length === 2) {
	    observers(target, type).splice(0);
	  }
	  else if (length === 1) {
	    let listeners = event(target);
	    Object.keys(listeners).forEach(type => delete listeners[type]);
	  }
	}
	exports.off = off;

	/**
	 * Returns a number of event listeners registered for the given event `type`
	 * on the given event `target`.
	 */
	function count(target, type) {
	  return observers(target, type).length;
	}
	exports.count = count;

	/**
	 * Registers listeners on the given event `target` from the given `listeners`
	 * dictionary. Iterates over the listeners and if property name matches name
	 * pattern `onEventType` and property is a function, then registers it as
	 * an `eventType` listener on `target`.
	 *
	 * @param {Object} target
	 *    The type of event.
	 * @param {Object} listeners
	 *    Dictionary of listeners.
	 */
	function setListeners(target, listeners) {
	  Object.keys(listeners || {}).forEach(key => {
	    let match = EVENT_TYPE_PATTERN.exec(key);
	    let type = match && match[1].toLowerCase();
	    if (!type) return;

	    let listener = listeners[key];
	    if (typeof(listener) === 'function')
	      on(target, type, listener);
	  });
	}
	exports.setListeners = setListeners;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module)))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const create = Object.create;
	const prototypeOf = Object.getPrototypeOf;

	/**
	 * Returns a new namespace, function that may can be used to access an
	 * namespaced object of the argument argument. Namespaced object are associated
	 * with owner objects via weak references. Namespaced objects inherit from the
	 * owners ancestor namespaced object. If owner's ancestor is `null` then
	 * namespaced object inherits from given `prototype`. Namespaces can be used
	 * to define internal APIs that can be shared via enclosing `namespace`
	 * function.
	 * @examples
	 *    const internals = ns();
	 *    internals(object).secret = secret;
	 */
	function ns() {
	  const map = new WeakMap();
	  return function namespace(target) {
	    if (!target)        // If `target` is not an object return `target` itself.
	      return target;
	    // If target has no namespaced object yet, create one that inherits from
	    // the target prototype's namespaced object.
	    if (!map.has(target))
	      map.set(target, create(namespace(prototypeOf(target) || null)));

	    return map.get(target);
	  };
	};

	// `Namespace` is a e4x function in the scope, so we export the function also as
	// `ns` as alias to avoid clashing.
	exports.ns = ns;
	exports.Namespace = ns;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Disclaimer: Some of the functions in this module implement APIs from
	// Jeremy Ashkenas's http://underscorejs.org/ library and all credits for
	// those goes to him.

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	}
	const { arity, name, derive, invoke } = __webpack_require__(26);

	/**
	 * Takes variadic numeber of functions and returns composed one.
	 * Returned function pushes `this` pseudo-variable to the head
	 * of the passed arguments and invokes all the functions from
	 * left to right passing same arguments to them. Composite function
	 * returns return value of the right most funciton.
	 */
	const method = (...lambdas) => {
	  return function method(...args) {
	    args.unshift(this);
	    return lambdas.reduce((_, lambda) => lambda.apply(this, args),
	                          void(0));
	  };
	};
	exports.method = method;

	/**
	 * Invokes `callee` by passing `params` as an arguments and `self` as `this`
	 * pseudo-variable. Returns value that is returned by a callee.
	 * @param {Function} callee
	 *    Function to invoke.
	 * @param {Array} params
	 *    Arguments to invoke function with.
	 * @param {Object} self
	 *    Object to be passed as a `this` pseudo variable.
	 */
	exports.invoke = invoke;

	/**
	 * Takes a function and bind values to one or more arguments, returning a new
	 * function of smaller arity.
	 *
	 * @param {Function} fn
	 *    The function to partial
	 *
	 * @returns The new function with binded values
	 */
	const partial = (f, ...curried) => {
	  if (typeof(f) !== "function")
	    throw new TypeError(String(f) + " is not a function");

	  let fn = derive(function(...args) {
	    return f.apply(this, curried.concat(args));
	  }, f);
	  fn.arity = arity(f) - curried.length;
	  return fn;
	};
	exports.partial = partial;

	/**
	 * Returns function with implicit currying, which will continue currying until
	 * expected number of argument is collected. Expected number of arguments is
	 * determined by `fn.length`. Using this with variadic functions is stupid,
	 * so don't do it.
	 *
	 * @examples
	 *
	 * var sum = curry(function(a, b) {
	 *   return a + b
	 * })
	 * console.log(sum(2, 2)) // 4
	 * console.log(sum(2)(4)) // 6
	 */
	const curry = new function() {
	  const currier = (fn, arity, params) => {
	    // Function either continues to curry arguments or executes function
	    // if desired arguments have being collected.
	    const curried = function(...input) {
	      // Prepend all curried arguments to the given arguments.
	      if (params) input.unshift.apply(input, params);
	      // If expected number of arguments has being collected invoke fn,
	      // othrewise return curried version Otherwise continue curried.
	      return (input.length >= arity) ? fn.apply(this, input) :
	             currier(fn, arity, input);
	    };
	    curried.arity = arity - (params ? params.length : 0);

	    return curried;
	  };

	  return fn => currier(fn, arity(fn));
	};
	exports.curry = curry;

	/**
	 * Returns the composition of a list of functions, where each function consumes
	 * the return value of the function that follows. In math terms, composing the
	 * functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
	 * @example
	 *
	 *   var greet = function(name) { return "hi: " + name; };
	 *   var exclaim = function(statement) { return statement + "!"; };
	 *   var welcome = compose(exclaim, greet);
	 *
	 *   welcome('moe');    // => 'hi: moe!'
	 */
	function compose(...lambdas) {
	  return function composed(...args) {
	    let index = lambdas.length;
	    while (0 <= --index)
	      args = [lambdas[index].apply(this, args)];

	    return args[0];
	  };
	}
	exports.compose = compose;

	/*
	 * Returns the first function passed as an argument to the second,
	 * allowing you to adjust arguments, run code before and after, and
	 * conditionally execute the original function.
	 * @example
	 *
	 *  var hello = function(name) { return "hello: " + name; };
	 *  hello = wrap(hello, function(f) {
	 *    return "before, " + f("moe") + ", after";
	 *  });
	 *
	 *  hello();    // => 'before, hello: moe, after'
	 */
	const wrap = (f, wrapper) => derive(function wrapped(...args) {
	  return wrapper.apply(this, [f].concat(args));
	}, f);
	exports.wrap = wrap;

	/**
	 * Returns the same value that is used as the argument. In math: f(x) = x
	 */
	const identity = value => value;
	exports.identity = identity;

	/**
	 * Memoizes a given function by caching the computed result. Useful for
	 * speeding up slow-running computations. If passed an optional hashFunction,
	 * it will be used to compute the hash key for storing the result, based on
	 * the arguments to the original function. The default hashFunction just uses
	 * the first argument to the memoized function as the key.
	 */
	const memoize = (f, hasher) => {
	  let memo = Object.create(null);
	  let cache = new WeakMap();
	  hasher = hasher || identity;
	  return derive(function memoizer(...args) {
	    const key = hasher.apply(this, args);
	    const type = typeof(key);
	    if (key && (type === "object" || type === "function")) {
	      if (!cache.has(key))
	        cache.set(key, f.apply(this, args));
	      return cache.get(key);
	    }
	    else {
	      if (!(key in memo))
	        memo[key] = f.apply(this, args);
	      return memo[key];
	    }
	  }, f);
	};
	exports.memoize = memoize;

	/*
	 * Creates a version of the function that can only be called one time. Repeated
	 * calls to the modified function will have no effect, returning the value from
	 * the original call. Useful for initialization functions, instead of having to
	 * set a boolean flag and then check it later.
	 */
	const once = f => {
	  let ran = false, cache;
	  return derive(function(...args) {
	    return ran ? cache : (ran = true, cache = f.apply(this, args));
	  }, f);
	};
	exports.once = once;
	// export cache as once will may be conflicting with event once a lot.
	exports.cache = once;

	// Takes a `f` function and returns a function that takes the same
	// arguments as `f`, has the same effects, if any, and returns the
	// opposite truth value.
	const complement = f => derive(function(...args) {
	  return args.length < arity(f) ? complement(partial(f, ...args)) :
	         !f.apply(this, args);
	}, f);
	exports.complement = complement;

	// Constructs function that returns `x` no matter what is it
	// invoked with.
	const constant = x => _ => x;
	exports.constant = constant;

	// Takes `p` predicate, `consequent` function and an optional
	// `alternate` function and composes function that returns
	// application of arguments over `consequent` if application over
	// `p` is `true` otherwise returns application over `alternate`.
	// If `alternate` is not a function returns `undefined`.
	const when = (p, consequent, alternate) => {
	  if (typeof(alternate) !== "function" && alternate !== void(0))
	    throw TypeError("alternate must be a function");
	  if (typeof(consequent) !== "function")
	    throw TypeError("consequent must be a function");

	  return function(...args) {
	    return p.apply(this, args) ?
	           consequent.apply(this, args) :
	           alternate && alternate.apply(this, args);
	  };
	};
	exports.when = when;

	// Apply function that behaves as `apply` does in lisp:
	// apply(f, x, [y, z]) => f.apply(f, [x, y, z])
	// apply(f, x) => f.apply(f, [x])
	const apply = (f, ...rest) => f.apply(f, rest.concat(rest.pop()));
	exports.apply = apply;

	// Returns function identical to given `f` but with flipped order
	// of arguments.
	const flip = f => derive(function(...args) {
	  return f.apply(this, args.reverse());
	}, f);
	exports.flip = flip;

	// Takes field `name` and `target` and returns value of that field.
	// If `target` is `null` or `undefined` it would be returned back
	// instead of attempt to access it's field. Function is implicitly
	// curried, this allows accessor function generation by calling it
	// with only `name` argument.
	const field = curry((name, target) =>
	  // Note: Permisive `==` is intentional.
	  target == null ? target : target[name]);
	exports.field = field;

	// Takes `.` delimited string representing `path` to a nested field
	// and a `target` to get it from. For convinience function is
	// implicitly curried, there for accessors can be created by invoking
	// it with just a `path` argument.
	const query = curry((path, target) => {
	  const names = path.split(".");
	  const count = names.length;
	  let index = 0;
	  let result = target;
	  // Note: Permisive `!=` is intentional.
	  while (result != null && index < count) {
	    result = result[names[index]];
	    index = index + 1;
	  }
	  return result;
	});
	exports.query = query;

	// Takes `Type` (constructor function) and a `value` and returns
	// `true` if `value` is instance of the given `Type`. Function is
	// implicitly curried this allows predicate generation by calling
	// function with just first argument.
	const isInstance = curry((Type, value) => value instanceof Type);
	exports.isInstance = isInstance;

	/*
	 * Takes a funtion and returns a wrapped function that returns `this`
	 */
	const chainable = f => derive(function(...args) {
	  f.apply(this, args);
	  return this;
	}, f);
	exports.chainable = chainable;

	// Functions takes `expected` and `actual` values and returns `true` if
	// `expected === actual`. Returns curried function if called with less then
	// two arguments.
	//
	// [ 1, 0, 1, 0, 1 ].map(is(1)) // => [ true, false, true, false, true ]
	const is = curry((expected, actual) => actual === expected);
	exports.is = is;

	const isnt = complement(is);
	exports.isnt = isnt;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Disclaimer: Some of the functions in this module implement APIs from
	// Jeremy Ashkenas's http://underscorejs.org/ library and all credits for
	// those goes to him.

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	}

	const arity = f => f.arity || f.length;
	exports.arity = arity;

	const name = f => f.displayName || f.name;
	exports.name = name;

	const derive = (f, source) => {
	  f.displayName = name(source);
	  f.arity = arity(source);
	  return f;
	};
	exports.derive = derive;

	const invoke = (callee, params, self) => callee.apply(self, params);
	exports.invoke = invoke;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module)))

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const { flatten } = __webpack_require__(28);

	/**
	 * Merges all the properties of all arguments into first argument. If two or
	 * more argument objects have own properties with the same name, the property
	 * is overridden, with precedence from right to left, implying, that properties
	 * of the object on the left are overridden by a same named property of the
	 * object on the right.
	 *
	 * Any argument given with "falsy" value - commonly `null` and `undefined` in
	 * case of objects - are skipped.
	 *
	 * @examples
	 *    var a = { bar: 0, a: 'a' }
	 *    var b = merge(a, { foo: 'foo', bar: 1 }, { foo: 'bar', name: 'b' });
	 *    b === a   // true
	 *    b.a       // 'a'
	 *    b.foo     // 'bar'
	 *    b.bar     // 1
	 *    b.name    // 'b'
	 */
	function merge(source) {
	  let descriptor = {};

	  // `Boolean` converts the first parameter to a boolean value. Any object is
	  // converted to `true` where `null` and `undefined` becames `false`. Therefore
	  // the `filter` method will keep only objects that are defined and not null.
	  [].slice.call(arguments, 1).filter(Boolean).forEach(function onEach(properties) {
	    getOwnPropertyIdentifiers(properties).forEach(function(name) {
	      descriptor[name] = Object.getOwnPropertyDescriptor(properties, name);
	    });
	  });
	  return Object.defineProperties(source, descriptor);
	}
	exports.merge = merge;

	/**
	 * Returns an object that inherits from the first argument and contains all the
	 * properties from all following arguments.
	 * `extend(source1, source2, source3)` is equivalent of
	 * `merge(Object.create(source1), source2, source3)`.
	 */
	function extend(source) {
	  let rest = Array.slice(arguments, 1);
	  rest.unshift(Object.create(source));
	  return merge.apply(null, rest);
	}
	exports.extend = extend;

	function has(obj, key) {
	  return obj.hasOwnProperty(key);
	}
	exports.has = has;

	function each(obj, fn) {
	  for (let key in obj) has(obj, key) && fn(obj[key], key, obj);
	}
	exports.each = each;

	/**
	 * Like `merge`, except no property descriptors are manipulated, for use
	 * with platform objects. Identical to underscore's `extend`. Useful for
	 * merging XPCOM objects
	 */
	function safeMerge(source) {
	  [].slice.call(arguments, 1).forEach(function onEach (obj) {
	    for (let prop in obj) source[prop] = obj[prop];
	  });
	  return source;
	}
	exports.safeMerge = safeMerge;

	/*
	 * Returns a copy of the object without omitted properties
	 */
	function omit(source, ...values) {
	  let copy = {};
	  let keys = flatten(values);
	  for (let prop in source)
	    if (!~keys.indexOf(prop))
	      copy[prop] = source[prop];
	  return copy;
	}
	exports.omit = omit;

	// get object's own property Symbols and/or Names, including nonEnumerables by default
	function getOwnPropertyIdentifiers(object, options = { names: true, symbols: true, nonEnumerables: true }) {
	  const symbols = !options.symbols ? [] :
	                  Object.getOwnPropertySymbols(object);
	  const names = !options.names ? [] :
	                options.nonEnumerables ? Object.getOwnPropertyNames(object) :
	                Object.keys(object);
	  return [...names, ...symbols];
	}
	exports.getOwnPropertyIdentifiers = getOwnPropertyIdentifiers;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module)))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "experimental"
	};

	/**
	 * Returns `true` if given `array` contain given `element` or `false`
	 * otherwise.
	 * @param {Array} array
	 *    Target array.
	 * @param {Object|String|Number|Boolean} element
	 *    Element being looked up.
	 * @returns {Boolean}
	 */
	var has = exports.has = function has(array, element) {
	  // shorter and faster equivalent of `array.indexOf(element) >= 0`
	  return !!~array.indexOf(element);
	};
	var hasAny = exports.hasAny = function hasAny(array, elements) {
	  if (arguments.length < 2)
	    return false;
	  if (!Array.isArray(elements))
	    elements = [ elements ];
	  return array.some(function (element) {
	      return has(elements, element);
	  });
	};

	/**
	 * Adds given `element` to the given `array` if it does not contain it yet.
	 * `true` is returned if element was added otherwise `false` is returned.
	 * @param {Array} array
	 *    Target array.
	 * @param {Object|String|Number|Boolean} element
	 *    Element to be added.
	 * @returns {Boolean}
	 */
	var add = exports.add = function add(array, element) {
	  var result;
	  if ((result = !has(array, element)))
	    array.push(element);

	  return result;
	};

	/**
	 * Removes first occurrence of the given `element` from the given `array`. If
	 * `array` does not contain given `element` `false` is returned otherwise
	 * `true` is returned.
	 * @param {Array} array
	 *    Target array.
	 * @param {Object|String|Number|Boolean} element
	 *    Element to be removed.
	 * @returns {Boolean}
	 */
	exports.remove = function remove(array, element) {
	  var result;
	  if ((result = has(array, element)))
	    array.splice(array.indexOf(element), 1);

	  return result;
	};

	/**
	 * Produces a duplicate-free version of the given `array`.
	 * @param {Array} array
	 *    Source array.
	 * @returns {Array}
	 */
	function unique(array) {
	  return array.reduce(function(result, item) {
	    add(result, item);
	    return result;
	  }, []);
	};
	exports.unique = unique;

	/**
	 * Produce an array that contains the union: each distinct element from all
	 * of the passed-in arrays.
	 */
	function union() {
	  return unique(Array.concat.apply(null, arguments));
	};
	exports.union = union;

	exports.flatten = function flatten(array){
	   var flat = [];
	   for (var i = 0, l = array.length; i < l; i++) {
	    flat = flat.concat(Array.isArray(array[i]) ? flatten(array[i]) : array[i]);
	   }
	   return flat;
	};

	function fromIterator(iterator) {
	  let array = [];
	  if (iterator.__iterator__) {
	    for (let item of iterator)
	      array.push(item);
	  }
	  else {
	    for (let item of iterator)
	      array.push(item);
	  }
	  return array;
	}
	exports.fromIterator = fromIterator;

	function find(array, predicate, fallback) {
	  var index = 0;
	  var count = array.length;
	  while (index < count) {
	    var value = array[index];
	    if (predicate(value)) return value;
	    else index = index + 1;
	  }
	  return fallback;
	}
	exports.find = find;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module)))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const protocol = __webpack_require__(19);
	const {Arg, RetVal, generateActorSpec} = protocol;
	const promise = __webpack_require__(4);
	const {Class} = __webpack_require__(20);

	const longStringSpec = generateActorSpec({
	  typeName: "longstractor",

	  methods: {
	    substring: {
	      request: {
	        start: Arg(0),
	        end: Arg(1)
	      },
	      response: { substring: RetVal() },
	    },
	    release: { release: true },
	  },
	});

	exports.longStringSpec = longStringSpec;

	/**
	 * When a caller is expecting a LongString actor but the string is already available on
	 * client, the SimpleStringFront can be used as it shares the same API as a
	 * LongStringFront but will not make unnecessary trips to the server.
	 */
	const SimpleStringFront = Class({
	  initialize: function (str) {
	    this.str = str;
	  },

	  get length() {
	    return this.str.length;
	  },

	  get initial() {
	    return this.str;
	  },

	  string: function () {
	    return promise.resolve(this.str);
	  },

	  substring: function (start, end) {
	    return promise.resolve(this.str.substring(start, end));
	  },

	  release: function () {
	    this.str = null;
	    return promise.resolve(undefined);
	  }
	});

	exports.SimpleStringFront = SimpleStringFront;

	// The long string actor needs some custom marshalling, because it is sometimes
	// returned as a primitive rather than a complete form.

	var stringActorType = protocol.types.getType("longstractor");
	protocol.types.addType("longstring", {
	  _actor: true,
	  write: (value, context, detail) => {
	    if (!(context instanceof protocol.Actor)) {
	      throw Error("Passing a longstring as an argument isn't supported.");
	    }

	    if (value.short) {
	      return value.str;
	    }
	    return stringActorType.write(value, context, detail);
	  },
	  read: (value, context, detail) => {
	    if (context instanceof protocol.Actor) {
	      throw Error("Passing a longstring as an argument isn't supported.");
	    }
	    if (typeof (value) === "string") {
	      return new SimpleStringFront(value);
	    }
	    return stringActorType.read(value, context, detail);
	  }
	});


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Arg, RetVal, generateActorSpec } = __webpack_require__(19);

	const cssPropertiesSpec = generateActorSpec({
	  typeName: "cssProperties",

	  methods: {
	    getCSSDatabase: {
	      request: {
	        clientBrowserVersion: Arg(0, "string"),
	      },

	      response: RetVal("json"),
	    }
	  }
	});

	exports.cssPropertiesSpec = cssPropertiesSpec;


/***/ },
/* 31 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * This file contains static lists of CSS properties and values. Some of the small lists
	 * are edited manually, while the larger ones are generated by a script. The comments
	 * above each list indicates how it should be updated.
	 */

	/**
	 * All CSS types that properties can support. This list can be manually edited.
	 */
	exports.CSS_TYPES = {
	  "ANGLE": 1,
	  "COLOR": 2,
	  "FREQUENCY": 3,
	  "GRADIENT": 4,
	  "IMAGE_RECT": 5,
	  "LENGTH": 6,
	  "NUMBER": 7,
	  "PERCENTAGE": 8,
	  "TIME": 9,
	  "TIMING_FUNCTION": 10,
	  "URL": 11,
	};

	/**
	 * All cubic-bezier CSS timing-function names. This list can be manually edited.
	 */
	exports.BEZIER_KEYWORDS = ["linear", "ease-in-out", "ease-in", "ease-out", "ease"];

	/**
	 * Functions that accept a color argument. This list can be manually edited.
	 */
	exports.COLOR_TAKING_FUNCTIONS = ["linear-gradient", "-moz-linear-gradient",
	                                  "repeating-linear-gradient",
	                                  "-moz-repeating-linear-gradient", "radial-gradient",
	                                  "-moz-radial-gradient", "repeating-radial-gradient",
	                                  "-moz-repeating-radial-gradient", "drop-shadow"];

	/**
	 * Functions that accept an angle argument. This list can be manually edited.
	 */
	exports.ANGLE_TAKING_FUNCTIONS = ["linear-gradient", "-moz-linear-gradient",
	                                  "repeating-linear-gradient",
	                                  "-moz-repeating-linear-gradient", "rotate", "rotateX",
	                                  "rotateY", "rotateZ", "rotate3d", "skew", "skewX",
	                                  "skewY", "hue-rotate"];

	/**
	 * The list of all CSS Pseudo Elements. This list MUST be automatically generated.
	 *
	 * The following script will copy the pseudo-elements to your clipboard if run from the
	 * Browser Console, which can be launched from Tools -> Web Developer -> Browser Console.

	var domUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	var json = JSON.stringify(domUtils.getCSSPseudoElementNames(), null, 0);
	copy(`exports.PSEUDO_ELEMENTS = ${json};\n`);
	console.log("The PSEUDO_ELEMENTS have been copied to your clipboard.")
	 */

	/*eslint-disable */
	exports.PSEUDO_ELEMENTS = [":after",":before",":backdrop",":first-letter",":first-line",":-moz-selection",":-moz-focus-inner",":-moz-focus-outer",":-moz-list-bullet",":-moz-list-number",":-moz-math-anonymous",":-moz-progress-bar",":-moz-range-track",":-moz-range-progress",":-moz-range-thumb",":-moz-meter-bar",":-moz-placeholder",":-moz-color-swatch"];
	/*eslint-enable */

	/**
	 * A list of CSS Properties and their various characteristics. This is used on the
	 * client-side when the CssPropertiesActor is not found, or when the client and server
	 * are the same version. A single property takes the form:
	 *
	 *  "animation": {
	 *    "isInherited": false,
	 *    "supports": [ 7, 9, 10 ]
	 *  }
	 *
	 * The following script will copy the CSS properties to your clipboard if run from the
	 * Browser Console, which can be launched from Tools -> Web Developer -> Browser Console.

	var {require} = Components.utils.import("resource://devtools/shared/Loader.jsm", {});
	var {generateCssProperties} = require("devtools/server/actors/css-properties");
	var cssProperties = generateCssProperties();
	for (var key in cssProperties) {
	  // Ignore OS-specific properties
	  if (key.indexOf('-moz-osx-') !== -1) {
	    cssProperties[key] = undefined;
	  }
	}
	var json = JSON.stringify(cssProperties, null, 0);
	copy(`exports.CSS_PROPERTIES = ${json};\n`);
	console.log("The CSS_PROPERTIES have been copied to your clipboard.");
	 */

	/*eslint-disable */
	exports.CSS_PROPERTIES = {"align-content":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","space-around","space-between","space-evenly","start","stretch","unset"]},"align-items":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"align-self":{"isInherited":false,"supports":[],"values":["auto","baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"animation-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"animation-direction":{"isInherited":false,"supports":[],"values":["alternate","alternate-reverse","inherit","initial","normal","reverse","unset"]},"animation-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"animation-fill-mode":{"isInherited":false,"supports":[],"values":["backwards","both","forwards","inherit","initial","none","unset"]},"animation-iteration-count":{"isInherited":false,"supports":[7],"values":["infinite","inherit","initial","unset"]},"animation-name":{"isInherited":false,"supports":[],"values":["inherit","initial","none","unset"]},"animation-play-state":{"isInherited":false,"supports":[],"values":["inherit","initial","paused","running","unset"]},"animation-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-moz-appearance":{"isInherited":false,"supports":[],"values":["-moz-gtk-info-bar","-moz-mac-disclosure-button-closed","-moz-mac-disclosure-button-open","-moz-mac-fullscreen-button","-moz-mac-help-button","-moz-mac-source-list","-moz-mac-vibrancy-dark","-moz-mac-vibrancy-light","-moz-win-borderless-glass","-moz-win-browsertabbar-toolbox","-moz-win-communications-toolbox","-moz-win-exclude-glass","-moz-win-glass","-moz-win-media-toolbox","-moz-window-button-box","-moz-window-button-box-maximized","-moz-window-button-close","-moz-window-button-maximize","-moz-window-button-minimize","-moz-window-button-restore","-moz-window-frame-bottom","-moz-window-frame-left","-moz-window-frame-right","-moz-window-titlebar","-moz-window-titlebar-maximized","button","button-arrow-down","button-arrow-next","button-arrow-previous","button-arrow-up","button-bevel","button-focus","caret","checkbox","checkbox-container","checkbox-label","checkmenuitem","dialog","dualbutton","groupbox","inherit","initial","listbox","listitem","menuarrow","menubar","menucheckbox","menuimage","menuitem","menuitemtext","menulist","menulist-button","menulist-text","menulist-textfield","menupopup","menuradio","menuseparator","meterbar","meterchunk","none","number-input","progressbar","progressbar-vertical","progresschunk","progresschunk-vertical","radio","radio-container","radio-label","radiomenuitem","range","range-thumb","resizer","resizerpanel","scale-horizontal","scale-vertical","scalethumb-horizontal","scalethumb-vertical","scalethumbend","scalethumbstart","scalethumbtick","scrollbar","scrollbar-horizontal","scrollbar-small","scrollbar-vertical","scrollbarbutton-down","scrollbarbutton-left","scrollbarbutton-right","scrollbarbutton-up","scrollbarthumb-horizontal","scrollbarthumb-vertical","scrollbartrack-horizontal","scrollbartrack-vertical","searchfield","separator","spinner","spinner-downbutton","spinner-textfield","spinner-upbutton","splitter","statusbar","statusbarpanel","tab","tab-scroll-arrow-back","tab-scroll-arrow-forward","tabpanel","tabpanels","textfield","textfield-multiline","toolbar","toolbarbutton","toolbarbutton-dropdown","toolbargripper","toolbox","tooltip","treeheader","treeheadercell","treeheadersortarrow","treeitem","treeline","treetwisty","treetwistyopen","treeview","unset","window"]},"backface-visibility":{"isInherited":false,"supports":[],"values":["hidden","inherit","initial","unset","visible"]},"background-attachment":{"isInherited":false,"supports":[],"values":["fixed","inherit","initial","local","scroll","unset"]},"background-blend-mode":{"isInherited":false,"supports":[],"values":["color","color-burn","color-dodge","darken","difference","exclusion","hard-light","hue","inherit","initial","lighten","luminosity","multiply","normal","overlay","saturation","screen","soft-light","unset"]},"background-clip":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","padding-box","text","unset"]},"background-color":{"isInherited":false,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"background-image":{"isInherited":false,"supports":[4,5,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"background-origin":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","padding-box","unset"]},"background-position-x":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"background-position-y":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"background-repeat":{"isInherited":false,"supports":[],"values":["inherit","initial","no-repeat","repeat","repeat-x","repeat-y","round","space","unset"]},"background-size":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-binding":{"isInherited":false,"supports":[11],"values":["inherit","initial","none","unset","url"]},"block-size":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"border-block-end-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-block-end-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-block-end-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-block-start-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-block-start-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-block-start-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-bottom-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-bottom-colors":{"isInherited":false,"supports":[2],"values":["inherit","initial","unset"]},"border-bottom-left-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-bottom-right-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-bottom-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-bottom-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-collapse":{"isInherited":true,"supports":[],"values":["collapse","inherit","initial","separate","unset"]},"border-image-outset":{"isInherited":false,"supports":[6,7],"values":["inherit","initial","unset"]},"border-image-repeat":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"border-image-slice":{"isInherited":false,"supports":[7,8],"values":["inherit","initial","unset"]},"border-image-source":{"isInherited":false,"supports":[4,5,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"border-image-width":{"isInherited":false,"supports":[6,7,8],"values":["inherit","initial","unset"]},"border-inline-end-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-inline-end-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-inline-end-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-inline-start-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-inline-start-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-inline-start-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-left-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-left-colors":{"isInherited":false,"supports":[2],"values":["inherit","initial","unset"]},"border-left-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-left-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-right-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-right-colors":{"isInherited":false,"supports":[2],"values":["inherit","initial","unset"]},"border-right-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-right-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-spacing":{"isInherited":true,"supports":[6],"values":["inherit","initial","unset"]},"border-top-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-top-colors":{"isInherited":false,"supports":[2],"values":["inherit","initial","unset"]},"border-top-left-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-top-right-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-top-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-top-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"bottom":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-box-align":{"isInherited":false,"supports":[],"values":["baseline","center","end","inherit","initial","start","stretch","unset"]},"box-decoration-break":{"isInherited":false,"supports":[],"values":["clone","inherit","initial","slice","unset"]},"-moz-box-direction":{"isInherited":false,"supports":[],"values":["inherit","initial","normal","reverse","unset"]},"-moz-box-flex":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-moz-box-ordinal-group":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-moz-box-orient":{"isInherited":false,"supports":[],"values":["block-axis","horizontal","inherit","initial","inline-axis","unset","vertical"]},"-moz-box-pack":{"isInherited":false,"supports":[],"values":["center","end","inherit","initial","justify","start","unset"]},"box-shadow":{"isInherited":false,"supports":[2,6],"values":["inherit","initial","unset"]},"box-sizing":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","unset"]},"caption-side":{"isInherited":true,"supports":[],"values":["bottom","bottom-outside","inherit","initial","left","right","top","top-outside","unset"]},"clear":{"isInherited":false,"supports":[],"values":["both","inherit","initial","inline-end","inline-start","left","none","right","unset"]},"clip":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"clip-path":{"isInherited":false,"supports":[11],"values":["inherit","initial","unset"]},"clip-rule":{"isInherited":true,"supports":[],"values":["evenodd","inherit","initial","nonzero","unset"]},"color":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"color-adjust":{"isInherited":true,"supports":[],"values":["economy","exact","inherit","initial","unset"]},"color-interpolation":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","linearrgb","srgb","unset"]},"color-interpolation-filters":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","linearrgb","srgb","unset"]},"-moz-column-count":{"isInherited":false,"supports":[7],"values":["auto","inherit","initial","unset"]},"-moz-column-fill":{"isInherited":false,"supports":[],"values":["auto","balance","inherit","initial","unset"]},"-moz-column-gap":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","normal","unset"]},"-moz-column-rule-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-column-rule-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"-moz-column-rule-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-column-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"content":{"isInherited":false,"supports":[11],"values":["inherit","initial","unset"]},"-moz-control-character-visibility":{"isInherited":true,"supports":[],"values":["hidden","inherit","initial","unset","visible"]},"counter-increment":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"counter-reset":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"cursor":{"isInherited":true,"supports":[11],"values":["inherit","initial","unset"]},"direction":{"isInherited":true,"supports":[],"values":["inherit","initial","ltr","rtl","unset"]},"display":{"isInherited":false,"supports":[],"values":["-moz-box","-moz-deck","-moz-grid","-moz-grid-group","-moz-grid-line","-moz-groupbox","-moz-inline-box","-moz-inline-grid","-moz-inline-stack","-moz-popup","-moz-stack","-webkit-box","-webkit-flex","-webkit-inline-box","-webkit-inline-flex","block","contents","flex","grid","inherit","initial","inline","inline-block","inline-flex","inline-grid","inline-table","list-item","none","ruby","ruby-base","ruby-base-container","ruby-text","ruby-text-container","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","unset"]},"dominant-baseline":{"isInherited":false,"supports":[],"values":["alphabetic","auto","central","hanging","ideographic","inherit","initial","mathematical","middle","no-change","reset-size","text-after-edge","text-before-edge","unset","use-script"]},"empty-cells":{"isInherited":true,"supports":[],"values":["hide","inherit","initial","show","unset"]},"fill":{"isInherited":true,"supports":[2,11],"values":["inherit","initial","unset"]},"fill-opacity":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"fill-rule":{"isInherited":true,"supports":[],"values":["evenodd","inherit","initial","nonzero","unset"]},"filter":{"isInherited":false,"supports":[11],"values":["inherit","initial","unset"]},"flex-basis":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"flex-direction":{"isInherited":false,"supports":[],"values":["column","column-reverse","inherit","initial","row","row-reverse","unset"]},"flex-grow":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"flex-shrink":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"flex-wrap":{"isInherited":false,"supports":[],"values":["inherit","initial","nowrap","unset","wrap","wrap-reverse"]},"float":{"isInherited":false,"supports":[],"values":["inherit","initial","inline-end","inline-start","left","none","right","unset"]},"-moz-float-edge":{"isInherited":false,"supports":[],"values":["content-box","inherit","initial","margin-box","unset"]},"flood-color":{"isInherited":false,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"flood-opacity":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"font-family":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-feature-settings":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-kerning":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","none","normal","unset"]},"font-language-override":{"isInherited":true,"supports":[],"values":["inherit","initial","normal","unset"]},"font-size":{"isInherited":true,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","large","larger","medium","small","smaller","unset","x-large","x-small","xx-large","xx-small"]},"font-size-adjust":{"isInherited":true,"supports":[7],"values":["inherit","initial","none","unset"]},"font-stretch":{"isInherited":true,"supports":[],"values":["condensed","expanded","extra-condensed","extra-expanded","inherit","initial","normal","semi-condensed","semi-expanded","ultra-condensed","ultra-expanded","unset"]},"font-style":{"isInherited":true,"supports":[],"values":["inherit","initial","italic","normal","oblique","unset"]},"font-synthesis":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-alternates":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-caps":{"isInherited":true,"supports":[],"values":["all-petite-caps","all-small-caps","inherit","initial","normal","petite-caps","small-caps","titling-caps","unicase","unset"]},"font-variant-east-asian":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-ligatures":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-numeric":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-position":{"isInherited":true,"supports":[],"values":["inherit","initial","normal","sub","super","unset"]},"font-weight":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"-moz-force-broken-image-icon":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-auto-columns":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"grid-auto-flow":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"grid-auto-rows":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"grid-column-end":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-column-gap":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"grid-column-start":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-row-end":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-row-gap":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"grid-row-start":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-template-areas":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"grid-template-columns":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"grid-template-rows":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"height":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"hyphens":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","manual","none","unset"]},"image-orientation":{"isInherited":true,"supports":[1],"values":["inherit","initial","unset"]},"-moz-image-region":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"image-rendering":{"isInherited":true,"supports":[],"values":["-moz-crisp-edges","auto","inherit","initial","optimizequality","optimizespeed","unset"]},"ime-mode":{"isInherited":false,"supports":[],"values":["active","auto","disabled","inactive","inherit","initial","normal","unset"]},"inline-size":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"isolation":{"isInherited":false,"supports":[],"values":["auto","inherit","initial","isolate","unset"]},"justify-content":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","space-around","space-between","space-evenly","start","stretch","unset"]},"justify-items":{"isInherited":false,"supports":[],"values":["auto","baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"justify-self":{"isInherited":false,"supports":[],"values":["auto","baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"left":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"letter-spacing":{"isInherited":true,"supports":[6],"values":["-moz-calc","calc","inherit","initial","normal","unset"]},"lighting-color":{"isInherited":false,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"line-height":{"isInherited":true,"supports":[6,7,8],"values":["-moz-block-height","-moz-calc","calc","inherit","initial","normal","unset"]},"list-style-image":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"list-style-position":{"isInherited":true,"supports":[],"values":["inherit","initial","inside","outside","unset"]},"list-style-type":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"margin-block-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-block-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-bottom":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-inline-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-inline-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-left":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-right":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-top":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"marker-end":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"marker-mid":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"marker-offset":{"isInherited":false,"supports":[6],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"marker-start":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"mask-clip":{"isInherited":false,"values":["border-box","content-box","inherit","initial","padding-box","unset"],"supports":[]},"mask-composite":{"isInherited":false,"values":["add","exclude","inherit","initial","intersect","subtract","unset"],"supports":[]},"mask-image":{"isInherited":false,"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"],"supports":[4,5,11]},"mask-mode":{"isInherited":false,"values":["alpha","inherit","initial","luminance","match-source","unset"],"supports":[]},"mask-origin":{"isInherited":false,"values":["border-box","content-box","inherit","initial","padding-box","unset"],"supports":[]},"mask-position-x":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"mask-position-y":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"mask-repeat":{"isInherited":false,"values":["inherit","initial","no-repeat","repeat","repeat-x","repeat-y","round","space","unset"],"supports":[]},"mask-size":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"mask-type":{"isInherited":false,"supports":[],"values":["alpha","inherit","initial","luminance","unset"]},"max-block-size":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","none","unset"]},"max-height":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","calc","inherit","initial","none","unset"]},"max-inline-size":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","calc","inherit","initial","none","unset"]},"max-width":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","calc","inherit","initial","none","unset"]},"min-block-size":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"min-height":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"min-inline-size":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"min-width":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"mix-blend-mode":{"isInherited":false,"supports":[],"values":["color","color-burn","color-dodge","darken","difference","exclusion","hard-light","hue","inherit","initial","lighten","luminosity","multiply","normal","overlay","saturation","screen","soft-light","unset"]},"object-fit":{"isInherited":false,"supports":[],"values":["contain","cover","fill","inherit","initial","none","scale-down","unset"]},"object-position":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"offset-block-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"offset-block-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"offset-inline-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"offset-inline-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"opacity":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"order":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-moz-orient":{"isInherited":false,"supports":[],"values":["block","horizontal","inherit","initial","inline","unset","vertical"]},"outline-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"outline-offset":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","unset"]},"-moz-outline-radius-bottomleft":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-outline-radius-bottomright":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-outline-radius-topleft":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-outline-radius-topright":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"outline-style":{"isInherited":false,"supports":[],"values":["auto","dashed","dotted","double","groove","inherit","initial","inset","none","outset","ridge","solid","unset"]},"outline-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"overflow-x":{"isInherited":false,"supports":[],"values":["-moz-hidden-unscrollable","auto","hidden","inherit","initial","scroll","unset","visible"]},"overflow-y":{"isInherited":false,"supports":[],"values":["-moz-hidden-unscrollable","auto","hidden","inherit","initial","scroll","unset","visible"]},"padding-block-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-block-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-bottom":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-inline-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-inline-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-left":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-right":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-top":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"page-break-after":{"isInherited":false,"supports":[],"values":["always","auto","avoid","inherit","initial","left","right","unset"]},"page-break-before":{"isInherited":false,"supports":[],"values":["always","auto","avoid","inherit","initial","left","right","unset"]},"page-break-inside":{"isInherited":false,"supports":[],"values":["auto","avoid","inherit","initial","unset"]},"paint-order":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"perspective":{"isInherited":false,"supports":[6],"values":["inherit","initial","none","unset"]},"perspective-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"pointer-events":{"isInherited":true,"supports":[],"values":["all","auto","fill","inherit","initial","none","painted","stroke","unset","visible","visiblefill","visiblepainted","visiblestroke"]},"position":{"isInherited":false,"supports":[],"values":["absolute","fixed","inherit","initial","relative","static","sticky","unset"]},"quotes":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"resize":{"isInherited":false,"supports":[],"values":["both","horizontal","inherit","initial","none","unset","vertical"]},"right":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"ruby-align":{"isInherited":true,"supports":[],"values":["center","inherit","initial","space-around","space-between","start","unset"]},"ruby-position":{"isInherited":true,"supports":[],"values":["inherit","initial","over","under","unset"]},"scroll-behavior":{"isInherited":false,"supports":[],"values":["auto","inherit","initial","smooth","unset"]},"scroll-snap-coordinate":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"scroll-snap-destination":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"scroll-snap-points-x":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"scroll-snap-points-y":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"scroll-snap-type-x":{"isInherited":false,"supports":[],"values":["inherit","initial","mandatory","none","proximity","unset"]},"scroll-snap-type-y":{"isInherited":false,"supports":[],"values":["inherit","initial","mandatory","none","proximity","unset"]},"shape-rendering":{"isInherited":true,"supports":[],"values":["auto","crispedges","geometricprecision","inherit","initial","optimizespeed","unset"]},"-moz-stack-sizing":{"isInherited":false,"supports":[],"values":["ignore","inherit","initial","stretch-to-fit","unset"]},"stop-color":{"isInherited":false,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"stop-opacity":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"stroke":{"isInherited":true,"supports":[2,11],"values":["inherit","initial","unset"]},"stroke-dasharray":{"isInherited":true,"supports":[6,7,8],"values":["inherit","initial","unset"]},"stroke-dashoffset":{"isInherited":true,"supports":[6,7,8],"values":["inherit","initial","unset"]},"stroke-linecap":{"isInherited":true,"supports":[],"values":["butt","inherit","initial","round","square","unset"]},"stroke-linejoin":{"isInherited":true,"supports":[],"values":["bevel","inherit","initial","miter","round","unset"]},"stroke-miterlimit":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"stroke-opacity":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"stroke-width":{"isInherited":true,"supports":[6,7,8],"values":["inherit","initial","unset"]},"-moz-tab-size":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"table-layout":{"isInherited":false,"supports":[],"values":["auto","fixed","inherit","initial","unset"]},"text-align":{"isInherited":true,"supports":[],"values":["-moz-center","-moz-left","-moz-right","center","end","inherit","initial","justify","left","right","start","unset"]},"text-align-last":{"isInherited":true,"supports":[],"values":["auto","center","end","inherit","initial","justify","left","right","start","unset"]},"text-anchor":{"isInherited":true,"supports":[],"values":["end","inherit","initial","middle","start","unset"]},"text-combine-upright":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"text-decoration-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"text-decoration-line":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"text-decoration-style":{"isInherited":false,"supports":[],"values":["-moz-none","dashed","dotted","double","inherit","initial","solid","unset","wavy"]},"text-emphasis-color":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"text-emphasis-position":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"text-emphasis-style":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"-webkit-text-fill-color":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"text-indent":{"isInherited":true,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"text-orientation":{"isInherited":true,"supports":[],"values":["inherit","initial","mixed","sideways","sideways-right","unset","upright"]},"text-overflow":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"text-rendering":{"isInherited":true,"supports":[],"values":["auto","geometricprecision","inherit","initial","optimizelegibility","optimizespeed","unset"]},"text-shadow":{"isInherited":true,"supports":[2,6],"values":["inherit","initial","unset"]},"-moz-text-size-adjust":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","none","unset"]},"-webkit-text-stroke-color":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-webkit-text-stroke-width":{"isInherited":true,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"text-transform":{"isInherited":true,"supports":[],"values":["capitalize","full-width","inherit","initial","lowercase","none","unset","uppercase"]},"top":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"touch-action":{"isInherited":false,"supports":[],"values":["auto","inherit","initial","manipulation","none","pan-x","pan-y","unset"]},"transform":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"transform-box":{"isInherited":false,"supports":[],"values":["border-box","fill-box","inherit","initial","unset","view-box"]},"transform-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"transform-style":{"isInherited":false,"supports":[],"values":["flat","inherit","initial","preserve-3d","unset"]},"transition-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"transition-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"transition-property":{"isInherited":false,"supports":[],"values":["all","inherit","initial","none","unset"]},"transition-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"unicode-bidi":{"isInherited":false,"supports":[],"values":["-moz-isolate","-moz-isolate-override","-moz-plaintext","bidi-override","embed","inherit","initial","isolate","isolate-override","normal","plaintext","unset"]},"-moz-user-focus":{"isInherited":true,"supports":[],"values":["ignore","inherit","initial","none","normal","select-after","select-all","select-before","select-menu","select-same","unset"]},"-moz-user-input":{"isInherited":true,"supports":[],"values":["auto","disabled","enabled","inherit","initial","none","unset"]},"-moz-user-modify":{"isInherited":true,"supports":[],"values":["inherit","initial","read-only","read-write","unset","write-only"]},"-moz-user-select":{"isInherited":false,"supports":[],"values":["-moz-all","-moz-none","-moz-text","all","auto","element","elements","inherit","initial","none","text","toggle","tri-state","unset"]},"vector-effect":{"isInherited":false,"supports":[],"values":["inherit","initial","non-scaling-stroke","none","unset"]},"vertical-align":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","-moz-middle-with-baseline","baseline","bottom","calc","inherit","initial","middle","sub","super","text-bottom","text-top","top","unset"]},"visibility":{"isInherited":true,"supports":[],"values":["collapse","hidden","inherit","initial","unset","visible"]},"white-space":{"isInherited":true,"supports":[],"values":["-moz-pre-space","inherit","initial","normal","nowrap","pre","pre-line","pre-wrap","unset"]},"width":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"will-change":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"-moz-window-dragging":{"isInherited":false,"supports":[],"values":["default","drag","inherit","initial","no-drag","unset"]},"word-break":{"isInherited":true,"supports":[],"values":["break-all","inherit","initial","keep-all","normal","unset"]},"word-spacing":{"isInherited":true,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","normal","unset"]},"overflow-wrap":{"isInherited":true,"supports":[],"values":["break-word","inherit","initial","normal","unset"]},"writing-mode":{"isInherited":true,"supports":[],"values":["horizontal-tb","inherit","initial","lr","lr-tb","rl","rl-tb","sideways-lr","sideways-rl","tb","tb-rl","unset","vertical-lr","vertical-rl"]},"z-index":{"isInherited":false,"supports":[7],"values":["auto","inherit","initial","unset"]},"all":{"isInherited":false,"supports":[1,2,4,5,6,7,8,9,10,11],"values":["COLOR","-moz-all","-moz-available","-moz-block-height","-moz-box","-moz-calc","-moz-center","-moz-crisp-edges","-moz-deck","-moz-element","-moz-fit-content","-moz-grid","-moz-grid-group","-moz-grid-line","-moz-groupbox","-moz-gtk-info-bar","-moz-hidden-unscrollable","-moz-image-rect","-moz-inline-box","-moz-inline-grid","-moz-inline-stack","-moz-left","-moz-linear-gradient","-moz-mac-disclosure-button-closed","-moz-mac-disclosure-button-open","-moz-mac-fullscreen-button","-moz-mac-help-button","-moz-mac-source-list","-moz-mac-vibrancy-dark","-moz-mac-vibrancy-light","-moz-max-content","-moz-middle-with-baseline","-moz-min-content","-moz-none","-moz-popup","-moz-pre-space","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","-moz-right","-moz-stack","-moz-text","-moz-use-text-color","-moz-win-borderless-glass","-moz-win-browsertabbar-toolbox","-moz-win-communications-toolbox","-moz-win-exclude-glass","-moz-win-glass","-moz-win-media-toolbox","-moz-window-button-box","-moz-window-button-box-maximized","-moz-window-button-close","-moz-window-button-maximize","-moz-window-button-minimize","-moz-window-button-restore","-moz-window-frame-bottom","-moz-window-frame-left","-moz-window-frame-right","-moz-window-titlebar","-moz-window-titlebar-maximized","-webkit-box","-webkit-flex","-webkit-inline-box","-webkit-inline-flex","absolute","active","add","all","all-petite-caps","all-small-caps","alpha","alphabetic","alternate","alternate-reverse","always","auto","avoid","backwards","balance","baseline","bevel","block","block-axis","border-box","both","bottom","bottom-outside","break-all","break-word","butt","button","button-arrow-down","button-arrow-next","button-arrow-previous","button-arrow-up","button-bevel","button-focus","calc","capitalize","caret","center","central","checkbox","checkbox-container","checkbox-label","checkmenuitem","clone","collapse","color","color-burn","color-dodge","column","column-reverse","condensed","contain","content-box","contents","cover","crispedges","cubic-bezier","currentColor","darken","dashed","default","dialog","difference","disabled","dotted","double","drag","dualbutton","ease","ease-in","ease-in-out","ease-out","economy","element","elements","enabled","end","evenodd","exact","exclude","exclusion","expanded","extra-condensed","extra-expanded","fill","fill-box","fixed","flat","flex","flex-end","flex-start","forwards","full-width","geometricprecision","grayscale","grid","groove","groupbox","hanging","hard-light","hidden","hide","horizontal","horizontal-tb","hsl","hsla","hue","ideographic","ignore","inactive","infinite","inherit","initial","inline","inline-axis","inline-block","inline-end","inline-flex","inline-grid","inline-start","inline-table","inset","inside","intersect","isolate","italic","justify","keep-all","large","larger","last-baseline","left","lighten","linear","linear-gradient","linearrgb","list-item","listbox","listitem","local","lowercase","lr","lr-tb","luminance","luminosity","mandatory","manipulation","manual","margin-box","match-source","mathematical","medium","menuarrow","menubar","menucheckbox","menuimage","menuitem","menuitemtext","menulist","menulist-button","menulist-text","menulist-textfield","menupopup","menuradio","menuseparator","meterbar","meterchunk","middle","miter","mixed","multiply","no-change","no-drag","no-repeat","non-scaling-stroke","none","nonzero","normal","nowrap","number-input","oblique","optimizelegibility","optimizequality","optimizespeed","outset","outside","over","overlay","padding-box","painted","pan-x","pan-y","paused","petite-caps","pre","pre-line","pre-wrap","preserve-3d","progressbar","progressbar-vertical","progresschunk","progresschunk-vertical","proximity","radial-gradient","radio","radio-container","radio-label","radiomenuitem","range","range-thumb","read-only","read-write","relative","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","reset-size","resizer","resizerpanel","reverse","rgb","rgba","ridge","right","rl","rl-tb","round","row","row-reverse","ruby","ruby-base","ruby-base-container","ruby-text","ruby-text-container","running","saturation","scale-down","scale-horizontal","scale-vertical","scalethumb-horizontal","scalethumb-vertical","scalethumbend","scalethumbstart","scalethumbtick","screen","scroll","scrollbar","scrollbar-horizontal","scrollbar-small","scrollbar-vertical","scrollbarbutton-down","scrollbarbutton-left","scrollbarbutton-right","scrollbarbutton-up","scrollbarthumb-horizontal","scrollbarthumb-vertical","scrollbartrack-horizontal","scrollbartrack-vertical","searchfield","select-after","select-all","select-before","select-menu","select-same","self-end","self-start","semi-condensed","semi-expanded","separate","separator","show","sideways","sideways-lr","sideways-right","sideways-rl","slice","small","small-caps","smaller","smooth","soft-light","solid","space","space-around","space-between","space-evenly","spinner","spinner-downbutton","spinner-textfield","spinner-upbutton","splitter","square","srgb","start","static","statusbar","statusbarpanel","step-end","step-start","steps","sticky","stretch","stretch-to-fit","stroke","sub","subtract","super","tab","tab-scroll-arrow-back","tab-scroll-arrow-forward","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","tabpanel","tabpanels","tb","tb-rl","text","text-after-edge","text-before-edge","text-bottom","text-top","textfield","textfield-multiline","thick","thin","titling-caps","toggle","toolbar","toolbarbutton","toolbarbutton-dropdown","toolbargripper","toolbox","tooltip","top","top-outside","transparent","treeheader","treeheadercell","treeheadersortarrow","treeitem","treeline","treetwisty","treetwistyopen","treeview","tri-state","ultra-condensed","ultra-expanded","under","unicase","unset","uppercase","upright","url","use-script","vertical","vertical-lr","vertical-rl","view-box","visible","visiblefill","visiblepainted","visiblestroke","wavy","window","wrap","wrap-reverse","write-only","x-large","x-small","xx-large","xx-small"]},"animation":{"isInherited":false,"supports":[7,9,10],"values":["alternate","alternate-reverse","backwards","both","cubic-bezier","ease","ease-in","ease-in-out","ease-out","forwards","infinite","inherit","initial","linear","none","normal","paused","reverse","running","step-end","step-start","steps","unset"]},"background":{"isInherited":false,"supports":[2,4,5,6,8,11],"values":["COLOR","-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","border-box","content-box","currentColor","fixed","hsl","hsla","inherit","initial","linear-gradient","local","no-repeat","none","padding-box","radial-gradient","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","rgb","rgba","round","scroll","space","text","transparent","unset","url"]},"background-position":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","linear-gradient","medium","none","outset","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","rgb","rgba","ridge","solid","thick","thin","transparent","unset","url"]},"border-block-end":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-block-start":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-bottom":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-image":{"isInherited":false,"supports":[4,5,6,7,8,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"border-inline-end":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-inline-start":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-left":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-right":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-top":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-column-rule":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"-moz-columns":{"isInherited":false,"supports":[6,7],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"flex":{"isInherited":false,"supports":[6,7,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"flex-flow":{"isInherited":false,"supports":[],"values":["column","column-reverse","inherit","initial","nowrap","row","row-reverse","unset","wrap","wrap-reverse"]},"font":{"isInherited":true,"supports":[6,7,8],"values":["-moz-block-height","-moz-calc","all-petite-caps","all-small-caps","auto","calc","condensed","expanded","extra-condensed","extra-expanded","inherit","initial","italic","large","larger","medium","none","normal","oblique","petite-caps","semi-condensed","semi-expanded","small","small-caps","smaller","sub","super","titling-caps","ultra-condensed","ultra-expanded","unicase","unset","x-large","x-small","xx-large","xx-small"]},"font-variant":{"isInherited":true,"supports":[],"values":["all-petite-caps","all-small-caps","inherit","initial","normal","petite-caps","small-caps","sub","super","titling-caps","unicase","unset"]},"grid":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"grid-area":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-column":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-gap":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"grid-row":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-template":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"list-style":{"isInherited":true,"supports":[11],"values":["inherit","initial","inside","none","outside","unset","url"]},"margin":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"marker":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"mask":{"isInherited":false,"supports":[4,5,6,8,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","add","alpha","border-box","content-box","exclude","inherit","initial","intersect","linear-gradient","luminance","match-source","no-repeat","none","padding-box","radial-gradient","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","round","space","subtract","unset","url"]},"mask-position":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"outline":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","auto","calc","currentColor","dashed","dotted","double","groove","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"-moz-outline-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"overflow":{"isInherited":false,"supports":[],"values":["-moz-hidden-unscrollable","auto","hidden","inherit","initial","scroll","unset","visible"]},"padding":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"scroll-snap-type":{"isInherited":false,"supports":[],"values":["inherit","initial","mandatory","none","proximity","unset"]},"text-decoration":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-none","-moz-use-text-color","currentColor","dashed","dotted","double","hsl","hsla","inherit","initial","rgb","rgba","solid","transparent","unset","wavy"]},"text-emphasis":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-webkit-text-stroke":{"isInherited":true,"supports":[2,6],"values":["COLOR","-moz-calc","calc","currentColor","hsl","hsla","inherit","initial","medium","rgb","rgba","thick","thin","transparent","unset"]},"-moz-transform":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"transition":{"isInherited":false,"supports":[9,10],"values":["all","cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","none","step-end","step-start","steps","unset"]},"word-wrap":{"isInherited":true,"supports":[],"values":["break-word","inherit","initial","normal","unset"]},"-moz-transform-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-perspective-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-perspective":{"isInherited":false,"supports":[6],"values":["inherit","initial","none","unset"]},"-moz-transform-style":{"isInherited":false,"supports":[],"values":["flat","inherit","initial","preserve-3d","unset"]},"-moz-backface-visibility":{"isInherited":false,"supports":[],"values":["hidden","inherit","initial","unset","visible"]},"-moz-border-image":{"isInherited":false,"supports":[4,5,6,7,8,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"-moz-transition":{"isInherited":false,"supports":[9,10],"values":["all","cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","none","step-end","step-start","steps","unset"]},"-moz-transition-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-moz-transition-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-moz-transition-property":{"isInherited":false,"supports":[],"values":["all","inherit","initial","none","unset"]},"-moz-transition-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-moz-animation":{"isInherited":false,"supports":[7,9,10],"values":["alternate","alternate-reverse","backwards","both","cubic-bezier","ease","ease-in","ease-in-out","ease-out","forwards","infinite","inherit","initial","linear","none","normal","paused","reverse","running","step-end","step-start","steps","unset"]},"-moz-animation-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-moz-animation-direction":{"isInherited":false,"supports":[],"values":["alternate","alternate-reverse","inherit","initial","normal","reverse","unset"]},"-moz-animation-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-moz-animation-fill-mode":{"isInherited":false,"supports":[],"values":["backwards","both","forwards","inherit","initial","none","unset"]},"-moz-animation-iteration-count":{"isInherited":false,"supports":[7],"values":["infinite","inherit","initial","unset"]},"-moz-animation-name":{"isInherited":false,"supports":[],"values":["inherit","initial","none","unset"]},"-moz-animation-play-state":{"isInherited":false,"supports":[],"values":["inherit","initial","paused","running","unset"]},"-moz-animation-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-moz-box-sizing":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","unset"]},"-moz-font-feature-settings":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"-moz-font-language-override":{"isInherited":true,"supports":[],"values":["inherit","initial","normal","unset"]},"-moz-padding-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"-moz-padding-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"-moz-margin-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-margin-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-border-end":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"-moz-border-end-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-end-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"-moz-border-end-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-border-start":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"-moz-border-start-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-start-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"-moz-border-start-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-hyphens":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","manual","none","unset"]},"-moz-text-align-last":{"isInherited":true,"supports":[],"values":["auto","center","end","inherit","initial","justify","left","right","start","unset"]},"-webkit-animation":{"isInherited":false,"supports":[7,9,10],"values":["alternate","alternate-reverse","backwards","both","cubic-bezier","ease","ease-in","ease-in-out","ease-out","forwards","infinite","inherit","initial","linear","none","normal","paused","reverse","running","step-end","step-start","steps","unset"]},"-webkit-animation-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-webkit-animation-direction":{"isInherited":false,"supports":[],"values":["alternate","alternate-reverse","inherit","initial","normal","reverse","unset"]},"-webkit-animation-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-webkit-animation-fill-mode":{"isInherited":false,"supports":[],"values":["backwards","both","forwards","inherit","initial","none","unset"]},"-webkit-animation-iteration-count":{"isInherited":false,"supports":[7],"values":["infinite","inherit","initial","unset"]},"-webkit-animation-name":{"isInherited":false,"supports":[],"values":["inherit","initial","none","unset"]},"-webkit-animation-play-state":{"isInherited":false,"supports":[],"values":["inherit","initial","paused","running","unset"]},"-webkit-animation-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-webkit-filter":{"isInherited":false,"supports":[11],"values":["inherit","initial","unset"]},"-webkit-text-size-adjust":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","none","unset"]},"-webkit-transform":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"-webkit-transform-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-transform-style":{"isInherited":false,"supports":[],"values":["flat","inherit","initial","preserve-3d","unset"]},"-webkit-backface-visibility":{"isInherited":false,"supports":[],"values":["hidden","inherit","initial","unset","visible"]},"-webkit-perspective":{"isInherited":false,"supports":[6],"values":["inherit","initial","none","unset"]},"-webkit-perspective-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-transition":{"isInherited":false,"supports":[9,10],"values":["all","cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","none","step-end","step-start","steps","unset"]},"-webkit-transition-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-webkit-transition-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-webkit-transition-property":{"isInherited":false,"supports":[],"values":["all","inherit","initial","none","unset"]},"-webkit-transition-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-webkit-border-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-top-left-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-top-right-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-bottom-left-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-bottom-right-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-background-clip":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","padding-box","text","unset"]},"-webkit-background-origin":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","padding-box","unset"]},"-webkit-background-size":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-image":{"isInherited":false,"supports":[4,5,6,7,8,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"-webkit-box-shadow":{"isInherited":false,"supports":[2,6],"values":["inherit","initial","unset"]},"-webkit-box-sizing":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","unset"]},"-webkit-box-flex":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-box-ordinal-group":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-box-orient":{"isInherited":false,"supports":[],"values":["block-axis","horizontal","inherit","initial","inline-axis","unset","vertical"]},"-webkit-box-direction":{"isInherited":false,"supports":[],"values":["inherit","initial","normal","reverse","unset"]},"-webkit-box-align":{"isInherited":false,"supports":[],"values":["baseline","center","end","inherit","initial","start","stretch","unset"]},"-webkit-box-pack":{"isInherited":false,"supports":[],"values":["center","end","inherit","initial","justify","start","unset"]},"-webkit-flex-direction":{"isInherited":false,"supports":[],"values":["column","column-reverse","inherit","initial","row","row-reverse","unset"]},"-webkit-flex-wrap":{"isInherited":false,"supports":[],"values":["inherit","initial","nowrap","unset","wrap","wrap-reverse"]},"-webkit-flex-flow":{"isInherited":false,"supports":[],"values":["column","column-reverse","inherit","initial","nowrap","row","row-reverse","unset","wrap","wrap-reverse"]},"-webkit-order":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-flex":{"isInherited":false,"supports":[6,7,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"-webkit-flex-grow":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-flex-shrink":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-flex-basis":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"-webkit-justify-content":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","space-around","space-between","space-evenly","start","stretch","unset"]},"-webkit-align-items":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"-webkit-align-self":{"isInherited":false,"supports":[],"values":["auto","baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"-webkit-align-content":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","space-around","space-between","space-evenly","start","stretch","unset"]},"-webkit-user-select":{"isInherited":false,"supports":[],"values":["-moz-all","-moz-none","-moz-text","all","auto","element","elements","inherit","initial","none","text","toggle","tri-state","unset"]},"-webkit-mask":{"isInherited":false,"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","add","alpha","border-box","content-box","exclude","inherit","initial","intersect","linear-gradient","luminance","match-source","no-repeat","none","padding-box","radial-gradient","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","round","space","subtract","unset","url"],"supports":[4,5,6,8,11]},"-webkit-mask-clip":{"isInherited":false,"values":["border-box","content-box","inherit","initial","padding-box","unset"],"supports":[]},"-webkit-mask-composite":{"isInherited":false,"values":["add","exclude","inherit","initial","intersect","subtract","unset"],"supports":[]},"-webkit-mask-image":{"isInherited":false,"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"],"supports":[4,5,11]},"-webkit-mask-origin":{"isInherited":false,"values":["border-box","content-box","inherit","initial","padding-box","unset"],"supports":[]},"-webkit-mask-position":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"-webkit-mask-position-x":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"-webkit-mask-position-y":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"-webkit-mask-repeat":{"isInherited":false,"values":["inherit","initial","no-repeat","repeat","repeat-x","repeat-y","round","space","unset"],"supports":[]},"-webkit-mask-size":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]}};
	/*eslint-enable */

	exports.CSS_PROPERTIES_DB = {
	  properties: exports.CSS_PROPERTIES,
	  pseudoElements: exports.PSEUDO_ELEMENTS
	};


/***/ },
/* 32 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// /!\  Auto-generated from nsColorNameList.h.
	// This should be kept in sync with that list.
	// test_cssColorDatabase.js tries to enforce this.

	const cssColors = {
	  aliceblue: [240, 248, 255, 1],
	  antiquewhite: [250, 235, 215, 1],
	  aqua: [0, 255, 255, 1],
	  aquamarine: [127, 255, 212, 1],
	  azure: [240, 255, 255, 1],
	  beige: [245, 245, 220, 1],
	  bisque: [255, 228, 196, 1],
	  black: [0, 0, 0, 1],
	  blanchedalmond: [255, 235, 205, 1],
	  blue: [0, 0, 255, 1],
	  blueviolet: [138, 43, 226, 1],
	  brown: [165, 42, 42, 1],
	  burlywood: [222, 184, 135, 1],
	  cadetblue: [95, 158, 160, 1],
	  chartreuse: [127, 255, 0, 1],
	  chocolate: [210, 105, 30, 1],
	  coral: [255, 127, 80, 1],
	  cornflowerblue: [100, 149, 237, 1],
	  cornsilk: [255, 248, 220, 1],
	  crimson: [220, 20, 60, 1],
	  cyan: [0, 255, 255, 1],
	  darkblue: [0, 0, 139, 1],
	  darkcyan: [0, 139, 139, 1],
	  darkgoldenrod: [184, 134, 11, 1],
	  darkgray: [169, 169, 169, 1],
	  darkgreen: [0, 100, 0, 1],
	  darkgrey: [169, 169, 169, 1],
	  darkkhaki: [189, 183, 107, 1],
	  darkmagenta: [139, 0, 139, 1],
	  darkolivegreen: [85, 107, 47, 1],
	  darkorange: [255, 140, 0, 1],
	  darkorchid: [153, 50, 204, 1],
	  darkred: [139, 0, 0, 1],
	  darksalmon: [233, 150, 122, 1],
	  darkseagreen: [143, 188, 143, 1],
	  darkslateblue: [72, 61, 139, 1],
	  darkslategray: [47, 79, 79, 1],
	  darkslategrey: [47, 79, 79, 1],
	  darkturquoise: [0, 206, 209, 1],
	  darkviolet: [148, 0, 211, 1],
	  deeppink: [255, 20, 147, 1],
	  deepskyblue: [0, 191, 255, 1],
	  dimgray: [105, 105, 105, 1],
	  dimgrey: [105, 105, 105, 1],
	  dodgerblue: [30, 144, 255, 1],
	  firebrick: [178, 34, 34, 1],
	  floralwhite: [255, 250, 240, 1],
	  forestgreen: [34, 139, 34, 1],
	  fuchsia: [255, 0, 255, 1],
	  gainsboro: [220, 220, 220, 1],
	  ghostwhite: [248, 248, 255, 1],
	  gold: [255, 215, 0, 1],
	  goldenrod: [218, 165, 32, 1],
	  gray: [128, 128, 128, 1],
	  grey: [128, 128, 128, 1],
	  green: [0, 128, 0, 1],
	  greenyellow: [173, 255, 47, 1],
	  honeydew: [240, 255, 240, 1],
	  hotpink: [255, 105, 180, 1],
	  indianred: [205, 92, 92, 1],
	  indigo: [75, 0, 130, 1],
	  ivory: [255, 255, 240, 1],
	  khaki: [240, 230, 140, 1],
	  lavender: [230, 230, 250, 1],
	  lavenderblush: [255, 240, 245, 1],
	  lawngreen: [124, 252, 0, 1],
	  lemonchiffon: [255, 250, 205, 1],
	  lightblue: [173, 216, 230, 1],
	  lightcoral: [240, 128, 128, 1],
	  lightcyan: [224, 255, 255, 1],
	  lightgoldenrodyellow: [250, 250, 210, 1],
	  lightgray: [211, 211, 211, 1],
	  lightgreen: [144, 238, 144, 1],
	  lightgrey: [211, 211, 211, 1],
	  lightpink: [255, 182, 193, 1],
	  lightsalmon: [255, 160, 122, 1],
	  lightseagreen: [32, 178, 170, 1],
	  lightskyblue: [135, 206, 250, 1],
	  lightslategray: [119, 136, 153, 1],
	  lightslategrey: [119, 136, 153, 1],
	  lightsteelblue: [176, 196, 222, 1],
	  lightyellow: [255, 255, 224, 1],
	  lime: [0, 255, 0, 1],
	  limegreen: [50, 205, 50, 1],
	  linen: [250, 240, 230, 1],
	  magenta: [255, 0, 255, 1],
	  maroon: [128, 0, 0, 1],
	  mediumaquamarine: [102, 205, 170, 1],
	  mediumblue: [0, 0, 205, 1],
	  mediumorchid: [186, 85, 211, 1],
	  mediumpurple: [147, 112, 219, 1],
	  mediumseagreen: [60, 179, 113, 1],
	  mediumslateblue: [123, 104, 238, 1],
	  mediumspringgreen: [0, 250, 154, 1],
	  mediumturquoise: [72, 209, 204, 1],
	  mediumvioletred: [199, 21, 133, 1],
	  midnightblue: [25, 25, 112, 1],
	  mintcream: [245, 255, 250, 1],
	  mistyrose: [255, 228, 225, 1],
	  moccasin: [255, 228, 181, 1],
	  navajowhite: [255, 222, 173, 1],
	  navy: [0, 0, 128, 1],
	  oldlace: [253, 245, 230, 1],
	  olive: [128, 128, 0, 1],
	  olivedrab: [107, 142, 35, 1],
	  orange: [255, 165, 0, 1],
	  orangered: [255, 69, 0, 1],
	  orchid: [218, 112, 214, 1],
	  palegoldenrod: [238, 232, 170, 1],
	  palegreen: [152, 251, 152, 1],
	  paleturquoise: [175, 238, 238, 1],
	  palevioletred: [219, 112, 147, 1],
	  papayawhip: [255, 239, 213, 1],
	  peachpuff: [255, 218, 185, 1],
	  peru: [205, 133, 63, 1],
	  pink: [255, 192, 203, 1],
	  plum: [221, 160, 221, 1],
	  powderblue: [176, 224, 230, 1],
	  purple: [128, 0, 128, 1],
	  rebeccapurple: [102, 51, 153, 1],
	  red: [255, 0, 0, 1],
	  rosybrown: [188, 143, 143, 1],
	  royalblue: [65, 105, 225, 1],
	  saddlebrown: [139, 69, 19, 1],
	  salmon: [250, 128, 114, 1],
	  sandybrown: [244, 164, 96, 1],
	  seagreen: [46, 139, 87, 1],
	  seashell: [255, 245, 238, 1],
	  sienna: [160, 82, 45, 1],
	  silver: [192, 192, 192, 1],
	  skyblue: [135, 206, 235, 1],
	  slateblue: [106, 90, 205, 1],
	  slategray: [112, 128, 144, 1],
	  slategrey: [112, 128, 144, 1],
	  snow: [255, 250, 250, 1],
	  springgreen: [0, 255, 127, 1],
	  steelblue: [70, 130, 180, 1],
	  tan: [210, 180, 140, 1],
	  teal: [0, 128, 128, 1],
	  thistle: [216, 191, 216, 1],
	  tomato: [255, 99, 71, 1],
	  turquoise: [64, 224, 208, 1],
	  violet: [238, 130, 238, 1],
	  wheat: [245, 222, 179, 1],
	  white: [255, 255, 255, 1],
	  whitesmoke: [245, 245, 245, 1],
	  yellow: [255, 255, 0, 1],
	  yellowgreen: [154, 205, 50, 1],
	};

	exports.cssColors = cssColors;


/***/ },
/* 33 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  ELEMENT_NODE: 1,
	  ATTRIBUTE_NODE: 2,
	  TEXT_NODE: 3,
	  CDATA_SECTION_NODE: 4,
	  ENTITY_REFERENCE_NODE: 5,
	  ENTITY_NODE: 6,
	  PROCESSING_INSTRUCTION_NODE: 7,
	  COMMENT_NODE: 8,
	  DOCUMENT_NODE: 9,
	  DOCUMENT_TYPE_NODE: 10,
	  DOCUMENT_FRAGMENT_NODE: 11,
	  NOTATION_NODE: 12,

	  // DocumentPosition
	  DOCUMENT_POSITION_DISCONNECTED: 0x01,
	  DOCUMENT_POSITION_PRECEDING: 0x02,
	  DOCUMENT_POSITION_FOLLOWING: 0x04,
	  DOCUMENT_POSITION_CONTAINS: 0x08,
	  DOCUMENT_POSITION_CONTAINED_BY: 0x10,
	  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20
	}


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Telemetry.
	 *
	 * To add metrics for a tool:
	 *
	 * 1. Create count, flag, and exponential entries in
	 *    toolkit/components/telemetry/Histograms.json. Each type is optional but it
	 *    is best if all three can be included.
	 *
	 * 2. Add your chart entries to devtools/client/shared/telemetry.js
	 *    (Telemetry.prototype._histograms):
	 *    mytoolname: {
	 *      histogram: "DEVTOOLS_MYTOOLNAME_OPENED_COUNT",
	 *      timerHistogram: "DEVTOOLS_MYTOOLNAME_TIME_ACTIVE_SECONDS"
	 *    },
	 *
	 * 3. Include this module at the top of your tool. Use:
	 *      let Telemetry = require("devtools/client/shared/telemetry")
	 *
	 * 4. Create a telemetry instance in your tool's constructor:
	 *      this._telemetry = new Telemetry();
	 *
	 * 5. When your tool is opened call:
	 *      this._telemetry.toolOpened("mytoolname");
	 *
	 * 6. When your tool is closed call:
	 *      this._telemetry.toolClosed("mytoolname");
	 *
	 * Note:
	 * You can view telemetry stats for your local Firefox instance via
	 * about:telemetry.
	 *
	 * You can view telemetry stats for large groups of Firefox users at
	 * telemetry.mozilla.org.
	 */

	"use strict";

	const TOOLS_OPENED_PREF = "devtools.telemetry.tools.opened.version";

	function Telemetry() {
	  // Bind pretty much all functions so that callers do not need to.
	  this.toolOpened = this.toolOpened.bind(this);
	  this.toolClosed = this.toolClosed.bind(this);
	  this.log = this.log.bind(this);
	  this.logOncePerBrowserVersion = this.logOncePerBrowserVersion.bind(this);
	  this.destroy = this.destroy.bind(this);

	  this._timers = new Map();
	}

	module.exports = Telemetry;

	var Services = __webpack_require__(1);

	Telemetry.prototype = {
	  _histograms: {
	    toolbox: {
	      histogram: "DEVTOOLS_TOOLBOX_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_TOOLBOX_TIME_ACTIVE_SECONDS"
	    },
	    options: {
	      histogram: "DEVTOOLS_OPTIONS_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_OPTIONS_TIME_ACTIVE_SECONDS"
	    },
	    webconsole: {
	      histogram: "DEVTOOLS_WEBCONSOLE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_WEBCONSOLE_TIME_ACTIVE_SECONDS"
	    },
	    browserconsole: {
	      histogram: "DEVTOOLS_BROWSERCONSOLE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_BROWSERCONSOLE_TIME_ACTIVE_SECONDS"
	    },
	    inspector: {
	      histogram: "DEVTOOLS_INSPECTOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_INSPECTOR_TIME_ACTIVE_SECONDS"
	    },
	    ruleview: {
	      histogram: "DEVTOOLS_RULEVIEW_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_RULEVIEW_TIME_ACTIVE_SECONDS"
	    },
	    computedview: {
	      histogram: "DEVTOOLS_COMPUTEDVIEW_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_COMPUTEDVIEW_TIME_ACTIVE_SECONDS"
	    },
	    fontinspector: {
	      histogram: "DEVTOOLS_FONTINSPECTOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_FONTINSPECTOR_TIME_ACTIVE_SECONDS"
	    },
	    animationinspector: {
	      histogram: "DEVTOOLS_ANIMATIONINSPECTOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_ANIMATIONINSPECTOR_TIME_ACTIVE_SECONDS"
	    },
	    jsdebugger: {
	      histogram: "DEVTOOLS_JSDEBUGGER_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_JSDEBUGGER_TIME_ACTIVE_SECONDS"
	    },
	    jsbrowserdebugger: {
	      histogram: "DEVTOOLS_JSBROWSERDEBUGGER_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_JSBROWSERDEBUGGER_TIME_ACTIVE_SECONDS"
	    },
	    styleeditor: {
	      histogram: "DEVTOOLS_STYLEEDITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_STYLEEDITOR_TIME_ACTIVE_SECONDS"
	    },
	    shadereditor: {
	      histogram: "DEVTOOLS_SHADEREDITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_SHADEREDITOR_TIME_ACTIVE_SECONDS"
	    },
	    webaudioeditor: {
	      histogram: "DEVTOOLS_WEBAUDIOEDITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_WEBAUDIOEDITOR_TIME_ACTIVE_SECONDS"
	    },
	    canvasdebugger: {
	      histogram: "DEVTOOLS_CANVASDEBUGGER_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_CANVASDEBUGGER_TIME_ACTIVE_SECONDS"
	    },
	    performance: {
	      histogram: "DEVTOOLS_JSPROFILER_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_JSPROFILER_TIME_ACTIVE_SECONDS"
	    },
	    memory: {
	      histogram: "DEVTOOLS_MEMORY_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_MEMORY_TIME_ACTIVE_SECONDS"
	    },
	    netmonitor: {
	      histogram: "DEVTOOLS_NETMONITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_NETMONITOR_TIME_ACTIVE_SECONDS"
	    },
	    storage: {
	      histogram: "DEVTOOLS_STORAGE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_STORAGE_TIME_ACTIVE_SECONDS"
	    },
	    paintflashing: {
	      histogram: "DEVTOOLS_PAINTFLASHING_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_PAINTFLASHING_TIME_ACTIVE_SECONDS"
	    },
	    scratchpad: {
	      histogram: "DEVTOOLS_SCRATCHPAD_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_SCRATCHPAD_TIME_ACTIVE_SECONDS"
	    },
	    "scratchpad-window": {
	      histogram: "DEVTOOLS_SCRATCHPAD_WINDOW_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_SCRATCHPAD_WINDOW_TIME_ACTIVE_SECONDS"
	    },
	    responsive: {
	      histogram: "DEVTOOLS_RESPONSIVE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_RESPONSIVE_TIME_ACTIVE_SECONDS"
	    },
	    eyedropper: {
	      histogram: "DEVTOOLS_EYEDROPPER_OPENED_COUNT",
	    },
	    menueyedropper: {
	      histogram: "DEVTOOLS_MENU_EYEDROPPER_OPENED_COUNT",
	    },
	    pickereyedropper: {
	      histogram: "DEVTOOLS_PICKER_EYEDROPPER_OPENED_COUNT",
	    },
	    toolbareyedropper: {
	      histogram: "DEVTOOLS_TOOLBAR_EYEDROPPER_OPENED_COUNT",
	    },
	    developertoolbar: {
	      histogram: "DEVTOOLS_DEVELOPERTOOLBAR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_DEVELOPERTOOLBAR_TIME_ACTIVE_SECONDS"
	    },
	    aboutdebugging: {
	      histogram: "DEVTOOLS_ABOUTDEBUGGING_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_ABOUTDEBUGGING_TIME_ACTIVE_SECONDS"
	    },
	    webide: {
	      histogram: "DEVTOOLS_WEBIDE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_WEBIDE_TIME_ACTIVE_SECONDS"
	    },
	    webideProjectEditor: {
	      histogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_TIME_ACTIVE_SECONDS"
	    },
	    webideProjectEditorSave: {
	      histogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_SAVE_COUNT",
	    },
	    webideNewProject: {
	      histogram: "DEVTOOLS_WEBIDE_NEW_PROJECT_COUNT",
	    },
	    webideImportProject: {
	      histogram: "DEVTOOLS_WEBIDE_IMPORT_PROJECT_COUNT",
	    },
	    custom: {
	      histogram: "DEVTOOLS_CUSTOM_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_CUSTOM_TIME_ACTIVE_SECONDS"
	    },
	    reloadAddonInstalled: {
	      histogram: "DEVTOOLS_RELOAD_ADDON_INSTALLED_COUNT",
	    },
	    reloadAddonReload: {
	      histogram: "DEVTOOLS_RELOAD_ADDON_RELOAD_COUNT",
	    },
	  },

	  /**
	   * Add an entry to a histogram.
	   *
	   * @param  {String} id
	   *         Used to look up the relevant histogram ID and log true to that
	   *         histogram.
	   */
	  toolOpened: function (id) {
	    let charts = this._histograms[id] || this._histograms.custom;

	    if (charts.histogram) {
	      this.log(charts.histogram, true);
	    }
	    if (charts.timerHistogram) {
	      this.startTimer(charts.timerHistogram);
	    }
	  },

	  /**
	   * Record that an action occurred.  Aliases to `toolOpened`, so it's just for
	   * readability at the call site for cases where we aren't actually opening
	   * tools.
	   */
	  actionOccurred(id) {
	    this.toolOpened(id);
	  },

	  toolClosed: function (id) {
	    let charts = this._histograms[id];

	    if (!charts || !charts.timerHistogram) {
	      return;
	    }

	    this.stopTimer(charts.timerHistogram);
	  },

	  /**
	   * Record the start time for a timing-based histogram entry.
	   *
	   * @param String histogramId
	   *        Histogram in which the data is to be stored.
	   */
	  startTimer: function (histogramId) {
	    this._timers.set(histogramId, new Date());
	  },

	  /**
	   * Stop the timer and log elasped time for a timing-based histogram entry.
	   *
	   * @param String histogramId
	   *        Histogram in which the data is to be stored.
	   * @param String key [optional]
	   *        Optional key for a keyed histogram.
	   */
	  stopTimer: function (histogramId, key) {
	    let startTime = this._timers.get(histogramId);
	    if (startTime) {
	      let time = (new Date() - startTime) / 1000;
	      if (!key) {
	        this.log(histogramId, time);
	      } else {
	        this.logKeyed(histogramId, key, time);
	      }
	      this._timers.delete(histogramId);
	    }
	  },

	  /**
	   * Log a value to a histogram.
	   *
	   * @param  {String} histogramId
	   *         Histogram in which the data is to be stored.
	   * @param  value
	   *         Value to store.
	   */
	  log: function (histogramId, value) {
	    if (histogramId) {
	      try {
	        let histogram = Services.telemetry.getHistogramById(histogramId);
	        histogram.add(value);
	      } catch (e) {
	        (console.log)("Warning: An attempt was made to write to the " + histogramId +
	             " histogram, which is not defined in Histograms.json\n");
	      }
	    }
	  },

	  /**
	   * Log a value to a keyed histogram.
	   *
	   * @param  {String} histogramId
	   *         Histogram in which the data is to be stored.
	   * @param  {String} key
	   *         The key within the single histogram.
	   * @param  value
	   *         Value to store.
	   */
	  logKeyed: function (histogramId, key, value) {
	    if (histogramId) {
	      try {
	        let histogram = Services.telemetry.getKeyedHistogramById(histogramId);
	        histogram.add(key, value);
	      } catch (e) {
	        (console.log)("Warning: An attempt was made to write to the " + histogramId +
	             " histogram, which is not defined in Histograms.json\n");
	      }
	    }
	  },

	  /**
	   * Log info about usage once per browser version. This allows us to discover
	   * how many individual users are using our tools for each browser version.
	   *
	   * @param  {String} perUserHistogram
	   *         Histogram in which the data is to be stored.
	   */
	  logOncePerBrowserVersion: function (perUserHistogram, value) {
	    let currentVersion = Services.appinfo.version;
	    let latest = Services.prefs.getCharPref(TOOLS_OPENED_PREF);
	    let latestObj = JSON.parse(latest);

	    let lastVersionHistogramUpdated = latestObj[perUserHistogram];

	    if (typeof lastVersionHistogramUpdated == "undefined" ||
	        lastVersionHistogramUpdated !== currentVersion) {
	      latestObj[perUserHistogram] = currentVersion;
	      latest = JSON.stringify(latestObj);
	      Services.prefs.setCharPref(TOOLS_OPENED_PREF, latest);
	      this.log(perUserHistogram, value);
	    }
	  },

	  destroy: function () {
	    for (let histogramId of this._timers.keys()) {
	      this.stopTimer(histogramId);
	    }
	  }
	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const EventEmitter = __webpack_require__(6);

	/**
	 * A partial implementation of the Menu API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu.md.
	 *
	 * Extra features:
	 *  - Emits an 'open' and 'close' event when the menu is opened/closed

	 * @param String id (non standard)
	 *        Needed so tests can confirm the XUL implementation is working
	 */
	function Menu({ id = null } = {}) {
	  this.menuitems = [];
	  this.id = id;

	  Object.defineProperty(this, "items", {
	    get() {
	      return this.menuitems;
	    }
	  });

	  EventEmitter.decorate(this);
	}

	/**
	 * Add an item to the end of the Menu
	 *
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.append = function (menuItem) {
	  this.menuitems.push(menuItem);
	};

	/**
	 * Add an item to a specified position in the menu
	 *
	 * @param {int} pos
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.insert = function (pos, menuItem) {
	  throw Error("Not implemented");
	};

	/**
	 * Show the Menu at a specified location on the screen
	 *
	 * Missing features:
	 *   - browserWindow - BrowserWindow (optional) - Default is null.
	 *   - positioningItem Number - (optional) OS X
	 *
	 * @param {int} screenX
	 * @param {int} screenY
	 * @param Toolbox toolbox (non standard)
	 *        Needed so we in which window to inject XUL
	 */
	Menu.prototype.popup = function (screenX, screenY, toolbox) {
	  let doc = toolbox.doc;
	  let popupset = doc.querySelector("popupset");
	  // See bug 1285229, on Windows, opening the same popup multiple times in a
	  // row ends up duplicating the popup. The newly inserted popup doesn't
	  // dismiss the old one. So remove any previously displayed popup before
	  // opening a new one.
	  let popup = popupset.querySelector("menupopup[menu-api=\"true\"]");
	  if (popup) {
	    popup.hidePopup();
	  }

	  popup = doc.createElement("menupopup");
	  popup.setAttribute("menu-api", "true");

	  if (this.id) {
	    popup.id = this.id;
	  }
	  this._createMenuItems(popup);

	  // Remove the menu from the DOM once it's hidden.
	  popup.addEventListener("popuphidden", (e) => {
	    if (e.target === popup) {
	      popup.remove();
	      this.emit("close");
	    }
	  });

	  popup.addEventListener("popupshown", (e) => {
	    if (e.target === popup) {
	      this.emit("open");
	    }
	  });

	  popupset.appendChild(popup);
	  popup.openPopupAtScreen(screenX, screenY, true);
	};

	Menu.prototype._createMenuItems = function (parent) {
	  let doc = parent.ownerDocument;
	  this.menuitems.forEach(item => {
	    if (!item.visible) {
	      return;
	    }

	    if (item.submenu) {
	      let menupopup = doc.createElement("menupopup");
	      item.submenu._createMenuItems(menupopup);

	      let menu = doc.createElement("menu");
	      menu.appendChild(menupopup);
	      menu.setAttribute("label", item.label);
	      if (item.disabled) {
	        menu.setAttribute("disabled", "true");
	      }
	      if (item.accesskey) {
	        menu.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menu.id = item.id;
	      }
	      parent.appendChild(menu);
	    } else if (item.type === "separator") {
	      let menusep = doc.createElement("menuseparator");
	      parent.appendChild(menusep);
	    } else {
	      let menuitem = doc.createElement("menuitem");
	      menuitem.setAttribute("label", item.label);
	      menuitem.addEventListener("command", () => {
	        item.click();
	      });

	      if (item.type === "checkbox") {
	        menuitem.setAttribute("type", "checkbox");
	      }
	      if (item.type === "radio") {
	        menuitem.setAttribute("type", "radio");
	      }
	      if (item.disabled) {
	        menuitem.setAttribute("disabled", "true");
	      }
	      if (item.checked) {
	        menuitem.setAttribute("checked", "true");
	      }
	      if (item.accesskey) {
	        menuitem.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menuitem.id = item.id;
	      }

	      parent.appendChild(menuitem);
	    }
	  });
	};

	Menu.setApplicationMenu = () => {
	  throw Error("Not implemented");
	};

	Menu.sendActionToFirstResponder = () => {
	  throw Error("Not implemented");
	};

	Menu.buildFromTemplate = () => {
	  throw Error("Not implemented");
	};

	module.exports = Menu;


/***/ },
/* 36 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * A partial implementation of the MenuItem API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu-item.md.
	 *
	 * Missing features:
	 *   - id String - Unique within a single menu. If defined then it can be used
	 *                 as a reference to this item by the position attribute.
	 *   - role String - Define the action of the menu item; when specified the
	 *                   click property will be ignored
	 *   - sublabel String
	 *   - accelerator Accelerator
	 *   - icon NativeImage
	 *   - position String - This field allows fine-grained definition of the
	 *                       specific location within a given menu.
	 *
	 * Implemented features:
	 *  @param Object options
	 *    Function click
	 *      Will be called with click(menuItem, browserWindow) when the menu item
	 *       is clicked
	 *    String type
	 *      Can be normal, separator, submenu, checkbox or radio
	 *    String label
	 *    Boolean enabled
	 *      If false, the menu item will be greyed out and unclickable.
	 *    Boolean checked
	 *      Should only be specified for checkbox or radio type menu items.
	 *    Menu submenu
	 *      Should be specified for submenu type menu items. If submenu is specified,
	 *      the type: 'submenu' can be omitted. If the value is not a Menu then it
	 *      will be automatically converted to one using Menu.buildFromTemplate.
	 *    Boolean visible
	 *      If false, the menu item will be entirely hidden.
	 */
	function MenuItem({
	    accesskey = null,
	    checked = false,
	    click = () => {},
	    disabled = false,
	    label = "",
	    id = null,
	    submenu = null,
	    type = "normal",
	    visible = true,
	} = { }) {
	  this.accesskey = accesskey;
	  this.checked = checked;
	  this.click = click;
	  this.disabled = disabled;
	  this.id = id;
	  this.label = label;
	  this.submenu = submenu;
	  this.type = type;
	  this.visible = visible;
	}

	module.exports = MenuItem;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/* globals StopIteration */

	"use strict";

	const ToolDefinitions = __webpack_require__(38).Tools;
	const CssLogic = __webpack_require__(122);
	const {ELEMENT_STYLE} = __webpack_require__(124);
	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);
	const Services = __webpack_require__(1);
	const {OutputParser} = __webpack_require__(127);
	const {PrefObserver, PREF_ORIG_SOURCES} = __webpack_require__(130);
	const {createChild} = __webpack_require__(131);
	const {gDevTools} = __webpack_require__(133);
	const {getCssProperties} = __webpack_require__(18);

	const overlays = __webpack_require__(134);
	const StyleInspectorMenu = __webpack_require__(157);
	const {KeyShortcuts} = __webpack_require__(15);
	const {LayoutView} = __webpack_require__(161);
	const clipboardHelper = __webpack_require__(158);

	const STYLE_INSPECTOR_PROPERTIES = "devtools-shared/locale/styleinspector.properties";
	const {LocalizationHelper} = __webpack_require__(39);
	const STYLE_INSPECTOR_L10N = new LocalizationHelper(STYLE_INSPECTOR_PROPERTIES);

	const FILTER_CHANGED_TIMEOUT = 150;
	const HTML_NS = "http://www.w3.org/1999/xhtml";

	/**
	 * Helper for long-running processes that should yield occasionally to
	 * the mainloop.
	 *
	 * @param {Window} win
	 *        Timeouts will be set on this window when appropriate.
	 * @param {Generator} generator
	 *        Will iterate this generator.
	 * @param {Object} options
	 *        Options for the update process:
	 *          onItem {function} Will be called with the value of each iteration.
	 *          onBatch {function} Will be called after each batch of iterations,
	 *            before yielding to the main loop.
	 *          onDone {function} Will be called when iteration is complete.
	 *          onCancel {function} Will be called if the process is canceled.
	 *          threshold {int} How long to process before yielding, in ms.
	 */
	function UpdateProcess(win, generator, options) {
	  this.win = win;
	  this.iter = _Iterator(generator);
	  this.onItem = options.onItem || function () {};
	  this.onBatch = options.onBatch || function () {};
	  this.onDone = options.onDone || function () {};
	  this.onCancel = options.onCancel || function () {};
	  this.threshold = options.threshold || 45;

	  this.canceled = false;
	}

	UpdateProcess.prototype = {
	  /**
	   * Schedule a new batch on the main loop.
	   */
	  schedule: function () {
	    if (this.canceled) {
	      return;
	    }
	    this._timeout = setTimeout(this._timeoutHandler.bind(this), 0);
	  },

	  /**
	   * Cancel the running process.  onItem will not be called again,
	   * and onCancel will be called.
	   */
	  cancel: function () {
	    if (this._timeout) {
	      clearTimeout(this._timeout);
	      this._timeout = 0;
	    }
	    this.canceled = true;
	    this.onCancel();
	  },

	  _timeoutHandler: function () {
	    this._timeout = null;
	    try {
	      this._runBatch();
	      this.schedule();
	    } catch (e) {
	      if (e instanceof StopIteration) {
	        this.onBatch();
	        this.onDone();
	        return;
	      }
	      console.error(e);
	      throw e;
	    }
	  },

	  _runBatch: function () {
	    let time = Date.now();
	    while (!this.canceled) {
	      // Continue until iter.next() throws...
	      let next = this.iter.next();
	      this.onItem(next[1]);
	      if ((Date.now() - time) > this.threshold) {
	        this.onBatch();
	        return;
	      }
	    }
	  }
	};

	/**
	 * CssComputedView is a panel that manages the display of a table
	 * sorted by style. There should be one instance of CssComputedView
	 * per style display (of which there will generally only be one).
	 *
	 * @param {Inspector} inspector
	 *        Inspector toolbox panel
	 * @param {Document} document
	 *        The document that will contain the computed view.
	 * @param {PageStyleFront} pageStyle
	 *        Front for the page style actor that will be providing
	 *        the style information.
	 */
	function CssComputedView(inspector, document, pageStyle) {
	  this.inspector = inspector;
	  this.styleDocument = document;
	  this.styleWindow = this.styleDocument.defaultView;
	  this.pageStyle = pageStyle;

	  this.propertyViews = [];

	  let cssProperties = getCssProperties(inspector.toolbox);
	  this._outputParser = new OutputParser(document, cssProperties.supportsType);

	  // Create bound methods.
	  this.focusWindow = this.focusWindow.bind(this);
	  this._onContextMenu = this._onContextMenu.bind(this);
	  this._onClick = this._onClick.bind(this);
	  this._onCopy = this._onCopy.bind(this);
	  this._onFilterStyles = this._onFilterStyles.bind(this);
	  this._onClearSearch = this._onClearSearch.bind(this);
	  this._onIncludeBrowserStyles = this._onIncludeBrowserStyles.bind(this);
	  this._onFilterTextboxContextMenu =
	    this._onFilterTextboxContextMenu.bind(this);

	  let doc = this.styleDocument;
	  this.element = doc.getElementById("propertyContainer");
	  this.searchField = doc.getElementById("computedview-searchbox");
	  this.searchClearButton = doc.getElementById("computedview-searchinput-clear");
	  this.includeBrowserStylesCheckbox =
	    doc.getElementById("browser-style-checkbox");

	  this.shortcuts = new KeyShortcuts({ window: this.styleWindow });
	  this._onShortcut = this._onShortcut.bind(this);
	  this.shortcuts.on("CmdOrCtrl+F", this._onShortcut);
	  this.shortcuts.on("Escape", this._onShortcut);
	  this.styleDocument.addEventListener("mousedown", this.focusWindow);
	  this.element.addEventListener("click", this._onClick);
	  this.element.addEventListener("copy", this._onCopy);
	  this.element.addEventListener("contextmenu", this._onContextMenu);
	  this.searchField.addEventListener("input", this._onFilterStyles);
	  this.searchField.addEventListener("contextmenu",
	                                    this._onFilterTextboxContextMenu);
	  this.searchClearButton.addEventListener("click", this._onClearSearch);
	  this.includeBrowserStylesCheckbox.addEventListener("input",
	    this._onIncludeBrowserStyles);

	  this.searchClearButton.hidden = true;

	  // No results text.
	  this.noResults = this.styleDocument.getElementById("computedview-no-results");

	  // Refresh panel when color unit changed.
	  this._handlePrefChange = this._handlePrefChange.bind(this);
	  gDevTools.on("pref-changed", this._handlePrefChange);

	  // Refresh panel when pref for showing original sources changes
	  this._onSourcePrefChanged = this._onSourcePrefChanged.bind(this);
	  this._prefObserver = new PrefObserver("devtools.");
	  this._prefObserver.on(PREF_ORIG_SOURCES, this._onSourcePrefChanged);

	  // The element that we're inspecting, and the document that it comes from.
	  this._viewedElement = null;

	  this.createStyleViews();

	  this._contextmenu = new StyleInspectorMenu(this, { isRuleView: false });

	  // Add the tooltips and highlightersoverlay
	  this.tooltips = new overlays.TooltipsOverlay(this);
	  this.tooltips.addToView();

	  this.highlighters = new overlays.HighlightersOverlay(this);
	  this.highlighters.addToView();
	}

	/**
	 * Lookup a l10n string in the shared styleinspector string bundle.
	 *
	 * @param {String} name
	 *        The key to lookup.
	 * @returns {String} localized version of the given key.
	 */
	CssComputedView.l10n = function (name) {
	  try {
	    return STYLE_INSPECTOR_L10N.getStr(name);
	  } catch (ex) {
	    console.log("Error reading '" + name + "'");
	    throw new Error("l10n error with " + name);
	  }
	};

	CssComputedView.prototype = {
	  // Cache the list of properties that match the selected element.
	  _matchedProperties: null,

	  // Used for cancelling timeouts in the style filter.
	  _filterChangedTimeout: null,

	  // Holds the ID of the panelRefresh timeout.
	  _panelRefreshTimeout: null,

	  // Toggle for zebra striping
	  _darkStripe: true,

	  // Number of visible properties
	  numVisibleProperties: 0,

	  setPageStyle: function (pageStyle) {
	    this.pageStyle = pageStyle;
	  },

	  get includeBrowserStyles() {
	    return this.includeBrowserStylesCheckbox.checked;
	  },

	  _handlePrefChange: function (event, data) {
	    if (this._computed && (data.pref === "devtools.defaultColorUnit" ||
	        data.pref === PREF_ORIG_SOURCES)) {
	      this.refreshPanel();
	    }
	  },

	  /**
	   * Update the view with a new selected element. The CssComputedView panel
	   * will show the style information for the given element.
	   *
	   * @param {NodeFront} element
	   *        The highlighted node to get styles for.
	   * @returns a promise that will be resolved when highlighting is complete.
	   */
	  selectElement: function (element) {
	    if (!element) {
	      this._viewedElement = null;
	      this.noResults.hidden = false;

	      if (this._refreshProcess) {
	        this._refreshProcess.cancel();
	      }
	      // Hiding all properties
	      for (let propView of this.propertyViews) {
	        propView.refresh();
	      }
	      return promise.resolve(undefined);
	    }

	    if (element === this._viewedElement) {
	      return promise.resolve(undefined);
	    }

	    this._viewedElement = element;
	    this.refreshSourceFilter();

	    return this.refreshPanel();
	  },

	  /**
	   * Get the type of a given node in the computed-view
	   *
	   * @param {DOMNode} node
	   *        The node which we want information about
	   * @return {Object} The type information object contains the following props:
	   * - type {String} One of the VIEW_NODE_XXX_TYPE const in
	   *   style-inspector-overlays
	   * - value {Object} Depends on the type of the node
	   * returns null if the node isn't anything we care about
	   */
	  getNodeInfo: function (node) {
	    if (!node) {
	      return null;
	    }

	    let classes = node.classList;

	    // Check if the node isn't a selector first since this doesn't require
	    // walking the DOM
	    if (classes.contains("matched") ||
	        classes.contains("bestmatch") ||
	        classes.contains("parentmatch")) {
	      let selectorText = "";
	      for (let child of node.childNodes) {
	        if (child.nodeType === node.TEXT_NODE) {
	          selectorText += child.textContent;
	        }
	      }
	      return {
	        type: overlays.VIEW_NODE_SELECTOR_TYPE,
	        value: selectorText.trim()
	      };
	    }

	    // Walk up the nodes to find out where node is
	    let propertyView;
	    let propertyContent;
	    let parent = node;
	    while (parent.parentNode) {
	      if (parent.classList.contains("property-view")) {
	        propertyView = parent;
	        break;
	      }
	      if (parent.classList.contains("property-content")) {
	        propertyContent = parent;
	        break;
	      }
	      parent = parent.parentNode;
	    }
	    if (!propertyView && !propertyContent) {
	      return null;
	    }

	    let value, type;

	    // Get the property and value for a node that's a property name or value
	    let isHref = classes.contains("theme-link") && !classes.contains("link");
	    if (propertyView && (classes.contains("property-name") ||
	                         classes.contains("property-value") ||
	                         isHref)) {
	      value = {
	        property: parent.querySelector(".property-name").textContent,
	        value: parent.querySelector(".property-value").textContent
	      };
	    }
	    if (propertyContent && (classes.contains("other-property-value") ||
	                            isHref)) {
	      let view = propertyContent.previousSibling;
	      value = {
	        property: view.querySelector(".property-name").textContent,
	        value: node.textContent
	      };
	    }

	    // Get the type
	    if (classes.contains("property-name")) {
	      type = overlays.VIEW_NODE_PROPERTY_TYPE;
	    } else if (classes.contains("property-value") ||
	               classes.contains("other-property-value")) {
	      type = overlays.VIEW_NODE_VALUE_TYPE;
	    } else if (isHref) {
	      type = overlays.VIEW_NODE_IMAGE_URL_TYPE;
	      value.url = node.href;
	    } else {
	      return null;
	    }

	    return {type, value};
	  },

	  _createPropertyViews: function () {
	    if (this._createViewsPromise) {
	      return this._createViewsPromise;
	    }

	    let deferred = defer();
	    this._createViewsPromise = deferred.promise;

	    this.refreshSourceFilter();
	    this.numVisibleProperties = 0;
	    let fragment = this.styleDocument.createDocumentFragment();

	    this._createViewsProcess = new UpdateProcess(
	      this.styleWindow, CssComputedView.propertyNames, {
	        onItem: (propertyName) => {
	          // Per-item callback.
	          let propView = new PropertyView(this, propertyName);
	          fragment.appendChild(propView.buildMain());
	          fragment.appendChild(propView.buildSelectorContainer());

	          if (propView.visible) {
	            this.numVisibleProperties++;
	          }
	          this.propertyViews.push(propView);
	        },
	        onCancel: () => {
	          deferred.reject("_createPropertyViews cancelled");
	        },
	        onDone: () => {
	          // Completed callback.
	          this.element.appendChild(fragment);
	          this.noResults.hidden = this.numVisibleProperties > 0;
	          deferred.resolve(undefined);
	        }
	      }
	    );

	    this._createViewsProcess.schedule();
	    return deferred.promise;
	  },

	  /**
	   * Refresh the panel content.
	   */
	  refreshPanel: function () {
	    if (!this._viewedElement) {
	      return promise.resolve();
	    }

	    // Capture the current viewed element to return from the promise handler
	    // early if it changed
	    let viewedElement = this._viewedElement;

	    return promise.all([
	      this._createPropertyViews(),
	      this.pageStyle.getComputed(this._viewedElement, {
	        filter: this._sourceFilter,
	        onlyMatched: !this.includeBrowserStyles,
	        markMatched: true
	      })
	    ]).then(([, computed]) => {
	      if (viewedElement !== this._viewedElement) {
	        return promise.resolve();
	      }

	      this._matchedProperties = new Set();
	      for (let name in computed) {
	        if (computed[name].matched) {
	          this._matchedProperties.add(name);
	        }
	      }
	      this._computed = computed;

	      if (this._refreshProcess) {
	        this._refreshProcess.cancel();
	      }

	      this.noResults.hidden = true;

	      // Reset visible property count
	      this.numVisibleProperties = 0;

	      // Reset zebra striping.
	      this._darkStripe = true;

	      let deferred = defer();
	      this._refreshProcess = new UpdateProcess(
	        this.styleWindow, this.propertyViews, {
	          onItem: (propView) => {
	            propView.refresh();
	          },
	          onCancel: () => {
	            deferred.reject("_refreshProcess of computed view cancelled");
	          },
	          onDone: () => {
	            this._refreshProcess = null;
	            this.noResults.hidden = this.numVisibleProperties > 0;

	            if (this.searchField.value.length > 0 &&
	                !this.numVisibleProperties) {
	              this.searchField.classList
	                              .add("devtools-style-searchbox-no-match");
	            } else {
	              this.searchField.classList
	                              .remove("devtools-style-searchbox-no-match");
	            }

	            this.inspector.emit("computed-view-refreshed");
	            deferred.resolve(undefined);
	          }
	        }
	      );
	      this._refreshProcess.schedule();
	      return deferred.promise;
	    }).then(null, (err) => console.error(err));
	  },

	  /**
	   * Handle the shortcut events in the computed view.
	   */
	  _onShortcut: function (name, event) {
	    if (!event.target.closest("#sidebar-panel-computedview")) {
	      return;
	    }
	    // Handle the search box's keypress event. If the escape key is pressed,
	    // clear the search box field.
	    if (name === "Escape" && event.target === this.searchField &&
	        this._onClearSearch()) {
	      event.preventDefault();
	      event.stopPropagation();
	    } else if (name === "CmdOrCtrl+F") {
	      this.searchField.focus();
	      event.preventDefault();
	    }
	  },

	  /**
	   * Set the filter style search value.
	   * @param {String} value
	   *        The search value.
	   */
	  setFilterStyles: function (value = "") {
	    this.searchField.value = value;
	    this.searchField.focus();
	    this._onFilterStyles();
	  },

	  /**
	   * Called when the user enters a search term in the filter style search box.
	   */
	  _onFilterStyles: function () {
	    if (this._filterChangedTimeout) {
	      clearTimeout(this._filterChangedTimeout);
	    }

	    let filterTimeout = (this.searchField.value.length > 0)
	      ? FILTER_CHANGED_TIMEOUT : 0;
	    this.searchClearButton.hidden = this.searchField.value.length === 0;

	    this._filterChangedTimeout = setTimeout(() => {
	      if (this.searchField.value.length > 0) {
	        this.searchField.setAttribute("filled", true);
	        this.inspector.emit("computed-view-filtered", true);
	      } else {
	        this.searchField.removeAttribute("filled");
	        this.inspector.emit("computed-view-filtered", false);
	      }

	      this.refreshPanel();
	      this._filterChangeTimeout = null;
	    }, filterTimeout);
	  },

	  /**
	   * Context menu handler for filter style search box.
	   */
	  _onFilterTextboxContextMenu: function (event) {
	    try {
	      this.styleDocument.defaultView.focus();
	      let contextmenu = this.inspector.toolbox.textboxContextMenuPopup;
	      contextmenu.openPopupAtScreen(event.screenX, event.screenY, true);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  /**
	   * Called when the user clicks on the clear button in the filter style search
	   * box. Returns true if the search box is cleared and false otherwise.
	   */
	  _onClearSearch: function () {
	    if (this.searchField.value) {
	      this.setFilterStyles("");
	      return true;
	    }

	    return false;
	  },

	  /**
	   * The change event handler for the includeBrowserStyles checkbox.
	   */
	  _onIncludeBrowserStyles: function () {
	    this.refreshSourceFilter();
	    this.refreshPanel();
	  },

	  /**
	   * When includeBrowserStylesCheckbox.checked is false we only display
	   * properties that have matched selectors and have been included by the
	   * document or one of thedocument's stylesheets. If .checked is false we
	   * display all properties including those that come from UA stylesheets.
	   */
	  refreshSourceFilter: function () {
	    this._matchedProperties = null;
	    this._sourceFilter = this.includeBrowserStyles ?
	                                 CssLogic.FILTER.UA :
	                                 CssLogic.FILTER.USER;
	  },

	  _onSourcePrefChanged: function () {
	    for (let propView of this.propertyViews) {
	      propView.updateSourceLinks();
	    }
	    this.inspector.emit("computed-view-sourcelinks-updated");
	  },

	  /**
	   * The CSS as displayed by the UI.
	   */
	  createStyleViews: function () {
	    if (CssComputedView.propertyNames) {
	      return;
	    }

	    CssComputedView.propertyNames = [];

	    // Here we build and cache a list of css properties supported by the browser
	    // We could use any element but let's use the main document's root element
	    let styles = this.styleWindow
	      .getComputedStyle(this.styleDocument.documentElement);
	    let mozProps = [];
	    for (let i = 0, numStyles = styles.length; i < numStyles; i++) {
	      let prop = styles.item(i);
	      if (prop.startsWith("--")) {
	        // Skip any CSS variables used inside of browser CSS files
	        continue;
	      } else if (prop.startsWith("-")) {
	        mozProps.push(prop);
	      } else {
	        CssComputedView.propertyNames.push(prop);
	      }
	    }

	    CssComputedView.propertyNames.sort();
	    CssComputedView.propertyNames.push.apply(CssComputedView.propertyNames,
	      mozProps.sort());

	    this._createPropertyViews().then(null, e => {
	      if (!this._isDestroyed) {
	        console.warn("The creation of property views was cancelled because " +
	          "the computed-view was destroyed before it was done creating views");
	      } else {
	        console.error(e);
	      }
	    });
	  },

	  /**
	   * Get a set of properties that have matched selectors.
	   *
	   * @return {Set} If a property name is in the set, it has matching selectors.
	   */
	  get matchedProperties() {
	    return this._matchedProperties || new Set();
	  },

	  /**
	   * Focus the window on mousedown.
	   */
	  focusWindow: function () {
	    let win = this.styleDocument.defaultView;
	    win.focus();
	  },

	  /**
	   * Context menu handler.
	   */
	  _onContextMenu: function (event) {
	    this._contextmenu.show(event);
	  },

	  _onClick: function (event) {
	    let target = event.target;

	    if (target.nodeName === "a") {
	      event.stopPropagation();
	      event.preventDefault();
	      let browserWin = this.inspector.target.tab.ownerDocument.defaultView;
	      browserWin.openUILinkIn(target.href, "tab");
	    }
	  },

	  /**
	   * Callback for copy event. Copy selected text.
	   *
	   * @param {Event} event
	   *        copy event object.
	   */
	  _onCopy: function (event) {
	    this.copySelection();
	    event.preventDefault();
	  },

	  /**
	   * Copy the current selection to the clipboard
	   */
	  copySelection: function () {
	    try {
	      let win = this.styleDocument.defaultView;
	      let text = win.getSelection().toString().trim();

	      // Tidy up block headings by moving CSS property names and their
	      // values onto the same line and inserting a colon between them.
	      let textArray = text.split(/[\r\n]+/);
	      let result = "";

	      // Parse text array to output string.
	      if (textArray.length > 1) {
	        for (let prop of textArray) {
	          if (CssComputedView.propertyNames.indexOf(prop) !== -1) {
	            // Property name
	            result += prop;
	          } else {
	            // Property value
	            result += ": " + prop + ";\n";
	          }
	        }
	      } else {
	        // Short text fragment.
	        result = textArray[0];
	      }

	      clipboardHelper.copyString(result);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  /**
	   * Destructor for CssComputedView.
	   */
	  destroy: function () {
	    this._viewedElement = null;
	    this._outputParser = null;

	    gDevTools.off("pref-changed", this._handlePrefChange);

	    this._prefObserver.off(PREF_ORIG_SOURCES, this._onSourcePrefChanged);
	    this._prefObserver.destroy();

	    // Cancel tree construction
	    if (this._createViewsProcess) {
	      this._createViewsProcess.cancel();
	    }
	    if (this._refreshProcess) {
	      this._refreshProcess.cancel();
	    }

	    // Remove context menu
	    if (this._contextmenu) {
	      this._contextmenu.destroy();
	      this._contextmenu = null;
	    }

	    this.tooltips.destroy();
	    this.highlighters.destroy();

	    // Remove bound listeners
	    this.styleDocument.removeEventListener("mousedown", this.focusWindow);
	    this.element.removeEventListener("click", this._onClick);
	    this.element.removeEventListener("copy", this._onCopy);
	    this.element.removeEventListener("contextmenu", this._onContextMenu);
	    this.searchField.removeEventListener("input", this._onFilterStyles);
	    this.searchField.removeEventListener("contextmenu",
	                                         this._onFilterTextboxContextMenu);
	    this.searchClearButton.removeEventListener("click", this._onClearSearch);
	    this.includeBrowserStylesCheckbox.removeEventListener("input",
	      this._onIncludeBrowserStyles);

	    // Nodes used in templating
	    this.element = null;
	    this.panel = null;
	    this.searchField = null;
	    this.searchClearButton = null;
	    this.includeBrowserStylesCheckbox = null;

	    // Property views
	    for (let propView of this.propertyViews) {
	      propView.destroy();
	    }
	    this.propertyViews = null;

	    this.inspector = null;
	    this.styleDocument = null;
	    this.styleWindow = null;

	    this._isDestroyed = true;
	  }
	};

	function PropertyInfo(tree, name) {
	  this.tree = tree;
	  this.name = name;
	}

	PropertyInfo.prototype = {
	  get value() {
	    if (this.tree._computed) {
	      let value = this.tree._computed[this.name].value;
	      return value;
	    }
	    return null;
	  }
	};

	/**
	 * A container to give easy access to property data from the template engine.
	 *
	 * @param {CssComputedView} tree
	 *        The CssComputedView instance we are working with.
	 * @param {String} name
	 *        The CSS property name for which this PropertyView
	 *        instance will render the rules.
	 */
	function PropertyView(tree, name) {
	  this.tree = tree;
	  this.name = name;

	  this.link = "https://developer.mozilla.org/CSS/" + name;

	  this._propertyInfo = new PropertyInfo(tree, name);
	}

	PropertyView.prototype = {
	  // The parent element which contains the open attribute
	  element: null,

	  // Property header node
	  propertyHeader: null,

	  // Destination for property names
	  nameNode: null,

	  // Destination for property values
	  valueNode: null,

	  // Are matched rules expanded?
	  matchedExpanded: false,

	  // Matched selector container
	  matchedSelectorsContainer: null,

	  // Matched selector expando
	  matchedExpander: null,

	  // Cache for matched selector views
	  _matchedSelectorViews: null,

	  // The previously selected element used for the selector view caches
	  _prevViewedElement: null,

	  /**
	   * Get the computed style for the current property.
	   *
	   * @return {String} the computed style for the current property of the
	   * currently highlighted element.
	   */
	  get value() {
	    return this.propertyInfo.value;
	  },

	  /**
	   * An easy way to access the CssPropertyInfo behind this PropertyView.
	   */
	  get propertyInfo() {
	    return this._propertyInfo;
	  },

	  /**
	   * Does the property have any matched selectors?
	   */
	  get hasMatchedSelectors() {
	    return this.tree.matchedProperties.has(this.name);
	  },

	  /**
	   * Should this property be visible?
	   */
	  get visible() {
	    if (!this.tree._viewedElement) {
	      return false;
	    }

	    if (!this.tree.includeBrowserStyles && !this.hasMatchedSelectors) {
	      return false;
	    }

	    let searchTerm = this.tree.searchField.value.toLowerCase();
	    let isValidSearchTerm = searchTerm.trim().length > 0;
	    if (isValidSearchTerm &&
	        this.name.toLowerCase().indexOf(searchTerm) === -1 &&
	        this.value.toLowerCase().indexOf(searchTerm) === -1) {
	      return false;
	    }

	    return true;
	  },

	  /**
	   * Returns the className that should be assigned to the propertyView.
	   *
	   * @return {String}
	   */
	  get propertyHeaderClassName() {
	    if (this.visible) {
	      let isDark = this.tree._darkStripe = !this.tree._darkStripe;
	      return isDark ? "property-view row-striped" : "property-view";
	    }
	    return "property-view-hidden";
	  },

	  /**
	   * Returns the className that should be assigned to the propertyView content
	   * container.
	   *
	   * @return {String}
	   */
	  get propertyContentClassName() {
	    if (this.visible) {
	      let isDark = this.tree._darkStripe;
	      return isDark ? "property-content row-striped" : "property-content";
	    }
	    return "property-content-hidden";
	  },

	  /**
	   * Build the markup for on computed style
	   *
	   * @return {Element}
	   */
	  buildMain: function () {
	    let doc = this.tree.styleDocument;

	    // Build the container element
	    this.onMatchedToggle = this.onMatchedToggle.bind(this);
	    this.element = doc.createElementNS(HTML_NS, "div");
	    this.element.setAttribute("class", this.propertyHeaderClassName);
	    this.element.addEventListener("dblclick", this.onMatchedToggle, false);

	    // Make it keyboard navigable
	    this.element.setAttribute("tabindex", "0");
	    this.shortcuts = new KeyShortcuts({
	      window: this.tree.styleWindow,
	      target: this.element
	    });
	    this.shortcuts.on("F1", (name, event) => {
	      this.mdnLinkClick(event);
	    });
	    this.shortcuts.on("Return", (name, event) => this.onMatchedToggle(event));
	    this.shortcuts.on("Space", (name, event) => this.onMatchedToggle(event));

	    let nameContainer = doc.createElementNS(HTML_NS, "div");
	    nameContainer.className = "property-name-container";
	    this.element.appendChild(nameContainer);

	    // Build the twisty expand/collapse
	    this.matchedExpander = doc.createElementNS(HTML_NS, "div");
	    this.matchedExpander.className = "expander theme-twisty";
	    this.matchedExpander.addEventListener("click", this.onMatchedToggle, false);
	    nameContainer.appendChild(this.matchedExpander);

	    // Build the style name element
	    this.nameNode = doc.createElementNS(HTML_NS, "div");
	    this.nameNode.setAttribute("class", "property-name theme-fg-color5");
	    // Reset its tabindex attribute otherwise, if an ellipsis is applied
	    // it will be reachable via TABing
	    this.nameNode.setAttribute("tabindex", "");
	    this.nameNode.textContent = this.nameNode.title = this.name;
	    // Make it hand over the focus to the container
	    this.onFocus = () => this.element.focus();
	    this.nameNode.addEventListener("click", this.onFocus, false);
	    nameContainer.appendChild(this.nameNode);

	    let valueContainer = doc.createElementNS(HTML_NS, "div");
	    valueContainer.className = "property-value-container";
	    this.element.appendChild(valueContainer);

	    // Build the style value element
	    this.valueNode = doc.createElementNS(HTML_NS, "div");
	    this.valueNode.setAttribute("class", "property-value theme-fg-color1");
	    // Reset its tabindex attribute otherwise, if an ellipsis is applied
	    // it will be reachable via TABing
	    this.valueNode.setAttribute("tabindex", "");
	    this.valueNode.setAttribute("dir", "ltr");
	    // Make it hand over the focus to the container
	    this.valueNode.addEventListener("click", this.onFocus, false);
	    valueContainer.appendChild(this.valueNode);

	    return this.element;
	  },

	  buildSelectorContainer: function () {
	    let doc = this.tree.styleDocument;
	    let element = doc.createElementNS(HTML_NS, "div");
	    element.setAttribute("class", this.propertyContentClassName);
	    this.matchedSelectorsContainer = doc.createElementNS(HTML_NS, "div");
	    this.matchedSelectorsContainer.setAttribute("class", "matchedselectors");
	    element.appendChild(this.matchedSelectorsContainer);

	    return element;
	  },

	  /**
	   * Refresh the panel's CSS property value.
	   */
	  refresh: function () {
	    this.element.className = this.propertyHeaderClassName;
	    this.element.nextElementSibling.className = this.propertyContentClassName;

	    if (this._prevViewedElement !== this.tree._viewedElement) {
	      this._matchedSelectorViews = null;
	      this._prevViewedElement = this.tree._viewedElement;
	    }

	    if (!this.tree._viewedElement || !this.visible) {
	      this.valueNode.textContent = this.valueNode.title = "";
	      this.matchedSelectorsContainer.parentNode.hidden = true;
	      this.matchedSelectorsContainer.textContent = "";
	      this.matchedExpander.removeAttribute("open");
	      return;
	    }

	    this.tree.numVisibleProperties++;

	    let outputParser = this.tree._outputParser;
	    let frag = outputParser.parseCssProperty(this.propertyInfo.name,
	      this.propertyInfo.value,
	      {
	        colorSwatchClass: "computedview-colorswatch",
	        colorClass: "computedview-color",
	        urlClass: "theme-link"
	        // No need to use baseURI here as computed URIs are never relative.
	      });
	    this.valueNode.innerHTML = "";
	    this.valueNode.appendChild(frag);

	    this.refreshMatchedSelectors();
	  },

	  /**
	   * Refresh the panel matched rules.
	   */
	  refreshMatchedSelectors: function () {
	    let hasMatchedSelectors = this.hasMatchedSelectors;
	    this.matchedSelectorsContainer.parentNode.hidden = !hasMatchedSelectors;

	    if (hasMatchedSelectors) {
	      this.matchedExpander.classList.add("expandable");
	    } else {
	      this.matchedExpander.classList.remove("expandable");
	    }

	    if (this.matchedExpanded && hasMatchedSelectors) {
	      return this.tree.pageStyle
	        .getMatchedSelectors(this.tree._viewedElement, this.name)
	        .then(matched => {
	          if (!this.matchedExpanded) {
	            return promise.resolve(undefined);
	          }

	          this._matchedSelectorResponse = matched;

	          return this._buildMatchedSelectors().then(() => {
	            this.matchedExpander.setAttribute("open", "");
	            this.tree.inspector.emit("computed-view-property-expanded");
	          });
	        }).then(null, console.error);
	    }

	    this.matchedSelectorsContainer.innerHTML = "";
	    this.matchedExpander.removeAttribute("open");
	    this.tree.inspector.emit("computed-view-property-collapsed");
	    return promise.resolve(undefined);
	  },

	  get matchedSelectors() {
	    return this._matchedSelectorResponse;
	  },

	  _buildMatchedSelectors: function () {
	    let promises = [];
	    let frag = this.element.ownerDocument.createDocumentFragment();

	    for (let selector of this.matchedSelectorViews) {
	      let p = createChild(frag, "p");
	      let span = createChild(p, "span", {
	        class: "rule-link"
	      });
	      let link = createChild(span, "a", {
	        target: "_blank",
	        class: "link theme-link",
	        title: selector.href,
	        sourcelocation: selector.source,
	        tabindex: "0",
	        textContent: selector.source
	      });
	      link.addEventListener("click", selector.openStyleEditor, false);
	      let shortcuts = new KeyShortcuts({
	        window: this.tree.styleWindow,
	        target: link
	      });
	      shortcuts.on("Return", () => selector.openStyleEditor());

	      let status = createChild(p, "span", {
	        dir: "ltr",
	        class: "rule-text theme-fg-color3 " + selector.statusClass,
	        title: selector.statusText,
	        textContent: selector.sourceText
	      });
	      let valueSpan = createChild(status, "span", {
	        class: "other-property-value theme-fg-color1"
	      });
	      valueSpan.appendChild(selector.outputFragment);
	      promises.push(selector.ready);
	    }

	    this.matchedSelectorsContainer.innerHTML = "";
	    this.matchedSelectorsContainer.appendChild(frag);
	    return promise.all(promises);
	  },

	  /**
	   * Provide access to the matched SelectorViews that we are currently
	   * displaying.
	   */
	  get matchedSelectorViews() {
	    if (!this._matchedSelectorViews) {
	      this._matchedSelectorViews = [];
	      this._matchedSelectorResponse.forEach(selectorInfo => {
	        let selectorView = new SelectorView(this.tree, selectorInfo);
	        this._matchedSelectorViews.push(selectorView);
	      }, this);
	    }
	    return this._matchedSelectorViews;
	  },

	  /**
	   * Update all the selector source links to reflect whether we're linking to
	   * original sources (e.g. Sass files).
	   */
	  updateSourceLinks: function () {
	    if (!this._matchedSelectorViews) {
	      return;
	    }
	    for (let view of this._matchedSelectorViews) {
	      view.updateSourceLink();
	    }
	  },

	  /**
	   * The action when a user expands matched selectors.
	   *
	   * @param {Event} event
	   *        Used to determine the class name of the targets click
	   *        event.
	   */
	  onMatchedToggle: function (event) {
	    if (event.shiftKey) {
	      return;
	    }
	    this.matchedExpanded = !this.matchedExpanded;
	    this.refreshMatchedSelectors();
	    event.preventDefault();
	  },

	  /**
	   * The action when a user clicks on the MDN help link for a property.
	   */
	  mdnLinkClick: function (event) {
	    let inspector = this.tree.inspector;

	    if (inspector.target.tab) {
	      let browserWin = inspector.target.tab.ownerDocument.defaultView;
	      browserWin.openUILinkIn(this.link, "tab");
	    }
	    event.preventDefault();
	    event.stopPropagation();
	  },

	  /**
	   * Destroy this property view, removing event listeners
	   */
	  destroy: function () {
	    this.element.removeEventListener("dblclick", this.onMatchedToggle, false);
	    this.shortcuts.destroy();
	    this.element = null;

	    this.matchedExpander.removeEventListener("click", this.onMatchedToggle,
	                                             false);
	    this.matchedExpander = null;

	    this.nameNode.removeEventListener("click", this.onFocus, false);
	    this.nameNode = null;

	    this.valueNode.removeEventListener("click", this.onFocus, false);
	    this.valueNode = null;
	  }
	};

	/**
	 * A container to give us easy access to display data from a CssRule
	 *
	 * @param CssComputedView tree
	 *        the owning CssComputedView
	 * @param selectorInfo
	 */
	function SelectorView(tree, selectorInfo) {
	  this.tree = tree;
	  this.selectorInfo = selectorInfo;
	  this._cacheStatusNames();

	  this.openStyleEditor = this.openStyleEditor.bind(this);

	  this.ready = this.updateSourceLink();
	}

	/**
	 * Decode for cssInfo.rule.status
	 * @see SelectorView.prototype._cacheStatusNames
	 * @see CssLogic.STATUS
	 */
	SelectorView.STATUS_NAMES = [
	  // "Parent Match", "Matched", "Best Match"
	];

	SelectorView.CLASS_NAMES = [
	  "parentmatch", "matched", "bestmatch"
	];

	SelectorView.prototype = {
	  /**
	   * Cache localized status names.
	   *
	   * These statuses are localized inside the styleinspector.properties string
	   * bundle.
	   * @see css-logic.js - the CssLogic.STATUS array.
	   */
	  _cacheStatusNames: function () {
	    if (SelectorView.STATUS_NAMES.length) {
	      return;
	    }

	    for (let status in CssLogic.STATUS) {
	      let i = CssLogic.STATUS[status];
	      if (i > CssLogic.STATUS.UNMATCHED) {
	        let value = CssComputedView.l10n("rule.status." + status);
	        // Replace normal spaces with non-breaking spaces
	        SelectorView.STATUS_NAMES[i] = value.replace(/ /g, "\u00A0");
	      }
	    }
	  },

	  /**
	   * A localized version of cssRule.status
	   */
	  get statusText() {
	    return SelectorView.STATUS_NAMES[this.selectorInfo.status];
	  },

	  /**
	   * Get class name for selector depending on status
	   */
	  get statusClass() {
	    return SelectorView.CLASS_NAMES[this.selectorInfo.status - 1];
	  },

	  get href() {
	    if (this._href) {
	      return this._href;
	    }
	    let sheet = this.selectorInfo.rule.parentStyleSheet;
	    this._href = sheet ? sheet.href : "#";
	    return this._href;
	  },

	  get sourceText() {
	    return this.selectorInfo.sourceText;
	  },

	  get value() {
	    return this.selectorInfo.value;
	  },

	  get outputFragment() {
	    // Sadly, because this fragment is added to the template by DOM Templater
	    // we lose any events that are attached. This means that URLs will open in a
	    // new window. At some point we should fix this by stopping using the
	    // templater.
	    let outputParser = this.tree._outputParser;
	    let frag = outputParser.parseCssProperty(
	      this.selectorInfo.name,
	      this.selectorInfo.value, {
	        colorSwatchClass: "computedview-colorswatch",
	        colorClass: "computedview-color",
	        urlClass: "theme-link",
	        baseURI: this.selectorInfo.rule.href
	      }
	    );
	    return frag;
	  },

	  /**
	   * Update the text of the source link to reflect whether we're showing
	   * original sources or not.
	   */
	  updateSourceLink: function () {
	    return this.updateSource().then((oldSource) => {
	      if (oldSource !== this.source && this.tree.element) {
	        let selector = '[sourcelocation="' + oldSource + '"]';
	        let link = this.tree.element.querySelector(selector);
	        if (link) {
	          link.textContent = this.source;
	          link.setAttribute("sourcelocation", this.source);
	        }
	      }
	    });
	  },

	  /**
	   * Update the 'source' store based on our original sources preference.
	   */
	  updateSource: function () {
	    let rule = this.selectorInfo.rule;
	    this.sheet = rule.parentStyleSheet;

	    if (!rule || !this.sheet) {
	      let oldSource = this.source;
	      this.source = CssLogic.l10n("rule.sourceElement");
	      return promise.resolve(oldSource);
	    }

	    let showOrig = Services.prefs.getBoolPref(PREF_ORIG_SOURCES);

	    if (showOrig && rule.type !== ELEMENT_STYLE) {
	      let deferred = defer();

	      // set as this first so we show something while we're fetching
	      this.source = CssLogic.shortSource(this.sheet) + ":" + rule.line;

	      rule.getOriginalLocation().then(({href, line}) => {
	        let oldSource = this.source;
	        this.source = CssLogic.shortSource({href: href}) + ":" + line;
	        deferred.resolve(oldSource);
	      });

	      return deferred.promise;
	    }

	    let oldSource = this.source;
	    this.source = CssLogic.shortSource(this.sheet) + ":" + rule.line;
	    return promise.resolve(oldSource);
	  },

	  /**
	   * When a css link is clicked this method is called in order to either:
	   *   1. Open the link in view source (for chrome stylesheets).
	   *   2. Open the link in the style editor.
	   *
	   *   We can only view stylesheets contained in document.styleSheets inside the
	   *   style editor.
	   */
	  openStyleEditor: function () {
	    let inspector = this.tree.inspector;
	    let rule = this.selectorInfo.rule;

	    // The style editor can only display stylesheets coming from content because
	    // chrome stylesheets are not listed in the editor's stylesheet selector.
	    //
	    // If the stylesheet is a content stylesheet we send it to the style
	    // editor else we display it in the view source window.
	    let parentStyleSheet = rule.parentStyleSheet;
	    if (!parentStyleSheet || parentStyleSheet.isSystem) {
	      let toolbox = gDevTools.getToolbox(inspector.target);
	      toolbox.viewSource(rule.href, rule.line);
	      return;
	    }

	    let location = promise.resolve(rule.location);
	    if (Services.prefs.getBoolPref(PREF_ORIG_SOURCES)) {
	      location = rule.getOriginalLocation();
	    }

	    location.then(({source, href, line, column}) => {
	      let target = inspector.target;
	      if (ToolDefinitions.styleEditor.isTargetSupported(target)) {
	        gDevTools.showToolbox(target, "styleeditor").then(function (toolbox) {
	          let sheet = source || href;
	          toolbox.getCurrentPanel().selectStyleSheet(sheet, line, column);
	        });
	      }
	    });
	  }
	};

	function ComputedViewTool(inspector, window) {
	  this.inspector = inspector;
	  this.document = window.document;

	  this.computedView = new CssComputedView(this.inspector, this.document,
	    this.inspector.pageStyle);
	  this.layoutView = new LayoutView(this.inspector, this.document);

	  this.onSelected = this.onSelected.bind(this);
	  this.refresh = this.refresh.bind(this);
	  this.onPanelSelected = this.onPanelSelected.bind(this);
	  this.onMutations = this.onMutations.bind(this);
	  this.onResized = this.onResized.bind(this);

	  this.inspector.selection.on("detached-front", this.onSelected);
	  this.inspector.selection.on("new-node-front", this.onSelected);
	  this.inspector.selection.on("pseudoclass", this.refresh);
	  this.inspector.sidebar.on("computedview-selected", this.onPanelSelected);
	  this.inspector.pageStyle.on("stylesheet-updated", this.refresh);
	  this.inspector.walker.on("mutations", this.onMutations);
	  this.inspector.walker.on("resize", this.onResized);

	  this.computedView.selectElement(null);

	  this.onSelected();
	}

	ComputedViewTool.prototype = {
	  isSidebarActive: function () {
	    if (!this.computedView) {
	      return false;
	    }
	    return this.inspector.sidebar.getCurrentTabID() == "computedview";
	  },

	  onSelected: function (event) {
	    // Ignore the event if the view has been destroyed, or if it's inactive.
	    // But only if the current selection isn't null. If it's been set to null,
	    // let the update go through as this is needed to empty the view on
	    // navigation.
	    if (!this.computedView) {
	      return;
	    }

	    let isInactive = !this.isSidebarActive() &&
	                     this.inspector.selection.nodeFront;
	    if (isInactive) {
	      return;
	    }

	    this.computedView.setPageStyle(this.inspector.pageStyle);

	    if (!this.inspector.selection.isConnected() ||
	        !this.inspector.selection.isElementNode()) {
	      this.computedView.selectElement(null);
	      return;
	    }

	    if (!event || event == "new-node-front") {
	      let done = this.inspector.updating("computed-view");
	      this.computedView.selectElement(this.inspector.selection.nodeFront).then(() => {
	        done();
	      });
	    }
	  },

	  refresh: function () {
	    if (this.isSidebarActive()) {
	      this.computedView.refreshPanel();
	    }
	  },

	  onPanelSelected: function () {
	    if (this.inspector.selection.nodeFront === this.computedView._viewedElement) {
	      this.refresh();
	    } else {
	      this.onSelected();
	    }
	  },

	  /**
	   * When markup mutations occur, if an attribute of the selected node changes,
	   * we need to refresh the view as that might change the node's styles.
	   */
	  onMutations: function (mutations) {
	    for (let {type, target} of mutations) {
	      if (target === this.inspector.selection.nodeFront &&
	          type === "attributes") {
	        this.refresh();
	        break;
	      }
	    }
	  },

	  /**
	   * When the window gets resized, this may cause media-queries to match, and
	   * therefore, different styles may apply.
	   */
	  onResized: function () {
	    this.refresh();
	  },

	  destroy: function () {
	    this.inspector.walker.off("mutations", this.onMutations);
	    this.inspector.walker.off("resize", this.onResized);
	    this.inspector.sidebar.off("computedview-selected", this.refresh);
	    this.inspector.selection.off("pseudoclass", this.refresh);
	    this.inspector.selection.off("new-node-front", this.onSelected);
	    this.inspector.selection.off("detached-front", this.onSelected);
	    this.inspector.sidebar.off("computedview-selected", this.onPanelSelected);
	    if (this.inspector.pageStyle) {
	      this.inspector.pageStyle.off("stylesheet-updated", this.refresh);
	    }

	    this.computedView.destroy();
	    this.layoutView.destroy();

	    this.computedView = this.layoutView = this.document = this.inspector = null;
	  }
	};

	exports.CssComputedView = CssComputedView;
	exports.ComputedViewTool = ComputedViewTool;
	exports.PropertyView = PropertyView;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);
	const osString = Services.appinfo.OS;

	// Panels
	// loader.lazyGetter(this, "OptionsPanel", () => require("devtools/client/framework/toolbox-options").OptionsPanel);
	// loader.lazyGetter(this, "InspectorPanel", () => require("devtools/client/inspector/inspector-panel").InspectorPanel);
	// loader.lazyGetter(this, "WebConsolePanel", () => require("devtools/client/webconsole/panel").WebConsolePanel);
	// loader.lazyGetter(this, "DebuggerPanel", () => require("devtools/client/debugger/panel").DebuggerPanel);
	// loader.lazyGetter(this, "StyleEditorPanel", () => require("devtools/client/styleeditor/styleeditor-panel").StyleEditorPanel);
	// loader.lazyGetter(this, "ShaderEditorPanel", () => require("devtools/client/shadereditor/panel").ShaderEditorPanel);
	// loader.lazyGetter(this, "CanvasDebuggerPanel", () => require("devtools/client/canvasdebugger/panel").CanvasDebuggerPanel);
	// loader.lazyGetter(this, "WebAudioEditorPanel", () => require("devtools/client/webaudioeditor/panel").WebAudioEditorPanel);
	// loader.lazyGetter(this, "MemoryPanel", () => require("devtools/client/memory/panel").MemoryPanel);
	// loader.lazyGetter(this, "PerformancePanel", () => require("devtools/client/performance/panel").PerformancePanel);
	// loader.lazyGetter(this, "NetMonitorPanel", () => require("devtools/client/netmonitor/panel").NetMonitorPanel);
	// loader.lazyGetter(this, "StoragePanel", () => require("devtools/client/storage/panel").StoragePanel);
	// loader.lazyGetter(this, "ScratchpadPanel", () => require("devtools/client/scratchpad/scratchpad-panel").ScratchpadPanel);
	// loader.lazyGetter(this, "DomPanel", () => require("devtools/client/dom/dom-panel").DomPanel);

	const {LocalizationHelper} = __webpack_require__(39);
	const L10N = new LocalizationHelper("devtools/locale/startup.properties");

	var Tools = {};
	exports.Tools = Tools;

	// Definitions
	Tools.options = {
	  id: "options",
	  ordinal: 0,
	  url: "chrome://devtools/content/framework/toolbox-options.xhtml",
	  icon: "chrome://devtools/skin/images/tool-options.svg",
	  invertIconForDarkTheme: true,
	  bgTheme: "theme-body",
	  label: l10n("options.label"),
	  iconOnly: true,
	  panelLabel: l10n("options.panelLabel"),
	  tooltip: l10n("optionsButton.tooltip"),
	  inMenu: false,

	  isTargetSupported: function () {
	    return true;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new OptionsPanel(iframeWindow, toolbox);
	  }
	};

	Tools.inspector = {
	  id: "inspector",
	  accesskey: l10n("inspector.accesskey"),
	  key: l10n("inspector.commandkey"),
	  ordinal: 1,
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  icon: "chrome://devtools/skin/images/tool-inspector.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/inspector/inspector.xul",
	  label: l10n("inspector.label"),
	  panelLabel: l10n("inspector.panelLabel"),
	  get tooltip() {
	    return l10n("inspector.tooltip2",
	    (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,
	  commands: [
	    "devtools/client/responsivedesign/resize-commands",
	    "devtools/client/inspector/inspector-commands"
	  ],

	  preventClosingOnKey: true,
	  onkey: function (panel, toolbox) {
	    toolbox.highlighterUtils.togglePicker();
	  },

	  isTargetSupported: function (target) {
	    return target.hasActor("inspector");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new InspectorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.webConsole = {
	  id: "webconsole",
	  key: l10n("cmd.commandkey"),
	  accesskey: l10n("webConsoleCmd.accesskey"),
	  modifiers: Services.appinfo.OS == "Darwin" ? "accel,alt" : "accel,shift",
	  ordinal: 2,
	  icon: "chrome://devtools/skin/images/tool-webconsole.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/webconsole/webconsole.xul",
	  label: l10n("ToolboxTabWebconsole.label"),
	  menuLabel: l10n("MenuWebconsole.label"),
	  panelLabel: l10n("ToolboxWebConsole.panelLabel"),
	  get tooltip() {
	    return l10n("ToolboxWebconsole.tooltip2",
	    (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,
	  commands: "devtools/client/webconsole/console-commands",

	  preventClosingOnKey: true,
	  onkey: function (panel, toolbox) {
	    if (toolbox.splitConsole) {
	      return toolbox.focusConsoleInput();
	    }

	    panel.focusInput();
	    return undefined;
	  },

	  isTargetSupported: function () {
	    return true;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new WebConsolePanel(iframeWindow, toolbox);
	  }
	};

	Tools.jsdebugger = {
	  id: "jsdebugger",
	  key: l10n("debuggerMenu.commandkey"),
	  accesskey: l10n("debuggerMenu.accesskey"),
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  ordinal: 3,
	  icon: "chrome://devtools/skin/images/tool-debugger.svg",
	  invertIconForDarkTheme: true,
	  highlightedicon: "chrome://devtools/skin/images/tool-debugger-paused.svg",
	  url: "chrome://devtools/content/debugger/debugger.xul",
	  label: l10n("ToolboxDebugger.label"),
	  panelLabel: l10n("ToolboxDebugger.panelLabel"),
	  get tooltip() {
	    return l10n("ToolboxDebugger.tooltip2",
	    (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,
	  commands: "devtools/client/debugger/debugger-commands",

	  isTargetSupported: function () {
	    return true;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new DebuggerPanel(iframeWindow, toolbox);
	  }
	};

	function switchDebugger() {
	  if (Services.prefs.getBoolPref("devtools.debugger.new-debugger-frontend")) {
	    const NewDebuggerPanel = __webpack_require__(121).DebuggerPanel;

	    Tools.jsdebugger.url = "chrome://devtools/content/debugger/new/index.html";
	    Tools.jsdebugger.build = function (iframeWindow, toolbox) {
	      return new NewDebuggerPanel(iframeWindow, toolbox);
	    };
	  } else {
	    Tools.jsdebugger.url = "chrome://devtools/content/debugger/debugger.xul";
	    Tools.jsdebugger.build = function (iframeWindow, toolbox) {
	      return new DebuggerPanel(iframeWindow, toolbox);
	    };
	  }
	}
	switchDebugger();

	Services.prefs.addObserver(
	  "devtools.debugger.new-debugger-frontend",
	  { observe: switchDebugger },
	  false
	);

	Tools.styleEditor = {
	  id: "styleeditor",
	  key: l10n("open.commandkey"),
	  ordinal: 4,
	  visibilityswitch: "devtools.styleeditor.enabled",
	  accesskey: l10n("open.accesskey"),
	  modifiers: "shift",
	  icon: "chrome://devtools/skin/images/tool-styleeditor.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/styleeditor/styleeditor.xul",
	  label: l10n("ToolboxStyleEditor.label"),
	  panelLabel: l10n("ToolboxStyleEditor.panelLabel"),
	  get tooltip() {
	    return l10n("ToolboxStyleEditor.tooltip3",
	    "Shift+" + functionkey(this.key));
	  },
	  inMenu: true,
	  commands: "devtools/client/styleeditor/styleeditor-commands",

	  isTargetSupported: function (target) {
	    return target.hasActor("styleEditor") || target.hasActor("styleSheets");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new StyleEditorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.shaderEditor = {
	  id: "shadereditor",
	  ordinal: 5,
	  visibilityswitch: "devtools.shadereditor.enabled",
	  icon: "chrome://devtools/skin/images/tool-shadereditor.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/shadereditor/shadereditor.xul",
	  label: l10n("ToolboxShaderEditor.label"),
	  panelLabel: l10n("ToolboxShaderEditor.panelLabel"),
	  tooltip: l10n("ToolboxShaderEditor.tooltip"),

	  isTargetSupported: function (target) {
	    return target.hasActor("webgl") && !target.chrome;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new ShaderEditorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.canvasDebugger = {
	  id: "canvasdebugger",
	  ordinal: 6,
	  visibilityswitch: "devtools.canvasdebugger.enabled",
	  icon: "chrome://devtools/skin/images/tool-canvas.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/canvasdebugger/canvasdebugger.xul",
	  label: l10n("ToolboxCanvasDebugger.label"),
	  panelLabel: l10n("ToolboxCanvasDebugger.panelLabel"),
	  tooltip: l10n("ToolboxCanvasDebugger.tooltip"),

	  // Hide the Canvas Debugger in the Add-on Debugger and Browser Toolbox
	  // (bug 1047520).
	  isTargetSupported: function (target) {
	    return target.hasActor("canvas") && !target.chrome;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new CanvasDebuggerPanel(iframeWindow, toolbox);
	  }
	};

	Tools.performance = {
	  id: "performance",
	  ordinal: 7,
	  icon: "chrome://devtools/skin/images/tool-profiler.svg",
	  invertIconForDarkTheme: true,
	  highlightedicon: "chrome://devtools/skin/images/tool-profiler-active.svg",
	  url: "chrome://devtools/content/performance/performance.xul",
	  visibilityswitch: "devtools.performance.enabled",
	  label: l10n("performance.label"),
	  panelLabel: l10n("performance.panelLabel"),
	  get tooltip() {
	    return l10n("performance.tooltip", "Shift+" + functionkey(this.key));
	  },
	  accesskey: l10n("performance.accesskey"),
	  key: l10n("performance.commandkey"),
	  modifiers: "shift",
	  inMenu: true,

	  isTargetSupported: function (target) {
	    return target.hasActor("profiler");
	  },

	  build: function (frame, target) {
	    return new PerformancePanel(frame, target);
	  }
	};

	Tools.memory = {
	  id: "memory",
	  ordinal: 8,
	  icon: "chrome://devtools/skin/images/tool-memory.svg",
	  invertIconForDarkTheme: true,
	  highlightedicon: "chrome://devtools/skin/images/tool-memory-active.svg",
	  url: "chrome://devtools/content/memory/memory.xhtml",
	  visibilityswitch: "devtools.memory.enabled",
	  label: l10n("memory.label"),
	  panelLabel: l10n("memory.panelLabel"),
	  tooltip: l10n("memory.tooltip"),

	  isTargetSupported: function (target) {
	    return target.getTrait("heapSnapshots") && !target.isAddon;
	  },

	  build: function (frame, target) {
	    return new MemoryPanel(frame, target);
	  }
	};

	Tools.netMonitor = {
	  id: "netmonitor",
	  accesskey: l10n("netmonitor.accesskey"),
	  key: l10n("netmonitor.commandkey"),
	  ordinal: 9,
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  visibilityswitch: "devtools.netmonitor.enabled",
	  icon: "chrome://devtools/skin/images/tool-network.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/netmonitor/netmonitor.xul",
	  label: l10n("netmonitor.label"),
	  panelLabel: l10n("netmonitor.panelLabel"),
	  get tooltip() {
	    return l10n("netmonitor.tooltip2",
	    (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,

	  isTargetSupported: function (target) {
	    return target.getTrait("networkMonitor");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new NetMonitorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.storage = {
	  id: "storage",
	  key: l10n("storage.commandkey"),
	  ordinal: 10,
	  accesskey: l10n("storage.accesskey"),
	  modifiers: "shift",
	  visibilityswitch: "devtools.storage.enabled",
	  icon: "chrome://devtools/skin/images/tool-storage.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/storage/storage.xul",
	  label: l10n("storage.label"),
	  menuLabel: l10n("storage.menuLabel"),
	  panelLabel: l10n("storage.panelLabel"),
	  get tooltip() {
	    return l10n("storage.tooltip3", "Shift+" + functionkey(this.key));
	  },
	  inMenu: true,

	  isTargetSupported: function (target) {
	    return target.isLocalTab ||
	           (target.hasActor("storage") && target.getTrait("storageInspector"));
	  },

	  build: function (iframeWindow, toolbox) {
	    return new StoragePanel(iframeWindow, toolbox);
	  }
	};

	Tools.webAudioEditor = {
	  id: "webaudioeditor",
	  ordinal: 11,
	  visibilityswitch: "devtools.webaudioeditor.enabled",
	  icon: "chrome://devtools/skin/images/tool-webaudio.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/webaudioeditor/webaudioeditor.xul",
	  label: l10n("ToolboxWebAudioEditor1.label"),
	  panelLabel: l10n("ToolboxWebAudioEditor1.panelLabel"),
	  tooltip: l10n("ToolboxWebAudioEditor1.tooltip"),

	  isTargetSupported: function (target) {
	    return !target.chrome && target.hasActor("webaudio");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new WebAudioEditorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.scratchpad = {
	  id: "scratchpad",
	  ordinal: 12,
	  visibilityswitch: "devtools.scratchpad.enabled",
	  icon: "chrome://devtools/skin/images/tool-scratchpad.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/scratchpad/scratchpad.xul",
	  label: l10n("scratchpad.label"),
	  panelLabel: l10n("scratchpad.panelLabel"),
	  tooltip: l10n("scratchpad.tooltip"),
	  inMenu: false,
	  commands: "devtools/client/scratchpad/scratchpad-commands",

	  isTargetSupported: function (target) {
	    return target.hasActor("console");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new ScratchpadPanel(iframeWindow, toolbox);
	  }
	};

	Tools.dom = {
	  id: "dom",
	  accesskey: l10n("dom.accesskey"),
	  key: l10n("dom.commandkey"),
	  ordinal: 13,
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  visibilityswitch: "devtools.dom.enabled",
	  icon: "chrome://devtools/skin/images/tool-dom.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/dom/dom.html",
	  label: l10n("dom.label"),
	  panelLabel: l10n("dom.panelLabel"),
	  get tooltip() {
	    return l10n("dom.tooltip",
	      (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,

	  isTargetSupported: function (target) {
	    return target.getTrait("webConsoleCommands");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new DomPanel(iframeWindow, toolbox);
	  }
	};

	var defaultTools = [
	  Tools.options,
	  Tools.webConsole,
	  Tools.inspector,
	  Tools.jsdebugger,
	  Tools.styleEditor,
	  Tools.shaderEditor,
	  Tools.canvasDebugger,
	  Tools.webAudioEditor,
	  Tools.performance,
	  Tools.netMonitor,
	  Tools.storage,
	  Tools.scratchpad,
	  Tools.memory,
	  Tools.dom,
	];

	exports.defaultTools = defaultTools;

	Tools.darkTheme = {
	  id: "dark",
	  label: l10n("options.darkTheme.label2"),
	  ordinal: 1,
	  stylesheets: ["chrome://devtools/skin/dark-theme.css"],
	  classList: ["theme-dark"],
	};

	Tools.lightTheme = {
	  id: "light",
	  label: l10n("options.lightTheme.label2"),
	  ordinal: 2,
	  stylesheets: ["chrome://devtools/skin/light-theme.css"],
	  classList: ["theme-light"],
	};

	Tools.firebugTheme = {
	  id: "firebug",
	  label: l10n("options.firebugTheme.label2"),
	  ordinal: 3,
	  stylesheets: ["chrome://devtools/skin/firebug-theme.css"],
	  classList: ["theme-light", "theme-firebug"],
	};

	exports.defaultThemes = [
	  Tools.darkTheme,
	  Tools.lightTheme,
	  Tools.firebugTheme,
	];

	/**
	 * Lookup l10n string from a string bundle.
	 *
	 * @param {string} name
	 *        The key to lookup.
	 * @param {string} arg
	 *        Optional format argument.
	 * @returns A localized version of the given key.
	 */
	function l10n(name, arg) {
	  try {
	    return arg ? L10N.getFormatStr(name, arg) : L10N.getStr(name);
	  } catch (ex) {
	    console.log("Error reading '" + name + "'");
	    throw new Error("l10n error with " + name);
	  }
	}

	function functionkey(shortkey) {
	  return shortkey.split("_")[1];
	}


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const parsePropertiesFile = __webpack_require__(40);
	const { sprintf } = __webpack_require__(41);

	const propertiesMap = {};

	// Some shenanigans are needed for LocalizationHelper's dynamic
	// require to work with Webpack.  Here we a create different context
	// require for each possible locale directory.  Then later we use
	// these functions, rather than plain |require|, to load the resource.
	const reqShared = __webpack_require__(42);
	const reqClient = __webpack_require__(49);
	const reqGlobal = __webpack_require__(87);

	/**
	 * Memoized getter for properties files that ensures a given url is only required and
	 * parsed once.
	 *
	 * @param {String} url
	 *        The URL of the properties file to parse.
	 * @return {Object} parsed properties mapped in an object.
	 */
	function getProperties(url) {
	  if (!propertiesMap[url]) {
	    // More shenanigans.  Here we take an input like
	    // "devtools-shared/locale/debugger.properties" and decide which
	    // context require function to use.  Despite the string processing
	    // here, in the end a string identical to |url| ends up being
	    // passed to "require".
	    let index = url.lastIndexOf("/");
	    // Turn "mumble/locale/resource.properties" => "./resource.properties".
	    let baseName = "." + url.substr(index);
	    let reqFn;
	    if (/^global/.test(url)) {
	      reqFn = reqGlobal;
	    } else if (/^devtools-shared/.test(url)) {
	      reqFn = reqShared;
	    } else {
	      reqFn = reqClient;
	    }
	    propertiesMap[url] = parsePropertiesFile(reqFn(baseName));
	  }

	  return propertiesMap[url];
	}

	/**
	 * Localization convenience methods.
	 *
	 * @param string stringBundleName
	 *        The desired string bundle's name.
	 */
	function LocalizationHelper(stringBundleName) {
	  this.stringBundleName = stringBundleName;
	}

	LocalizationHelper.prototype = {
	  /**
	   * L10N shortcut function.
	   *
	   * @param string name
	   * @return string
	   */
	  getStr: function (name) {
	    let properties = getProperties(this.stringBundleName);
	    if (name in properties) {
	      return properties[name];
	    }

	    throw new Error("No localization found for [" + name + "]");
	  },

	  /**
	   * L10N shortcut function.
	   *
	   * @param string name
	   * @param array args
	   * @return string
	   */
	  getFormatStr: function (name, ...args) {
	    return sprintf(this.getStr(name), ...args);
	  },

	  /**
	   * L10N shortcut function for numeric arguments that need to be formatted.
	   * All numeric arguments will be fixed to 2 decimals and given a localized
	   * decimal separator. Other arguments will be left alone.
	   *
	   * @param string name
	   * @param array args
	   * @return string
	   */
	  getFormatStrWithNumbers: function (name, ...args) {
	    let newArgs = args.map(x => {
	      return typeof x == "number" ? this.numberWithDecimals(x, 2) : x;
	    });

	    return this.getFormatStr(name, ...newArgs);
	  },

	  /**
	   * Converts a number to a locale-aware string format and keeps a certain
	   * number of decimals.
	   *
	   * @param number number
	   *        The number to convert.
	   * @param number decimals [optional]
	   *        Total decimals to keep.
	   * @return string
	   *         The localized number as a string.
	   */
	  numberWithDecimals: function (number, decimals = 0) {
	    // If this is an integer, don't do anything special.
	    if (number === (number|0)) {
	      return number;
	    }
	    // If this isn't a number (and yes, `isNaN(null)` is false), return zero.
	    if (isNaN(number) || number === null) {
	      return "0";
	    }

	    let localized = number.toLocaleString();

	    // If no grouping or decimal separators are available, bail out, because
	    // padding with zeros at the end of the string won't make sense anymore.
	    if (!localized.match(/[^\d]/)) {
	      return localized;
	    }

	    return number.toLocaleString(undefined, {
	      maximumFractionDigits: decimals,
	      minimumFractionDigits: decimals
	    });
	  }
	};

	function getPropertiesForNode(node) {
	  let bundleEl = node.closest("[data-localization-bundle]");
	  if (!bundleEl) {
	    return null;
	  }

	  let propertiesUrl = bundleEl.getAttribute("data-localization-bundle");
	  return getProperties(propertiesUrl);
	}

	/**
	 * Translate existing markup annotated with data-localization attributes.
	 *
	 * How to use data-localization in markup:
	 *
	 *   <div data-localization="content=myContent;title=myTitle"/>
	 *
	 * The data-localization attribute identifies an element as being localizable.
	 * The content of the attribute is semi-colon separated list of descriptors.
	 * - "title=myTitle" means the "title" attribute should be replaced with the localized
	 *   string corresponding to the key "myTitle".
	 * - "content=myContent" means the text content of the node should be replaced by the
	 *   string corresponding to "myContent"
	 *
	 * How to define the localization bundle in markup:
	 *
	 *   <div data-localization-bundle="url/to/my.properties">
	 *     [...]
	 *       <div data-localization="content=myContent;title=myTitle"/>
	 *
	 * Set the data-localization-bundle on an ancestor of the nodes that should be localized.
	 *
	 * @param {Element} root
	 *        The root node to use for the localization
	 */
	function localizeMarkup(root) {
	  let elements = root.querySelectorAll("[data-localization]");
	  for (let element of elements) {
	    let properties = getPropertiesForNode(element);
	    if (!properties) {
	      continue;
	    }

	    let attributes = element.getAttribute("data-localization").split(";");
	    for (let attribute of attributes) {
	      let [name, value] = attribute.trim().split("=");
	      if (name === "content") {
	        element.textContent = properties[value];
	      } else {
	        element.setAttribute(name, properties[value]);
	      }
	    }

	    element.removeAttribute("data-localization");
	  }
	}

	const sharedL10N = new LocalizationHelper("devtools-shared/locale/shared.properties");

	/**
	 * A helper for having the same interface as LocalizationHelper, but for more
	 * than one file. Useful for abstracting l10n string locations.
	 */
	function MultiLocalizationHelper(...stringBundleNames) {
	  let instances = stringBundleNames.map(bundle => {
	    return new LocalizationHelper(bundle);
	  });

	  // Get all function members of the LocalizationHelper class, making sure we're
	  // not executing any potential getters while doing so, and wrap all the
	  // methods we've found to work on all given string bundles.
	  Object.getOwnPropertyNames(LocalizationHelper.prototype)
	    .map(name => ({
	      name: name,
	      descriptor: Object.getOwnPropertyDescriptor(LocalizationHelper.prototype,
	                                                  name)
	    }))
	    .filter(({ descriptor }) => descriptor.value instanceof Function)
	    .forEach(method => {
	      this[method.name] = (...args) => {
	        for (let l10n of instances) {
	          try {
	            return method.descriptor.value.apply(l10n, args);
	          } catch (e) {
	            // Do nothing
	          }
	        }
	        return null;
	      };
	    });
	}

	exports.LocalizationHelper = LocalizationHelper;
	exports.localizeMarkup = localizeMarkup;
	exports.MultiLocalizationHelper = MultiLocalizationHelper;
	Object.defineProperty(exports, "ELLIPSIS", { get: () => sharedL10N.getStr("ellipsis") });


/***/ },
/* 40 */
/***/ function(module, exports) {

	/**
	 * The MIT License (MIT)
	 *
	 * Copyright (c) 2014 Gabriel Llamas
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */

	"use strict";

	var hex = function (c){
	  switch (c){
	    case "0": return 0;
	    case "1": return 1;
	    case "2": return 2;
	    case "3": return 3;
	    case "4": return 4;
	    case "5": return 5;
	    case "6": return 6;
	    case "7": return 7;
	    case "8": return 8;
	    case "9": return 9;
	    case "a": case "A": return 10;
	    case "b": case "B": return 11;
	    case "c": case "C": return 12;
	    case "d": case "D": return 13;
	    case "e": case "E": return 14;
	    case "f": case "F": return 15;
	  }
	};

	var parse = function (data, options, handlers, control){
	  var c;
	  var code;
	  var escape;
	  var skipSpace = true;
	  var isCommentLine;
	  var isSectionLine;
	  var newLine = true;
	  var multiLine;
	  var isKey = true;
	  var key = "";
	  var value = "";
	  var section;
	  var unicode;
	  var unicodeRemaining;
	  var escapingUnicode;
	  var keySpace;
	  var sep;
	  var ignoreLine;

	  var line = function (){
	    if (key || value || sep){
	      handlers.line (key, value);
	      key = "";
	      value = "";
	      sep = false;
	    }
	  };

	  var escapeString = function (key, c, code){
	    if (escapingUnicode && unicodeRemaining){
	      unicode = (unicode << 4) + hex (c);
	      if (--unicodeRemaining) return key;
	      escape = false;
	      escapingUnicode = false;
	      return key + String.fromCharCode (unicode);
	    }

	    //code 117: u
	    if (code === 117){
	      unicode = 0;
	      escapingUnicode = true;
	      unicodeRemaining = 4;
	      return key;
	    }

	    escape = false;

	    //code 116: t
	    //code 114: r
	    //code 110: n
	    //code 102: f
	    if (code === 116) return key + "\t";
	    else if (code === 114) return key + "\r";
	    else if (code === 110) return key + "\n";
	    else if (code === 102) return key + "\f";

	    return key + c;
	  };

	  var isComment;
	  var isSeparator;

	  if (options._strict){
	    isComment = function (c, code, options){
	      return options._comments[c];
	    };

	    isSeparator = function (c, code, options){
	      return options._separators[c];
	    };
	  }else{
	    isComment = function (c, code, options){
	      //code 35: #
	      //code 33: !
	      return code === 35 || code === 33 || options._comments[c];
	    };

	    isSeparator = function (c, code, options){
	      //code 61: =
	      //code 58: :
	      return code === 61 || code === 58 || options._separators[c];
	    };
	  }

	  for (var i=~~control.resume; i<data.length; i++){
	    if (control.abort) return;
	    if (control.pause){
	      //The next index is always the start of a new line, it's a like a fresh
	      //start, there's no need to save the current state
	      control.resume = i;
	      return;
	    }

	    c = data[i];
	    code = data.charCodeAt (i);

	    //code 13: \r
	    if (code === 13) continue;

	    if (isCommentLine){
	      //code 10: \n
	      if (code === 10){
	        isCommentLine = false;
	        newLine = true;
	        skipSpace = true;
	      }
	      continue;
	    }

	    //code 93: ]
	    if (isSectionLine && code === 93){
	      handlers.section (section);
	      //Ignore chars after the section in the same line
	      ignoreLine = true;
	      continue;
	    }

	    if (skipSpace){
	      //code 32: " " (space)
	      //code 9: \t
	      //code 12: \f
	      if (code === 32 || code === 9 || code === 12){
	        continue;
	      }
	      //code 10: \n
	      if (!multiLine && code === 10){
	        //Empty line or key w/ separator and w/o value
	        isKey = true;
	        keySpace = false;
	        newLine = true;
	        line ();
	        continue;
	      }
	      skipSpace = false;
	      multiLine = false;
	    }

	    if (newLine){
	      newLine = false;
	      if (isComment (c, code, options)){
	        isCommentLine = true;
	        continue;
	      }
	      //code 91: [
	      if (options.sections && code === 91){
	        section = "";
	        isSectionLine = true;
	        control.skipSection = false;
	        continue;
	      }
	    }

	    //code 10: \n
	    if (code !== 10){
	      if (control.skipSection || ignoreLine) continue;

	      if (!isSectionLine){
	        if (!escape && isKey && isSeparator (c, code, options)){
	          //sep is needed to detect empty key and empty value with a
	          //non-whitespace separator
	          sep = true;
	          isKey = false;
	          keySpace = false;
	          //Skip whitespace between separator and value
	          skipSpace = true;
	          continue;
	        }
	      }

	      //code 92: "\" (backslash)
	      if (code === 92){
	        if (escape){
	          if (escapingUnicode) continue;

	          if (keySpace){
	            //Line with whitespace separator
	            keySpace = false;
	            isKey = false;
	          }

	          if (isSectionLine) section += "\\";
	          else if (isKey) key += "\\";
	          else value += "\\";
	        }
	        escape = !escape;
	      }else{
	        if (keySpace){
	          //Line with whitespace separator
	          keySpace = false;
	          isKey = false;
	        }

	        if (isSectionLine){
	          if (escape) section = escapeString (section, c, code);
	          else section += c;
	        }else if (isKey){
	          if (escape){
	            key = escapeString (key, c, code);
	          }else{
	            //code 32: " " (space)
	            //code 9: \t
	            //code 12: \f
	            if (code === 32 || code === 9 || code === 12){
	              keySpace = true;
	              //Skip whitespace between key and separator
	              skipSpace = true;
	              continue;
	            }
	            key += c;
	          }
	        }else{
	          if (escape) value = escapeString (value, c, code);
	          else value += c;
	        }
	      }
	    }else{
	      if (escape){
	        if (!escapingUnicode){
	          escape = false;
	        }
	        skipSpace = true;
	        multiLine = true;
	      }else{
	        if (isSectionLine){
	          isSectionLine = false;
	          if (!ignoreLine){
	            //The section doesn't end with ], it's a key
	            control.error = new Error ("The section line \"" + section +
	                "\" must end with \"]\"");
	            return;
	          }
	          ignoreLine = false;
	        }
	        newLine = true;
	        skipSpace = true;
	        isKey = true;

	        line ();
	      }
	    }
	  }

	  control.parsed = true;

	  if (isSectionLine && !ignoreLine){
	    //The section doesn't end with ], it's a key
	    control.error = new Error ("The section line \"" + section + "\" must end" +
	        "with \"]\"");
	    return;
	  }
	  line ();
	};

	var INCLUDE_KEY = "include";
	var INDEX_FILE = "index.properties";

	var cast = function (value){
	  if (value === null || value === "null") return null;
	  if (value === "undefined") return undefined;
	  if (value === "true") return true;
	  if (value === "false") return false;
	  var v = Number (value);
	  return isNaN (v) ? value : v;
	};

	var expand = function  (o, str, options, cb){
	  if (!options.variables || !str) return cb (null, str);

	  var stack = [];
	  var c;
	  var cp;
	  var key = "";
	  var section = null;
	  var v;
	  var holder;
	  var t;
	  var n;

	  for (var i=0; i<str.length; i++){
	    c = str[i];

	    if (cp === "$" && c === "{"){
	      key = key.substring (0, key.length - 1);
	      stack.push ({
	        key: key,
	        section: section
	      });
	      key = "";
	      section = null;
	      continue;
	    }else if (stack.length){
	      if (options.sections && c === "|"){
	        section = key;
	        key = "";
	        continue;
	      }else if (c === "}"){
	        holder = section !== null ? searchValue (o, section, true) : o;
	        if (!holder){
	          return cb (new Error ("The section \"" + section + "\" does not " +
	              "exist"));
	        }

	        v = options.namespaces ? searchValue (holder, key) : holder[key];
	        if (v === undefined){
	          //Read the external vars
	          v = options.namespaces
	              ? searchValue (options._vars, key)
	              : options._vars[key]

	          if (v === undefined){
	            return cb (new Error ("The property \"" + key + "\" does not " +
	                "exist"));
	          }
	        }

	        t = stack.pop ();
	        section = t.section;
	        key = t.key + (v === null ? "" : v);
	        continue;
	      }
	    }

	    cp = c;
	    key += c;
	  }

	  if (stack.length !== 0){
	    return cb (new Error ("Malformed variable: " + str));
	  }

	  cb (null, key);
	};

	var searchValue = function (o, chain, section){
	  var n = chain.split (".");
	  var str;

	  for (var i=0; i<n.length-1; i++){
	    str = n[i];
	    if (o[str] === undefined) return;
	    o = o[str];
	  }

	  var v = o[n[n.length - 1]];
	  if (section){
	    if (typeof v !== "object") return;
	    return v;
	  }else{
	    if (typeof v === "object") return;
	    return v;
	  }
	};

	var namespaceKey = function (o, key, value){
	  var n = key.split (".");
	  var str;

	  for (var i=0; i<n.length-1; i++){
	    str = n[i];
	    if (o[str] === undefined){
	      o[str] = {};
	    }else if (typeof o[str] !== "object"){
	      throw new Error ("Invalid namespace chain in the property name '" +
	          key + "' ('" + str + "' has already a value)");
	    }
	    o = o[str];
	  }

	  o[n[n.length - 1]] = value;
	};

	var namespaceSection = function (o, section){
	  var n = section.split (".");
	  var str;

	  for (var i=0; i<n.length; i++){
	    str = n[i];
	    if (o[str] === undefined){
	      o[str] = {};
	    }else if (typeof o[str] !== "object"){
	      throw new Error ("Invalid namespace chain in the section name '" +
	          section + "' ('" + str + "' has already a value)");
	    }
	    o = o[str];
	  }

	  return o;
	};

	var merge = function (o1, o2){
	  for (var p in o2){
	    try{
	      if (o1[p].constructor === Object){
	        o1[p] = merge (o1[p], o2[p]);
	      }else{
	        o1[p] = o2[p];
	      }
	    }catch (e){
	      o1[p] = o2[p];
	    }
	  }
	  return o1;
	}

	var build = function (data, options, dirname, cb){
	  var o = {};

	  if (options.namespaces){
	    var n = {};
	  }

	  var control = {
	    abort: false,
	    skipSection: false
	  };

	  if (options.include){
	    var remainingIncluded = 0;

	    var include = function (value){
	      if (currentSection !== null){
	        return abort (new Error ("Cannot include files from inside a " +
	            "section: " + currentSection));
	      }

	      var p = path.resolve (dirname, value);
	      if (options._included[p]) return;

	      options._included[p] = true;
	      remainingIncluded++;
	      control.pause = true;

	      read (p, options, function (error, included){
	        if (error) return abort (error);

	        remainingIncluded--;
	        merge (options.namespaces ? n : o, included);
	        control.pause = false;

	        if (!control.parsed){
	          parse (data, options, handlers, control);
	          if (control.error) return abort (control.error);
	        }

	        if (!remainingIncluded) cb (null, options.namespaces ? n : o);
	      });
	    };
	  }

	  if (!data){
	    if (cb) return cb (null, o);
	    return o;
	  }

	  var currentSection = null;
	  var currentSectionStr = null;

	  var abort = function (error){
	    control.abort = true;
	    if (cb) return cb (error);
	    throw error;
	  };

	  var handlers = {};
	  var reviver = {
	    assert: function (){
	      return this.isProperty ? reviverLine.value : true;
	    }
	  };
	  var reviverLine = {};

	  //Line handler
	  //For speed reasons, if "namespaces" is enabled, the old object is still
	  //populated, e.g.: ${a.b} reads the "a.b" property from { "a.b": 1 }, instead
	  //of having a unique object { a: { b: 1 } } which is slower to search for
	  //the "a.b" value
	  //If "a.b" is not found, then the external vars are read. If "namespaces" is
	  //enabled, the var "a.b" is split and it searches the a.b value. If it is not
	  //enabled, then the var "a.b" searches the "a.b" value

	  var line;
	  var error;

	  if (options.reviver){
	    if (options.sections){
	      line = function (key, value){
	        if (options.include && key === INCLUDE_KEY) return include (value);

	        reviverLine.value = value;
	        reviver.isProperty = true;
	        reviver.isSection = false;

	        value = options.reviver.call (reviver, key, value, currentSectionStr);
	        if (value !== undefined){
	          if (options.namespaces){
	            try{
	              namespaceKey (currentSection === null ? n : currentSection,
	                  key, value);
	            }catch (error){
	              abort (error);
	            }
	          }else{
	            if (currentSection === null) o[key] = value;
	            else currentSection[key] = value;
	          }
	        }
	      };
	    }else{
	      line = function (key, value){
	        if (options.include && key === INCLUDE_KEY) return include (value);

	        reviverLine.value = value;
	        reviver.isProperty = true;
	        reviver.isSection = false;

	        value = options.reviver.call (reviver, key, value);
	        if (value !== undefined){
	          if (options.namespaces){
	            try{
	              namespaceKey (n, key, value);
	            }catch (error){
	              abort (error);
	            }
	          }else{
	            o[key] = value;
	          }
	        }
	      };
	    }
	  }else{
	    if (options.sections){
	      line = function (key, value){
	        if (options.include && key === INCLUDE_KEY) return include (value);

	        if (options.namespaces){
	          try{
	            namespaceKey (currentSection === null ? n : currentSection, key,
	                value);
	          }catch (error){
	            abort (error);
	          }
	        }else{
	          if (currentSection === null) o[key] = value;
	          else currentSection[key] = value;
	        }
	      };
	    }else{
	      line = function (key, value){
	        if (options.include && key === INCLUDE_KEY) return include (value);

	        if (options.namespaces){
	          try{
	            namespaceKey (n, key, value);
	          }catch (error){
	            abort (error);
	          }
	        }else{
	          o[key] = value;
	        }
	      };
	    }
	  }

	  //Section handler
	  var section;
	  if (options.sections){
	    if (options.reviver){
	      section = function (section){
	        currentSectionStr = section;
	        reviverLine.section = section;
	        reviver.isProperty = false;
	        reviver.isSection = true;

	        var add = options.reviver.call (reviver, null, null, section);
	        if (add){
	          if (options.namespaces){
	            try{
	              currentSection = namespaceSection (n, section);
	            }catch (error){
	              abort (error);
	            }
	          }else{
	            currentSection = o[section] = {};
	          }
	        }else{
	          control.skipSection = true;
	        }
	      };
	    }else{
	      section = function (section){
	        currentSectionStr = section;
	        if (options.namespaces){
	          try{
	            currentSection = namespaceSection (n, section);
	          }catch (error){
	            abort (error);
	          }
	        }else{
	          currentSection = o[section] = {};
	        }
	      };
	    }
	  }

	  //Variables
	  if (options.variables){
	    handlers.line = function (key, value){
	      expand (options.namespaces ? n : o, key, options, function (error, key){
	        if (error) return abort (error);

	        expand (options.namespaces ? n : o, value, options,
	            function (error, value){
	          if (error) return abort (error);

	          line (key, cast (value || null));
	        });
	      });
	    };

	    if (options.sections){
	      handlers.section = function (s){
	        expand (options.namespaces ? n : o, s, options, function (error, s){
	          if (error) return abort (error);

	          section (s);
	        });
	      };
	    }
	  }else{
	    handlers.line = function (key, value){
	      line (key, cast (value || null));
	    };

	    if (options.sections){
	      handlers.section = section;
	    }
	  }

	  parse (data, options, handlers, control);
	  if (control.error) return abort (control.error);

	  if (control.abort || control.pause) return;

	  if (cb) return cb (null, options.namespaces ? n : o);
	  return options.namespaces ? n : o;
	};

	var read = function (f, options, cb){
	  fs.stat (f, function (error, stats){
	    if (error) return cb (error);

	    var dirname;

	    if (stats.isDirectory ()){
	      dirname = f;
	      f = path.join (f, INDEX_FILE);
	    }else{
	      dirname = path.dirname (f);
	    }

	    fs.readFile (f, { encoding: "utf8" }, function (error, data){
	      if (error) return cb (error);
	      build (data, options, dirname, cb);
	    });
	  });
	};

	module.exports = function (data, options, cb){
	  if (typeof options === "function"){
	    cb = options;
	    options = {};
	  }

	  options = options || {};
	  var code;

	  if (options.include){
	    if (!cb) throw new Error ("A callback must be passed if the 'include' " +
	        "option is enabled");
	    options._included = {};
	  }

	  options = options || {};
	  options._strict = options.strict && (options.comments || options.separators);
	  options._vars = options.vars || {};

	  var comments = options.comments || [];
	  if (!Array.isArray (comments)) comments = [comments];
	  var c = {};
	  comments.forEach (function (comment){
	    code = comment.charCodeAt (0);
	    if (comment.length > 1 || code < 33 || code > 126){
	      throw new Error ("The comment token must be a single printable ASCII " +
	          "character");
	    }
	    c[comment] = true;
	  });
	  options._comments = c;

	  var separators = options.separators || [];
	  if (!Array.isArray (separators)) separators = [separators];
	  var s = {};
	  separators.forEach (function (separator){
	    code = separator.charCodeAt (0);
	    if (separator.length > 1 || code < 33 || code > 126){
	      throw new Error ("The separator token must be a single printable ASCII " +
	          "character");
	    }
	    s[separator] = true;
	  });
	  options._separators = s;

	  if (options.path){
	    if (!cb) throw new Error ("A callback must be passed if the 'path' " +
	        "option is enabled");
	    if (options.include){
	      read (data, options, cb);
	    }else{
	      fs.readFile (data, { encoding: "utf8" }, function (error, data){
	        if (error) return cb (error);
	        build (data, options, ".", cb);
	      });
	    }
	  }else{
	    return build (data, options, ".", cb);
	  }
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2007-2016, Alexandru Marasteanu <hello [at) alexei (dot] ro>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 * * Neither the name of this software nor the names of its contributors may be
	 *   used to endorse or promote products derived from this software without
	 *   specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 */

	/* globals window, exports, define */

	(function(window) {
	    'use strict'

	    var re = {
	        not_string: /[^s]/,
	        not_bool: /[^t]/,
	        not_type: /[^T]/,
	        not_primitive: /[^v]/,
	        number: /[diefg]/,
	        numeric_arg: /bcdiefguxX/,
	        json: /[j]/,
	        not_json: /[^j]/,
	        text: /^[^\x25]+/,
	        modulo: /^\x25{2}/,
	        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosStTuvxX])/,
	        key: /^([a-z_][a-z_\d]*)/i,
	        key_access: /^\.([a-z_][a-z_\d]*)/i,
	        index_access: /^\[(\d+)\]/,
	        sign: /^[\+\-]/
	    }

	    function sprintf() {
	        var key = arguments[0], cache = sprintf.cache
	        if (!(cache[key] && cache.hasOwnProperty(key))) {
	            cache[key] = sprintf.parse(key)
	        }
	        return sprintf.format.call(null, cache[key], arguments)
	    }

	    sprintf.format = function(parse_tree, argv) {
	        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ''
	        for (i = 0; i < tree_length; i++) {
	            node_type = get_type(parse_tree[i])
	            if (node_type === 'string') {
	                output[output.length] = parse_tree[i]
	            }
	            else if (node_type === 'array') {
	                match = parse_tree[i] // convenience purposes only
	                if (match[2]) { // keyword argument
	                    arg = argv[cursor]
	                    for (k = 0; k < match[2].length; k++) {
	                        if (!arg.hasOwnProperty(match[2][k])) {
	                            throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]))
	                        }
	                        arg = arg[match[2][k]]
	                    }
	                }
	                else if (match[1]) { // positional argument (explicit)
	                    arg = argv[match[1]]
	                }
	                else { // positional argument (implicit)
	                    arg = argv[cursor++]
	                }

	                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && get_type(arg) == 'function') {
	                    arg = arg()
	                }

	                if (re.numeric_arg.test(match[8]) && (get_type(arg) != 'number' && isNaN(arg))) {
	                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
	                }

	                if (re.number.test(match[8])) {
	                    is_positive = arg >= 0
	                }

	                switch (match[8]) {
	                    case 'b':
	                        arg = parseInt(arg, 10).toString(2)
	                    break
	                    case 'c':
	                        arg = String.fromCharCode(parseInt(arg, 10))
	                    break
	                    case 'd':
	                    case 'i':
	                        arg = parseInt(arg, 10)
	                    break
	                    case 'j':
	                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
	                    break
	                    case 'e':
	                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()
	                    break
	                    case 'f':
	                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
	                    break
	                    case 'g':
	                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
	                    break
	                    case 'o':
	                        arg = arg.toString(8)
	                    break
	                    case 's':
	                    case 'S':
	                        arg = String(arg)
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 't':
	                        arg = String(!!arg)
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 'T':
	                        arg = get_type(arg)
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 'u':
	                        arg = parseInt(arg, 10) >>> 0
	                    break
	                    case 'v':
	                        arg = arg.valueOf()
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 'x':
	                        arg = parseInt(arg, 10).toString(16)
	                    break
	                    case 'X':
	                        arg = parseInt(arg, 10).toString(16).toUpperCase()
	                    break
	                }
	                if (re.json.test(match[8])) {
	                    output[output.length] = arg
	                }
	                else {
	                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
	                        sign = is_positive ? '+' : '-'
	                        arg = arg.toString().replace(re.sign, '')
	                    }
	                    else {
	                        sign = ''
	                    }
	                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '
	                    pad_length = match[6] - (sign + arg).length
	                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : '') : ''
	                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
	                }
	            }
	        }
	        return output.join('')
	    }

	    sprintf.cache = {}

	    sprintf.parse = function(fmt) {
	        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
	        while (_fmt) {
	            if ((match = re.text.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = match[0]
	            }
	            else if ((match = re.modulo.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = '%'
	            }
	            else if ((match = re.placeholder.exec(_fmt)) !== null) {
	                if (match[2]) {
	                    arg_names |= 1
	                    var field_list = [], replacement_field = match[2], field_match = []
	                    if ((field_match = re.key.exec(replacement_field)) !== null) {
	                        field_list[field_list.length] = field_match[1]
	                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
	                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else {
	                                throw new SyntaxError("[sprintf] failed to parse named argument key")
	                            }
	                        }
	                    }
	                    else {
	                        throw new SyntaxError("[sprintf] failed to parse named argument key")
	                    }
	                    match[2] = field_list
	                }
	                else {
	                    arg_names |= 2
	                }
	                if (arg_names === 3) {
	                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
	                }
	                parse_tree[parse_tree.length] = match
	            }
	            else {
	                throw new SyntaxError("[sprintf] unexpected placeholder")
	            }
	            _fmt = _fmt.substring(match[0].length)
	        }
	        return parse_tree
	    }

	    var vsprintf = function(fmt, argv, _argv) {
	        _argv = (argv || []).slice(0)
	        _argv.splice(0, 0, fmt)
	        return sprintf.apply(null, _argv)
	    }

	    /**
	     * helpers
	     */
	    function get_type(variable) {
	        if (typeof variable === 'number') {
	            return 'number'
	        }
	        else if (typeof variable === 'string') {
	            return 'string'
	        }
	        else {
	            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
	        }
	    }

	    var preformattedPadding = {
	        '0': ['', '0', '00', '000', '0000', '00000', '000000', '0000000'],
	        ' ': ['', ' ', '  ', '   ', '    ', '     ', '      ', '       '],
	        '_': ['', '_', '__', '___', '____', '_____', '______', '_______'],
	    }
	    function str_repeat(input, multiplier) {
	        if (multiplier >= 0 && multiplier <= 7 && preformattedPadding[input]) {
	            return preformattedPadding[input][multiplier]
	        }
	        return Array(multiplier + 1).join(input)
	    }

	    /**
	     * export to either browser or node.js
	     */
	    if (true) {
	        exports.sprintf = sprintf
	        exports.vsprintf = vsprintf
	    }
	    else {
	        window.sprintf = sprintf
	        window.vsprintf = vsprintf

	        if (typeof define === 'function' && define.amd) {
	            define(function() {
	                return {
	                    sprintf: sprintf,
	                    vsprintf: vsprintf
	                }
	            })
	        }
	    }
	})(typeof window === 'undefined' ? this : window);


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./csscoverage.properties": 43,
		"./debugger.properties": 44,
		"./gcli.properties": 45,
		"./gclicommands.properties": 46,
		"./shared.properties": 47,
		"./styleinspector.properties": 48
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 42;


/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the 'csscoverage' command and in\n# the user interface that this command creates.\n\n# LOCALIZATION NOTE (csscoverageDesc, csscoverageStartDesc2,\n# csscoverageStopDesc2, csscoverageOneShotDesc2, csscoverageToggleDesc2,\n# csscoverageReportDesc2): Short descriptions of the csscoverage commands\ncsscoverageDesc=Control CSS coverage analysis\ncsscoverageStartDesc2=Begin collecting CSS coverage data\ncsscoverageStopDesc2=Stop collecting CSS coverage data\ncsscoverageOneShotDesc2=Collect instantaneous CSS coverage data\ncsscoverageToggleDesc2=Toggle collecting CSS coverage data\ncsscoverageReportDesc2=Show CSS coverage report\ncsscoverageStartNoReloadDesc=Don’t start with a page reload\ncsscoverageStartNoReloadManual=It’s best if we start by reloading the current page because that starts the test at a known point, but there could be reasons why we don’t want to do that (e.g. the page contains state that will be lost across a reload)\n\n# LOCALIZATION NOTE (csscoverageRunningReply, csscoverageDoneReply): Text that\n# describes the current state of the css coverage system\ncsscoverageRunningReply=Running CSS coverage analysis\ncsscoverageDoneReply=CSS Coverage analysis completed\n\n# LOCALIZATION NOTE (csscoverageRunningError, csscoverageNotRunningError,\n# csscoverageNotRunError): Error message that describe things that can go wrong\n# with the css coverage system\ncsscoverageRunningError=CSS coverage analysis already running\ncsscoverageNotRunningError=CSS coverage analysis not running\ncsscoverageNotRunError=CSS coverage analysis has not been run\ncsscoverageNoRemoteError=Target does not support CSS Coverage\ncsscoverageOneShotReportError=CSS coverage report is not available for ‘oneshot’ data. Please use start/stop.\n"

/***/ },
/* 44 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Debugger\n# which is available from the Web Developer sub-menu -> 'Debugger'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (remoteIncomingPromptTitle): The title displayed on the\n# dialog that prompts the user to allow the incoming connection.\nremoteIncomingPromptTitle=Incoming Connection\n\n# LOCALIZATION NOTE (remoteIncomingPromptHeader): Header displayed on the\n# dialog that prompts the user to allow the incoming connection.\nremoteIncomingPromptHeader=An incoming request to permit remote debugging connection was detected. A remote client can take complete control over your browser!\n# LOCALIZATION NOTE (remoteIncomingPromptClientEndpoint): Part of the prompt\n# dialog for the user to choose whether an incoming connection should be\n# allowed.\n# %1$S: The host and port of the client such as \"127.0.0.1:6000\"\nremoteIncomingPromptClientEndpoint=Client Endpoint: %1$S\n# LOCALIZATION NOTE (remoteIncomingPromptServerEndpoint): Part of the prompt\n# dialog for the user to choose whether an incoming connection should be\n# allowed.\n# %1$S: The host and port of the server such as \"127.0.0.1:6000\"\nremoteIncomingPromptServerEndpoint=Server Endpoint: %1$S\n# LOCALIZATION NOTE (remoteIncomingPromptFooter): Footer displayed on the\n# dialog that prompts the user to allow the incoming connection.\nremoteIncomingPromptFooter=Allow connection?\n\n# LOCALIZATION NOTE (remoteIncomingPromptDisable): The label displayed on the\n# third button in the incoming connection dialog that lets the user disable the\n# remote debugger server.\nremoteIncomingPromptDisable=Disable\n\n# LOCALIZATION NOTE (clientSendOOBTitle): The title displayed on the dialog that\n# instructs the user to transfer an authentication token to the server.\nclientSendOOBTitle=Client Identification\n# LOCALIZATION NOTE (clientSendOOBHeader): Header displayed on the dialog that\n# instructs the user to transfer an authentication token to the server.\nclientSendOOBHeader=The endpoint you are connecting to needs more information to authenticate this connection.  Please provide the token below in the prompt that appears on the other end.\n# LOCALIZATION NOTE (clientSendOOBHash): Part of the dialog that instructs the\n# user to transfer an authentication token to the server.\n# %1$S: The client's cert fingerprint\nclientSendOOBHash=My Cert: %1$S\n# LOCALIZATION NOTE (clientSendOOBToken): Part of the dialog that instructs the\n# user to transfer an authentication token to the server.\n# %1$S: The authentication token that the user will transfer.\nclientSendOOBToken=Token: %1$S\n\n# LOCALIZATION NOTE (serverReceiveOOBTitle): The title displayed on the dialog\n# that instructs the user to provide an authentication token from the client.\nserverReceiveOOBTitle=Provide Client Token\n# LOCALIZATION NOTE (serverReceiveOOBBody): Main text displayed on the dialog\n# that instructs the user to provide an authentication token from the client.\nserverReceiveOOBBody=The client should be displaying a token value.  Enter that token value here to complete authentication with this client.\n"

/***/ },
/* 45 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Web Console\n# command line which is available from the Web Developer sub-menu\n# -> 'Web Console'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# For each command there are in general two strings. As an example consider\n# the 'pref' command.\n# commandDesc (e.g. prefDesc for the command 'pref'): this string contains a\n# very short description of the command. It's designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\n# commandManual (e.g. prefManual for the command 'pref'): this string will\n# contain a fuller description of the command. It's diplayed when the user\n# asks for help about a specific command (e.g. 'help pref').\n\n# LOCALIZATION NOTE: This message is used to describe any command or command\n# parameter when no description has been provided.\ncanonDescNone=(No description)\n\n# LOCALIZATION NOTE: The default name for a group of parameters.\ncanonDefaultGroupName=Options\n\n# LOCALIZATION NOTE (canonProxyDesc, canonProxyManual): These commands are\n# used to execute commands on a remote system (using a proxy). Parameters: %S\n# is the name of the remote system.\ncanonProxyDesc=Execute a command on %S\ncanonProxyManual=A set of commands that are executed on a remote system. The remote system is reached via %S\n\n# LOCALIZATION NOTE: This error message is displayed when we try to add a new\n# command (using a proxy) where one already exists with the same name.\ncanonProxyExists=There is already a command called ‘%S’\n\n# LOCALIZATION NOTE: This message describes the '{' command, which allows\n# entry of JavaScript like traditional developer tool command lines.\ncliEvalJavascript=Enter JavaScript directly\n\n# LOCALIZATION NOTE: This message is displayed when the command line has more\n# arguments than the current command can understand.\ncliUnusedArg=Too many arguments\n\n# LOCALIZATION NOTE: The title of the dialog which displays the options that\n# are available to the current command.\ncliOptions=Available Options\n\n# LOCALIZATION NOTE: The error message when the user types a command that\n# isn't registered\ncliUnknownCommand2=Invalid Command: ‘%1$S’.\n\n# LOCALIZATION NOTE: A parameter should have a value, but doesn't\ncliIncompleteParam=Value required for ‘%1$S’.\n\n# LOCALIZATION NOTE: Error message given when a file argument points to a file\n# that does not exist, but should (e.g. for use with File->Open) %1$S is a\n# filename\nfileErrNotExists=‘%1$S’ doesn’t exist\n\n# LOCALIZATION NOTE: Error message given when a file argument points to a file\n# that exists, but should not (e.g. for use with File->Save As) %1$S is a\n# filename\nfileErrExists=‘%1$S’ already exists\n\n# LOCALIZATION NOTE: Error message given when a file argument points to a\n# non-file, when a file is needed. %1$S is a filename\nfileErrIsNotFile=‘%1$S’ is not a file\n\n# LOCALIZATION NOTE: Error message given when a file argument points to a\n# non-directory, when a directory is needed (e.g. for use with 'cd') %1$S is a\n# filename\nfileErrIsNotDirectory=‘%1$S’ is not a directory\n\n# LOCALIZATION NOTE: Error message given when a file argument does not match\n# the specified regular expression %1$S is a filename %2$S is a regular\n# expression\nfileErrDoesntMatch=‘%1$S’ does not match ‘%2$S’\n\n# LOCALIZATION NOTE: When the menu has displayed all the matches that it\n# should (i.e. about 10 items) then we display this to alert the user that\n# more matches are available.\nfieldMenuMore=More matches, keep typing\n\n# LOCALIZATION NOTE: The command line provides completion for JavaScript\n# commands, however there are times when the scope of what we're completing\n# against can't be used. This error message is displayed when this happens.\njstypeParseScope=Scope lost\n\n# LOCALIZATION NOTE (jstypeParseMissing, jstypeBeginSyntax,\n# jstypeBeginUnterm): These error messages are displayed when the command line\n# is doing JavaScript completion and encounters errors.\njstypeParseMissing=Can’t find property ‘%S’\njstypeBeginSyntax=Syntax error\njstypeBeginUnterm=Unterminated string literal\n\n# LOCALIZATION NOTE: This message is displayed if the system for providing\n# JavaScript completions encounters and error it displays this.\njstypeParseError=Error\n\n# LOCALIZATION NOTE (typesNumberNan, typesNumberNotInt2, typesDateNan): These\n# error messages are displayed when the command line is passed a variable\n# which has the wrong format and can't be converted. Parameters: %S is the\n# passed variable.\ntypesNumberNan=Can’t convert “%S” to a number.\ntypesNumberNotInt2=Can’t convert “%S” to an integer.\ntypesDateNan=Can’t convert “%S” to a date.\n\n# LOCALIZATION NOTE (typesNumberMax, typesNumberMin, typesDateMax,\n# typesDateMin): These error messages are displayed when the command line is\n# passed a variable which has a value out of range (number or date).\n# Parameters: %1$S is the passed variable, %2$S is the limit value.\ntypesNumberMax=%1$S is greater than maximum allowed: %2$S.\ntypesNumberMin=%1$S is smaller than minimum allowed: %2$S.\ntypesDateMax=%1$S is later than maximum allowed: %2$S.\ntypesDateMin=%1$S is earlier than minimum allowed: %2$S.\n\n# LOCALIZATION NOTE: This error message is displayed when the command line is\n# passed an option with a limited number of correct values, but the passed\n# value is not one of them.\ntypesSelectionNomatch=Can’t use ‘%S’.\n\n# LOCALIZATION NOTE: This error message is displayed when the command line is\n# expecting a CSS query string, however the passed string is not valid.\nnodeParseSyntax=Syntax error in CSS query\n\n# LOCALIZATION NOTE (nodeParseMultiple, nodeParseNone): These error messages\n# are displayed when the command line is expecting a CSS string that matches a\n# single node, but more nodes (or none) match.\nnodeParseMultiple=Too many matches (%S)\nnodeParseNone=No matches\n\n# LOCALIZATION NOTE (helpDesc, helpManual, helpSearchDesc, helpSearchManual3):\n# These strings describe the \"help\" command, used to display a description of\n# a command (e.g. \"help pref\"), and its parameter 'search'.\nhelpDesc=Get help on the available commands\nhelpManual=Provide help either on a specific command (if a search string is provided and an exact match is found) or on the available commands (if a search string is not provided, or if no exact match is found).\nhelpSearchDesc=Search string\nhelpSearchManual3=search string to use in narrowing down the displayed commands. Regular expressions not supported.\n\n# LOCALIZATION NOTE: These strings are displayed in the help page for a\n# command in the console.\nhelpManSynopsis=Synopsis\n\n# LOCALIZATION NOTE: This message is displayed in the help page if the command\n# has no parameters.\nhelpManNone=None\n\n# LOCALIZATION NOTE: This message is displayed in response to the 'help'\n# command when used without a filter, just above the list of known commands.\nhelpListAll=Available Commands:\n\n# LOCALIZATION NOTE (helpListPrefix, helpListNone): These messages are\n# displayed in response to the 'help <search>' command (i.e. with a search\n# string), just above the list of matching commands. Parameters: %S is the\n# search string.\nhelpListPrefix=Commands starting with ‘%S’:\nhelpListNone=No commands starting with ‘%S’\n\n# LOCALIZATION NOTE (helpManRequired, helpManOptional, helpManDefault): When\n# the 'help x' command wants to show the manual for the 'x' command, it needs\n# to be able to describe the parameters as either required or optional, or if\n# they have a default value.\nhelpManRequired=required\nhelpManOptional=optional\nhelpManDefault=optional, default=%S\n\n# LOCALIZATION NOTE: This forms part of the output from the 'help' command.\n# 'GCLI' is a project name and should be left untranslated.\nhelpIntro=GCLI is an experiment to create a highly usable command line for web developers.\n\n# LOCALIZATION NOTE: Text shown as part of the output of the 'help' command\n# when the command in question has sub-commands, before a list of the matching\n# sub-commands.\nsubCommands=Sub-Commands\n\n# LOCALIZATION NOTE: This error message is displayed when the command line is\n# cannot find a match for the parse types.\ncommandParseError=Command line parsing error\n\n# LOCALIZATION NOTE (contextDesc, contextManual, contextPrefixDesc): These\n# strings are used to describe the 'context' command and its 'prefix'\n# parameter. See localization comment for 'connect' for an explanation about\n# 'prefix'.\ncontextDesc=Concentrate on a group of commands\ncontextManual=Setup a default prefix to future commands. For example ‘context git’ would allow you to type ‘commit’ rather than ‘git commit’.\ncontextPrefixDesc=The command prefix\n\n# LOCALIZATION NOTE: This message message displayed during the processing of\n# the 'context' command, when the found command is not a parent command.\ncontextNotParentError=Can’t use ‘%S’ as a prefix because it is not a parent command.\n\n# LOCALIZATION NOTE (contextReply, contextEmptyReply): These messages are\n# displayed during the processing of the 'context' command, to indicate\n# success or that there is no command prefix.\ncontextReply=Using %S as a command prefix\ncontextEmptyReply=Command prefix is unset\n\n# LOCALIZATION NOTE (connectDesc, connectManual, connectPrefixDesc,\n# connectMethodDesc, connectUrlDesc, connectDupReply): These strings describe\n# the 'connect' command and all its available parameters. A 'prefix' is an \n# alias for the remote server (think of it as a \"connection name\"), and it\n# allows to identify a specific server when connected to multiple remote\n# servers.\nconnectDesc=Proxy commands to server\nconnectManual=Connect to the server, creating local versions of the commands on the server. Remote commands initially have a prefix to distinguish them from local commands (but see the context command to get past this)\nconnectPrefixDesc=Parent prefix for imported commands\nconnectMethodDesc=The method of connecting\nconnectUrlDesc=The URL to connect to\nconnectDupReply=Connection called %S already exists.\n\n# LOCALIZATION NOTE: The output of the 'connect' command, telling the user\n# what it has done. Parameters: %S is the prefix command. See localization\n# comment for 'connect' for an explanation about 'prefix'.\nconnectReply=Added %S commands.\n\n# LOCALIZATION NOTE (disconnectDesc2, disconnectManual2,\n# disconnectPrefixDesc): These strings describe the 'disconnect' command and\n# all its available parameters. See localization comment for 'connect' for an\n# explanation about 'prefix'.\ndisconnectDesc2=Disconnect from server\ndisconnectManual2=Disconnect from a server currently connected for remote commands execution\ndisconnectPrefixDesc=Parent prefix for imported commands\n\n# LOCALIZATION NOTE: This is the output of the 'disconnect' command,\n# explaining the user what has been done. Parameters: %S is the number of\n# commands removed.\ndisconnectReply=Removed %S commands.\n\n# LOCALIZATION NOTE (globalDesc, globalWindowDesc, globalOutput): These\n# strings describe the 'global' command and its parameters\nglobalDesc=Change the JS global\nglobalWindowDesc=The new window/global\nglobalOutput=JS global is now %S\n\n# LOCALIZATION NOTE: These strings describe the 'clear' command\nclearDesc=Clear the output area\n\n# LOCALIZATION NOTE (langDesc, langOutput): These strings describe the 'lang'\n# command and its parameters\nlangDesc=Enter commands in different languages\nlangOutput=You are now using %S\n\n# LOCALIZATION NOTE (prefDesc, prefManual, prefListDesc, prefListManual,\n# prefListSearchDesc, prefListSearchManual, prefShowDesc, prefShowManual,\n# prefShowSettingDesc, prefShowSettingManual): These strings describe the\n# 'pref' command and all its available sub-commands and parameters.\nprefDesc=Commands to control settings\nprefManual=Commands to display and alter preferences both for GCLI and the surrounding environment\nprefListDesc=Display available settings\nprefListManual=Display a list of preferences, optionally filtered when using the ‘search’ parameter\nprefListSearchDesc=Filter the list of settings displayed\nprefListSearchManual=Search for the given string in the list of available preferences\nprefShowDesc=Display setting value\nprefShowManual=Display the value of a given preference\nprefShowSettingDesc=Setting to display\nprefShowSettingManual=The name of the setting to display\n\n# LOCALIZATION NOTE: This message is used to show the preference name and the\n# associated preference value. Parameters: %1$S is the preference name, %2$S\n# is the preference value.\nprefShowSettingValue=%1$S: %2$S\n\n# LOCALIZATION NOTE (prefSetDesc, prefSetManual, prefSetSettingDesc,\n# prefSetSettingManual, prefSetValueDesc, prefSetValueManual): These strings\n# describe the 'pref set' command and all its parameters.\nprefSetDesc=Alter a setting\nprefSetManual=Alter preferences defined by the environment\nprefSetSettingDesc=Setting to alter\nprefSetSettingManual=The name of the setting to alter.\nprefSetValueDesc=New value for setting\nprefSetValueManual=The new value for the specified setting\n\n# LOCALIZATION NOTE (prefResetDesc, prefResetManual, prefResetSettingDesc,\n# prefResetSettingManual): These strings describe the 'pref reset' command and\n# all its parameters.\nprefResetDesc=Reset a setting\nprefResetManual=Reset the value of a setting to the system defaults\nprefResetSettingDesc=Setting to reset\nprefResetSettingManual=The name of the setting to reset to the system default value\n\n# LOCALIZATION NOTE: This string is displayed in the output from the 'pref\n# list' command as a label to an input element that allows the user to filter\n# the results.\nprefOutputFilter=Filter\n\n# LOCALIZATION NOTE (prefOutputName, prefOutputValue): These strings are\n# displayed in the output from the 'pref list' command as table headings.\nprefOutputName=Name\nprefOutputValue=Value\n\n# LOCALIZATION NOTE (introDesc, introManual): These strings describe the\n# 'intro' command. The localization of 'Got it!' should be the same used in\n# introTextGo.\nintroDesc=Show the opening message\nintroManual=Redisplay the message that is shown to new users until they click the ‘Got it!’ button\n\n# LOCALIZATION NOTE (introTextOpening3, introTextCommands, introTextKeys2,\n# introTextF1Escape, introTextGo): These strings are displayed when the user\n# first opens the developer toolbar to explain the command line, and is shown\n# each time it is opened until the user clicks the 'Got it!' button.\nintroTextOpening3=GCLI is an experiment to create a highly usable command line for web developers.\nintroTextCommands=For a list of commands type\nintroTextKeys2=, or to show/hide command hints press\nintroTextF1Escape=F1/Escape\nintroTextGo=Got it!\n\n# LOCALIZATION NOTE: This is a short description of the 'hideIntro' setting.\nhideIntroDesc=Show the initial welcome message\n\n# LOCALIZATION NOTE: This is a description of the 'eagerHelper' setting. It's\n# displayed when the user asks for help on the settings. eagerHelper allows\n# users to select between showing no tooltips, permanent tooltips, and only\n# important tooltips.\neagerHelperDesc=How eager are the tooltips\n"

/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside Web Console commands.\n# The Web Console command line is available from the Web Developer sub-menu\n# -> 'Web Console'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (helpDesc) A very short string used to describe the\n# function of the help command.\nhelpDesc=Get help on the available commands\n\n# LOCALIZATION NOTE (helpAvailable) Used in the output of the help command to\n# explain the contents of the command help table.\nhelpAvailable=Available Commands\n\n# LOCALIZATION NOTE (notAvailableInE10S) Used in the output of any command that\n# is not compatible with multiprocess mode (E10S).\nnotAvailableInE10S=The command ‘%1$S’ is not available in multiprocess mode (E10S)\n\n# LOCALIZATION NOTE (consoleDesc) A very short string used to describe the\n# function of the console command.\nconsoleDesc=Commands to control the console\n\n# LOCALIZATION NOTE (consoleManual) A longer description describing the\n# set of commands that control the console.\nconsoleManual=Filter, clear and close the web console\n\n# LOCALIZATION NOTE (consoleclearDesc) A very short string used to describe the\n# function of the 'console clear' command.\nconsoleclearDesc=Clear the console\n\n# LOCALIZATION NOTE (screenshotDesc) A very short description of the\n# 'screenshot' command. See screenshotManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nscreenshotDesc=Save an image of the page\n\n# LOCALIZATION NOTE (screenshotManual) A fuller description of the 'screenshot'\n# command, displayed when the user asks for help on what it does.\nscreenshotManual=Save a PNG image of the entire visible window (optionally after a delay)\n\n# LOCALIZATION NOTE (screenshotFilenameDesc) A very short string to describe\n# the 'filename' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotFilenameDesc=Destination filename\n\n# LOCALIZATION NOTE (screenshotFilenameManual) A fuller description of the\n# 'filename' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotFilenameManual=The name of the file (should have a ‘.png’ extension) to which we write the screenshot.\n\n# LOCALIZATION NOTE (screenshotClipboardDesc) A very short string to describe\n# the 'clipboard' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotClipboardDesc=Copy screenshot to clipboard? (true/false)\n\n# LOCALIZATION NOTE (screenshotClipboardManual) A fuller description of the\n# 'clipboard' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotClipboardManual=True if you want to copy the screenshot instead of saving it to a file.\n\n# LOCALIZATION NOTE (screenshotGroupOptions) A label for the optional options of\n# the screenshot command.\nscreenshotGroupOptions=Options\n\n# LOCALIZATION NOTE (screenshotDelayDesc) A very short string to describe\n# the 'delay' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotDelayDesc=Delay (seconds)\n\n# LOCALIZATION NOTE (screenshotDelayManual) A fuller description of the\n# 'delay' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotDelayManual=The time to wait (in seconds) before the screenshot is taken\n\n# LOCALIZATION NOTE (screenshotDPRDesc) A very short string to describe\n# the 'dpr' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotDPRDesc=Device pixel ratio\n\n# LOCALIZATION NOTE (screenshotDPRManual) A fuller description of the\n# 'dpr' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotDPRManual=The device pixel ratio to use when taking the screenshot\n\n# LOCALIZATION NOTE (screenshotFullscreenDesc) A very short string to describe\n# the 'fullscreen' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotFullPageDesc=Entire webpage? (true/false)\n\n# LOCALIZATION NOTE (screenshotFullscreenManual) A fuller description of the\n# 'fullscreen' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotFullPageManual=True if the screenshot should also include parts of the webpage which are outside the current scrolled bounds.\n\n# LOCALIZATION NOTE (screenshotGeneratedFilename) The auto generated filename\n# when no file name is provided. The first argument (%1$S) is the date string\n# in yyyy-mm-dd format and the second argument (%2$S) is the time string\n# in HH.MM.SS format. Please don't add the extension here.\nscreenshotGeneratedFilename=Screen Shot %1$S at %2$S\n\n# LOCALIZATION NOTE (screenshotErrorSavingToFile) Text displayed to user upon\n# encountering error while saving the screenshot to the file specified.\nscreenshotErrorSavingToFile=Error saving to\n\n# LOCALIZATION NOTE (screenshotSavedToFile) Text displayed to user when the\n# screenshot is successfully saved to the file specified.\nscreenshotSavedToFile=Saved to\n\n# LOCALIZATION NOTE (screenshotErrorCopying) Text displayed to user upon\n# encountering error while copying the screenshot to clipboard.\nscreenshotErrorCopying=Error occurred while copying to clipboard.\n\n# LOCALIZATION NOTE (screenshotCopied) Text displayed to user when the\n# screenshot is successfully copied to the clipboard.\nscreenshotCopied=Copied to clipboard.\n\n# LOCALIZATION NOTE (screenshotTooltipPage) Text displayed as tooltip for screenshot button in devtools ToolBox.\nscreenshotTooltipPage=Take a screenshot of the entire page\n\n# LOCALIZATION NOTE (screenshotImgurDesc) A very short string to describe\n# the 'imgur' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotImgurDesc=Upload to imgur.com\n\n# LOCALIZATION NOTE (screenshotImgurManual) A fuller description of the\n# 'imgur' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotImgurManual=Use if you want to upload to imgur.com instead of saving to disk\n\n# LOCALIZATION NOTE (screenshotImgurError) Text displayed to user upon\n# encountering error while uploading the screenshot to imgur.com.\nscreenshotImgurError=Could not reach imgur API\n\n# LOCALIZATION NOTE (screenshotImgurUploading) Text displayed to user when the\n# screenshot is successfully sent to Imgur but the program is waiting on a response.\n# The argument (%1$S) is a new image URL at Imgur.\nscreenshotImgurUploaded=Uploaded to %1$S\n\n# LOCALIZATION NOTE (highlightDesc) A very short description of the\n# 'highlight' command. See highlightManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nhighlightDesc=Highlight nodes\n\n# LOCALIZATION NOTE (highlightManual) A fuller description of the 'highlight'\n# command, displayed when the user asks for help on what it does.\nhighlightManual=Highlight nodes that match a selector on the page\n\n# LOCALIZATION NOTE (highlightSelectorDesc) A very short string to describe\n# the 'selector' parameter to the 'highlight' command, which is displayed in\n# a dialog when the user is using this command.\nhighlightSelectorDesc=CSS selector\n\n# LOCALIZATION NOTE (highlightSelectorManual) A fuller description of the\n# 'selector' parameter to the 'highlight' command, displayed when the user\n# asks for help on what it does.\nhighlightSelectorManual=The CSS selector used to match nodes in the page\n\n# LOCALIZATION NOTE (highlightOptionsDesc) The title of a set of options to\n# the 'highlight' command, displayed as a heading to the list of option.\nhighlightOptionsDesc=Options\n\n# LOCALIZATION NOTE (highlightHideGuidesDesc) A very short string to describe\n# the 'hideguides' option parameter to the 'highlight' command, which is\n# displayed in a dialog when the user is using this command.\nhighlightHideGuidesDesc=Hide guides\n\n# LOCALIZATION NOTE (highlightHideGuidesManual) A fuller description of the\n# 'hideguides' option parameter to the 'highlight' command, displayed when the\n# user asks for help on what it does.\nhighlightHideGuidesManual=Hide the guides around the highlighted node\n\n# LOCALIZATION NOTE (highlightShowInfoBarDesc) A very short string to describe\n# the 'showinfobar' option parameter to the 'highlight' command, which is\n# displayed in a dialog when the user is using this command.\nhighlightShowInfoBarDesc=Show the node infobar\n\n# LOCALIZATION NOTE (highlightShowInfoBarManual) A fuller description of the\n# 'showinfobar' option parameter to the 'highlight' command, displayed when the\n# user asks for help on what it does.\nhighlightShowInfoBarManual=Show the infobar above the highlighted node (the infobar displays the tagname, attributes and dimension)\n\n# LOCALIZATION NOTE (highlightShowAllDesc) A very short string to describe\n# the 'showall' option parameter to the 'highlight' command, which is\n# displayed in a dialog when the user is using this command.\nhighlightShowAllDesc=Show all matches\n\n# LOCALIZATION NOTE (highlightShowAllManual) A fuller description of the\n# 'showall' option parameter to the 'highlight' command, displayed when the\n# user asks for help on what it does.\nhighlightShowAllManual=If too many nodes match the selector, only the first 100 will be shown to avoid slowing down the page too much. Use this option to show all matches instead\n\n# LOCALIZATION NOTE (highlightRegionDesc) A very short string to describe the\n# 'region' option parameter to the 'highlight' command, which is displayed in a\n# dialog when the user is using this command.\nhighlightRegionDesc=Box model region\n\n# LOCALIZATION NOTE (highlightRegionManual) A fuller description of the 'region'\n# option parameter to the 'highlight' command, displayed when the user asks for\n# help on what it does.\nhighlightRegionManual=Which box model region should be highlighted: ‘content’, ‘padding’, ‘border’ or ‘margin’\n\n# LOCALIZATION NOTE (highlightFillDesc) A very short string to describe the\n# 'fill' option parameter to the 'highlight' command, which is displayed in a\n# dialog when the user is using this command.\nhighlightFillDesc=Fill style\n\n# LOCALIZATION NOTE (highlightFillManual) A fuller description of the 'fill'\n# option parameter to the 'highlight' command, displayed when the user asks for\n# help on what it does.\nhighlightFillManual=Override the default region fill style with a custom color\n\n# LOCALIZATION NOTE (highlightKeepDesc) A very short string to describe the\n# 'keep' option parameter to the 'highlight' command, which is displayed in a\n# dialog when the user is using this command.\nhighlightKeepDesc=Keep existing highlighters\n\n# LOCALIZATION NOTE (highlightKeepManual) A fuller description of the 'keep'\n# option parameter to the 'highlight' command, displayed when the user asks for\n# help on what it does.\nhighlightKeepManual=By default, existing highlighters are hidden when running the command, unless this option is set\n\n# LOCALIZATION NOTE (highlightOutputConfirm) A confirmation message for the\n# 'highlight' command, displayed to the user once the command has been entered,\n# informing the user how many nodes have been highlighted successfully and how\n# to turn highlighting off\nhighlightOutputConfirm2=%1$S node highlighted;%1$S nodes highlighted\n\n# LOCALIZATION NOTE (highlightOutputMaxReached) A confirmation message for the\n# 'highlight' command, displayed to the user once the command has been entered,\n# informing the user how many nodes have been highlighted successfully and that\n# some nodes could not be highlighted due to the maximum number of nodes being\n# reached, and how to turn highlighting off\nhighlightOutputMaxReached=%1$S nodes matched, but only %2$S nodes highlighted. Use ‘--showall’ to show all\n\n# LOCALIZATION NOTE (unhighlightDesc) A very short description of the\n# 'unhighlight' command. See unhighlightManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nunhighlightDesc=Unhighlight all nodes\n\n# LOCALIZATION NOTE (unhighlightManual) A fuller description of the 'unhighlight'\n# command, displayed when the user asks for help on what it does.\nunhighlightManual=Unhighlight all nodes previously highlighted with the ‘highlight’ command\n\n# LOCALIZATION NOTE (restartBrowserDesc) A very short description of the\n# 'restart' command. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\n# The argument (%1$S) is the browser name.\nrestartBrowserDesc=Restart %1$S\n\n# LOCALIZATION NOTE (restartBrowserNocacheDesc) A very short string to\n# describe the 'nocache' parameter to the 'restart' command, which is\n# displayed in a dialog when the user is using this command.\nrestartBrowserNocacheDesc=Disables loading content from cache upon restart\n\n# LOCALIZATION NOTE (restartBrowserRequestCancelled) A string displayed to the\n# user when a scheduled restart has been aborted by the user.\nrestartBrowserRequestCancelled=Restart request cancelled by user.\n\n# LOCALIZATION NOTE (restartBrowserRestarting) A string displayed to the\n# user when a restart has been initiated without a delay.\n# The argument (%1$S) is the browser name.\nrestartBrowserRestarting=Restarting %1$S…\n\n# LOCALIZATION NOTE (restartBrowserGroupOptions) A label for the optional options of\n# the restart command.\nrestartBrowserGroupOptions=Options\n\n# LOCALIZATION NOTE (restartBrowserSafemodeDesc) A very short string to\n# describe the 'safemode' parameter to the 'restart' command, which is\n# displayed in a dialog when the user is using this command.\nrestartBrowserSafemodeDesc=Enables Safe Mode upon restart\n\n# LOCALIZATION NOTE (inspectDesc) A very short description of the 'inspect'\n# command. See inspectManual for a fuller description of what it does. This\n# string is designed to be shown in a menu alongside the command name, which\n# is why it should be as short as possible.\ninspectDesc=Inspect a node\n\n# LOCALIZATION NOTE (inspectManual) A fuller description of the 'inspect'\n# command, displayed when the user asks for help on what it does.\ninspectManual=Investigate the dimensions and properties of an element using a CSS selector to open the DOM highlighter\n\n# LOCALIZATION NOTE (inspectNodeDesc) A very short string to describe the\n# 'node' parameter to the 'inspect' command, which is displayed in a dialog\n# when the user is using this command.\ninspectNodeDesc=CSS selector\n\n# LOCALIZATION NOTE (inspectNodeManual) A fuller description of the 'node'\n# parameter to the 'inspect' command, displayed when the user asks for help\n# on what it does.\ninspectNodeManual=A CSS selector for use with document.querySelector which identifies a single element\n\n# LOCALIZATION NOTE (eyedropperDesc) A very short description of the 'eyedropper'\n# command. See eyedropperManual for a fuller description of what it does. This\n# string is designed to be shown in a menu alongside the command name, which\n# is why it should be as short as possible.\neyedropperDesc=Grab a color from the page\n\n# LOCALIZATION NOTE (eyedropperManual) A fuller description of the 'eyedropper'\n# command, displayed when the user asks for help on what it does.\neyedropperManual=Open a panel that magnifies an area of page to inspect pixels and copy color values\n\n# LOCALIZATION NOTE (debuggerClosed) Used in the output of several commands\n# to explain that the debugger must be opened first.\ndebuggerClosed=The debugger must be opened before using this command\n\n# LOCALIZATION NOTE (debuggerStopped) Used in the output of several commands\n# to explain that the debugger must be opened first before setting breakpoints.\ndebuggerStopped=The debugger must be opened before setting breakpoints\n\n# LOCALIZATION NOTE (breakDesc) A very short string used to describe the\n# function of the break command.\nbreakDesc=Manage breakpoints\n\n# LOCALIZATION NOTE (breakManual) A longer description describing the\n# set of commands that control breakpoints.\nbreakManual=Commands to list, add and remove breakpoints\n\n# LOCALIZATION NOTE (breaklistDesc) A very short string used to describe the\n# function of the 'break list' command.\nbreaklistDesc=Display known breakpoints\n\n# LOCALIZATION NOTE (breaklistNone) Used in the output of the 'break list'\n# command to explain that the list is empty.\nbreaklistNone=No breakpoints set\n\n# LOCALIZATION NOTE (breaklistOutRemove) A title used in the output from the\n# 'break list' command on a button which can be used to remove breakpoints\nbreaklistOutRemove=Remove\n\n# LOCALIZATION NOTE (breakaddAdded) Used in the output of the 'break add'\n# command to explain that a breakpoint was added.\nbreakaddAdded=Added breakpoint\n\n# LOCALIZATION NOTE (breakaddFailed) Used in the output of the 'break add'\n# command to explain that a breakpoint could not be added.\nbreakaddFailed=Could not set breakpoint: %S\n\n# LOCALIZATION NOTE (breakaddDesc) A very short string used to describe the\n# function of the 'break add' command.\nbreakaddDesc=Add a breakpoint\n\n# LOCALIZATION NOTE (breakaddManual) A longer description describing the\n# set of commands that are responsible for adding breakpoints.\nbreakaddManual=Breakpoint types supported: line\n\n# LOCALIZATION NOTE (breakaddlineDesc) A very short string used to describe the\n# function of the 'break add line' command.\nbreakaddlineDesc=Add a line breakpoint\n\n# LOCALIZATION NOTE (breakaddlineFileDesc) A very short string used to describe\n# the function of the file parameter in the 'break add line' command.\nbreakaddlineFileDesc=JS file URI\n\n# LOCALIZATION NOTE (breakaddlineLineDesc) A very short string used to describe\n# the function of the line parameter in the 'break add line' command.\nbreakaddlineLineDesc=Line number\n\n# LOCALIZATION NOTE (breakdelDesc) A very short string used to describe the\n# function of the 'break del' command.\nbreakdelDesc=Remove a breakpoint\n\n# LOCALIZATION NOTE (breakdelBreakidDesc) A very short string used to describe\n# the function of the index parameter in the 'break del' command.\nbreakdelBreakidDesc=Index of breakpoint\n\n# LOCALIZATION NOTE (breakdelRemoved) Used in the output of the 'break del'\n# command to explain that a breakpoint was removed.\nbreakdelRemoved=Breakpoint removed\n\n# LOCALIZATION NOTE (dbgDesc) A very short string used to describe the\n# function of the dbg command.\ndbgDesc=Manage debugger\n\n# LOCALIZATION NOTE (dbgManual) A longer description describing the\n# set of commands that control the debugger.\ndbgManual=Commands to interrupt or resume the main thread, step in, out and over lines of code\n\n# LOCALIZATION NOTE (dbgOpen) A very short string used to describe the function\n# of the dbg open command.\ndbgOpen=Open the debugger\n\n# LOCALIZATION NOTE (dbgClose) A very short string used to describe the function\n# of the dbg close command.\ndbgClose=Close the debugger\n\n# LOCALIZATION NOTE (dbgInterrupt) A very short string used to describe the\n# function of the dbg interrupt command.\ndbgInterrupt=Pauses the main thread\n\n# LOCALIZATION NOTE (dbgContinue) A very short string used to describe the\n# function of the dbg continue command.\ndbgContinue=Resumes the main thread, and continues execution following a breakpoint, until the next breakpoint or the termination of the script.\n\n# LOCALIZATION NOTE (dbgStepDesc) A very short string used to describe the\n# function of the dbg step command.\ndbgStepDesc=Manage stepping\n\n# LOCALIZATION NOTE (dbgStepManual) A longer description describing the\n# set of commands that control stepping.\ndbgStepManual=Commands to step in, out and over lines of code\n\n# LOCALIZATION NOTE (dbgStepOverDesc) A very short string used to describe the\n# function of the dbg step over command.\ndbgStepOverDesc=Executes the current statement and then stops at the next statement. If the current statement is a function call then the debugger executes the whole function, and it stops at the next statement after the function call\n\n# LOCALIZATION NOTE (dbgStepInDesc) A very short string used to describe the\n# function of the dbg step in command.\ndbgStepInDesc=Executes the current statement and then stops at the next statement. If the current statement is a function call, then the debugger steps into that function, otherwise it stops at the next statement\n\n# LOCALIZATION NOTE (dbgStepOutDesc) A very short string used to describe the\n# function of the dbg step out command.\ndbgStepOutDesc=Steps out of the current function and up one level if the function is nested. If in the main body, the script is executed to the end, or to the next breakpoint. The skipped statements are executed, but not stepped through\n\n# LOCALIZATION NOTE (dbgListSourcesDesc) A very short string used to describe the\n# function of the dbg list command.\ndbgListSourcesDesc=List the source URLs loaded in the debugger\n\n# LOCALIZATION NOTE (dbgBlackBoxDesc) A very short string used to describe the\n# function of the 'dbg blackbox' command.\ndbgBlackBoxDesc=Black box sources in the debugger\n\n# LOCALIZATION NOTE (dbgBlackBoxSourceDesc) A very short string used to describe the\n# 'source' parameter to the 'dbg blackbox' command.\ndbgBlackBoxSourceDesc=A specific source to black box\n\n# LOCALIZATION NOTE (dbgBlackBoxGlobDesc) A very short string used to describe the\n# 'glob' parameter to the 'dbg blackbox' command.\ndbgBlackBoxGlobDesc=Black box all sources that match this glob (for example: “*.min.js”)\n\n# LOCALIZATION NOTE (dbgBlackBoxInvertDesc) A very short string used to describe the\n# 'invert' parameter to the 'dbg blackbox' command.\ndbgBlackBoxInvertDesc=Invert matching, so that we black box every source that is not the source provided or does not match the provided glob pattern.\n\n# LOCALIZATION NOTE (dbgBlackBoxEmptyDesc) A very short string used to let the\n# user know that no sources were black boxed.\ndbgBlackBoxEmptyDesc=(No sources black boxed)\n\n# LOCALIZATION NOTE (dbgBlackBoxNonEmptyDesc) A very short string used to let the\n# user know which sources were black boxed.\ndbgBlackBoxNonEmptyDesc=The following sources were black boxed:\n\n# LOCALIZATION NOTE (dbgBlackBoxErrorDesc) A very short string used to let the\n# user know there was an error black boxing a source (whose url follows this\n# text).\ndbgBlackBoxErrorDesc=Error black boxing:\n\n# LOCALIZATION NOTE (dbgUnBlackBoxDesc) A very short string used to describe the\n# function of the 'dbg unblackbox' command.\ndbgUnBlackBoxDesc=Stop black boxing sources in the debugger\n\n# LOCALIZATION NOTE (dbgUnBlackBoxSourceDesc) A very short string used to describe the\n# 'source' parameter to the 'dbg unblackbox' command.\ndbgUnBlackBoxSourceDesc=A specific source to stop black boxing\n\n# LOCALIZATION NOTE (dbgUnBlackBoxGlobDesc) A very short string used to describe the\n# 'glob' parameter to the 'dbg blackbox' command.\ndbgUnBlackBoxGlobDesc=Stop black boxing all sources that match this glob (for example: “*.min.js”)\n\n# LOCALIZATION NOTE (dbgUnBlackBoxEmptyDesc) A very short string used to let the\n# user know that we did not stop black boxing any sources.\ndbgUnBlackBoxEmptyDesc=(Did not stop black boxing any sources)\n\n# LOCALIZATION NOTE (dbgUnBlackBoxNonEmptyDesc) A very short string used to let the\n# user know which sources we stopped black boxing.\ndbgUnBlackBoxNonEmptyDesc=Stopped black boxing the following sources:\n\n# LOCALIZATION NOTE (dbgUnBlackBoxErrorDesc) A very short string used to let the\n# user know there was an error black boxing a source (whose url follows this\n# text).\ndbgUnBlackBoxErrorDesc=Error stopping black boxing:\n\n# LOCALIZATION NOTE (dbgUnBlackBoxInvertDesc) A very short string used to describe the\n# 'invert' parameter to the 'dbg unblackbox' command.\ndbgUnBlackBoxInvertDesc=Invert matching, so that we stop black boxing every source that is not the source provided or does not match the provided glob pattern.\n\n# LOCALIZATION NOTE (consolecloseDesc) A very short description of the\n# 'console close' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nconsolecloseDesc=Close the console\n\n# LOCALIZATION NOTE (consoleopenDesc) A very short description of the\n# 'console open' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nconsoleopenDesc=Open the console\n\n# LOCALIZATION NOTE (editDesc) A very short description of the 'edit'\n# command. See editManual2 for a fuller description of what it does. This\n# string is designed to be shown in a menu alongside the command name, which\n# is why it should be as short as possible.\neditDesc=Tweak a page resource\n\n# LOCALIZATION NOTE (editManual2) A fuller description of the 'edit' command,\n# displayed when the user asks for help on what it does.\neditManual2=Edit one of the resources that is part of this page\n\n# LOCALIZATION NOTE (editResourceDesc) A very short string to describe the\n# 'resource' parameter to the 'edit' command, which is displayed in a dialog\n# when the user is using this command.\neditResourceDesc=URL to edit\n\n# LOCALIZATION NOTE (editLineToJumpToDesc) A very short string to describe the\n# 'line' parameter to the 'edit' command, which is displayed in a dialog\n# when the user is using this command.\neditLineToJumpToDesc=Line to jump to\n\n# LOCALIZATION NOTE (resizePageDesc) A very short string to describe the\n# 'resizepage' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizePageDesc=Resize the page\n\n# LOCALIZATION NOTE (resizePageArgWidthDesc) A very short string to describe the\n# 'width' parameter to the 'resizepage' command, which is displayed in a dialog\n# when the user is using this command.\nresizePageArgWidthDesc=Width in pixels\n\n# LOCALIZATION NOTE (resizePageArgWidthDesc) A very short string to describe the\n# 'height' parameter to the 'resizepage' command, which is displayed in a dialog\n# when the user is using this command.\nresizePageArgHeightDesc=Height in pixels\n\n# LOCALIZATION NOTE (resizeModeOnDesc) A very short string to describe the\n# 'resizeon ' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeOnDesc=Enter Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeOffDesc) A very short string to describe the\n# 'resize off' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeOffDesc=Exit Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeToggleDesc) A very short string to describe the\n# 'resize toggle' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeToggleDesc=Toggle Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeToggleTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles Responsive Design Mode.\nresizeModeToggleTooltip=Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeToDesc) A very short string to describe the\n# 'resize to' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeToDesc=Alter page size\n\n# LOCALIZATION NOTE (resizeModeDesc) A very short string to describe the\n# 'resize' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeDesc=Control Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeManual) A fuller description of the 'resize'\n# command, displayed when the user asks for help on what it does.\n# The argument (%1$S) is the browser name.\nresizeModeManual2=Responsive websites respond to their environment, so they look good on a mobile display, a cinema display and everything in-between. Responsive Design Mode allows you to easily test a variety of page sizes in %1$S without needing to resize your whole browser.\n\n# LOCALIZATION NOTE (cmdDesc) A very short description of the 'cmd'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\ncmdDesc=Manipulate the commands\n\n# LOCALIZATION NOTE (cmdRefreshDesc) A very short description of the 'cmd refresh'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\ncmdRefreshDesc=Re-read mozcmd directory\n\n# LOCALIZATION NOTE (cmdStatus3) When the we load new commands from mozcmd\n# directory, we report where we loaded from using %1$S.\ncmdStatus3=Loaded commands from ‘%1$S’\n\n# LOCALIZATION NOTE (cmdSetdirDesc)  A very short description of the 'cmd setdir'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\ncmdSetdirDesc=Setup a mozcmd directory\n\n# LOCALIZATION NOTE (cmdSetdirManual3) A fuller description of the 'cmd setdir'\n# command, displayed when the user asks for help on what it does.\ncmdSetdirManual3=A ‘mozcmd’ directory is an easy way to create new custom commands. For more information see https://developer.mozilla.org/docs/Tools/GCLI/Customization\n\n# LOCALIZATION NOTE (cmdSetdirDirectoryDesc) The description of the directory\n# parameter to the 'cmd setdir' command.\ncmdSetdirDirectoryDesc=Directory containing .mozcmd files\n\n# LOCALIZATION NOTE (addonDesc) A very short description of the 'addon'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\naddonDesc=Manipulate add-ons\n\n# LOCALIZATION NOTE (addonListDesc) A very short description of the 'addon list'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\naddonListDesc=List installed add-ons\n\n# LOCALIZATION NOTE (addonListTypeDesc) A very short description of the\n# 'addon list <type>' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\naddonListTypeDesc=Select an add-on type\n\n# LOCALIZATION NOTE (addonListDictionaryHeading, addonListExtensionHeading,\n# addonListLocaleHeading, addonListPluginHeading, addonListThemeHeading,\n# addonListUnknownHeading) Used in the output of the 'addon list' command as the\n# first line of output.\naddonListDictionaryHeading=The following dictionaries are currently installed:\naddonListExtensionHeading=The following extensions are currently installed:\naddonListLocaleHeading=The following locales are currently installed:\naddonListPluginHeading=The following plugins are currently installed:\naddonListThemeHeading=The following themes are currently installed:\naddonListAllHeading=The following add-ons are currently installed:\naddonListUnknownHeading=The following add-ons of the selected type are currently installed:\n\n# LOCALIZATION NOTE (addonListOutEnable, addonListOutDisable) Used in the\n# output of the 'addon list' command as the labels for the enable/disable\n# action buttons in the listing. This string is designed to be shown in a\n# small action button next to the addon name, which is why it should be as\n# short as possible.\naddonListOutEnable=Enable\naddonListOutDisable=Disable\n\n# LOCALIZATION NOTE (addonPending, addonPendingEnable, addonPendingDisable,\n# addonPendingUninstall, addonPendingInstall, addonPendingUpgrade) Used in\n# the output of the 'addon list' command as the descriptions of pending\n# addon operations. addonPending is used as a prefix for a list of pending\n# actions (named by the other lookup variables). These strings are designed\n# to be shown alongside addon names, which is why they should be as short\n# as possible.\naddonPending=pending\naddonPendingEnable=enable\naddonPendingDisable=disable\naddonPendingUninstall=uninstall\naddonPendingInstall=install\naddonPendingUpgrade=upgrade\n\n# LOCALIZATION NOTE (addonNameDesc) A very short description of the\n# name parameter of numerous add-on commands. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\naddonNameDesc=The name of the add-on\n\n# LOCALIZATION NOTE (addonNoneOfType) Used in the output of the 'addon list'\n# command when a search for add-ons of a particular type were not found.\naddonNoneOfType=There are no add-ons of that type installed.\n\n# LOCALIZATION NOTE (addonEnableDesc) A very short description of the\n# 'addon enable <type>' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\naddonEnableDesc=Enable the specified add-on\n\n# LOCALIZATION NOTE (addonAlreadyEnabled) Used in the output of the\n# 'addon enable' command when an attempt is made to enable an add-on that is\n# already enabled.\naddonAlreadyEnabled=%S is already enabled.\n\n# LOCALIZATION NOTE (addonEnabled) Used in the output of the 'addon enable'\n# command when an add-on is enabled.\naddonEnabled=%S enabled.\n\n# LOCALIZATION NOTE (addonDisableDesc) A very short description of the\n# 'addon disable <type>' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\naddonDisableDesc=Disable the specified add-on\n\n# LOCALIZATION NOTE (addonAlreadyDisabled) Used in the output of the\n# 'addon disable' command when an attempt is made to disable an add-on that is\n# already disabled.\naddonAlreadyDisabled=%S is already disabled.\n\n# LOCALIZATION NOTE (addonDisabled) Used in the output of the 'addon disable'\n# command when an add-on is disabled.\naddonDisabled=%S disabled.\n\n# LOCALIZATION NOTE (addonCtpDesc) A very short description of the\n# 'addon ctp <type>' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\naddonCtpDesc=Set the specified plugin to click-to-play.\n\n# LOCALIZATION NOTE (addonCtp) Used in the output of the 'addon ctp'\n# command when a plugin is set to click-to-play.\naddonCtp=%S set to click-to-play.\n\n# LOCALIZATION NOTE (addonAlreadyCtp) Used in the output of the\n# 'addon ctp' command when an attempt is made to set a plugin to\n# click-to-play that is already set to click-to-play.\naddonAlreadyCtp=%S is already set to click-to-play.\n\n# LOCALIZATION NOTE (addonCantCtp) Used in the output of the 'addon\n# ctp' command when an attempt is made to set an addon to click-to-play,\n# but the addon is not a plugin.\naddonCantCtp=%S cannot be set to click-to-play because it is not a plugin.\n\n# LOCALIZATION NOTE (addonNoCtp) Used in the output of the 'addon\n# ctp' command when an attempt is made to set an addon to click-to-play,\n# but the plugin cannot be set to click-to-play for some reason.\naddonNoCtp=%S cannot be set to click-to-play.\n\n# LOCALIZATION NOTE (exportDesc) A very short description of the 'export'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\nexportDesc=Export resources\n\n# LOCALIZATION NOTE (exportHtmlDesc) A very short description of the 'export\n# html' command. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nexportHtmlDesc=Export HTML from page\n\n# LOCALIZATION NOTE (pagemodDesc) A very short description of the 'pagemod'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\npagemodDesc=Make page changes\n\n# LOCALIZATION NOTE (pagemodReplaceDesc) A very short description of the\n# 'pagemod replace' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\npagemodReplaceDesc=Search and replace in page elements\n\n# LOCALIZATION NOTE (pagemodReplaceSearchDesc) A very short string to describe\n# the 'search' parameter to the 'pagemod replace' command, which is displayed in\n# a dialog when the user is using this command.\npagemodReplaceSearchDesc=What to search for\n\n# LOCALIZATION NOTE (pagemodReplaceReplaceDesc) A very short string to describe\n# the 'replace' parameter to the 'pagemod replace' command, which is displayed in\n# a dialog when the user is using this command.\npagemodReplaceReplaceDesc=Replacement string\n\n# LOCALIZATION NOTE (pagemodReplaceIgnoreCaseDesc) A very short string to\n# describe the 'ignoreCase' parameter to the 'pagemod replace' command, which is\n# displayed in a dialog when the user is using this command.\npagemodReplaceIgnoreCaseDesc=Perform case-insensitive search\n\n# LOCALIZATION NOTE (pagemodReplaceRootDesc) A very short string to describe the\n# 'root' parameter to the 'pagemod replace' command, which is displayed in\n# a dialog when the user is using this command.\npagemodReplaceRootDesc=CSS selector to root of search\n\n# LOCALIZATION NOTE (pagemodReplaceSelectorDesc) A very short string to describe\n# the 'selector' parameter to the 'pagemod replace' command, which is displayed\n# in a dialog when the user is using this command.\npagemodReplaceSelectorDesc=CSS selector to match in search\n\n# LOCALIZATION NOTE (pagemodReplaceAttributesDesc) A very short string to\n# describe the 'attributes' parameter to the 'pagemod replace' command, which is\n# displayed in a dialog when the user is using this command.\npagemodReplaceAttributesDesc=Attribute match regexp\n\n# LOCALIZATION NOTE (pagemodReplaceAttrOnlyDesc) A very short string to describe\n# the 'attrOnly' parameter to the 'pagemod replace' command, which is displayed\n# in a dialog when the user is using this command.\npagemodReplaceAttrOnlyDesc=Restrict search to attributes\n\n# LOCALIZATION NOTE (pagemodReplaceContentOnlyDesc) A very short string to\n# describe the 'contentOnly' parameter to the 'pagemod replace' command, which\n# is displayed in a dialog when the user is using this command.\npagemodReplaceContentOnlyDesc=Restrict search to text nodes\n\n# LOCALIZATION NOTE (pagemodReplaceResultMatchedElements) A string displayed as\n# the result of the 'pagemod replace' command.\npagemodReplaceResult=Elements matched by selector: %1$S. Replaces in text nodes: %2$S. Replaces in attributes: %3$S.\n\n# LOCALIZATION NOTE (pagemodRemoveDesc) A very short description of the\n# 'pagemod remove' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\npagemodRemoveDesc=Remove elements and attributes from page\n\n# LOCALIZATION NOTE (pagemodRemoveElementDesc) A very short description of the\n# 'pagemod remove element' command. This string is designed to be shown in\n# a menu alongside the command name, which is why it should be as short as\n# possible.\npagemodRemoveElementDesc=Remove elements from page\n\n# LOCALIZATION NOTE (pagemodRemoveElementSearchDesc) A very short string to\n# describe the 'search' parameter to the 'pagemod remove element' command, which\n# is displayed in a dialog when the user is using this command.\npagemodRemoveElementSearchDesc=CSS selector specifying elements to remove\n\n# LOCALIZATION NOTE (pagemodRemoveElementRootDesc) A very short string to\n# describe the 'root' parameter to the 'pagemod remove element' command, which\n# is displayed in a dialog when the user is using this command.\npagemodRemoveElementRootDesc=CSS selector specifying root of search\n\n# LOCALIZATION NOTE (pagemodRemoveElementStripOnlyDesc) A very short string to\n# describe the 'stripOnly' parameter to the 'pagemod remove element' command,\n# which is displayed in a dialog when the user is using this command.\npagemodRemoveElementStripOnlyDesc=Remove element, but leave content\n\n# LOCALIZATION NOTE (pagemodRemoveElementIfEmptyOnlyDesc) A very short string to\n# describe the 'ifEmptyOnly' parameter to the 'pagemod remove element' command,\n# which is displayed in a dialog when the user is using this command.\npagemodRemoveElementIfEmptyOnlyDesc=Remove only empty elements\n\n# LOCALIZATION NOTE (pagemodRemoveElementResultMatchedAndRemovedElements)\n# A string displayed as the result of the 'pagemod remove element' command.\npagemodRemoveElementResultMatchedAndRemovedElements=Elements matched by selector: %1$S. Elements removed: %2$S.\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeDesc) A very short description of the\n# 'pagemod remove attribute' command. This string is designed to be shown in\n# a menu alongside the command name, which is why it should be as short as\n# possible.\npagemodRemoveAttributeDesc=Remove matching attributes\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeSearchAttributesDesc) A very short\n# string to describe the 'searchAttributes' parameter to the 'pagemod remove\n# attribute' command, which is displayed in a dialog when the user is using this\n# command.\npagemodRemoveAttributeSearchAttributesDesc=Regexp specifying attributes to remove\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeSearchElementsDesc) A very short\n# string to describe the 'searchElements' parameter to the 'pagemod remove\n# attribute' command, which is displayed in a dialog when the user is using this\n# command.\npagemodRemoveAttributeSearchElementsDesc=CSS selector of elements to include\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeRootDesc) A very short string to\n# describe the 'root' parameter to the 'pagemod remove attribute' command, which\n# is displayed in a dialog when the user is using this command.\npagemodRemoveAttributeRootDesc=CSS selector of root of search\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeIgnoreCaseDesc) A very short string\n# to describe the 'ignoreCase' parameter to the 'pagemod remove attribute'\n# command, which is displayed in a dialog when the user is using this command.\npagemodRemoveAttributeIgnoreCaseDesc=Perform case-insensitive search\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeResult) A string displayed as the\n# result of the 'pagemod remove attribute' command.\npagemodRemoveAttributeResult=Elements matched by selector: %1$S. Attributes removed: %2$S.\n\n# LOCALIZATION NOTE (toolsDesc2) A very short description of the 'tools'\n# command, the parent command for tool-hacking commands.\n# The argument (%1$S) is the browser name.\ntoolsDesc2=Hack the %1$S Developer Tools\n\n# LOCALIZATION NOTE (toolsManual2) A fuller description of the 'tools'\n# command. The argument (%1$S) is the browser name.\ntoolsManual2=Various commands related to hacking directly on the %1$S Developer Tools.\n\n# LOCALIZATION NOTE (toolsSrcdirDesc) A very short description of the 'tools srcdir'\n# command, for pointing your developer tools loader at a mozilla-central source tree.\ntoolsSrcdirDesc=Load tools from a mozilla-central checkout\n\n# LOCALIZATION NOTE (toolsSrcdirNotFound2) Shown when the 'tools srcdir' command was handed\n# an invalid srcdir.\ntoolsSrcdirNotFound2=%1$S does not exist or is not a mozilla-central checkout.\n\n# LOCALIZATION NOTE (toolsSrcdirReloaded2) Displayed when tools have been reloaded by the\n# 'tools srcdir' command.\ntoolsSrcdirReloaded2=Tools loaded from %1$S.\n\n# LOCALIZATION NOTE (toolsSrcdirManual2) A full description of the 'tools srcdir'\n# command. The argument (%1$S) is the browser name.\ntoolsSrcdirManual2=Load the %1$S Developer Tools from a complete mozilla-central checkout.\n\n# LOCALIZATION NOTE (toolsSrcdirDir) The srcdir argument to the 'tools srcdir' command.\ntoolsSrcdirDir=A mozilla-central checkout\n\n# LOCALIZATION NOTE (toolsBuiltinDesc) A short description of the 'tools builtin'\n# command, which overrides a previous 'tools srcdir' command.\ntoolsBuiltinDesc=Use the builtin tools\n\n# LOCALIZATION NOTE (toolsBuiltinDesc) A fuller description of the 'tools builtin'\n# command.\ntoolsBuiltinManual=Use the builtin tools, overriding any previous srcdir command.\n\n# LOCALIZATION NOTE (toolsBuiltinReloaded) Displayed when tools are loaded with the\n# 'tools builtin' command.\ntoolsBuiltinReloaded=Builtin tools loaded.\n\n# LOCALIZATION NOTE (toolsReloadDesc) A short description of the 'tools reload' command.\n# which will reload the tools from the current srcdir.\ntoolsReloadDesc=Reload the developer tools\n\n# LOCALIZATION NOTE (toolsReloaded2) Displayed when tools are reloaded with the 'tools\n# reload' command.\ntoolsReloaded2=Tools reloaded.\n\n# LOCALIZATION NOTE (cookieDesc) A very short description of the 'cookie'\n# command. See cookieManual for a fuller description of what it does. This\n# string is designed to be shown in a menu alongside the command name, which\n# is why it should be as short as possible.\ncookieDesc=Display and alter cookies\n\n# LOCALIZATION NOTE (cookieManual) A fuller description of the 'cookie'\n# command, displayed when the user asks for help on what it does.\ncookieManual=Commands to list, create, delete and alter cookies for the current domain.\n\n# LOCALIZATION NOTE (cookieListDesc) A very short description of the\n# 'cookie list' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncookieListDesc=Display cookies\n\n# LOCALIZATION NOTE (cookieListManual) A fuller description of the 'cookie list'\n# command, displayed when the user asks for help on what it does.\ncookieListManual=Display a list of the cookies relevant to the current page.\n\n# LOCALIZATION NOTE (cookieListOutHost,cookieListOutPath,cookieListOutExpires,cookieListOutAttributes):\n# The 'cookie list' command has a number of headings for cookie properties.\n# Particular care should be taken in translating these strings as they have\n# references to names in the cookies spec.\ncookieListOutHost=Host:\ncookieListOutPath=Path:\ncookieListOutExpires=Expires:\ncookieListOutAttributes=Attributes:\n\n# LOCALIZATION NOTE (cookieListOutNone) The output of the 'cookie list' command\n# uses this string when no cookie attributes (like httpOnly, secure, etc) apply\ncookieListOutNone=None\n\n# LOCALIZATION NOTE (cookieListOutSession) The output of the 'cookie list'\n# command uses this string to describe a cookie with an expiry value of '0'\n# that is to say it is a session cookie\ncookieListOutSession=At browser exit (session)\n\n# LOCALIZATION NOTE (cookieListOutNonePage) The output of the 'cookie list'\n# command uses this string for pages like 'about:blank' which can't contain\n# cookies\ncookieListOutNonePage=No cookies found for this page\n\n# LOCALIZATION NOTE (cookieListOutNoneHost) The output of the 'cookie list'\n# command uses this string when there are no cookies on a given web page\ncookieListOutNoneHost=No cookies found for host %1$S\n\n# LOCALIZATION NOTE (cookieListOutEdit) A title used in the output from the\n# 'cookie list' command on a button which can be used to edit cookie values\ncookieListOutEdit=Edit\n\n# LOCALIZATION NOTE (cookieListOutRemove) A title used in the output from the\n# 'cookie list' command on a button which can be used to remove cookies\ncookieListOutRemove=Remove\n\n# LOCALIZATION NOTE (cookieRemoveDesc) A very short description of the\n# 'cookie remove' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncookieRemoveDesc=Remove a cookie\n\n# LOCALIZATION NOTE (cookieRemoveManual) A fuller description of the 'cookie remove'\n# command, displayed when the user asks for help on what it does.\ncookieRemoveManual=Remove a cookie, given its key\n\n# LOCALIZATION NOTE (cookieRemoveKeyDesc) A very short string to describe the\n# 'key' parameter to the 'cookie remove' command, which is displayed in a dialog\n# when the user is using this command.\ncookieRemoveKeyDesc=The key of the cookie to remove\n\n# LOCALIZATION NOTE (cookieSetDesc) A very short description of the\n# 'cookie set' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncookieSetDesc=Set a cookie\n\n# LOCALIZATION NOTE (cookieSetManual) A fuller description of the 'cookie set'\n# command, displayed when the user asks for help on what it does.\ncookieSetManual=Set a cookie by specifying a key name, its value and optionally one or more of the following attributes: expires (max-age in seconds or the expires date in GMTString format), path, domain, secure\n\n# LOCALIZATION NOTE (cookieSetKeyDesc) A very short string to describe the\n# 'key' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetKeyDesc=The key of the cookie to set\n\n# LOCALIZATION NOTE (cookieSetValueDesc) A very short string to describe the\n# 'value' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetValueDesc=The value of the cookie to set\n\n# LOCALIZATION NOTE (cookieSetOptionsDesc) The title of a set of options to\n# the 'cookie set' command, displayed as a heading to the list of option.\ncookieSetOptionsDesc=Options\n\n# LOCALIZATION NOTE (cookieSetPathDesc) A very short string to describe the\n# 'path' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetPathDesc=The path of the cookie to set\n\n# LOCALIZATION NOTE (cookieSetDomainDesc) A very short string to describe the\n# 'domain' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetDomainDesc=The domain of the cookie to set\n\n# LOCALIZATION NOTE (cookieSetSecureDesc) A very short string to describe the\n# 'secure' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetSecureDesc=Only transmitted over https\n\n# LOCALIZATION NOTE (cookieSetHttpOnlyDesc) A very short string to describe the\n# 'httpOnly' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetHttpOnlyDesc=Not accessible from client side script\n\n# LOCALIZATION NOTE (cookieSetSessionDesc) A very short string to describe the\n# 'session' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetSessionDesc=Only valid for the lifetime of the browser session\n\n# LOCALIZATION NOTE (cookieSetExpiresDesc) A very short string to describe the\n# 'expires' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetExpiresDesc=The expiry date of the cookie (quoted RFC2822 or ISO 8601 date)\n\n# LOCALIZATION NOTE (jsbDesc) A very short description of the\n# 'jsb' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\njsbDesc=JavaScript beautifier\n\n# LOCALIZATION NOTE (jsbUrlDesc) A very short description of the\n# 'jsb <url>' parameter. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\njsbUrlDesc=The URL of the JS file to beautify\n\n# LOCALIZATION NOTE (jsbIndentSizeDesc) A very short description of the\n# 'jsb <indentSize>' parameter. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\njsbIndentSizeDesc=Indentation size in chars\n\n# LOCALIZATION NOTE (jsbIndentSizeManual) A fuller description of the\n# 'jsb <indentChar>' parameter, displayed when the user asks for help on what it\n# does.\njsbIndentSizeManual=The number of chars with which to indent each line\n\n# LOCALIZATION NOTE (jsbIndentCharDesc) A very short description of the\n# 'jsb <indentChar>' parameter. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\njsbIndentCharDesc=The chars used to indent each line\n\n# LOCALIZATION NOTE (jsbIndentCharManual) A fuller description of the\n# 'jsb <indentChar>' parameter, displayed when the user asks for help on what it\n# does.\njsbIndentCharManual=The chars used to indent each line. The possible choices are space or tab.\n\n# the 'jsb <doNotPreserveNewlines>' parameter. This string is designed to be\n# shown in a menu alongside the command name, which is why it should be as short\n# as possible.\njsbDoNotPreserveNewlinesDesc=Do not preserve line breaks\n\n# LOCALIZATION NOTE (jsbPreserveNewlinesManual) A fuller description of the\n# 'jsb <jsbPreserveNewlines>' parameter, displayed when the user asks for help\n# on what it does.\njsbPreserveNewlinesManual=Should existing line breaks be preserved\n\n# LOCALIZATION NOTE (jsbPreserveMaxNewlinesDesc) A very short description of the\n# 'jsb <preserveMaxNewlines>' parameter. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\njsbPreserveMaxNewlinesDesc=Max consecutive line breaks\n\n# LOCALIZATION NOTE (jsbPreserveMaxNewlinesManual) A fuller description of the\n# 'jsb <preserveMaxNewlines>' parameter, displayed when the user asks for help\n# on what it does.\njsbPreserveMaxNewlinesManual=The maximum number of consecutive line breaks to preserve\n\n# LOCALIZATION NOTE (jsbJslintHappyDesc) A very short description of the\n# 'jsb <jslintHappy>' parameter. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\njsbJslintHappyDesc=Enforce jslint-stricter mode?\n\n# LOCALIZATION NOTE (jsbJslintHappyManual) A fuller description of the\n# 'jsb <jslintHappy>' parameter, displayed when the user asks for help\n# on what it does.\njsbJslintHappyManual=When set to true, jslint-stricter mode is enforced\n\n# LOCALIZATION NOTE (jsbBraceStyleDesc2) A very short description of the\n# 'jsb <braceStyle>' parameter. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\njsbBraceStyleDesc2=Select the coding style of braces\n\n# LOCALIZATION NOTE (jsbBraceStyleManual2) A fuller description of the\n# 'jsb <braceStyle>' parameter, displayed when the user asks for help\n# on what it does.\n#\n# NOTES: The keywords collapse, expand, end-expand and expand-strict should not\n# be translated. \"even if it will break your code\" means that the resulting code\n# may no longer be functional.\njsbBraceStyleManual2=Select the coding style of braces: collapse - put braces on the same line as control statements; expand - put braces on own line (Allman / ANSI style); end-expand - put end braces on own line; expand-strict - put braces on own line even if it will break your code.\n\n# LOCALIZATION NOTE (jsbNoSpaceBeforeConditionalDesc) A very short description\n# of the 'jsb <noSpaceBeforeConditional>' parameter. This string is designed to\n# be shown in a menu alongside the command name, which is why it should be as\n# short as possible.\njsbNoSpaceBeforeConditionalDesc=No space before conditional statements\n\n# LOCALIZATION NOTE (jsbUnescapeStringsDesc) A very short description of the\n# 'jsb <unescapeStrings>' parameter. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\njsbUnescapeStringsDesc=Unescape \\\\xNN characters?\n\n# LOCALIZATION NOTE (jsbUnescapeStringsManual) A fuller description of the\n# 'jsb <unescapeStrings>' parameter, displayed when the user asks for help\n# on what it does.\njsbUnescapeStringsManual=Should printable characters in strings encoded in \\\\xNN notation be unescaped?\n\n# LOCALIZATION NOTE (jsbInvalidURL) Displayed when an invalid URL is passed to\n# the jsb command.\njsbInvalidURL=Please enter a valid URL\n\n# LOCALIZATION NOTE (jsbOptionsDesc) The title of a set of options to\n# the 'jsb' command, displayed as a heading to the list of options.\njsbOptionsDesc=Options\n\n# LOCALIZATION NOTE (calllogDesc) A very short description of the\n# 'calllog' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogDesc=Commands to manipulate function call logging\n\n# LOCALIZATION NOTE (calllogStartDesc) A very short description of the\n# 'calllog start' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogStartDesc=Start logging function calls to the console\n\n# LOCALIZATION NOTE (calllogStartReply) A string displayed as the result of\n# the 'calllog start' command.\ncalllogStartReply=Call logging started.\n\n# LOCALIZATION NOTE (calllogStopDesc) A very short description of the\n# 'calllog stop' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogStopDesc=Stop function call logging\n\n# LOCALIZATION NOTE (calllogStopNoLogging) A string displayed as the result of\n# the 'calllog stop' command when there is nothing to stop.\ncalllogStopNoLogging=No call logging is currently active\n\n# LOCALIZATION NOTE (calllogStopReply) A string displayed as the result of\n# the 'calllog stop' command when there are logging actions to stop.\ncalllogStopReply=Stopped call logging. Active contexts: %1$S.\n\n# LOCALIZATION NOTE (calllogStartChromeDesc) A very short description of the\n# 'calllog chromestart' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogChromeStartDesc=Start logging function calls for chrome code to the console\n\n# LOCALIZATION NOTE (calllogChromeSourceTypeDesc) A very short description of the\n# 'calllog chromestart <sourceType>' parameter. This string is designed to be\n# shown in a menu alongside the command name, which is why it should be as short as possible.\ncalllogChromeSourceTypeDesc=Global object, JSM URI, or JS to get a global object from\n\n# LOCALIZATION NOTE (calllogChromeSourceTypeDesc) A very short description of the\n# 'calllog chromestart' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogChromeSourceTypeManual=The global object, URI of a JSM, or JS to execute in the chrome window from which to obtain a global object\n\n# LOCALIZATION NOTE (calllogChromeStartReply) A string displayed as the result\n# of the 'calllog chromestart' command.\ncalllogChromeStartReply=Call logging started.\n\n# LOCALIZATION NOTE (calllogChromeStopDesc) A very short description of the\n# 'calllog chromestop' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogChromeStopDesc=Stop function call logging\n\n# LOCALIZATION NOTE (calllogChromeStopNoLogging) A string displayed as the\n# result of the 'calllog chromestop' command when there is nothing to stop.\ncalllogChromeStopNoLogging=No call logging for chrome code is currently active\n\n# LOCALIZATION NOTE (calllogStopReply) A string displayed as the result of\n# the 'calllog chromestop' command when there are logging actions to stop.\ncalllogChromeStopReply=Stopped call logging. Active contexts: %1$S.\n\n# LOCALIZATION NOTE (callLogChromeAnonFunction) A string displayed as the result\n# of the 'calllog chromestart' command when an anonymouse function is to be\n# logged.\ncallLogChromeAnonFunction=<anonymous>\n\n# LOCALIZATION NOTE (callLogChromeMethodCall) A string displayed as the result\n# of the 'calllog chromestart' command to proceed a method name when it is to be\n# logged.\ncallLogChromeMethodCall=Method call\n\n# LOCALIZATION NOTE (callLogChromeInvalidJSM) A string displayed as the result\n# of the 'calllog chromestart' command with an invalid JSM or JSM path.\ncallLogChromeInvalidJSM=Invalid JSM!\n\n# LOCALIZATION NOTE (callLogChromeVarNotFoundContent) A string displayed as the\n# result of the 'calllog chromestart' command with a source type of\n# content-variable and an invalid variable name.\ncallLogChromeVarNotFoundContent=Variable not found in content window.\n\n# LOCALIZATION NOTE (callLogChromeVarNotFoundChrome) A string displayed as the\n# result of the 'calllog chromestart' command with a source type of\n# chrome-variable and an invalid variable name.\ncallLogChromeVarNotFoundChrome=Variable not found in chrome window.\n\n# LOCALIZATION NOTE (callLogChromeEvalException) A string displayed as the\n# result of the 'calllog chromestart' command with a source type of JavaScript\n# and invalid JavaScript code.\ncallLogChromeEvalException=Evaluated JavaScript threw the following exception\n\n# LOCALIZATION NOTE (callLogChromeEvalNeedsObject) A string displayed as the\n# result of passing a non-JavaScript object creating source via the\n# 'calllog chromestart javascript' command.\ncallLogChromeEvalNeedsObject=The JavaScript source must evaluate to an object whose method calls are to be logged e.g. “({a1: function() {this.a2()},a2: function() {}});”\n\n# LOCALIZATION NOTE (scratchpadOpenTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which opens Scratchpad.\nscratchpadOpenTooltip=Scratchpad\n\n# LOCALIZATION NOTE (paintflashingDesc) A very short string used to describe the\n# function of the \"paintflashing\" command\npaintflashingDesc=Highlight painted area\n\n# LOCALIZATION NOTE (paintflashingOnDesc) A very short string used to describe the\n# function of the \"paintflashing on\" command.\npaintflashingOnDesc=Turn on paint flashing\n\n# LOCALIZATION NOTE (paintflashingOffDesc) A very short string used to describe the\n# function of the \"paintflashing off\" command.\npaintflashingOffDesc=Turn off paint flashing\n\n# LOCALIZATION NOTE (paintflashingChrome) A very short string used to describe the\n# function of the \"paintflashing on/off chrome\" command.\npaintflashingChromeDesc=chrome frames\n\n# LOCALIZATION NOTE (paintflashingManual) A longer description describing the\n# set of commands that control paint flashing.\npaintflashingManual=Draw repainted areas in different colors\n\n# LOCALIZATION NOTE (paintflashingTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles paint flashing.\npaintflashingTooltip=Highlight painted area\n\n# LOCALIZATION NOTE (paintflashingToggleDesc) A very short string used to describe the\n# function of the \"paintflashing toggle\" command.\npaintflashingToggleDesc=Toggle paint flashing\n\n# LOCALIZATION NOTE (splitconsoleTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles the split webconsole.\nsplitconsoleTooltip=Toggle split console\n\n# LOCALIZATION NOTE (appCacheDesc) A very short string used to describe the\n# function of the \"appcache\" command\nappCacheDesc=Application cache utilities\n\n# LOCALIZATION NOTE (appCacheValidateDesc) A very short string used to describe\n# the function of the \"appcache validate\" command.\nappCacheValidateDesc=Validate cache manifest\n\n# LOCALIZATION NOTE (appCacheValidateManual) A fuller description of the\n# 'validate' parameter to the 'appcache' command, displayed when the user asks\n# for help on what it does.\nappCacheValidateManual=Find issues relating to a cache manifest and the files that it references\n\n# LOCALIZATION NOTE (appCacheValidateUriDesc) A very short string used to describe\n# the function of the \"uri\" parameter of the appcache validate\" command.\nappCacheValidateUriDesc=URI to check\n\n# LOCALIZATION NOTE (appCacheValidated) Displayed by the \"appcache validate\"\n# command when it has been successfully validated.\nappCacheValidatedSuccessfully=Appcache validated successfully.\n\n# LOCALIZATION NOTE (appCacheClearDesc) A very short string used to describe\n# the function of the \"appcache clear\" command.\nappCacheClearDesc=Clear entries from the application cache\n\n# LOCALIZATION NOTE (appCacheClearManual) A fuller description of the\n# 'appcache clear' command, displayed when the user asks for help on what it does.\nappCacheClearManual=Clear one or more entries from the application cache\n\n# LOCALIZATION NOTE (appCacheClearCleared) Displayed by the \"appcache clear\"\n# command when entries are successfully cleared.\nappCacheClearCleared=Entries cleared successfully.\n\n# LOCALIZATION NOTE (AppCacheListDesc) A very short string used to describe\n# the function of the \"appcache list\" command.\nappCacheListDesc=Display a list of application cache entries.\n\n# LOCALIZATION NOTE (AppCacheListManual) A fuller description of the\n# 'appcache list' command, displayed when the user asks for help on what it does.\nappCacheListManual=Display a list of all application cache entries. If the search parameter is used then the table displays the entries containing the search term.\n\n# LOCALIZATION NOTE (AppCacheListSearchDesc) A very short string used to describe\n# the function of the \"search\" parameter of the appcache list\" command.\nappCacheListSearchDesc=Filter results using a search term.\n\n# LOCALIZATION NOTE (AppCacheList*) Row headers for the 'appcache list' command.\nappCacheListKey=Key:\nappCacheListDataSize=Data size:\nappCacheListDeviceID=Device ID:\nappCacheListExpirationTime=Expires:\nappCacheListFetchCount=Fetch count:\nappCacheListLastFetched=Last fetched:\nappCacheListLastModified=Last modified:\n\n# LOCALIZATION NOTE (appCacheListViewEntry) The text for the view entry button\n# of the 'appcache list' command.\nappCacheListViewEntry=View Entry\n\n# LOCALIZATION NOTE (appCacheViewEntryDesc) A very short string used to describe\n# the function of the \"appcache viewentry\" command.\nappCacheViewEntryDesc=Open a new tab containing the specified cache entry information.\n\n# LOCALIZATION NOTE (appCacheViewEntryManual) A fuller description of the\n# 'appcache viewentry' command, displayed when the user asks for help on what it\n# does.\nappCacheViewEntryManual=Open a new tab containing the specified cache entry information.\n\n# LOCALIZATION NOTE (appCacheViewEntryKey) A very short string used to describe\n# the function of the \"key\" parameter of the 'appcache viewentry' command.\nappCacheViewEntryKey=The key for the entry to display.\n\n# LOCALIZATION NOTE (profilerDesc) A very short string used to describe the\n# function of the profiler command.\nprofilerDesc=Manage profiler\n\n# LOCALIZATION NOTE (profilerManual) A longer description describing the\n# set of commands that control the profiler.\nprofilerManual=Commands to start or stop a JavaScript profiler\n\n# LOCALIZATION NOTE (profilerOpen) A very short string used to describe the function\n# of the profiler open command.\nprofilerOpenDesc=Open the profiler\n\n# LOCALIZATION NOTE (profilerClose) A very short string used to describe the function\n# of the profiler close command.\nprofilerCloseDesc=Close the profiler\n\n# LOCALIZATION NOTE (profilerStart) A very short string used to describe the function\n# of the profiler start command.\nprofilerStartDesc=Start profiling\n\n# LOCALIZATION NOTE (profilerStartManual) A fuller description of the 'profile name'\n# parameter. This parameter is used to name a newly created profile or to lookup\n# an existing profile by its name.\nprofilerStartManual=Name of a profile you wish to start.\n\n# LOCALIZATION NOTE (profilerStop) A very short string used to describe the function\n# of the profiler stop command.\nprofilerStopDesc=Stop profiling\n\n# LOCALIZATION NOTE (profilerStopManual) A fuller description of the 'profile name'\n# parameter. This parameter is used to lookup an existing profile by its name.\nprofilerStopManual=Name of a profile you wish to stop.\n\n# LOCALIZATION NOTE (profilerList) A very short string used to describe the function\n# of the profiler list command.\nprofilerListDesc=List all profiles\n\n# LOCALIZATION NOTE (profilerShow) A very short string used to describe the function\n# of the profiler show command.\nprofilerShowDesc=Show individual profile\n\n# LOCALIZATION NOTE (profilerShowManual) A fuller description of the 'profile name'\n# parameter. This parameter is used to name a newly created profile or to lookup\n# an existing profile by its name.\nprofilerShowManual=Name of a profile.\n\n# LOCALIZATION NOTE (profilerAlreadyStarted) A message that is displayed whenever\n# an operation cannot be completed because the profile in question has already\n# been started.\nprofilerAlreadyStarted2=Profile has already been started\n\n# LOCALIZATION NOTE (profilerNotFound) A message that is displayed whenever\n# an operation cannot be completed because the profile in question could not be\n# found.\nprofilerNotFound=Profile not found\n\n# LOCALIZATION NOTE (profilerNotStarted) A message that is displayed whenever\n# an operation cannot be completed because the profile in question has not been\n# started yet. It also contains a hint to use the 'profile start' command to\n# start the profiler.\nprofilerNotStarted3=Profiler has not been started yet. Use ‘profile start’ to start profiling\n\n# LOCALIZATION NOTE (profilerStarted2) A very short string that indicates that\n# we have started recording.\nprofilerStarted2=Recording…\n\n# LOCALIZATION NOTE (profilerStopped) A very short string that indicates that\n# we have stopped recording.\nprofilerStopped=Stopped…\n\n# LOCALIZATION NOTE (profilerNotReady) A message that is displayed whenever\n# an operation cannot be completed because the profiler has not been opened yet.\nprofilerNotReady=For this command to work you need to open the profiler first\n\n# LOCALIZATION NOTE (listenDesc) A very short string used to describe the\n# function of the 'listen' command.\nlistenDesc=Open a remote debug port\n\n# LOCALIZATION NOTE (listenManual2) A longer description of the 'listen'\n# command.\nlistenManual2=%1$S can allow remote debugging over a TCP/IP connection. For security reasons this is turned off by default, but can be enabled using this command.\n\n# LOCALIZATION NOTE (listenPortDesc) A very short string used to describe the\n# function of 'port' parameter to the 'listen' command.\nlistenPortDesc=The TCP port to listen on\n\n# LOCALIZATION NOTE (listenDisabledOutput) Text of a message output during the\n# execution of the 'listen' command.\nlistenDisabledOutput=Listen is disabled by the devtools.debugger.remote-enabled preference\n\n# LOCALIZATION NOTE (listenInitOutput) Text of a message output during the\n# execution of the 'listen' command. %1$S is a port number\nlistenInitOutput=Listening on port %1$S\n\n# LOCALIZATION NOTE (listenNoInitOutput) Text of a message output during the\n# execution of the 'listen' command.\nlistenNoInitOutput=DebuggerServer not initialized\n\n# LOCALIZATION NOTE (unlistenDesc) A very short string used to describe the\n# function of the 'unlisten' command.\nunlistenDesc=Close all remote debug ports\n\n# LOCALIZATION NOTE (unlistenManual) A longer description of the 'unlisten'\n# command.\nunlistenManual=Closes all the open ports for remote debugging.\n\n# LOCALIZATION NOTE (unlistenOutput) Text of a message output during the\n# execution of the 'unlisten' command.\nunlistenOutput=All TCP ports closed\n\n# LOCALIZATION NOTE (mediaDesc, mediaEmulateDesc, mediaEmulateManual,\n# mediaEmulateType, mediaResetDesc, mediaResetManual) These strings describe\n# the 'media' commands and all available parameters.\nmediaDesc=CSS media type emulation\nmediaEmulateDesc=Emulate a specified CSS media type\nmediaEmulateManual=View the document as if rendered on a device supporting the given media type, with the relevant CSS rules applied.\nmediaEmulateType=The media type to emulate\nmediaResetDesc=Stop emulating a CSS media type\n\n# LOCALIZATION NOTE (qsaDesc, qsaQueryDesc)\n# These strings describe the 'qsa' commands and all available parameters.\nqsaDesc=Perform querySelectorAll on the current document and return number of matches\nqsaQueryDesc=CSS selectors separated by comma\n\n# LOCALIZATION NOTE (injectDesc, injectManual, injectLibraryDesc, injectLoaded,\n# injectFailed) These strings describe the 'inject' commands and all available\n# parameters.\ninjectDesc=Inject common libraries into the page\ninjectManual2=Inject common libraries into the content of the page which can also be accessed from the console.\ninjectLibraryDesc=Select the library to inject or enter a valid script URI to inject\ninjectLoaded=%1$S loaded\ninjectFailed=Failed to load %1$S - Invalid URI\n\n# LOCALIZATION NOTE (folderDesc, folderOpenDesc, folderOpenDir,\n# folderOpenProfileDesc) These strings describe the 'folder' commands and\n# all available parameters.\nfolderDesc=Open folders\nfolderOpenDesc=Open folder path\nfolderOpenDir=Directory Path\nfolderOpenProfileDesc=Open profile directory\n\n# LOCALIZATION NOTE (folderInvalidPath) A string displayed as the result\n# of the 'folder open' command with an invalid folder path.\nfolderInvalidPath=Please enter a valid path\n\n# LOCALIZATION NOTE (folderOpenDirResult) A very short string used to\n# describe the result of the 'folder open' command.\n# The argument (%1$S) is the folder path.\nfolderOpenDirResult=Opened %1$S\n\n# LOCALIZATION NOTE (mdnDesc) A very short string used to describe the\n# use of 'mdn' command.\nmdnDesc=Retrieve documentation from MDN\n# LOCALIZATION NOTE (mdnCssDesc) A very short string used to describe the\n# result of the 'mdn css' command.\nmdnCssDesc=Retrieve documentation about a given CSS property name from MDN\n# LOCALIZATION NOTE (mdnCssProp) String used to describe the 'property name'\n# parameter used in the 'mdn css' command.\nmdnCssProp=Property name\n# LOCALIZATION NOTE (mdnCssPropertyNotFound) String used to display an error in\n# the result of the 'mdn css' command. Errors occur when a given CSS property\n# wasn't found on MDN. The %1$S parameter will be replaced with the name of the\n# CSS property.\nmdnCssPropertyNotFound=MDN documentation for the CSS property ‘%1$S’ was not found.\n# LOCALIZATION NOTE (mdnCssVisitPage) String used as the label of a link to the\n# MDN page for a given CSS property.\nmdnCssVisitPage=Visit MDN page\n\n# LOCALIZATION NOTE (security)\nsecurityPrivacyDesc=Display supported security and privacy features\nsecurityManual=Commands to list and get suggestions about security features for the current domain.\nsecurityListDesc=Display security features\nsecurityListManual=Display a list of all relevant security features of the current page.\n# CSP specific\nsecurityCSPDesc=Display CSP specific security features\nsecurityCSPManual=Display feedback about the CSP applied to the current page.\nsecurityCSPRemWildCard=Can you remove the wildcard(*)?\nsecurityCSPPotentialXSS=Potential XSS vulnerability!\n# LOCALIZATION NOTE: do not translate 'Content-Security-Policy'\nsecurityCSPNoCSPOnPage=Could not find Content-Security-Policy for\nsecurityCSPHeaderOnPage=Content-Security-Policy for\nsecurityCSPROHeaderOnPage=Content-Security-Policy-Report-Only for\n# Referrer Policy specific\nsecurityReferrerPolicyDesc=Display the current Referrer Policy\nsecurityReferrerPolicyManual=Display the Referrer Policy for the current page with example referrers for different URIs.\nsecurityReferrerNextURI=When Visiting\nsecurityReferrerCalculatedReferrer=Referrer Will Be\n# LOCALIZATION NOTE: %1$S is the current page URI\nsecurityReferrerPolicyReportHeader=Referrer Policy for %1$S\nsecurityReferrerPolicyOtherDomain=Other Origin\nsecurityReferrerPolicyOtherDomainDowngrade=Other Origin HTTP\nsecurityReferrerPolicySameDomain=Same Origin\nsecurityReferrerPolicySameDomainDowngrade=Same Host HTTP\n\n# LOCALIZATION NOTE (rulersDesc) A very short description of the\n# 'rulers' command. See rulersManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nrulersDesc=Toggle rulers for the page\n\n# LOCALIZATION NOTE (rulersManual) A fuller description of the 'rulers'\n# command, displayed when the user asks for help on what it does.\nrulersManual=Toggle the horizontal and vertical rulers for the current page\n\n# LOCALIZATION NOTE (rulersTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles the rulers.\nrulersTooltip=Toggle rulers for the page\n\n# LOCALIZATION NOTE (measureDesc) A very short description of the\n# 'measure' command. See measureManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nmeasureDesc=Measure a portion of the page\n\n# LOCALIZATION NOTE (measureManual) A fuller description of the 'measure'\n# command, displayed when the user asks for help on what it does.\nmeasureManual=Activate the measuring tool to measure an arbitrary area of the page\n\n# LOCALIZATION NOTE (measureTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles the measuring tool.\nmeasureTooltip=Measure a portion of the page\n"

/***/ },
/* 47 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (ellipsis): The ellipsis (three dots) character\nellipsis=…"

/***/ },
/* 48 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Style Inspector.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n\n# LOCALIZATION NOTE (panelTitle): This is the panel title\npanelTitle=Style Inspector\n\n# LOCALIZATION NOTE (rule.status): For each style property the panel shows\n# the rules which hold that specific property. For every rule, the rule status\n# is also displayed: a rule can be the best match, a match, a parent match, or a\n# rule did not match the element the user has highlighted.\nrule.status.BEST=Best Match\nrule.status.MATCHED=Matched\nrule.status.PARENT_MATCH=Parent Match\n\n# LOCALIZATION NOTE (rule.sourceElement, rule.sourceInline): For each\n# style property the panel shows the rules which hold that specific property.\n# For every rule, the rule source is also displayed: a rule can come from a\n# file, from the same page (inline), or from the element itself (element).\nrule.sourceInline=inline\nrule.sourceElement=element\n\n# LOCALIZATION NOTE (rule.inheritedFrom): Shown for CSS rules\n# that were inherited from a parent node. Will be passed a node\n# identifier of the parent node.\n# e.g \"Inherited from body#bodyID\"\nrule.inheritedFrom=Inherited from %S\n\n# LOCALIZATION NOTE (rule.keyframe): Shown for CSS Rules keyframe header.\n# Will be passed an identifier of the keyframe animation name.\nrule.keyframe=Keyframes %S\n\n# LOCALIZATION NOTE (rule.userAgentStyles): Shown next to the style sheet\n# link for CSS rules that were loaded from a user agent style sheet.\n# These styles will not be editable, and will only be visible if the\n# devtools.inspector.showUserAgentStyles pref is true.\nrule.userAgentStyles=(user agent)\n\n# LOCALIZATION NOTE (rule.pseudoElement): Shown for CSS rules\n# pseudo element header\nrule.pseudoElement=Pseudo-elements\n\n# LOCALIZATION NOTE (rule.pseudoElement): Shown for CSS rules\n# pseudo element header\nrule.selectedElement=This Element\n\n# LOCALIZATION NOTE (helpLinkTitle): For each style property\n# the user can hover it and get a help link button which allows one to\n# quickly jump to the documentation from the Mozilla Developer Network site.\n# This is the link title shown in the hover tooltip.\nhelpLinkTitle=Read the documentation for this property\n\n# LOCALIZATION NOTE (rule.warning.title): When an invalid property value is\n# entered into the rule view a warning icon is displayed. This text is used for\n# the title attribute of the warning icon.\nrule.warning.title=Invalid property value\n\n# LOCALIZATION NOTE (rule.filterProperty.title): Text displayed in the tooltip\n# of the search button that is shown next to a property that has been overridden\n# in the rule view.\nrule.filterProperty.title=Filter rules containing this property\n\n# LOCALIZATION NOTE (ruleView.empty): Text displayed when the highlighter is\n# first opened and there's no node selected in the rule view.\nrule.empty=No element selected.\n\n# LOCALIZATION NOTE (ruleView.selectorHighlighter.tooltip): Text displayed in a\n# tooltip when the mouse is over a selector highlighter icon in the rule view.\nrule.selectorHighlighter.tooltip=Highlight all elements matching this selector\n\n# LOCALIZATION NOTE (rule.colorSwatch.tooltip): Text displayed in a tooltip\n# when the mouse is over a color swatch in the rule view.\nrule.colorSwatch.tooltip=Click to open the color picker, shift+click to change the color format\n\n# LOCALIZATION NOTE (rule.bezierSwatch.tooltip): Text displayed in a tooltip\n# when the mouse is over a cubic-bezier swatch in the rule view.\nrule.bezierSwatch.tooltip=Click to open the timing-function editor\n\n# LOCALIZATION NOTE (rule.filterSwatch.tooltip): Text displayed in a tooltip\n# when the mouse is over a filter swatch in the rule view.\nrule.filterSwatch.tooltip=Click to open the filter editor\n\n# LOCALIZATION NOTE (rule.angleSwatch.tooltip): Text displayed in a tooltip\n# when the mouse is over a angle swatch in the rule view.\nrule.angleSwatch.tooltip=Shift+click to change the angle format\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyColor): Text displayed in the rule\n# and computed view context menu when a color value was clicked.\nstyleinspector.contextmenu.copyColor=Copy Color\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyColor.accessKey): Access key for\n# the rule and computed view context menu \"Copy Color\" entry.\nstyleinspector.contextmenu.copyColor.accessKey=L\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyUrl): In rule and computed view :\n# text displayed in the context menu for an image URL.\n# Clicking it copies the URL to the clipboard of the user.\nstyleinspector.contextmenu.copyUrl=Copy URL\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyUrl.accessKey): Access key for\n# the rule and computed view context menu \"Copy URL\" entry.\nstyleinspector.contextmenu.copyUrl.accessKey=U\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyImageDataUrl): In rule and computed view :\n# text displayed in the context menu for an image URL.\n# Clicking it copies the image as Data-URL to the clipboard of the user.\nstyleinspector.contextmenu.copyImageDataUrl=Copy Image Data-URL\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyDataUri.accessKey): Access key for\n# the rule and computed view context menu \"Copy Image Data-URL\" entry.\nstyleinspector.contextmenu.copyImageDataUrl.accessKey=I\n\n# LOCALIZATION NOTE (styleinspector.copyDataUriError): Text set in the clipboard\n# if an error occurs when using the copyImageDataUrl context menu action\n# (invalid image link, timeout, etc...)\nstyleinspector.copyImageDataUrlError=Failed to copy image Data-URL\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.toggleOrigSources): Text displayed in the rule view\n# context menu.\nstyleinspector.contextmenu.toggleOrigSources=Show Original Sources\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.toggleOrigSources.accessKey): Access key for\n# the rule view context menu \"Show original sources\" entry.\nstyleinspector.contextmenu.toggleOrigSources.accessKey=O\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.showMdnDocs): Text displayed in the rule view\n# context menu to display docs from MDN for an item.\nstyleinspector.contextmenu.showMdnDocs=Show MDN Docs\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.showMdnDocs.accessKey): Access key for\n# the rule view context menu \"Show MDN docs\" entry.\nstyleinspector.contextmenu.showMdnDocs.accessKey=D\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.addNewRule): Text displayed in the\n# rule view context menu for adding a new rule to the element.\n# This should match addRuleButton.tooltip in styleinspector.dtd\nstyleinspector.contextmenu.addNewRule=Add New Rule\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.addRule.accessKey): Access key for\n# the rule view context menu \"Add rule\" entry.\nstyleinspector.contextmenu.addNewRule.accessKey=R\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.selectAll): Text displayed in the\n# computed view context menu.\nstyleinspector.contextmenu.selectAll=Select All\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.selectAll.accessKey): Access key for\n# the computed view context menu \"Select all\" entry.\nstyleinspector.contextmenu.selectAll.accessKey=A\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copy): Text displayed in the\n# computed view context menu.\nstyleinspector.contextmenu.copy=Copy\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copy.accessKey): Access key for\n# the computed view context menu \"Copy\" entry.\nstyleinspector.contextmenu.copy.accessKey=C\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyLocation): Text displayed in the\n# rule view context menu for copying the source location.\nstyleinspector.contextmenu.copyLocation=Copy Location\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyPropertyDeclaration): Text\n# displayed in the rule view context menu for copying the property declaration.\nstyleinspector.contextmenu.copyPropertyDeclaration=Copy Property Declaration\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyPropertyName): Text displayed in\n# the rule view context menu for copying the property name.\nstyleinspector.contextmenu.copyPropertyName=Copy Property Name\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyPropertyValue): Text displayed in\n# the rule view context menu for copying the property value.\nstyleinspector.contextmenu.copyPropertyValue=Copy Property Value\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyRule): Text displayed in the\n# rule view context menu for copying the rule.\nstyleinspector.contextmenu.copyRule=Copy Rule\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copySelector): Text displayed in the\n# rule view context menu for copying the selector.\nstyleinspector.contextmenu.copySelector=Copy Selector\n"

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./aboutdebugging.properties": 50,
		"./animationinspector.properties": 51,
		"./app-manager.properties": 52,
		"./appcacheutils.properties": 53,
		"./canvasdebugger.properties": 54,
		"./components.properties": 55,
		"./connection-screen.properties": 56,
		"./debugger.properties": 57,
		"./device.properties": 58,
		"./dom.properties": 59,
		"./eyedropper.properties": 60,
		"./filterwidget.properties": 61,
		"./graphs.properties": 62,
		"./har.properties": 63,
		"./inspector.properties": 64,
		"./jit-optimizations.properties": 65,
		"./jsonview.properties": 66,
		"./markers.properties": 67,
		"./memory.properties": 68,
		"./menus.properties": 69,
		"./netmonitor.properties": 70,
		"./performance.properties": 71,
		"./projecteditor.properties": 72,
		"./promisedebugger.properties": 73,
		"./responsive.properties": 74,
		"./responsiveUI.properties": 75,
		"./scratchpad.properties": 76,
		"./shadereditor.properties": 77,
		"./shared.properties": 78,
		"./sourceeditor.properties": 79,
		"./startup.properties": 80,
		"./storage.properties": 81,
		"./styleeditor.properties": 82,
		"./toolbox.properties": 83,
		"./webaudioeditor.properties": 84,
		"./webconsole.properties": 85,
		"./webide.properties": 86
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 49;


/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (debug):\n# This string is displayed as a label of the button that starts\n# debugging a service worker.\ndebug = Debug\n\n# LOCALIZATION NOTE (push):\n# This string is displayed as a label of the button that pushes a test payload\n# to a service worker.\npush = Push\n\n# LOCALIZATION NOTE (start):\n# This string is displayed as a label of the button that starts a service worker.\nstart = Start\n\nscope = Scope\nunregister = unregister\n\npushService = Push Service\n\n# LOCALIZATION NOTE (addons):\n# This string is displayed as a header of the about:debugging#addons page.\naddons = Add-ons\n\n# LOCALIZATION NOTE (addonDebugging.label):\n# This string is displayed next to a check box that enables the user to switch\n# addon debugging on/off.\naddonDebugging.label = Enable add-on debugging\n\n# LOCALIZATION NOTE (addonDebugging.tooltip):\n# This string is displayed in a tooltip that appears when hovering over a check\n# box that switches addon debugging on/off.\naddonDebugging.tooltip = Turning this on will allow you to debug add-ons and various other parts of the browser chrome\n\n# LOCALIZATION NOTE (moreInfo):\n# This string is displayed next to addonDebugging.label as a link to a page\n# with documentation.\nmoreInfo = more info\n\n# LOCALIZATION NOTE (loadTemporaryAddon):\n# This string is displayed as a label of a button that allows the user to\n# load additional add-ons.\nloadTemporaryAddon = Load Temporary Add-on\n\n# LOCALIZATION NOTE (extensions):\n# This string is displayed as a header above the list of loaded add-ons.\nextensions = Extensions\n\n# LOCALIZATION NOTE (selectAddonFromFile2):\n# This string is displayed as the title of the file picker that appears when\n# the user clicks the 'Load Temporary Add-on' button\nselectAddonFromFile2 = Select Manifest File or Package (.xpi)\n\n# LOCALIZATION NOTE (reload):\n# This string is displayed as a label of the button that reloads a given addon.\nreload = Reload\n\n# LOCALIZATION NOTE (reloadDisabledTooltip):\n# This string is displayed in a tooltip that appears when hovering over a\n# disabled 'reload' button.\nreloadDisabledTooltip = Only temporarily installed add-ons can be reloaded\n\n# LOCALIZATION NOTE (workers):\n# This string is displayed as a header of the about:debugging#workers page.\nworkers = Workers\n\nserviceWorkers = Service Workers\nsharedWorkers = Shared Workers\notherWorkers = Other Workers\n\n# LOCALIZATION NOTE (tabs):\n# This string is displayed as a header of the about:debugging#tabs page.\ntabs = Tabs\n\n# LOCALIZATION NOTE (pageNotFound):\n# This string is displayed as the main message at any error/invalid page.\npageNotFound = Page not found\n\n# LOCALIZATION NOTE (doesNotExist):\n# This string is displayed as an error message when navigating to an invalid page\n# %S will be replaced by the name of the page at run-time.\ndoesNotExist = #%S does not exist!\n\n# LOCALIZATION NOTE (nothing):\n# This string is displayed when the list of workers is empty.\nnothing = Nothing yet.\n\nconfigurationIsNotCompatible = Your browser configuration is not compatible with Service Workers\n"

/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Animation inspector\n# which is available as a sidebar panel in the Inspector.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (panel.invalidElementSelected):\n# This is the label shown in the panel when an invalid node is currently\n# selected in the inspector (i.e. a non-element node or a node that is not\n# animated).\npanel.invalidElementSelected=No animations were found for the current element.\n\n# LOCALIZATION NOTE (panel.selectElement): This is the label shown in the panel\n# when an invalid node is currently selected in the inspector, to invite the\n# user to select a new node by clicking on the element-picker icon.\npanel.selectElement=Pick another element from the page.\n\n# LOCALIZATION NOTE (panel.allAnimations): This is the label shown at the bottom of\n# the panel, in a toolbar, to let the user know the toolbar applies to all\n# animations, not just the ones applying to the current element.\npanel.allAnimations=All animations\n\n# LOCALIZATION NOTE (player.animationDurationLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the animation duration.\nplayer.animationDurationLabel=Duration:\n\n# LOCALIZATION NOTE (player.animationDelayLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the animation delay.\nplayer.animationDelayLabel=Delay:\n\n# LOCALIZATION NOTE (player.animationEndDelayLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the animation endDelay.\nplayer.animationEndDelayLabel=End delay:\n\n# LOCALIZATION NOTE (player.animationRateLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the animation playback rate.\nplayer.animationRateLabel=Playback rate:\n\n# LOCALIZATION NOTE (player.animationIterationCountLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the number of times the animation is set to repeat.\nplayer.animationIterationCountLabel=Repeats:\n\n# LOCALIZATION NOTE (player.infiniteIterationCount):\n# In case the animation repeats infinitely, this string is displayed next to the\n# player.animationIterationCountLabel string, instead of a number.\nplayer.infiniteIterationCount=&#8734;\n\n# LOCALIZATION NOTE (player.infiniteIterationCountText):\n# See player.infiniteIterationCount for a description of what this is.\n# Unlike player.infiniteIterationCount, this string isn't used in HTML, but in\n# a tooltip.\nplayer.infiniteIterationCountText=∞\n\n# LOCALIZATION NOTE (player.animationIterationStartLabel):\n# This string is displayed in a tooltip that appears when hovering over\n# animations in the timeline. It is the label displayed before the animation\n# iterationStart value.\n# %1$S will be replaced by the original iteration start value\n# %2$S will be replaced by the actual time of iteration start\nplayer.animationIterationStartLabel=Iteration start: %1$S (%2$Ss)\n\n# LOCALIZATION NOTE (player.timeLabel):\n# This string is displayed in each animation player widget, to indicate either\n# how long (in seconds) the animation lasts, or what is the animation's current\n# time (in seconds too);\nplayer.timeLabel=%Ss\n\n# LOCALIZATION NOTE (player.playbackRateLabel):\n# This string is displayed in each animation player widget, as the label of\n# drop-down list items that can be used to change the rate at which the\n# animation runs (1× being the default, 2× being twice as fast).\nplayer.playbackRateLabel=%S×\n\n# LOCALIZATION NOTE (player.runningOnCompositorTooltip):\n# This string is displayed as a tooltip for the icon that indicates that the\n# animation is running on the compositor thread.\nplayer.runningOnCompositorTooltip=This animation is running on compositor thread\n\n# LOCALIZATION NOTE (player.allPropertiesOnCompositorTooltip):\n# This string is displayed as a tooltip for the icon that indicates that\n# all of animation is running on the compositor thread.\nplayer.allPropertiesOnCompositorTooltip=All animation properties are optimized\n\n# LOCALIZATION NOTE (player.somePropertiesOnCompositorTooltip):\n# This string is displayed as a tooltip for the icon that indicates that\n# all of animation is not running on the compositor thread.\nplayer.somePropertiesOnCompositorTooltip=Some animation properties are optimized\n\n# LOCALIZATION NOTE (timeline.rateSelectorTooltip):\n# This string is displayed in the timeline toolbar, as the tooltip of the\n# drop-down list that can be used to change the rate at which the animations\n# run.\ntimeline.rateSelectorTooltip=Set the animations playback rates\n\n# LOCALIZATION NOTE (timeline.pauseResumeButtonTooltip):\n# This string is displayed in the timeline toolbar, as the tooltip of the\n# pause/resume button that can be used to pause or resume the animations\ntimeline.pausedButtonTooltip=Resume the animations\n\n# LOCALIZATION NOTE (timeline.pauseResumeButtonTooltip):\n# This string is displayed in the timeline toolbar, as the tooltip of the\n# pause/resume button that can be used to pause or resume the animations\ntimeline.resumedButtonTooltip=Pause the animations\n\n# LOCALIZATION NOTE (timeline.rewindButtonTooltip):\n# This string is displayed in the timeline toolbar, as the tooltip of the\n# rewind button that can be used to rewind the animations\ntimeline.rewindButtonTooltip=Rewind the animations\n\n# LOCALIZATION NOTE (timeline.timeGraduationLabel):\n# This string is displayed at the top of the animation panel, next to each time\n# graduation, to indicate what duration (in milliseconds) this graduation\n# corresponds to.\ntimeline.timeGraduationLabel=%Sms\n\n# LOCALIZATION NOTE (timeline.cssanimation.nameLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over the name of a CSS Animation in the timeline UI.\n# %S will be replaced by the name of the animation at run-time.\ntimeline.cssanimation.nameLabel=%S - CSS Animation\n\n# LOCALIZATION NOTE (timeline.csstransition.nameLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over the name of a CSS Transition in the timeline UI.\n# %S will be replaced by the name of the transition at run-time.\ntimeline.csstransition.nameLabel=%S - CSS Transition\n\n# LOCALIZATION NOTE (timeline.scriptanimation.nameLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over the name of a script-generated animation in the timeline UI.\n# %S will be replaced by the name of the animation at run-time.\ntimeline.scriptanimation.nameLabel=%S - Script Animation\n\n# LOCALIZATION NOTE (timeline.scriptanimation.unnamedLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over an unnamed script-generated animation in the timeline UI.\ntimeline.scriptanimation.unnamedLabel=Script Animation\n\n# LOCALIZATION NOTE (timeline.unknown.nameLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over the name of an unknown animation type in the timeline UI.\n# This can happen if devtools couldn't figure out the type of the animation.\n# %S will be replaced by the name of the transition at run-time.\ntimeline.unknown.nameLabel=%S\n"

/***/ },
/* 52 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nvalidator.nonExistingFolder=The project folder doesn’t exist\nvalidator.expectProjectFolder=The project folder ends up being a file\nvalidator.noManifestFile=A manifest file is required at project root folder, named either ‘manifest.webapp’ for packaged apps or ‘manifest.json’ for add-ons.\nvalidator.invalidManifestURL=Invalid manifest URL ‘%S’\n# LOCALIZATION NOTE (validator.invalidManifestJSON, validator.noAccessManifestURL):\n# %1$S is the error message, %2$S is the URI of the manifest.\nvalidator.invalidManifestJSON=The webapp manifest isn’t a valid JSON file: %1$S at: %2$S\nvalidator.noAccessManifestURL=Unable to read manifest file: %1$S at: %2$S\n# LOCALIZATION NOTE (validator.invalidHostedManifestURL): %1$S is the URI of\n# the manifest, %2$S is the error message.\nvalidator.invalidHostedManifestURL=Invalid hosted manifest URL ‘%1$S’: %2$S\nvalidator.invalidProjectType=Unknown project type ‘%S’\n# LOCALIZATION NOTE (validator.missNameManifestProperty, validator.missIconsManifestProperty):\n# don't translate 'icons' and 'name'.\nvalidator.missNameManifestProperty=Missing mandatory ‘name’ in Manifest.\nvalidator.missIconsManifestProperty=Missing ‘icons’ in Manifest.\nvalidator.missIconMarketplace2=app submission to the Marketplace requires a 128px icon\nvalidator.invalidAppType=Unknown app type: ‘%S’.\nvalidator.invalidHostedPriviledges=Hosted App can’t be type ‘%S’.\nvalidator.noCertifiedSupport=‘certified’ apps are not fully supported on the App manager.\nvalidator.nonAbsoluteLaunchPath=Launch path has to be an absolute path starting with ‘/’: ‘%S’\nvalidator.accessFailedLaunchPath=Unable to access the app starting document ‘%S’\n# LOCALIZATION NOTE (validator.accessFailedLaunchPathBadHttpCode): %1$S is the URI of\n# the launch document, %2$S is the http error code.\nvalidator.accessFailedLaunchPathBadHttpCode=Unable to access the app starting document ‘%1$S’, got HTTP code %2$S\n"

/***/ },
/* 53 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Web Console\n# command line which is available from the Web Developer sub-menu\n# -> 'Web Console'.\n# These messages are displayed when an attempt is made to validate a\n# page or a cache manifest using AppCacheUtils.jsm\n\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (noManifest): the specified page has no cache manifest.\nnoManifest=The specified page has no manifest.\n\n# LOCALIZATION NOTE (notUTF8): the associated cache manifest has a character\n# encoding that is not UTF-8. Parameters: %S is the current encoding.\nnotUTF8=Manifest has a character encoding of %S. Manifests must have the utf-8 character encoding.\n\n# LOCALIZATION NOTE (badMimeType): the associated cache manifest has a\n# mimetype that is not text/cache-manifest. Parameters: %S is the current\n# mimetype.\nbadMimeType=Manifest has a mimetype of %S. Manifests must have a mimetype of text/cache-manifest.\n\n# LOCALIZATION NOTE (duplicateURI): the associated cache manifest references\n# the same URI from multiple locations. Parameters: %1$S is the URI, %2$S is a\n# list of references to this URI.\nduplicateURI=URI %1$S is referenced in multiple locations. This is not allowed: %2$S.\n\n# LOCALIZATION NOTE (networkBlocksURI, fallbackBlocksURI): the associated\n# cache manifest references the same URI in the NETWORK (or FALLBACK) section\n# as it does in other sections. Parameters: %1$S is the line number, %2$S is\n# the resource name, %3$S is the line number, %4$S is the resource name, %5$S\n# is the section name.\nnetworkBlocksURI=NETWORK section line %1$S (%2$S) prevents caching of line %3$S (%4$S) in the %5$S section.\nfallbackBlocksURI=FALLBACK section line %1$S (%2$S) prevents caching of line %3$S (%4$S) in the %5$S section.\n\n# LOCALIZATION NOTE (fileChangedButNotManifest): the associated cache manifest\n# references a URI that has a file modified after the cache manifest.\n# Parameters: %1$S is the resource name, %2$S is the cache manifest, %3$S is\n# the line number.\nfileChangedButNotManifest=The file %1$S was modified after %2$S. Unless the text in the manifest file is changed the cached version will be used instead at line %3$S.\n\n# LOCALIZATION NOTE (cacheControlNoStore): the specified page has a header\n# preventing caching or storing information. Parameters: %1$S is the resource\n# name, %2$S is the line number.\ncacheControlNoStore=%1$S has cache-control set to no-store. This will prevent the application cache from storing the file at line %2$S.\n\n# LOCALIZATION NOTE (notAvailable): the specified resource is not available.\n# Parameters: %1$S is the resource name, %2$S is the line number.\nnotAvailable=%1$S points to a resource that is not available at line %2$S.\n\n# LOCALIZATION NOTE (invalidURI): it's used when an invalid URI is passed to\n# the appcache.\ninvalidURI=The URI passed to AppCacheUtils is invalid.\n\n# LOCALIZATION NOTE (noResults): it's used when a search returns no results.\nnoResults=Your search returned no results.\n\n# LOCALIZATION NOTE (cacheDisabled): it's used when the cache is disabled and\n# an attempt is made to view offline data.\ncacheDisabled=Your disk cache is disabled. Please set browser.cache.disk.enable to true in about:config and try again.\n\n# LOCALIZATION NOTE (firstLineMustBeCacheManifest): the associated cache\n# manifest has a first line that is not \"CACHE MANIFEST\". Parameters: %S is\n# the line number.\nfirstLineMustBeCacheManifest=The first line of the manifest must be “CACHE MANIFEST” at line %S.\n\n# LOCALIZATION NOTE (cacheManifestOnlyFirstLine2): the associated cache\n# manifest has \"CACHE MANIFEST\" on a line other than the first line.\n# Parameters: %S is the line number where \"CACHE MANIFEST\" appears.\ncacheManifestOnlyFirstLine2=“CACHE MANIFEST” is only valid on the first line but was found at line %S.\n\n# LOCALIZATION NOTE (asteriskInWrongSection2): the associated cache manifest\n# has an asterisk (*) in a section other than the NETWORK section. Parameters:\n# %1$S is the section name, %2$S is the line number.\nasteriskInWrongSection2=Asterisk (*) incorrectly used in the %1$S section at line %2$S. If a line in the NETWORK section contains only a single asterisk character, then any URI not listed in the manifest will be treated as if the URI was listed in the NETWORK section. Otherwise such URIs will be treated as unavailable. Other uses of the * character are prohibited.\n\n# LOCALIZATION NOTE (escapeSpaces): the associated cache manifest has a space\n# in a URI. Spaces must be replaced with %20. Parameters: %S is the line\n# number where this error occurs.\nescapeSpaces=Spaces in URIs need to be replaced with %20 at line %S.\n\n# LOCALIZATION NOTE (slashDotDotSlashBad): the associated cache manifest has a\n# URI containing /../, which is invalid. Parameters: %S is the line number\n# where this error occurs.\nslashDotDotSlashBad=/../ is not a valid URI prefix at line %S.\n\n# LOCALIZATION NOTE (tooManyDotDotSlashes): the associated cache manifest has\n# a URI containing too many ../ operators. Too many of these operators mean\n# that the file would be below the root of the site, which is not possible.\n# Parameters: %S is the line number where this error occurs.\ntooManyDotDotSlashes=Too many dot dot slash operators (../) at line %S.\n\n# LOCALIZATION NOTE (fallbackUseSpaces): the associated cache manifest has a\n# FALLBACK section containing more or less than the standard two URIs\n# separated by a single space. Parameters: %S is the line number where this\n# error occurs.\nfallbackUseSpaces=Only two URIs separated by spaces are allowed in the FALLBACK section at line %S.\n\n# LOCALIZATION NOTE (fallbackAsterisk2): the associated cache manifest has a\n# FALLBACK section that attempts to use an asterisk (*) as a wildcard. In this\n# section the URI is simply a path prefix. Parameters: %S is the line number\n# where this error occurs.\nfallbackAsterisk2=Asterisk (*) incorrectly used in the FALLBACK section at line %S. URIs in the FALLBACK section simply need to match a prefix of the request URI.\n\n# LOCALIZATION NOTE (settingsBadValue): the associated cache manifest has a\n# SETTINGS section containing something other than the valid \"prefer-online\"\n# or \"fast\". Parameters: %S is the line number where this error occurs.\nsettingsBadValue=The SETTINGS section may only contain a single value, “prefer-online” or “fast” at line %S.\n\n# LOCALIZATION NOTE (invalidSectionName): the associated cache manifest\n# contains an invalid section name. Parameters: %1$S is the section name, %2$S\n# is the line number.\ninvalidSectionName=Invalid section name (%1$S) at line %2$S.\n"

/***/ },
/* 54 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Canvas Debugger\n# which is available from the Web Developer sub-menu -> 'Canvas'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (noSnapshotsText): The text to display in the snapshots menu\n# when there are no recorded snapshots yet.\nnoSnapshotsText=There are no snapshots yet.\n\n# LOCALIZATION NOTE (snapshotsList.itemLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# identifying a set of function calls of a recorded animation frame.\nsnapshotsList.itemLabel=Snapshot #%S\n\n# LOCALIZATION NOTE (snapshotsList.loadingLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# for an item that has not finished loading.\nsnapshotsList.loadingLabel=Loading…\n\n# LOCALIZATION NOTE (snapshotsList.saveLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# for saving an item to disk.\nsnapshotsList.saveLabel=Save\n\n# LOCALIZATION NOTE (snapshotsList.savingLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# while saving an item to disk.\nsnapshotsList.savingLabel=Saving…\n\n# LOCALIZATION NOTE (snapshotsList.loadedLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# for an item which was loaded from disk\nsnapshotsList.loadedLabel=Loaded from disk\n\n# LOCALIZATION NOTE (snapshotsList.saveDialogTitle):\n# This string is displayed as a title for saving a snapshot to disk.\nsnapshotsList.saveDialogTitle=Save animation frame snapshot…\n\n# LOCALIZATION NOTE (snapshotsList.saveDialogJSONFilter):\n# This string is displayed as a filter for saving a snapshot to disk.\nsnapshotsList.saveDialogJSONFilter=JSON Files\n\n# LOCALIZATION NOTE (snapshotsList.saveDialogAllFilter):\n# This string is displayed as a filter for saving a snapshot to disk.\nsnapshotsList.saveDialogAllFilter=All Files\n\n# LOCALIZATION NOTE (snapshotsList.drawCallsLabel):\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# as a generic description about how many draw calls were made.\nsnapshotsList.drawCallsLabel=#1 draw;#1 draws\n\n# LOCALIZATION NOTE (snapshotsList.functionCallsLabel):\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# as a generic description about how many function calls were made in total.\nsnapshotsList.functionCallsLabel=#1 call;#1 calls\n\n# LOCALIZATION NOTE (recordingTimeoutFailure):\n# This notification alert is displayed when attempting to record a requestAnimationFrame\n# cycle in the Canvas Debugger and no cycles detected. This alerts the user that no\n# loops were found.\nrecordingTimeoutFailure=Canvas Debugger could not find a requestAnimationFrame or setTimeout cycle.\n"

/***/ },
/* 55 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the shared React components,\n# so files in `devtools/client/shared/components/*`.\n\n# LOCALIZATION NOTE (frame.unknownSource): When we do not know the source filename of\n# a frame, we use this string instead.\nframe.unknownSource=(unknown)\n\n# LOCALIZATION NOTE (viewsourceindebugger): The label for the tooltip when hovering over\n# a source link that links to the debugger.\n# %S represents the URL to match in the debugger.\nframe.viewsourceindebugger=View source in Debugger → %S\n\n# LOCALIZATION NOTE (notificationBox.closeTooltip): The content of a tooltip that\n# appears when hovering over the close button in a notification box.\nnotificationBox.closeTooltip=Close this message\n"

/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE : FILE This file contains the Remote Connection strings.\n# The Remote Connection window can reached from the \"connect…\" menuitem\n# in the Web Developer menu.\n\nmainProcess=Main Process\n"

/***/ },
/* 57 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Debugger\n# which is available from the Web Developer sub-menu -> 'Debugger'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (collapsePanes): This is the tooltip for the button\n# that collapses the left and right panes in the debugger UI.\ncollapsePanes=Collapse panes\n\n# LOCALIZATION NOTE (expandPanes): This is the tooltip for the button\n# that expands the left and right panes in the debugger UI.\nexpandPanes=Expand panes\n\n# LOCALIZATION NOTE (pauseButtonTooltip): The tooltip that is displayed for the pause\n# button when the debugger is in a running state.\npauseButtonTooltip=Click to pause (%S)\n\n# LOCALIZATION NOTE (pausePendingButtonTooltip): The tooltip that is displayed for\n# the pause button after it's been clicked but before the next JavaScript to run.\npausePendingButtonTooltip=Waiting for next execution\n\n# LOCALIZATION NOTE (resumeButtonTooltip): The label that is displayed on the pause\n# button when the debugger is in a paused state.\nresumeButtonTooltip=Click to resume (%S)\n\n# LOCALIZATION NOTE (stepOverTooltip): The label that is displayed on the\n# button that steps over a function call.\nstepOverTooltip=Step Over (%S)\n\n# LOCALIZATION NOTE (stepInTooltip): The label that is displayed on the\n# button that steps into a function call.\nstepInTooltip=Step In (%S)\n\n# LOCALIZATION NOTE (stepOutTooltip): The label that is displayed on the\n# button that steps out of a function call.\nstepOutTooltip=Step Out (%S)\n\n# LOCALIZATION NOTE (noWorkersText): The text to display in the workers list\n# when there are no workers.\nnoWorkersText=This page has no workers.\n\n# LOCALIZATION NOTE (noSourcesText): The text to display in the sources list\n# when there are no sources.\nnoSourcesText=This page has no sources.\n\n# LOCALIZATION NOTE (noEventListenersText): The text to display in the events tab\n# when there are no events.\nnoEventListenersText=No event listeners to display\n\n# LOCALIZATION NOTE (noStackFramesText): The text to display in the call stack tab\n# when there are no stack frames.\nnoStackFramesText=No stack frames to display\n\n# LOCALIZATION NOTE (eventCheckboxTooltip): The tooltip text to display when\n# the user hovers over the checkbox used to toggle an event breakpoint.\neventCheckboxTooltip=Toggle breaking on this event\n\n# LOCALIZATION NOTE (eventOnSelector): The text to display in the events tab\n# for every event item, between the event type and event selector.\neventOnSelector=on\n\n# LOCALIZATION NOTE (eventInSource): The text to display in the events tab\n# for every event item, between the event selector and listener's owner source.\neventInSource=in\n\n# LOCALIZATION NOTE (eventNodes): The text to display in the events tab when\n# an event is listened on more than one target node.\neventNodes=%S nodes\n\n# LOCALIZATION NOTE (eventNative): The text to display in the events tab when\n# a listener is added from plugins, thus getting translated to native code.\neventNative=[native code]\n\n# LOCALIZATION NOTE (*Events): The text to display in the events tab for\n# each group of sub-level event entries.\nanimationEvents=Animation\naudioEvents=Audio\nbatteryEvents=Battery\nclipboardEvents=Clipboard\ncompositionEvents=Composition\ndeviceEvents=Device\ndisplayEvents=Display\ndragAndDropEvents=Drag and Drop\ngamepadEvents=Gamepad\nindexedDBEvents=IndexedDB\ninteractionEvents=Interaction\nkeyboardEvents=Keyboard\nmediaEvents=HTML5 Media\nmouseEvents=Mouse\nmutationEvents=Mutation\nnavigationEvents=Navigation\npointerLockEvents=Pointer Lock\nsensorEvents=Sensor\nstorageEvents=Storage\ntimeEvents=Time\ntouchEvents=Touch\notherEvents=Other\n\n# LOCALIZATION NOTE (blackBoxCheckboxTooltip): The tooltip text to display when\n# the user hovers over the checkbox used to toggle black boxing its associated\n# source.\nblackBoxCheckboxTooltip=Toggle black boxing\n\n# LOCALIZATION NOTE (noMatchingStringsText): The text to display in the\n# global search results when there are no matching strings after filtering.\nnoMatchingStringsText=No matches found\n\n# LOCALIZATION NOTE (emptySearchText): This is the text that appears in the\n# filter text box when it is empty and the scripts container is selected.\nemptySearchText=Search scripts (%S)\n\n# LOCALIZATION NOTE (emptyVariablesFilterText): This is the text that\n# appears in the filter text box for the variables view container.\nemptyVariablesFilterText=Filter variables\n\n# LOCALIZATION NOTE (emptyPropertiesFilterText): This is the text that\n# appears in the filter text box for the editor's variables view bubble.\nemptyPropertiesFilterText=Filter properties\n\n# LOCALIZATION NOTE (searchPanelFilter): This is the text that appears in the\n# filter panel popup for the filter scripts operation.\nsearchPanelFilter=Filter scripts (%S)\n\n# LOCALIZATION NOTE (searchPanelGlobal): This is the text that appears in the\n# filter panel popup for the global search operation.\nsearchPanelGlobal=Search in all files (%S)\n\n# LOCALIZATION NOTE (searchPanelFunction): This is the text that appears in the\n# filter panel popup for the function search operation.\nsearchPanelFunction=Search for function definition (%S)\n\n# LOCALIZATION NOTE (searchPanelToken): This is the text that appears in the\n# filter panel popup for the token search operation.\nsearchPanelToken=Find in this file (%S)\n\n# LOCALIZATION NOTE (searchPanelGoToLine): This is the text that appears in the\n# filter panel popup for the line search operation.\nsearchPanelGoToLine=Go to line (%S)\n\n# LOCALIZATION NOTE (searchPanelVariable): This is the text that appears in the\n# filter panel popup for the variables search operation.\nsearchPanelVariable=Filter variables (%S)\n\n# LOCALIZATION NOTE (breakpointMenuItem): The text for all the elements that\n# are displayed in the breakpoints menu item popup.\nbreakpointMenuItem.setConditional=Configure conditional breakpoint\nbreakpointMenuItem.enableSelf=Enable breakpoint\nbreakpointMenuItem.disableSelf=Disable breakpoint\nbreakpointMenuItem.deleteSelf=Remove breakpoint\nbreakpointMenuItem.enableOthers=Enable others\nbreakpointMenuItem.disableOthers=Disable others\nbreakpointMenuItem.deleteOthers=Remove others\nbreakpointMenuItem.enableAll=Enable all breakpoints\nbreakpointMenuItem.disableAll=Disable all breakpoints\nbreakpointMenuItem.deleteAll=Remove all breakpoints\n\n# LOCALIZATION NOTE (loadingText): The text that is displayed in the script\n# editor when the loading process has started but there is no file to display\n# yet.\nloadingText=Loading\\u2026\n\n# LOCALIZATION NOTE (errorLoadingText2): The text that is displayed in the debugger\n# viewer when there is an error loading a file\nerrorLoadingText2=Error loading this URL: %S\n\n# LOCALIZATION NOTE (addWatchExpressionText): The text that is displayed in the\n# watch expressions list to add a new item.\naddWatchExpressionText=Add watch expression\n\n# LOCALIZATION NOTE (addWatchExpressionButton): The button that is displayed in the\n# variables view popup.\naddWatchExpressionButton=Watch\n\n# LOCALIZATION NOTE (emptyVariablesText): The text that is displayed in the\n# variables pane when there are no variables to display.\nemptyVariablesText=No variables to display\n\n# LOCALIZATION NOTE (scopeLabel): The text that is displayed in the variables\n# pane as a header for each variable scope (e.g. \"Global scope, \"With scope\",\n# etc.).\nscopeLabel=%S scope\n\n# LOCALIZATION NOTE (watchExpressionsScopeLabel): The name of the watch\n# expressions scope. This text is displayed in the variables pane as a header for\n# the watch expressions scope.\nwatchExpressionsScopeLabel=Watch expressions\n\n# LOCALIZATION NOTE (globalScopeLabel): The name of the global scope. This text\n# is added to scopeLabel and displayed in the variables pane as a header for\n# the global scope.\nglobalScopeLabel=Global\n\n# LOCALIZATION NOTE (variablesViewErrorStacktrace): This is the text that is\n# shown before the stack trace in an error.\nvariablesViewErrorStacktrace=Stack trace:\n\n# LOCALIZATION NOTE (variablesViewMoreObjects): the text that is displayed\n# when you have an object preview that does not show all of the elements. At the end of the list\n# you see \"N more...\" in the web console output.\n# This is a semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of remaining items in the object\n# example: 3 more…\nvariablesViewMoreObjects=#1 more…;#1 more…\n\n# LOCALIZATION NOTE (variablesEditableNameTooltip): The text that is displayed\n# in the variables list on an item with an editable name.\nvariablesEditableNameTooltip=Double click to edit\n\n# LOCALIZATION NOTE (variablesEditableValueTooltip): The text that is displayed\n# in the variables list on an item with an editable value.\nvariablesEditableValueTooltip=Click to change value\n\n# LOCALIZATION NOTE (variablesCloseButtonTooltip): The text that is displayed\n# in the variables list on an item which can be removed.\nvariablesCloseButtonTooltip=Click to remove\n\n# LOCALIZATION NOTE (variablesEditButtonTooltip): The text that is displayed\n# in the variables list on a getter or setter which can be edited.\nvariablesEditButtonTooltip=Click to set value\n\n# LOCALIZATION NOTE (variablesEditableValueTooltip): The text that is displayed\n# in a tooltip on the \"open in inspector\" button in the the variables list for a\n# DOMNode item.\nvariablesDomNodeValueTooltip=Click to select the node in the inspector\n\n# LOCALIZATION NOTE (configurable|...|Tooltip): The text that is displayed\n# in the variables list on certain variables or properties as tooltips.\n# Expanations of what these represent can be found at the following links:\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n# It's probably best to keep these in English.\nconfigurableTooltip=configurable\nenumerableTooltip=enumerable\nwritableTooltip=writable\nfrozenTooltip=frozen\nsealedTooltip=sealed\nextensibleTooltip=extensible\noverriddenTooltip=overridden\nWebIDLTooltip=WebIDL\n\n# LOCALIZATION NOTE (variablesSeparatorLabel): The text that is displayed\n# in the variables list as a separator between the name and value.\nvariablesSeparatorLabel=:\n\n# LOCALIZATION NOTE (watchExpressionsSeparatorLabel2): The text that is displayed\n# in the watch expressions list as a separator between the code and evaluation.\nwatchExpressionsSeparatorLabel2=\\u0020→\n\n# LOCALIZATION NOTE (functionSearchSeparatorLabel): The text that is displayed\n# in the functions search panel as a separator between function's inferred name\n# and its real name (if available).\nfunctionSearchSeparatorLabel=←\n\n# LOCALIZATION NOTE (resumptionOrderPanelTitle): This is the text that appears\n# as a description in the notification panel popup, when multiple debuggers are\n# open in separate tabs and the user tries to resume them in the wrong order.\n# The substitution parameter is the URL of the last paused window that must be\n# resumed first.\nresumptionOrderPanelTitle=There are one or more paused debuggers. Please resume the most-recently paused debugger first at: %S\n\nvariablesViewOptimizedOut=(optimized away)\nvariablesViewUninitialized=(uninitialized)\nvariablesViewMissingArgs=(unavailable)\n\nanonymousSourcesLabel=Anonymous Sources\n\nexperimental=This is an experimental feature"

/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside Device Emulation developer\n# tools. The correct localization of this file might be to keep it in English,\n# or another language commonly spoken among web developers.  You want to make\n# that choice consistent across the developer tools.  A good criteria is the\n# language in which you'd find the best documentation on web development on the\n# web.\n\n# LOCALIZATION NOTE:\n# These strings are category names in a list of devices that a user can choose\n# to simulate (e.g. \"ZTE Open C\", \"VIA Vixen\", \"720p HD Television\", etc).\ndevice.phones=Phones\ndevice.tablets=Tablets\ndevice.laptops=Laptops\ndevice.televisions=TVs\ndevice.consoles=Gaming consoles\ndevice.watches=Watches\n"

/***/ },
/* 59 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the DOM panel\n# which is available from the Web Developer sub-menu -> 'DOM'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (dom.filterDOMPanel): A placeholder text used for\n# DOM panel search box.\ndom.filterDOMPanel=Filter DOM Panel\n\n# LOCALIZATION NOTE (dom.refresh): A label for Refresh button in\n# DOM panel toolbar\ndom.refresh=Refresh"

/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the Eyedropper color tool.\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE  (colorValue.copied): This text is displayed when the user selects a\n# color with the eyedropper and it's copied to the clipboard.\ncolorValue.copied=copied\n"

/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the CSS Filter Editor Widget\n# which can be found in a tooltip that appears in the Rule View when clicking\n# on a filter swatch displayed next to CSS declarations like 'filter: blur(2px)'.\n\n# LOCALIZATION NOTE (emptyFilterList):\n# This string is displayed when filter's list is empty\n# (no filter specified / all removed)\nemptyFilterList=No filter specified\n\n# LOCALIZATION NOTE (emptyPresetList):\n# This string is displayed when preset's list is empty\nemptyPresetList=You don’t have any saved presets. \\\nYou can store filter presets by choosing a name and saving them. \\\nPresets are quickly accessible and you can re-use them with ease.\n\n# LOCALIZATION NOTE (addUsingList):\n# This string is displayed under [emptyFilterList] when filter's\n# list is empty, guiding user to add a filter using the list below it\naddUsingList=Add a filter using the list below\n\n# LOCALIZATION NOTE (dropShadowPlaceholder):\n# This string is used as a placeholder for drop-shadow's input\n# in the filter list (shown when <input> is empty)\ndropShadowPlaceholder=x y radius color\n\n# LOCALIZATION NOTE (dragHandleTooltipText):\n# This string is used as a tooltip text (shown on mouse hover) on the\n# drag handles of filters which are used to re-order filters\ndragHandleTooltipText=Drag up or down to re-order filter\n\n# LOCALIZATION NOTE (labelDragTooltipText):\n# This string is used as a tooltip text (shown on mouse hover) on the\n# filters' labels which can be dragged left/right to increase/decrease\n# the filter's value (like photoshop)\nlabelDragTooltipText=Drag left or right to decrease or increase the value\n\n# LOCALIZATION NOTE (filterListSelectPlaceholder):\n# This string is used as a preview option in the list of possible filters\n# <select>\nfilterListSelectPlaceholder=Select a Filter\n\n# LOCALIZATION NOTE (addNewFilterButton):\n# This string is displayed on a button used to add new filters\naddNewFilterButton=Add\n\n# LOCALIZATION NOTE (newPresetPlaceholder):\n# This string is used as a placeholder in the list of presets which is used to\n# save a new preset\nnewPresetPlaceholder=Preset Name\n\n# LOCALIZATION NOTE (savePresetButton):\n# This string is displayed on a button used to save a new preset\nsavePresetButton=Save\n\n# LOCALIZATION NOTE(presetsToggleButton):\n# This string is used in a button which toggles the presets list\npresetsToggleButton=Presets\n"

/***/ },
/* 62 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Performance Tools\n# which is available from the Web Developer sub-menu -> 'Performance'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web. These strings\n# are specifically for marker names in the performance tool.\n\n# LOCALIZATION NOTE (graphs.label.average):\n# This string is displayed on graphs when showing an average.\ngraphs.label.average=avg\n\n# LOCALIZATION NOTE (graphs.label.minimum):\n# This string is displayed on graphs when showing a minimum.\ngraphs.label.minimum=min\n\n# LOCALIZATION NOTE (graphs.label.maximum):\n# This string is displayed on graphs when showing a maximum.\ngraphs.label.maximum=max\n"

/***/ },
/* 63 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Network Monitor\n# which is available from the Web Developer sub-menu -> 'Network Monitor'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (har.responseBodyNotIncluded): A label used within\n# HAR file explaining that HTTP response bodies are not includes\n# in exported data.\nhar.responseBodyNotIncluded=Response bodies are not included.\n\n# LOCALIZATION NOTE (har.responseBodyNotIncluded): A label used within\n# HAR file explaining that HTTP request bodies are not includes\n# in exported data.\nhar.requestBodyNotIncluded=Request bodies are not included.\n\n"

/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Inspector\n# which is available from the Web Developer sub-menu -> 'Inspect'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\nbreadcrumbs.siblings=Siblings\n\n# LOCALIZATION NOTE (debuggerPausedWarning): Used in the Inspector tool, when\n# the user switch to the inspector when the debugger is paused.\ndebuggerPausedWarning.message=Debugger is paused. Some features like mouse selection will not work.\n\n# LOCALIZATION NOTE (nodeMenu.tooltiptext)\n# This menu appears in the Infobar (on top of the highlighted node) once\n# the node is selected.\nnodeMenu.tooltiptext=Node operations\n\ninspector.panelLabel.markupView=Markup View\n\n# LOCALIZATION NOTE (markupView.more.showing)\n# When there are too many nodes to load at once, we will offer to\n# show all the nodes.\nmarkupView.more.showing=Some nodes were hidden.\n\n# LOCALIZATION NOTE (markupView.more.showAll2): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\nmarkupView.more.showAll2=Show one more node;Show all #1 nodes\n\n\n#LOCALIZATION NOTE: Used in the image preview tooltip when the image could not be loaded\npreviewTooltip.image.brokenImage=Could not load the image\n\n#LOCALIZATION NOTE: Used in the image preview tooltip when the image could not be loaded\neventsTooltip.openInDebugger=Open in Debugger\n\n# LOCALIZATION NOTE (docsTooltip.visitMDN): Shown in the tooltip that displays\n# help from MDN. This is a link to the complete MDN documentation page.\ndocsTooltip.visitMDN=Visit MDN page\n\n# LOCALIZATION NOTE (docsTooltip.visitMDN): Shown in the docs tooltip when the MDN page\n# could not be loaded (for example, because of a connectivity problem).\ndocsTooltip.loadDocsError=Could not load docs page.\n\n# LOCALIZATION NOTE (inspector.collapsePane): This is the tooltip for the button\n# that collapses the right panel (rules, computed, box-model, etc...) in the\n# inspector UI.\ninspector.collapsePane=Collapse pane\n\n# LOCALIZATION NOTE (inspector.expandPane): This is the tooltip for the button\n# that expands the right panel (rules, computed, box-model, etc...) in the\n# inspector UI.\ninspector.expandPane=Expand pane\n\n# LOCALIZATION NOTE (inspector.searchResultsCount): This is the label that\n# will show up next to the inspector search box. %1$S is the current result\n# index and %2$S is the total number of search results. For example: \"3 of 9\".\n# This won't be visible until the search box is updated in Bug 835896.\ninspector.searchResultsCount2=%1$S of %2$S\n\n# LOCALIZATION NOTE (inspector.searchResultsNone): This is the label that\n# will show up next to the inspector search box when no matches were found\n# for the given string.\n# This won't be visible until the search box is updated in Bug 835896.\ninspector.searchResultsNone=No matches\n\n# LOCALIZATION NOTE (inspector.menu.openUrlInNewTab.label): This is the label of\n# a menu item in the inspector contextual-menu that appears when the user right-\n# clicks on the attribute of a node in the inspector that is a URL, and that\n# allows to open that URL in a new tab.\ninspector.menu.openUrlInNewTab.label=Open Link in New Tab\n\n# LOCALIZATION NOTE (inspector.menu.copyUrlToClipboard.label): This is the label\n# of a menu item in the inspector contextual-menu that appears when the user\n# right-clicks on the attribute of a node in the inspector that is a URL, and\n# that allows to copy that URL in the clipboard.\ninspector.menu.copyUrlToClipboard.label=Copy Link Address\n\n# LOCALIZATION NOTE (inspector.menu.selectElement.label): This is the label of a\n# menu item in the inspector contextual-menu that appears when the user right-\n# clicks on the attribute of a node in the inspector that is the ID of another\n# element in the DOM (like with <label for=\"input-id\">), and that allows to\n# select that element in the inspector.\ninspector.menu.selectElement.label=Select Element #%S\n\n# LOCALIZATION NOTE (inspectorEditAttribute.label): This is the label of a\n# sub-menu \"Attribute\" in the inspector contextual-menu that appears\n# when the user right-clicks on the node in the inspector, and that allows\n# to edit an attribute on this node.\ninspectorEditAttribute.label=Edit Attribute %S\ninspectorEditAttribute.accesskey=E\n\n# LOCALIZATION NOTE (inspectorRemoveAttribute.label): This is the label of a\n# sub-menu \"Attribute\" in the inspector contextual-menu that appears\n# when the user right-clicks on the attribute of a node in the inspector,\n# and that allows to remove this attribute.\ninspectorRemoveAttribute.label=Remove Attribute %S\ninspectorRemoveAttribute.accesskey=R\n\n# LOCALIZATION NOTE (inspector.nodePreview.selectNodeLabel):\n# This string is displayed in a tooltip that is shown when hovering over a DOM\n# node preview (e.g. something like \"div#foo.bar\").\n# DOM node previews can be displayed in places like the animation-inspector, the\n# console or the object inspector.\n# The tooltip invites the user to click on the node in order to select it in the\n# inspector panel.\ninspector.nodePreview.selectNodeLabel=Click to select this node in the Inspector\n\n# LOCALIZATION NOTE (inspector.nodePreview.highlightNodeLabel):\n# This string is displayed in a tooltip that is shown when hovering over a the\n# inspector icon displayed next to a DOM node preview (e.g. next to something\n# like \"div#foo.bar\").\n# DOM node previews can be displayed in places like the animation-inspector, the\n# console or the object inspector.\n# The tooltip invites the user to click on the icon in order to highlight the\n# node in the page.\ninspector.nodePreview.highlightNodeLabel=Click to highlight this node in the page\n\n# LOCALIZATION NOTE (inspectorHTMLEdit.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users edit the\n# (outer) HTML of the current node\ninspectorHTMLEdit.label=Edit As HTML\ninspectorHTMLEdit.accesskey=E\n\n# LOCALIZATION NOTE (inspectorCopyInnerHTML.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users copy the\n# inner HTML of the current node\ninspectorCopyInnerHTML.label=Inner HTML\ninspectorCopyInnerHTML.accesskey=I\n\n# LOCALIZATION NOTE (inspectorCopyOuterHTML.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users copy the\n# outer HTML of the current node\ninspectorCopyOuterHTML.label=Outer HTML\ninspectorCopyOuterHTML.accesskey=O\n\n# LOCALIZATION NOTE (inspectorCopyCSSSelector.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users copy\n# the CSS Selector of the current node\ninspectorCopyCSSSelector.label=CSS Selector\ninspectorCopyCSSSelector.accesskey=S\n\n# LOCALIZATION NOTE (inspectorPasteOuterHTML.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users paste outer\n# HTML in the current node\ninspectorPasteOuterHTML.label=Outer HTML\ninspectorPasteOuterHTML.accesskey=O\n\n# LOCALIZATION NOTE (inspectorPasteInnerHTML.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users paste inner\n# HTML in the current node\ninspectorPasteInnerHTML.label=Inner HTML\ninspectorPasteInnerHTML.accesskey=I\n\n# LOCALIZATION NOTE (inspectorHTMLPasteBefore.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users paste\n# the HTML before the current node\ninspectorHTMLPasteBefore.label=Before\ninspectorHTMLPasteBefore.accesskey=B\n\n# LOCALIZATION NOTE (inspectorHTMLPasteAfter.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users paste\n# the HTML after the current node\ninspectorHTMLPasteAfter.label=After\ninspectorHTMLPasteAfter.accesskey=A\n\n# LOCALIZATION NOTE (inspectorHTMLPasteFirstChild.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users paste\n# the HTML as the first child the current node\ninspectorHTMLPasteFirstChild.label=As First Child\ninspectorHTMLPasteFirstChild.accesskey=F\n\n# LOCALIZATION NOTE (inspectorHTMLPasteLastChild.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users paste\n# the HTML as the last child the current node\ninspectorHTMLPasteLastChild.label=As Last Child\ninspectorHTMLPasteLastChild.accesskey=L\n\n# LOCALIZATION NOTE (inspectorScrollNodeIntoView.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users scroll\n# the current node into view\ninspectorScrollNodeIntoView.label=Scroll Into View\ninspectorScrollNodeIntoView.accesskey=S\n\n# LOCALIZATION NOTE (inspectorHTMLDelete.label): This is the label shown in\n# the inspector contextual-menu for the item that lets users delete the\n# current node\ninspectorHTMLDelete.label=Delete Node\ninspectorHTMLDelete.accesskey=D\n\n# LOCALIZATION NOTE (inspectorAttributesSubmenu.label): This is the label\n# shown in the inspector contextual-menu for the sub-menu of the other\n# attribute items, which allow to:\n# - add new attribute\n# - edit attribute\n# - remove attribute\ninspectorAttributesSubmenu.label=Attributes\ninspectorAttributesSubmenu.accesskey=A\n\n# LOCALIZATION NOTE (inspectorAddAttribute.label): This is the label shown in\n# the inspector contextual-menu for the item that lets users add attribute\n# to current node\ninspectorAddAttribute.label=Add Attribute\ninspectorAddAttribute.accesskey=A\n\n# LOCALIZATION NOTE (inspectorSearchHTML.label3): This is the label that is\n# shown as the placeholder for the markup view search in the inspector.\ninspectorSearchHTML.label3=Search HTML\n\n# LOCALIZATION NOTE (inspectorImageDataUri.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users copy\n# the URL embedding the image data encoded in Base 64 (what we name\n# here Image Data URL). For more information:\n# https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs\ninspectorImageDataUri.label=Image Data-URL\n\n# LOCALIZATION NOTE (inspectorShowDOMProperties.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users see\n# the DOM properties of the current node. When triggered, this item\n# opens the split Console and displays the properties in its side panel.\ninspectorShowDOMProperties.label=Show DOM Properties\n\n# LOCALIZATION NOTE (inspectorUseInConsole.label): This is the label\n# shown in the inspector contextual-menu for the item that outputs a\n# variable for the current node to the console. When triggered,\n# this item opens the split Console.\ninspectorUseInConsole.label=Use in Console\n\n# LOCALIZATION NOTE (inspectorExpandNode.label): This is the label\n# shown in the inspector contextual-menu for recursively expanding\n# mark-up elements\ninspectorExpandNode.label=Expand All\n\n# LOCALIZATION NOTE (inspectorCollapseNode.label): This is the label\n# shown in the inspector contextual-menu for recursively collapsing\n# mark-up elements\ninspectorCollapseNode.label=Collapse\n\n# LOCALIZATION NOTE (inspectorScreenshotNode.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users take\n# a screenshot of the currently selected node.\ninspectorScreenshotNode.label=Screenshot Node\n\n# LOCALIZATION NOTE (inspectorDuplicateNode.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users\n# duplicate the currently selected node.\ninspectorDuplicateNode.label=Duplicate Node\n\n# LOCALIZATION NOTE (inspectorAddNode.label): This is the label shown in\n# the inspector toolbar for the button that lets users add elements to the\n# DOM (as children of the currently selected element).\ninspectorAddNode.label=Create New Node\ninspectorAddNode.accesskey=C\n\n# LOCALIZATION NOTE (inspectorCopyHTMLSubmenu.label): This is the label\n# shown in the inspector contextual-menu for the sub-menu of the other\n# copy items, which allow to:\n# - Copy Inner HTML\n# - Copy Outer HTML\n# - Copy Unique selector\n# - Copy Image data URI\ninspectorCopyHTMLSubmenu.label=Copy\n\n# LOCALIZATION NOTE (inspectorPasteHTMLSubmenu.label): This is the label\n# shown in the inspector contextual-menu for the sub-menu of the other\n# paste items, which allow to:\n# - Paste Inner HTML\n# - Paste Outer HTML\n# - Before\n# - After\n# - As First Child\n# - As Last Child\ninspectorPasteHTMLSubmenu.label=Paste\n\n# LOCALIZATION NOTE (inspector.searchHTML.key):\n# Key shortcut used to focus the DOM element search box on top-right corner of\n# the markup view\ninspector.searchHTML.key=CmdOrCtrl+F\n\n# LOCALIZATION NOTE (markupView.hide.key):\n# Key shortcut used to hide the selected node in the markup view.\nmarkupView.hide.key=h\n\n# LOCALIZATION NOTE (markupView.edit.key):\n# Key shortcut used to hide the selected node in the markup view.\nmarkupView.edit.key=F2\n\n# LOCALIZATION NOTE (markupView.scrollInto.key):\n# Key shortcut used to scroll the webpage in order to ensure the selected node\n# is visible\nmarkupView.scrollInto.key=s\n\n# LOCALIZATION NOTE (inspector.sidebar.fontInspectorTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying the list of fonts used in the page.\ninspector.sidebar.fontInspectorTitle=Fonts\n\n# LOCALIZATION NOTE (inspector.sidebar.ruleViewTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying the list of CSS rules used\n# in the page.\ninspector.sidebar.ruleViewTitle=Rules\n\n# LOCALIZATION NOTE (inspector.sidebar.computedViewTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying the list of computed CSS values\n# used in the page.\ninspector.sidebar.computedViewTitle=Computed\n\n# LOCALIZATION NOTE (inspector.sidebar.layoutViewTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying box model of the selected element.\ninspector.sidebar.layoutViewTitle=Box Model\n\n# LOCALIZATION NOTE (inspector.sidebar.animationInspectorTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying animations defined in the page.\ninspector.sidebar.animationInspectorTitle=Animations\n"

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used within the JIT tools\n# in the Performance Tools which is available from the Web Developer\n# sub-menu -> 'Performance' The correct localization of this file might\n# be to keep it in English, or another language commonly spoken among\n# web developers. You want to make that choice consistent across the\n# developer tools. A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (jit.title):\n# This string is displayed in the header of the JIT Optimizations view.\njit.title=JIT Optimizations\n\n# LOCALIZATION NOTE (jit.optimizationFailure):\n# This string is displayed in a tooltip when no JIT optimizations were detected.\njit.optimizationFailure=Optimization failed\n\n# LOCALIZATION NOTE (jit.samples):\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This string is displayed for the unit representing the number of times a\n# frame is sampled.\n# \"#1\" represents the number of samples\n# example: 30 samples\njit.samples=#1 sample;#1 samples\n\n# LOCALIZATION NOTE (jit.types):\n# This string is displayed for the group of Ion Types in the optimizations view.\njit.types=Types\n\n# LOCALIZATION NOTE (jit.attempts):\n# This string is displayed for the group of optimization attempts in the optimizations view.\njit.attempts=Attempts\n"

/***/ },
/* 66 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the JSON View tool\n# that is used to inspect application/json document types loaded\n# in the browser.\n\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE (jsonViewer.tab.JSON, jsonViewer.tab.RawData,\n# jsonViewer.tab.Headers): Label for a panel tab.\njsonViewer.tab.JSON=JSON\njsonViewer.tab.RawData=Raw Data\njsonViewer.tab.Headers=Headers\n\n# LOCALIZATION NOTE (jsonViewer.responseHeaders, jsonViewer.requestHeaders):\n# Label for header groups within the 'Headers' panel.\njsonViewer.responseHeaders=Response Headers\njsonViewer.requestHeaders=Request Headers\n\n# LOCALIZATION NOTE (jsonViewer.Save): Label for save command\njsonViewer.Save=Save\n\n# LOCALIZATION NOTE (jsonViewer.Copy): Label for clipboard copy command\njsonViewer.Copy=Copy\n\n# LOCALIZATION NOTE (jsonViewer.ExpandAll): Label for expanding all nodes\njsonViewer.ExpandAll=Expand All\n\n# LOCALIZATION NOTE (jsonViewer.PrettyPrint): Label for JSON\n# pretty print action button.\njsonViewer.PrettyPrint=Pretty Print\n\n# LOCALIZATION NOTE (jsonViewer.reps.more): Label used in arrays\n# that have more items than displayed.\njsonViewer.reps.more=more…\n\n# LOCALIZATION NOTE (jsonViewer.filterJSON): Label used in search box\n# at the top right cornder of the JSON Viewer.\njsonViewer.filterJSON=Filter JSON\n\n# LOCALIZATION NOTE (jsonViewer.reps.reference): Label used for cycle\n# references in an array.\njsonViewer.reps.reference=Cycle Reference\n"

/***/ },
/* 67 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Performance Tools\n# which is available from the Web Developer sub-menu -> 'Performance'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web. These strings\n# are specifically for marker names in the performance tool.\n\n# LOCALIZATION NOTE (marker.label.*):\n# These strings are displayed in the Performance Tool waterfall, identifying markers.\n# We want to use the same wording as Google Chrome when appropriate.\nmarker.label.styles=Recalculate Style\nmarker.label.reflow=Layout\nmarker.label.paint=Paint\nmarker.label.composite=Composite Layers\nmarker.label.compositeForwardTransaction=Composite Request Sent\nmarker.label.javascript=Function Call\nmarker.label.parseHTML=Parse HTML\nmarker.label.parseXML=Parse XML\nmarker.label.domevent=DOM Event\nmarker.label.consoleTime=Console\nmarker.label.garbageCollection2=Garbage Collection\nmarker.label.garbageCollection.incremental=Incremental GC\nmarker.label.garbageCollection.nonIncremental=Non-incremental GC\nmarker.label.minorGC=Minor GC\nmarker.label.cycleCollection=Cycle Collection\nmarker.label.cycleCollection.forgetSkippable=CC Graph Reduction\nmarker.label.timestamp=Timestamp\nmarker.label.worker=Worker\nmarker.label.messagePort=MessagePort\nmarker.label.unknown=Unknown\n\n# LOCALIZATION NOTE (marker.label.javascript.*):\n# These strings are displayed as JavaScript markers that have special\n# reasons that can be translated.\nmarker.label.javascript.scriptElement=Script Tag\nmarker.label.javascript.promiseCallback=Promise Callback\nmarker.label.javascript.promiseInit=Promise Init\nmarker.label.javascript.workerRunnable=Worker\nmarker.label.javascript.jsURI=JavaScript URI\nmarker.label.javascript.eventHandler=Event Handler\n\n# LOCALIZATION NOTE (marker.field.*):\n# Strings used in the waterfall sidebar as property names.\n\n# General marker fields\nmarker.field.start=Start:\nmarker.field.end=End:\nmarker.field.duration=Duration:\n\n# General \"reason\" for a marker (JavaScript, Garbage Collection)\nmarker.field.causeName=Cause:\n# General \"type\" for a marker (Cycle Collection, Garbage Collection)\nmarker.field.type=Type:\n# General \"label\" for a marker (user defined)\nmarker.field.label=Label:\n\n# Field names for stack values\nmarker.field.stack=Stack:\nmarker.field.startStack=Stack at start:\nmarker.field.endStack=Stack at end:\n\n# %S is the \"Async Cause\" of a marker, and this signifies that the cause\n# was an asynchronous one in a displayed stack.\nmarker.field.asyncStack=(Async: %S)\n\n# For console.time markers\nmarker.field.consoleTimerName=Timer Name:\n\n# For DOM Event markers\nmarker.field.DOMEventType=Event Type:\nmarker.field.DOMEventPhase=Phase:\n\n# Non-incremental cause for a Garbage Collection marker\nmarker.field.nonIncrementalCause=Non-incremental Cause:\n\n# For \"Recalculate Style\" markers\nmarker.field.restyleHint=Restyle Hint:\n\n# The type of operation performed by a Worker.\nmarker.worker.serializeDataOffMainThread=Serialize data in Worker\nmarker.worker.serializeDataOnMainThread=Serialize data on the main thread\nmarker.worker.deserializeDataOffMainThread=Deserialize data in Worker\nmarker.worker.deserializeDataOnMainThread=Deserialize data on the main thread\n\n# The type of operation performed by a MessagePort\nmarker.messagePort.serializeData=Serialize data\nmarker.messagePort.deserializeData=Deserialize data\n\n# Strings used in the waterfall sidebar as values.\nmarker.value.unknownFrame=<unknown location>\nmarker.value.DOMEventTargetPhase=Target\nmarker.value.DOMEventCapturingPhase=Capture\nmarker.value.DOMEventBubblingPhase=Bubbling\n\n# LOCALIZATION NOTE (marker.gcreason.label.*):\n# These strings are used to give a concise but readable description of a GC reason.\nmarker.gcreason.label.API=API Call\nmarker.gcreason.label.EAGER_ALLOC_TRIGGER=Eager Allocation Trigger\nmarker.gcreason.label.DESTROY_RUNTIME=Shutdown\nmarker.gcreason.label.LAST_DITCH=Out of Memory\nmarker.gcreason.label.TOO_MUCH_MALLOC=Too Many Bytes Allocated\nmarker.gcreason.label.ALLOC_TRIGGER=Too Many Allocations\nmarker.gcreason.label.DEBUG_GC=Debug GC\nmarker.gcreason.label.COMPARTMENT_REVIVED=Dead Global Revived\nmarker.gcreason.label.RESET=Finish Incremental Cycle\nmarker.gcreason.label.OUT_OF_NURSERY=Nursery is Full\nmarker.gcreason.label.EVICT_NURSERY=Nursery Eviction\nmarker.gcreason.label.FULL_STORE_BUFFER=Nursery Objects Too Active\nmarker.gcreason.label.SHARED_MEMORY_LIMIT=Large Allocation Failed\nmarker.gcreason.label.PERIODIC_FULL_GC=Periodic Full GC\nmarker.gcreason.label.INCREMENTAL_TOO_SLOW=Allocations Rate Too Fast\nmarker.gcreason.label.COMPONENT_UTILS=Cu.forceGC\nmarker.gcreason.label.MEM_PRESSURE=Low Memory\nmarker.gcreason.label.CC_WAITING=Forced by Cycle Collection\nmarker.gcreason.label.CC_FORCED=Forced by Cycle Collection\nmarker.gcreason.label.LOAD_END=Page Load Finished\nmarker.gcreason.label.PAGE_HIDE=Moved to Background\nmarker.gcreason.label.NSJSCONTEXT_DESTROY=Destroy JS Context\nmarker.gcreason.label.SET_NEW_DOCUMENT=New Document\nmarker.gcreason.label.SET_DOC_SHELL=New Document\nmarker.gcreason.label.DOM_UTILS=API Call\nmarker.gcreason.label.DOM_IPC=IPC\nmarker.gcreason.label.DOM_WORKER=Periodic Worker GC\nmarker.gcreason.label.INTER_SLICE_GC=Periodic Incremental GC Slice\nmarker.gcreason.label.FULL_GC_TIMER=Periodic Full GC\nmarker.gcreason.label.SHUTDOWN_CC=Shutdown\nmarker.gcreason.label.FINISH_LARGE_EVALUATE=Large Eval\nmarker.gcreason.label.DOM_WINDOW_UTILS=User Inactive\nmarker.gcreason.label.USER_INACTIVE=User Inactive\n\n# The name of a nursery collection.\nmarker.nurseryCollection=Nursery Collection\n\n# LOCALIZATION NOTE (marker.gcreason.description.*):\n# These strings are used to give an expanded description of why a GC occurred.\nmarker.gcreason.description.API=There was an API call to force garbage collection.\nmarker.gcreason.description.EAGER_ALLOC_TRIGGER=JavaScript returned to the event loop and there were enough bytes allocated since the last GC that a new GC cycle was triggered.\nmarker.gcreason.description.DESTROY_RUNTIME=Firefox destroyed a JavaScript runtime or context, and this was the final garbage collection before shutting down.\nmarker.gcreason.description.LAST_DITCH=JavaScript attempted to allocate, but there was no memory available. Doing a full compacting garbage collection as an attempt to free up memory for the allocation.\nmarker.gcreason.description.TOO_MUCH_MALLOC=JavaScript allocated too many bytes, and forced a garbage collection.\nmarker.gcreason.description.ALLOC_TRIGGER=JavaScript allocated too many times, and forced a garbage collection.\nmarker.gcreason.description.DEBUG_GC=GC due to Zeal debug settings.\nmarker.gcreason.description.COMPARTMENT_REVIVED=A global object that was thought to be dead at the start of the GC cycle was revived by the end of the GC cycle.\nmarker.gcreason.description.RESET=The active incremental GC cycle was forced to finish immediately.\nmarker.gcreason.description.OUT_OF_NURSERY=JavaScript allocated enough new objects in the nursery that it became full and triggered a minor GC.\nmarker.gcreason.description.EVICT_NURSERY=Work needed to be done on the tenured heap, requiring the nursery to be empty.\nmarker.gcreason.description.FULL_STORE_BUFFER=There were too many properties on tenured objects whose value was an object in the nursery.\nmarker.gcreason.description.SHARED_MEMORY_LIMIT=A large allocation was requested, but there was not enough memory.\nmarker.gcreason.description.PERIODIC_FULL_GC=JavaScript returned to the event loop, and it has been a relatively long time since Firefox performed a garbage collection.\nmarker.gcreason.description.INCREMENTAL_TOO_SLOW=A full, non-incremental garbage collection was triggered because there was a faster rate of allocations than the existing incremental garbage collection cycle could keep up with.\nmarker.gcreason.description.COMPONENT_UTILS=Components.utils.forceGC() was called to force a garbage collection.\nmarker.gcreason.description.MEM_PRESSURE=There was very low memory available.\nmarker.gcreason.description.CC_WAITING=The cycle collector required a garbage collection.\nmarker.gcreason.description.CC_FORCED=The cycle collector required a garbage collection.\nmarker.gcreason.description.LOAD_END=The document finished loading.\nmarker.gcreason.description.PAGE_HIDE=The tab or window was moved to the background.\nmarker.gcreason.description.NSJSCONTEXT_DESTROY=Firefox destroyed a JavaScript runtime or context, and this was the final garbage collection before shutting down.\nmarker.gcreason.description.SET_NEW_DOCUMENT=The page has been navigated to a new document.\nmarker.gcreason.description.SET_DOC_SHELL=The page has been navigated to a new document.\nmarker.gcreason.description.DOM_UTILS=There was an API call to force garbage collection.\nmarker.gcreason.description.DOM_IPC=Received an inter-process message that requested a garbage collection.\nmarker.gcreason.description.DOM_WORKER=The worker was idle for a relatively long time.\nmarker.gcreason.description.INTER_SLICE_GC=There has been a relatively long time since the last incremental GC slice.\nmarker.gcreason.description.FULL_GC_TIMER=JavaScript returned to the event loop, and it has been a relatively long time since we performed a garbage collection.\nmarker.gcreason.description.SHUTDOWN_CC=Firefox destroyed a JavaScript runtime or context, and this was the final garbage collection before shutting down.\nmarker.gcreason.description.FINISH_LARGE_EVALUATE=Firefox finished evaluating a large script, and performed a GC because the script will never be run again.\nmarker.gcreason.description.DOM_WINDOW_UTILS=The user was inactive for a long time. Took the opportunity to perform GC when it was unlikely to be noticed.\nmarker.gcreason.description.USER_INACTIVE=The user was inactive for a long time. Firefox took the opportunity to perform GC when it was unlikely to be noticed.\n"

/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Memory Tools\n# which is available from the Web Developer sub-menu -> 'Memory'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (snapshot.io.save): The label for the link that saves a\n# snapshot to disk.\nsnapshot.io.save=Save\n\n# LOCALIZATION NOTE (snapshot.io.delete): The label for the link that deletes\n# a snapshot\nsnapshot.io.delete=Delete\n\n# LOCALIZATION NOTE (snapshot.io.save.window): The title for the window\n# displayed when saving a snapshot to disk.\nsnapshot.io.save.window=Save Snapshot\n\n# LOCALIZATION NOTE (snapshot.io.import.window): The title for the window\n# displayed when importing a snapshot form disk.\nsnapshot.io.import.window=Import Snapshot\n\n# LOCALIZATION NOTE (snapshot.io.filter): The title for the filter used to\n# filter file types (*.fxsnapshot)\nsnapshot.io.filter=Firefox Snapshots\n\n# LOCALIZATION NOTE (aggregate.mb): The label annotating the number of bytes (in\n# megabytes) in a snapshot. %S represents the value, rounded to 2 decimal\n# points.\naggregate.mb=%S MB\n\n# LOCALIZATION NOTE (snapshot-title.loading): The title for a snapshot before\n# it has a creation time to display.\nsnapshot-title.loading=Processing…\n\n# LOCALIZATION NOTE (checkbox.recordAllocationStacks): The label describing the\n# boolean checkbox whether or not to record call stacks.\ncheckbox.recordAllocationStacks=Record call stacks\n\n# LOCALIZATION NOTE (checkbox.recordAllocationStacks.tooltip): The tooltip for\n# the label describing the boolean checkbox whether or not to record call\n# stacks.\ncheckbox.recordAllocationStacks.tooltip=Toggle the recording of the call stack of when an object was allocated. Subsequent snapshots will be able to group and label objects by call stacks, but only with those objects created after toggling this option. Recording call stacks has a performance overhead.\n\n# LOCALIZATION NOTE (toolbar.displayBy): The label describing the select menu\n# options of the display options.\ntoolbar.displayBy=Group by:\n\n# LOCALIZATION NOTE (toolbar.displayBy.tooltip): The tooltip for the label\n# describing the select menu options of the display options.\ntoolbar.displayBy.tooltip=Change how objects are grouped\n\n# LOCALIZATION NOTE (toolbar.pop-view): The text in the button to go back to the\n# previous view.\ntoolbar.pop-view=←\n\n# LOCALIZATION NOTE (toolbar.pop-view.label): The text for the label for the\n# button to go back to the previous view.\ntoolbar.pop-view.label=Go back to aggregates\n\n# LOCALIZATION NOTE (toolbar.viewing-individuals): The text letting the user\n# know that they are viewing individual nodes from a census group.\ntoolbar.viewing-individuals=⁂ Viewing individuals in group\n\n# LOCALIZATION NOTE (censusDisplays.coarseType.tooltip): The tooltip for the\n# \"coarse type\" display option.\ncensusDisplays.coarseType.tooltip=Group items by their type\n\n# LOCALIZATION NOTE (censusDisplays.allocationStack.tooltip): The tooltip for\n# the \"call stack\" display option.\ncensusDisplays.allocationStack.tooltip=Group items by the JavaScript stack recorded when the object was allocated\n\n# LOCALIZATION NOTE (censusDisplays.invertedAllocationStack.tooltip): The\n# tooltip for the \"inverted call stack\" display option.\ncensusDisplays.invertedAllocationStack.tooltip=Group items by the inverted JavaScript call stack recorded when the object was created\n\n# LOCALIZATION NOTE (censusDisplays.treeMap.tooltip): The tooltip for the\n# \"tree map\" display option.\ncensusDisplays.treeMap.tooltip=Visualize memory usage: larger blocks account for a larger percent of memory usage\n\n# LOCALIZATION NOTE (censusDisplays.objectClass.tooltip): The tooltip for the\n# \"object class\" display option.\ncensusDisplays.objectClass.tooltip=Group items by their JavaScript Object [[class]] name\n\n# LOCALIZATION NOTE (censusDisplays.internalType.tooltip): The tooltip for the\n# \"internal type\" display option.\ncensusDisplays.internalType.tooltip=Group items by their internal C++ type\n\n# LOCALIZATION NOTE (toolbar.labelBy): The label describing the select menu\n# options of the label options.\ntoolbar.labelBy=Label by:\n\n# LOCALIZATION NOTE (toolbar.labelBy): The tooltip for the label describing the\n# select menu options of the label options.\ntoolbar.labelBy.tooltip=Change how objects are labeled\n\n# LOCALIZATION NOTE (dominatorTreeDisplays.coarseType.tooltip): The tooltip for\n# the \"coarse type\" dominator tree display option.\ndominatorTreeDisplays.coarseType.tooltip=Label objects by the broad categories they fit in\n\n# LOCALIZATION NOTE (dominatorTreeDisplays.allocationStack.tooltip): The\n# tooltip for the \"call stack\" dominator tree display option.\ndominatorTreeDisplays.allocationStack.tooltip=Label objects by the JavaScript stack recorded when it was allocated\n\n# LOCALIZATION NOTE (dominatorTreeDisplays.internalType.tooltip): The\n# tooltip for the \"internal type\" dominator tree display option.\ndominatorTreeDisplays.internalType.tooltip=Label objects by their internal C++ type name\n\n# LOCALIZATION NOTE (treeMapDisplays.coarseType.tooltip): The tooltip for\n# the \"coarse type\" tree map display option.\ntreeMapDisplays.coarseType.tooltip=Label objects by the broad categories they fit in\n\n# LOCALIZATION NOTE (toolbar.view): The label for the view selector in the\n# toolbar.\ntoolbar.view=View:\n\n# LOCALIZATION NOTE (toolbar.view.tooltip): The tooltip for the label for the\n# view selector in the toolbar.\ntoolbar.view.tooltip=Change the view of the snapshot\n\n# LOCALIZATION NOTE (toolbar.view.census): The label for the census view option\n# in the toolbar.\ntoolbar.view.census=Aggregate\n\n# LOCALIZATION NOTE (toolbar.view.census.tooltip): The tooltip for the label for\n# the census view option in the toolbar.\ntoolbar.view.census.tooltip=View a summary of the snapshot’s contents by aggregating objects into groups\n\n# LOCALIZATION NOTE (toolbar.view.dominators): The label for the dominators view\n# option in the toolbar.\ntoolbar.view.dominators=Dominators\n\n# LOCALIZATION NOTE (toolbar.view.dominators.tooltip): The tooltip for the label\n# for the dominators view option in the toolbar.\ntoolbar.view.dominators.tooltip=View the dominator tree and surface the largest structures in the snapshot\n\n# LOCALIZATION NOTE (toolbar.view.treemap): The label for the tree map option\n# in the toolbar.\ntoolbar.view.treemap=Tree Map\n\n# LOCALIZATION NOTE (toolbar.view.treemap.tooltip): The tooltip for the label for\n# the tree map view option in the toolbar.\ntoolbar.view.treemap.tooltip=Visualize memory usage: larger blocks account for a larger percent of memory usage\n\n# LOCALIZATION NOTE (take-snapshot): The label describing the button that\n# initiates taking a snapshot, either as the main label, or a tooltip.\ntake-snapshot=Take snapshot\n\n# LOCALIZATION NOTE (import-snapshot): The label describing the button that\n# initiates importing a snapshot.\nimport-snapshot=Import…\n\n# LOCALIZATION NOTE (clear-snapshots.tooltip): The tooltip for the button that\n# deletes existing snapshot.\nclear-snapshots.tooltip=Delete all snapshots\n\n# LOCALIZATION NOTE (diff-snapshots.tooltip): The tooltip for the button that\n# initiates selecting two snapshots to diff with each other.\ndiff-snapshots.tooltip=Compare snapshots\n\n# LOCALIZATION NOTE (filter.placeholder): The placeholder text used for the\n# memory tool's filter search box.\nfilter.placeholder=Filter\n\n# LOCALIZATION NOTE (filter.tooltip): The tooltip text used for the memory\n# tool's filter search box.\nfilter.tooltip=Filter the contents of the snapshot\n\n# LOCALIZATION NOTE (tree-item.view-individuals.tooltip): The tooltip for the\n# button to view individuals in this group.\ntree-item.view-individuals.tooltip=View individual nodes in this group and their retaining paths\n\n# LOCALIZATION NOTE (tree-item.load-more): The label for the links to fetch the\n# lazily loaded sub trees in the dominator tree view.\ntree-item.load-more=Load more…\n\n# LOCALIZATION NOTE (tree-item.rootlist): The label for the root of the\n# dominator tree.\ntree-item.rootlist=GC Roots\n\n# LOCALIZATION NOTE (tree-item.nostack): The label describing the row in the heap tree\n# that represents a row broken down by call stack when no stack was available.\ntree-item.nostack=(no stack available)\n\n# LOCALIZATION NOTE (tree-item.nofilename): The label describing the row in the\n# heap tree that represents a row broken down by filename when no filename was\n# available.\ntree-item.nofilename=(no filename available)\n\n# LOCALIZATION NOTE (tree-item.root): The label describing the row in the heap tree\n# that represents the root of the tree when inverted.\ntree-item.root=(root)\n\n# LOCALIZATION NOTE (tree-item.percent2): A percent of bytes or count displayed in the tree view.\n# there are two \"%\" after %S to escape and display \"%\"\ntree-item.percent2=%S%%\n\n# LOCALIZATION NOTE (diffing.baseline): The name of the baseline snapshot in a\n# diffing comparison.\ndiffing.baseline=Baseline\n\n# LOCALIZATION NOTE (diffing.comparison): The name of the snapshot being\n# compared to the baseline in a diffing comparison.\ndiffing.comparison=Comparison\n\n# LOCALIZATION NOTE (diffing.prompt.selectBaseline): The prompt to select the\n# first snapshot when doing a diffing comparison.\ndiffing.prompt.selectBaseline=Select the baseline snapshot\n\n# LOCALIZATION NOTE (diffing.prompt.selectComparison): The prompt to select the\n# second snapshot when doing a diffing comparison.\ndiffing.prompt.selectComparison=Select the snapshot to compare to the baseline\n\n# LOCALIZATION NOTE (diffing.state.error): The label describing the diffing\n# state ERROR, used in the snapshot list when an error occurs while diffing two\n# snapshots.\ndiffing.state.error=Error\n\n# LOCALIZATION NOTE (diffing.state.error.full): The text describing the diffing\n# state ERROR, used in the main view when an error occurs while diffing two\n# snapshots.\ndiffing.state.error.full=There was an error while comparing snapshots.\n\n# LOCALIZATION NOTE (diffing.state.taking-diff): The label describing the diffin\n# state TAKING_DIFF, used in the snapshots list when computing the difference\n# between two snapshots.\ndiffing.state.taking-diff=Computing difference…\n\n# LOCALIZATION NOTE (diffing.state.taking-diff.full): The label describing the\n# diffing state TAKING_DIFF, used in the main view when computing the difference\n# between two snapshots.\ndiffing.state.taking-diff.full=Computing difference…\n\n# LOCALIZATION NOTE (diffing.state.selecting): The label describing the diffing\n# state SELECTING.\ndiffing.state.selecting=Select two snapshots to compare\n\n# LOCALIZATION NOTE (diffing.state.selecting.full): The label describing the\n# diffing state SELECTING, used in the main view when selecting snapshots to\n# diff.\ndiffing.state.selecting.full=Select two snapshots to compare\n\n# LOCALIZATION NOTE (dominatorTree.state.computing): The label describing the\n# dominator tree state COMPUTING.\ndominatorTree.state.computing=Generating dominators report…\n\n# LOCALIZATION NOTE (dominatorTree.state.computing): The label describing the\n# dominator tree state COMPUTING, used in the dominator tree view.\ndominatorTree.state.computing.full=Generating dominators report…\n\n# LOCALIZATION NOTE (dominatorTree.state.fetching): The label describing the\n# dominator tree state FETCHING.\ndominatorTree.state.fetching=Computing sizes…\n\n# LOCALIZATION NOTE (dominatorTree.state.fetching): The label describing the\n# dominator tree state FETCHING, used in the dominator tree view.\ndominatorTree.state.fetching.full=Computing dominator’s retained sizes…\n\n# LOCALIZATION NOTE (dominatorTree.state.incrementalFetching): The label\n# describing the dominator tree state INCREMENTAL_FETCHING.\ndominatorTree.state.incrementalFetching=Fetching…\n\n# LOCALIZATION NOTE (dominatorTree.state.incrementalFetching): The label describing the\n# dominator tree state INCREMENTAL_FETCHING, used in the dominator tree view.\ndominatorTree.state.incrementalFetching.full=Fetching more…\n\n# LOCALIZATION NOTE (dominatorTree.state.error): The label describing the\n# dominator tree state ERROR.\ndominatorTree.state.error=Error\n\n# LOCALIZATION NOTE (dominatorTree.state.error): The label describing the\n# dominator tree state ERROR, used in the dominator tree view.\ndominatorTree.state.error.full=There was an error while processing the dominator tree\n\n# LOCALIZATION NOTE (snapshot.state.saving.full): The label describing the\n# snapshot state SAVING, used in the main heap view.\nsnapshot.state.saving.full=Saving snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.importing.full): The label describing the\n# snapshot state IMPORTING, used in the main heap view.\nsnapshot.state.importing.full=Importing…\n\n# LOCALIZATION NOTE (snapshot.state.reading.full): The label describing the\n# snapshot state READING, and SAVED, due to these states being combined\n# visually, used in the main heap view.\nsnapshot.state.reading.full=Reading snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.saving-census.full): The label describing\n# the snapshot state SAVING, used in the main heap view.\nsnapshot.state.saving-census.full=Generating aggregate report…\n\n# LOCALIZATION NOTE (snapshot.state.saving-tree-map.full): The label describing\n# the snapshot state SAVING, used in the main heap view.\nsnapshot.state.saving-tree-map.full=Saving tree map…\n\n# LOCALIZATION NOTE (snapshot.state.error.full): The label describing the\n# snapshot state ERROR, used in the main heap view.\nsnapshot.state.error.full=There was an error processing this snapshot.\n\n# LOCALIZATION NOTE (individuals.state.error): The short message displayed when\n# there is an error fetching individuals from a group.\nindividuals.state.error=Error\n\n# LOCALIZATION NOTE (individuals.state.error.full): The longer message displayed\n# when there is an error fetching individuals from a group.\nindividuals.state.error.full=There was an error while fetching individuals in the group\n\n# LOCALIZATION NOTE (individuals.state.fetching): The short message displayed\n# while fetching individuals.\nindividuals.state.fetching=Fetching…\n\n# LOCALIZATION NOTE (individuals.state.fetching.full): The longer message\n# displayed while fetching individuals.\nindividuals.state.fetching.full=Fetching individuals in group…\n\n# LOCALIZATION NOTE (individuals.field.node): The header label for an individual\n# node.\nindividuals.field.node=Node\n\n# LOCALIZATION NOTE (individuals.field.node.tooltip): The tooltip for the header\n# label for an individual node.\nindividuals.field.node.tooltip=The individual node in the snapshot\n\n# LOCALIZATION NOTE (snapshot.state.saving): The label describing the snapshot\n# state SAVING, used in the snapshot list view\nsnapshot.state.saving=Saving snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.importing): The label describing the\n# snapshot state IMPORTING, used in the snapshot list view\nsnapshot.state.importing=Importing snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.reading): The label describing the snapshot\n# state READING, and SAVED, due to these states being combined visually, used in\n# the snapshot list view.\nsnapshot.state.reading=Reading snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.saving-census): The label describing the\n# snapshot state SAVING, used in snapshot list view.\nsnapshot.state.saving-census=Saving report…\n\n# LOCALIZATION NOTE (snapshot.state.saving-census): The label describing the\n# snapshot state SAVING, used in snapshot list view.\nsnapshot.state.saving-tree-map=Saving tree map…\n\n# LOCALIZATION NOTE (snapshot.state.error): The label describing the snapshot\n# state ERROR, used in the snapshot list view.\nsnapshot.state.error=Error\n\n# LOCALIZATION NOTE (heapview.no-difference): Message displayed when there is no\n# difference between two snapshots.\nheapview.no-difference=No difference between the baseline and comparison.\n\n# LOCALIZATION NOTE (heapview.none-match): Message displayed when there are no\n# matches when filtering.\nheapview.none-match=No matches.\n\n# LOCALIZATION NOTE (heapview.none-match): Message displayed when there report\n# is empty.\nheapview.empty=Empty.\n\n# LOCALIZATION NOTE (heapview.noAllocationStacks): The message displayed to\n# users when selecting a display by \"call stack\" but no call stacks\n# were recorded in the heap snapshot.\nheapview.noAllocationStacks=No call stacks found. Record call stacks before taking a snapshot.\n\n# LOCALIZATION NOTE (heapview.field.retainedSize): The name of the column in the\n# dominator tree view for retained byte sizes.\nheapview.field.retainedSize=Retained Size (Bytes)\n\n# LOCALIZATION NOTE (heapview.field.retainedSize.tooltip): The tooltip for the\n# column header in the dominator tree view for retained byte sizes.\nheapview.field.retainedSize.tooltip=The sum of the size of the object itself, and the sizes of all the other objects kept alive by it\n\n# LOCALIZATION NOTE (heapview.field.shallowSize): The name of the column in the\n# dominator tree view for shallow byte sizes.\nheapview.field.shallowSize=Shallow Size (Bytes)\n\n# LOCALIZATION NOTE (heapview.field.shallowSize.tooltip): The tooltip for the\n# column header in the dominator tree view for shallow byte sizes.\nheapview.field.shallowSize.tooltip=The size of the object itself\n\n# LOCALIZATION NOTE (dominatortree.field.label): The name of the column in the\n# dominator tree for an object's label.\ndominatortree.field.label=Dominator\n\n# LOCALIZATION NOTE (dominatortree.field.label.tooltip): The tooltip for the column\n# header in the dominator tree view for an object's label.\ndominatortree.field.label.tooltip=The label for an object in memory\n\n# LOCALIZATION NOTE (heapview.field.bytes): The name of the column in the heap\n# view for bytes.\nheapview.field.bytes=Bytes\n\n# LOCALIZATION NOTE (heapview.field.bytes.tooltip): The tooltip for the column\n# header in the heap view for bytes.\nheapview.field.bytes.tooltip=The number of bytes taken up by this group, excluding subgroups\n\n# LOCALIZATION NOTE (heapview.field.count): The name of the column in the heap\n# view for count.\nheapview.field.count=Count\n\n# LOCALIZATION NOTE (heapview.field.count.tooltip): The tooltip for the column\n# header in the heap view for count.\nheapview.field.count.tooltip=The number of reachable objects in this group, excluding subgroups\n\n# LOCALIZATION NOTE (heapview.field.totalbytes): The name of the column in the\n# heap view for total bytes.\nheapview.field.totalbytes=Total Bytes\n\n# LOCALIZATION NOTE (heapview.field.totalbytes.tooltip): The tooltip for the\n# column header in the heap view for total bytes.\nheapview.field.totalbytes.tooltip=The number of bytes taken up by this group, including subgroups\n\n# LOCALIZATION NOTE (heapview.field.totalcount): The name of the column in the\n# heap view for total count.\nheapview.field.totalcount=Total Count\n\n# LOCALIZATION NOTE (heapview.field.totalcount.tooltip): The tooltip for the\n# column header in the heap view for total count.\nheapview.field.totalcount.tooltip=The number of reachable objects in this group, including subgroups\n\n# LOCALIZATION NOTE (heapview.field.name): The name of the column in the heap\n# view for name.\nheapview.field.name=Group\n\n# LOCALIZATION NOTE (heapview.field.name.tooltip): The tooltip for the column\n# header in the heap view for name.\nheapview.field.name.tooltip=The name of this group\n\n# LOCALIZATION NOTE (shortest-paths.header): The header label for the shortest\n# paths pane.\nshortest-paths.header=Retaining Paths (from Garbage Collector Roots)\n\n# LOCALIZATION NOTE (shortest-paths.select-node): The message displayed in the\n# shortest paths pane when a node is not yet selected.\nshortest-paths.select-node=Select an item to view its retaining paths\n\n# LOCALIZATION NOTE (tree-map.node-count): The label for the count value of a\n# node in the tree map\ntree-map.node-count=count\n"

/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ndevToolsCmd.key = VK_F12\ndevToolsCmd.keytext = F12\n\ndevtoolsServiceWorkers.label = Service Workers\ndevtoolsServiceWorkers.accesskey = k\n\ndevtoolsConnect.label = Connect…\ndevtoolsConnect.accesskey = C\n\nbrowserConsoleCmd.label = Browser Console\nbrowserConsoleCmd.accesskey = B\nbrowserConsoleCmd.key = j\n\nresponsiveDesignMode.label = Responsive Design Mode\nresponsiveDesignMode.accesskey = R\nresponsiveDesignMode.key = M\n\neyedropper.label = Eyedropper\neyedropper.accesskey = Y\n\n# LOCALIZATION NOTE (scratchpad.label): This menu item label appears\n# in the Tools menu. See bug 653093.\n# The Scratchpad is intended to provide a simple text editor for creating\n# and evaluating bits of JavaScript code for the purposes of function\n# prototyping, experimentation and convenient scripting.\n#\n# It's quite possible that you won't have a good analogue for the word\n# \"Scratchpad\" in your locale. You should feel free to find a close\n# approximation to it or choose a word (or words) that means\n# \"simple discardable text editor\".\nscratchpad.label = Scratchpad\nscratchpad.accesskey = s\nscratchpad.key = VK_F4\nscratchpad.keytext = F4\n\n# LOCALIZATION NOTE (browserToolboxMenu.label): This is the label for the\n# application menu item that opens the browser toolbox UI in the Tools menu.\nbrowserToolboxMenu.label = Browser Toolbox\nbrowserToolboxMenu.accesskey = e\nbrowserToolboxMenu.key = i\n\n# LOCALIZATION NOTE (browserContentToolboxMenu.label): This is the label for the\n# application menu item that opens the browser content toolbox UI in the Tools menu.\n# This toolbox allows to debug the chrome of the content process in multiprocess builds.\nbrowserContentToolboxMenu.label = Browser Content Toolbox\nbrowserContentToolboxMenu.accesskey = x\n\ndevToolbarMenu.label = Developer Toolbar\ndevToolbarMenu.accesskey = v\ndevToolbarMenu.key = VK_F2\ndevToolbarMenu.keytext = F2\n\nwebide.label = WebIDE\nwebide.accesskey = W\nwebide.key = VK_F8\nwebide.keytext = F8\n\ndevToolboxMenuItem.label = Toggle Tools\ndevToolboxMenuItem.accesskey = T\ndevToolboxMenuItem.key = I\n\ngetMoreDevtoolsCmd.label = Get More Tools\ngetMoreDevtoolsCmd.accesskey = M\n"

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Network Monitor\n# which is available from the Web Developer sub-menu -> 'Network Monitor'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (netmonitor.security.state.secure)\n# This string is used as an tooltip for request that was performed over secure\n# channel i.e. the connection was encrypted.\nnetmonitor.security.state.secure=The connection used to fetch this resource was secure.\n\n# LOCALIZATION NOTE (netmonitor.security.state.insecure)\n# This string is used as an tooltip for request that was performed over insecure\n# channel i.e. the connection was not https\nnetmonitor.security.state.insecure=The connection used to fetch this resource was not secure.\n\n# LOCALIZATION NOTE (netmonitor.security.state.broken)\n# This string is used as an tooltip for request that failed due to security\n# issues.\nnetmonitor.security.state.broken=A security error prevented the resource from being loaded.\n\n# LOCALIZATION NOTE (netmonitor.security.state.weak)\n# This string is used as an tooltip for request that had minor security issues\nnetmonitor.security.state.weak=This resource was transferred over a connection that used weak encryption.\n\n# LOCALIZATION NOTE (netmonitor.security.enabled):\n# This string is used to indicate that a specific security feature is used by\n# a connection in the security details tab.\n# For example: \"HTTP Strict Transport Security: Enabled\"\nnetmonitor.security.enabled=Enabled\n\n# LOCALIZATION NOTE (netmonitor.security.disabled):\n# This string is used to indicate that a specific security feature is not used by\n# a connection in the security details tab.\n# For example: \"HTTP Strict Transport Security: Disabled\"\nnetmonitor.security.disabled=Disabled\n\n# LOCALIZATION NOTE (netmonitor.security.hostHeader):\n# This string is used as a header for section containing security information\n# related to the remote host. %S is replaced with the domain name of the remote\n# host. For example: Host example.com\nnetmonitor.security.hostHeader=Host %S:\n\n# LOCALIZATION NOTE (netmonitor.security.notAvailable):\n# This string is used to indicate that a certain piece of information is not\n# available to be displayed. For example a certificate that has no organization\n# defined:\n#   Organization: <Not Available>\nnetmonitor.security.notAvailable=<Not Available>\n\n# LOCALIZATION NOTE (collapseDetailsPane): This is the tooltip for the button\n# that collapses the network details pane in the UI.\ncollapseDetailsPane=Hide request details\n\n# LOCALIZATION NOTE (expandDetailsPane): This is the tooltip for the button\n# that expands the network details pane in the UI.\nexpandDetailsPane=Show request details\n\n# LOCALIZATION NOTE (headersEmptyText): This is the text displayed in the\n# headers tab of the network details pane when there are no headers available.\nheadersEmptyText=No headers for this request\n\n# LOCALIZATION NOTE (headersFilterText): This is the text displayed in the\n# headers tab of the network details pane for the filtering input.\nheadersFilterText=Filter headers\n\n# LOCALIZATION NOTE (cookiesEmptyText): This is the text displayed in the\n# cookies tab of the network details pane when there are no cookies available.\ncookiesEmptyText=No cookies for this request\n\n# LOCALIZATION NOTE (cookiesFilterText): This is the text displayed in the\n# cookies tab of the network details pane for the filtering input.\ncookiesFilterText=Filter cookies\n\n# LOCALIZATION NOTE (paramsEmptyText): This is the text displayed in the\n# params tab of the network details pane when there are no params available.\nparamsEmptyText=No parameters for this request\n\n# LOCALIZATION NOTE (paramsFilterText): This is the text displayed in the\n# params tab of the network details pane for the filtering input.\nparamsFilterText=Filter request parameters\n\n# LOCALIZATION NOTE (paramsQueryString): This is the label displayed\n# in the network details params tab identifying the query string.\nparamsQueryString=Query string\n\n# LOCALIZATION NOTE (paramsFormData): This is the label displayed\n# in the network details params tab identifying the form data.\nparamsFormData=Form data\n\n# LOCALIZATION NOTE (paramsPostPayload): This is the label displayed\n# in the network details params tab identifying the request payload.\nparamsPostPayload=Request payload\n\n# LOCALIZATION NOTE (requestHeaders): This is the label displayed\n# in the network details headers tab identifying the request headers.\nrequestHeaders=Request headers\n\n# LOCALIZATION NOTE (requestHeadersFromUpload): This is the label displayed\n# in the network details headers tab identifying the request headers from\n# the upload stream of a POST request's body.\nrequestHeadersFromUpload=Request headers from upload stream\n\n# LOCALIZATION NOTE (responseHeaders): This is the label displayed\n# in the network details headers tab identifying the response headers.\nresponseHeaders=Response headers\n\n# LOCALIZATION NOTE (requestCookies): This is the label displayed\n# in the network details params tab identifying the request cookies.\nrequestCookies=Request cookies\n\n# LOCALIZATION NOTE (responseCookies): This is the label displayed\n# in the network details params tab identifying the response cookies.\nresponseCookies=Response cookies\n\n# LOCALIZATION NOTE (jsonFilterText): This is the text displayed\n# in the response tab of the network details pane for the JSON filtering input.\njsonFilterText=Filter properties\n\n# LOCALIZATION NOTE (jsonScopeName): This is the text displayed\n# in the response tab of the network details pane for a JSON scope.\njsonScopeName=JSON\n\n# LOCALIZATION NOTE (jsonpScopeName): This is the text displayed\n# in the response tab of the network details pane for a JSONP scope.\njsonpScopeName=JSONP → callback %S()\n\n# LOCALIZATION NOTE (networkMenu.sortedAsc): This is the tooltip displayed\n# in the network table toolbar, for any column that is sorted ascending.\nnetworkMenu.sortedAsc=Sorted ascending\n\n# LOCALIZATION NOTE (networkMenu.sortedDesc): This is the tooltip displayed\n# in the network table toolbar, for any column that is sorted descending.\nnetworkMenu.sortedDesc=Sorted descending\n\n# LOCALIZATION NOTE (networkMenu.empty): This is the label displayed\n# in the network table footer when there are no requests available.\nnetworkMenu.empty=No requests\n\n# LOCALIZATION NOTE (networkMenu.summary): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This label is displayed in the network table footer providing concise\n# information about all requests. Parameters: #1 is the number of requests,\n# #2 is the size, #3 is the number of seconds.\nnetworkMenu.summary=One request, #2 KB, #3 s;#1 requests, #2 KB, #3 s\n\n# LOCALIZATION NOTE (networkMenu.sizeB): This is the label displayed\n# in the network menu specifying the size of a request (in bytes).\nnetworkMenu.sizeB=%S B\n\n# LOCALIZATION NOTE (networkMenu.sizeKB): This is the label displayed\n# in the network menu specifying the size of a request (in kilobytes).\nnetworkMenu.sizeKB=%S KB\n\n# LOCALIZATION NOTE (networkMenu.sizeMB): This is the label displayed\n# in the network menu specifying the size of a request (in megabytes).\nnetworkMenu.sizeMB=%S MB\n\n# LOCALIZATION NOTE (networkMenu.sizeGB): This is the label displayed\n# in the network menu specifying the size of a request (in gigabytes).\nnetworkMenu.sizeGB=%S GB\n\n# LOCALIZATION NOTE (networkMenu.sizeUnavailable): This is the label displayed\n# in the network menu specifying the transferred size of a request is\n# unavailable.\nnetworkMenu.sizeUnavailable=—\n\n# LOCALIZATION NOTE (networkMenu.sizeCached): This is the label displayed\n# in the network menu specifying the transferred of a request is\n# cached.\nnetworkMenu.sizeCached=cached\n\n# LOCALIZATION NOTE (networkMenu.sizeServiceWorker): This is the label displayed\n# in the network menu specifying the transferred of a request computed\n# by a service worker.\nnetworkMenu.sizeServiceWorker=service worker\n\n# LOCALIZATION NOTE (networkMenu.totalMS): This is the label displayed\n# in the network menu specifying the time for a request to finish (in milliseconds).\nnetworkMenu.totalMS=→ %S ms\n\n# LOCALIZATION NOTE (networkMenu.millisecond): This is the label displayed\n# in the network menu specifying timing interval divisions (in milliseconds).\nnetworkMenu.millisecond=%S ms\n\n# LOCALIZATION NOTE (networkMenu.second): This is the label displayed\n# in the network menu specifying timing interval divisions (in seconds).\nnetworkMenu.second=%S s\n\n# LOCALIZATION NOTE (networkMenu.minute): This is the label displayed\n# in the network menu specifying timing interval divisions (in minutes).\nnetworkMenu.minute=%S min\n\n# LOCALIZATION NOTE (pieChart.loading): This is the label displayed\n# for pie charts (e.g., in the performance analysis view) when there is\n# no data available yet.\npieChart.loading=Loading\n\n# LOCALIZATION NOTE (pieChart.unavailable): This is the label displayed\n# for pie charts (e.g., in the performance analysis view) when there is\n# no data available, even after loading it.\npieChart.unavailable=Empty\n\n# LOCALIZATION NOTE (tableChart.loading): This is the label displayed\n# for table charts (e.g., in the performance analysis view) when there is\n# no data available yet.\ntableChart.loading=Please wait…\n\n# LOCALIZATION NOTE (tableChart.unavailable): This is the label displayed\n# for table charts (e.g., in the performance analysis view) when there is\n# no data available, even after loading it.\ntableChart.unavailable=No data available\n\n# LOCALIZATION NOTE (charts.sizeKB): This is the label displayed\n# in pie or table charts specifying the size of a request (in kilobytes).\ncharts.sizeKB=%S KB\n\n# LOCALIZATION NOTE (charts.totalS): This is the label displayed\n# in pie or table charts specifying the time for a request to finish (in seconds).\ncharts.totalS=%S s\n\n# LOCALIZATION NOTE (charts.cacheEnabled): This is the label displayed\n# in the performance analysis view for \"cache enabled\" charts.\ncharts.cacheEnabled=Primed cache\n\n# LOCALIZATION NOTE (charts.cacheDisabled): This is the label displayed\n# in the performance analysis view for \"cache disabled\" charts.\ncharts.cacheDisabled=Empty cache\n\n# LOCALIZATION NOTE (charts.totalSize): This is the label displayed\n# in the performance analysis view for total requests size, in kilobytes.\ncharts.totalSize=Size: %S KB\n\n# LOCALIZATION NOTE (charts.totalSeconds): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This is the label displayed in the performance analysis view for the\n# total requests time, in seconds.\ncharts.totalSeconds=Time: #1 second;Time: #1 seconds\n\n# LOCALIZATION NOTE (charts.totalCached): This is the label displayed\n# in the performance analysis view for total cached responses.\ncharts.totalCached=Cached responses: %S\n\n# LOCALIZATION NOTE (charts.totalCount): This is the label displayed\n# in the performance analysis view for total requests.\ncharts.totalCount=Total requests: %S\n\n# LOCALIZATION NOTE (netRequest.headers): A label used for Headers tab\n# This tab displays list of HTTP headers\nnetRequest.headers=Headers\n\n# LOCALIZATION NOTE (netRequest.response): A label used for Response tab\n# This tab displays HTTP response body\nnetRequest.response=Response\n\n# LOCALIZATION NOTE (netRequest.rawData): A label used for a section\n# in Response tab. This section displays raw response body as it's\n# been received from the backend (debugger server)\nnetRequest.rawData=Raw Data\n\n# LOCALIZATION NOTE (netRequest.xml): A label used for a section\n# in Response tab. This section displays parsed XML response body.\nnetRequest.xml=XML\n\n# LOCALIZATION NOTE (netRequest.image): A label used for a section\n# in Response tab. This section displays images returned in response body.\nnetRequest.image=Image\n\n# LOCALIZATION NOTE (netRequest.sizeLimitMessage): A label used\n# in Response and Post tabs in case the body is bigger than given limit.\n# It allows the user to click and fetch more from the backend.\n# The {{link}} will be replace at run-time by an active link.\n# String with ID 'netRequest.sizeLimitMessageLink' will be used as text\n# for this link.\nnetRequest.sizeLimitMessage=Size limit has been reached. Click {{link}} to load more.\nnetRequest.sizeLimitMessageLink=here\n\n# LOCALIZATION NOTE (netRequest.responseBodyDiscarded): A label used\n# in Response tab if the response body is not available.\nnetRequest.responseBodyDiscarded=Response body was not stored.\n\n# LOCALIZATION NOTE (netRequest.requestBodyDiscarded): A label used\n# in Post tab if the post body is not available.\nnetRequest.requestBodyDiscarded=Request POST body was not stored.\n\n# LOCALIZATION NOTE (netRequest.post): A label used for Post tab\n# This tab displays HTTP post body\nnetRequest.post=POST\n\n# LOCALIZATION NOTE (netRequest.cookies): A label used for Cookies tab\n# This tab displays request and response cookies.\nnetRequest.cookies=Cookies\n\n# LOCALIZATION NOTE (netRequest.params): A label used for URL parameters tab\n# This tab displays data parsed from URL query string.\nnetRequest.params=Params\n\n# LOCALIZATION NOTE (netRequest.callstack): A label used for request stacktrace tab\n# This tab displays the request's JavaScript stack trace. Should be identical to\n# debuggerUI.tabs.callstack\nnetRequest.callstack=Call Stack\n"

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Performance Tools\n# which is available from the Web Developer sub-menu -> 'Performance'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (noRecordingsText): The text to display in the\n# recordings menu when there are no recorded profiles yet.\nnoRecordingsText=There are no profiles yet.\n\n# LOCALIZATION NOTE (recordingsList.itemLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# identifying a set of function calls. %S represents the number of recording,\n# iterating for every new recording, resulting in \"Recording #1\", \"Recording #2\", etc.\nrecordingsList.itemLabel=Recording #%S\n\n# LOCALIZATION NOTE (recordingsList.recordingLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# for an item that has not finished recording.\nrecordingsList.recordingLabel=In progress…\n\n# LOCALIZATION NOTE (recordingsList.loadingLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# for an item that is finished and is loading.\nrecordingsList.loadingLabel=Loading…\n\n# LOCALIZATION NOTE (recordingsList.durationLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# for an item that has finished recording.\nrecordingsList.durationLabel=%S ms\n\n# LOCALIZATION NOTE (recordingsList.saveLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# for saving an item to disk.\nrecordingsList.saveLabel=Save\n\n# LOCALIZATION NOTE (graphs.fps):\n# This string is displayed in the framerate graph of the Performance Tools,\n# as the unit used to measure frames per second. This label should be kept\n# AS SHORT AS POSSIBLE so it doesn't obstruct important parts of the graph.\ngraphs.fps=fps\n\n# LOCALIZATION NOTE (graphs.ms):\n# This string is displayed in the flamegraph of the Performance Tools,\n# as the unit used to measure time (in milliseconds). This label should be kept\n# AS SHORT AS POSSIBLE so it doesn't obstruct important parts of the graph.\ngraphs.ms=ms\n\n# LOCALIZATION NOTE (graphs.memory):\n# This string is displayed in the memory graph of the Performance tool,\n# as the unit used to memory consumption. This label should be kept\n# AS SHORT AS POSSIBLE so it doesn't obstruct important parts of the graph.\ngraphs.memory=MB\n\n# LOCALIZATION NOTE (category.*):\n# These strings are displayed in the categories graph of the Performance Tools,\n# as the legend for each block in every bar. These labels should be kept\n# AS SHORT AS POSSIBLE so they don't obstruct important parts of the graph.\ncategory.other=Gecko\ncategory.css=Styles\ncategory.js=JIT\ncategory.gc=GC\ncategory.network=Network\ncategory.graphics=Graphics\ncategory.storage=Storage\ncategory.events=Input & Events\ncategory.tools=Tools\n\n# LOCALIZATION NOTE (table.bytes):\n# This string is displayed in the call tree after bytesize units.\n# %S represents the value in bytes.\ntable.bytes=%S B\n\n# LOCALIZATION NOTE (table.ms2):\n# This string is displayed in the call tree after units of time in milliseconds.\n# %S represents the value in milliseconds.\ntable.ms2=%S ms\n\n# LOCALIZATION NOTE (table.percentage3):\n# This string is displayed in the call tree after units representing percentages.\n# %S represents the value in percentage with two decimal points, localized.\n# there are two \"%\" after %S to escape and display \"%\"\ntable.percentage3=%S%%\n\n# LOCALIZATION NOTE (table.root):\n# This string is displayed in the call tree for the root node.\ntable.root=(root)\n\n# LOCALIZATION NOTE (table.idle):\n# This string is displayed in the call tree for the idle blocks.\ntable.idle=(idle)\n\n# LOCALIZATION NOTE (table.url.tooltiptext):\n# This string is displayed in the call tree as the tooltip text for the url\n# labels which, when clicked, jump to the debugger.\ntable.url.tooltiptext=View source in Debugger\n\n# LOCALIZATION NOTE (table.view-optimizations.tooltiptext2):\n# This string is displayed in the icon displayed next to frames that\n# have optimization data\ntable.view-optimizations.tooltiptext2=Frame contains JIT optimization data\n\n# LOCALIZATION NOTE (recordingsList.importDialogTitle):\n# This string is displayed as a title for importing a recoring from disk.\nrecordingsList.importDialogTitle=Import recording…\n\n# LOCALIZATION NOTE (recordingsList.saveDialogTitle):\n# This string is displayed as a title for saving a recording to disk.\nrecordingsList.saveDialogTitle=Save recording…\n\n# LOCALIZATION NOTE (recordingsList.saveDialogJSONFilter):\n# This string is displayed as a filter for saving a recording to disk.\nrecordingsList.saveDialogJSONFilter=JSON Files\n\n# LOCALIZATION NOTE (recordingsList.saveDialogAllFilter):\n# This string is displayed as a filter for saving a recording to disk.\nrecordingsList.saveDialogAllFilter=All Files\n\n# LOCALIZATION NOTE (timeline.tick):\n# This string is displayed in the timeline overview, for delimiting ticks\n# by time, in milliseconds.\ntimeline.tick=%S ms\n\n# LOCALIZATION NOTE (timeline.records):\n# This string is displayed in the timeline waterfall, as a title for the menu.\ntimeline.records=RECORDS\n\n# LOCALIZATION NOTE (profiler.bufferFull):\n# This string is displayed when recording, indicating how much of the\n# buffer is currently be used.\n# %S is the percentage of the buffer used -- there are two \"%\"s after to escape\n# the % that is actually displayed.\n# Example: \"Buffer 54% full\"\nprofiler.bufferFull=Buffer %S%% full\n\n# LOCALIZATION NOTE (recordings.start):\n# The label shown on the main recording buttons to start recording.\nrecordings.start=Start Recording Performance\n\n# LOCALIZATION NOTE (recordings.stop):\n# The label shown on the main recording buttons to stop recording.\nrecordings.stop=Stop Recording Performance\n\n# LOCALIZATION NOTE (recordings.start.tooltip):\n# This string is displayed as a tooltip on a button that starts a new profile.\nrecordings.start.tooltip=Toggle the recording state of a performance recording.\n\n# LOCALIZATION NOTE (recordings.import.tooltip):\n# This string is displayed on a button that opens a dialog to import a saved profile data file.\nrecordings.import.tooltip=Import…\n\n# LOCALIZATION NOTE (recordings.clear.tooltip):\n# This string is displayed on a button that removes all the recordings.\nrecordings.clear.tooltip=Clear\n"

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the ProjectEditor component\n# which is used for editing files in a directory and is used inside the\n# App Manager.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (projecteditor.confirmUnsavedTitle):\n# This string is displayed as as the title of the confirm prompt that checks\n# to make sure if the project can be closed/switched without saving changes\nprojecteditor.confirmUnsavedTitle=Unsaved Changes\n\n# LOCALIZATION NOTE (projecteditor.confirmUnsavedLabel2):\n# This string is displayed as the message of the confirm prompt that checks\n# to make sure if the project can be closed/switched without saving changes\nprojecteditor.confirmUnsavedLabel2=You have unsaved changes that will be lost. Are you sure you want to continue?\n\n# LOCALIZATION NOTE (projecteditor.deleteLabel):\n# This string is displayed as a context menu item for allowing the selected\n# file / folder to be deleted.\nprojecteditor.deleteLabel=Delete\n\n# LOCALIZATION NOTE (projecteditor.deletePromptTitle):\n# This string is displayed as as the title of the confirm prompt that checks\n# to make sure if a file or folder should be removed.\nprojecteditor.deletePromptTitle=Delete\n\n# LOCALIZATION NOTE (projecteditor.deleteFolderPromptMessage):\n# This string is displayed as as the message of the confirm prompt that checks\n# to make sure if a folder should be removed.\nprojecteditor.deleteFolderPromptMessage=Are you sure you want to delete this folder?\n\n# LOCALIZATION NOTE (projecteditor.deleteFilePromptMessage):\n# This string is displayed as as the message of the confirm prompt that checks\n# to make sure if a file should be removed.\nprojecteditor.deleteFilePromptMessage=Are you sure you want to delete this file?\n\n# LOCALIZATION NOTE (projecteditor.newLabel):\n# This string is displayed as a menu item for adding a new file to\n# the directory.\nprojecteditor.newLabel=New…\n\n# LOCALIZATION NOTE (projecteditor.renameLabel):\n# This string is displayed as a menu item for renaming a file in\n# the directory.\nprojecteditor.renameLabel=Rename\n\n# LOCALIZATION NOTE (projecteditor.saveLabel):\n# This string is displayed as a menu item for saving the current file.\nprojecteditor.saveLabel=Save\n\n# LOCALIZATION NOTE (projecteditor.saveAsLabel):\n# This string is displayed as a menu item for saving the current file\n# with a new name.\nprojecteditor.saveAsLabel=Save As…\n\n# LOCALIZATION NOTE (projecteditor.selectFileLabel):\n# This string is displayed as the title on the file picker when saving a file.\nprojecteditor.selectFileLabel=Select a File\n\n# LOCALIZATION NOTE (projecteditor.openFolderLabel):\n# This string is displayed as the title on the file picker when opening a folder.\nprojecteditor.openFolderLabel=Select a Folder\n\n# LOCALIZATION NOTE (projecteditor.openFileLabel):\n# This string is displayed as the title on the file picker when opening a file.\nprojecteditor.openFileLabel=Open a File\n\n# LOCALIZATION NOTE  (projecteditor.find.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to search\n# text in the files.\nprojecteditor.find.commandkey=F\n\n# LOCALIZATION NOTE  (projecteditor.save.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to\n# save the file.  It is used with accel+shift to \"save as\".\nprojecteditor.save.commandkey=S\n\n# LOCALIZATION NOTE  (projecteditor.new.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to\n# create a new file.\nprojecteditor.new.commandkey=N\n"

/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Promise debugger\n# which is available as a panel in the Debugger.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n"

/***/ },
/* 74 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Responsive Design Mode,\n# available from the Web Developer sub-menu -> 'Responsive Design Mode'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (responsive.editDeviceList): option displayed in the device\n# selector\nresponsive.editDeviceList=Edit list…\n\n# LOCALIZATION NOTE (responsive.exit): tooltip text of the exit button.\nresponsive.exit=Close Responsive Design Mode\n\n# LOCALIZATION NOTE (responsive.deviceListLoading): placeholder text for\n# device selector when it's still fetching devices\nresponsive.deviceListLoading=Loading…\n\n# LOCALIZATION NOTE (responsive.deviceListError): placeholder text for\n# device selector when an error occurred\nresponsive.deviceListError=No list available\n\n# LOCALIZATION NOTE (responsive.done): button text in the device list modal\nresponsive.done=Done\n\n# LOCALIZATION NOTE (responsive.noDeviceSelected): placeholder text for the\n# device selector\nresponsive.noDeviceSelected=no device selected\n\n# LOCALIZATION NOTE  (responsive.title): the title displayed in the global\n# toolbar\nresponsive.title=Responsive Design Mode\n\n# LOCALIZATION NOTE (responsive.enableTouch): tooltip text for the touch\n# simulation button when it's disabled\nresponsive.enableTouch=Enable touch simulation\n\n# LOCALIZATION NOTE (responsive.disableTouch): tooltip text for the touch\n# simulation button when it's enabled\nresponsive.disableTouch=Disable touch simulation\n\n# LOCALIZATION NOTE  (responsive.screenshot): tooltip of the screenshot button.\nresponsive.screenshot=Take a screenshot of the viewport\n\n# LOCALIZATION NOTE (responsive.screenshotGeneratedFilename): The auto generated\n# filename.\n# The first argument (%1$S) is the date string in yyyy-mm-dd format and the\n# second argument (%2$S) is the time string in HH.MM.SS format.\nresponsive.screenshotGeneratedFilename=Screen Shot %1$S at %2$S\n\n# LOCALIZATION NOTE (responsive.remoteOnly): Message displayed in the tab's\n# notification box if a user tries to open Responsive Design Mode in a\n# non-remote tab.\nresponsive.remoteOnly=Responsive Design Mode is only available for remote browser tabs, such as those used for web content in multi-process Firefox.\n"

/***/ },
/* 75 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Responsive Mode\n# which is available from the Web Developer sub-menu -> 'Responsive Mode'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n\n# LOCALIZATION NOTE  (responsiveUI.rotate2): tooltip of the rotate button.\nresponsiveUI.rotate2=Rotate\n\n# LOCALIZATION NOTE  (responsiveUI.screenshot): tooltip of the screenshot button.\nresponsiveUI.screenshot=Screenshot\n\n# LOCALIZATION NOTE  (responsiveUI.userAgentPlaceholder): placeholder for the user agent input.\nresponsiveUI.userAgentPlaceholder=Custom User Agent\n\n# LOCALIZATION NOTE (responsiveUI.screenshotGeneratedFilename): The auto generated filename.\n# The first argument (%1$S) is the date string in yyyy-mm-dd format and the second\n# argument (%2$S) is the time string in HH.MM.SS format.\nresponsiveUI.screenshotGeneratedFilename=Screen Shot %1$S at %2$S\n\n# LOCALIZATION NOTE  (responsiveUI.touch): tooltip of the touch button.\nresponsiveUI.touch=Simulate touch events (page reload might be needed)\n\n# LOCALIZATION NOTE  (responsiveUI.addPreset): label of the add preset button.\nresponsiveUI.addPreset=Add Preset\n\n# LOCALIZATION NOTE  (responsiveUI.removePreset): label of the remove preset button.\nresponsiveUI.removePreset=Remove Preset\n\n# LOCALIZATION NOTE  (responsiveUI.customResolution): label of the first item\n# in the menulist at the beginning of the toolbar. For %S is replace with the\n# current size of the page. For example: \"400x600\".\nresponsiveUI.customResolution=%S (custom)\n\n# LOCALIZATION NOTE  (responsiveUI.namedResolution): label of custom items with a name\n# in the menulist of the toolbar.\n# For example: \"320x480 (phone)\".\nresponsiveUI.namedResolution=%S (%S)\n\n# LOCALIZATION NOTE  (responsiveUI.customNamePromptTitle1): prompt title when asking\n# the user to specify a name for a new custom preset.\nresponsiveUI.customNamePromptTitle1=Responsive Design Mode\n\n# LOCALIZATION NOTE (responsiveUI.close1): tooltip text of the close button.\nresponsiveUI.close1=Leave Responsive Design Mode\n\n# LOCALIZATION NOTE  (responsiveUI.customNamePromptMsg): prompt message when asking\n# the user to specify a name for a new custom preset.\nresponsiveUI.customNamePromptMsg=Give a name to the %Sx%S preset\n\n# LOCALIZATION NOTE (responsiveUI.resizer): tooltip showed when\n# overring the resizers.\nresponsiveUI.resizerTooltip=Use the Control key for more precision. Use Shift key for rounded sizes.\n\n# LOCALIZATION NOTE (responsiveUI.needReload): notification that appears\n# when touch events are enabled\nresponsiveUI.needReload=If touch event listeners have been added earlier, the page needs to be reloaded.\nresponsiveUI.notificationReload=Reload\nresponsiveUI.notificationReload_accesskey=R\nresponsiveUI.dontShowReloadNotification=Never show again\nresponsiveUI.dontShowReloadNotification_accesskey=N\n"

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the JavaScript scratchpad\n# which is available from the Web Developer sub-menu -> 'Scratchpad'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE  (export.fileOverwriteConfirmation): This is displayed when\n# the user attempts to save to an already existing file.\nexport.fileOverwriteConfirmation=File exists. Overwrite?\n\n# LOCALIZATION NOTE  (browserWindow.unavailable): This error message is shown\n# when Scratchpad does not find any recently active main browser window.\nbrowserWindow.unavailable=Scratchpad cannot find any browser window to execute the code in.\n\n# LOCALIZATION NOTE  (scratchpadContext.invalid): This error message is shown\n# when user tries to run an operation in Scratchpad in an unsupported context.\nscratchpadContext.invalid=Scratchpad cannot run this operation in the current mode.\n\n# LOCALIZATION NOTE  (openFile.title): This is the file picker title, when you\n# open a file from Scratchpad.\nopenFile.title=Open File\n\n# LOCALIZATION NOTE  (openFile.failed): This is the message displayed when file\n# open fails.\nopenFile.failed=Failed to read the file.\n\n# LOCALIZATION NOTE  (importFromFile.convert.failed): This is the message\n# displayed when file conversion from some charset to Unicode fails.\n# %1 is the name of the charset from which the conversion failed.\nimportFromFile.convert.failed=Failed to convert file to Unicode from %1$S.\n\n# LOCALIZATION NOTE (clearRecentMenuItems.label): This is the label for the\n# menuitem in the 'Open Recent'-menu which clears all recent files.\nclearRecentMenuItems.label=Clear Items\n\n# LOCALIZATION NOTE  (saveFileAs): This is the file picker title, when you save\n# a file in Scratchpad.\nsaveFileAs=Save File As\n\n# LOCALIZATION NOTE  (saveFile.failed): This is the message displayed when file\n# save fails.\nsaveFile.failed=The file save operation failed.\n\n# LOCALIZATION NOTE  (confirmClose): This is message in the prompt dialog when\n# you try to close a scratchpad with unsaved changes.\nconfirmClose=Do you want to save the changes you made to this scratchpad?\n\n# LOCALIZATION NOTE  (confirmClose.title): This is title of the prompt dialog when\n# you try to close a scratchpad with unsaved changes.\nconfirmClose.title=Unsaved Changes\n\n# LOCALIZATION NOTE  (confirmRevert): This is message in the prompt dialog when\n# you try to revert unsaved content of scratchpad.\nconfirmRevert=Do you want to revert the changes you made to this scratchpad?\n\n# LOCALIZATION NOTE  (confirmRevert.title): This is title of the prompt dialog when\n# you try to revert unsaved content of scratchpad.\nconfirmRevert.title=Revert Changes\n\n# LOCALIZATION NOTE  (scratchpadIntro): This is a multi-line comment explaining\n# how to use the Scratchpad. Note that this should be a valid JavaScript\n# comment inside /* and */.\nscratchpadIntro1=/*\\n * This is a JavaScript Scratchpad.\\n *\\n * Enter some JavaScript, then Right Click or choose from the Execute Menu:\\n * 1. Run to evaluate the selected text (%1$S),\\n * 2. Inspect to bring up an Object Inspector on the result (%2$S), or,\\n * 3. Display to insert the result in a comment after the selection. (%3$S)\\n */\\n\\n\n\n# LOCALIZATION NOTE  (notification.browserContext): This is the message displayed\n# over the top of the editor when the user has switched to browser context.\nbrowserContext.notification=This scratchpad executes in the Browser context.\n\n# LOCALIZATION NOTE (help.openDocumentationPage): This returns a localized link with\n# documentation for Scratchpad on MDN.\nhelp.openDocumentationPage=https://developer.mozilla.org/en/Tools/Scratchpad\n\n# LOCALIZATION NOTE (scratchpad.statusBarLineCol): Line, Column\n# information displayed in statusbar when selection is made in\n# Scratchpad.\nscratchpad.statusBarLineCol  = Line %1$S, Col %2$S\n\n# LOCALIZATION NOTE (fileExists.notification): This is the message displayed\n# over the top of the the editor when a file does not exist.\nfileNoLongerExists.notification=This file no longer exists.\n\n# LOCALIZATION NOTE (propertiesFilterPlaceholder): this is the text that\n# appears in the filter text box for the properties view container.\npropertiesFilterPlaceholder=Filter properties\n\n# LOCALIZATION NOTE (connectionTimeout): message displayed when the Remote Scratchpad\n# fails to connect to the server due to a timeout.\nconnectionTimeout=Connection timeout. Check the Error Console on both ends for potential error messages. Reopen the Scratchpad to try again.\n\n# LOCALIZATION NOTE (selfxss.msg): the text that is displayed when\n# a new user of the developer tools pastes code into the console\n# %1 is the text of selfxss.okstring\nselfxss.msg=Scam Warning: Take care when pasting things you don’t understand. This could allow attackers to steal your identity or take control of your computer. Please type ‘%S’ in the scratchpad below to allow pasting.\n\n# LOCALIZATION NOTE (selfxss.msg): the string to be typed\n# in by a new user of the developer tools when they receive the sefxss.msg prompt.\n# Please avoid using non-keyboard characters here\nselfxss.okstring=allow pasting\n"

/***/ },
/* 77 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Debugger\n# which is available from the Web Developer sub-menu -> 'Debugger'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (shadersList.programLabel):\n# This string is displayed in the programs list of the Shader Editor,\n# identifying a set of linked GLSL shaders.\nshadersList.programLabel=Program %S\n\n# LOCALIZATION NOTE (shadersList.blackboxLabel):\n# This string is displayed in the programs list of the Shader Editor, while\n# the user hovers over the checkbox used to toggle blackboxing of a program's\n# associated fragment shader.\nshadersList.blackboxLabel=Toggle geometry visibility\n"

/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (dimensions): This is used to display the dimensions\n# of a node or image, like 100×200.\ndimensions=%S\\u00D7%S\n\n# LOCALIZATION NOTE (groupCheckbox.tooltip): This is used in the SideMenuWidget\n# as the default tooltip of a group checkbox\nsideMenu.groupCheckbox.tooltip=Toggle all checkboxes in this group"

/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Source Editor component.\n# This component is used whenever source code is displayed for the purpose of\n# being edited, inside the Firefox developer tools - current examples are the\n# Scratchpad and the Style Editor tools.\n\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE  (findCmd.promptTitle): This is the dialog title used\n# when the user wants to search for a string in the code. You can\n# access this feature by pressing Ctrl-F on Windows/Linux or Cmd-F on Mac.\nfindCmd.promptTitle=Find…\n\n# LOCALIZATION NOTE  (findCmd.promptMessage): This is the message shown when\n# the user wants to search for a string in the code. You can\n# access this feature by pressing Ctrl-F on Windows/Linux or Cmd-F on Mac.\nfindCmd.promptMessage=Search for:\n\n# LOCALIZATION NOTE  (gotoLineCmd.promptTitle): This is the dialog title used\n# when the user wants to jump to a specific line number in the code. You can\n# access this feature by pressing Ctrl-J on Windows/Linux or Cmd-J on Mac.\ngotoLineCmd.promptTitle=Go to line…\n\n# LOCALIZATION NOTE  (gotoLineCmd.promptMessage): This is the message shown when\n# the user wants to jump to a specific line number in the code. You can\n# access this feature by pressing Ctrl-J on Windows/Linux or Cmd-J on Mac.\ngotoLineCmd.promptMessage=Jump to line number:\n\n# LOCALIZATION NOTE  (annotation.breakpoint.title): This is the text shown in\n# front of any breakpoint annotation when it is displayed as a tooltip in one of\n# the editor gutters. This feature is used in the JavaScript Debugger.\nannotation.breakpoint.title=Breakpoint: %S\n\n# LOCALIZATION NOTE  (annotation.currentLine): This is the text shown in\n# a tooltip displayed in any of the editor gutters when the user hovers the\n# current line.\nannotation.currentLine=Current line\n\n# LOCALIZATION NOTE  (annotation.debugLocation.title): This is the text shown in\n# a tooltip displayed in any of the editor gutters when the user hovers the\n# current debugger location. The debugger can pause the JavaScript execution at\n# user-defined lines.\nannotation.debugLocation.title=Current step: %S\n\n# LOCALIZATION NOTE  (autocompletion.docsLink): This is the text shown on\n# the link inside of the documentation popup.  If you type 'document' in Scratchpad\n# then press Shift+Space you can see the popup.\nautocompletion.docsLink=docs\n\n# LOCALIZATION NOTE  (autocompletion.notFound): This is the text shown in\n# the documentation popup if Tern fails to find a type for the object.\nautocompletion.notFound=not found\n\n# LOCALIZATION NOTE  (jumpToLine.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to jump to\n# a specific line in the editor.\njumpToLine.commandkey=J\n\n# LOCALIZATION NOTE  (toggleComment.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to either\n# comment or uncomment selected lines in the editor.\ntoggleComment.commandkey=/\n\n# LOCALIZATION NOTE  (indentLess.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to reduce\n# indentation level in CodeMirror. However, its default value also used by\n# the Toolbox to switch between tools so we disable it.\n#\n# DO NOT translate this key without proper synchronization with toolbox.dtd.\nindentLess.commandkey=[\n\n# LOCALIZATION NOTE  (indentMore.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to increase\n# indentation level in CodeMirror. However, its default value also used by\n# the Toolbox to switch between tools\n#\n# DO NOT translate this key without proper synchronization with toolbox.dtd.\nindentMore.commandkey=]\n\n# LOCALIZATION NOTE  (moveLineUp.commandkey): This is the combination of keys\n# used to move the current line up.\n# Do not localize \"Alt\", \"Up\", or change the format of the string. These are key\n# identifiers, not messages displayed to the user.\nmoveLineUp.commandkey=Alt-Up\n\n# LOCALIZATION NOTE  (moveLineDown.commandkey): This is the combination of keys\n# used to move the current line up.\n# Do not localize \"Alt\", \"Down\", or change the format of the string. These are\n# key identifiers, not messages displayed to the user.\nmoveLineDown.commandkey=Alt-Down\n\n# LOCALIZATION NOTE  (autocompletion.commandkey): This is the key, used with\n# Ctrl, for code autocompletion.\n# Do not localize \"Space\", it's the key identifier, not a message displayed to\n# the user.\nautocompletion.commandkey=Space\n\n# LOCALIZATION NOTE  (showInformation2.commandkey): This is the combination of\n# keys used to display more information, like type inference.\n# Do not localize \"Shift\", \"Ctrl\", \"Space\", or change the format of the string.\n# These are key identifiers, not messages displayed to the user.\nshowInformation2.commandkey=Shift-Ctrl-Space\n\n# LOCALIZATION NOTE  (find.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to find\n# the typed search\nfind.commandkey=F\n\n# LOCALIZATION NOTE  (findAgain.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to find\n# again the typed search\nfindAgain.commandkey=G\n"

/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (optionsButton.tooltip): This is used as the tooltip\n# for the options panel tab.\noptionsButton.tooltip=Toolbox Options\n\n# LOCALIZATION NOTE (options.label): This is used as the label of the tab in\n# the devtools window.\noptions.label=Options\n\n# LOCALIZATION NOTE (options.panelLabel): This is used as the label for the\n# toolbox panel.\noptions.panelLabel=Toolbox Options Panel\n\n# LOCALIZATION NOTE (options.darkTheme.label2)\n# Used as a label for dark theme\noptions.darkTheme.label2=Dark\n\n# LOCALIZATION NOTE (options.lightTheme.label2)\n# Used as a label for light theme\noptions.lightTheme.label2=Light\n\n# LOCALIZATION NOTE (options.firebugTheme.label2)\n# Used as a label for Firebug theme\noptions.firebugTheme.label2=Firebug\n\n# LOCALIZATION NOTE (performance.label):\n# This string is displayed in the title of the tab when the profiler is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nperformance.label=Performance\n\n# LOCALIZATION NOTE (performance.panelLabel):\n# This is used as the label for the toolbox panel.\nperformance.panelLabel=Performance Panel\n\n# LOCALIZATION NOTE (performance.commandkey, performance.accesskey)\n# Used for the menuitem in the tool menu\nperformance.commandkey=VK_F5\nperformance.accesskey=P\n\n# LOCALIZATION NOTE (performance.tooltip):\n# This string is displayed in the tooltip of the tab when the profiler is\n# displayed inside the developer tools window.\n# Keyboard shortcut for Performance Tools will be shown inside brackets.\nperformance.tooltip=Performance (%S)\n\n# LOCALIZATION NOTE (MenuWebconsole.label): the string displayed in the Tools\n# menu as a shortcut to open the devtools with the Web Console tab selected.\nMenuWebconsole.label=Web Console\n\n# LOCALIZATION NOTE (ToolboxTabWebconsole.label): the string displayed as the\n# label of the tab in the devtools window.\nToolboxTabWebconsole.label=Console\n\n# LOCALIZATION NOTE (ToolboxWebConsole.panelLabel): the string used as the\n# label for the toolbox panel.\nToolboxWebConsole.panelLabel=Console Panel\n\n# LOCALIZATION NOTE (ToolboxWebconsole.tooltip2): the string displayed in the\n# tooltip of the tab when the Web Console is displayed inside the developer\n# tools window.\n# Keyboard shortcut for Console will be shown inside the brackets.\nToolboxWebconsole.tooltip2=Web Console (%S)\n\ncmd.commandkey=K\nwebConsoleCmd.accesskey=W\n\n# LOCALIZATION NOTE (ToolboxDebugger.label):\n# This string is displayed in the title of the tab when the debugger is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxDebugger.label=Debugger\n\n# LOCALIZATION NOTE (ToolboxDebugger.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxDebugger.panelLabel=Debugger Panel\n\n# LOCALIZATION NOTE (ToolboxDebugger.tooltip2):\n# This string is displayed in the tooltip of the tab when the debugger is\n# displayed inside the developer tools window..\n# A keyboard shortcut for JS Debugger will be shown inside brackets.\nToolboxDebugger.tooltip2=JavaScript Debugger (%S)\n\n# LOCALIZATION NOTE (debuggerMenu.commandkey, debuggerMenu.accesskey)\n# Used for the menuitem in the tool menu\ndebuggerMenu.commandkey=S\ndebuggerMenu.accesskey=D\n\n# LOCALIZATION NOTE (ToolboxStyleEditor.label):\n# This string is displayed in the title of the tab when the style editor is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxStyleEditor.label=Style Editor\n\n# LOCALIZATION NOTE (ToolboxStyleEditor.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxStyleEditor.panelLabel=Style Editor Panel\n\n# LOCALIZATION NOTE (ToolboxStyleEditor.tooltip3):\n# This string is displayed in the tooltip of the tab when the style editor is\n# displayed inside the developer tools window.\n# A keyboard shortcut for Stylesheet Editor will be shown inside the latter pair of brackets.\nToolboxStyleEditor.tooltip3=Stylesheet Editor (CSS) (%S)\n\n# LOCALIZATION NOTE  (open.commandkey): This the key to use in\n# conjunction with shift to open the style editor\nopen.commandkey=VK_F7\n\n# LOCALIZATION NOTE (open.accesskey): The access key used to open the style\n# editor.\nopen.accesskey=l\n\n# LOCALIZATION NOTE (ToolboxShaderEditor.label):\n# This string is displayed in the title of the tab when the Shader Editor is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxShaderEditor.label=Shader Editor\n\n# LOCALIZATION NOTE (ToolboxShaderEditor.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxShaderEditor.panelLabel=Shader Editor Panel\n\n# LOCALIZATION NOTE (ToolboxShaderEditor.tooltip):\n# This string is displayed in the tooltip of the tab when the Shader Editor is\n# displayed inside the developer tools window.\nToolboxShaderEditor.tooltip=Live GLSL shader language editor for WebGL\n\n# LOCALIZATION NOTE (ToolboxCanvasDebugger.label):\n# This string is displayed in the title of the tab when the Shader Editor is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxCanvasDebugger.label=Canvas\n\n# LOCALIZATION NOTE (ToolboxCanvasDebugger.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxCanvasDebugger.panelLabel=Canvas Panel\n\n# LOCALIZATION NOTE (ToolboxCanvasDebugger.tooltip):\n# This string is displayed in the tooltip of the tab when the Shader Editor is\n# displayed inside the developer tools window.\nToolboxCanvasDebugger.tooltip=Tools to inspect and debug <canvas> contexts\n\n# LOCALIZATION NOTE (ToolboxWebAudioEditor1.label):\n# This string is displayed in the title of the tab when the Web Audio Editor\n# is displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxWebAudioEditor1.label=Web Audio\n\n# LOCALIZATION NOTE (ToolboxWebAudioEditor1.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxWebAudioEditor1.panelLabel=Web Audio Panel\n\n# LOCALIZATION NOTE (ToolboxWebAudioEditor1.tooltip):\n# This string is displayed in the tooltip of the tab when the Web Audio Editor is\n# displayed inside the developer tools window.\nToolboxWebAudioEditor1.tooltip=Web Audio context visualizer and audio node inspector\n\n# LOCALIZATION NOTE (inspector.*)\n# Used for the menuitem in the tool menu\ninspector.label=Inspector\ninspector.commandkey=C\ninspector.accesskey=I\n\n# LOCALIZATION NOTE (inspector.panelLabel)\n# Labels applied to the panel and views within the panel in the toolbox\ninspector.panelLabel=Inspector Panel\n\n# LOCALIZATION NOTE (inspector.tooltip2)\n# Keyboard shortcut for DOM and Style Inspector will be shown inside brackets.\ninspector.tooltip2=DOM and Style Inspector (%S)\n\n# LOCALIZATION NOTE (netmonitor.label):\n# This string is displayed in the title of the tab when the Network Monitor is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nnetmonitor.label=Network\n\n# LOCALIZATION NOTE (netmonitor.panelLabel):\n# This is used as the label for the toolbox panel.\nnetmonitor.panelLabel=Network Panel\n\n# LOCALIZATION NOTE (netmonitor.commandkey, netmonitor.accesskey)\n# Used for the menuitem in the tool menu\nnetmonitor.commandkey=Q\nnetmonitor.accesskey=N\n\n# LOCALIZATION NOTE (netmonitor.tooltip2):\n# This string is displayed in the tooltip of the tab when the Network Monitor is\n# displayed inside the developer tools window.\n# Keyboard shortcut for Network Monitor will be shown inside the brackets.\nnetmonitor.tooltip2=Network Monitor (%S)\n\n# LOCALIZATION NOTE  (storage.commandkey): This the key to use in\n# conjunction with shift to open the storage editor\nstorage.commandkey=VK_F9\n\n# LOCALIZATION NOTE (storage.accesskey): The access key used to open the storage\n# editor.\nstorage.accesskey=a\n\n# LOCALIZATION NOTE (storage.label):\n# This string is displayed as the label of the tab in the developer tools window\nstorage.label=Storage\n\n# LOCALIZATION NOTE (storage.menuLabel):\n# This string is displayed in the Tools menu as a shortcut to open the devtools\n# with the Storage Inspector tab selected.\nstorage.menuLabel=Storage Inspector\n\n# LOCALIZATION NOTE (storage.panelLabel):\n# This string is used as the aria-label for the iframe of the Storage Inspector\n# tool in developer tools toolbox.\nstorage.panelLabel=Storage Panel\n\n# LOCALIZATION NOTE (storage.tooltip3):\n# This string is displayed in the tooltip of the tab when the storage editor is\n# displayed inside the developer tools window.\n# A keyboard shortcut for Storage Inspector will be shown inside the brackets.\nstorage.tooltip3=Storage Inspector (Cookies, Local Storage, …) (%S)\n\n# LOCALIZATION NOTE (scratchpad.label): this string is displayed in the title of\n# the tab when the Scratchpad is displayed inside the developer tools window and\n# in the Developer Tools Menu.\nscratchpad.label=Scratchpad\n\n# LOCALIZATION NOTE (scratchpad.panelLabel): this is used as the\n# label for the toolbox panel.\nscratchpad.panelLabel=Scratchpad Panel\n\n# LOCALIZATION NOTE (scratchpad.tooltip):  This string is displayed in the\n# tooltip of the tab when the Scratchpad is displayed inside the developer tools\n# window.\nscratchpad.tooltip=Scratchpad\n\n# LOCALIZATION NOTE (memory.label): This string is displayed in the title of the\n# tab when the memory tool is displayed inside the developer tools window and in\n# the Developer Tools Menu.\nmemory.label=Memory\n\n# LOCALIZATION NOTE (memory.panelLabel): This is used as the label for the\n# toolbox panel.\nmemory.panelLabel=Memory Panel\n\n# LOCALIZATION NOTE (memory.tooltip): This string is displayed in the tooltip of\n# the tab when the memory tool is displayed inside the developer tools window.\nmemory.tooltip=Memory\n\n# LOCALIZATION NOTE (dom.label):\n# This string is displayed in the title of the tab when the DOM panel is\n# displayed inside the developer tools window and in the Developer Tools Menu.\ndom.label=DOM\n\n# LOCALIZATION NOTE (dom.panelLabel):\n# This is used as the label for the toolbox panel.\ndom.panelLabel=DOM Panel\n\n# LOCALIZATION NOTE (dom.commandkey, dom.accesskey)\n# Used for the menuitem in the tool menu\ndom.commandkey=W\ndom.accesskey=D\n\n# LOCALIZATION NOTE (dom.tooltip):\n# This string is displayed in the tooltip of the tab when the DOM is\n# displayed inside the developer tools window.\n# Keyboard shortcut for DOM panel will be shown inside the brackets.\ndom.tooltip=DOM (%S)\n"

/***/ },
/* 81 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Storage Editor tool.\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE (storage.filter.key):\n# Key shortcut used to focus the filter box on top of the data view\nstorage.filter.key=CmdOrCtrl+F\n\n# LOCALIZATION NOTE (tree.emptyText):\n# This string is displayed when the Storage Tree is empty. This can happen when\n# there are no websites on the current page (about:blank)\ntree.emptyText=No hosts on the page\n\n# LOCALIZATION NOTE (table.emptyText):\n# This string is displayed when there are no rows in the Storage Table for the\n# selected host.\ntable.emptyText=No data present for selected host\n\n# LOCALIZATION NOTE (tree.labels.*):\n# These strings are the labels for Storage type groups present in the Storage\n# Tree, like cookies, local storage etc.\ntree.labels.cookies=Cookies\ntree.labels.localStorage=Local Storage\ntree.labels.sessionStorage=Session Storage\ntree.labels.indexedDB=Indexed DB\ntree.labels.Cache=Cache Storage\n\n# LOCALIZATION NOTE (table.headers.*.*):\n# These strings are the header names of the columns in the Storage Table for\n# each type of storage available through the Storage Tree to the side.\ntable.headers.cookies.name=Name\ntable.headers.cookies.path=Path\ntable.headers.cookies.host=Domain\ntable.headers.cookies.expires=Expires on\ntable.headers.cookies.value=Value\ntable.headers.cookies.lastAccessed=Last accessed on\ntable.headers.cookies.creationTime=Created on\n# LOCALIZATION NOTE (table.headers.cookies.isHttpOnly):\n# This string is used in the header for the column which denotes whether a\n# cookie is HTTP only or not.\ntable.headers.cookies.isHttpOnly=isHttpOnly\n# LOCALIZATION NOTE (table.headers.cookies.isSecure):\n# This string is used in the header for the column which denotes whether a\n# cookie can be accessed via a secure channel only or not.\ntable.headers.cookies.isSecure=isSecure\n# LOCALIZATION NOTE (table.headers.cookies.isDomain):\n# This string is used in the header for the column which denotes whether a\n# cookie is a domain cookie only or not.\ntable.headers.cookies.isDomain=isDomain\n\ntable.headers.localStorage.name=Key\ntable.headers.localStorage.value=Value\n\ntable.headers.sessionStorage.name=Key\ntable.headers.sessionStorage.value=Value\n\ntable.headers.Cache.url=URL\ntable.headers.Cache.status=Status\n\ntable.headers.indexedDB.name=Key\ntable.headers.indexedDB.db=Database Name\ntable.headers.indexedDB.objectStore=Object Store Name\ntable.headers.indexedDB.value=Value\ntable.headers.indexedDB.origin=Origin\ntable.headers.indexedDB.version=Version\ntable.headers.indexedDB.objectStores=Object Stores\ntable.headers.indexedDB.keyPath=Key\ntable.headers.indexedDB.autoIncrement=Auto Increment\ntable.headers.indexedDB.indexes=Indexes\n\n# LOCALIZATION NOTE (label.expires.session):\n# This string is displayed in the expires column when the cookie is Session\n# Cookie\nlabel.expires.session=Session\n\n# LOCALIZATION NOTE (storage.search.placeholder):\n# This is the placeholder text in the sidebar search box\nstorage.search.placeholder=Filter values\n\n# LOCALIZATION NOTE (storage.data.label):\n# This is the heading displayed over the item value in the sidebar\nstorage.data.label=Data\n\n# LOCALIZATION NOTE (storage.parsedValue.label):\n# This is the heading displayed over the item parsed value in the sidebar\nstorage.parsedValue.label=Parsed Value\n\n# LOCALIZATION NOTE (storage.popupMenu.deleteLabel):\n# Label of popup menu action to delete storage item.\nstorage.popupMenu.deleteLabel=Delete “%S”\n\n# LOCALIZATION NOTE (storage.popupMenu.deleteAllLabel):\n# Label of popup menu action to delete all storage items.\nstorage.popupMenu.deleteAllFromLabel=Delete All From “%S”\n\n# LOCALIZATION NOTE (storage.idb.deleteBlocked):\n# Warning notification when IndexedDB database could not be deleted immediately.\nstorage.idb.deleteBlocked=Database “%S” will be deleted after all connections are closed.\n\n# LOCALIZATION NOTE (storage.idb.deleteError):\n# Error notification when IndexedDB database could not be deleted.\nstorage.idb.deleteError=Database “%S” could not be deleted.\n"

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Style Editor.\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE  (inlineStyleSheet): This is the name used for an style sheet\n# that is declared inline in the <style> element. Shown in the stylesheets list.\n# the argument is the index (order) of the containing <style> element in the\n# document.\ninlineStyleSheet=<inline style sheet #%S>\n\n# LOCALIZATION NOTE  (newStyleSheet): This is the default name for a new\n# user-created style sheet.\nnewStyleSheet=New style sheet #%S\n\n# LOCALIZATION NOTE  (ruleCount.label): Semicolon-separated list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This is shown in the style sheets list.\n# #1 rule.\n# example: 111 rules.\nruleCount.label=#1 rule.;#1 rules.\n\n# LOCALIZATION NOTE  (error-load): This is shown when loading fails.\nerror-load=Style sheet could not be loaded.\n\n# LOCALIZATION NOTE  (error-save): This is shown when saving fails.\nerror-save=Style sheet could not be saved.\n\n# LOCALIZATION NOTE  (error-compressed): This is shown when we can't show\n# coverage information because the css source is compressed.\nerror-compressed=Can’t show coverage information for compressed stylesheets\n\n# LOCALIZATION NOTE  (importStyleSheet.title): This is the file picker title,\n# when you import a style sheet into the Style Editor.\nimportStyleSheet.title=Import style sheet\n\n# LOCALIZATION NOTE  (importStyleSheet.filter): This is the *.css filter title\nimportStyleSheet.filter=CSS files\n\n# LOCALIZATION NOTE  (saveStyleSheet.title): This is the file picker title,\n# when you save a style sheet from the Style Editor.\nsaveStyleSheet.title=Save style sheet\n\n# LOCALIZATION NOTE  (saveStyleSheet.filter): This is the *.css filter title\nsaveStyleSheet.filter=CSS files\n\n# LOCALIZATION NOTE  (saveStyleSheet.commandkey): This the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to Save\nsaveStyleSheet.commandkey=S\n\n"

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ntoolboxDockButtons.bottom.tooltip=Dock to bottom of browser window\ntoolboxDockButtons.side.tooltip=Dock to side of browser window\ntoolboxDockButtons.window.tooltip=Show in separate window\n\n# LOCALIZATION NOTE (toolboxDockButtons.bottom.minimize): This string is shown\n# as a tooltip that appears in the toolbox when it is in \"bottom host\" mode and\n# when hovering over the minimize button in the toolbar. When clicked, the\n# button minimizes the toolbox so that just the toolbar is visible at the\n# bottom.\ntoolboxDockButtons.bottom.minimize=Minimize the toolbox\n\n# LOCALIZATION NOTE (toolboxDockButtons.bottom.maximize): This string is shown\n# as a tooltip that appears in the toolbox when it is in \"bottom host\" mode and\n# when hovering over the maximize button in the toolbar. When clicked, the\n# button maximizes the toolbox again (if it had been minimized before) so that\n# the whole toolbox is visible again.\ntoolboxDockButtons.bottom.maximize=Maximize the toolbox\n\n# LOCALIZATION NOTE (toolboxToggleButton.errors): Semi-colon list of plural\n# forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of errors in the current web page\ntoolboxToggleButton.errors=#1 error;#1 errors\n\n# LOCALIZATION NOTE (toolboxToggleButton.warnings): Semi-colon list of plural\n# forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of warnings in the current web page\ntoolboxToggleButton.warnings=#1 warning;#1 warnings\n\n# LOCALIZATION NOTE (toolboxToggleButton.tooltip): This string is shown\n# as tooltip in the developer toolbar to open/close the developer tools.\n# It's using toolboxToggleButton.errors as first and\n# toolboxToggleButton.warnings as second argument to show the number of errors\n# and warnings.\ntoolboxToggleButton.tooltip=%1$S, %2$S\\nClick to toggle the developer tools.\n\n# LOCALIZATION NOTE (toolbar.closeButton.tooltip)\n# Used as a message in tooltip when overing the close button of the Developer\n# Toolbar.\ntoolbar.closeButton.tooltip=Close Developer Toolbar\n\n# LOCALIZATION NOTE (toolbar.toolsButton.tooltip)\n# Used as a message in tooltip when overing the wrench icon of the Developer\n# Toolbar, which toggle the developer toolbox.\ntoolbar.toolsButton.tooltip=Toggle developer tools\n\n# LOCALIZATION NOTE (toolbox.titleTemplate1): This is the template\n# used to format the title of the toolbox.\n# The URL of the page being targeted: %1$S.\ntoolbox.titleTemplate1=Developer Tools - %1$S\n\n# LOCALIZATION NOTE (toolbox.titleTemplate2): This is the template\n# used to format the title of the toolbox.\n# The page title or other name for the thing being targeted: %1$S\n# The URL of the page being targeted: %2$S.\ntoolbox.titleTemplate2=Developer Tools - %1$S - %2$S\n\n# LOCALIZATION NOTE (toolbox.defaultTitle): This is used as the tool\n# name when no tool is selected.\ntoolbox.defaultTitle=Developer Tools\n\n# LOCALIZATION NOTE (toolbox.label): This is used as the label for the\n# toolbox as a whole\ntoolbox.label=Developer Tools\n\n# LOCALIZATION NOTE (options.toolNotSupported): This is the template\n# used to add a * marker to the label for the Options Panel tool checkbox for the\n# tool which is not supported for the current toolbox target.\n# The name of the tool: %1$S.\noptions.toolNotSupportedMarker=%1$S *\n\n# LOCALIZATION NOTE (scratchpad.keycode)\n# Used for opening scratchpad from the detached toolbox window\n# Needs to match scratchpad.keycode from browser.dtd\nscratchpad.keycode=VK_F4\n\n# LOCALIZATION NOTE (browserConsoleCmd.commandkey)\n# Used for toggling the browser console from the detached toolbox window\n# Needs to match browserConsoleCmd.commandkey from browser.dtd\nbrowserConsoleCmd.commandkey=j\n\n# LOCALIZATION NOTE (pickButton.tooltip)\n# This is the tooltip of the pick button in the toolbox toolbar\npickButton.tooltip=Pick an element from the page\n\n# LOCALIZATION NOTE (sidebar.showAllTabs.tooltip)\n# This is the tooltip shown when hover over the '…' button in the tabbed side\n# bar, when there's no enough space to show all tabs at once\nsidebar.showAllTabs.tooltip=All tabs\n\n# LOCALIZATION NOTE (toolbox.noContentProcess.message)\n# Used as a message in the alert displayed when trying to open a browser\n# content toolbox and there is no content process running\ntoolbox.noContentProcess.message=No content process running.\n\n# LOCALIZATION NOTE (toolbox.viewCssSourceInStyleEditor.label)\n# Used as a message in either tooltips or contextual menu items to open the\n# corresponding URL as a css file in the Style-Editor tool.\n# DEV NOTE: Mostly used wherever toolbox.viewSourceInStyleEditor is used.\ntoolbox.viewCssSourceInStyleEditor.label=Open File in Style-Editor\n\n# LOCALIZATION NOTE (toolbox.viewJsSourceInDebugger.label)\n# Used as a message in either tooltips or contextual menu items to open the\n# corresponding URL as a js file in the Debugger tool.\n# DEV NOTE: Mostly used wherever toolbox.viewSourceInDebugger is used.\ntoolbox.viewJsSourceInDebugger.label=Open File in Debugger\n\ntoolbox.resumeOrderWarning=Page did not resume after the debugger was attached. To fix this, please close and re-open the toolbox.\n\n# LOCALIZATION NOTE (toolbox.options.key)\n# Key shortcut used to open the options panel\ntoolbox.options.key=CmdOrCtrl+Shift+O\n\n# LOCALIZATION NOTE (toolbox.help.key)\n# Key shortcut used to open the options panel\ntoolbox.help.key=F1\n\n# LOCALIZATION NOTE (toolbox.nextTool.key)\n# Key shortcut used to select the next tool\ntoolbox.nextTool.key=CmdOrCtrl+]\n\n# LOCALIZATION NOTE (toolbox.previousTool.key)\n# Key shortcut used to select the previous tool\ntoolbox.previousTool.key=CmdOrCtrl+[\n\n# LOCALIZATION NOTE (toolbox.zoom*.key)\n# Key shortcuts used to zomm in/out or reset the toolbox\n# Should match fullZoom*Cmd.commandkey values from browser.dtd\ntoolbox.zoomIn.key=CmdOrCtrl+Plus\ntoolbox.zoomIn2.key=CmdOrCtrl+=\ntoolbox.zoomIn3.key=\n\ntoolbox.zoomOut.key=CmdOrCtrl+-\ntoolbox.zoomOut2.key=\n\ntoolbox.zoomReset.key=CmdOrCtrl+0\ntoolbox.zoomReset2.key=\n\n# LOCALIZATION NOTE (toolbox.reload*.key)\n# Key shortcuts used to reload the page\ntoolbox.reload.key=CmdOrCtrl+R\ntoolbox.reload2.key=F5\n\n# LOCALIZATION NOTE (toolbox.forceReload*.key)\n# Key shortcuts used to force reload of the page by bypassing caches\ntoolbox.forceReload.key=CmdOrCtrl+Shift+R\ntoolbox.forceReload2.key=CmdOrCtrl+F5\n\n# LOCALIZATION NOTE (toolbox.minimize.key)\n# Key shortcut used to minimize the toolbox\ntoolbox.minimize.key=CmdOrCtrl+Shift+U\n\n# LOCALIZATION NOTE (toolbox.toggleHost.key)\n# Key shortcut used to move the toolbox in bottom or side of the browser window\ntoolbox.toggleHost.key=CmdOrCtrl+Shift+D\n"

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Web Audio tool\n# which is available in the developer tools' toolbox, once\n# enabled in the developer tools' preference \"Web Audio\".\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (collapseInspector): This is the tooltip for the button\n# that collapses the inspector in the web audio tool UI.\ncollapseInspector=Collapse inspector\n\n# LOCALIZATION NOTE (expandInspector): This is the tooltip for the button\n# that expands the inspector in the web audio tool UI.\nexpandInspector=Expand inspector\n"

/***/ },
/* 85 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n\n# LOCALIZATION NOTE (timestampFormat): %1$02S = hours (24-hour clock),\n# %2$02S = minutes, %3$02S = seconds, %4$03S = milliseconds.\ntimestampFormat=%02S:%02S:%02S.%03S\n\nhelperFuncUnsupportedTypeError=Can’t call pprint on this type of object.\n\n# LOCALIZATION NOTE (NetworkPanel.deltaDurationMS): this string is used to\n# show the duration between two network events (e.g request and response\n# header or response header and response body). Parameters: %S is the duration.\nNetworkPanel.durationMS=%Sms\n\nConsoleAPIDisabled=The Web Console logging API (console.log, console.info, console.warn, console.error) has been disabled by a script on this page.\n\n# LOCALIZATION NOTE (webConsoleWindowTitleAndURL): the Web Console floating\n# panel title. For RTL languages you need to set the LRM in the string to give\n# the URL the correct direction. Parameters: %S is the web page URL.\nwebConsoleWindowTitleAndURL=Web Console - %S\n\n# LOCALIZATION NOTE (webConsoleXhrIndicator): the indicator displayed before\n# a URL in the Web Console that was requested using an XMLHttpRequest.\n# Should probably be the same as &btnConsoleXhr; in webConsole.dtd\nwebConsoleXhrIndicator=XHR\n\n# LOCALIZATION NOTE (webConsoleMixedContentWarning): the message displayed\n# after a URL in the Web Console that has been flagged for Mixed Content (i.e.\n# http content in an https page).\nwebConsoleMixedContentWarning=Mixed Content\n\n# LOCALIZATION NOTE (webConsoleMoreInfoLabel): the more info tag displayed\n# after security related web console messages.\nwebConsoleMoreInfoLabel=Learn More\n\n# LOCALIZATION NOTE (scratchpad.linkText): the text used in the right hand\n# side of the Web Console command line when JavaScript is being entered, to\n# indicate how to jump into scratchpad mode.\nscratchpad.linkText=Shift+RETURN - Open in Scratchpad\n\n# LOCALIZATION NOTE (reflow.*): the console displays reflow activity.\n# We can get 2 kind of lines: with JS link or without JS link. It looks like\n# that:\n# reflow: 12ms\n# reflow: 12ms function foobar, file.js line 42\n# The 2nd line, from \"function\" to the end of the line, is a link to the\n# JavaScript debugger.\nreflow.messageWithNoLink=reflow: %Sms\nreflow.messageWithLink=reflow: %Sms\\u0020\nreflow.messageLinkText=function %1$S, %2$S line %3$S\n\n# LOCALIZATION NOTE (stacktrace.anonymousFunction): this string is used to\n# display JavaScript functions that have no given name - they are said to be\n# anonymous. Test console.trace() in the webconsole.\nstacktrace.anonymousFunction=<anonymous>\n\n# LOCALIZATION NOTE (stacktrace.asyncStack): this string is used to\n# indicate that a given stack frame has an async parent.\n# %S is the \"Async Cause\" of the frame.\nstacktrace.asyncStack=(Async: %S)\n\n# LOCALIZATION NOTE (timerStarted): this string is used to display the result\n# of the console.time() call. Parameters: %S is the name of the timer.\ntimerStarted=%S: timer started\n\n# LOCALIZATION NOTE (timeEnd): this string is used to display the result of\n# the console.timeEnd() call. Parameters: %1$S is the name of the timer, %2$S\n# is the number of milliseconds.\ntimeEnd=%1$S: %2$Sms\n\n# LOCALIZATION NOTE (consoleCleared): this string is displayed when receiving a\n# call to console.clear() to let the user know the previous messages of the\n# console have been removed programmatically.\nconsoleCleared=Console was cleared.\n\n# LOCALIZATION NOTE (noCounterLabel): this string is used to display\n# count-messages with no label provided.\nnoCounterLabel=<no label>\n\n# LOCALIZATION NOTE (Autocomplete.blank): this string is used when inputnode\n# string containing anchor doesn't matches to any property in the content.\nAutocomplete.blank=  <- no result\n\nmaxTimersExceeded=The maximum allowed number of timers in this page was exceeded.\n\n# LOCALIZATION NOTE (maxCountersExceeded): Error message shown when the maximum\n# number of console.count()-counters was exceeded.\nmaxCountersExceeded=The maximum allowed number of counters in this page was exceeded.\n\n# LOCALIZATION NOTE (longStringEllipsis): the string displayed after a long\n# string. This string is clickable such that the rest of the string is\n# retrieved from the server.\nlongStringEllipsis=[…]\n\n# LOCALIZATION NOTE (longStringTooLong): the string displayed after the user\n# tries to expand a long string.\nlongStringTooLong=The string you are trying to view is too long to be displayed by the Web Console.\n\n# LOCALIZATION NOTE (connectionTimeout): message displayed when the Remote Web\n# Console fails to connect to the server due to a timeout.\nconnectionTimeout=Connection timeout. Check the Error Console on both ends for potential error messages. Reopen the Web Console to try again.\n\n# LOCALIZATION NOTE (propertiesFilterPlaceholder): this is the text that\n# appears in the filter text box for the properties view container.\npropertiesFilterPlaceholder=Filter properties\n\n# LOCALIZATION NOTE (emptyPropertiesList): the text that is displayed in the\n# properties pane when there are no properties to display.\nemptyPropertiesList=No properties to display\n\n# LOCALIZATION NOTE (messageRepeats.tooltip2): the tooltip text that is displayed\n# when you hover the red bubble that shows how many times a message is repeated\n# in the web console output.\n# This is a semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of message repeats\n# example: 3 repeats\nmessageRepeats.tooltip2=#1 repeat;#1 repeats\n\n# LOCALIZATION NOTE (openNodeInInspector): the text that is displayed in a\n# tooltip when hovering over the inspector icon next to a DOM Node in the console\n# output\nopenNodeInInspector=Click to select the node in the inspector\n\n# LOCALIZATION NOTE (cdFunctionInvalidArgument): the text that is displayed when\n# cd() is invoked with an invalid argument.\ncdFunctionInvalidArgument=Cannot cd() to the given window. Invalid argument.\n\n# LOCALIZATION NOTE (selfxss.msg): the text that is displayed when\n# a new user of the developer tools pastes code into the console\n# %1 is the text of selfxss.okstring\nselfxss.msg=Scam Warning: Take care when pasting things you don’t understand. This could allow attackers to steal your identity or take control of your computer. Please type ‘%S’ below (no need to press enter) to allow pasting.\n\n# LOCALIZATION NOTE (selfxss.msg): the string to be typed\n# in by a new user of the developer tools when they receive the sefxss.msg prompt.\n# Please avoid using non-keyboard characters here\nselfxss.okstring=allow pasting\n\n# LOCALIZATION NOTE (messageToggleDetails): the text that is displayed when\n# you hover the arrow for expanding/collapsing the message details. For\n# console.error() and other messages we show the stacktrace.\nmessageToggleDetails=Show/hide message details.\n\n# LOCALIZATION NOTE (emptySlotLabel): the text is displayed when an Array\n# with empty slots is printed to the console.\n# This is a semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of empty slots\n# example: 1 empty slot\n# example: 5 empty slots\nemptySlotLabel=#1 empty slot;#1 empty slots\n\n# LOCALIZATION NOTE (table.index, table.iterationIndex, table.key, table.value):\n# the column header displayed in the console table widget.\ntable.index=(index)\ntable.iterationIndex=(iteration index)\ntable.key=Key\ntable.value=Values\n\n# LOCALIZATION NOTE (severity.error, severity.warn, severity.info, severity.log):\n# tooltip for icons next to console output\nseverity.error=Error\nseverity.warn=Warning\nseverity.info=Info\nseverity.log=Log\n\n# LOCALIZATION NOTE (level.error, level.warn, level.info, level.log, level.debug):\n# tooltip for icons next to console output\nlevel.error=Error\nlevel.warn=Warning\nlevel.info=Info\nlevel.log=Log\nlevel.debug=Debug\n\n# LOCALIZATION NOTE (webconsole.find.key)\n# Key shortcut used to focus the search box on upper right of the console\nwebconsole.find.key=CmdOrCtrl+F\n\n# LOCALIZATION NOTE (webconsole.close.key)\n# Key shortcut used to close the Browser console (doesn't work in regular web console)\nwebconsole.close.key=CmdOrCtrl+W\n\n# LOCALIZATION NOTE (webconsole.clear.key*)\n# Key shortcut used to clear the console output\nwebconsole.clear.key=Ctrl+Shift+L\nwebconsole.clear.keyOSX=Ctrl+L\n"

/***/ },
/* 86 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ntitle_noApp=Firefox WebIDE\ntitle_app=Firefox WebIDE: %S\n\nruntimeButton_label=Select Runtime\nprojectButton_label=Open App\n\nmainProcess_label=Main Process\n\nlocal_runtime=Local Runtime\nremote_runtime=Remote Runtime\nremote_runtime_promptTitle=Remote Runtime\nremote_runtime_promptMessage=hostname:port\n\nimportPackagedApp_title=Select Directory\nimportHostedApp_title=Open Hosted App\nimportHostedApp_header=Enter Manifest URL\n\nselectCustomBinary_title=Select custom B2G binary\nselectCustomProfile_title=Select custom Gaia profile\n\nnotification_showTroubleShooting_label=Troubleshooting\nnotification_showTroubleShooting_accesskey=T\n\n# LOCALIZATION NOTE (project_tab_loading): This is shown as a temporary tab\n# title for browser tab projects when the tab is still loading.\nproject_tab_loading=Loading…\n\n# These messages appear in a notification box when an error occur.\n\nerror_cantInstallNotFullyConnected=Can’t install project. Not fully connected.\nerror_cantInstallValidationErrors=Can’t install project. Validation errors.\nerror_listRunningApps=Can’t get app list from device\n\n# Variable: name of the operation (in english)\nerror_operationTimeout=Operation timed out: %1$S\nerror_operationFail=Operation failed: %1$S\n\n# Variable: app name\nerror_cantConnectToApp=Can’t connect to app: %1$S\n\n# Variable: error message (in english)\nerror_cantFetchAddonsJSON=Can’t fetch the add-on list: %S\n\nerror_appProjectsLoadFailed=Unable to load project list. This can occur if you’ve used this profile with a newer version of Firefox.\nerror_folderCreationFailed=Unable to create project folder in the selected directory.\n\n# Variable: runtime app build ID (looks like this %Y%M%D format) and firefox build ID (same format)\nerror_runtimeVersionTooRecent=The connected runtime has a more recent build date (%1$S) than your desktop Firefox (%2$S) does. This is an unsupported setup and may cause DevTools to fail. Please update Firefox.\n\naddons_stable=stable\naddons_unstable=unstable\n# LOCALIZATION NOTE (addons_simulator_label): This label is shown as the name of\n# a given simulator version in the \"Manage Simulators\" pane.  %1$S: Firefox OS\n# version in the simulator, ex. 1.3.  %2$S: Simulator stability label, ex.\n# \"stable\" or \"unstable\".\naddons_simulator_label=Firefox OS %1$S Simulator (%2$S)\naddons_install_button=install\naddons_uninstall_button=uninstall\naddons_adb_label=ADB Helper Add-on\naddons_adapters_label=Tools Adapters Add-on\naddons_adb_warning=USB devices won’t be detected without this add-on\naddons_status_unknown=?\naddons_status_installed=Installed\naddons_status_uninstalled=Not Installed\naddons_status_preparing=preparing\naddons_status_downloading=downloading\naddons_status_installing=installing\n\nruntimedetails_checkno=no\nruntimedetails_checkyes=yes\nruntimedetails_checkunknown=unknown (requires ADB Helper 0.4.0 or later)\nruntimedetails_notUSBDevice=Not a USB device\n\n# Validation status\nstatus_tooltip=Validation status: %1$S\nstatus_valid=VALID\nstatus_warning=WARNINGS\nstatus_error=ERRORS\nstatus_unknown=UNKNOWN\n\n# Device preferences and settings\ndevice_reset_default=Reset to default\n\n# Simulator options\nsimulator_custom_device=Custom\nsimulator_custom_binary=Custom B2G binary…\nsimulator_custom_profile=Custom Gaia profile…\nsimulator_default_profile=Use default\n"

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./aboutProfiles.properties": 88,
		"./aboutReader.properties": 89,
		"./aboutServiceWorkers.properties": 90,
		"./aboutSupport.properties": 91,
		"./aboutTelemetry.properties": 92,
		"./aboutWebrtc.properties": 93,
		"./autocomplete.properties": 94,
		"./browser.properties": 95,
		"./charsetMenu.properties": 96,
		"./commonDialogs.properties": 97,
		"./config.properties": 98,
		"./console.properties": 99,
		"./contentAreaCommands.properties": 100,
		"./customizeToolbar.properties": 101,
		"./dateFormat.properties": 102,
		"./dialog.properties": 103,
		"./extensions.properties": 104,
		"./fallbackMenubar.properties": 105,
		"./filefield.properties": 106,
		"./filepicker.properties": 107,
		"./findbar.properties": 108,
		"./finddialog.properties": 109,
		"./headsUpDisplay.properties": 110,
		"./intl.properties": 111,
		"./keys.properties": 112,
		"./languageNames.properties": 113,
		"./narrate.properties": 114,
		"./nsTreeSorting.properties": 115,
		"./printdialog.properties": 116,
		"./regionNames.properties": 117,
		"./resetProfile.properties": 118,
		"./viewSource.properties": 119,
		"./wizard.properties": 120
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 87;


/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nname = Profile: %S\nisDefault = Default Profile\nrootDir = Root Directory\n# LOCALIZATION NOTE: localDir is used to show the directory corresponding to\n# the main profile directory that exists for the purpose of storing data on the\n# local filesystem, including cache files or other data files that may not\n# represent critical user data. (e.g., this directory may not be included as\n# part of a backup scheme.)\n# In case localDIr and rootDir are equal, localDir is not shown.\nlocalDir = Local Directory\ncurrentProfile = This is the profile in use and it cannot be deleted.\n\nrename = Rename\nremove = Remove\nsetAsDefault = Set as default profile\nlaunchProfile = Launch profile in new browser\n\nyes = yes\nno = no\n\nrenameProfileTitle = Rename Profile\nrenameProfile = Rename profile %S\n\ninvalidProfileNameTitle = Invalid profile name\ninvalidProfileName = The profile name “%S” is not allowed.\n\ndeleteProfileTitle = Delete Profile\ndeleteProfileConfirm = Deleting a profile will remove the profile from the list of available profiles and cannot be undone.\\nYou may also choose to delete the profile data files, including your settings, certificates and other user-related data. This option will delete the folder “%S” and cannot be undone.\\nWould you like to delete the profile data files?\ndeleteFiles = Delete Files\ndontDeleteFiles = Don’t Delete Files\n\nopenDir = Open Directory\n# LOCALIZATION NOTE (macOpenDir): This is the Mac-specific variant of openDir.\n# This allows us to use the preferred\"Finder\" terminology on Mac.\nmacOpenDir = Show in Finder\n# LOCALIZATION NOTE (winOpenDir): This is the Windows-specific variant of\n# openDir.\nwinOpenDir = Show Folder\n"

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#LOCALIZATION NOTE (aboutReader.loading2):\n# Use the unicode ellipsis char, \\u2026,\n# or use \"...\" if \\u2026 doesn't suit traditions in your locale.\naboutReader.loading2=Loading…\naboutReader.loadError=Failed to load article from page\n\naboutReader.colorScheme.light=Light\naboutReader.colorScheme.dark=Dark\naboutReader.colorScheme.sepia=Sepia\naboutReader.colorScheme.auto=Auto\n\n# LOCALIZATION NOTE (aboutReader.fontType.serif, aboutReader.fontType.sans-serif):\n# These are the styles of typeface that are options in the reader view controls.\naboutReader.fontType.serif=Serif\naboutReader.fontType.sans-serif=Sans-serif\n\n# LOCALIZATION NOTE (aboutReader.fontTypeSample): String used to sample font types.\naboutReader.fontTypeSample=Aa\n\naboutReader.toolbar.close=Close Reader View\naboutReader.toolbar.typeControls=Type controls\n\n# These are used for the Reader View toolbar button and the menuitem within the\n# View menu.\nreaderView.enter=Enter Reader View\nreaderView.enter.accesskey=R\nreaderView.close=Close Reader View\nreaderView.close.accesskey=R\n"

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ntitle = Origin: %S\n\n# LOCALIZATION NOTE: %1$S is brandShortName, %2$2 is the application ID, and $%$3 is true/false value.\n# LOCALIZATION NOTE: the term \"InBrowserElement\" should not be translated\nb2gtitle = %1$S Application ID %2$S - InBrowserElement %3$S\n\nscope = Scope:\n\nscriptSpec = Script Spec:\n\n# LOCALIZATION NOTE: the term \"Worker\" should not be translated.\ncurrentWorkerURL = Current Worker URL:\n\nactiveCacheName = Active Cache Name:\n\nwaitingCacheName = Waiting Cache Name:\n\ntrue = true\n\nfalse = false\n\n# LOCALIZATION NOTE this term is used as a button label (verb, not noun).\nupdate = Update\n\nunregister = Unregister\n\nwaiting = Waiting…\n\n# LOCALIZATION NOTE: the term \"Service Worker\" should not translated.\nunregisterError = Failed to unregister this Service Worker.\n\npushEndpoint = Push Endpoint:\n"

/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (downloadsTitleFiles): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of relevant days with crash reports\ncrashesTitle=Crash Reports for the Last #1 Day;Crash Reports for the Last #1 Days\n\n# LOCALIZATION NOTE (crashesTimeMinutes): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of minutes (between 1 and 59) which have passed since the crash\ncrashesTimeMinutes=#1 minute ago;#1 minutes ago\n\n# LOCALIZATION NOTE (crashesTimeHours): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of hours (between 1 and 23) which have passed since the crash\ncrashesTimeHours=#1 hour ago;#1 hours ago\n\n# LOCALIZATION NOTE (crashesTimeDays): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of days (1 or more) which have passed since the crash\ncrashesTimeDays=#1 day ago;#1 days ago\n\n# LOCALIZATION NOTE (downloadsTitleFiles): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of pending crash reports\npendingReports=All Crash Reports (including #1 pending crash in the given time range);All Crash Reports (including #1 pending crashes in the given time range)\n\n# LOCALIZATION NOTE (rawDataCopied) Text displayed in a mobile \"Toast\" to user when the\n# raw data is successfully copied to the clipboard via button press.\nrawDataCopied=Raw data copied to clipboard\n\n# LOCALIZATION NOTE (textCopied) Text displayed in a mobile \"Toast\" to user when the\n# text is successfully copied to the clipboard via button press.\ntextCopied=Text copied to clipboard\n\n# LOCALIZATION NOTE The verb \"blocked\" here refers to a graphics feature such as \"Direct2D\" or \"OpenGL layers\".\nblockedDriver = Blocked for your graphics driver version.\n\n# LOCALIZATION NOTE The %S here is a placeholder, leave unchanged, it will get replaced by the driver version string.\ntryNewerDriver = Blocked for your graphics driver version. Try updating your graphics driver to version %S or newer.\n\n# LOCALIZATION NOTE The verb \"blocked\" here refers to a graphics feature such as \"Direct2D\" or \"OpenGL layers\".\nblockedGfxCard = Blocked for your graphics card because of unresolved driver issues.\n\n# LOCALIZATION NOTE The verb \"blocked\" here refers to a graphics feature such as \"Direct2D\" or \"OpenGL layers\".\nblockedOSVersion = Blocked for your operating system version.\n\n# LOCALIZATION NOTE The verb \"blocked\" here refers to a graphics feature such as \"Direct2D\" or \"OpenGL layers\".\nblockedMismatchedVersion = Blocked for your graphics driver version mismatch between registry and DLL.\n\n# LOCALIZATION NOTE In the following strings, \"Direct2D\", \"DirectWrite\" and \"ClearType\"\n# are proper nouns and should not be translated. Feel free to leave english strings if\n# there are no good translations, these are only used in about:support\nclearTypeParameters = ClearType Parameters\n\ncompositing = Compositing\nhardwareH264 = Hardware H264 Decoding\naudioBackend = Audio Backend\nmainThreadNoOMTC = main thread, no OMTC\nyes = Yes\nno = No\n\ngpuDescription = Description\ngpuVendorID = Vendor ID\ngpuDeviceID = Device ID\ngpuSubsysID = Subsys ID\ngpuDrivers = Drivers\ngpuRAM = RAM\ngpuDriverVersion = Driver Version\ngpuDriverDate = Driver Date\ngpuActive = Active\nwebglRenderer = WebGL Renderer\nwebgl2Renderer = WebGL2 Renderer\nGPU1 = GPU #1\nGPU2 = GPU #2\nblocklistedBug = Blocklisted due to known issues\n# LOCALIZATION NOTE %1$S will be replaced with a bug number string.\nbugLink = bug %1$S\n# LOCALIZATION NOTE %1$S will be replaced with an arbitrary identifier\n# string that can be searched on DXR/MXR or grepped in the source tree.\nunknownFailure = Blocklisted; failure code %1$S\nd3d11layersCrashGuard = D3D11 Compositor\nd3d11videoCrashGuard = D3D11 Video Decoder\nd3d9videoCrashGuard = D3D9 Video Decoder\nglcontextCrashGuard = OpenGL\nresetOnNextRestart = Reset on Next Restart\n\nminLibVersions = Expected minimum version\nloadedLibVersions = Version in use\n\nhasSeccompBPF = Seccomp-BPF (System Call Filtering)\nhasSeccompTSync = Seccomp Thread Synchronization\nhasUserNamespaces = User Namespaces\nhasPrivilegedUserNamespaces = User Namespaces for privileged processes\ncanSandboxContent = Content Process Sandboxing\ncanSandboxMedia = Media Plugin Sandboxing\ncontentSandboxLevel = Content Process Sandbox Level\n\n# LOCALIZATION NOTE %1$S and %2$S will be replaced with the number of remote and the total number\n# of windows, respectively, while %3$S will be replaced with one of the status strings below,\n# which contains a description of the multi-process preference and status.\n# Note: multiProcessStatus.3 doesn't exist because status=3 was deprecated.\nmultiProcessWindows = %1$S/%2$S (%3$S)\nmultiProcessStatus.0 = Enabled by user\nmultiProcessStatus.1 = Enabled by default\nmultiProcessStatus.2 = Disabled\nmultiProcessStatus.4 = Disabled by accessibility tools\nmultiProcessStatus.5 = Disabled by lack of graphics hardware acceleration on Mac OS X\nmultiProcessStatus.6 = Disabled by unsupported text input\nmultiProcessStatus.7 = Disabled by add-ons\nmultiProcessStatus.8 = Disabled forcibly\n# No longer in use (bug 1296353) but we might bring this back.\nmultiProcessStatus.9 = Disabled by graphics hardware acceleration on Windows XP\nmultiProcessStatus.unknown = Unknown status\n\nasyncPanZoom = Asynchronous Pan/Zoom\napzNone = none\nwheelEnabled = wheel input enabled\ntouchEnabled = touch input enabled\ndragEnabled = scrollbar drag enabled\n\n# LOCALIZATION NOTE %1 will be replaced with the key of a preference.\nwheelWarning = async wheel input disabled due to unsupported pref: %S\ntouchWarning = async touch input disabled due to unsupported pref: %S\n"

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# Note to translators:\n# - %1$S will be replaced by brandFullName\n# - %2$S will be replaced with the value of the toolkit.telemetry.server_owner preference\npageSubtitle = This page shows the information about performance, hardware, usage and customizations collected by Telemetry. This information is submitted to %1$S to help improve %2$S.\n\ngeneralDataTitle = General Data\n\ngeneralDataHeadingName = Name\n\ngeneralDataHeadingValue = Value\n\nenvironmentDataHeadingName = Name\n\nenvironmentDataHeadingValue = Value\n\nenvironmentDataSubsectionToggle = Click to toggle section\n\nenvironmentDataSubsectionEmpty = (No data collected)\n\ntelemetryLogTitle = Telemetry Log\n\ntelemetryLogHeadingId = Id\n\ntelemetryLogHeadingTimestamp = Timestamp\n\ntelemetryLogHeadingData = Data\n\nslowSqlMain = Slow SQL Statements on Main Thread\n\nslowSqlOther = Slow SQL Statements on Helper Threads\n\nslowSqlHits = Hits\n\nslowSqlAverage = Avg. Time (ms)\n\nslowSqlStatement = Statement\n\n# Note to translators:\n# - The %1$S will be replaced with the number of the hang\n# - The %2$S will be replaced with the duration of the hang\nchrome-hangs-title = Hang Report #%1$S (%2$S seconds)\n\n# Note to translators:\n# - The %1$S will be replaced with the number of the late write\nlate-writes-title = Late Write #%1$S\n\nstackTitle = Stack:\n\nmemoryMapTitle = Memory map:\n\nerrorFetchingSymbols = An error occurred while fetching symbols. Check that you are connected to the Internet and try again.\n\nhistogramSamples = samples\n\nhistogramAverage = average\n\nhistogramSum = sum\n\nhistogramCopy = Copy\n\nkeysHeader = Property\n\nnamesHeader = Name\n\nvaluesHeader = Value\n\naddonTableID = Add-on ID\n\naddonTableDetails = Details\n\n# Note to translators:\n# - The %1$S will be replaced with the name of an Add-on Provider (e.g. \"XPI\", \"Plugin\")\naddonProvider = %1$S Provider\n\nparentPayload = Parent Payload\n\n# Note to translators:\n# - The %1$S will be replaced with the number of the child payload (e.g. \"1\", \"2\")\nchildPayloadN = Child Payload %1$S\n"

/***/ },
/* 93 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (document_title, cannot_retrieve_log):\n# The text \"WebRTC\" is a proper noun and should not be translated.\n# It is the general label for the standards based technology. see http://www.webrtc.org\ndocument_title = WebRTC Internals\ncannot_retrieve_log = Cannot retrieve WebRTC log data\n\n# LOCALIZATION NOTE (save_page_msg):\n# %1$S will be replaced by a full path file name: the target of the SavePage operation.\nsave_page_msg = page saved to: %1$S\n\n# LOCALIZATION NOTE (save_page_dialog_title): \"about:webrtc\" is a internal browser URL and should not be\n# translated. This string is used as a title for a file save dialog box.\nsave_page_dialog_title = save about:webrtc as\n\n# LOCALIZATION NOTE (debug_mode_off_state_msg):\n# %1$S will be replaced by the full path file name of the debug log.\ndebug_mode_off_state_msg = trace log can be found at: %1$S\n\n# LOCALIZATION NOTE (debug_mode_on_state_msg):\n# %1$S will be replaced by the full path file name of the debug log.\ndebug_mode_on_state_msg = debug mode active, trace log at: %1$S\n\n# LOCALIZATION NOTE (aec_logging_msg_label, aec_logging_off_state_label,\n# aec_logging_on_state_label, aec_logging_on_state_msg):\n# AEC is an abbreviation for Acoustic Echo Cancellation.\naec_logging_msg_label = AEC Logging\naec_logging_off_state_label = Start AEC Logging\naec_logging_on_state_label = Stop AEC Logging\naec_logging_on_state_msg = AEC logging active (speak with the caller for a few minutes and then stop the capture)\n\n# LOCALIZATION NOTE (aec_logging_off_state_msg):\n# %1$S will be replaced by the full path to the directory containing the captured log files.\n# AEC is an abbreviation for Acoustic Echo Cancellation.\naec_logging_off_state_msg = captured log files can be found in: %1$S\n\n# LOCALIZATION NOTE (peer_connection_id_label): \"PeerConnection\" is a proper noun\n# associated with the WebRTC module. \"ID\" is an abbreviation for Identifier. This string\n# should not normally be translated and is used as a data label.\npeer_connection_id_label = PeerConnection ID\n\n# LOCALIZATION NOTE (sdp_heading, local_sdp_heading, remote_sdp_heading):\n# \"SDP\" is an abbreviation for Session Description Protocol, an IETF standard.\n# See http://wikipedia.org/wiki/Session_Description_Protocol\nsdp_heading = SDP\nlocal_sdp_heading = Local SDP\nremote_sdp_heading = Remote SDP\n\n# LOCALIZATION NOTE (rtp_stats_heading): \"RTP\" is an abbreviation for the\n# Real-time Transport Protocol, an IETF specification, and should not\n# normally be translated. \"Stats\" is an abbreviation for Statistics.\nrtp_stats_heading = RTP Stats\n\n# LOCALIZATION NOTE (ice_state, ice_stats_heading): \"ICE\" is an abbreviation\n# for Interactive Connectivity Establishment, which is an IETF protocol,\n# and should not normally be translated. \"Stats\" is an abbreviation for\n# Statistics.\nice_state = ICE State\nice_stats_heading = ICE Stats\n\n# LOCALIZATION NOTE (av_sync_label): \"A/V\" stands for Audio/Video.\n# \"sync\" is an abbreviation for sychronization. This is used as\n# a data label.\nav_sync_label = A/V sync\n\n# LOCALIZATION NOTE (jitter_buffer_delay_label): A jitter buffer is an\n# element in the processing chain, see http://wikipedia.org/wiki/Jitter\n# This is used as a data label.\njitter_buffer_delay_label = Jitter-buffer delay\n\n# LOCALIZATION NOTE (avg_bitrate_label, avg_framerate_label): \"Avg.\" is an abbreviation\n# for Average. These are used as data labels.\navg_bitrate_label = Avg. bitrate\navg_framerate_label = Avg. framerate\n\n# LOCALIZATION NOTE (typeLocal, typeRemote): These adjectives are used to label a\n# line of statistics collected for a peer connection. The data represents\n# either the local or remote end of the connection.\ntypeLocal = Local\ntypeRemote = Remote\n\n# LOCALIZATION NOTE (nominated): This adjective is used to label a table column.\n# Cells in this column contain the localized javascript string representation of \"true\"\n# or are left blank.\nnominated = Nominated\n\n# LOCALIZATION NOTE (selected): This adjective is used to label a table column.\n# Cells in this column contain the localized javascript string representation of \"true\"\n# or are left blank. This represents an attribute of an ICE candidate.\nselected = Selected\n\nsave_page_label = Save Page\ndebug_mode_msg_label = Debug Mode\ndebug_mode_off_state_label = Start Debug Mode\ndebug_mode_on_state_label = Stop Debug Mode\nstats_heading = Session Statistics\nlog_heading = Connection Log\nlog_show_msg = show log\nlog_hide_msg = hide log\nconnection_closed = closed\nlocal_candidate = Local Candidate\nremote_candidate = Remote Candidate\npriority = Priority\nfold_show_msg = show details\nfold_show_hint = click to expand this section\nfold_hide_msg = hide details\nfold_hide_hint = click to collapse this section\ndropped_frames_label = Dropped frames\ndiscarded_packets_label = Discarded packets\ndecoder_label = Decoder\nencoder_label = Encoder\nreceived_label = Received\npackets = packets\nlost_label = Lost\njitter_label = Jitter\nsent_label = Sent\n\n"

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (searchWithEngine): %S will be replaced with\n# the search engine provider's name. This format was chosen because\n# the provider can also end with \"Search\" (e.g.: MSN Search).\nsearchWithEngine = Search with %S\n\n# LOCALIZATION NOTE (switchToTab2): This is the same as the older switchToTab\n# string that it's replacing, except it uses title case, so \"Switch\" and \"Tab\"\n# are capitalized.\nswitchToTab2 = Switch to Tab\n\n# LOCALIZATION NOTE (visit): This is shown next to autocomplete entries that are\n# simple URLs or sites, which will be visited when the user selects them.\nvisit = Visit\n\n# LOCALIZATION NOTE (bookmarkKeywordSearch): This is the title of autocomplete\n# entries that are bookmark keyword searches.  %1$S will be replaced with the\n# domain name of the bookmark, and %2$S will be replaced with the keyword\n# search text that the user is typing.  %2$S will not be empty.\nbookmarkKeywordSearch = %1$S: %2$S\n"

/***/ },
/* 95 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nbrowsewithcaret.checkMsg=Do not show me this dialog box again.\nbrowsewithcaret.checkWindowTitle=Caret Browsing\nbrowsewithcaret.checkLabel=Pressing F7 turns Caret Browsing on or off. This feature places a moveable cursor in web pages, allowing you to select text with the keyboard. Do you want to turn Caret Browsing on?\nbrowsewithcaret.checkButtonLabel=Yes\n\nplainText.wordWrap=Wrap Long Lines\n\nformPostSecureToInsecureWarning.title = Security Warning\nformPostSecureToInsecureWarning.message = The information you have entered on this page will be sent over an insecure connection and could be read by a third party.\\n\\nAre you sure you want to send this information?\nformPostSecureToInsecureWarning.continue = Continue\n"

/***/ },
/* 96 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE: The property keys ending with \".key\" are for access keys.\n# Localizations may add or delete properties where the property key ends with\n# \".key\" as appropriate for the localization. The code that uses this data can\n# deal with the absence of an access key for an item.\n#\n# For gbk, gbk.bis and gbk.bis.key are used to trigger string changes in\n# localizations.\n#\n# In the en-US version of this file, access keys are given to the following:\n# * UTF-8\n# * All encodings that are the fallback encoding for some locale in Firefox\n# * All encodings that are the fallback encoding for some locale in IE\n# * All Japanese encodings\n#\n# For the items whose property key does not end in \".key\" and whose value\n# includes \"(\" U+0028 LEFT PARENTHESIS, the \"(\" character is significant for\n# processing by CharsetMenu.jsm. If your localization does not use ASCII\n# parentheses where en-US does in this file, please file a bug to make\n# CharsetMenu.jsm also recognize the delimiter your localization uses.\n# (When this code was developed, all localizations appeared to use\n# U+0028 LEFT PARENTHESIS for this purpose.)\n\n# Auto-Detect (sub)menu\ncharsetMenuCharsets = Character Encoding\ncharsetMenuAutodet = Auto-Detect\n# 'A' is reserved for Arabic:\ncharsetMenuAutodet.key = D\ncharsetMenuAutodet.off = (off)\ncharsetMenuAutodet.off.key = o\ncharsetMenuAutodet.ja = Japanese\ncharsetMenuAutodet.ja.key = J\ncharsetMenuAutodet.ru = Russian\ncharsetMenuAutodet.ru.key = R\ncharsetMenuAutodet.uk = Ukrainian\ncharsetMenuAutodet.uk.key = U\n\n# Globally-relevant\nUTF-8.key        = U\nUTF-8            = Unicode\nwindows-1252.key = W\nwindows-1252     = Western\n\n# Arabic\nwindows-1256.key = A\nwindows-1256     = Arabic (Windows)\nISO-8859-6       = Arabic (ISO)\n\n# Baltic\nwindows-1257.key = B\nwindows-1257     = Baltic (Windows)\nISO-8859-4       = Baltic (ISO)\n\n# Central European\nwindows-1250.key =         E\nwindows-1250     = Central European (Windows)\nISO-8859-2.key   =       l\nISO-8859-2       = Central European (ISO)\n\n# Chinese, Simplified\ngbk.bis.key      =          S\ngbk.bis          = Chinese, Simplified\n\n# Chinese, Traditional\nBig5.key         =          T\nBig5             = Chinese, Traditional\n\n# Cyrillic\nwindows-1251.key = C\nwindows-1251     = Cyrillic (Windows)\nISO-8859-5       = Cyrillic (ISO)\nKOI8-R           = Cyrillic (KOI8-R)\nKOI8-U           = Cyrillic (KOI8-U)\nIBM866           = Cyrillic (DOS)\n\n# Greek\nwindows-1253.key = G\nwindows-1253     = Greek (Windows)\nISO-8859-7.key   =          O\nISO-8859-7       = Greek (ISO)\n\n# Hebrew\nwindows-1255.key = H\nwindows-1255     = Hebrew\n# LOCALIZATION NOTE (ISO-8859-8): The value for this item should begin with\n# the same word for Hebrew as the value for windows-1255 so that this item \n# sorts right after that one in the collation order for your locale.\nISO-8859-8       = Hebrew, Visual\n\n# Japanese\nShift_JIS.key    = J\nShift_JIS        = Japanese (Shift_JIS)\nEUC-JP.key       =   p\nEUC-JP           = Japanese (EUC-JP)\nISO-2022-JP.key  =     n\nISO-2022-JP      = Japanese (ISO-2022-JP)\n\n# Korean\nEUC-KR.key       = K\nEUC-KR           = Korean\n\n# Thai\nwindows-874.key  =    i\nwindows-874      = Thai\n\n# Turkish\nwindows-1254.key =   r\nwindows-1254     = Turkish\n\n# Vietnamese\nwindows-1258.key = V\nwindows-1258     = Vietnamese\n\n"

/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nAlert=Alert\nConfirm=Confirm\nConfirmCheck=Confirm\nPrompt=Prompt\nPromptUsernameAndPassword2=Authentication Required\nPromptPassword2=Password Required\nSelect=Select\nOK=OK\nCancel=Cancel\nYes=&Yes\nNo=&No\nSave=&Save\nRevert=&Revert\nDontSave=Do&n’t Save\nScriptDlgGenericHeading=[JavaScript Application]\nScriptDlgHeading=The page at %S says:\nScriptDialogLabel=Prevent this page from creating additional dialogs\nScriptDialogPreventTitle=Confirm Dialog Preference\n# LOCALIZATION NOTE (EnterLoginForRealm2, EnterLoginForProxy2):\n# %1 is an untrusted string provided by a remote server. It could try to\n# take advantage of sentence structure in order to mislead the user (see\n# bug 244273). %1 should be integrated into the translated sentences as\n# little as possible. %2 is the url of the site being accessed.\nEnterLoginForRealm2=%2$S is requesting your username and password.\\n\\nThe site says: “%1$S”\nEnterLoginForProxy2=The proxy %2$S is requesting a username and password.\\n\\nThe site says: “%1$S”\nEnterUserPasswordFor2=%1$S is requesting your username and password.\nEnterUserPasswordForCrossOrigin=%1$S is requesting your username and password.\\n\\nWARNING: Your password will not be sent to the website you are currently visiting!\nEnterPasswordFor=Enter password for %1$S on %2$S\n"

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# Lock column values\ndefault=default\nuser=user set\nlocked=locked\n\n# Type column values\nstring=string\nint=integer\nbool=boolean\n\n# Preference prompts\n# %S is replaced by one of the type column values above\nnew_title=New %S value\nnew_prompt=Enter the preference name\nmodify_title=Enter %S value\n\nnan_title=Invalid value\nnan_text=The text you entered is not a number.\n"

/***/ },
/* 99 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ntypeError=Error:\ntypeWarning=Warning:\ntypeMessage=Message:\nerrFile=Source File: %S\nerrLine=Line: %S\nerrLineCol=Line: %S, Column: %S\nerrCode=Source Code:\nerrTime=Timestamp: %S\n\n# LOCALIZATION NOTE (evaluationContextChanged): The message displayed when the\n# browser console's evaluation context (window against which input is evaluated)\n# changes.\nevaluationContextChanged=The console’s evaluation context changed, probably because the target window was closed or because you opened a main window from the browser console’s window.\n"

/***/ },
/* 100 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# context menu strings\n\nSaveImageTitle=Save Image\nSaveVideoTitle=Save Video\nSaveAudioTitle=Save Audio\nSaveLinkTitle=Save As\nDefaultSaveFileName=index\nWebPageCompleteFilter=Web Page, complete\nWebPageHTMLOnlyFilter=Web Page, HTML only\nWebPageXHTMLOnlyFilter=Web Page, XHTML only\nWebPageSVGOnlyFilter=Web Page, SVG only\nWebPageXMLOnlyFilter=Web Page, XML only\n\n# LOCALIZATION NOTE (filesFolder):\n#    This is the name of the folder that is created parallel to a HTML file \n#    when it is saved \"With Images\". The %S section is replaced with the\n#    leaf name of the file being saved (minus extension).\nfilesFolder=%S_files\n"

/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nenterToolbarTitle=New Toolbar\nenterToolbarName=Enter a name for this toolbar:\nenterToolbarDup=There is already a toolbar with the name “%S”. Please enter a different name.\nenterToolbarBlank=You must enter a name to create a new toolbar.\nseparatorTitle=Separator\nspringTitle=Flexible Space\nspacerTitle=Space\n"

/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nmonth.1.Mmm=Jan\nmonth.2.Mmm=Feb\nmonth.3.Mmm=Mar\nmonth.4.Mmm=Apr\nmonth.5.Mmm=May\nmonth.6.Mmm=Jun\nmonth.7.Mmm=Jul\nmonth.8.Mmm=Aug\nmonth.9.Mmm=Sep\nmonth.10.Mmm=Oct\nmonth.11.Mmm=Nov\nmonth.12.Mmm=Dec\n\nmonth.1.name=January\nmonth.2.name=February\nmonth.3.name=March\nmonth.4.name=April\nmonth.5.name=May\nmonth.6.name=June\nmonth.7.name=July\nmonth.8.name=August\nmonth.9.name=September\nmonth.10.name=October\nmonth.11.name=November\nmonth.12.name=December\n\nday.1.name=Sunday\nday.2.name=Monday\nday.3.name=Tuesday\nday.4.name=Wednesday\nday.5.name=Thursday\nday.6.name=Friday\nday.7.name=Saturday\n\nday.1.Mmm=Sun\nday.2.Mmm=Mon\nday.3.Mmm=Tue\nday.4.Mmm=Wed\nday.5.Mmm=Thu\nday.6.Mmm=Fri\nday.7.Mmm=Sat\n\nday.1.short=Su\nday.2.short=Mo\nday.3.short=Tu\nday.4.short=We\nday.5.short=Th\nday.6.short=Fr\nday.7.short=Sa\n\nnoon=Noon\nmidnight=Midnight\n\nAllDay=All Day\n"

/***/ },
/* 103 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nbutton-accept=OK\nbutton-cancel=Cancel\nbutton-help=Help\nbutton-disclosure=More Info\naccesskey-accept=\naccesskey-cancel=\naccesskey-help=H\naccesskey-disclosure=I\n"

/***/ },
/* 104 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ncsp.error.missing-directive = Policy is missing a required ‘%S’ directive\n\n#LOCALIZATION NOTE (csp.error.illegal-keyword) %1$S is the name of a CSP directive, such as \"script-src\". %2$S is the name of a CSP keyword, usually 'unsafe-inline'.\ncsp.error.illegal-keyword = ‘%1$S’ directive contains a forbidden %2$S keyword\n\n#LOCALIZATION NOTE (csp.error.illegal-protocol) %2$S a protocol name, such as \"http\", which appears as \"http:\", as it would in a URL.\ncsp.error.illegal-protocol = ‘%1$S’ directive contains a forbidden %2$S: protocol source\n\n#LOCALIZATION NOTE (csp.error.missing-host) %2$S a protocol name, such as \"http\", which appears as \"http:\", as it would in a URL.\ncsp.error.missing-host = %2$S: protocol requires a host in ‘%1$S’ directives\n\n#LOCALIZATION NOTE (csp.error.missing-source) %1$S is the name of a CSP directive, such as \"script-src\". %2$S is the name of a CSP source, usually 'self'.\ncsp.error.missing-source = ‘%1$S’ must include the source %2$S\n\n#LOCALIZATION NOTE (csp.error.illegal-host-wildcard) %2$S a protocol name, such as \"http\", which appears as \"http:\", as it would in a URL.\ncsp.error.illegal-host-wildcard = %2$S: wildcard sources in ‘%1$S’ directives must include at least one non-generic sub-domain (e.g., *.example.com rather than *.com)\n"

/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# OSX only. Default menu label when there is no xul menubar.\n\nquitMenuitem.label=Quit\nquitMenuitem.key=q\n"

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#### Change Action\n\ndownloadHelperNoneSelected=None Selected\n"

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE: The extensions to which these descriptions refer\n#                    now live in toolkit/content/filepicker.properties\nallTitle=All Files\nhtmlTitle=HTML Files\ntextTitle=Text Files\nimageTitle=Image Files\nxmlTitle=XML Files\nxulTitle=XUL Files\nappsTitle=Applications\naudioTitle=Audio Files\nvideoTitle=Video Files\n\ndirTextInputLabel=Directory name:\ndirTextInputAccesskey=n\n\nconfirmTitle=Confirm\nconfirmFileReplacing=%S already exists.\\nDo you want to replace it?\nopenButtonLabel=Open\nsaveButtonLabel=Save\nselectFolderButtonLabel=Select\nnoButtonLabel=No\nformatLabel=Format:\n\nerrorOpenFileDoesntExistTitle=Error opening %S\nerrorOpenFileDoesntExistMessage=File %S doesn’t exist\nerrorDirDoesntExistTitle=Error accessing %S\nerrorDirDoesntExistMessage=Directory %S doesn’t exist\n\nerrorOpeningFileTitle=Error opening %S\nopenWithoutPermissionMessage_file=File %S is not readable\n\nerrorSavingFileTitle=Error saving %S\nsaveParentIsFileMessage=%S is a file, can’t save %S\nsaveParentDoesntExistMessage=Path %S doesn’t exist, can’t save %S\n\nsaveWithoutPermissionMessage_file=File %S is not writable.\nsaveWithoutPermissionMessage_dir=Cannot create file. Directory %S is not writable.\n\nerrorNewDirDoesExistTitle=Error creating %S\nerrorNewDirDoesExistMessage=A file named %S already exists, directory cannot be created.\n\nerrorCreateNewDirTitle=Error creating %S\nerrorCreateNewDirMessage=Directory %S could not be created\nerrorCreateNewDirIsFileMessage=Directory cannot be created, %S is a file\nerrorCreateNewDirPermissionMessage=Directory cannot be created, %S not writable\n\npromptNewDirTitle=Create new directory\npromptNewDirMessage=Directory name:\n\nerrorPathProblemTitle=Unknown Error\nerrorPathProblemMessage=An unknown error occurred (path %S)\n"

/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# strings used by the Find bar, split from browser.properties\nNotFound=Phrase not found\nWrappedToTop=Reached end of page, continued from top\nWrappedToBottom=Reached top of page, continued from bottom\nNormalFind=Find in page\nFastFind=Quick find\nFastFindLinks=Quick find (links only)\nCaseSensitive=(Case sensitive)\nEntireWord=(Whole words only)\n# LOCALIZATION NOTE (FoundMatches): Semicolon-separated list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 is currently selected match and #2 the total amount of matches.\nFoundMatches=#1 of #2 match;#1 of #2 matches\n# LOCALIZATION NOTE (FoundMatchesCountLimit): Semicolon-separated list of plural\n# forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 is the total amount of matches allowed before counting stops.\nFoundMatchesCountLimit=More than #1 match;More than #1 matches\n"

/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nnotFoundWarning=The text you entered was not found.\nnotFoundTitle=Find"

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n\n# LOCALIZATION NOTE (stacktrace.anonymousFunction):\n# This string is used to display JavaScript functions that have no given name -\n# they are said to be anonymous. See stacktrace.outputMessage.\nstacktrace.anonymousFunction=<anonymous>\n\n# LOCALIZATION NOTE (stacktrace.outputMessage):\n# This string is used in the Web Console output to identify a web developer call\n# to console.trace(). The stack trace of JavaScript function calls is displayed.\n# In this minimal message we only show the last call.\nstacktrace.outputMessage=Stack trace from %S, function %S, line %S.\n"

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (general.useragent.locale):\n# This is the valid BCP 47 language tag representing your locale.\n#\n# In most cases, this will simply be your locale code. However, in rare cases\n# (such as 'jp-JP-mac'), you may need to modify your locale code in order to\n# make it a valid BCP 47 language tag. (If your locale code does not include a\n# region subtag, do not include one in the language tag representing your\n# locale.)\ngeneral.useragent.locale=en-US\n\n# LOCALIZATION NOTE (intl.accept_languages):\n# This is a comma-separated list of valid BCP 47 language tags.\n#\n# Begin with the value of 'general.useragent.locale'. Next, include language\n# tags for other languages that you expect most users of your locale to be\n# able to speak, so that their browsing experience degrades gracefully if\n# content is not available in their primary language.\n#\n# It is recommended that you include \"en-US, en\" at the end of the list as a\n# last resort. However, if you know that users of your locale would prefer a\n# different variety of English, or if they are not likely to understand\n# English at all, you may opt to include a different English language tag, or\n# to exclude English altogether.\n#\n# For example, the Breton [br] locale might consider including French and\n# British English in their list, since those languages are commonly spoken in\n# the same area as Breton:\n# intl.accept_languages=br, fr-FR, fr, en-GB, en\nintl.accept_languages=en-US, en\n\n# LOCALIZATION NOTE (font.language.group):\n# This preference controls the initial setting of the language drop-down menu\n# in the Content > Fonts & Colors > Advanced preference panel.\n#\n# Set it to the value of one of the menuitems in the \"selectLangs\" menulist in\n# http://dxr.mozilla.org/mozilla-central/source/browser/components/preferences/fonts.xul\nfont.language.group=x-western\n\n# LOCALIZATION NOTE (intl.charset.detector):\n# This preference controls the initial setting for the character encoding\n# detector. Valid values are ja_parallel_state_machine for Japanese, ruprob\n# for Russian and ukprob for Ukrainian and the empty string to turn detection\n# off. The value must be empty for locales other than Japanese, Russian and\n# Ukrainian.\nintl.charset.detector=\n\n# LOCALIZATION NOTE (pluralRule): Pick the appropriate plural rule for your\n# language. This will determine how many plural forms of a word you will need\n# to provide and in what order.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\npluralRule=1\n\n# LOCALIZATION NOTE (intl.menuitems.alwaysappendaccesskeys, intl.menuitems.insertseparatorbeforeaccesskeys):\n# Valid values are: true, false, <empty string>\n# Missing preference or empty value equals false.\nintl.menuitems.alwaysappendaccesskeys=\nintl.menuitems.insertseparatorbeforeaccesskeys=true\n"

/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE : FILE This file contains the application's labels for keys on the keyboard.\n#                     If you decide to translate this file, you should translate it based on\n#                     the prevelant kind of keyboard for your target user.\n# LOCALIZATION NOTE : There are two types of keys, those w/ text on their labels\n#                     and those w/ glyphs.\n# LOCALIZATION NOTE : VK_<…> represents a key on the keyboard.\n#\n# For more information please see bugzilla bug 90888.\n\n# F1..F10 should probably not be translated unless there are keyboards that actually have other labels\n# F11..F20 might be something else, but are really keyboard specific and not region/language specific\n# there are actually two different F11/F12 keys, I don't know which one these labels represent.\n# eg, F13..F20 on a sparc keyboard are labeled Props, Again .. Find, Cut\n# sparc also has Stop, Again and F11/F12. VK_F11/VK_F12 probably map to Stop/Again\n# LOCALIZATION NOTE : BLOCK Do not translate the next block\nVK_F1=F1\nVK_F2=F2\nVK_F3=F3\nVK_F4=F4\nVK_F5=F5\nVK_F6=F6\nVK_F7=F7\nVK_F8=F8\nVK_F9=F9\nVK_F10=F10\n\nVK_F11=F11\nVK_F12=F12\nVK_F13=F13\nVK_F14=F14\nVK_F15=F15\nVK_F16=F16\nVK_F17=F17\nVK_F18=F18\nVK_F19=F19\nVK_F20=F20\n# LOCALIZATION NOTE : BLOCK end do not translate block\n\n# LOCALIZATION NOTE : BLOCK GLYPHS, DO translate this block\nVK_UP=Up Arrow\nVK_DOWN=Down Arrow\nVK_LEFT=Left Arrow\nVK_RIGHT=Right Arrow\nVK_PAGE_UP=Page Up\nVK_PAGE_DOWN=Page Down\n# LOCALIZATION NOTE : BLOCK end GLYPHS\n\n# Enter, backspace, and Tab might have both glyphs and text\n# if the keyboards usually have a glyph,\n# if there is a meaningful translation,\n# or if keyboards are localized\n# then translate them or insert the appropriate glyph\n# otherwise you should probably just translate the glyph regions\n\n# LOCALIZATION NOTE : BLOCK maybe GLYPHS\nVK_RETURN=Return\nVK_TAB=Tab\nVK_BACK=Backspace\nVK_DELETE=Del\n# LOCALIZATION NOTE : BLOCK end maybe GLYPHS\n# LOCALIZATION NOTE : BLOCK typing state keys\nVK_HOME=Home\nVK_END=End\n\nVK_ESCAPE=Esc\nVK_INSERT=Ins\n# LOCALIZATION NOTE : BLOCK end\n"

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\naa = Afar\nab = Abkhazian\nae = Avestan\naf = Afrikaans\nak = Akan\nam = Amharic\nan = Aragonese\nar = Arabic\nas = Assamese\nast = Asturian\nav = Avaric\nay = Aymara\naz = Azerbaijani\nba = Bashkir\nbe = Belarusian\nbg = Bulgarian\nbh = Bihari\nbi = Bislama\nbm = Bambara\nbn = Bengali\nbo = Tibetan\nbr = Breton\nbs = Bosnian\nca = Catalan\nce = Chechen\nch = Chamorro\nco = Corsican\ncr = Cree\ncs = Czech\ncsb = Kashubian\ncu = Church Slavic\ncv = Chuvash\ncy = Welsh\nda = Danish\nde = German\ndsb = Lower Sorbian\ndv = Divehi\ndz = Dzongkha\nee = Ewe\nel = Greek\nen = English\neo = Esperanto\nes = Spanish\net = Estonian\neu = Basque\nfa = Persian\nff = Fulah\nfi = Finnish\nfj = Fijian\nfo = Faroese\nfr = French\nfur = Friulian\nfy = Frisian\nga = Irish\ngd = Scottish Gaelic\ngl = Galician\ngn = Guarani\ngu = Gujarati\ngv = Manx\nha = Hausa\nhaw = Hawaiian\nhe = Hebrew\nhi = Hindi\nhil = Hiligaynon\nho = Hiri Motu\nhr = Croatian\nhsb = Upper Sorbian\nht = Haitian\nhu = Hungarian\nhy = Armenian\nhz = Herero\nia = Interlingua\nid = Indonesian\nie = Interlingue\nig = Igbo\nii = Sichuan Yi\nik = Inupiaq\nio = Ido\nis = Icelandic\nit = Italian\niu = Inuktitut\nja = Japanese\njv = Javanese\nka = Georgian\nkg = Kongo\nki = Kikuyu\nkj = Kuanyama\nkk = Kazakh\nkl = Greenlandic\nkm = Khmer\nkn = Kannada\nko = Korean\nkok = Konkani\nkr = Kanuri\nks = Kashmiri\nku = Kurdish\nkv = Komi\nkw = Cornish\nky = Kirghiz\nla = Latin\nlb = Luxembourgish\nlg = Ganda\nli = Limburgan\nln = Lingala\nlo = Lao\nlt = Lithuanian\nlu = Luba-Katanga\nlv = Latvian\nmg = Malagasy\nmh = Marshallese\nmi = Maori\nmk = Macedonian\nml = Malayalam\nmn = Mongolian\nmr = Marathi\nms = Malay\nmt = Maltese\nmy = Burmese\nna = Nauru\nnb = Norwegian Bokm\\u00e5l\nnd = Ndebele, North\nne = Nepali\nng = Ndonga\nnl = Dutch\nnn = Norwegian Nynorsk\nno = Norwegian\nnr = Ndebele, South\nnso = Sotho, Northern\nnv = Navajo\nny = Chichewa\noc = Occitan\noj = Ojibwa\nom = Oromo\nor = Odia\nos = Ossetian\npa = Punjabi\npi = Pali\npl = Polish\nps = Pashto\npt = Portuguese\nqu = Quechua\nrm = Rhaeto-Romanic\nrn = Kirundi\nro = Romanian\nru = Russian\nrw = Kinyarwanda\nsa = Sanskrit\nsc = Sardinian\nsd = Sindhi\nse = Northern Sami\nsg = Sango\nsi = Singhalese\nsk = Slovak\nsl = Slovenian\nsm = Samoan\nsn = Shona\nso = Somali\nson = Songhay\nsq = Albanian\nsr = Serbian\nss = Siswati\nst = Sotho, Southern\nsu = Sundanese\nsv = Swedish\nsw = Swahili\nta = Tamil\nte = Telugu\ntg = Tajik\nth = Thai\nti = Tigrinya\ntig = Tigre\ntk = Turkmen\ntl = Tagalog\ntlh = Klingon\ntn = Tswana\nto = Tonga\ntr = Turkish\nts = Tsonga\ntt = Tatar\ntw = Twi\nty = Tahitian\nug = Uighur\nuk = Ukrainian\nur = Urdu\nuz = Uzbek\nve = Venda\nvi = Vietnamese\nvo = Volap\\u00fck\nwa = Walloon\nwen = Sorbian\nwo = Wolof\nxh = Xhosa\nyi = Yiddish\nyo = Yoruba\nza = Zhuang\nzh = Chinese\nzu = Zulu\n"

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# Narrate, meaning \"read the page out loud\". This is the name of the feature\n# and it is the label for the popup button.\nnarrate = Narrate\nback = Back\nstart = Start\nstop = Stop\nforward = Forward\nspeed = Speed\nselectvoicelabel = Voice:\n# Default voice is determined by the language of the document.\ndefaultvoice = Default\n\n# Voice name and language.\n# eg. David (English)\nvoiceLabel = %S (%S)"

/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nSortMenuItems=Sorted by %COLNAME%\n"

/***/ },
/* 116 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# These strings are used in the native GTK, Mac and Windows print dialogs.\n\n# GTK titles:\nprintTitleGTK=Print\noptionsTabLabelGTK=Options\nprintFramesTitleGTK=Print Frames\n\n# Mac titles:\noptionsTitleMac=Options:\nappearanceTitleMac=Appearance:\nframesTitleMac=Frames:\npageHeadersTitleMac=Page Headers:\npageFootersTitleMac=Page Footers:\n\n# Windows titles:\noptionsTitleWindows=Options\nprintFramesTitleWindows=Print Frames\n\n# TRANSLATOR NOTE: For radio button labels and check button labels, an underscore _\n# before a character will turn that character into an accesskey in the GTK dialog.\n# e.g. \"_As laid out\" will make A the accesskey.\n# In the Windows labels, use an ampersand (&).\n# On Mac, underscores will be stripped.\n\nasLaidOut=_As Laid Out on the Screen\nasLaidOutWindows=As &laid out on the screen\nselectedFrame=The _Selected Frame\nselectedFrameWindows=The selected &frame\nseparateFrames=Each Frame on Separate _Pages\nseparateFramesWindows=&Each frame separately\nshrinkToFit=Ignore Scaling and S_hrink To Fit Page Width\nselectionOnly=Print Selection _Only\nprintBGOptions=Print Backgrounds\nprintBGColors=Print Background _Colors\nprintBGImages=Print Background I_mages\nheaderFooter=Header and Footer\nleft=Left\ncenter=Center\nright=Right\nheaderFooterBlank=--blank--\nheaderFooterTitle=Title\nheaderFooterURL=URL\nheaderFooterDate=Date/Time\nheaderFooterPage=Page #\nheaderFooterPageTotal=Page # of #\nheaderFooterCustom=Custom…\ncustomHeaderFooterPrompt=Please enter your custom header/footer text\n\n# These are for the summary view in the Mac dialog:\nsummaryFramesTitle=Print Frames\nsummarySelectionOnlyTitle=Print Selection\nsummaryShrinkToFitTitle=Shrink To Fit\nsummaryPrintBGColorsTitle=Print BG Colors\nsummaryPrintBGImagesTitle=Print BG Images\nsummaryHeaderTitle=Page Headers\nsummaryFooterTitle=Page Footers\nsummaryNAValue=N/A\nsummaryOnValue=On\nsummaryOffValue=Off\n"

/***/ },
/* 117 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nad\t=\tAndorra\nae\t=\tUnited Arab Emirates\naf\t=\tAfghanistan\nag\t=\tAntigua and Barbuda\nai\t=\tAnguilla\nal\t=\tAlbania\nam\t=\tArmenia\nao\t=\tAngola\naq\t=\tAntarctica\nar\t=\tArgentina\nas\t=\tAmerican Samoa\nat\t=\tAustria\nau\t=\tAustralia\naw\t=\tAruba\naz\t=\tAzerbaijan\nba\t=\tBosnia and Herzegovina\nbb\t=\tBarbados\nbd\t=\tBangladesh\nbe\t=\tBelgium\nbf\t=\tBurkina Faso\nbg\t=\tBulgaria\nbh\t=\tBahrain\nbi\t=\tBurundi\nbj\t=\tBenin\nbl\t=\tSaint Barthelemy\nbm\t=\tBermuda\nbn\t=\tBrunei\nbo\t=\tBolivia\nbq\t=\tBonaire, Sint Eustatius, and Saba\nbr\t=\tBrazil\nbs\t=\tBahamas, The\nbt\t=\tBhutan\nbv\t=\tBouvet Island\nbw\t=\tBotswana\nby\t=\tBelarus\nbz\t=\tBelize\nca\t=\tCanada\ncc\t=\tCocos (Keeling) Islands\ncd\t=\tCongo (Kinshasa)\ncf\t=\tCentral African Republic\ncg\t=\tCongo (Brazzaville)\nch\t=\tSwitzerland\nci\t=\tCôte d’Ivoire\nck\t=\tCook Islands\ncl\t=\tChile\ncm\t=\tCameroon\ncn\t=\tChina\nco\t=\tColombia\ncp\t=\tClipperton Island\ncr\t=\tCosta Rica\ncu\t=\tCuba\ncv\t=\tCabo Verde\ncw\t=\tCuraçao\ncx\t=\tChristmas Island\ncy\t=\tCyprus\ncz\t=\tCzech Republic\nde\t=\tGermany\ndg\t=\tDiego Garcia\ndj\t=\tDjibouti\ndk\t=\tDenmark\ndm\t=\tDominica\ndo\t=\tDominican Republic\ndz\t=\tAlgeria\nec\t=\tEcuador\nee\t=\tEstonia\neg\t=\tEgypt\neh\t=\tWestern Sahara\ner\t=\tEritrea\nes\t=\tSpain\net\t=\tEthiopia\nfi\t=\tFinland\nfj\t=\tFiji\nfk\t=\tFalkland Islands (Islas Malvinas)\nfm\t=\tMicronesia, Federated States of\nfo\t=\tFaroe Islands\nfr\t=\tFrance\nga\t=\tGabon\ngb\t=\tUnited Kingdom\ngd\t=\tGrenada\nge\t=\tGeorgia\ngf\t=\tFrench Guiana\ngg\t=\tGuernsey\ngh\t=\tGhana\ngi\t=\tGibraltar\ngl\t=\tGreenland\ngm\t=\tGambia, The\ngn\t=\tGuinea\ngp\t=\tGuadeloupe\ngq\t=\tEquatorial Guinea\ngr\t=\tGreece\ngs\t=\tSouth Georgia and South Sandwich Islands\ngt\t=\tGuatemala\ngu\t=\tGuam\ngw\t=\tGuinea-Bissau\ngy\t=\tGuyana\nhk\t=\tHong Kong\nhm\t=\tHeard Island and McDonald Islands\nhn\t=\tHonduras\nhr\t=\tCroatia\nht\t=\tHaiti\nhu\t=\tHungary\nid\t=\tIndonesia\nie\t=\tIreland\nil\t=\tIsrael\nim\t=\tIsle of Man\nin\t=\tIndia\nio\t=\tBritish Indian Ocean Territory\niq\t=\tIraq\nir\t=\tIran\nis\t=\tIceland\nit\t=\tItaly\nje\t=\tJersey\njm\t=\tJamaica\njo\t=\tJordan\njp\t=\tJapan\nke\t=\tKenya\nkg\t=\tKyrgyzstan\nkh\t=\tCambodia\nki\t=\tKiribati\nkm\t=\tComoros\nkn\t=\tSaint Kitts and Nevis\nkp\t=\tKorea, North\nkr\t=\tKorea, South\nkw\t=\tKuwait\nky\t=\tCayman Islands\nkz\t=\tKazakhstan\nla\t=\tLaos\nlb\t=\tLebanon\nlc\t=\tSaint Lucia\nli\t=\tLiechtenstein\nlk\t=\tSri Lanka\nlr\t=\tLiberia\nls\t=\tLesotho\nlt\t=\tLithuania\nlu\t=\tLuxembourg\nlv\t=\tLatvia\nly\t=\tLibya\nma\t=\tMorocco\nmc\t=\tMonaco\nmd\t=\tMoldova\nme\t=\tMontenegro\nmf\t=\tSaint Martin\nmg\t=\tMadagascar\nmh\t=\tMarshall Islands\nmk\t=\tMacedonia\nml\t=\tMali\nmm\t=\tBurma\nmn\t=\tMongolia\nmo\t=\tMacau\nmp\t=\tNorthern Mariana Islands\nmq\t=\tMartinique\nmr\t=\tMauritania\nms\t=\tMontserrat\nmt\t=\tMalta\nmu\t=\tMauritius\nmv\t=\tMaldives\nmw\t=\tMalawi\nmx\t=\tMexico\nmy\t=\tMalaysia\nmz\t=\tMozambique\nna\t=\tNamibia\nnc\t=\tNew Caledonia\nne\t=\tNiger\nnf\t=\tNorfolk Island\nng\t=\tNigeria\nni\t=\tNicaragua\nnl\t=\tNetherlands\nno\t=\tNorway\nnp\t=\tNepal\nnr\t=\tNauru\nnu\t=\tNiue\nnz\t=\tNew Zealand\nom\t=\tOman\npa\t=\tPanama\npe\t=\tPeru\npf\t=\tFrench Polynesia\npg\t=\tPapua New Guinea\nph\t=\tPhilippines\npk\t=\tPakistan\npl\t=\tPoland\npm\t=\tSaint Pierre and Miquelon\npn\t=\tPitcairn Islands\npr\t=\tPuerto Rico\npt\t=\tPortugal\npw\t=\tPalau\npy\t=\tParaguay\nqa\t=\tQatar\nqm\t=\tMidway Islands\nqs\t=\tBassas da India\nqu\t=\tJuan de Nova Island\nqw\t=\tWake Island\nqx\t=\tGlorioso Islands\nqz\t=\tAkrotiri\nre\t=\tReunion\nro\t=\tRomania\nrs\t=\tSerbia\nru\t=\tRussia\nrw\t=\tRwanda\nsa\t=\tSaudi Arabia\nsb\t=\tSolomon Islands\nsc\t=\tSeychelles\nsd\t=\tSudan\nse\t=\tSweden\nsg\t=\tSingapore\nsh\t=\tSaint Helena, Ascension, and Tristan da Cunha\nsi\t=\tSlovenia\nsk\t=\tSlovakia\nsl\t=\tSierra Leone\nsm\t=\tSan Marino\nsn\t=\tSenegal\nso\t=\tSomalia\nsr\t=\tSuriname\nss\t=\tSouth Sudan\nst\t=\tSao Tome and Principe\nsv\t=\tEl Salvador\nsx\t=\tSint Maarten\nsy\t=\tSyria\nsz\t=\tSwaziland\ntc\t=\tTurks and Caicos Islands\ntd\t=\tChad\ntf\t=\tFrench Southern and Antarctic Lands\ntg\t=\tTogo\nth\t=\tThailand\ntj\t=\tTajikistan\ntk\t=\tTokelau\ntl\t=\tTimor-Leste\ntm\t=\tTurkmenistan\ntn\t=\tTunisia\nto\t=\tTonga\ntr\t=\tTurkey\ntt\t=\tTrinidad and Tobago\ntv\t=\tTuvalu\ntw\t=\tTaiwan\ntz\t=\tTanzania\nua\t=\tUkraine\nug\t=\tUganda\nus\t=\tUnited States\nuy\t=\tUruguay\nuz\t=\tUzbekistan\nva\t=\tVatican City\nvc\t=\tSaint Vincent and the Grenadines\nve\t=\tVenezuela\nvg\t=\tVirgin Islands, British\nvi\t=\tVirgin Islands, U.S.\nvn\t=\tVietnam\nvu\t=\tVanuatu\nwf\t=\tWallis and Futuna\nws\t=\tSamoa\nxa\t=\tAshmore and Cartier Islands\nxb\t=\tBaker Island\nxc\t=\tCoral Sea Islands\nxd\t=\tDhekelia\nxe\t=\tEuropa Island\nxg\t=\tGaza Strip\nxh\t=\tHowland Island\nxj\t=\tJan Mayen\nxk\t=\tKosovo\nxl\t=\tPalmyra Atoll\nxm\t=\tKingman Reef\nxp\t=\tParacel Islands\nxq\t=\tJarvis Island\nxr\t=\tSvalbard\nxs\t=\tSpratly Islands\nxt\t=\tTromelin Island\nxu\t=\tJohnston Atoll\nxv\t=\tNavassa Island\nxw\t=\tWest Bank\nye\t=\tYemen\nyt\t=\tMayotte\nza\t=\tSouth Africa\nzm\t=\tZambia\nzw\t=\tZimbabwe\n"

/***/ },
/* 118 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE: These strings are used for profile reset.\n\n# LOCALIZATION NOTE (resetUnusedProfile.message): %S is brandShortName.\nresetUnusedProfile.message=It looks like you haven’t started %S in a while. Do you want to clean it up for a fresh, like-new experience? And by the way, welcome back!\n# LOCALIZATION NOTE (resetUninstalled.message): %S is brandShortName.\nresetUninstalled.message=Looks like you’ve reinstalled %S. Want us to clean it up for a fresh, like-new experience?\n\n# LOCALIZATION NOTE (refreshProfile.resetButton.label): %S is brandShortName.\nrefreshProfile.resetButton.label=Refresh %S…\nrefreshProfile.resetButton.accesskey=e\n"

/***/ },
/* 119 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ngoToLineTitle     = Go to line\ngoToLineText      = Enter line number\ninvalidInputTitle = Invalid input\ninvalidInputText  = The line number entered is invalid.\noutOfRangeTitle   = Line not found\noutOfRangeText    = The specified line was not found.\nstatusBarLineCol  = Line %1$S, Col %2$S\nviewSelectionSourceTitle = DOM Source of Selection\nviewMathMLSourceTitle    = DOM Source of MathML\n\ncontext_goToLine_label        = Go to Line…\ncontext_goToLine_accesskey    = L\ncontext_wrapLongLines_label   = Wrap Long Lines\ncontext_highlightSyntax_label = Syntax Highlighting\n"

/***/ },
/* 120 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ndefault-first-title=Welcome to the %S\ndefault-last-title=Completing the %S\ndefault-first-title-mac=Introduction\ndefault-last-title-mac=Conclusion\n"

/***/ },
/* 121 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	function DebuggerPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this.toolbox = toolbox;
	}

	DebuggerPanel.prototype = {
	  open: function() {
	    let targetPromise;
	    if (!this.toolbox.target.isRemote) {
	      targetPromise = this.toolbox.target.makeRemote();
	    } else {
	      targetPromise = promise.resolve(this.toolbox.target);
	    }

	    return targetPromise.then(() => {
	      this.panelWin.Debugger.bootstrap({
	        threadClient: this.toolbox.threadClient,
	        tabTarget: this.toolbox.target
	      });
	      return this;
	    });
	  },

	  _store: function() {
	    return this.panelWin.Debugger.store;
	  },

	  _getState: function() {
	    return this._store().getState();
	  },

	  _actions: function() {
	    return this.panelWin.Debugger.actions;
	  },

	  _selectors: function() {
	    return this.panelWin.Debugger.selectors;
	  },

	  getFrames: function() {
	    let frames = this._selectors().getFrames(this._getState());

	    // frames is an empty array when the debugger is not paused
	    if (!frames.toJS) {
	      return {
	        frames: [],
	        selected: -1
	      }
	    }

	    frames = frames.toJS();
	    const selectedFrame = this._selectors().getSelectedFrame(this._getState());
	    const selected = frames.findIndex(frame => frame.id == selectedFrame.id);

	    frames.forEach(frame => {
	      frame.actor = frame.id;
	    });

	    return { frames, selected };
	  },

	  destroy: function() {
	  }
	};

	exports.DebuggerPanel = DebuggerPanel;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/*
	 * About the objects defined in this file:
	 * - CssLogic contains style information about a view context. It provides
	 *   access to 2 sets of objects: Css[Sheet|Rule|Selector] provide access to
	 *   information that does not change when the selected element changes while
	 *   Css[Property|Selector]Info provide information that is dependent on the
	 *   selected element.
	 *   Its key methods are highlight(), getPropertyInfo() and forEachSheet(), etc
	 *   It also contains a number of static methods for l10n, naming, etc
	 *
	 * - CssSheet provides a more useful API to a DOM CSSSheet for our purposes,
	 *   including shortSource and href.
	 * - CssRule a more useful API to a nsIDOMCSSRule including access to the group
	 *   of CssSelectors that the rule provides properties for
	 * - CssSelector A single selector - i.e. not a selector group. In other words
	 *   a CssSelector does not contain ','. This terminology is different from the
	 *   standard DOM API, but more inline with the definition in the spec.
	 *
	 * - CssPropertyInfo contains style information for a single property for the
	 *   highlighted element.
	 * - CssSelectorInfo is a wrapper around CssSelector, which adds sorting with
	 *   reference to the selected element.
	 */

	"use strict";

	/**
	 * Provide access to the style information in a page.
	 * CssLogic uses the standard DOM API, and the Gecko inIDOMUtils API to access
	 * styling information in the page, and present this to the user in a way that
	 * helps them understand:
	 * - why their expectations may not have been fulfilled
	 * - how browsers process CSS
	 * @constructor
	 */

	const Services = __webpack_require__(1);
	const CSSLexer = __webpack_require__(123);
	const {LocalizationHelper} = __webpack_require__(39);
	const styleInspectorL10N =
	  new LocalizationHelper("devtools-shared/locale/styleinspector.properties");

	/**
	 * Special values for filter, in addition to an href these values can be used
	 */
	exports.FILTER = {
	  // show properties for all user style sheets.
	  USER: "user",
	  // USER, plus user-agent (i.e. browser) style sheets
	  UA: "ua",
	};

	/**
	 * Each rule has a status, the bigger the number, the better placed it is to
	 * provide styling information.
	 *
	 * These statuses are localized inside the styleinspector.properties
	 * string bundle.
	 * @see csshtmltree.js RuleView._cacheStatusNames()
	 */
	exports.STATUS = {
	  BEST: 3,
	  MATCHED: 2,
	  PARENT_MATCH: 1,
	  UNMATCHED: 0,
	  UNKNOWN: -1,
	};

	/**
	 * Lookup a l10n string in the shared styleinspector string bundle.
	 *
	 * @param {String} name
	 *        The key to lookup.
	 * @returns {String} A localized version of the given key.
	 */
	exports.l10n = name => styleInspectorL10N.getStr(name);

	/**
	 * Is the given property sheet a content stylesheet?
	 *
	 * @param {CSSStyleSheet} sheet a stylesheet
	 * @return {boolean} true if the given stylesheet is a content stylesheet,
	 * false otherwise.
	 */
	exports.isContentStylesheet = function (sheet) {
	  return sheet.parsingMode !== "agent";
	};

	/**
	 * Return a shortened version of a style sheet's source.
	 *
	 * @param {CSSStyleSheet} sheet the DOM object for the style sheet.
	 */
	exports.shortSource = function (sheet) {
	  // Use a string like "inline" if there is no source href
	  if (!sheet || !sheet.href) {
	    return exports.l10n("rule.sourceInline");
	  }

	  // We try, in turn, the filename, filePath, query string, whole thing
	  let url = {};
	  try {
	    url = new URL(sheet.href);
	  } catch (ex) {
	    // Some UA-provided stylesheets are not valid URLs.
	  }

	  if (url.pathname) {
	    let index = url.pathname.lastIndexOf("/");
	    if (index !== -1 && index < url.pathname.length) {
	      return url.pathname.slice(index + 1);
	    }
	    return url.pathname;
	  }

	  if (url.query) {
	    return url.query;
	  }

	  let dataUrl = sheet.href.match(/^(data:[^,]*),/);
	  return dataUrl ? dataUrl[1] : sheet.href;
	};

	const TAB_CHARS = "\t";

	/**
	 * Prettify minified CSS text.
	 * This prettifies CSS code where there is no indentation in usual places while
	 * keeping original indentation as-is elsewhere.
	 * @param string text The CSS source to prettify.
	 * @return string Prettified CSS source
	 */
	function prettifyCSS(text, ruleCount) {
	  if (prettifyCSS.LINE_SEPARATOR == null) {
	    let os = Services.appinfo.OS;
	    prettifyCSS.LINE_SEPARATOR = (os === "WINNT" ? "\r\n" : "\n");
	  }

	  // remove initial and terminating HTML comments and surrounding whitespace
	  text = text.replace(/(?:^\s*<!--[\r\n]*)|(?:\s*-->\s*$)/g, "");
	  let originalText = text;
	  text = text.trim();

	  // don't attempt to prettify if there's more than one line per rule.
	  let lineCount = text.split("\n").length - 1;
	  if (ruleCount !== null && lineCount >= ruleCount) {
	    return originalText;
	  }

	  // We reformat the text using a simple state machine.  The
	  // reformatting preserves most of the input text, changing only
	  // whitespace.  The rules are:
	  //
	  // * After a "{" or ";" symbol, ensure there is a newline and
	  //   indentation before the next non-comment, non-whitespace token.
	  // * Additionally after a "{" symbol, increase the indentation.
	  // * A "}" symbol ensures there is a preceding newline, and
	  //   decreases the indentation level.
	  // * Ensure there is whitespace before a "{".
	  //
	  // This approach can be confused sometimes, but should do ok on a
	  // minified file.
	  let indent = "";
	  let indentLevel = 0;
	  let tokens = CSSLexer.getCSSLexer(text);
	  let result = "";
	  let pushbackToken = undefined;

	  // A helper function that reads tokens, looking for the next
	  // non-comment, non-whitespace token.  Comment and whitespace tokens
	  // are appended to |result|.  If this encounters EOF, it returns
	  // null.  Otherwise it returns the last whitespace token that was
	  // seen.  This function also updates |pushbackToken|.
	  let readUntilSignificantToken = () => {
	    while (true) {
	      let token = tokens.nextToken();
	      if (!token || token.tokenType !== "whitespace") {
	        pushbackToken = token;
	        return token;
	      }
	      // Saw whitespace.  Before committing to it, check the next
	      // token.
	      let nextToken = tokens.nextToken();
	      if (!nextToken || nextToken.tokenType !== "comment") {
	        pushbackToken = nextToken;
	        return token;
	      }
	      // Saw whitespace + comment.  Update the result and continue.
	      result = result + text.substring(token.startOffset, nextToken.endOffset);
	    }
	  };

	  // State variables for readUntilNewlineNeeded.
	  //
	  // Starting index of the accumulated tokens.
	  let startIndex;
	  // Ending index of the accumulated tokens.
	  let endIndex;
	  // True if any non-whitespace token was seen.
	  let anyNonWS;
	  // True if the terminating token is "}".
	  let isCloseBrace;
	  // True if the token just before the terminating token was
	  // whitespace.
	  let lastWasWS;

	  // A helper function that reads tokens until there is a reason to
	  // insert a newline.  This updates the state variables as needed.
	  // If this encounters EOF, it returns null.  Otherwise it returns
	  // the final token read.  Note that if the returned token is "{",
	  // then it will not be included in the computed start/end token
	  // range.  This is used to handle whitespace insertion before a "{".
	  let readUntilNewlineNeeded = () => {
	    let token;
	    while (true) {
	      if (pushbackToken) {
	        token = pushbackToken;
	        pushbackToken = undefined;
	      } else {
	        token = tokens.nextToken();
	      }
	      if (!token) {
	        endIndex = text.length;
	        break;
	      }

	      // A "}" symbol must be inserted later, to deal with indentation
	      // and newline.
	      if (token.tokenType === "symbol" && token.text === "}") {
	        isCloseBrace = true;
	        break;
	      } else if (token.tokenType === "symbol" && token.text === "{") {
	        break;
	      }

	      if (token.tokenType !== "whitespace") {
	        anyNonWS = true;
	      }

	      if (startIndex === undefined) {
	        startIndex = token.startOffset;
	      }
	      endIndex = token.endOffset;

	      if (token.tokenType === "symbol" && token.text === ";") {
	        break;
	      }

	      lastWasWS = token.tokenType === "whitespace";
	    }
	    return token;
	  };

	  while (true) {
	    // Set the initial state.
	    startIndex = undefined;
	    endIndex = undefined;
	    anyNonWS = false;
	    isCloseBrace = false;
	    lastWasWS = false;

	    // Read tokens until we see a reason to insert a newline.
	    let token = readUntilNewlineNeeded();

	    // Append any saved up text to the result, applying indentation.
	    if (startIndex !== undefined) {
	      if (isCloseBrace && !anyNonWS) {
	        // If we saw only whitespace followed by a "}", then we don't
	        // need anything here.
	      } else {
	        result = result + indent + text.substring(startIndex, endIndex);
	        if (isCloseBrace) {
	          result += prettifyCSS.LINE_SEPARATOR;
	        }
	      }
	    }

	    if (isCloseBrace) {
	      indent = TAB_CHARS.repeat(--indentLevel);
	      result = result + indent + "}";
	    }

	    if (!token) {
	      break;
	    }

	    if (token.tokenType === "symbol" && token.text === "{") {
	      if (!lastWasWS) {
	        result += " ";
	      }
	      result += "{";
	      indent = TAB_CHARS.repeat(++indentLevel);
	    }

	    // Now it is time to insert a newline.  However first we want to
	    // deal with any trailing comments.
	    token = readUntilSignificantToken();

	    // "Early" bail-out if the text does not appear to be minified.
	    // Here we ignore the case where whitespace appears at the end of
	    // the text.
	    if (pushbackToken && token && token.tokenType === "whitespace" &&
	        /\n/g.test(text.substring(token.startOffset, token.endOffset))) {
	      return originalText;
	    }

	    // Finally time for that newline.
	    result = result + prettifyCSS.LINE_SEPARATOR;

	    // Maybe we hit EOF.
	    if (!pushbackToken) {
	      break;
	    }
	  }

	  return result;
	}

	exports.prettifyCSS = prettifyCSS;


/***/ },
/* 123 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// A CSS Lexer.  This file is a bit unusual -- it is a more or less
	// direct translation of layout/style/nsCSSScanner.cpp and
	// layout/style/CSSLexer.cpp into JS.  This implements the
	// CSSLexer.webidl interface, and the intent is to try to keep it in
	// sync with changes to the platform CSS lexer.  Due to this goal,
	// this file violates some naming conventions and consequently locally
	// disables some eslint rules.

	/* eslint-disable camelcase, no-inline-comments, mozilla/no-aArgs */
	/* eslint-disable no-else-return */

	"use strict";

	// White space of any kind.  No value fields are used.  Note that
	// comments do *not* count as white space; comments separate tokens
	// but are not themselves tokens.
	const eCSSToken_Whitespace = "whitespace";     //
	// A comment.
	const eCSSToken_Comment = "comment";        // /*...*/

	// Identifier-like tokens.  mIdent is the text of the identifier.
	// The difference between ID and Hash is: if the text after the #
	// would have been a valid Ident if the # hadn't been there, the
	// scanner produces an ID token.  Otherwise it produces a Hash token.
	// (This distinction is required by css3-selectors.)
	const eCSSToken_Ident = "ident";          // word
	const eCSSToken_Function = "function";       // word(
	const eCSSToken_AtKeyword = "at";      // @word
	const eCSSToken_ID = "id";             // #word
	const eCSSToken_Hash = "hash";           // #0word

	// Numeric tokens.  mNumber is the floating-point value of the
	// number, and mHasSign indicates whether there was an explicit sign
	// (+ or -) in front of the number.  If mIntegerValid is true, the
	// number had the lexical form of an integer, and mInteger is its
	// integer value.  Lexically integer values outside the range of a
	// 32-bit signed number are clamped to the maximum values; mNumber
	// will indicate a 'truer' value in that case.  Percentage tokens
	// are always considered not to be integers, even if their numeric
	// value is integral (100% => mNumber = 1.0).  For Dimension
	// tokens, mIdent holds the text of the unit.
	const eCSSToken_Number = "number";         // 1 -5 +2e3 3.14159 7.297352e-3
	const eCSSToken_Dimension = "dimension";      // 24px 8.5in
	const eCSSToken_Percentage = "percentage";     // 85% 1280.4%

	// String-like tokens.  In all cases, mIdent holds the text
	// belonging to the string, and mSymbol holds the delimiter
	// character, which may be ', ", or zero (only for unquoted URLs).
	// Bad_String and Bad_URL tokens are emitted when the closing
	// delimiter or parenthesis was missing.
	const eCSSToken_String = "string";         // 'foo bar' "foo bar"
	const eCSSToken_Bad_String = "bad_string";     // 'foo bar
	const eCSSToken_URL = "url";            // url(foobar) url("foo bar")
	const eCSSToken_Bad_URL = "bad_url";        // url(foo

	// Any one-character symbol.  mSymbol holds the character.
	const eCSSToken_Symbol = "symbol";         // . ; { } ! *

	// Match operators.  These are single tokens rather than pairs of
	// Symbol tokens because css3-selectors forbids the presence of
	// comments between the two characters.  No value fields are used;
	// the token type indicates which operator.
	const eCSSToken_Includes = "includes";       // ~=
	const eCSSToken_Dashmatch = "dashmatch";      // |=
	const eCSSToken_Beginsmatch = "beginsmatch";    // ^=
	const eCSSToken_Endsmatch = "endsmatch";      // $=
	const eCSSToken_Containsmatch = "containsmatch";  // *=

	// Unicode-range token: currently used only in @font-face.
	// The lexical rule for this token includes several forms that are
	// semantically invalid.  Therefore, mIdent always holds the
	// complete original text of the token (so we can print it
	// accurately in diagnostics), and mIntegerValid is true iff the
	// token is semantically valid.  In that case, mInteger holds the
	// lowest value included in the range, and mInteger2 holds the
	// highest value included in the range.
	const eCSSToken_URange = "urange";         // U+007e U+01?? U+2000-206F

	// HTML comment delimiters, ignored as a unit when they appear at
	// the top level of a style sheet, for compatibility with websites
	// written for compatibility with pre-CSS browsers.  This token type
	// subsumes the css2.1 CDO and CDC tokens, which are always treated
	// the same by the parser.  mIdent holds the text of the token, for
	// diagnostics.
	const eCSSToken_HTMLComment = "htmlcomment";    // <!-- -->

	const eEOFCharacters_None = 0x0000;

	// to handle \<EOF> inside strings
	const eEOFCharacters_DropBackslash = 0x0001;

	// to handle \<EOF> outside strings
	const eEOFCharacters_ReplacementChar = 0x0002;

	// to close comments
	const eEOFCharacters_Asterisk = 0x0004;
	const eEOFCharacters_Slash = 0x0008;

	// to close double-quoted strings
	const eEOFCharacters_DoubleQuote = 0x0010;

	// to close single-quoted strings
	const eEOFCharacters_SingleQuote = 0x0020;

	// to close URLs
	const eEOFCharacters_CloseParen = 0x0040;

	// Bridge the char/string divide.
	const APOSTROPHE = "'".charCodeAt(0);
	const ASTERISK = "*".charCodeAt(0);
	const CARRIAGE_RETURN = "\r".charCodeAt(0);
	const CIRCUMFLEX_ACCENT = "^".charCodeAt(0);
	const COMMERCIAL_AT = "@".charCodeAt(0);
	const DIGIT_NINE = "9".charCodeAt(0);
	const DIGIT_ZERO = "0".charCodeAt(0);
	const DOLLAR_SIGN = "$".charCodeAt(0);
	const EQUALS_SIGN = "=".charCodeAt(0);
	const EXCLAMATION_MARK = "!".charCodeAt(0);
	const FULL_STOP = ".".charCodeAt(0);
	const GREATER_THAN_SIGN = ">".charCodeAt(0);
	const HYPHEN_MINUS = "-".charCodeAt(0);
	const LATIN_CAPITAL_LETTER_E = "E".charCodeAt(0);
	const LATIN_CAPITAL_LETTER_U = "U".charCodeAt(0);
	const LATIN_SMALL_LETTER_E = "e".charCodeAt(0);
	const LATIN_SMALL_LETTER_U = "u".charCodeAt(0);
	const LEFT_PARENTHESIS = "(".charCodeAt(0);
	const LESS_THAN_SIGN = "<".charCodeAt(0);
	const LINE_FEED = "\n".charCodeAt(0);
	const NUMBER_SIGN = "#".charCodeAt(0);
	const PERCENT_SIGN = "%".charCodeAt(0);
	const PLUS_SIGN = "+".charCodeAt(0);
	const QUESTION_MARK = "?".charCodeAt(0);
	const QUOTATION_MARK = "\"".charCodeAt(0);
	const REVERSE_SOLIDUS = "\\".charCodeAt(0);
	const RIGHT_PARENTHESIS = ")".charCodeAt(0);
	const SOLIDUS = "/".charCodeAt(0);
	const TILDE = "~".charCodeAt(0);
	const VERTICAL_LINE = "|".charCodeAt(0);

	const UCS2_REPLACEMENT_CHAR = 0xFFFD;

	const kImpliedEOFCharacters = [
	  UCS2_REPLACEMENT_CHAR,
	  ASTERISK,
	  SOLIDUS,
	  QUOTATION_MARK,
	  APOSTROPHE,
	  RIGHT_PARENTHESIS,
	  0
	];

	/**
	 * Ensure that the character is valid.  If it is valid, return it;
	 * otherwise, return the replacement character.
	 *
	 * @param {Number} c the character to check
	 * @return {Number} the character or its replacement
	 */
	function ensureValidChar(c) {
	  if (c >= 0x00110000 || (c & 0xFFF800) == 0xD800) {
	    // Out of range or a surrogate.
	    return UCS2_REPLACEMENT_CHAR;
	  }
	  return c;
	}

	/**
	 * Turn a string into an array of character codes.
	 *
	 * @param {String} str the input string
	 * @return {Array} an array of character codes, one per character in
	 *         the input string.
	 */
	function stringToCodes(str) {
	  return Array.prototype.map.call(str, (c) => c.charCodeAt(0));
	}

	const IS_HEX_DIGIT = 0x01;
	const IS_IDSTART = 0x02;
	const IS_IDCHAR = 0x04;
	const IS_URL_CHAR = 0x08;
	const IS_HSPACE = 0x10;
	const IS_VSPACE = 0x20;
	const IS_SPACE = IS_HSPACE | IS_VSPACE;
	const IS_STRING = 0x40;

	const H = IS_HSPACE;
	const V = IS_VSPACE;
	const I = IS_IDCHAR;
	const J = IS_IDSTART;
	const U = IS_URL_CHAR;
	const S = IS_STRING;
	const X = IS_HEX_DIGIT;

	const SH = S | H;
	const SU = S | U;
	const SUI = S | U | I;
	const SUIJ = S | U | I | J;
	const SUIX = S | U | I | X;
	const SUIJX = S | U | I | J | X;

	/* eslint-disable indent, no-multi-spaces, comma-spacing, spaced-comment */
	const gLexTable = [
	// 00    01    02    03    04    05    06    07
	    0,    S,    S,    S,    S,    S,    S,    S,
	// 08   TAB    LF    0B    FF    CR    0E    0F
	    S,   SH,    V,    S,    V,    V,    S,    S,
	// 10    11    12    13    14    15    16    17
	    S,    S,    S,    S,    S,    S,    S,    S,
	// 18    19    1A    1B    1C    1D    1E    1F
	    S,    S,    S,    S,    S,    S,    S,    S,
	//SPC     !     "     #     $     %     &     '
	   SH,   SU,    0,   SU,   SU,   SU,   SU,    0,
	//  (     )     *     +     ,     -     .     /
	    S,    S,   SU,   SU,   SU,  SUI,   SU,   SU,
	//  0     1     2     3     4     5     6     7
	 SUIX, SUIX, SUIX, SUIX, SUIX, SUIX, SUIX, SUIX,
	//  8     9     :     ;     <     =     >     ?
	 SUIX, SUIX,   SU,   SU,   SU,   SU,   SU,   SU,
	//  @     A     B     C     D     E     F     G
	   SU,SUIJX,SUIJX,SUIJX,SUIJX,SUIJX,SUIJX, SUIJ,
	//  H     I     J     K     L     M     N     O
	 SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ,
	//  P     Q     R     S     T     U     V     W
	 SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ,
	//  X     Y     Z     [     \     ]     ^     _
	 SUIJ, SUIJ, SUIJ,   SU,    J,   SU,   SU, SUIJ,
	//  `     a     b     c     d     e     f     g
	   SU,SUIJX,SUIJX,SUIJX,SUIJX,SUIJX,SUIJX, SUIJ,
	//  h     i     j     k     l     m     n     o
	 SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ,
	//  p     q     r     s     t     u     v     w
	 SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ,
	//  x     y     z     {     |     }     ~    7F
	 SUIJ, SUIJ, SUIJ,   SU,   SU,   SU,   SU,    S,
	];
	/* eslint-enable indent, no-multi-spaces, comma-spacing, spaced-comment */

	/**
	 * True if 'ch' is in character class 'cls', which should be one of
	 * the constants above or some combination of them.  All characters
	 * above U+007F are considered to be in 'cls'.  EOF is never in 'cls'.
	 */
	function IsOpenCharClass(ch, cls) {
	  return ch >= 0 && (ch >= 128 || (gLexTable[ch] & cls) != 0);
	}

	/**
	 * True if 'ch' is in character class 'cls', which should be one of
	 * the constants above or some combination of them.  No characters
	 * above U+007F are considered to be in 'cls'. EOF is never in 'cls'.
	 */
	function IsClosedCharClass(ch, cls) {
	  return ch >= 0 && ch < 128 && (gLexTable[ch] & cls) != 0;
	}

	/**
	 * True if 'ch' is CSS whitespace, i.e. any of the ASCII characters
	 * TAB, LF, FF, CR, or SPC.
	 */
	function IsWhitespace(ch) {
	  return IsClosedCharClass(ch, IS_SPACE);
	}

	/**
	 * True if 'ch' is horizontal whitespace, i.e. TAB or SPC.
	 */
	function IsHorzSpace(ch) {
	  return IsClosedCharClass(ch, IS_HSPACE);
	}

	/**
	 * True if 'ch' is vertical whitespace, i.e. LF, FF, or CR.  Vertical
	 * whitespace requires special handling when consumed, see AdvanceLine.
	 */
	function IsVertSpace(ch) {
	  return IsClosedCharClass(ch, IS_VSPACE);
	}

	/**
	 * True if 'ch' is a character that can appear in the middle of an identifier.
	 * This includes U+0000 since it is handled as U+FFFD, but for purposes of
	 * GatherText it should not be included in IsOpenCharClass.
	 */
	function IsIdentChar(ch) {
	  return IsOpenCharClass(ch, IS_IDCHAR) || ch == 0;
	}

	/**
	 * True if 'ch' is a character that by itself begins an identifier.
	 * This includes U+0000 since it is handled as U+FFFD, but for purposes of
	 * GatherText it should not be included in IsOpenCharClass.
	 * (This is a subset of IsIdentChar.)
	 */
	function IsIdentStart(ch) {
	  return IsOpenCharClass(ch, IS_IDSTART) || ch == 0;
	}

	/**
	 * True if the two-character sequence aFirstChar+aSecondChar begins an
	 * identifier.
	 */
	function StartsIdent(aFirstChar, aSecondChar) {
	  return IsIdentStart(aFirstChar) ||
	    (aFirstChar == HYPHEN_MINUS && (aSecondChar == HYPHEN_MINUS ||
	                                    IsIdentStart(aSecondChar)));
	}

	/**
	 * True if 'ch' is a decimal digit.
	 */
	function IsDigit(ch) {
	  return (ch >= DIGIT_ZERO) && (ch <= DIGIT_NINE);
	}

	/**
	 * True if 'ch' is a hexadecimal digit.
	 */
	function IsHexDigit(ch) {
	  return IsClosedCharClass(ch, IS_HEX_DIGIT);
	}

	/**
	 * Assuming that 'ch' is a decimal digit, return its numeric value.
	 */
	function DecimalDigitValue(ch) {
	  return ch - DIGIT_ZERO;
	}

	/**
	 * Assuming that 'ch' is a hexadecimal digit, return its numeric value.
	 */
	function HexDigitValue(ch) {
	  if (IsDigit(ch)) {
	    return DecimalDigitValue(ch);
	  } else {
	    // Note: c&7 just keeps the low three bits which causes
	    // upper and lower case alphabetics to both yield their
	    // "relative to 10" value for computing the hex value.
	    return (ch & 0x7) + 9;
	  }
	}

	/**
	 * If 'ch' can be the first character of a two-character match operator
	 * token, return the token type code for that token, otherwise return
	 * eCSSToken_Symbol to indicate that it can't.
	 */
	function MatchOperatorType(ch) {
	  switch (ch) {
	    case TILDE: return eCSSToken_Includes;
	    case VERTICAL_LINE: return eCSSToken_Dashmatch;
	    case CIRCUMFLEX_ACCENT: return eCSSToken_Beginsmatch;
	    case DOLLAR_SIGN: return eCSSToken_Endsmatch;
	    case ASTERISK: return eCSSToken_Containsmatch;
	    default: return eCSSToken_Symbol;
	  }
	}

	function Scanner(buffer) {
	  this.mBuffer = buffer || "";
	  this.mOffset = 0;
	  this.mCount = this.mBuffer.length;
	  this.mLineNumber = 1;
	  this.mLineOffset = 0;
	  this.mTokenLineOffset = 0;
	  this.mTokenOffset = 0;
	  this.mTokenLineNumber = 1;
	  this.mEOFCharacters = eEOFCharacters_None;
	}

	Scanner.prototype = {
	  /**
	   * @see CSSLexer.lineNumber
	   */
	  get lineNumber() {
	    return this.mTokenLineNumber - 1;
	  },

	  /**
	   * @see CSSLexer.columnNumber
	   */
	  get columnNumber() {
	    return this.mTokenOffset - this.mTokenLineOffset;
	  },

	  /**
	   * @see CSSLexer.performEOFFixup
	   */
	  performEOFFixup: function (aInputString, aPreserveBackslash) {
	    let result = aInputString;

	    let eofChars = this.mEOFCharacters;

	    if (aPreserveBackslash &&
	        (eofChars & (eEOFCharacters_DropBackslash |
	                     eEOFCharacters_ReplacementChar)) != 0) {
	      eofChars &= ~(eEOFCharacters_DropBackslash |
	                    eEOFCharacters_ReplacementChar);
	      result += "\\";
	    }

	    if ((eofChars & eEOFCharacters_DropBackslash) != 0 &&
	        result.length > 0 && result.endsWith("\\")) {
	      result = result.slice(0, -1);
	    }

	    let extra = [];
	    this.AppendImpliedEOFCharacters(eofChars, extra);
	    let asString = String.fromCharCode.apply(null, extra);

	    return result + asString;
	  },

	  /**
	   * @see CSSLexer.nextToken
	   */
	  nextToken: function () {
	    let token = {};
	    if (!this.Next(token)) {
	      return null;
	    }

	    let resultToken = {};
	    resultToken.tokenType = token.mType;
	    resultToken.startOffset = this.mTokenOffset;
	    resultToken.endOffset = this.mOffset;

	    let constructText = () => {
	      return String.fromCharCode.apply(null, token.mIdent);
	    };

	    switch (token.mType) {
	      case eCSSToken_Whitespace:
	        break;

	      case eCSSToken_Ident:
	      case eCSSToken_Function:
	      case eCSSToken_AtKeyword:
	      case eCSSToken_ID:
	      case eCSSToken_Hash:
	        resultToken.text = constructText();
	        break;

	      case eCSSToken_Dimension:
	        resultToken.text = constructText();
	        /* Fall through.  */
	      case eCSSToken_Number:
	      case eCSSToken_Percentage:
	        resultToken.number = token.mNumber;
	        resultToken.hasSign = token.mHasSign;
	        resultToken.isInteger = token.mIntegerValid;
	        break;

	      case eCSSToken_String:
	      case eCSSToken_Bad_String:
	      case eCSSToken_URL:
	      case eCSSToken_Bad_URL:
	        resultToken.text = constructText();
	        /* Don't bother emitting the delimiter, as it is readily extracted
	           from the source string when needed.  */
	        break;

	      case eCSSToken_Symbol:
	        resultToken.text = String.fromCharCode(token.mSymbol);
	        break;

	      case eCSSToken_Includes:
	      case eCSSToken_Dashmatch:
	      case eCSSToken_Beginsmatch:
	      case eCSSToken_Endsmatch:
	      case eCSSToken_Containsmatch:
	      case eCSSToken_URange:
	        break;

	      case eCSSToken_Comment:
	      case eCSSToken_HTMLComment:
	        /* The comment text is easily extracted from the source string,
	           and is rarely useful.  */
	        break;
	    }

	    return resultToken;
	  },

	  /**
	   * Return the raw UTF-16 code unit at position |this.mOffset + n| within
	   * the read buffer.  If that is beyond the end of the buffer, returns
	   * -1 to indicate end of input.
	   */
	  Peek: function (n = 0) {
	    if (this.mOffset + n >= this.mCount) {
	      return -1;
	    }
	    return this.mBuffer.charCodeAt(this.mOffset + n);
	  },

	  /**
	   * Advance |this.mOffset| over |n| code units.  Advance(0) is a no-op.
	   * If |n| is greater than the distance to end of input, will silently
	   * stop at the end.  May not be used to advance over a line boundary;
	   * AdvanceLine() must be used instead.
	   */
	  Advance: function (n = 1) {
	    if (this.mOffset + n >= this.mCount || this.mOffset + n < this.mOffset) {
	      this.mOffset = this.mCount;
	    } else {
	      this.mOffset += n;
	    }
	  },

	  /**
	   * Advance |this.mOffset| over a line boundary.
	   */
	  AdvanceLine: function () {
	    // Advance over \r\n as a unit.
	    if (this.mBuffer.charCodeAt(this.mOffset) == CARRIAGE_RETURN &&
	        this.mOffset + 1 < this.mCount &&
	        this.mBuffer.charCodeAt(this.mOffset + 1) == LINE_FEED) {
	      this.mOffset += 2;
	    } else {
	      this.mOffset += 1;
	    }
	    // 0 is a magical line number meaning that we don't know (i.e., script)
	    if (this.mLineNumber != 0) {
	      this.mLineNumber++;
	    }
	    this.mLineOffset = this.mOffset;
	  },

	  /**
	   * Skip over a sequence of whitespace characters (vertical or
	   * horizontal) starting at the current read position.
	   */
	  SkipWhitespace: function () {
	    for (;;) {
	      let ch = this.Peek();
	      if (!IsWhitespace(ch)) { // EOF counts as non-whitespace
	        break;
	      }
	      if (IsVertSpace(ch)) {
	        this.AdvanceLine();
	      } else {
	        this.Advance();
	      }
	    }
	  },

	  /**
	   * Skip over one CSS comment starting at the current read position.
	   */
	  SkipComment: function () {
	    this.Advance(2);
	    for (;;) {
	      let ch = this.Peek();
	      if (ch < 0) {
	        this.SetEOFCharacters(eEOFCharacters_Asterisk | eEOFCharacters_Slash);
	        return;
	      }
	      if (ch == ASTERISK) {
	        this.Advance();
	        ch = this.Peek();
	        if (ch < 0) {
	          this.SetEOFCharacters(eEOFCharacters_Slash);
	          return;
	        }
	        if (ch == SOLIDUS) {
	          this.Advance();
	          return;
	        }
	      } else if (IsVertSpace(ch)) {
	        this.AdvanceLine();
	      } else {
	        this.Advance();
	      }
	    }
	  },

	  /**
	   * If there is a valid escape sequence starting at the current read
	   * position, consume it, decode it, append the result to |aOutput|,
	   * and return true.  Otherwise, consume nothing, leave |aOutput|
	   * unmodified, and return false.  If |aInString| is true, accept the
	   * additional form of escape sequence allowed within string-like tokens.
	   */
	  GatherEscape: function (aOutput, aInString) {
	    let ch = this.Peek(1);
	    if (ch < 0) {
	      // If we are in a string (or a url() containing a string), we want to drop
	      // the backslash on the floor.  Otherwise, we want to treat it as a U+FFFD
	      // character.
	      this.Advance();
	      if (aInString) {
	        this.SetEOFCharacters(eEOFCharacters_DropBackslash);
	      } else {
	        aOutput.push(UCS2_REPLACEMENT_CHAR);
	        this.SetEOFCharacters(eEOFCharacters_ReplacementChar);
	      }
	      return true;
	    }
	    if (IsVertSpace(ch)) {
	      if (aInString) {
	        // In strings (and in url() containing a string), escaped
	        // newlines are completely removed, to allow splitting over
	        // multiple lines.
	        this.Advance();
	        this.AdvanceLine();
	        return true;
	      }
	      // Outside of strings, backslash followed by a newline is not an escape.
	      return false;
	    }

	    if (!IsHexDigit(ch)) {
	      // "Any character (except a hexadecimal digit, linefeed, carriage
	      // return, or form feed) can be escaped with a backslash to remove
	      // its special meaning." -- CSS2.1 section 4.1.3
	      this.Advance(2);
	      if (ch == 0) {
	        aOutput.push(UCS2_REPLACEMENT_CHAR);
	      } else {
	        aOutput.push(ch);
	      }
	      return true;
	    }

	    // "[at most six hexadecimal digits following a backslash] stand
	    // for the ISO 10646 character with that number, which must not be
	    // zero. (It is undefined in CSS 2.1 what happens if a style sheet
	    // does contain a character with Unicode codepoint zero.)"
	    //   -- CSS2.1 section 4.1.3

	    // At this point we know we have \ followed by at least one
	    // hexadecimal digit, therefore the escape sequence is valid and we
	    // can go ahead and consume the backslash.
	    this.Advance();
	    let val = 0;
	    let i = 0;
	    do {
	      val = val * 16 + HexDigitValue(ch);
	      i++;
	      this.Advance();
	      ch = this.Peek();
	    } while (i < 6 && IsHexDigit(ch));

	    // "Interpret the hex digits as a hexadecimal number. If this
	    // number is zero, or is greater than the maximum allowed
	    // codepoint, return U+FFFD REPLACEMENT CHARACTER" -- CSS Syntax
	    // Level 3
	    if (val == 0) {
	      aOutput.push(UCS2_REPLACEMENT_CHAR);
	    } else {
	      aOutput.push(ensureValidChar(val));
	    }

	    // Consume exactly one whitespace character after a
	    // hexadecimal escape sequence.
	    if (IsVertSpace(ch)) {
	      this.AdvanceLine();
	    } else if (IsHorzSpace(ch)) {
	      this.Advance();
	    }
	    return true;
	  },

	  /**
	   * Consume a run of "text" beginning with the current read position,
	   * consisting of characters in the class |aClass| (which must be a
	   * suitable argument to IsOpenCharClass) plus escape sequences.
	   * Append the text to |aText|, after decoding escape sequences.
	   *
	   * Returns true if at least one character was appended to |aText|,
	   * false otherwise.
	   */
	  GatherText: function (aClass, aText) {
	    let start = this.mOffset;
	    let inString = aClass == IS_STRING;

	    for (;;) {
	      // Consume runs of unescaped characters in one go.
	      let n = this.mOffset;
	      while (n < this.mCount && IsOpenCharClass(this.mBuffer.charCodeAt(n),
	                                                aClass)) {
	        n++;
	      }
	      if (n > this.mOffset) {
	        let substr = this.mBuffer.slice(this.mOffset, n);
	        Array.prototype.push.apply(aText, stringToCodes(substr));
	        this.mOffset = n;
	      }
	      if (n == this.mCount) {
	        break;
	      }

	      let ch = this.Peek();
	      if (ch == 0) {
	        this.Advance();
	        aText.push(UCS2_REPLACEMENT_CHAR);
	        continue;
	      }

	      if (ch != REVERSE_SOLIDUS) {
	        break;
	      }
	      if (!this.GatherEscape(aText, inString)) {
	        break;
	      }
	    }

	    return this.mOffset > start;
	  },

	  /**
	   * Scan an Ident token.  This also handles Function and URL tokens,
	   * both of which begin indistinguishably from an identifier.  It can
	   * produce a Symbol token when an apparent identifier actually led
	   * into an invalid escape sequence.
	   */
	  ScanIdent: function (aToken) {
	    if (!this.GatherText(IS_IDCHAR, aToken.mIdent)) {
	      aToken.mSymbol = this.Peek();
	      this.Advance();
	      return true;
	    }

	    if (this.Peek() != LEFT_PARENTHESIS) {
	      aToken.mType = eCSSToken_Ident;
	      return true;
	    }

	    this.Advance();
	    aToken.mType = eCSSToken_Function;

	    let asString = String.fromCharCode.apply(null, aToken.mIdent);
	    if (asString.toLowerCase() === "url") {
	      this.NextURL(aToken);
	    }
	    return true;
	  },

	  /**
	   * Scan an AtKeyword token.  Also handles production of Symbol when
	   * an '@' is not followed by an identifier.
	   */
	  ScanAtKeyword: function (aToken) {
	    // Fall back for when '@' isn't followed by an identifier.
	    aToken.mSymbol = COMMERCIAL_AT;
	    this.Advance();

	    let ch = this.Peek();
	    if (StartsIdent(ch, this.Peek(1))) {
	      if (this.GatherText(IS_IDCHAR, aToken.mIdent)) {
	        aToken.mType = eCSSToken_AtKeyword;
	      }
	    }
	    return true;
	  },

	  /**
	   * Scan a Hash token.  Handles the distinction between eCSSToken_ID
	   * and eCSSToken_Hash, and handles production of Symbol when a '#'
	   * is not followed by identifier characters.
	   */
	  ScanHash: function (aToken) {
	    // Fall back for when '#' isn't followed by identifier characters.
	    aToken.mSymbol = NUMBER_SIGN;
	    this.Advance();

	    let ch = this.Peek();
	    if (IsIdentChar(ch) || ch == REVERSE_SOLIDUS) {
	      let type =
	          StartsIdent(ch, this.Peek(1)) ? eCSSToken_ID : eCSSToken_Hash;
	      aToken.mIdent.length = 0;
	      if (this.GatherText(IS_IDCHAR, aToken.mIdent)) {
	        aToken.mType = type;
	      }
	    }

	    return true;
	  },

	  /**
	   * Scan a Number, Percentage, or Dimension token (all of which begin
	   * like a Number).  Can produce a Symbol when a '.' is not followed by
	   * digits, or when '+' or '-' are not followed by either a digit or a
	   * '.' and then a digit.  Can also produce a HTMLComment when it
	   * encounters '-->'.
	   */
	  ScanNumber: function (aToken) {
	    let c = this.Peek();

	    // Sign of the mantissa (-1 or 1).
	    let sign = c == HYPHEN_MINUS ? -1 : 1;
	    // Absolute value of the integer part of the mantissa.  This is a double so
	    // we don't run into overflow issues for consumers that only care about our
	    // floating-point value while still being able to express the full int32_t
	    // range for consumers who want integers.
	    let intPart = 0;
	    // Fractional part of the mantissa.  This is a double so that when
	    // we convert to float at the end we'll end up rounding to nearest
	    // float instead of truncating down (as we would if fracPart were
	    // a float and we just effectively lost the last several digits).
	    let fracPart = 0;
	    // Absolute value of the power of 10 that we should multiply by
	    // (only relevant for numbers in scientific notation).  Has to be
	    // a signed integer, because multiplication of signed by unsigned
	    // converts the unsigned to signed, so if we plan to actually
	    // multiply by expSign...
	    let exponent = 0;
	    // Sign of the exponent.
	    let expSign = 1;

	    aToken.mHasSign = (c == PLUS_SIGN || c == HYPHEN_MINUS);
	    if (aToken.mHasSign) {
	      this.Advance();
	      c = this.Peek();
	    }

	    let gotDot = (c == FULL_STOP);

	    if (!gotDot) {
	      // Scan the integer part of the mantissa.
	      do {
	        intPart = 10 * intPart + DecimalDigitValue(c);
	        this.Advance();
	        c = this.Peek();
	      } while (IsDigit(c));

	      gotDot = (c == FULL_STOP) && IsDigit(this.Peek(1));
	    }

	    if (gotDot) {
	      // Scan the fractional part of the mantissa.
	      this.Advance();
	      c = this.Peek();
	      // Power of ten by which we need to divide our next digit
	      let divisor = 10;
	      do {
	        fracPart += DecimalDigitValue(c) / divisor;
	        divisor *= 10;
	        this.Advance();
	        c = this.Peek();
	      } while (IsDigit(c));
	    }

	    let gotE = false;
	    if (c == LATIN_SMALL_LETTER_E || c == LATIN_CAPITAL_LETTER_E) {
	      let expSignChar = this.Peek(1);
	      let nextChar = this.Peek(2);
	      if (IsDigit(expSignChar) ||
	          ((expSignChar == HYPHEN_MINUS || expSignChar == PLUS_SIGN) &&
	           IsDigit(nextChar))) {
	        gotE = true;
	        if (expSignChar == HYPHEN_MINUS) {
	          expSign = -1;
	        }
	        this.Advance(); // consumes the E
	        if (expSignChar == HYPHEN_MINUS || expSignChar == PLUS_SIGN) {
	          this.Advance();
	          c = nextChar;
	        } else {
	          c = expSignChar;
	        }
	        do {
	          exponent = 10 * exponent + DecimalDigitValue(c);
	          this.Advance();
	          c = this.Peek();
	        } while (IsDigit(c));
	      }
	    }

	    let type = eCSSToken_Number;

	    // Set mIntegerValid for all cases (except %, below) because we need
	    // it for the "2n" in :nth-child(2n).
	    aToken.mIntegerValid = false;

	    // Time to reassemble our number.
	    // Do all the math in double precision so it's truncated only once.
	    let value = sign * (intPart + fracPart);
	    if (gotE) {
	      // Explicitly cast expSign*exponent to double to avoid issues with
	      // overloaded pow() on Windows.
	      value *= Math.pow(10.0, expSign * exponent);
	    } else if (!gotDot) {
	      // Clamp values outside of integer range.
	      if (sign > 0) {
	        aToken.mInteger = Math.min(intPart, Number.MAX_SAFE_INTEGER);
	      } else {
	        aToken.mInteger = Math.max(-intPart, Number.MIN_SAFE_INTEGER);
	      }
	      aToken.mIntegerValid = true;
	    }

	    let ident = aToken.mIdent;

	    // Check for Dimension and Percentage tokens.
	    if (c >= 0) {
	      if (StartsIdent(c, this.Peek(1))) {
	        if (this.GatherText(IS_IDCHAR, ident)) {
	          type = eCSSToken_Dimension;
	        }
	      } else if (c == PERCENT_SIGN) {
	        this.Advance();
	        type = eCSSToken_Percentage;
	        value = value / 100.0;
	        aToken.mIntegerValid = false;
	      }
	    }
	    aToken.mNumber = value;
	    aToken.mType = type;
	    return true;
	  },

	  /**
	   * Scan a string constant ('foo' or "foo").  Will always produce
	   * either a String or a Bad_String token; the latter occurs when the
	   * close quote is missing.  Always returns true (for convenience in Next()).
	   */
	  ScanString: function (aToken) {
	    let aStop = this.Peek();
	    aToken.mType = eCSSToken_String;
	    aToken.mSymbol = aStop; // Remember how it's quoted.
	    this.Advance();

	    for (;;) {
	      this.GatherText(IS_STRING, aToken.mIdent);

	      let ch = this.Peek();
	      if (ch == -1) {
	        this.AddEOFCharacters(aStop == QUOTATION_MARK ?
	                              eEOFCharacters_DoubleQuote :
	                              eEOFCharacters_SingleQuote);
	        break; // EOF ends a string token with no error.
	      }
	      if (ch == aStop) {
	        this.Advance();
	        break;
	      }
	      // Both " and ' are excluded from IS_STRING.
	      if (ch == QUOTATION_MARK || ch == APOSTROPHE) {
	        aToken.mIdent.push(ch);
	        this.Advance();
	        continue;
	      }

	      aToken.mType = eCSSToken_Bad_String;
	      break;
	    }
	    return true;
	  },

	  /**
	   * Scan a unicode-range token.  These match the regular expression
	   *
	   *     u\+[0-9a-f?]{1,6}(-[0-9a-f]{1,6})?
	   *
	   * However, some such tokens are "invalid".  There are three valid forms:
	   *
	   *     u+[0-9a-f]{x}              1 <= x <= 6
	   *     u+[0-9a-f]{x}\?{y}         1 <= x+y <= 6
	   *     u+[0-9a-f]{x}-[0-9a-f]{y}  1 <= x <= 6, 1 <= y <= 6
	   *
	   * All unicode-range tokens have their text recorded in mIdent; valid ones
	   * are also decoded into mInteger and mInteger2, and mIntegerValid is set.
	   * Note that this does not validate the numeric range, only the syntactic
	   * form.
	   */
	  ScanURange: function (aResult) {
	    let intro1 = this.Peek();
	    let intro2 = this.Peek(1);
	    let ch = this.Peek(2);

	    aResult.mIdent.push(intro1);
	    aResult.mIdent.push(intro2);
	    this.Advance(2);

	    let valid = true;
	    let haveQues = false;
	    let low = 0;
	    let high = 0;
	    let i = 0;

	    do {
	      aResult.mIdent.push(ch);
	      if (IsHexDigit(ch)) {
	        if (haveQues) {
	          valid = false; // All question marks should be at the end.
	        }
	        low = low * 16 + HexDigitValue(ch);
	        high = high * 16 + HexDigitValue(ch);
	      } else {
	        haveQues = true;
	        low = low * 16 + 0x0;
	        high = high * 16 + 0xF;
	      }

	      i++;
	      this.Advance();
	      ch = this.Peek();
	    } while (i < 6 && (IsHexDigit(ch) || ch == QUESTION_MARK));

	    if (ch == HYPHEN_MINUS && IsHexDigit(this.Peek(1))) {
	      if (haveQues) {
	        valid = false;
	      }

	      aResult.mIdent.push(ch);
	      this.Advance();
	      ch = this.Peek();
	      high = 0;
	      i = 0;
	      do {
	        aResult.mIdent.push(ch);
	        high = high * 16 + HexDigitValue(ch);

	        i++;
	        this.Advance();
	        ch = this.Peek();
	      } while (i < 6 && IsHexDigit(ch));
	    }

	    aResult.mInteger = low;
	    aResult.mInteger2 = high;
	    aResult.mIntegerValid = valid;
	    aResult.mType = eCSSToken_URange;
	    return true;
	  },

	  SetEOFCharacters: function (aEOFCharacters) {
	    this.mEOFCharacters = aEOFCharacters;
	  },

	  AddEOFCharacters: function (aEOFCharacters) {
	    this.mEOFCharacters = this.mEOFCharacters | aEOFCharacters;
	  },

	  AppendImpliedEOFCharacters: function (aEOFCharacters, aResult) {
	    // First, ignore eEOFCharacters_DropBackslash.
	    let c = aEOFCharacters >> 1;

	    // All of the remaining EOFCharacters bits represent appended characters,
	    // and the bits are in the order that they need appending.
	    for (let p of kImpliedEOFCharacters) {
	      if (c & 1) {
	        aResult.push(p);
	      }
	      c >>= 1;
	    }
	  },

	  /**
	   * Consume the part of an URL token after the initial 'url('.  Caller
	   * is assumed to have consumed 'url(' already.  Will always produce
	   * either an URL or a Bad_URL token.
	   *
	   * Exposed for use by nsCSSParser::ParseMozDocumentRule, which applies
	   * the special lexical rules for URL tokens in a nonstandard context.
	   */
	  NextURL: function (aToken) {
	    this.SkipWhitespace();

	    // aToken.mIdent may be "url" at this point; clear that out
	    aToken.mIdent.length = 0;

	    let ch = this.Peek();
	    // Do we have a string?
	    if (ch == QUOTATION_MARK || ch == APOSTROPHE) {
	      this.ScanString(aToken);
	      if (aToken.mType == eCSSToken_Bad_String) {
	        aToken.mType = eCSSToken_Bad_URL;
	        // Flag us as having been a Bad_String.
	        aToken.mInteger2 = 1;
	        this.ConsumeBadURLRemnants(aToken);
	        return;
	      }
	    } else {
	      // Otherwise, this is the start of a non-quoted url (which may be empty).
	      aToken.mSymbol = 0;
	      this.GatherText(IS_URL_CHAR, aToken.mIdent);
	    }

	    // Consume trailing whitespace and then look for a close parenthesis.
	    this.SkipWhitespace();
	    ch = this.Peek();
	    // ch can be less than zero indicating EOF
	    if (ch < 0 || ch == RIGHT_PARENTHESIS) {
	      this.Advance();
	      aToken.mType = eCSSToken_URL;
	      if (ch < 0) {
	        this.AddEOFCharacters(eEOFCharacters_CloseParen);
	      }
	    } else {
	      aToken.mType = eCSSToken_Bad_URL;
	      if (aToken.mSymbol != 0) {
	        // Flag us as having been a String, not a Bad_String.
	        aToken.mInteger2 = 0;
	      }
	      this.ConsumeBadURLRemnants(aToken);
	    }
	  },

	  ConsumeBadURLRemnants: function (aToken) {
	    aToken.mInteger = aToken.mIdent.length;
	    let ch = this.Peek();
	    do {
	      if (ch < 0) {
	        this.AddEOFCharacters(eEOFCharacters_CloseParen);
	        break;
	      }

	      if (ch == REVERSE_SOLIDUS && this.GatherEscape(aToken.mIdent, false)) {
	        // Nothing else needs to be done here for the moment; we've consumed the
	        // backslash and following escape.
	      } else {
	        // We always want to consume this character.
	        if (IsVertSpace(ch)) {
	          this.AdvanceLine();
	        } else {
	          this.Advance();
	        }
	        if (ch == 0) {
	          aToken.mIdent.push(UCS2_REPLACEMENT_CHAR);
	        } else {
	          aToken.mIdent.push(ch);
	        }
	      }

	      ch = this.Peek();
	    } while (ch != RIGHT_PARENTHESIS);
	  },

	  /**
	   * Primary scanner entry point.  Consume one token and fill in
	   * |aToken| accordingly.  Will skip over any number of comments first,
	   * and will also skip over rather than return whitespace and comment
	   * tokens, depending on the value of |aSkip|.
	   *
	   * Returns true if it successfully consumed a token, false if EOF has
	   * been reached.  Will always advance the current read position by at
	   * least one character unless called when already at EOF.
	   */
	  Next: function (aToken, aSkip) {
	    let ch;

	    // do this here so we don't have to do it in dozens of other places
	    aToken.mIdent = [];
	    aToken.mType = eCSSToken_Symbol;

	    this.mTokenOffset = this.mOffset;
	    this.mTokenLineOffset = this.mLineOffset;
	    this.mTokenLineNumber = this.mLineNumber;

	    ch = this.Peek();
	    if (IsWhitespace(ch)) {
	      this.SkipWhitespace();
	      aToken.mType = eCSSToken_Whitespace;
	      return true;
	    }
	    if (ch == SOLIDUS && // !IsSVGMode() &&
	        this.Peek(1) == ASTERISK) {
	      this.SkipComment();
	      aToken.mType = eCSSToken_Comment;
	      return true;
	    }

	    // EOF
	    if (ch < 0) {
	      return false;
	    }

	    // 'u' could be UNICODE-RANGE or an identifier-family token
	    if (ch == LATIN_SMALL_LETTER_U || ch == LATIN_CAPITAL_LETTER_U) {
	      let c2 = this.Peek(1);
	      let c3 = this.Peek(2);
	      if (c2 == PLUS_SIGN && (IsHexDigit(c3) || c3 == QUESTION_MARK)) {
	        return this.ScanURange(aToken);
	      }
	      return this.ScanIdent(aToken);
	    }

	    // identifier family
	    if (IsIdentStart(ch)) {
	      return this.ScanIdent(aToken);
	    }

	    // number family
	    if (IsDigit(ch)) {
	      return this.ScanNumber(aToken);
	    }

	    if (ch == FULL_STOP && IsDigit(this.Peek(1))) {
	      return this.ScanNumber(aToken);
	    }

	    if (ch == PLUS_SIGN) {
	      let c2 = this.Peek(1);
	      if (IsDigit(c2) || (c2 == FULL_STOP && IsDigit(this.Peek(2)))) {
	        return this.ScanNumber(aToken);
	      }
	    }

	    // HYPHEN_MINUS can start an identifier-family token, a number-family token,
	    // or an HTML-comment
	    if (ch == HYPHEN_MINUS) {
	      let c2 = this.Peek(1);
	      let c3 = this.Peek(2);
	      if (IsIdentStart(c2) || (c2 == HYPHEN_MINUS && c3 != GREATER_THAN_SIGN)) {
	        return this.ScanIdent(aToken);
	      }
	      if (IsDigit(c2) || (c2 == FULL_STOP && IsDigit(c3))) {
	        return this.ScanNumber(aToken);
	      }
	      if (c2 == HYPHEN_MINUS && c3 == GREATER_THAN_SIGN) {
	        this.Advance(3);
	        aToken.mType = eCSSToken_HTMLComment;
	        aToken.mIdent = stringToCodes("-->");
	        return true;
	      }
	    }

	    // the other HTML-comment token
	    if (ch == LESS_THAN_SIGN &&
	        this.Peek(1) == EXCLAMATION_MARK &&
	        this.Peek(2) == HYPHEN_MINUS &&
	        this.Peek(3) == HYPHEN_MINUS) {
	      this.Advance(4);
	      aToken.mType = eCSSToken_HTMLComment;
	      aToken.mIdent = stringToCodes("<!--");
	      return true;
	    }

	    // AT_KEYWORD
	    if (ch == COMMERCIAL_AT) {
	      return this.ScanAtKeyword(aToken);
	    }

	    // HASH
	    if (ch == NUMBER_SIGN) {
	      return this.ScanHash(aToken);
	    }

	    // STRING
	    if (ch == QUOTATION_MARK || ch == APOSTROPHE) {
	      return this.ScanString(aToken);
	    }

	    // Match operators: ~= |= ^= $= *=
	    let opType = MatchOperatorType(ch);
	    if (opType != eCSSToken_Symbol && this.Peek(1) == EQUALS_SIGN) {
	      aToken.mType = opType;
	      this.Advance(2);
	      return true;
	    }

	    // Otherwise, a symbol (DELIM).
	    aToken.mSymbol = ch;
	    this.Advance();
	    return true;
	  },
	};

	/**
	 * Create and return a new CSS lexer, conforming to the @see CSSLexer
	 * webidl interface.
	 *
	 * @param {String} input the CSS text to lex
	 * @return {CSSLexer} the new lexer
	 */
	function getCSSLexer(input) {
	  return new Scanner(input);
	}

	exports.getCSSLexer = getCSSLexer;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  Option,
	  RetVal,
	  generateActorSpec,
	  types
	} = __webpack_require__(19);
	__webpack_require__(125);
	__webpack_require__(126);

	// Predeclare the domstylerule actor type
	types.addActorType("domstylerule");

	/**
	 * DOM Nodes returned by the style actor will be owned by the DOM walker
	 * for the connection.
	  */
	types.addLifetime("walker", "walker");

	/**
	 * When asking for the styles applied to a node, we return a list of
	 * appliedstyle json objects that lists the rules that apply to the node
	 * and which element they were inherited from (if any).
	 *
	 * Note appliedstyle only sends the list of actorIDs and is not a valid return
	 * value on its own. appliedstyle should be returned with the actual list of
	 * StyleRuleActor and StyleSheetActor. See appliedStylesReturn.
	 */
	types.addDictType("appliedstyle", {
	  rule: "domstylerule#actorid",
	  inherited: "nullable:domnode#actorid",
	  keyframes: "nullable:domstylerule#actorid"
	});

	types.addDictType("matchedselector", {
	  rule: "domstylerule#actorid",
	  selector: "string",
	  value: "string",
	  status: "number"
	});

	types.addDictType("appliedStylesReturn", {
	  entries: "array:appliedstyle",
	  rules: "array:domstylerule",
	  sheets: "array:stylesheet"
	});

	types.addDictType("modifiedStylesReturn", {
	  isMatching: RetVal("boolean"),
	  ruleProps: RetVal("nullable:appliedStylesReturn")
	});

	types.addDictType("fontpreview", {
	  data: "nullable:longstring",
	  size: "json"
	});

	types.addDictType("fontface", {
	  name: "string",
	  CSSFamilyName: "string",
	  rule: "nullable:domstylerule",
	  srcIndex: "number",
	  URI: "string",
	  format: "string",
	  preview: "nullable:fontpreview",
	  localName: "string",
	  metadata: "string"
	});

	const pageStyleSpec = generateActorSpec({
	  typeName: "pagestyle",

	  events: {
	    "stylesheet-updated": {
	      type: "styleSheetUpdated",
	      styleSheet: Arg(0, "stylesheet")
	    }
	  },

	  methods: {
	    getComputed: {
	      request: {
	        node: Arg(0, "domnode"),
	        markMatched: Option(1, "boolean"),
	        onlyMatched: Option(1, "boolean"),
	        filter: Option(1, "string"),
	      },
	      response: {
	        computed: RetVal("json")
	      }
	    },
	    getAllUsedFontFaces: {
	      request: {
	        includePreviews: Option(0, "boolean"),
	        previewText: Option(0, "string"),
	        previewFontSize: Option(0, "string"),
	        previewFillStyle: Option(0, "string")
	      },
	      response: {
	        fontFaces: RetVal("array:fontface")
	      }
	    },
	    getUsedFontFaces: {
	      request: {
	        node: Arg(0, "domnode"),
	        includePreviews: Option(1, "boolean"),
	        previewText: Option(1, "string"),
	        previewFontSize: Option(1, "string"),
	        previewFillStyle: Option(1, "string")
	      },
	      response: {
	        fontFaces: RetVal("array:fontface")
	      }
	    },
	    getMatchedSelectors: {
	      request: {
	        node: Arg(0, "domnode"),
	        property: Arg(1, "string"),
	        filter: Option(2, "string")
	      },
	      response: RetVal(types.addDictType("matchedselectorresponse", {
	        rules: "array:domstylerule",
	        sheets: "array:stylesheet",
	        matched: "array:matchedselector"
	      }))
	    },
	    getApplied: {
	      request: {
	        node: Arg(0, "domnode"),
	        inherited: Option(1, "boolean"),
	        matchedSelectors: Option(1, "boolean"),
	        filter: Option(1, "string")
	      },
	      response: RetVal("appliedStylesReturn")
	    },
	    isPositionEditable: {
	      request: { node: Arg(0, "domnode")},
	      response: { value: RetVal("boolean") }
	    },
	    getLayout: {
	      request: {
	        node: Arg(0, "domnode"),
	        autoMargins: Option(1, "boolean")
	      },
	      response: RetVal("json")
	    },
	    addNewRule: {
	      request: {
	        node: Arg(0, "domnode"),
	        pseudoClasses: Arg(1, "nullable:array:string"),
	        editAuthored: Arg(2, "boolean")
	      },
	      response: RetVal("appliedStylesReturn")
	    }
	  }
	});

	exports.pageStyleSpec = pageStyleSpec;

	const styleRuleSpec = generateActorSpec({
	  typeName: "domstylerule",

	  events: {
	    "location-changed": {
	      type: "locationChanged",
	      line: Arg(0, "number"),
	      column: Arg(1, "number")
	    },
	  },

	  methods: {
	    setRuleText: {
	      request: { modification: Arg(0, "string") },
	      response: { rule: RetVal("domstylerule") }
	    },
	    modifyProperties: {
	      request: { modifications: Arg(0, "array:json") },
	      response: { rule: RetVal("domstylerule") }
	    },
	    modifySelector: {
	      request: { selector: Arg(0, "string") },
	      response: { isModified: RetVal("boolean") },
	    },
	    modifySelector2: {
	      request: {
	        node: Arg(0, "domnode"),
	        value: Arg(1, "string"),
	        editAuthored: Arg(2, "boolean")
	      },
	      response: RetVal("modifiedStylesReturn")
	    }
	  }
	});

	exports.styleRuleSpec = styleRuleSpec;

	// The PageStyle actor flattens the DOM CSS objects a little bit, merging
	// Rules and their Styles into one actor.  For elements (which have a style
	// but no associated rule) we fake a rule with the following style id.
	const ELEMENT_STYLE = 100;
	exports.ELEMENT_STYLE = ELEMENT_STYLE;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  RetVal,
	  generateActorSpec,
	  types
	} = __webpack_require__(19);

	types.addDictType("imageData", {
	  // The image data
	  data: "nullable:longstring",
	  // The original image dimensions
	  size: "json"
	});

	const nodeSpec = generateActorSpec({
	  typeName: "domnode",

	  methods: {
	    getNodeValue: {
	      request: {},
	      response: {
	        value: RetVal("longstring")
	      }
	    },
	    setNodeValue: {
	      request: { value: Arg(0) },
	      response: {}
	    },
	    getUniqueSelector: {
	      request: {},
	      response: {
	        value: RetVal("string")
	      }
	    },
	    scrollIntoView: {
	      request: {},
	      response: {}
	    },
	    getImageData: {
	      request: {maxDim: Arg(0, "nullable:number")},
	      response: RetVal("imageData")
	    },
	    getEventListenerInfo: {
	      request: {},
	      response: {
	        events: RetVal("json")
	      }
	    },
	    modifyAttributes: {
	      request: {
	        modifications: Arg(0, "array:json")
	      },
	      response: {}
	    },
	    getFontFamilyDataURL: {
	      request: {font: Arg(0, "string"), fillStyle: Arg(1, "nullable:string")},
	      response: RetVal("imageData")
	    }
	  }
	});

	exports.nodeSpec = nodeSpec;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  RetVal,
	  generateActorSpec,
	  types
	} = __webpack_require__(19);

	const originalSourceSpec = generateActorSpec({
	  typeName: "originalsource",

	  methods: {
	    getText: {
	      response: {
	        text: RetVal("longstring")
	      }
	    }
	  }
	});

	exports.originalSourceSpec = originalSourceSpec;

	const mediaRuleSpec = generateActorSpec({
	  typeName: "mediarule",

	  events: {
	    "matches-change": {
	      type: "matchesChange",
	      matches: Arg(0, "boolean"),
	    }
	  }
	});

	exports.mediaRuleSpec = mediaRuleSpec;

	types.addActorType("stylesheet");

	const styleSheetSpec = generateActorSpec({
	  typeName: "stylesheet",

	  events: {
	    "property-change": {
	      type: "propertyChange",
	      property: Arg(0, "string"),
	      value: Arg(1, "json")
	    },
	    "style-applied": {
	      type: "styleApplied",
	      kind: Arg(0, "number"),
	      styleSheet: Arg(1, "stylesheet")
	    },
	    "media-rules-changed": {
	      type: "mediaRulesChanged",
	      rules: Arg(0, "array:mediarule")
	    }
	  },

	  methods: {
	    toggleDisabled: {
	      response: { disabled: RetVal("boolean")}
	    },
	    getText: {
	      response: {
	        text: RetVal("longstring")
	      }
	    },
	    getOriginalSources: {
	      request: {},
	      response: {
	        originalSources: RetVal("nullable:array:originalsource")
	      }
	    },
	    getOriginalLocation: {
	      request: {
	        line: Arg(0, "number"),
	        column: Arg(1, "number")
	      },
	      response: RetVal(types.addDictType("originallocationresponse", {
	        source: "string",
	        line: "number",
	        column: "number"
	      }))
	    },
	    getMediaRules: {
	      request: {},
	      response: {
	        mediaRules: RetVal("nullable:array:mediarule")
	      }
	    },
	    update: {
	      request: {
	        text: Arg(0, "string"),
	        transition: Arg(1, "boolean")
	      }
	    }
	  }
	});

	exports.styleSheetSpec = styleSheetSpec;

	const styleSheetsSpec = generateActorSpec({
	  typeName: "stylesheets",

	  methods: {
	    getStyleSheets: {
	      request: {},
	      response: { styleSheets: RetVal("array:stylesheet") }
	    },
	    addStyleSheet: {
	      request: { text: Arg(0, "string") },
	      response: { styleSheet: RetVal("stylesheet") }
	    }
	  }
	});

	exports.styleSheetsSpec = styleSheetsSpec;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {Cc, Ci} = __webpack_require__(11);
	const {angleUtils} = __webpack_require__(128);
	const {colorUtils} = __webpack_require__(129);
	const {getCSSLexer} = __webpack_require__(123);
	const EventEmitter = __webpack_require__(6);
	const {
	  ANGLE_TAKING_FUNCTIONS,
	  BEZIER_KEYWORDS,
	  COLOR_TAKING_FUNCTIONS,
	  CSS_TYPES
	} = __webpack_require__(31);

	const HTML_NS = "http://www.w3.org/1999/xhtml";

	// loader.lazyGetter(this, "DOMUtils", function () {
	//   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	// });

	/**
	 * This module is used to process text for output by developer tools. This means
	 * linking JS files with the debugger, CSS files with the style editor, JS
	 * functions with the debugger, placing color swatches next to colors and
	 * adding doorhanger previews where possible (images, angles, lengths,
	 * border radius, cubic-bezier etc.).
	 *
	 * Usage:
	 *   const {OutputParser} = require("devtools/client/shared/output-parser");
	 *
	 *   let parser = new OutputParser(document, supportsType);
	 *
	 *   parser.parseCssProperty("color", "red"); // Returns document fragment.
	 *
	 * @param {Document} document Used to create DOM nodes.
	 * @param {Function} supportsTypes A function that returns a boolean when asked if a css
	 * property name supports a given css type.
	 * The function is executed like supportsType("color", CSS_TYPES.COLOR) where CSS_TYPES is
	 * defined in devtools/shared/css-properties-db.js
	 */
	function OutputParser(document, supportsType) {
	  this.parsed = [];
	  this.doc = document;
	  this.supportsType = supportsType;
	  this.colorSwatches = new WeakMap();
	  this.angleSwatches = new WeakMap();
	  this._onColorSwatchMouseDown = this._onColorSwatchMouseDown.bind(this);
	  this._onAngleSwatchMouseDown = this._onAngleSwatchMouseDown.bind(this);
	}

	exports.OutputParser = OutputParser;

	OutputParser.prototype = {
	  /**
	   * Parse a CSS property value given a property name.
	   *
	   * @param  {String} name
	   *         CSS Property Name
	   * @param  {String} value
	   *         CSS Property value
	   * @param  {Object} [options]
	   *         Options object. For valid options and default values see
	   *         _mergeOptions().
	   * @return {DocumentFragment}
	   *         A document fragment containing color swatches etc.
	   */
	  parseCssProperty: function (name, value, options = {}) {
	    options = this._mergeOptions(options);

	    options.expectCubicBezier = this.supportsType(name, CSS_TYPES.TIMING_FUNCTION);
	    options.expectFilter = name === "filter";
	    options.supportsColor = this.supportsType(name, CSS_TYPES.COLOR) ||
	                            this.supportsType(name, CSS_TYPES.GRADIENT);

	    // The filter property is special in that we want to show the
	    // swatch even if the value is invalid, because this way the user
	    // can easily use the editor to fix it.
	    if (options.expectFilter || this._cssPropertySupportsValue(name, value)) {
	      return this._parse(value, options);
	    }
	    this._appendTextNode(value);

	    return this._toDOM();
	  },

	  /**
	   * Given an initial FUNCTION token, read tokens from |tokenStream|
	   * and collect all the (non-comment) text.  Return the collected
	   * text.  The function token and the close paren are included in the
	   * result.
	   *
	   * @param  {CSSToken} initialToken
	   *         The FUNCTION token.
	   * @param  {String} text
	   *         The original CSS text.
	   * @param  {CSSLexer} tokenStream
	   *         The token stream from which to read.
	   * @return {String}
	   *         The text of body of the function call.
	   */
	  _collectFunctionText: function (initialToken, text, tokenStream) {
	    let result = text.substring(initialToken.startOffset,
	                                initialToken.endOffset);
	    let depth = 1;
	    while (depth > 0) {
	      let token = tokenStream.nextToken();
	      if (!token) {
	        break;
	      }
	      if (token.tokenType === "comment") {
	        continue;
	      }
	      result += text.substring(token.startOffset, token.endOffset);
	      if (token.tokenType === "symbol") {
	        if (token.text === "(") {
	          ++depth;
	        } else if (token.text === ")") {
	          --depth;
	        }
	      } else if (token.tokenType === "function") {
	        ++depth;
	      }
	    }
	    return result;
	  },

	  /**
	   * Parse a string.
	   *
	   * @param  {String} text
	   *         Text to parse.
	   * @param  {Object} [options]
	   *         Options object. For valid options and default values see
	   *         _mergeOptions().
	   * @return {DocumentFragment}
	   *         A document fragment.
	   */
	  _parse: function (text, options = {}) {
	    text = text.trim();
	    this.parsed.length = 0;

	    let tokenStream = getCSSLexer(text);
	    let parenDepth = 0;
	    let outerMostFunctionTakesColor = false;

	    let colorOK = function () {
	      return options.supportsColor ||
	        (options.expectFilter && parenDepth === 1 &&
	         outerMostFunctionTakesColor);
	    };

	    let angleOK = function (angle) {
	      return (new angleUtils.CssAngle(angle)).valid;
	    };

	    while (true) {
	      let token = tokenStream.nextToken();
	      if (!token) {
	        break;
	      }
	      if (token.tokenType === "comment") {
	        continue;
	      }

	      switch (token.tokenType) {
	        case "function": {
	          if (COLOR_TAKING_FUNCTIONS.includes(token.text) ||
	              ANGLE_TAKING_FUNCTIONS.includes(token.text)) {
	            // The function can accept a color or an angle argument, and we know
	            // it isn't special in some other way. So, we let it
	            // through to the ordinary parsing loop so that the value
	            // can be handled in a single place.
	            this._appendTextNode(text.substring(token.startOffset,
	                                                token.endOffset));
	            if (parenDepth === 0) {
	              outerMostFunctionTakesColor = COLOR_TAKING_FUNCTIONS.includes(
	                token.text);
	            }
	            ++parenDepth;
	          } else {
	            let functionText = this._collectFunctionText(token, text,
	                                                         tokenStream);

	            if (options.expectCubicBezier && token.text === "cubic-bezier") {
	              this._appendCubicBezier(functionText, options);
	            } else if (colorOK() && colorUtils.isValidCSSColor(functionText)) {
	              this._appendColor(functionText, options);
	            } else {
	              this._appendTextNode(functionText);
	            }
	          }
	          break;
	        }

	        case "ident":
	          if (options.expectCubicBezier &&
	              BEZIER_KEYWORDS.indexOf(token.text) >= 0) {
	            this._appendCubicBezier(token.text, options);
	          } else if (colorOK() && colorUtils.isValidCSSColor(token.text)) {
	            this._appendColor(token.text, options);
	          } else if (angleOK(token.text)) {
	            this._appendAngle(token.text, options);
	          } else {
	            this._appendTextNode(text.substring(token.startOffset,
	                                                token.endOffset));
	          }
	          break;

	        case "id":
	        case "hash": {
	          let original = text.substring(token.startOffset, token.endOffset);
	          if (colorOK() && colorUtils.isValidCSSColor(original)) {
	            this._appendColor(original, options);
	          } else {
	            this._appendTextNode(original);
	          }
	          break;
	        }
	        case "dimension":
	          let value = text.substring(token.startOffset, token.endOffset);
	          if (angleOK(value)) {
	            this._appendAngle(value, options);
	          } else {
	            this._appendTextNode(value);
	          }
	          break;
	        case "url":
	        case "bad_url":
	          this._appendURL(text.substring(token.startOffset, token.endOffset),
	                          token.text, options);
	          break;

	        case "symbol":
	          if (token.text === "(") {
	            ++parenDepth;
	          } else if (token.text === ")") {
	            --parenDepth;
	            if (parenDepth === 0) {
	              outerMostFunctionTakesColor = false;
	            }
	          }
	          // falls through
	        default:
	          this._appendTextNode(
	            text.substring(token.startOffset, token.endOffset));
	          break;
	      }
	    }

	    let result = this._toDOM();

	    if (options.expectFilter && !options.filterSwatch) {
	      result = this._wrapFilter(text, options, result);
	    }

	    return result;
	  },

	  /**
	   * Append a cubic-bezier timing function value to the output
	   *
	   * @param {String} bezier
	   *        The cubic-bezier timing function
	   * @param {Object} options
	   *        Options object. For valid options and default values see
	   *        _mergeOptions()
	   */
	  _appendCubicBezier: function (bezier, options) {
	    let container = this._createNode("span", {
	      "data-bezier": bezier
	    });

	    if (options.bezierSwatchClass) {
	      let swatch = this._createNode("span", {
	        class: options.bezierSwatchClass
	      });
	      container.appendChild(swatch);
	    }

	    let value = this._createNode("span", {
	      class: options.bezierClass
	    }, bezier);

	    container.appendChild(value);
	    this.parsed.push(container);
	  },

	  /**
	   * Append a angle value to the output
	   *
	   * @param {String} angle
	   *        angle to append
	   * @param {Object} options
	   *        Options object. For valid options and default values see
	   *        _mergeOptions()
	   */
	  _appendAngle: function (angle, options) {
	    let angleObj = new angleUtils.CssAngle(angle);
	    let container = this._createNode("span", {
	      "data-angle": angle
	    });

	    if (options.angleSwatchClass) {
	      let swatch = this._createNode("span", {
	        class: options.angleSwatchClass
	      });
	      this.angleSwatches.set(swatch, angleObj);
	      swatch.addEventListener("mousedown", this._onAngleSwatchMouseDown, false);

	      // Add click listener to stop event propagation when shift key is pressed
	      // in order to prevent the value input to be focused.
	      // Bug 711942 will add a tooltip to edit angle values and we should
	      // be able to move this listener to Tooltip.js when it'll be implemented.
	      swatch.addEventListener("click", function (event) {
	        if (event.shiftKey) {
	          event.stopPropagation();
	        }
	      }, false);
	      EventEmitter.decorate(swatch);
	      container.appendChild(swatch);
	    }

	    let value = this._createNode("span", {
	      class: options.angleClass
	    }, angle);

	    container.appendChild(value);
	    this.parsed.push(container);
	  },

	  /**
	   * Check if a CSS property supports a specific value.
	   *
	   * @param  {String} name
	   *         CSS Property name to check
	   * @param  {String} value
	   *         CSS Property value to check
	   */
	  _cssPropertySupportsValue: function (name, value) {
	    return DOMUtils.cssPropertyIsValid(name, value);
	  },

	  /**
	   * Tests if a given colorObject output by CssColor is valid for parsing.
	   * Valid means it's really a color, not any of the CssColor SPECIAL_VALUES
	   * except transparent
	   */
	  _isValidColor: function (colorObj) {
	    return colorObj.valid &&
	      (!colorObj.specialValue || colorObj.specialValue === "transparent");
	  },

	  /**
	   * Append a color to the output.
	   *
	   * @param  {String} color
	   *         Color to append
	   * @param  {Object} [options]
	   *         Options object. For valid options and default values see
	   *         _mergeOptions().
	   */
	  _appendColor: function (color, options = {}) {
	    let colorObj = new colorUtils.CssColor(color);

	    if (this._isValidColor(colorObj)) {
	      let container = this._createNode("span", {
	        "data-color": color
	      });

	      if (options.colorSwatchClass) {
	        let swatch = this._createNode("span", {
	          class: options.colorSwatchClass,
	          style: "background-color:" + color
	        });
	        this.colorSwatches.set(swatch, colorObj);
	        swatch.addEventListener("mousedown", this._onColorSwatchMouseDown,
	                                false);
	        EventEmitter.decorate(swatch);
	        container.appendChild(swatch);
	      }

	      if (options.defaultColorType) {
	        color = colorObj.toString();
	        container.dataset.color = color;
	      }

	      let value = this._createNode("span", {
	        class: options.colorClass
	      }, color);

	      container.appendChild(value);
	      this.parsed.push(container);
	    } else {
	      this._appendTextNode(color);
	    }
	  },

	  /**
	   * Wrap some existing nodes in a filter editor.
	   *
	   * @param {String} filters
	   *        The full text of the "filter" property.
	   * @param {object} options
	   *        The options object passed to parseCssProperty().
	   * @param {object} nodes
	   *        Nodes created by _toDOM().
	   *
	   * @returns {object}
	   *        A new node that supplies a filter swatch and that wraps |nodes|.
	   */
	  _wrapFilter: function (filters, options, nodes) {
	    let container = this._createNode("span", {
	      "data-filters": filters
	    });

	    if (options.filterSwatchClass) {
	      let swatch = this._createNode("span", {
	        class: options.filterSwatchClass
	      });
	      container.appendChild(swatch);
	    }

	    let value = this._createNode("span", {
	      class: options.filterClass
	    });
	    value.appendChild(nodes);
	    container.appendChild(value);

	    return container;
	  },

	  _onColorSwatchMouseDown: function (event) {
	    if (!event.shiftKey) {
	      return;
	    }

	    // Prevent click event to be fired to not show the tooltip
	    event.stopPropagation();

	    let swatch = event.target;
	    let color = this.colorSwatches.get(swatch);
	    let val = color.nextColorUnit();

	    swatch.nextElementSibling.textContent = val;
	    swatch.emit("unit-change", val);
	  },

	  _onAngleSwatchMouseDown: function (event) {
	    if (!event.shiftKey) {
	      return;
	    }

	    event.stopPropagation();

	    let swatch = event.target;
	    let angle = this.angleSwatches.get(swatch);
	    let val = angle.nextAngleUnit();

	    swatch.nextElementSibling.textContent = val;
	    swatch.emit("unit-change", val);
	  },

	  /**
	   * A helper function that sanitizes a possibly-unterminated URL.
	   */
	  _sanitizeURL: function (url) {
	    // Re-lex the URL and add any needed termination characters.
	    let urlTokenizer = getCSSLexer(url);
	    // Just read until EOF; there will only be a single token.
	    while (urlTokenizer.nextToken()) {
	      // Nothing.
	    }

	    return urlTokenizer.performEOFFixup(url, true);
	  },

	  /**
	   * Append a URL to the output.
	   *
	   * @param  {String} match
	   *         Complete match that may include "url(xxx)"
	   * @param  {String} url
	   *         Actual URL
	   * @param  {Object} [options]
	   *         Options object. For valid options and default values see
	   *         _mergeOptions().
	   */
	  _appendURL: function (match, url, options) {
	    if (options.urlClass) {
	      // Sanitize the URL.  Note that if we modify the URL, we just
	      // leave the termination characters.  This isn't strictly
	      // "as-authored", but it makes a bit more sense.
	      match = this._sanitizeURL(match);
	      // This regexp matches a URL token.  It puts the "url(", any
	      // leading whitespace, and any opening quote into |leader|; the
	      // URL text itself into |body|, and any trailing quote, trailing
	      // whitespace, and the ")" into |trailer|.  We considered adding
	      // functionality for this to CSSLexer, in some way, but this
	      // seemed simpler on the whole.
	      let [, leader, , body, trailer] =
	        /^(url\([ \t\r\n\f]*(["']?))(.*?)(\2[ \t\r\n\f]*\))$/i.exec(match);

	      this._appendTextNode(leader);

	      let href = url;
	      if (options.baseURI) {
	        try {
	          href = new URL(url, options.baseURI).href;
	        } catch (e) {
	          // Ignore.
	        }
	      }

	      this._appendNode("a", {
	        target: "_blank",
	        class: options.urlClass,
	        href: href
	      }, body);

	      this._appendTextNode(trailer);
	    } else {
	      this._appendTextNode(match);
	    }
	  },

	  /**
	   * Create a node.
	   *
	   * @param  {String} tagName
	   *         Tag type e.g. "div"
	   * @param  {Object} attributes
	   *         e.g. {class: "someClass", style: "cursor:pointer"};
	   * @param  {String} [value]
	   *         If a value is included it will be appended as a text node inside
	   *         the tag. This is useful e.g. for span tags.
	   * @return {Node} Newly created Node.
	   */
	  _createNode: function (tagName, attributes, value = "") {
	    let node = this.doc.createElementNS(HTML_NS, tagName);
	    let attrs = Object.getOwnPropertyNames(attributes);

	    for (let attr of attrs) {
	      if (attributes[attr]) {
	        node.setAttribute(attr, attributes[attr]);
	      }
	    }

	    if (value) {
	      let textNode = this.doc.createTextNode(value);
	      node.appendChild(textNode);
	    }

	    return node;
	  },

	  /**
	   * Append a node to the output.
	   *
	   * @param  {String} tagName
	   *         Tag type e.g. "div"
	   * @param  {Object} attributes
	   *         e.g. {class: "someClass", style: "cursor:pointer"};
	   * @param  {String} [value]
	   *         If a value is included it will be appended as a text node inside
	   *         the tag. This is useful e.g. for span tags.
	   */
	  _appendNode: function (tagName, attributes, value = "") {
	    let node = this._createNode(tagName, attributes, value);
	    this.parsed.push(node);
	  },

	  /**
	   * Append a text node to the output. If the previously output item was a text
	   * node then we append the text to that node.
	   *
	   * @param  {String} text
	   *         Text to append
	   */
	  _appendTextNode: function (text) {
	    let lastItem = this.parsed[this.parsed.length - 1];
	    if (typeof lastItem === "string") {
	      this.parsed[this.parsed.length - 1] = lastItem + text;
	    } else {
	      this.parsed.push(text);
	    }
	  },

	  /**
	   * Take all output and append it into a single DocumentFragment.
	   *
	   * @return {DocumentFragment}
	   *         Document Fragment
	   */
	  _toDOM: function () {
	    let frag = this.doc.createDocumentFragment();

	    for (let item of this.parsed) {
	      if (typeof item === "string") {
	        frag.appendChild(this.doc.createTextNode(item));
	      } else {
	        frag.appendChild(item);
	      }
	    }

	    this.parsed.length = 0;
	    return frag;
	  },

	  /**
	   * Merges options objects. Default values are set here.
	   *
	   * @param  {Object} overrides
	   *         The option values to override e.g. _mergeOptions({colors: false})
	   *
	   *         Valid options are:
	   *           - defaultColorType: true // Convert colors to the default type
	   *                                    // selected in the options panel.
	   *           - colorSwatchClass: ""   // The class to use for color swatches.
	   *           - colorClass: ""         // The class to use for the color value
	   *                                    // that follows the swatch.
	   *           - bezierSwatchClass: ""  // The class to use for bezier swatches.
	   *           - bezierClass: ""        // The class to use for the bezier value
	   *                                    // that follows the swatch.
	   *           - angleSwatchClass: ""   // The class to use for angle swatches.
	   *           - angleClass: ""         // The class to use for the angle value
	   *                                    // that follows the swatch.
	   *           - supportsColor: false   // Does the CSS property support colors?
	   *           - urlClass: ""           // The class to be used for url() links.
	   *           - baseURI: undefined     // A string used to resolve
	   *                                    // relative links.
	   *           - filterSwatch: false    // A special case for parsing a
	   *                                    // "filter" property, causing the
	   *                                    // parser to skip the call to
	   *                                    // _wrapFilter.  Used only for
	   *                                    // previewing with the filter swatch.
	   * @return {Object}
	   *         Overridden options object
	   */
	  _mergeOptions: function (overrides) {
	    let defaults = {
	      defaultColorType: true,
	      colorSwatchClass: "",
	      colorClass: "",
	      bezierSwatchClass: "",
	      bezierClass: "",
	      angleSwatchClass: "",
	      angleClass: "",
	      supportsColor: false,
	      urlClass: "",
	      baseURI: undefined,
	      filterSwatch: false
	    };

	    for (let item in overrides) {
	      defaults[item] = overrides[item];
	    }
	    return defaults;
	  }
	};


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const SPECIALVALUES = new Set([
	  "initial",
	  "inherit",
	  "unset"
	]);

	const {getCSSLexer} = __webpack_require__(123);

	/**
	 * This module is used to convert between various angle units.
	 *
	 * Usage:
	 *   let {angleUtils} = require("devtools/client/shared/css-angle");
	 *   let angle = new angleUtils.CssAngle("180deg");
	 *
	 *   angle.authored === "180deg"
	 *   angle.valid === true
	 *   angle.rad === "3,14rad"
	 *   angle.grad === "200grad"
	 *   angle.turn === "0.5turn"
	 *
	 *   angle.toString() === "180deg"; // Outputs the angle value and its unit
	 *   // Angle objects can be reused
	 *   angle.newAngle("-1TURN") === "-1TURN"; // true
	 */

	function CssAngle(angleValue) {
	  this.newAngle(angleValue);
	}

	module.exports.angleUtils = {
	  CssAngle: CssAngle,
	  classifyAngle: classifyAngle
	};

	CssAngle.ANGLEUNIT = {
	  "deg": "deg",
	  "rad": "rad",
	  "grad": "grad",
	  "turn": "turn"
	};

	CssAngle.prototype = {
	  _angleUnit: null,
	  _angleUnitUppercase: false,

	  // The value as-authored.
	  authored: null,
	  // A lower-cased copy of |authored|.
	  lowerCased: null,

	  get angleUnit() {
	    if (this._angleUnit === null) {
	      this._angleUnit = classifyAngle(this.authored);
	    }
	    return this._angleUnit;
	  },

	  set angleUnit(unit) {
	    this._angleUnit = unit;
	  },

	  get valid() {
	    let token = getCSSLexer(this.authored).nextToken();
	    if (!token) {
	      return false;
	    }
	    return (token.tokenType === "dimension"
	      && token.text.toLowerCase() in CssAngle.ANGLEUNIT);
	  },

	  get specialValue() {
	    return SPECIALVALUES.has(this.lowerCased) ? this.authored : null;
	  },

	  get deg() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let angleUnit = classifyAngle(this.authored);
	    if (angleUnit === CssAngle.ANGLEUNIT.deg) {
	      // The angle is valid and is in degree.
	      return this.authored;
	    }

	    let degValue;
	    if (angleUnit === CssAngle.ANGLEUNIT.rad) {
	      // The angle is valid and is in radian.
	      degValue = this.authoredAngleValue / (Math.PI / 180);
	    }

	    if (angleUnit === CssAngle.ANGLEUNIT.grad) {
	      // The angle is valid and is in gradian.
	      degValue = this.authoredAngleValue * 0.9;
	    }

	    if (angleUnit === CssAngle.ANGLEUNIT.turn) {
	      // The angle is valid and is in turn.
	      degValue = this.authoredAngleValue * 360;
	    }

	    let unitStr = CssAngle.ANGLEUNIT.deg;
	    if (this._angleUnitUppercase === true) {
	      unitStr = unitStr.toUpperCase();
	    }
	    return `${Math.round(degValue * 100) / 100}${unitStr}`;
	  },

	  get rad() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let unit = classifyAngle(this.authored);
	    if (unit === CssAngle.ANGLEUNIT.rad) {
	      // The angle is valid and is in radian.
	      return this.authored;
	    }

	    let radValue;
	    if (unit === CssAngle.ANGLEUNIT.deg) {
	      // The angle is valid and is in degree.
	      radValue = this.authoredAngleValue * (Math.PI / 180);
	    }

	    if (unit === CssAngle.ANGLEUNIT.grad) {
	      // The angle is valid and is in gradian.
	      radValue = this.authoredAngleValue * 0.9 * (Math.PI / 180);
	    }

	    if (unit === CssAngle.ANGLEUNIT.turn) {
	      // The angle is valid and is in turn.
	      radValue = this.authoredAngleValue * 360 * (Math.PI / 180);
	    }

	    let unitStr = CssAngle.ANGLEUNIT.rad;
	    if (this._angleUnitUppercase === true) {
	      unitStr = unitStr.toUpperCase();
	    }
	    return `${Math.round(radValue * 10000) / 10000}${unitStr}`;
	  },

	  get grad() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let unit = classifyAngle(this.authored);
	    if (unit === CssAngle.ANGLEUNIT.grad) {
	      // The angle is valid and is in gradian
	      return this.authored;
	    }

	    let gradValue;
	    if (unit === CssAngle.ANGLEUNIT.deg) {
	      // The angle is valid and is in degree
	      gradValue = this.authoredAngleValue / 0.9;
	    }

	    if (unit === CssAngle.ANGLEUNIT.rad) {
	      // The angle is valid and is in radian
	      gradValue = this.authoredAngleValue / 0.9 / (Math.PI / 180);
	    }

	    if (unit === CssAngle.ANGLEUNIT.turn) {
	      // The angle is valid and is in turn
	      gradValue = this.authoredAngleValue * 400;
	    }

	    let unitStr = CssAngle.ANGLEUNIT.grad;
	    if (this._angleUnitUppercase === true) {
	      unitStr = unitStr.toUpperCase();
	    }
	    return `${Math.round(gradValue * 100) / 100}${unitStr}`;
	  },

	  get turn() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let unit = classifyAngle(this.authored);
	    if (unit === CssAngle.ANGLEUNIT.turn) {
	      // The angle is valid and is in turn
	      return this.authored;
	    }

	    let turnValue;
	    if (unit === CssAngle.ANGLEUNIT.deg) {
	      // The angle is valid and is in degree
	      turnValue = this.authoredAngleValue / 360;
	    }

	    if (unit === CssAngle.ANGLEUNIT.rad) {
	      // The angle is valid and is in radian
	      turnValue = (this.authoredAngleValue / (Math.PI / 180)) / 360;
	    }

	    if (unit === CssAngle.ANGLEUNIT.grad) {
	      // The angle is valid and is in gradian
	      turnValue = this.authoredAngleValue / 400;
	    }

	    let unitStr = CssAngle.ANGLEUNIT.turn;
	    if (this._angleUnitUppercase === true) {
	      unitStr = unitStr.toUpperCase();
	    }
	    return `${Math.round(turnValue * 100) / 100}${unitStr}`;
	  },

	  /**
	   * Check whether the angle value is in the special list e.g.
	   * inherit or invalid.
	   *
	   * @return {String|Boolean}
	   *         - If the current angle is a special value e.g. "inherit" then
	   *           return the angle.
	   *         - If the angle is invalid return an empty string.
	   *         - If the angle is a regular angle e.g. 90deg so we return false
	   *           to indicate that the angle is neither invalid nor special.
	   */
	  _getInvalidOrSpecialValue: function () {
	    if (this.specialValue) {
	      return this.specialValue;
	    }
	    if (!this.valid) {
	      return "";
	    }
	    return false;
	  },

	  /**
	   * Change angle
	   *
	   * @param  {String} angle
	   *         Any valid angle value + unit string
	   */
	  newAngle: function (angle) {
	    // Store a lower-cased version of the angle to help with format
	    // testing.  The original text is kept as well so it can be
	    // returned when needed.
	    this.lowerCased = angle.toLowerCase();
	    this._angleUnitUppercase = (angle === angle.toUpperCase());
	    this.authored = angle;

	    let reg = new RegExp(
	      `(${Object.keys(CssAngle.ANGLEUNIT).join("|")})$`, "i");
	    let unitStartIdx = angle.search(reg);
	    this.authoredAngleValue = angle.substring(0, unitStartIdx);
	    this.authoredAngleUnit = angle.substring(unitStartIdx, angle.length);

	    return this;
	  },

	  nextAngleUnit: function () {
	    // Get a reordered array from the formats object
	    // to have the current format at the front so we can cycle through.
	    let formats = Object.keys(CssAngle.ANGLEUNIT);
	    let putOnEnd = formats.splice(0, formats.indexOf(this.angleUnit));
	    formats = formats.concat(putOnEnd);
	    let currentDisplayedValue = this[formats[0]];

	    for (let format of formats) {
	      if (this[format].toLowerCase() !== currentDisplayedValue.toLowerCase()) {
	        this.angleUnit = CssAngle.ANGLEUNIT[format];
	        break;
	      }
	    }
	    return this.toString();
	  },

	  /**
	   * Return a string representing a angle
	   */
	  toString: function () {
	    let angle;

	    switch (this.angleUnit) {
	      case CssAngle.ANGLEUNIT.deg:
	        angle = this.deg;
	        break;
	      case CssAngle.ANGLEUNIT.rad:
	        angle = this.rad;
	        break;
	      case CssAngle.ANGLEUNIT.grad:
	        angle = this.grad;
	        break;
	      case CssAngle.ANGLEUNIT.turn:
	        angle = this.turn;
	        break;
	      default:
	        angle = this.deg;
	    }

	    if (this._angleUnitUppercase &&
	        this.angleUnit != CssAngle.ANGLEUNIT.authored) {
	      angle = angle.toUpperCase();
	    }
	    return angle;
	  },

	  /**
	   * This method allows comparison of CssAngle objects using ===.
	   */
	  valueOf: function () {
	    return this.deg;
	  },
	};

	/**
	 * Given a color, classify its type as one of the possible angle
	 * units, as known by |CssAngle.angleUnit|.
	 *
	 * @param  {String} value
	 *         The angle, in any form accepted by CSS.
	 * @return {String}
	 *         The angle classification, one of "deg", "rad", "grad", or "turn".
	 */
	function classifyAngle(value) {
	  value = value.toLowerCase();
	  if (value.endsWith("deg")) {
	    return CssAngle.ANGLEUNIT.deg;
	  }

	  if (value.endsWith("grad")) {
	    return CssAngle.ANGLEUNIT.grad;
	  }

	  if (value.endsWith("rad")) {
	    return CssAngle.ANGLEUNIT.rad;
	  }
	  if (value.endsWith("turn")) {
	    return CssAngle.ANGLEUNIT.turn;
	  }

	  return CssAngle.ANGLEUNIT.deg;
	}


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);

	const {getCSSLexer} = __webpack_require__(123);
	const {cssColors} = __webpack_require__(32);

	const COLOR_UNIT_PREF = "devtools.defaultColorUnit";

	const SPECIALVALUES = new Set([
	  "currentcolor",
	  "initial",
	  "inherit",
	  "transparent",
	  "unset"
	]);

	/**
	 * This module is used to convert between various color types.
	 *
	 * Usage:
	 *   let {colorUtils} = require("devtools/shared/css-color");
	 *   let color = new colorUtils.CssColor("red");
	 *
	 *   color.authored === "red"
	 *   color.hasAlpha === false
	 *   color.valid === true
	 *   color.transparent === false // transparent has a special status.
	 *   color.name === "red"        // returns hex when no name available.
	 *   color.hex === "#f00"        // returns shortHex when available else returns
	 *                                  longHex. If alpha channel is present then we
	 *                                  return this.alphaHex if available,
	 *                                  or this.longAlphaHex if not.
	 *   color.alphaHex === "#f00f"  // returns short alpha hex when available
	 *                                  else returns longAlphaHex.
	 *   color.longHex === "#ff0000" // If alpha channel is present then we return
	 *                                  this.longAlphaHex.
	 *   color.longAlphaHex === "#ff0000ff"
	 *   color.rgb === "rgb(255, 0, 0)" // If alpha channel is present
	 *                                  // then we return this.rgba.
	 *   color.rgba === "rgba(255, 0, 0, 1)"
	 *   color.hsl === "hsl(0, 100%, 50%)"
	 *   color.hsla === "hsla(0, 100%, 50%, 1)" // If alpha channel is present
	 *                                             then we return this.rgba.
	 *
	 *   color.toString() === "#f00"; // Outputs the color type determined in the
	 *                                   COLOR_UNIT_PREF constant (above).
	 *   // Color objects can be reused
	 *   color.newColor("green") === "#0f0"; // true
	 *
	 *   Valid values for COLOR_UNIT_PREF are contained in CssColor.COLORUNIT.
	 */

	function CssColor(colorValue) {
	  this.newColor(colorValue);
	}

	module.exports.colorUtils = {
	  CssColor: CssColor,
	  rgbToHsl: rgbToHsl,
	  setAlpha: setAlpha,
	  classifyColor: classifyColor,
	  rgbToColorName: rgbToColorName,
	  colorToRGBA: colorToRGBA,
	  isValidCSSColor: isValidCSSColor,
	};

	/**
	 * Values used in COLOR_UNIT_PREF
	 */
	CssColor.COLORUNIT = {
	  "authored": "authored",
	  "hex": "hex",
	  "name": "name",
	  "rgb": "rgb",
	  "hsl": "hsl"
	};

	CssColor.prototype = {
	  _colorUnit: null,
	  _colorUnitUppercase: false,

	  // The value as-authored.
	  authored: null,
	  // A lower-cased copy of |authored|.
	  lowerCased: null,

	  get colorUnit() {
	    if (this._colorUnit === null) {
	      let defaultUnit = Services.prefs.getCharPref(COLOR_UNIT_PREF);
	      this._colorUnit = CssColor.COLORUNIT[defaultUnit];
	      this._colorUnitUppercase =
	        (this.authored === this.authored.toUpperCase());
	    }
	    return this._colorUnit;
	  },

	  set colorUnit(unit) {
	    this._colorUnit = unit;
	  },

	  /**
	   * If the current color unit pref is "authored", then set the
	   * default color unit from the given color.  Otherwise, leave the
	   * color unit untouched.
	   *
	   * @param {String} color The color to use
	   */
	  setAuthoredUnitFromColor: function (color) {
	    if (Services.prefs.getCharPref(COLOR_UNIT_PREF) ===
	        CssColor.COLORUNIT.authored) {
	      this._colorUnit = classifyColor(color);
	      this._colorUnitUppercase = (color === color.toUpperCase());
	    }
	  },

	  get hasAlpha() {
	    if (!this.valid) {
	      return false;
	    }
	    return this._getRGBATuple().a !== 1;
	  },

	  get valid() {
	    return isValidCSSColor(this.authored);
	  },

	  /**
	   * Return true for all transparent values e.g. rgba(0, 0, 0, 0).
	   */
	  get transparent() {
	    try {
	      let tuple = this._getRGBATuple();
	      return !(tuple.r || tuple.g || tuple.b || tuple.a);
	    } catch (e) {
	      return false;
	    }
	  },

	  get specialValue() {
	    return SPECIALVALUES.has(this.lowerCased) ? this.authored : null;
	  },

	  get name() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    try {
	      let tuple = this._getRGBATuple();

	      if (tuple.a !== 1) {
	        return this.hex;
	      }
	      let {r, g, b} = tuple;
	      return rgbToColorName(r, g, b);
	    } catch (e) {
	      return this.hex;
	    }
	  },

	  get hex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.hasAlpha) {
	      return this.alphaHex;
	    }

	    let hex = this.longHex;
	    if (hex.charAt(1) == hex.charAt(2) &&
	        hex.charAt(3) == hex.charAt(4) &&
	        hex.charAt(5) == hex.charAt(6)) {
	      hex = "#" + hex.charAt(1) + hex.charAt(3) + hex.charAt(5);
	    }
	    return hex;
	  },

	  get alphaHex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let alphaHex = this.longAlphaHex;
	    if (alphaHex.charAt(1) == alphaHex.charAt(2) &&
	        alphaHex.charAt(3) == alphaHex.charAt(4) &&
	        alphaHex.charAt(5) == alphaHex.charAt(6) &&
	        alphaHex.charAt(7) == alphaHex.charAt(8)) {
	      alphaHex = "#" + alphaHex.charAt(1) + alphaHex.charAt(3) +
	        alphaHex.charAt(5) + alphaHex.charAt(7);
	    }
	    return alphaHex;
	  },

	  get longHex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.hasAlpha) {
	      return this.longAlphaHex;
	    }

	    let tuple = this._getRGBATuple();
	    return "#" + ((1 << 24) + (tuple.r << 16) + (tuple.g << 8) +
	                  (tuple.b << 0)).toString(16).substr(-6);
	  },

	  get longAlphaHex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let tuple = this._getRGBATuple();
	    return "#" + ((1 << 24) + (tuple.r << 16) + (tuple.g << 8) +
	                  (tuple.b << 0)).toString(16).substr(-6) +
	                  Math.round(tuple.a * 255).toString(16).padEnd(2, "0");
	  },

	  get rgb() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (!this.hasAlpha) {
	      if (this.lowerCased.startsWith("rgb(")) {
	        // The color is valid and begins with rgb(.
	        return this.authored;
	      }
	      let tuple = this._getRGBATuple();
	      return "rgb(" + tuple.r + ", " + tuple.g + ", " + tuple.b + ")";
	    }
	    return this.rgba;
	  },

	  get rgba() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.lowerCased.startsWith("rgba(")) {
	      // The color is valid and begins with rgba(.
	      return this.authored;
	    }
	    let components = this._getRGBATuple();
	    return "rgba(" + components.r + ", " +
	                     components.g + ", " +
	                     components.b + ", " +
	                     components.a + ")";
	  },

	  get hsl() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.lowerCased.startsWith("hsl(")) {
	      // The color is valid and begins with hsl(.
	      return this.authored;
	    }
	    if (this.hasAlpha) {
	      return this.hsla;
	    }
	    return this._hsl();
	  },

	  get hsla() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.lowerCased.startsWith("hsla(")) {
	      // The color is valid and begins with hsla(.
	      return this.authored;
	    }
	    if (this.hasAlpha) {
	      let a = this._getRGBATuple().a;
	      return this._hsl(a);
	    }
	    return this._hsl(1);
	  },

	  /**
	   * Check whether the current color value is in the special list e.g.
	   * transparent or invalid.
	   *
	   * @return {String|Boolean}
	   *         - If the current color is a special value e.g. "transparent" then
	   *           return the color.
	   *         - If the color is invalid return an empty string.
	   *         - If the color is a regular color e.g. #F06 so we return false
	   *           to indicate that the color is neither invalid or special.
	   */
	  _getInvalidOrSpecialValue: function () {
	    if (this.specialValue) {
	      return this.specialValue;
	    }
	    if (!this.valid) {
	      return "";
	    }
	    return false;
	  },

	  /**
	   * Change color
	   *
	   * @param  {String} color
	   *         Any valid color string
	   */
	  newColor: function (color) {
	    // Store a lower-cased version of the color to help with format
	    // testing.  The original text is kept as well so it can be
	    // returned when needed.
	    this.lowerCased = color.toLowerCase();
	    this.authored = color;
	    return this;
	  },

	  nextColorUnit: function () {
	    // Reorder the formats array to have the current format at the
	    // front so we can cycle through.
	    let formats = ["hex", "hsl", "rgb", "name"];
	    let currentFormat = classifyColor(this.toString());
	    let putOnEnd = formats.splice(0, formats.indexOf(currentFormat));
	    formats = formats.concat(putOnEnd);
	    let currentDisplayedColor = this[formats[0]];

	    for (let format of formats) {
	      if (this[format].toLowerCase() !== currentDisplayedColor.toLowerCase()) {
	        this.colorUnit = CssColor.COLORUNIT[format];
	        break;
	      }
	    }

	    return this.toString();
	  },

	  /**
	   * Return a string representing a color of type defined in COLOR_UNIT_PREF.
	   */
	  toString: function () {
	    let color;

	    switch (this.colorUnit) {
	      case CssColor.COLORUNIT.authored:
	        color = this.authored;
	        break;
	      case CssColor.COLORUNIT.hex:
	        color = this.hex;
	        break;
	      case CssColor.COLORUNIT.hsl:
	        color = this.hsl;
	        break;
	      case CssColor.COLORUNIT.name:
	        color = this.name;
	        break;
	      case CssColor.COLORUNIT.rgb:
	        color = this.rgb;
	        break;
	      default:
	        color = this.rgb;
	    }

	    if (this._colorUnitUppercase &&
	        this.colorUnit != CssColor.COLORUNIT.authored) {
	      color = color.toUpperCase();
	    }

	    return color;
	  },

	  /**
	   * Returns a RGBA 4-Tuple representation of a color or transparent as
	   * appropriate.
	   */
	  _getRGBATuple: function () {
	    let tuple = colorToRGBA(this.authored);

	    tuple.a = parseFloat(tuple.a.toFixed(1));

	    return tuple;
	  },

	  _hsl: function (maybeAlpha) {
	    if (this.lowerCased.startsWith("hsl(") && maybeAlpha === undefined) {
	      // We can use it as-is.
	      return this.authored;
	    }

	    let {r, g, b} = this._getRGBATuple();
	    let [h, s, l] = rgbToHsl([r, g, b]);
	    if (maybeAlpha !== undefined) {
	      return "hsla(" + h + ", " + s + "%, " + l + "%, " + maybeAlpha + ")";
	    }
	    return "hsl(" + h + ", " + s + "%, " + l + "%)";
	  },

	  /**
	   * This method allows comparison of CssColor objects using ===.
	   */
	  valueOf: function () {
	    return this.rgba;
	  },
	};

	/**
	 * Convert rgb value to hsl
	 *
	 * @param {array} rgb
	 *         Array of rgb values
	 * @return {array}
	 *         Array of hsl values.
	 */
	function rgbToHsl([r, g, b]) {
	  r = r / 255;
	  g = g / 255;
	  b = b / 255;

	  let max = Math.max(r, g, b);
	  let min = Math.min(r, g, b);
	  let h;
	  let s;
	  let l = (max + min) / 2;

	  if (max == min) {
	    h = s = 0;
	  } else {
	    let d = max - min;
	    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

	    switch (max) {
	      case r:
	        h = ((g - b) / d) % 6;
	        break;
	      case g:
	        h = (b - r) / d + 2;
	        break;
	      case b:
	        h = (r - g) / d + 4;
	        break;
	    }
	    h *= 60;
	    if (h < 0) {
	      h += 360;
	    }
	  }

	  return [Math.round(h), Math.round(s * 100), Math.round(l * 100)];
	}

	/**
	 * Takes a color value of any type (hex, hsl, hsla, rgb, rgba)
	 * and an alpha value to generate an rgba string with the correct
	 * alpha value.
	 *
	 * @param  {String} colorValue
	 *         Color in the form of hex, hsl, hsla, rgb, rgba.
	 * @param  {Number} alpha
	 *         Alpha value for the color, between 0 and 1.
	 * @return {String}
	 *         Converted color with `alpha` value in rgba form.
	 */
	function setAlpha(colorValue, alpha) {
	  let color = new CssColor(colorValue);

	  // Throw if the color supplied is not valid.
	  if (!color.valid) {
	    throw new Error("Invalid color.");
	  }

	  // If an invalid alpha valid, just set to 1.
	  if (!(alpha >= 0 && alpha <= 1)) {
	    alpha = 1;
	  }

	  let { r, g, b } = color._getRGBATuple();
	  return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
	}

	/**
	 * Given a color, classify its type as one of the possible color
	 * units, as known by |CssColor.colorUnit|.
	 *
	 * @param  {String} value
	 *         The color, in any form accepted by CSS.
	 * @return {String}
	 *         The color classification, one of "rgb", "hsl", "hex", or "name".
	 */
	function classifyColor(value) {
	  value = value.toLowerCase();
	  if (value.startsWith("rgb(") || value.startsWith("rgba(")) {
	    return CssColor.COLORUNIT.rgb;
	  } else if (value.startsWith("hsl(") || value.startsWith("hsla(")) {
	    return CssColor.COLORUNIT.hsl;
	  } else if (/^#[0-9a-f]+$/.exec(value)) {
	    return CssColor.COLORUNIT.hex;
	  }
	  return CssColor.COLORUNIT.name;
	}

	// This holds a map from colors back to color names for use by
	// rgbToColorName.
	var cssRGBMap;

	/**
	 * Given a color, return its name, if it has one.  Throws an exception
	 * if the color does not have a name.
	 *
	 * @param {Number} r, g, b  The color components.
	 * @return {String} the name of the color
	 */
	function rgbToColorName(r, g, b) {
	  if (!cssRGBMap) {
	    cssRGBMap = {};
	    for (let name in cssColors) {
	      let key = JSON.stringify(cssColors[name]);
	      if (!(key in cssRGBMap)) {
	        cssRGBMap[key] = name;
	      }
	    }
	  }
	  let value = cssRGBMap[JSON.stringify([r, g, b, 1])];
	  if (!value) {
	    throw new Error("no such color");
	  }
	  return value;
	}

	// Translated from nsColor.cpp.
	function _hslValue(m1, m2, h) {
	  if (h < 0.0) {
	    h += 1.0;
	  }
	  if (h > 1.0) {
	    h -= 1.0;
	  }
	  if (h < 1.0 / 6.0) {
	    return m1 + (m2 - m1) * h * 6.0;
	  }
	  if (h < 1.0 / 2.0) {
	    return m2;
	  }
	  if (h < 2.0 / 3.0) {
	    return m1 + (m2 - m1) * (2.0 / 3.0 - h) * 6.0;
	  }
	  return m1;
	}

	// Translated from nsColor.cpp.  All three values are expected to be
	// in the range 0-1.
	function hslToRGB([h, s, l]) {
	  let r, g, b;
	  let m1, m2;
	  if (l <= 0.5) {
	    m2 = l * (s + 1);
	  } else {
	    m2 = l + s - l * s;
	  }
	  m1 = l * 2 - m2;
	  r = Math.floor(255 * _hslValue(m1, m2, h + 1.0 / 3.0));
	  g = Math.floor(255 * _hslValue(m1, m2, h));
	  b = Math.floor(255 * _hslValue(m1, m2, h - 1.0 / 3.0));
	  return [r, g, b];
	}

	/**
	 * A helper function to convert a hex string like "F0C" or "F0C8" to a color.
	 *
	 * @param {String} name the color string
	 * @return {Object} an object of the form {r, g, b, a}; or null if the
	 *         name was not a valid color
	 */
	function hexToRGBA(name) {
	  let r, g, b, a = 1;

	  if (name.length === 3) {
	    // short hex string (e.g. F0C)
	    r = parseInt(name.charAt(0) + name.charAt(0), 16);
	    g = parseInt(name.charAt(1) + name.charAt(1), 16);
	    b = parseInt(name.charAt(2) + name.charAt(2), 16);
	  } else if (name.length === 4) {
	    // short alpha hex string (e.g. F0CA)
	    r = parseInt(name.charAt(0) + name.charAt(0), 16);
	    g = parseInt(name.charAt(1) + name.charAt(1), 16);
	    b = parseInt(name.charAt(2) + name.charAt(2), 16);
	    a = parseInt(name.charAt(3) + name.charAt(3), 16) / 255;
	  } else if (name.length === 6) {
	    // hex string (e.g. FD01CD)
	    r = parseInt(name.charAt(0) + name.charAt(1), 16);
	    g = parseInt(name.charAt(2) + name.charAt(3), 16);
	    b = parseInt(name.charAt(4) + name.charAt(5), 16);
	  } else if (name.length === 8) {
	    // alpha hex string (e.g. FD01CDAB)
	    r = parseInt(name.charAt(0) + name.charAt(1), 16);
	    g = parseInt(name.charAt(2) + name.charAt(3), 16);
	    b = parseInt(name.charAt(4) + name.charAt(5), 16);
	    a = parseInt(name.charAt(6) + name.charAt(7), 16) / 255;
	  } else {
	    return null;
	  }
	  a = Math.round(a * 10) / 10;
	  return {r, g, b, a};
	}

	/**
	 * A helper function to clamp a value.
	 *
	 * @param {Number} value The value to clamp
	 * @param {Number} min The minimum value
	 * @param {Number} max The maximum value
	 * @return {Number} A value between min and max
	 */
	function clamp(value, min, max) {
	  if (value < min) {
	    value = min;
	  }
	  if (value > max) {
	    value = max;
	  }
	  return value;
	}

	/**
	 * A helper function to get a token from a lexer, skipping comments
	 * and whitespace.
	 *
	 * @param {CSSLexer} lexer The lexer
	 * @return {CSSToken} The next non-whitespace, non-comment token; or
	 * null at EOF.
	 */
	function getToken(lexer) {
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token || (token.tokenType !== "comment" &&
	                   token.tokenType !== "whitespace")) {
	      return token;
	    }
	  }
	}

	/**
	 * A helper function to examine a token and ensure it is a comma.
	 * Then fetch and return the next token.  Returns null if the
	 * token was not a comma, or at EOF.
	 *
	 * @param {CSSLexer} lexer The lexer
	 * @param {CSSToken} token A token to be examined
	 * @return {CSSToken} The next non-whitespace, non-comment token; or
	 * null if token was not a comma, or at EOF.
	 */
	function requireComma(lexer, token) {
	  if (!token || token.tokenType !== "symbol" || token.text !== ",") {
	    return null;
	  }
	  return getToken(lexer);
	}

	/**
	 * A helper function to parse the first three arguments to hsl()
	 * or hsla().
	 *
	 * @param {CSSLexer} lexer The lexer
	 * @return {Array} An array of the form [r,g,b]; or null on error.
	 */
	function parseHsl(lexer) {
	  let vals = [];

	  let token = getToken(lexer);
	  if (!token || token.tokenType !== "number") {
	    return null;
	  }

	  let val = token.number / 360.0;
	  vals.push(val - Math.floor(val));

	  for (let i = 0; i < 2; ++i) {
	    token = requireComma(lexer, getToken(lexer));
	    if (!token || token.tokenType !== "percentage") {
	      return null;
	    }
	    vals.push(clamp(token.number, 0, 1));
	  }

	  return hslToRGB(vals);
	}

	/**
	 * A helper function to parse the first three arguments to rgb()
	 * or rgba().
	 *
	 * @param {CSSLexer} lexer The lexer
	 * @return {Array} An array of the form [r,g,b]; or null on error.
	 */
	function parseRgb(lexer) {
	  let isPercentage = false;
	  let vals = [];
	  for (let i = 0; i < 3; ++i) {
	    let token = getToken(lexer);
	    if (i > 0) {
	      token = requireComma(lexer, token);
	    }
	    if (!token) {
	      return null;
	    }

	    /* Either all parameters are integers, or all are percentages, so
	       check the first one to see.  */
	    if (i === 0 && token.tokenType === "percentage") {
	      isPercentage = true;
	    }

	    if (isPercentage) {
	      if (token.tokenType !== "percentage") {
	        return null;
	      }
	      vals.push(Math.round(255 * clamp(token.number, 0, 1)));
	    } else {
	      if (token.tokenType !== "number" || !token.isInteger) {
	        return null;
	      }
	      vals.push(clamp(token.number, 0, 255));
	    }
	  }
	  return vals;
	}

	/**
	 * Convert a string representing a color to an object holding the
	 * color's components.  Any valid CSS color form can be passed in.
	 *
	 * @param {String} name the color
	 * @return {Object} an object of the form {r, g, b, a}; or null if the
	 *         name was not a valid color
	 */
	function colorToRGBA(name) {
	  name = name.trim().toLowerCase();

	  if (name in cssColors) {
	    let result = cssColors[name];
	    return {r: result[0], g: result[1], b: result[2], a: result[3]};
	  } else if (name === "transparent") {
	    return {r: 0, g: 0, b: 0, a: 0};
	  } else if (name === "currentcolor") {
	    return {r: 0, g: 0, b: 0, a: 1};
	  }

	  let lexer = getCSSLexer(name);

	  let func = getToken(lexer);
	  if (!func) {
	    return null;
	  }

	  if (func.tokenType === "id" || func.tokenType === "hash") {
	    if (getToken(lexer) !== null) {
	      return null;
	    }
	    return hexToRGBA(func.text);
	  }

	  const expectedFunctions = ["rgba", "rgb", "hsla", "hsl"];
	  if (!func || func.tokenType !== "function" ||
	      !expectedFunctions.includes(func.text)) {
	    return null;
	  }

	  let hsl = func.text === "hsl" || func.text === "hsla";
	  let alpha = func.text === "rgba" || func.text === "hsla";

	  let vals = hsl ? parseHsl(lexer) : parseRgb(lexer);
	  if (!vals) {
	    return null;
	  }

	  if (alpha) {
	    let token = requireComma(lexer, getToken(lexer));
	    if (!token || token.tokenType !== "number") {
	      return null;
	    }
	    vals.push(clamp(token.number, 0, 1));
	  } else {
	    vals.push(1);
	  }

	  let parenToken = getToken(lexer);
	  if (!parenToken || parenToken.tokenType !== "symbol" ||
	      parenToken.text !== ")") {
	    return null;
	  }
	  if (getToken(lexer) !== null) {
	    return null;
	  }

	  return {r: vals[0], g: vals[1], b: vals[2], a: vals[3]};
	}

	/**
	 * Check whether a string names a valid CSS color.
	 *
	 * @param {String} name The string to check
	 * @return {Boolean} True if the string is a CSS color name.
	 */
	function isValidCSSColor(name) {
	  return colorToRGBA(name) !== null;
	}


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);
	const EventEmitter = __webpack_require__(6);

	exports.PREF_ORIG_SOURCES = "devtools.styleeditor.source-maps-enabled";

	/**
	 * A PreferenceObserver observes a pref branch for pref changes.
	 * It emits an event for each preference change.
	 */
	function PrefObserver(branchName) {
	  this.branchName = branchName;
	  this.branch = Services.prefs.getBranch(branchName);
	  this.branch.addObserver("", this, false);

	  EventEmitter.decorate(this);
	}

	exports.PrefObserver = PrefObserver;

	PrefObserver.prototype = {
	  observe: function (subject, topic, data) {
	    if (topic == "nsPref:changed") {
	      this.emit(this.branchName + data);
	    }
	  },

	  destroy: function () {
	    if (this.branch) {
	      this.branch.removeObserver("", this);
	    }
	  }
	};


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {parseDeclarations} = __webpack_require__(132);
	const promise = __webpack_require__(4);
	const {getCSSLexer} = __webpack_require__(123);
	const {KeyCodes} = __webpack_require__(16);

	const HTML_NS = "http://www.w3.org/1999/xhtml";

	/**
	 * Create a child element with a set of attributes.
	 *
	 * @param {Element} parent
	 *        The parent node.
	 * @param {string} tagName
	 *        The tag name.
	 * @param {object} attributes
	 *        A set of attributes to set on the node.
	 */
	function createChild(parent, tagName, attributes = {}) {
	  let elt = parent.ownerDocument.createElementNS(HTML_NS, tagName);
	  for (let attr in attributes) {
	    if (attributes.hasOwnProperty(attr)) {
	      if (attr === "textContent") {
	        elt.textContent = attributes[attr];
	      } else if (attr === "child") {
	        elt.appendChild(attributes[attr]);
	      } else {
	        elt.setAttribute(attr, attributes[attr]);
	      }
	    }
	  }
	  parent.appendChild(elt);
	  return elt;
	}

	exports.createChild = createChild;

	/**
	 * Append a text node to an element.
	 *
	 * @param {Element} parent
	 *        The parent node.
	 * @param {string} text
	 *        The text content for the text node.
	 */
	function appendText(parent, text) {
	  parent.appendChild(parent.ownerDocument.createTextNode(text));
	}

	exports.appendText = appendText;

	/**
	 * Called when a character is typed in a value editor.  This decides
	 * whether to advance or not, first by checking to see if ";" was
	 * typed, and then by lexing the input and seeing whether the ";"
	 * would be a terminator at this point.
	 *
	 * @param {number} keyCode
	 *        Key code to be checked.
	 * @param {string} aValue
	 *        Current text editor value.
	 * @param {number} insertionPoint
	 *        The index of the insertion point.
	 * @return {Boolean} True if the focus should advance; false if
	 *        the character should be inserted.
	 */
	function advanceValidate(keyCode, value, insertionPoint) {
	  // Only ";" has special handling here.
	  if (keyCode !== KeyCodes.DOM_VK_SEMICOLON) {
	    return false;
	  }

	  // Insert the character provisionally and see what happens.  If we
	  // end up with a ";" symbol token, then the semicolon terminates the
	  // value.  Otherwise it's been inserted in some spot where it has a
	  // valid meaning, like a comment or string.
	  value = value.slice(0, insertionPoint) + ";" + value.slice(insertionPoint);
	  let lexer = getCSSLexer(value);
	  while (true) {
	    let token = lexer.nextToken();
	    if (token.endOffset > insertionPoint) {
	      if (token.tokenType === "symbol" && token.text === ";") {
	        // The ";" is a terminator.
	        return true;
	      }
	      // The ";" is not a terminator in this context.
	      break;
	    }
	  }
	  return false;
	}

	exports.advanceValidate = advanceValidate;

	/**
	 * Create a throttling function wrapper to regulate its frequency.
	 *
	 * @param {Function} func
	 *         The function to throttle
	 * @param {number} wait
	 *         The throttling period
	 * @param {Object} scope
	 *         The scope to use for func
	 * @return {Function} The throttled function
	 */
	function throttle(func, wait, scope) {
	  let timer = null;

	  return function () {
	    if (timer) {
	      clearTimeout(timer);
	    }

	    let args = arguments;
	    timer = setTimeout(function () {
	      timer = null;
	      func.apply(scope, args);
	    }, wait);
	  };
	}

	exports.throttle = throttle;

	/**
	 * Event handler that causes a blur on the target if the input has
	 * multiple CSS properties as the value.
	 */
	function blurOnMultipleProperties(cssProperties) {
	  return (e) => {
	    setTimeout(() => {
	      let props = parseDeclarations(cssProperties.isKnown, e.target.value);
	      if (props.length > 1) {
	        e.target.blur();
	      }
	    }, 0);
	  };
	}

	exports.blurOnMultipleProperties = blurOnMultipleProperties;

	/**
	 * Log the provided error to the console and return a rejected Promise for
	 * this error.
	 *
	 * @param {Error} error
	 *         The error to log
	 * @return {Promise} A rejected promise
	 */
	function promiseWarn(error) {
	  console.error(error);
	  return promise.reject(error);
	}

	exports.promiseWarn = promiseWarn;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// This file holds various CSS parsing and rewriting utilities.
	// Some entry points of note are:
	// parseDeclarations - parse a CSS rule into declarations
	// RuleRewriter - rewrite CSS rule text
	// parsePseudoClassesAndAttributes - parse selector and extract
	//     pseudo-classes
	// parseSingleValue - parse a single CSS property value

	"use strict";

	const promise = __webpack_require__(4);
	const {getCSSLexer} = __webpack_require__(123);
	const {Task} = __webpack_require__(17);

	const SELECTOR_ATTRIBUTE = exports.SELECTOR_ATTRIBUTE = 1;
	const SELECTOR_ELEMENT = exports.SELECTOR_ELEMENT = 2;
	const SELECTOR_PSEUDO_CLASS = exports.SELECTOR_PSEUDO_CLASS = 3;

	// Used to test whether a newline appears anywhere in some text.
	const NEWLINE_RX = /[\r\n]/;
	// Used to test whether a bit of text starts an empty comment, either
	// an "ordinary" /* ... */ comment, or a "heuristic bypass" comment
	// like /*! ... */.
	const EMPTY_COMMENT_START_RX = /^\/\*!?[ \r\n\t\f]*$/;
	// Used to test whether a bit of text ends an empty comment.
	const EMPTY_COMMENT_END_RX = /^[ \r\n\t\f]*\*\//;
	// Used to test whether a string starts with a blank line.
	const BLANK_LINE_RX = /^[ \t]*(?:\r\n|\n|\r|\f|$)/;

	// When commenting out a declaration, we put this character into the
	// comment opener so that future parses of the commented text know to
	// bypass the property name validity heuristic.
	const COMMENT_PARSING_HEURISTIC_BYPASS_CHAR = "!";

	/**
	 * A generator function that lexes a CSS source string, yielding the
	 * CSS tokens.  Comment tokens are dropped.
	 *
	 * @param {String} CSS source string
	 * @yield {CSSToken} The next CSSToken that is lexed
	 * @see CSSToken for details about the returned tokens
	 */
	function* cssTokenizer(string) {
	  let lexer = getCSSLexer(string);
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token) {
	      break;
	    }
	    // None of the existing consumers want comments.
	    if (token.tokenType !== "comment") {
	      yield token;
	    }
	  }
	}

	/**
	 * Pass |string| to the CSS lexer and return an array of all the
	 * returned tokens.  Comment tokens are not included.  In addition to
	 * the usual information, each token will have starting and ending
	 * line and column information attached.  Specifically, each token
	 * has an additional "loc" attribute.  This attribute is an object
	 * of the form {line: L, column: C}.  Lines and columns are both zero
	 * based.
	 *
	 * It's best not to add new uses of this function.  In general it is
	 * simpler and better to use the CSSToken offsets, rather than line
	 * and column.  Also, this function lexes the entire input string at
	 * once, rather than lazily yielding a token stream.  Use
	 * |cssTokenizer| or |getCSSLexer| instead.
	 *
	 * @param{String} string The input string.
	 * @return {Array} An array of tokens (@see CSSToken) that have
	 *        line and column information.
	 */
	function cssTokenizerWithLineColumn(string) {
	  let lexer = getCSSLexer(string);
	  let result = [];
	  let prevToken = undefined;
	  while (true) {
	    let token = lexer.nextToken();
	    let lineNumber = lexer.lineNumber;
	    let columnNumber = lexer.columnNumber;

	    if (prevToken) {
	      prevToken.loc.end = {
	        line: lineNumber,
	        column: columnNumber
	      };
	    }

	    if (!token) {
	      break;
	    }

	    if (token.tokenType === "comment") {
	      // We've already dealt with the previous token's location.
	      prevToken = undefined;
	    } else {
	      let startLoc = {
	        line: lineNumber,
	        column: columnNumber
	      };
	      token.loc = {start: startLoc};

	      result.push(token);
	      prevToken = token;
	    }
	  }

	  return result;
	}

	/**
	 * Escape a comment body.  Find the comment start and end strings in a
	 * string and inserts backslashes so that the resulting text can
	 * itself be put inside a comment.
	 *
	 * @param {String} inputString
	 *                 input string
	 * @return {String} the escaped result
	 */
	function escapeCSSComment(inputString) {
	  let result = inputString.replace(/\/(\\*)\*/g, "/\\$1*");
	  return result.replace(/\*(\\*)\//g, "*\\$1/");
	}

	/**
	 * Un-escape a comment body.  This undoes any comment escaping that
	 * was done by escapeCSSComment.  That is, given input like "/\*
	 * comment *\/", it will strip the backslashes.
	 *
	 * @param {String} inputString
	 *                 input string
	 * @return {String} the un-escaped result
	 */
	function unescapeCSSComment(inputString) {
	  let result = inputString.replace(/\/\\(\\*)\*/g, "/$1*");
	  return result.replace(/\*\\(\\*)\//g, "*$1/");
	}

	/**
	 * A helper function for @see parseDeclarations that handles parsing
	 * of comment text.  This wraps a recursive call to parseDeclarations
	 * with the processing needed to ensure that offsets in the result
	 * refer back to the original, unescaped, input string.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        A function to check if the CSS property is known. This is either an
	 *        internal server function or from the CssPropertiesFront.
	 * @param {String} commentText The text of the comment, without the
	 *                             delimiters.
	 * @param {Number} startOffset The offset of the comment opener
	 *                             in the original text.
	 * @param {Number} endOffset The offset of the comment closer
	 *                           in the original text.
	 * @return {array} Array of declarations of the same form as returned
	 *                 by parseDeclarations.
	 */
	function parseCommentDeclarations(isCssPropertyKnown, commentText, startOffset,
	                                  endOffset) {
	  let commentOverride = false;
	  if (commentText === "") {
	    return [];
	  } else if (commentText[0] === COMMENT_PARSING_HEURISTIC_BYPASS_CHAR) {
	    // This is the special sign that the comment was written by
	    // rewriteDeclarations and so we should bypass the usual
	    // heuristic.
	    commentOverride = true;
	    commentText = commentText.substring(1);
	  }

	  let rewrittenText = unescapeCSSComment(commentText);

	  // We might have rewritten an embedded comment.  For example
	  // /\* ... *\/ would turn into /* ... */.
	  // This rewriting is necessary for proper lexing, but it means
	  // that the offsets we get back can be off.  So now we compute
	  // a map so that we can rewrite offsets later.  The map is the same
	  // length as |rewrittenText| and tells us how to map an index
	  // into |rewrittenText| to an index into |commentText|.
	  //
	  // First, we find the location of each comment starter or closer in
	  // |rewrittenText|.  At these spots we put a 1 into |rewrites|.
	  // Then we walk the array again, using the elements to compute a
	  // delta, which we use to make the final mapping.
	  //
	  // Note we allocate one extra entry because we can see an ending
	  // offset that is equal to the length.
	  let rewrites = new Array(rewrittenText.length + 1).fill(0);

	  let commentRe = /\/\\*\*|\*\\*\//g;
	  while (true) {
	    let matchData = commentRe.exec(rewrittenText);
	    if (!matchData) {
	      break;
	    }
	    rewrites[matchData.index] = 1;
	  }

	  let delta = 0;
	  for (let i = 0; i <= rewrittenText.length; ++i) {
	    delta += rewrites[i];
	    // |startOffset| to add the offset from the comment starter, |+2|
	    // for the length of the "/*", then |i| and |delta| as described
	    // above.
	    rewrites[i] = startOffset + 2 + i + delta;
	    if (commentOverride) {
	      ++rewrites[i];
	    }
	  }

	  // Note that we pass "false" for parseComments here.  It doesn't
	  // seem worthwhile to support declarations in comments-in-comments
	  // here, as there's no way to generate those using the tools, and
	  // users would be crazy to write such things.
	  let newDecls = parseDeclarationsInternal(isCssPropertyKnown, rewrittenText,
	                                           false, true, commentOverride);
	  for (let decl of newDecls) {
	    decl.offsets[0] = rewrites[decl.offsets[0]];
	    decl.offsets[1] = rewrites[decl.offsets[1]];
	    decl.colonOffsets[0] = rewrites[decl.colonOffsets[0]];
	    decl.colonOffsets[1] = rewrites[decl.colonOffsets[1]];
	    decl.commentOffsets = [startOffset, endOffset];
	  }
	  return newDecls;
	}

	/**
	 * A helper function for parseDeclarationsInternal that creates a new
	 * empty declaration.
	 *
	 * @return {object} an empty declaration of the form returned by
	 *                  parseDeclarations
	 */
	function getEmptyDeclaration() {
	  return {name: "", value: "", priority: "",
	          terminator: "",
	          offsets: [undefined, undefined],
	          colonOffsets: false};
	}

	/**
	 * A helper function that does all the parsing work for
	 * parseDeclarations.  This is separate because it has some arguments
	 * that don't make sense in isolation.
	 *
	 * The return value and arguments are like parseDeclarations, with
	 * these additional arguments.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        Function to check if the CSS property is known.
	 * @param {Boolean} inComment
	 *        If true, assume that this call is parsing some text
	 *        which came from a comment in another declaration.
	 *        In this case some heuristics are used to avoid parsing
	 *        text which isn't obviously a series of declarations.
	 * @param {Boolean} commentOverride
	 *        This only makes sense when inComment=true.
	 *        When true, assume that the comment was generated by
	 *        rewriteDeclarations, and skip the usual name-checking
	 *        heuristic.
	 */
	function parseDeclarationsInternal(isCssPropertyKnown, inputString,
	                                   parseComments, inComment, commentOverride) {
	  if (inputString === null || inputString === undefined) {
	    throw new Error("empty input string");
	  }

	  let lexer = getCSSLexer(inputString);

	  let declarations = [getEmptyDeclaration()];
	  let lastProp = declarations[0];

	  let current = "", hasBang = false;
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token) {
	      break;
	    }

	    // Ignore HTML comment tokens (but parse anything they might
	    // happen to surround).
	    if (token.tokenType === "htmlcomment") {
	      continue;
	    }

	    // Update the start and end offsets of the declaration, but only
	    // when we see a significant token.
	    if (token.tokenType !== "whitespace" && token.tokenType !== "comment") {
	      if (lastProp.offsets[0] === undefined) {
	        lastProp.offsets[0] = token.startOffset;
	      }
	      lastProp.offsets[1] = token.endOffset;
	    } else if (lastProp.name && !current && !hasBang &&
	               !lastProp.priority && lastProp.colonOffsets[1]) {
	      // Whitespace appearing after the ":" is attributed to it.
	      lastProp.colonOffsets[1] = token.endOffset;
	    }

	    if (token.tokenType === "symbol" && token.text === ":") {
	      if (!lastProp.name) {
	        // Set the current declaration name if there's no name yet
	        lastProp.name = current.trim();
	        lastProp.colonOffsets = [token.startOffset, token.endOffset];
	        current = "";
	        hasBang = false;

	        // When parsing a comment body, if the left-hand-side is not a
	        // valid property name, then drop it and stop parsing.
	        if (inComment && !commentOverride &&
	            !isCssPropertyKnown(lastProp.name)) {
	          lastProp.name = null;
	          break;
	        }
	      } else {
	        // Otherwise, just append ':' to the current value (declaration value
	        // with colons)
	        current += ":";
	      }
	    } else if (token.tokenType === "symbol" && token.text === ";") {
	      lastProp.terminator = "";
	      // When parsing a comment, if the name hasn't been set, then we
	      // have probably just seen an ordinary semicolon used in text,
	      // so drop this and stop parsing.
	      if (inComment && !lastProp.name) {
	        current = "";
	        break;
	      }
	      lastProp.value = current.trim();
	      current = "";
	      hasBang = false;
	      declarations.push(getEmptyDeclaration());
	      lastProp = declarations[declarations.length - 1];
	    } else if (token.tokenType === "ident") {
	      if (token.text === "important" && hasBang) {
	        lastProp.priority = "important";
	        hasBang = false;
	      } else {
	        if (hasBang) {
	          current += "!";
	        }
	        // Re-escape the token to avoid dequoting problems.
	        // See bug 1287620.
	        current += CSS.escape(token.text);
	      }
	    } else if (token.tokenType === "symbol" && token.text === "!") {
	      hasBang = true;
	    } else if (token.tokenType === "whitespace") {
	      if (current !== "") {
	        current += " ";
	      }
	    } else if (token.tokenType === "comment") {
	      if (parseComments && !lastProp.name && !lastProp.value) {
	        let commentText = inputString.substring(token.startOffset + 2,
	                                                token.endOffset - 2);
	        let newDecls = parseCommentDeclarations(isCssPropertyKnown, commentText,
	                                                token.startOffset,
	                                                token.endOffset);

	        // Insert the new declarations just before the final element.
	        let lastDecl = declarations.pop();
	        declarations = [...declarations, ...newDecls, lastDecl];
	      } else {
	        current += " ";
	      }
	    } else {
	      current += inputString.substring(token.startOffset, token.endOffset);
	    }
	  }

	  // Handle whatever trailing properties or values might still be there
	  if (current) {
	    if (!lastProp.name) {
	      // Ignore this case in comments.
	      if (!inComment) {
	        // Trailing property found, e.g. p1:v1;p2:v2;p3
	        lastProp.name = current.trim();
	      }
	    } else {
	      // Trailing value found, i.e. value without an ending ;
	      lastProp.value = current.trim();
	      let terminator = lexer.performEOFFixup("", true);
	      lastProp.terminator = terminator + ";";
	      // If the input was unterminated, attribute the remainder to
	      // this property.  This avoids some bad behavior when rewriting
	      // an unterminated comment.
	      if (terminator) {
	        lastProp.offsets[1] = inputString.length;
	      }
	    }
	  }

	  // Remove declarations that have neither a name nor a value
	  declarations = declarations.filter(prop => prop.name || prop.value);

	  return declarations;
	}

	/**
	 * Returns an array of CSS declarations given a string.
	 * For example, parseDeclarations(isCssPropertyKnown, "width: 1px; height: 1px")
	 * would return:
	 * [{name:"width", value: "1px"}, {name: "height", "value": "1px"}]
	 *
	 * The input string is assumed to only contain declarations so { and }
	 * characters will be treated as part of either the property or value,
	 * depending where it's found.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        A function to check if the CSS property is known. This is either an
	 *        internal server function or from the CssPropertiesFront.
	 *        that are supported by the server.
	 * @param {String} inputString
	 *        An input string of CSS
	 * @param {Boolean} parseComments
	 *        If true, try to parse the contents of comments as well.
	 *        A comment will only be parsed if it occurs outside of
	 *        the body of some other declaration.
	 * @return {Array} an array of objects with the following signature:
	 *         [{"name": string, "value": string, "priority": string,
	 *           "terminator": string,
	 *           "offsets": [start, end], "colonOffsets": [start, end]},
	 *          ...]
	 *         Here, "offsets" holds the offsets of the start and end
	 *         of the declaration text, in a form suitable for use with
	 *         String.substring.
	 *         "terminator" is a string to use to terminate the declaration,
	 *         usually "" to mean no additional termination is needed.
	 *         "colonOffsets" holds the start and end locations of the
	 *         ":" that separates the property name from the value.
	 *         If the declaration appears in a comment, then there will
	 *         be an additional {"commentOffsets": [start, end] property
	 *         on the object, which will hold the offsets of the start
	 *         and end of the enclosing comment.
	 */
	function parseDeclarations(isCssPropertyKnown, inputString,
	                           parseComments = false) {
	  return parseDeclarationsInternal(isCssPropertyKnown, inputString,
	                                   parseComments, false, false);
	}

	/**
	 * Return an object that can be used to rewrite declarations in some
	 * source text.  The source text and parsing are handled in the same
	 * way as @see parseDeclarations, with |parseComments| being true.
	 * Rewriting is done by calling one of the modification functions like
	 * setPropertyEnabled.  The returned object has the same interface
	 * as @see RuleModificationList.
	 *
	 * An example showing how to disable the 3rd property in a rule:
	 *
	 *    let rewriter = new RuleRewriter(isCssPropertyKnown, ruleActor,
	 *                                    ruleActor.authoredText);
	 *    rewriter.setPropertyEnabled(3, "color", false);
	 *    rewriter.apply().then(() => { ... the change is made ... });
	 *
	 * The exported rewriting methods are |renameProperty|, |setPropertyEnabled|,
	 * |createProperty|, |setProperty|, and |removeProperty|.  The |apply|
	 * method can be used to send the edited text to the StyleRuleActor;
	 * |getDefaultIndentation| is useful for the methods requiring a
	 * default indentation value; and |getResult| is useful for testing.
	 *
	 * Additionally, editing will set the |changedDeclarations| property
	 * on this object.  This property has the same form as the |changed|
	 * property of the object returned by |getResult|.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        A function to check if the CSS property is known. This is either an
	 *        internal server function or from the CssPropertiesFront.
	 *        that are supported by the server. Note that if Bug 1222047
	 *        is completed then isCssPropertyKnown will not need to be passed in.
	 *        The CssProperty front will be able to obtained directly from the
	 *        RuleRewriter.
	 * @param {StyleRuleFront} rule The style rule to use.  Note that this
	 *        is only needed by the |apply| and |getDefaultIndentation| methods;
	 *        and in particular for testing it can be |null|.
	 * @param {String} inputString The CSS source text to parse and modify.
	 * @return {Object} an object that can be used to rewrite the input text.
	 */
	function RuleRewriter(isCssPropertyKnown, rule, inputString) {
	  this.rule = rule;
	  this.inputString = inputString;
	  // Whether there are any newlines in the input text.
	  this.hasNewLine = /[\r\n]/.test(this.inputString);
	  // Keep track of which any declarations we had to rewrite while
	  // performing the requested action.
	  this.changedDeclarations = {};
	  // The declarations.
	  this.declarations = parseDeclarations(isCssPropertyKnown, this.inputString,
	                                        true);

	  this.decl = null;
	  this.result = null;
	  // If not null, a promise that must be wait upon before |apply| can
	  // do its work.
	  this.editPromise = null;

	  // If the |defaultIndentation| property is set, then it is used;
	  // otherwise the RuleRewriter will try to compute the default
	  // indentation based on the style sheet's text.  This override
	  // facility is for testing.
	  this.defaultIndentation = null;
	}

	RuleRewriter.prototype = {
	  /**
	   * An internal function to complete initialization and set some
	   * properties for further processing.
	   *
	   * @param {Number} index The index of the property to modify
	   */
	  completeInitialization: function (index) {
	    if (index < 0) {
	      throw new Error("Invalid index " + index + ". Expected positive integer");
	    }
	    // |decl| is the declaration to be rewritten, or null if there is no
	    // declaration corresponding to |index|.
	    // |result| is used to accumulate the result text.
	    if (index < this.declarations.length) {
	      this.decl = this.declarations[index];
	      this.result = this.inputString.substring(0, this.decl.offsets[0]);
	    } else {
	      this.decl = null;
	      this.result = this.inputString;
	    }
	  },

	  /**
	   * A helper function to compute the indentation of some text.  This
	   * examines the rule's existing text to guess the indentation to use;
	   * unlike |getDefaultIndentation|, which examines the entire style
	   * sheet.
	   *
	   * @param {String} string the input text
	   * @param {Number} offset the offset at which to compute the indentation
	   * @return {String} the indentation at the indicated position
	   */
	  getIndentation: function (string, offset) {
	    let originalOffset = offset;
	    for (--offset; offset >= 0; --offset) {
	      let c = string[offset];
	      if (c === "\r" || c === "\n" || c === "\f") {
	        return string.substring(offset + 1, originalOffset);
	      }
	      if (c !== " " && c !== "\t") {
	        // Found some non-whitespace character before we found a newline
	        // -- let's reset the starting point and keep going, as we saw
	        // something on the line before the declaration.
	        originalOffset = offset;
	      }
	    }
	    // Ran off the end.
	    return "";
	  },

	  /**
	   * Modify a property value to ensure it is "lexically safe" for
	   * insertion into a style sheet.  This function doesn't attempt to
	   * ensure that the resulting text is a valid value for the given
	   * property; but rather just that inserting the text into the style
	   * sheet will not cause unwanted changes to other rules or
	   * declarations.
	   *
	   * @param {String} text The input text.  This should include the trailing ";".
	   * @return {Array} An array of the form [anySanitized, text], where
	   *                 |anySanitized| is a boolean that indicates
	   *                  whether anything substantive has changed; and
	   *                  where |text| is the text that has been rewritten
	   *                  to be "lexically safe".
	   */
	  sanitizePropertyValue: function (text) {
	    let lexer = getCSSLexer(text);

	    let result = "";
	    let previousOffset = 0;
	    let braceDepth = 0;
	    let anySanitized = false;
	    while (true) {
	      let token = lexer.nextToken();
	      if (!token) {
	        break;
	      }

	      if (token.tokenType === "symbol") {
	        switch (token.text) {
	          case ";":
	            // We simply drop the ";" here.  This lets us cope with
	            // declarations that don't have a ";" and also other
	            // termination.  The caller handles adding the ";" again.
	            result += text.substring(previousOffset, token.startOffset);
	            previousOffset = token.endOffset;
	            break;

	          case "{":
	            ++braceDepth;
	            break;

	          case "}":
	            --braceDepth;
	            if (braceDepth < 0) {
	              // Found an unmatched close bracket.
	              braceDepth = 0;
	              // Copy out text from |previousOffset|.
	              result += text.substring(previousOffset, token.startOffset);
	              // Quote the offending symbol.
	              result += "\\" + token.text;
	              previousOffset = token.endOffset;
	              anySanitized = true;
	            }
	            break;
	        }
	      }
	    }

	    // Copy out any remaining text, then any needed terminators.
	    result += text.substring(previousOffset, text.length);
	    let eofFixup = lexer.performEOFFixup("", true);
	    if (eofFixup) {
	      anySanitized = true;
	      result += eofFixup;
	    }
	    return [anySanitized, result];
	  },

	  /**
	   * Start at |index| and skip whitespace
	   * backward in |string|.  Return the index of the first
	   * non-whitespace character, or -1 if the entire string was
	   * whitespace.
	   * @param {String} string the input string
	   * @param {Number} index the index at which to start
	   * @return {Number} index of the first non-whitespace character, or -1
	   */
	  skipWhitespaceBackward: function (string, index) {
	    for (--index;
	         index >= 0 && (string[index] === " " || string[index] === "\t");
	         --index) {
	      // Nothing.
	    }
	    return index;
	  },

	  /**
	   * Terminate a given declaration, if needed.
	   *
	   * @param {Number} index The index of the rule to possibly
	   *                       terminate.  It might be invalid, so this
	   *                       function must check for that.
	   */
	  maybeTerminateDecl: function (index) {
	    if (index < 0 || index >= this.declarations.length
	        // No need to rewrite declarations in comments.
	        || ("commentOffsets" in this.declarations[index])) {
	      return;
	    }

	    let termDecl = this.declarations[index];
	    let endIndex = termDecl.offsets[1];
	    // Due to an oddity of the lexer, we might have gotten a bit of
	    // extra whitespace in a trailing bad_url token -- so be sure to
	    // skip that as well.
	    endIndex = this.skipWhitespaceBackward(this.result, endIndex) + 1;

	    let trailingText = this.result.substring(endIndex);
	    if (termDecl.terminator) {
	      // Insert the terminator just at the end of the declaration,
	      // before any trailing whitespace.
	      this.result = this.result.substring(0, endIndex) + termDecl.terminator +
	        trailingText;
	      // In a couple of cases, we may have had to add something to
	      // terminate the declaration, but the termination did not
	      // actually affect the property's value -- and at this spot, we
	      // only care about reporting value changes.  In particular, we
	      // might have added a plain ";", or we might have terminated a
	      // comment with "*/;".  Neither of these affect the value.
	      if (termDecl.terminator !== ";" && termDecl.terminator !== "*/;") {
	        this.changedDeclarations[index] =
	          termDecl.value + termDecl.terminator.slice(0, -1);
	      }
	    }
	    // If the rule generally has newlines, but this particular
	    // declaration doesn't have a trailing newline, insert one now.
	    // Maybe this style is too weird to bother with.
	    if (this.hasNewLine && !NEWLINE_RX.test(trailingText)) {
	      this.result += "\n";
	    }
	  },

	  /**
	   * Sanitize the given property value and return the sanitized form.
	   * If the property is rewritten during sanitization, make a note in
	   * |changedDeclarations|.
	   *
	   * @param {String} text The property text.
	   * @param {Number} index The index of the property.
	   * @return {String} The sanitized text.
	   */
	  sanitizeText: function (text, index) {
	    let [anySanitized, sanitizedText] = this.sanitizePropertyValue(text);
	    if (anySanitized) {
	      this.changedDeclarations[index] = sanitizedText;
	    }
	    return sanitizedText;
	  },

	  /**
	   * Rename a declaration.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name current name of the property
	   * @param {String} newName new name of the property
	   */
	  renameProperty: function (index, name, newName) {
	    this.completeInitialization(index);
	    this.result += CSS.escape(newName);
	    // We could conceivably compute the name offsets instead so we
	    // could preserve white space and comments on the LHS of the ":".
	    this.completeCopying(this.decl.colonOffsets[0]);
	  },

	  /**
	   * Enable or disable a declaration
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name current name of the property
	   * @param {Boolean} isEnabled true if the property should be enabled;
	   *                        false if it should be disabled
	   */
	  setPropertyEnabled: function (index, name, isEnabled) {
	    this.completeInitialization(index);
	    const decl = this.decl;
	    let copyOffset = decl.offsets[1];
	    if (isEnabled) {
	      // Enable it.  First see if the comment start can be deleted.
	      let commentStart = decl.commentOffsets[0];
	      if (EMPTY_COMMENT_START_RX.test(this.result.substring(commentStart))) {
	        this.result = this.result.substring(0, commentStart);
	      } else {
	        this.result += "*/ ";
	      }

	      // Insert the name and value separately, so we can report
	      // sanitization changes properly.
	      let commentNamePart =
	          this.inputString.substring(decl.offsets[0],
	                                     decl.colonOffsets[1]);
	      this.result += unescapeCSSComment(commentNamePart);

	      // When uncommenting, we must be sure to sanitize the text, to
	      // avoid things like /* decl: }; */, which will be accepted as
	      // a property but which would break the entire style sheet.
	      let newText = this.inputString.substring(decl.colonOffsets[1],
	                                               decl.offsets[1]);
	      newText = unescapeCSSComment(newText).trimRight();
	      this.result += this.sanitizeText(newText, index) + ";";

	      // See if the comment end can be deleted.
	      let trailingText = this.inputString.substring(decl.offsets[1]);
	      if (EMPTY_COMMENT_END_RX.test(trailingText)) {
	        copyOffset = decl.commentOffsets[1];
	      } else {
	        this.result += " /*";
	      }
	    } else {
	      // Disable it.  Note that we use our special comment syntax
	      // here.
	      let declText = this.inputString.substring(decl.offsets[0],
	                                                decl.offsets[1]);
	      this.result += "/*" + COMMENT_PARSING_HEURISTIC_BYPASS_CHAR +
	        " " + escapeCSSComment(declText) + " */";
	    }
	    this.completeCopying(copyOffset);
	  },

	  /**
	   * Return a promise that will be resolved to the default indentation
	   * of the rule.  This is a helper for internalCreateProperty.
	   *
	   * @return {Promise} a promise that will be resolved to a string
	   *         that holds the default indentation that should be used
	   *         for edits to the rule.
	   */
	  getDefaultIndentation: function () {
	    return this.rule.parentStyleSheet.guessIndentation();
	  },

	  /**
	   * An internal function to create a new declaration.  This does all
	   * the work of |createProperty|.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name name of the new property
	   * @param {String} value value of the new property
	   * @param {String} priority priority of the new property; either
	   *                          the empty string or "important"
	   * @return {Promise} a promise that is resolved when the edit has
	   *                   completed
	   */
	  internalCreateProperty: Task.async(function* (index, name, value, priority) {
	    this.completeInitialization(index);
	    let newIndentation = "";
	    if (this.hasNewLine) {
	      if (this.declarations.length > 0) {
	        newIndentation = this.getIndentation(this.inputString,
	                                             this.declarations[0].offsets[0]);
	      } else if (this.defaultIndentation) {
	        newIndentation = this.defaultIndentation;
	      } else {
	        newIndentation = yield this.getDefaultIndentation();
	      }
	    }

	    this.maybeTerminateDecl(index - 1);

	    // If we generally have newlines, and if skipping whitespace
	    // backward stops at a newline, then insert our text before that
	    // whitespace.  This ensures the indentation we computed is what
	    // is actually used.
	    let savedWhitespace = "";
	    if (this.hasNewLine) {
	      let wsOffset = this.skipWhitespaceBackward(this.result,
	                                                 this.result.length);
	      if (this.result[wsOffset] === "\r" || this.result[wsOffset] === "\n") {
	        savedWhitespace = this.result.substring(wsOffset + 1);
	        this.result = this.result.substring(0, wsOffset + 1);
	      }
	    }

	    this.result += newIndentation + CSS.escape(name) + ": " +
	      this.sanitizeText(value, index);

	    if (priority === "important") {
	      this.result += " !important";
	    }
	    this.result += ";";
	    if (this.hasNewLine) {
	      this.result += "\n";
	    }
	    this.result += savedWhitespace;

	    if (this.decl) {
	      // Still want to copy in the declaration previously at this
	      // index.
	      this.completeCopying(this.decl.offsets[0]);
	    }
	  }),

	  /**
	   * Create a new declaration.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name name of the new property
	   * @param {String} value value of the new property
	   * @param {String} priority priority of the new property; either
	   *                          the empty string or "important"
	   */
	  createProperty: function (index, name, value, priority) {
	    this.editPromise = this.internalCreateProperty(index, name, value,
	                                                   priority);
	  },

	  /**
	   * Set a declaration's value.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name the property's name
	   * @param {String} value the property's value
	   * @param {String} priority the property's priority, either the empty
	   *                          string or "important"
	   */
	  setProperty: function (index, name, value, priority) {
	    this.completeInitialization(index);
	    // We might see a "set" on a previously non-existent property; in
	    // that case, act like "create".
	    if (!this.decl) {
	      this.createProperty(index, name, value, priority);
	      return;
	    }

	    // Note that this assumes that "set" never operates on disabled
	    // properties.
	    this.result += this.inputString.substring(this.decl.offsets[0],
	                                              this.decl.colonOffsets[1]) +
	      this.sanitizeText(value, index);

	    if (priority === "important") {
	      this.result += " !important";
	    }
	    this.result += ";";
	    this.completeCopying(this.decl.offsets[1]);
	  },

	  /**
	   * Remove a declaration.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name the name of the property to remove
	   */
	  removeProperty: function (index, name) {
	    this.completeInitialization(index);

	    // If asked to remove a property that does not exist, bail out.
	    if (!this.decl) {
	      return;
	    }

	    let copyOffset = this.decl.offsets[1];
	    // Maybe removing this rule left us with a completely blank
	    // line.  In this case, we'll delete the whole thing.  We only
	    // bother with this if we're looking at sources that already
	    // have a newline somewhere.
	    if (this.hasNewLine) {
	      let nlOffset = this.skipWhitespaceBackward(this.result,
	                                                 this.decl.offsets[0]);
	      if (nlOffset < 0 || this.result[nlOffset] === "\r" ||
	          this.result[nlOffset] === "\n") {
	        let trailingText = this.inputString.substring(copyOffset);
	        let match = BLANK_LINE_RX.exec(trailingText);
	        if (match) {
	          this.result = this.result.substring(0, nlOffset + 1);
	          copyOffset += match[0].length;
	        }
	      }
	    }
	    this.completeCopying(copyOffset);
	  },

	  /**
	   * An internal function to copy any trailing text to the output
	   * string.
	   *
	   * @param {Number} copyOffset Offset into |inputString| of the
	   *        final text to copy to the output string.
	   */
	  completeCopying: function (copyOffset) {
	    // Add the trailing text.
	    this.result += this.inputString.substring(copyOffset);
	  },

	  /**
	   * Apply the modifications in this object to the associated rule.
	   *
	   * @return {Promise} A promise which will be resolved when the modifications
	   *         are complete.
	   */
	  apply: function () {
	    return promise.resolve(this.editPromise).then(() => {
	      return this.rule.setRuleText(this.result);
	    });
	  },

	  /**
	   * Get the result of the rewriting.  This is used for testing.
	   *
	   * @return {object} an object of the form {changed: object, text: string}
	   *                  |changed| is an object where each key is
	   *                  the index of a property whose value had to be
	   *                  rewritten during the sanitization process, and
	   *                  whose value is the new text of the property.
	   *                  |text| is the rewritten text of the rule.
	   */
	  getResult: function () {
	    return {changed: this.changedDeclarations, text: this.result};
	  },
	};

	/**
	 * Returns an array of the parsed CSS selector value and type given a string.
	 *
	 * The components making up the CSS selector can be extracted into 3 different
	 * types: element, attribute and pseudoclass. The object that is appended to
	 * the returned array contains the value related to one of the 3 types described
	 * along with the actual type.
	 *
	 * The following are the 3 types that can be returned in the object signature:
	 * (1) SELECTOR_ATTRIBUTE
	 * (2) SELECTOR_ELEMENT
	 * (3) SELECTOR_PSEUDO_CLASS
	 *
	 * @param {String} value
	 *        The CSS selector text.
	 * @return {Array} an array of objects with the following signature:
	 *         [{ "value": string, "type": integer }, ...]
	 */
	function parsePseudoClassesAndAttributes(value) {
	  if (!value) {
	    throw new Error("empty input string");
	  }

	  let tokens = cssTokenizer(value);
	  let result = [];
	  let current = "";
	  let functionCount = 0;
	  let hasAttribute = false;
	  let hasColon = false;

	  for (let token of tokens) {
	    if (token.tokenType === "ident") {
	      current += value.substring(token.startOffset, token.endOffset);

	      if (hasColon && !functionCount) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
	        }

	        current = "";
	        hasColon = false;
	      }
	    } else if (token.tokenType === "symbol" && token.text === ":") {
	      if (!hasColon) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_ELEMENT });
	        }

	        current = "";
	        hasColon = true;
	      }

	      current += token.text;
	    } else if (token.tokenType === "function") {
	      current += value.substring(token.startOffset, token.endOffset);
	      functionCount++;
	    } else if (token.tokenType === "symbol" && token.text === ")") {
	      current += token.text;

	      if (hasColon && functionCount == 1) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
	        }

	        current = "";
	        functionCount--;
	        hasColon = false;
	      } else {
	        functionCount--;
	      }
	    } else if (token.tokenType === "symbol" && token.text === "[") {
	      if (!hasAttribute && !functionCount) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_ELEMENT });
	        }

	        current = "";
	        hasAttribute = true;
	      }

	      current += token.text;
	    } else if (token.tokenType === "symbol" && token.text === "]") {
	      current += token.text;

	      if (hasAttribute && !functionCount) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_ATTRIBUTE });
	        }

	        current = "";
	        hasAttribute = false;
	      }
	    } else {
	      current += value.substring(token.startOffset, token.endOffset);
	    }
	  }

	  if (current) {
	    result.push({ value: current, type: SELECTOR_ELEMENT });
	  }

	  return result;
	}

	/**
	 * Expects a single CSS value to be passed as the input and parses the value
	 * and priority.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        A function to check if the CSS property is known. This is either an
	 *        internal server function or from the CssPropertiesFront.
	 *        that are supported by the server.
	 * @param {String} value
	 *        The value from the text editor.
	 * @return {Object} an object with 'value' and 'priority' properties.
	 */
	function parseSingleValue(isCssPropertyKnown, value) {
	  let declaration = parseDeclarations(isCssPropertyKnown,
	                                      "a: " + value + ";")[0];
	  return {
	    value: declaration ? declaration.value : "",
	    priority: declaration ? declaration.priority : ""
	  };
	}

	exports.cssTokenizer = cssTokenizer;
	exports.cssTokenizerWithLineColumn = cssTokenizerWithLineColumn;
	exports.escapeCSSComment = escapeCSSComment;
	// unescapeCSSComment is exported for testing.
	exports._unescapeCSSComment = unescapeCSSComment;
	exports.parseDeclarations = parseDeclarations;
	// parseCommentDeclarations is exported for testing.
	exports._parseCommentDeclarations = parseCommentDeclarations;
	exports.RuleRewriter = RuleRewriter;
	exports.parsePseudoClassesAndAttributes = parsePseudoClassesAndAttributes;
	exports.parseSingleValue = parseSingleValue;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);
	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);

	// Load gDevToolsBrowser toolbox lazily as they need gDevTools to be fully initialized
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "Toolbox", "devtools/client/framework/toolbox", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "gDevToolsBrowser", "devtools/client/framework/devtools-browser", true);

	const {defaultTools: DefaultTools, defaultThemes: DefaultThemes} =
	  __webpack_require__(38);
	const EventEmitter = __webpack_require__(6);
	// const {JsonView} = require("devtools/client/jsonview/main");
	// const AboutDevTools = require("devtools/client/framework/about-devtools-toolbox");
	// const {when: unload} = require("sdk/system/unload");

	const FORBIDDEN_IDS = new Set(["toolbox", ""]);
	const MAX_ORDINAL = 99;

	/**
	 * DevTools is a class that represents a set of developer tools, it holds a
	 * set of tools and keeps track of open toolboxes in the browser.
	 */
	function DevTools() {
	  this._tools = new Map();     // Map<toolId, tool>
	  this._themes = new Map();    // Map<themeId, theme>
	  this._toolboxes = new Map(); // Map<target, toolbox>

	  // destroy() is an observer's handler so we need to preserve context.
	  this.destroy = this.destroy.bind(this);

	  // JSON Viewer for 'application/json' documents.
	  // JsonView.initialize();

	  // AboutDevTools.register();

	  EventEmitter.decorate(this);

	  // Services.obs.addObserver(this.destroy, "quit-application", false);

	  // This is important step in initialization codepath where we are going to
	  // start registering all default tools and themes: create menuitems, keys, emit
	  // related events.
	  this.registerDefaults();
	};

	DevTools.prototype = {
	  // The windowtype of the main window, used in various tools. This may be set
	  // to something different by other gecko apps.
	  chromeWindowType: "navigator:browser",

	  registerDefaults() {
	    // Ensure registering items in the sorted order (getDefault* functions
	    // return sorted lists)
	    this.getDefaultTools().forEach(definition => this.registerTool(definition));
	    this.getDefaultThemes().forEach(definition => this.registerTheme(definition));
	  },

	  unregisterDefaults() {
	    for (let definition of this.getToolDefinitionArray()) {
	      this.unregisterTool(definition.id);
	    }
	    for (let definition of this.getThemeDefinitionArray()) {
	      this.unregisterTheme(definition.id);
	    }
	  },

	  /**
	   * Register a new developer tool.
	   *
	   * A definition is a light object that holds different information about a
	   * developer tool. This object is not supposed to have any operational code.
	   * See it as a "manifest".
	   * The only actual code lives in the build() function, which will be used to
	   * start an instance of this tool.
	   *
	   * Each toolDefinition has the following properties:
	   * - id: Unique identifier for this tool (string|required)
	   * - visibilityswitch: Property name to allow us to hide this tool from the
	   *                     DevTools Toolbox.
	   *                     A falsy value indicates that it cannot be hidden.
	   * - icon: URL pointing to a graphic which will be used as the src for an
	   *         16x16 img tag (string|required)
	   * - invertIconForLightTheme: The icon can automatically have an inversion
	   *         filter applied (default is false).  All builtin tools are true, but
	   *         addons may omit this to prevent unwanted changes to the `icon`
	   *         image. filter: invert(1) is applied to the image (boolean|optional)
	   * - url: URL pointing to a XUL/XHTML document containing the user interface
	   *        (string|required)
	   * - label: Localized name for the tool to be displayed to the user
	   *          (string|required)
	   * - hideInOptions: Boolean indicating whether or not this tool should be
	                      shown in toolbox options or not. Defaults to false.
	   *                  (boolean)
	   * - build: Function that takes an iframe, which has been populated with the
	   *          markup from |url|, and also the toolbox containing the panel.
	   *          And returns an instance of ToolPanel (function|required)
	   */
	  registerTool: function DT_registerTool(toolDefinition) {
	    let toolId = toolDefinition.id;

	    if (!toolId || FORBIDDEN_IDS.has(toolId)) {
	      throw new Error("Invalid definition.id");
	    }

	    // Make sure that additional tools will always be able to be hidden.
	    // When being called from main.js, defaultTools has not yet been exported.
	    // But, we can assume that in this case, it is a default tool.
	    if (DefaultTools.indexOf(toolDefinition) == -1) {
	      toolDefinition.visibilityswitch = "devtools." + toolId + ".enabled";
	    }

	    this._tools.set(toolId, toolDefinition);

	    this.emit("tool-registered", toolId);
	  },

	  /**
	   * Removes all tools that match the given |toolId|
	   * Needed so that add-ons can remove themselves when they are deactivated
	   *
	   * @param {string|object} tool
	   *        Definition or the id of the tool to unregister. Passing the
	   *        tool id should be avoided as it is a temporary measure.
	   * @param {boolean} isQuitApplication
	   *        true to indicate that the call is due to app quit, so we should not
	   *        cause a cascade of costly events
	   */
	  unregisterTool: function DT_unregisterTool(tool, isQuitApplication) {
	    let toolId = null;
	    if (typeof tool == "string") {
	      toolId = tool;
	      tool = this._tools.get(tool);
	    }
	    else {
	      toolId = tool.id;
	    }
	    this._tools.delete(toolId);

	    if (!isQuitApplication) {
	      this.emit("tool-unregistered", tool);
	    }
	  },

	  /**
	   * Sorting function used for sorting tools based on their ordinals.
	   */
	  ordinalSort: function DT_ordinalSort(d1, d2) {
	    let o1 = (typeof d1.ordinal == "number") ? d1.ordinal : MAX_ORDINAL;
	    let o2 = (typeof d2.ordinal == "number") ? d2.ordinal : MAX_ORDINAL;
	    return o1 - o2;
	  },

	  getDefaultTools: function DT_getDefaultTools() {
	    return DefaultTools.sort(this.ordinalSort);
	  },

	  getAdditionalTools: function DT_getAdditionalTools() {
	    let tools = [];
	    for (let [key, value] of this._tools) {
	      if (DefaultTools.indexOf(value) == -1) {
	        tools.push(value);
	      }
	    }
	    return tools.sort(this.ordinalSort);
	  },

	  getDefaultThemes() {
	    return DefaultThemes.sort(this.ordinalSort);
	  },

	  /**
	   * Get a tool definition if it exists and is enabled.
	   *
	   * @param {string} toolId
	   *        The id of the tool to show
	   *
	   * @return {ToolDefinition|null} tool
	   *         The ToolDefinition for the id or null.
	   */
	  getToolDefinition: function DT_getToolDefinition(toolId) {
	    let tool = this._tools.get(toolId);
	    if (!tool) {
	      return null;
	    } else if (!tool.visibilityswitch) {
	      return tool;
	    }

	    let enabled;
	    try {
	      enabled = Services.prefs.getBoolPref(tool.visibilityswitch);
	    } catch (e) {
	      enabled = true;
	    }

	    return enabled ? tool : null;
	  },

	  /**
	   * Allow ToolBoxes to get at the list of tools that they should populate
	   * themselves with.
	   *
	   * @return {Map} tools
	   *         A map of the the tool definitions registered in this instance
	   */
	  getToolDefinitionMap: function DT_getToolDefinitionMap() {
	    let tools = new Map();

	    for (let [id, definition] of this._tools) {
	      if (this.getToolDefinition(id)) {
	        tools.set(id, definition);
	      }
	    }

	    return tools;
	  },

	  /**
	   * Tools have an inherent ordering that can't be represented in a Map so
	   * getToolDefinitionArray provides an alternative representation of the
	   * definitions sorted by ordinal value.
	   *
	   * @return {Array} tools
	   *         A sorted array of the tool definitions registered in this instance
	   */
	  getToolDefinitionArray: function DT_getToolDefinitionArray() {
	    let definitions = [];

	    for (let [id, definition] of this._tools) {
	      if (this.getToolDefinition(id)) {
	        definitions.push(definition);
	      }
	    }

	    return definitions.sort(this.ordinalSort);
	  },

	  /**
	   * Register a new theme for developer tools toolbox.
	   *
	   * A definition is a light object that holds various information about a
	   * theme.
	   *
	   * Each themeDefinition has the following properties:
	   * - id: Unique identifier for this theme (string|required)
	   * - label: Localized name for the theme to be displayed to the user
	   *          (string|required)
	   * - stylesheets: Array of URLs pointing to a CSS document(s) containing
	   *                the theme style rules (array|required)
	   * - classList: Array of class names identifying the theme within a document.
	   *              These names are set to document element when applying
	   *              the theme (array|required)
	   * - onApply: Function that is executed by the framework when the theme
	   *            is applied. The function takes the current iframe window
	   *            and the previous theme id as arguments (function)
	   * - onUnapply: Function that is executed by the framework when the theme
	   *            is unapplied. The function takes the current iframe window
	   *            and the new theme id as arguments (function)
	   */
	  registerTheme: function DT_registerTheme(themeDefinition) {
	    let themeId = themeDefinition.id;

	    if (!themeId) {
	      throw new Error("Invalid theme id");
	    }

	    if (this._themes.get(themeId)) {
	      throw new Error("Theme with the same id is already registered");
	    }

	    this._themes.set(themeId, themeDefinition);

	    this.emit("theme-registered", themeId);
	  },

	  /**
	   * Removes an existing theme from the list of registered themes.
	   * Needed so that add-ons can remove themselves when they are deactivated
	   *
	   * @param {string|object} theme
	   *        Definition or the id of the theme to unregister.
	   */
	  unregisterTheme: function DT_unregisterTheme(theme) {
	    let themeId = null;
	    if (typeof theme == "string") {
	      themeId = theme;
	      theme = this._themes.get(theme);
	    }
	    else {
	      themeId = theme.id;
	    }

	    let currTheme = Services.prefs.getCharPref("devtools.theme");

	    // Note that we can't check if `theme` is an item
	    // of `DefaultThemes` as we end up reloading definitions
	    // module and end up with different theme objects
	    let isCoreTheme = DefaultThemes.some(t => t.id === themeId);

	    // Reset the theme if an extension theme that's currently applied
	    // is being removed.
	    // Ignore shutdown since addons get disabled during that time.
	    if (!Services.startup.shuttingDown &&
	        !isCoreTheme &&
	        theme.id == currTheme) {
	      Services.prefs.setCharPref("devtools.theme", "light");

	      let data = {
	        pref: "devtools.theme",
	        newValue: "light",
	        oldValue: currTheme
	      };

	      this.emit("pref-changed", data);

	      this.emit("theme-unregistered", theme);
	    }

	    this._themes.delete(themeId);
	  },

	  /**
	   * Get a theme definition if it exists.
	   *
	   * @param {string} themeId
	   *        The id of the theme
	   *
	   * @return {ThemeDefinition|null} theme
	   *         The ThemeDefinition for the id or null.
	   */
	  getThemeDefinition: function DT_getThemeDefinition(themeId) {
	    let theme = this._themes.get(themeId);
	    if (!theme) {
	      return null;
	    }
	    return theme;
	  },

	  /**
	   * Get map of registered themes.
	   *
	   * @return {Map} themes
	   *         A map of the the theme definitions registered in this instance
	   */
	  getThemeDefinitionMap: function DT_getThemeDefinitionMap() {
	    let themes = new Map();

	    for (let [id, definition] of this._themes) {
	      if (this.getThemeDefinition(id)) {
	        themes.set(id, definition);
	      }
	    }

	    return themes;
	  },

	  /**
	   * Get registered themes definitions sorted by ordinal value.
	   *
	   * @return {Array} themes
	   *         A sorted array of the theme definitions registered in this instance
	   */
	  getThemeDefinitionArray: function DT_getThemeDefinitionArray() {
	    let definitions = [];

	    for (let [id, definition] of this._themes) {
	      if (this.getThemeDefinition(id)) {
	        definitions.push(definition);
	      }
	    }

	    return definitions.sort(this.ordinalSort);
	  },

	  /**
	   * Show a Toolbox for a target (either by creating a new one, or if a toolbox
	   * already exists for the target, by bring to the front the existing one)
	   * If |toolId| is specified then the displayed toolbox will have the
	   * specified tool selected.
	   * If |hostType| is specified then the toolbox will be displayed using the
	   * specified HostType.
	   *
	   * @param {Target} target
	   *         The target the toolbox will debug
	   * @param {string} toolId
	   *        The id of the tool to show
	   * @param {Toolbox.HostType} hostType
	   *        The type of host (bottom, window, side)
	   * @param {object} hostOptions
	   *        Options for host specifically
	   *
	   * @return {Toolbox} toolbox
	   *        The toolbox that was opened
	   */
	  showToolbox: function (target, toolId, hostType, hostOptions) {
	    let deferred = defer();

	    let toolbox = this._toolboxes.get(target);
	    if (toolbox) {

	      let hostPromise = (hostType != null && toolbox.hostType != hostType) ?
	          toolbox.switchHost(hostType) :
	          promise.resolve(null);

	      if (toolId != null && toolbox.currentToolId != toolId) {
	        hostPromise = hostPromise.then(function () {
	          return toolbox.selectTool(toolId);
	        });
	      }

	      return hostPromise.then(function () {
	        toolbox.raise();
	        return toolbox;
	      });
	    }
	    else {
	      // No toolbox for target, create one
	      toolbox = new Toolbox(target, toolId, hostType, hostOptions);

	      this.emit("toolbox-created", toolbox);

	      this._toolboxes.set(target, toolbox);

	      toolbox.once("destroy", () => {
	        this.emit("toolbox-destroy", target);
	      });

	      toolbox.once("destroyed", () => {
	        this._toolboxes.delete(target);
	        this.emit("toolbox-destroyed", target);
	      });

	      // If toolId was passed in, it will already be selected before the
	      // open promise resolves.
	      toolbox.open().then(() => {
	        deferred.resolve(toolbox);
	        this.emit("toolbox-ready", toolbox);
	      });
	    }

	    return deferred.promise;
	  },

	  /**
	   * Return the toolbox for a given target.
	   *
	   * @param  {object} target
	   *         Target value e.g. the target that owns this toolbox
	   *
	   * @return {Toolbox} toolbox
	   *         The toolbox that is debugging the given target
	   */
	  getToolbox: function DT_getToolbox(target) {
	    return this._toolboxes.get(target);
	  },

	  /**
	   * Close the toolbox for a given target
	   *
	   * @return promise
	   *         This promise will resolve to false if no toolbox was found
	   *         associated to the target. true, if the toolbox was successfully
	   *         closed.
	   */
	  closeToolbox: function DT_closeToolbox(target) {
	    let toolbox = this._toolboxes.get(target);
	    if (toolbox == null) {
	      return promise.resolve(false);
	    }
	    return toolbox.destroy().then(() => true);
	  },

	  /**
	   * Called to tear down a tools provider.
	   */
	  _teardown: function DT_teardown() {
	    for (let [target, toolbox] of this._toolboxes) {
	      toolbox.destroy();
	    }
	    // AboutDevTools.unregister();
	  },

	  /**
	   * All browser windows have been closed, tidy up remaining objects.
	   */
	  destroy: function () {
	    // Services.obs.removeObserver(this.destroy, "quit-application");

	    for (let [key, tool] of this.getToolDefinitionMap()) {
	      this.unregisterTool(key, true);
	    }

	    // JsonView.destroy();

	    gDevTools.unregisterDefaults();

	    // Cleaning down the toolboxes: i.e.
	    //   for (let [target, toolbox] of this._toolboxes) toolbox.destroy();
	    // Is taken care of by the gDevToolsBrowser.forgetBrowserWindow
	  },

	  /**
	   * Iterator that yields each of the toolboxes.
	   */
	  *[Symbol.iterator ]() {
	    for (let toolbox of this._toolboxes) {
	      yield toolbox;
	    }
	  }
	};

	const gDevTools = exports.gDevTools = new DevTools();

	// Watch for module loader unload. Fires when the tools are reloaded.
	// unload(function () {
	//   gDevTools._teardown();
	// });


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// The style-inspector overlays are:
	// - tooltips that appear when hovering over property values
	// - editor tooltips that appear when clicking color swatches, etc.
	// - in-content highlighters that appear when hovering over property values
	// - etc.

	const {getColor} = __webpack_require__(135);
	const {HTMLTooltip} = __webpack_require__(137);
	const {
	  getImageDimensions,
	  setImageTooltip,
	  setBrokenImageTooltip,
	} = __webpack_require__(140);
	const {
	  CssDocsTooltip,
	} = __webpack_require__(141);
	const {
	  SwatchColorPickerTooltip,
	  SwatchCubicBezierTooltip,
	  SwatchFilterTooltip
	} = __webpack_require__(143);
	const EventEmitter = __webpack_require__(6);
	const promise = __webpack_require__(4);
	const {Task} = __webpack_require__(17);
	const Services = __webpack_require__(1);

	const PREF_IMAGE_TOOLTIP_SIZE = "devtools.inspector.imagePreviewTooltipSize";

	// Types of existing tooltips
	const TOOLTIP_IMAGE_TYPE = "image";
	const TOOLTIP_FONTFAMILY_TYPE = "font-family";

	// Types of nodes in the rule/computed-view
	const VIEW_NODE_SELECTOR_TYPE = 1;
	exports.VIEW_NODE_SELECTOR_TYPE = VIEW_NODE_SELECTOR_TYPE;
	const VIEW_NODE_PROPERTY_TYPE = 2;
	exports.VIEW_NODE_PROPERTY_TYPE = VIEW_NODE_PROPERTY_TYPE;
	const VIEW_NODE_VALUE_TYPE = 3;
	exports.VIEW_NODE_VALUE_TYPE = VIEW_NODE_VALUE_TYPE;
	const VIEW_NODE_IMAGE_URL_TYPE = 4;
	exports.VIEW_NODE_IMAGE_URL_TYPE = VIEW_NODE_IMAGE_URL_TYPE;
	const VIEW_NODE_LOCATION_TYPE = 5;
	exports.VIEW_NODE_LOCATION_TYPE = VIEW_NODE_LOCATION_TYPE;

	/**
	 * Manages all highlighters in the style-inspector.
	 *
	 * @param {CssRuleView|CssComputedView} view
	 *        Either the rule-view or computed-view panel
	 */
	function HighlightersOverlay(view) {
	  this.view = view;

	  let {CssRuleView} = __webpack_require__(149);
	  this.isRuleView = view instanceof CssRuleView;

	  this.highlighterUtils = this.view.inspector.toolbox.highlighterUtils;

	  this._onMouseMove = this._onMouseMove.bind(this);
	  this._onMouseOut = this._onMouseOut.bind(this);

	  this.highlighters = {};

	  // Only initialize the overlay if at least one of the highlighter types is
	  // supported
	  this.supportsHighlighters =
	    this.highlighterUtils.supportsCustomHighlighters();

	  EventEmitter.decorate(this);
	}

	exports.HighlightersOverlay = HighlightersOverlay;

	HighlightersOverlay.prototype = {
	  /**
	   * Add the highlighters overlay to the view. This will start tracking mouse
	   * movements and display highlighters when needed
	   */
	  addToView: function () {
	    if (!this.supportsHighlighters || this._isStarted || this._isDestroyed) {
	      return;
	    }

	    let el = this.view.element;
	    el.addEventListener("mousemove", this._onMouseMove, false);
	    el.addEventListener("mouseout", this._onMouseOut, false);
	    el.ownerDocument.defaultView.addEventListener("mouseout", this._onMouseOut, false);

	    this._isStarted = true;
	  },

	  /**
	   * Remove the overlay from the current view. This will stop tracking mouse
	   * movement and showing highlighters
	   */
	  removeFromView: function () {
	    if (!this.supportsHighlighters || !this._isStarted || this._isDestroyed) {
	      return;
	    }

	    this._hideCurrent();

	    let el = this.view.element;
	    el.removeEventListener("mousemove", this._onMouseMove, false);
	    el.removeEventListener("mouseout", this._onMouseOut, false);

	    this._isStarted = false;
	  },

	  _onMouseMove: function (event) {
	    // Bail out if the target is the same as for the last mousemove
	    if (event.target === this._lastHovered) {
	      return;
	    }

	    // Only one highlighter can be displayed at a time, hide the currently shown
	    this._hideCurrent();

	    this._lastHovered = event.target;

	    let nodeInfo = this.view.getNodeInfo(event.target);
	    if (!nodeInfo) {
	      return;
	    }

	    // Choose the type of highlighter required for the hovered node
	    let type;
	    if (this._isRuleViewTransform(nodeInfo) ||
	        this._isComputedViewTransform(nodeInfo)) {
	      type = "CssTransformHighlighter";
	    }

	    if (type) {
	      this.highlighterShown = type;
	      let node = this.view.inspector.selection.nodeFront;
	      this._getHighlighter(type)
	          .then(highlighter => highlighter.show(node))
	          .then(shown => {
	            if (shown) {
	              this.emit("highlighter-shown");
	            }
	          });
	    }
	  },

	  _onMouseOut: function (event) {
	    // Only hide the highlighter if the mouse leaves the currently hovered node.
	    if (!this._lastHovered ||
	        (event && this._lastHovered.contains(event.relatedTarget))) {
	      return;
	    }

	    // Otherwise, hide the highlighter.
	    this._lastHovered = null;
	    this._hideCurrent();
	  },

	  /**
	   * Is the current hovered node a css transform property value in the rule-view
	   *
	   * @param {Object} nodeInfo
	   * @return {Boolean}
	   */
	  _isRuleViewTransform: function (nodeInfo) {
	    let isTransform = nodeInfo.type === VIEW_NODE_VALUE_TYPE &&
	                      nodeInfo.value.property === "transform";
	    let isEnabled = nodeInfo.value.enabled &&
	                    !nodeInfo.value.overridden &&
	                    !nodeInfo.value.pseudoElement;
	    return this.isRuleView && isTransform && isEnabled;
	  },

	  /**
	   * Is the current hovered node a css transform property value in the
	   * computed-view
	   *
	   * @param {Object} nodeInfo
	   * @return {Boolean}
	   */
	  _isComputedViewTransform: function (nodeInfo) {
	    let isTransform = nodeInfo.type === VIEW_NODE_VALUE_TYPE &&
	                      nodeInfo.value.property === "transform";
	    return !this.isRuleView && isTransform;
	  },

	  /**
	   * Hide the currently shown highlighter
	   */
	  _hideCurrent: function () {
	    if (!this.highlighterShown || !this.highlighters[this.highlighterShown]) {
	      return;
	    }

	    // For some reason, the call to highlighter.hide doesn't always return a
	    // promise. This causes some tests to fail when trying to install a
	    // rejection handler on the result of the call. To avoid this, check
	    // whether the result is truthy before installing the handler.
	    let onHidden = this.highlighters[this.highlighterShown].hide();
	    if (onHidden) {
	      onHidden.then(null, e => console.error(e));
	    }

	    this.highlighterShown = null;
	    this.emit("highlighter-hidden");
	  },

	  /**
	   * Get a highlighter front given a type. It will only be initialized once
	   * @param {String} type The highlighter type. One of this.highlighters
	   * @return a promise that resolves to the highlighter
	   */
	  _getHighlighter: function (type) {
	    let utils = this.highlighterUtils;

	    if (this.highlighters[type]) {
	      return promise.resolve(this.highlighters[type]);
	    }

	    return utils.getHighlighterByType(type).then(highlighter => {
	      this.highlighters[type] = highlighter;
	      return highlighter;
	    });
	  },

	  /**
	   * Destroy this overlay instance, removing it from the view and destroying
	   * all initialized highlighters
	   */
	  destroy: function () {
	    this.removeFromView();

	    for (let type in this.highlighters) {
	      if (this.highlighters[type]) {
	        this.highlighters[type].finalize();
	        this.highlighters[type] = null;
	      }
	    }

	    this.view = null;
	    this.highlighterUtils = null;

	    this._isDestroyed = true;
	  }
	};

	/**
	 * Manages all tooltips in the style-inspector.
	 *
	 * @param {CssRuleView|CssComputedView} view
	 *        Either the rule-view or computed-view panel
	 */
	function TooltipsOverlay(view) {
	  this.view = view;

	  let {CssRuleView} = __webpack_require__(149);
	  this.isRuleView = view instanceof CssRuleView;

	  this._onNewSelection = this._onNewSelection.bind(this);
	  this.view.inspector.selection.on("new-node-front", this._onNewSelection);
	}

	exports.TooltipsOverlay = TooltipsOverlay;

	TooltipsOverlay.prototype = {
	  get isEditing() {
	    return this.colorPicker.tooltip.isVisible() ||
	           this.colorPicker.eyedropperOpen ||
	           this.cubicBezier.tooltip.isVisible() ||
	           this.filterEditor.tooltip.isVisible();
	  },

	  /**
	   * Add the tooltips overlay to the view. This will start tracking mouse
	   * movements and display tooltips when needed
	   */
	  addToView: function () {
	    if (this._isStarted || this._isDestroyed) {
	      return;
	    }

	    let { toolbox } = this.view.inspector;

	    // Image, fonts, ... preview tooltip
	    this.previewTooltip = new HTMLTooltip(toolbox, {
	      type: "arrow",
	      useXulWrapper: true
	    });
	    this.previewTooltip.startTogglingOnHover(this.view.element,
	      this._onPreviewTooltipTargetHover.bind(this));

	    // MDN CSS help tooltip
	    this.cssDocs = new CssDocsTooltip(toolbox);

	    if (this.isRuleView) {
	      // Color picker tooltip
	      this.colorPicker = new SwatchColorPickerTooltip(toolbox, this.view.inspector);
	      // Cubic bezier tooltip
	      this.cubicBezier = new SwatchCubicBezierTooltip(toolbox);
	      // Filter editor tooltip
	      this.filterEditor = new SwatchFilterTooltip(toolbox);
	    }

	    this._isStarted = true;
	  },

	  /**
	   * Remove the tooltips overlay from the view. This will stop tracking mouse
	   * movements and displaying tooltips
	   */
	  removeFromView: function () {
	    if (!this._isStarted || this._isDestroyed) {
	      return;
	    }

	    this.previewTooltip.stopTogglingOnHover(this.view.element);
	    this.previewTooltip.destroy();

	    if (this.colorPicker) {
	      this.colorPicker.destroy();
	    }

	    if (this.cubicBezier) {
	      this.cubicBezier.destroy();
	    }

	    if (this.cssDocs) {
	      this.cssDocs.destroy();
	    }

	    if (this.filterEditor) {
	      this.filterEditor.destroy();
	    }

	    this._isStarted = false;
	  },

	  /**
	   * Given a hovered node info, find out which type of tooltip should be shown,
	   * if any
	   *
	   * @param {Object} nodeInfo
	   * @return {String} The tooltip type to be shown, or null
	   */
	  _getTooltipType: function ({type, value: prop}) {
	    let tooltipType = null;
	    let inspector = this.view.inspector;

	    // Image preview tooltip
	    if (type === VIEW_NODE_IMAGE_URL_TYPE &&
	        inspector.hasUrlToImageDataResolver) {
	      tooltipType = TOOLTIP_IMAGE_TYPE;
	    }

	    // Font preview tooltip
	    if (type === VIEW_NODE_VALUE_TYPE && prop.property === "font-family") {
	      let value = prop.value.toLowerCase();
	      if (value !== "inherit" && value !== "unset" && value !== "initial") {
	        tooltipType = TOOLTIP_FONTFAMILY_TYPE;
	      }
	    }

	    return tooltipType;
	  },

	  /**
	   * Executed by the tooltip when the pointer hovers over an element of the
	   * view. Used to decide whether the tooltip should be shown or not and to
	   * actually put content in it.
	   * Checks if the hovered target is a css value we support tooltips for.
	   *
	   * @param {DOMNode} target The currently hovered node
	   * @return {Promise}
	   */
	  _onPreviewTooltipTargetHover: Task.async(function* (target) {
	    let nodeInfo = this.view.getNodeInfo(target);
	    if (!nodeInfo) {
	      // The hovered node isn't something we care about
	      return false;
	    }

	    let type = this._getTooltipType(nodeInfo);
	    if (!type) {
	      // There is no tooltip type defined for the hovered node
	      return false;
	    }

	    if (this.isRuleView && this.colorPicker.tooltip.isVisible()) {
	      this.colorPicker.revert();
	      this.colorPicker.hide();
	    }

	    if (this.isRuleView && this.cubicBezier.tooltip.isVisible()) {
	      this.cubicBezier.revert();
	      this.cubicBezier.hide();
	    }

	    if (this.isRuleView && this.cssDocs.tooltip.isVisible()) {
	      this.cssDocs.hide();
	    }

	    if (this.isRuleView && this.filterEditor.tooltip.isVisible()) {
	      this.filterEditor.revert();
	      this.filterEdtior.hide();
	    }

	    let inspector = this.view.inspector;

	    if (type === TOOLTIP_IMAGE_TYPE) {
	      try {
	        yield this._setImagePreviewTooltip(nodeInfo.value.url);
	      } catch (e) {
	        yield setBrokenImageTooltip(this.previewTooltip, this.view.inspector.panelDoc);
	      }
	      return true;
	    }

	    if (type === TOOLTIP_FONTFAMILY_TYPE) {
	      let font = nodeInfo.value.value;
	      let nodeFront = inspector.selection.nodeFront;
	      yield this._setFontPreviewTooltip(font, nodeFront);
	      return true;
	    }

	    return false;
	  }),

	  /**
	   * Set the content of the preview tooltip to display an image preview. The image URL can
	   * be relative, a call will be made to the debuggee to retrieve the image content as an
	   * imageData URI.
	   *
	   * @param {String} imageUrl
	   *        The image url value (may be relative or absolute).
	   * @return {Promise} A promise that resolves when the preview tooltip content is ready
	   */
	  _setImagePreviewTooltip: Task.async(function* (imageUrl) {
	    let doc = this.view.inspector.panelDoc;
	    let maxDim = Services.prefs.getIntPref(PREF_IMAGE_TOOLTIP_SIZE);

	    let naturalWidth, naturalHeight;
	    if (imageUrl.startsWith("data:")) {
	      // If the imageUrl already is a data-url, save ourselves a round-trip
	      let size = yield getImageDimensions(doc, imageUrl);
	      naturalWidth = size.naturalWidth;
	      naturalHeight = size.naturalHeight;
	    } else {
	      let inspectorFront = this.view.inspector.inspector;
	      let {data, size} = yield inspectorFront.getImageDataFromURL(imageUrl, maxDim);
	      imageUrl = yield data.string();
	      naturalWidth = size.naturalWidth;
	      naturalHeight = size.naturalHeight;
	    }

	    yield setImageTooltip(this.previewTooltip, doc, imageUrl,
	      {maxDim, naturalWidth, naturalHeight});
	  }),

	  /**
	   * Set the content of the preview tooltip to display a font family preview.
	   *
	   * @param {String} font
	   *        The font family value.
	   * @param {object} nodeFront
	   *        The NodeActor that will used to retrieve the dataURL for the font
	   *        family tooltip contents.
	   * @return {Promise} A promise that resolves when the preview tooltip content is ready
	   */
	  _setFontPreviewTooltip: Task.async(function* (font, nodeFront) {
	    if (!font || !nodeFront || typeof nodeFront.getFontFamilyDataURL !== "function") {
	      throw new Error("Unable to create font preview tooltip content.");
	    }

	    font = font.replace(/"/g, "'");
	    font = font.replace("!important", "");
	    font = font.trim();

	    let fillStyle = getColor("body-color");
	    let {data, size: maxDim} = yield nodeFront.getFontFamilyDataURL(font, fillStyle);

	    let imageUrl = yield data.string();
	    let doc = this.view.inspector.panelDoc;
	    let {naturalWidth, naturalHeight} = yield getImageDimensions(doc, imageUrl);

	    yield setImageTooltip(this.previewTooltip, doc, imageUrl,
	      {hideDimensionLabel: true, maxDim, naturalWidth, naturalHeight});
	  }),

	  _onNewSelection: function () {
	    if (this.previewTooltip) {
	      this.previewTooltip.hide();
	    }

	    if (this.colorPicker) {
	      this.colorPicker.hide();
	    }

	    if (this.cubicBezier) {
	      this.cubicBezier.hide();
	    }

	    if (this.cssDocs) {
	      this.cssDocs.hide();
	    }

	    if (this.filterEditor) {
	      this.filterEditor.hide();
	    }
	  },

	  /**
	   * Destroy this overlay instance, removing it from the view
	   */
	  destroy: function () {
	    this.removeFromView();

	    this.view.inspector.selection.off("new-node-front", this._onNewSelection);
	    this.view = null;

	    this._isDestroyed = true;
	  }
	};


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Colors for themes taken from:
	 * https://developer.mozilla.org/en-US/docs/Tools/DevToolsColors
	 */

	const Services = __webpack_require__(1);
	const { gDevTools } = __webpack_require__(133);

	const variableFileContents = __webpack_require__(136);

	const THEME_SELECTOR_STRINGS = {
	  light: ":root.theme-light {",
	  dark: ":root.theme-dark {"
	};

	/**
	 * Takes a theme name and returns the contents of its variable rule block.
	 * The first time this runs fetches the variables CSS file and caches it.
	 */
	function getThemeFile(name) {
	  // If there's no theme expected for this name, use `light` as default.
	  let selector = THEME_SELECTOR_STRINGS[name] ||
	                 THEME_SELECTOR_STRINGS.light;

	  // This is a pretty naive way to find the contents between:
	  // selector {
	  //   name: val;
	  // }
	  // There is test coverage for this feature (browser_theme.js)
	  // so if an } is introduced in the variables file it will catch that.
	  let theme = variableFileContents;
	  theme = theme.substring(theme.indexOf(selector));
	  theme = theme.substring(0, theme.indexOf("}"));

	  return theme;
	}

	/**
	 * Returns the string value of the current theme,
	 * like "dark" or "light".
	 */
	const getTheme = exports.getTheme = () => {
	  return Services.prefs.getCharPref("devtools.theme");
	};

	/**
	 * Returns a color indicated by `type` (like "toolbar-background", or
	 * "highlight-red"), with the ability to specify a theme, or use whatever the
	 * current theme is if left unset. If theme not found, falls back to "light"
	 * theme. Returns null if the type cannot be found for the theme given.
	 */
	/* eslint-disable no-unused-vars */
	const getColor = exports.getColor = (type, theme) => {
	  let themeName = theme || getTheme();
	  let themeFile = getThemeFile(themeName);
	  let match = themeFile.match(new RegExp("--theme-" + type + ": (.*);"));

	  // Return the appropriate variable in the theme, or otherwise, null.
	  return match ? match[1] : null;
	};

	/**
	 * Mimics selecting the theme selector in the toolbox;
	 * sets the preference and emits an event on gDevTools to trigger
	 * the themeing.
	 */
	const setTheme = exports.setTheme = (newTheme) => {
	  let oldTheme = getTheme();

	  Services.prefs.setCharPref("devtools.theme", newTheme);
	  gDevTools.emit("pref-changed", {
	    pref: "devtools.theme",
	    newValue: newTheme,
	    oldValue: oldTheme
	  });
	};
	/* eslint-enable */


/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = "/* vim:set ts=2 sw=2 sts=2 et: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/* Variable declarations for light and dark devtools themes.\n * Colors are taken from:\n * https://developer.mozilla.org/en-US/docs/Tools/DevToolsColors.\n * Changes should be kept in sync with commandline.css and commandline.inc.css.\n */\n\n/* IMPORTANT NOTE:\n * This file is parsed in js (see client/shared/theme.js)\n * so the formatting should be consistent (i.e. no '}' inside a rule).\n */\n\n:root.theme-light {\n  --theme-body-background: white;\n  --theme-sidebar-background: white;\n  --theme-contrast-background: #e6b064;\n\n  --theme-tab-toolbar-background: #fcfcfc;\n  --theme-toolbar-background: #fcfcfc;\n  --theme-selection-background: #4c9ed9;\n  --theme-selection-background-semitransparent: rgba(76, 158, 217, 0.15);\n  --theme-selection-color: #f5f7fa;\n  --theme-splitter-color: #dde1e4;\n  --theme-comment: #696969;\n\n  --theme-body-color: #393f4c;\n  --theme-body-color-alt: #585959;\n  --theme-body-color-inactive: #999797;\n  --theme-content-color1: #292e33;\n  --theme-content-color2: #8fa1b2;\n  --theme-content-color3: #667380;\n\n  --theme-highlight-green: #2cbb0f;\n  --theme-highlight-blue: #0088cc;\n  --theme-highlight-bluegrey: #0072ab;\n  --theme-highlight-purple: #5b5fff;\n  --theme-highlight-lightorange: #d97e00;\n  --theme-highlight-orange: #f13c00;\n  --theme-highlight-red: #ed2655;\n  --theme-highlight-pink: #b82ee5;\n  --theme-highlight-gray: #dde1e4;\n\n  /* For accessibility purposes we want to enhance the focus styling. This\n   * should improve keyboard navigation usability. */\n  --theme-focus-outline-color: #000000;\n\n  /* Colors used in Graphs, like performance tools. Similar colors to Chrome's timeline. */\n  --theme-graphs-green: #85d175;\n  --theme-graphs-blue: #83b7f6;\n  --theme-graphs-bluegrey: #0072ab;\n  --theme-graphs-purple: #b693eb;\n  --theme-graphs-yellow: #efc052;\n  --theme-graphs-orange: #d97e00;\n  --theme-graphs-red: #e57180;\n  --theme-graphs-grey: #cccccc;\n  --theme-graphs-full-red: #f00;\n  --theme-graphs-full-blue: #00f;\n\n  /* Images */\n  --theme-pane-collapse-image: url(chrome://devtools/skin/images/pane-collapse.svg);\n  --theme-pane-expand-image: url(chrome://devtools/skin/images/pane-expand.svg);\n\n  /* Tooltips */\n  --theme-tooltip-border: #d9e1e8;\n  --theme-tooltip-background: rgba(255, 255, 255, .9);\n  --theme-tooltip-shadow: rgba(155, 155, 155, 0.26);\n\n  /* Command line */\n  --theme-command-line-image: url(chrome://devtools/skin/images/commandline-icon.svg#light-theme);\n  --theme-command-line-image-focus: url(chrome://devtools/skin/images/commandline-icon.svg#light-theme-focus);\n}\n\n:root.theme-dark {\n  --theme-body-background: #393f4c;\n  --theme-sidebar-background: #393f4c;\n  --theme-contrast-background: #ffb35b;\n\n  --theme-tab-toolbar-background: #272b35;\n  --theme-toolbar-background: #272b35;\n  --theme-selection-background: #5675B9;\n  --theme-selection-background-semitransparent: rgba(86, 117, 185, 0.5);\n  --theme-selection-color: #f5f7fa;\n  --theme-splitter-color: #454d5d;\n  --theme-comment: #757873;\n\n  --theme-body-color: #8fa1b2;\n  --theme-body-color-alt: #b6babf;\n  --theme-body-color-inactive: #8fa1b2;\n  --theme-content-color1: #a9bacb;\n  --theme-content-color2: #8fa1b2;\n  --theme-content-color3: #5f7387;\n\n  --theme-highlight-green: #00ff7f;\n  --theme-highlight-blue: #46afe3;\n  --theme-highlight-bluegrey: #5e88b0;\n  --theme-highlight-purple: #bcb8db;\n  --theme-highlight-lightorange: #d99b28;\n  --theme-highlight-orange: #d96629;\n  --theme-highlight-red: #eb5368;\n  --theme-highlight-pink: #df80ff;\n  --theme-highlight-gray: #e9f4fe;\n\n  /* For accessibility purposes we want to enhance the focus styling. This\n   * should improve keyboard navigation usability. */\n  --theme-focus-outline-color: #ced3d9;\n\n  /* Colors used in Graphs, like performance tools. Mostly similar to some \"highlight-*\" colors. */\n  --theme-graphs-green: #70bf53;\n  --theme-graphs-blue: #46afe3;\n  --theme-graphs-bluegrey: #5e88b0;\n  --theme-graphs-purple: #df80ff;\n  --theme-graphs-yellow: #d99b28;\n  --theme-graphs-orange: #d96629;\n  --theme-graphs-red: #eb5368;\n  --theme-graphs-grey: #757873;\n  --theme-graphs-full-red: #f00;\n  --theme-graphs-full-blue: #00f;\n\n  /* Images */\n  --theme-pane-collapse-image: url(chrome://devtools/skin/images/pane-collapse.svg);\n  --theme-pane-expand-image: url(chrome://devtools/skin/images/pane-expand.svg);\n\n  /* Tooltips */\n  --theme-tooltip-border: #434850;\n  --theme-tooltip-background: rgba(19, 28, 38, .9);\n  --theme-tooltip-shadow: rgba(25, 25, 25, 0.76);\n\n  /* Command line */\n  --theme-command-line-image: url(chrome://devtools/skin/images/commandline-icon.svg#dark-theme);\n  --theme-command-line-image-focus: url(chrome://devtools/skin/images/commandline-icon.svg#dark-theme-focus);\n}\n\n:root.theme-firebug {\n  --theme-body-background: #fcfcfc;\n  --theme-sidebar-background: #fcfcfc;\n  --theme-contrast-background: #e6b064;\n\n  --theme-tab-toolbar-background: #ebeced;\n  --theme-toolbar-background: #f0f1f2;\n  --theme-selection-background: #3399ff;\n  --theme-selection-background-semitransparent: rgba(128,128,128,0.2);\n  --theme-selection-color: white;\n  --theme-splitter-color: #aabccf;\n  --theme-comment: green;\n\n  --theme-body-color: #18191a;\n  --theme-body-color-alt: #585959;\n  --theme-content-color1: #292e33;\n  --theme-content-color2: #8fa1b2;\n  --theme-content-color3: #667380;\n\n  --theme-highlight-green: #2cbb0f;\n  --theme-highlight-blue: #3455db;\n  --theme-highlight-bluegrey: #0072ab;\n  --theme-highlight-purple: #887ce6;\n  --theme-highlight-lightorange: #d97e00;\n  --theme-highlight-orange: #f13c00;\n  --theme-highlight-red: #e22f6f;\n  --theme-highlight-pink: #b82ee5;\n  --theme-highlight-gray: #dde1e4;\n\n  /* Colors used in Graphs, like performance tools. Similar colors to Chrome's timeline. */\n  --theme-graphs-green: #85d175;\n  --theme-graphs-blue: #83b7f6;\n  --theme-graphs-bluegrey: #0072ab;\n  --theme-graphs-purple: #b693eb;\n  --theme-graphs-yellow: #efc052;\n  --theme-graphs-orange: #d97e00;\n  --theme-graphs-red: #e57180;\n  --theme-graphs-grey: #cccccc;\n  --theme-graphs-full-red: #f00;\n  --theme-graphs-full-blue: #00f;\n\n  /* Images */\n  --theme-pane-collapse-image: url(chrome://devtools/skin/images/firebug/pane-collapse.svg);\n  --theme-pane-expand-image: url(chrome://devtools/skin/images/firebug/pane-expand.svg);\n\n  /* Font size */\n  --theme-toolbar-font-size: 12px;\n\n  /* Header */\n  --theme-header-background: #F0F0F0 linear-gradient(to top,\n                                                     rgba(0, 0, 0, 0.1),\n                                                     transparent) repeat-x;\n\n  /* Command line */\n  --theme-command-line-image: url(chrome://devtools/skin/images/firebug/commandline-icon.svg);\n  --theme-command-line-image-focus: url(chrome://devtools/skin/images/firebug/commandline-icon.svg#focus);\n}\n\n:root {\n  --theme-focus-border-color-textbox: #0675d3;\n  --theme-textbox-box-shadow: rgba(97,181,255,.75);\n\n  /* For accessibility purposes we want to enhance the focus styling. This\n   * should improve keyboard navigation usability. */\n  --theme-focus-outline: 1px dotted var(--theme-focus-outline-color);\n  --theme-focus-box-shadow-textbox: 0 0 0 1px var(--theme-textbox-box-shadow);\n}\n"

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const EventEmitter = __webpack_require__(6);
	const {TooltipToggle} = __webpack_require__(138);
	const {listenOnce} = __webpack_require__(139);
	const {Task} = __webpack_require__(17);

	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	const POSITION = {
	  TOP: "top",
	  BOTTOM: "bottom",
	};

	module.exports.POSITION = POSITION;

	const TYPE = {
	  NORMAL: "normal",
	  ARROW: "arrow",
	};

	module.exports.TYPE = TYPE;

	const ARROW_WIDTH = 32;

	// Default offset between the tooltip's left edge and the tooltip arrow.
	const ARROW_OFFSET = 20;

	const EXTRA_HEIGHT = {
	  "normal": 0,
	  // The arrow is 16px tall, but merges on 3px with the panel border
	  "arrow": 13,
	};

	const EXTRA_BORDER = {
	  "normal": 0,
	  "arrow": 3,
	};

	/**
	 * Calculate the vertical position & offsets to use for the tooltip. Will attempt to
	 * respect the provided height and position preferences, unless the available height
	 * prevents this.
	 *
	 * @param {DOMRect} anchorRect
	 *        Bounding rectangle for the anchor, relative to the tooltip document.
	 * @param {DOMRect} viewportRect
	 *        Bounding rectangle for the viewport. top/left can be different from 0 if some
	 *        space should not be used by tooltips (for instance OS toolbars, taskbars etc.).
	 * @param {Number} height
	 *        Preferred height for the tooltip.
	 * @param {String} pos
	 *        Preferred position for the tooltip. Possible values: "top" or "bottom".
	 * @return {Object}
	 *         - {Number} top: the top offset for the tooltip.
	 *         - {Number} height: the height to use for the tooltip container.
	 *         - {String} computedPosition: Can differ from the preferred position depending
	 *           on the available height). "top" or "bottom"
	 */
	const calculateVerticalPosition =
	function (anchorRect, viewportRect, height, pos, offset) {
	  let {TOP, BOTTOM} = POSITION;

	  let {top: anchorTop, height: anchorHeight} = anchorRect;

	  // Translate to the available viewport space before calculating dimensions and position.
	  anchorTop -= viewportRect.top;

	  // Calculate available space for the tooltip.
	  let availableTop = anchorTop;
	  let availableBottom = viewportRect.height - (anchorTop + anchorHeight);

	  // Find POSITION
	  let keepPosition = false;
	  if (pos === TOP) {
	    keepPosition = availableTop >= height + offset;
	  } else if (pos === BOTTOM) {
	    keepPosition = availableBottom >= height + offset;
	  }
	  if (!keepPosition) {
	    pos = availableTop > availableBottom ? TOP : BOTTOM;
	  }

	  // Calculate HEIGHT.
	  let availableHeight = pos === TOP ? availableTop : availableBottom;
	  height = Math.min(height, availableHeight - offset);
	  height = Math.floor(height);

	  // Calculate TOP.
	  let top = pos === TOP ? anchorTop - height - offset : anchorTop + anchorHeight + offset;

	  // Translate back to absolute coordinates by re-including viewport top margin.
	  top += viewportRect.top;

	  return {top, height, computedPosition: pos};
	};

	/**
	 * Calculate the vertical position & offsets to use for the tooltip. Will attempt to
	 * respect the provided height and position preferences, unless the available height
	 * prevents this.
	 *
	 * @param {DOMRect} anchorRect
	 *        Bounding rectangle for the anchor, relative to the tooltip document.
	 * @param {DOMRect} viewportRect
	 *        Bounding rectangle for the viewport. top/left can be different from 0 if some
	 *        space should not be used by tooltips (for instance OS toolbars, taskbars etc.).
	 * @param {Number} width
	 *        Preferred width for the tooltip.
	 * @param {String} type
	 *        The tooltip type (e.g. "arrow").
	 * @param {Number} offset
	 *        Horizontal offset in pixels.
	 * @param {Boolean} isRtl
	 *        If the anchor is in RTL, the tooltip should be aligned to the right.
	 * @return {Object}
	 *         - {Number} left: the left offset for the tooltip.
	 *         - {Number} width: the width to use for the tooltip container.
	 *         - {Number} arrowLeft: the left offset to use for the arrow element.
	 */
	const calculateHorizontalPosition =
	function (anchorRect, viewportRect, width, type, offset, isRtl) {
	  let anchorWidth = anchorRect.width;
	  let anchorStart = isRtl ? anchorRect.right : anchorRect.left;

	  // Translate to the available viewport space before calculating dimensions and position.
	  anchorStart -= viewportRect.left;

	  // Calculate WIDTH.
	  width = Math.min(width, viewportRect.width);

	  // Calculate LEFT.
	  // By default the tooltip is aligned with the anchor left edge. Unless this
	  // makes it overflow the viewport, in which case is shifts to the left.
	  let left = anchorStart + offset - (isRtl ? width : 0);
	  left = Math.min(left, viewportRect.width - width);
	  left = Math.max(0, left);

	  // Calculate ARROW LEFT (tooltip's LEFT might be updated)
	  let arrowLeft;
	  // Arrow style tooltips may need to be shifted to the left
	  if (type === TYPE.ARROW) {
	    let arrowCenter = left + ARROW_OFFSET + ARROW_WIDTH / 2;
	    let anchorCenter = anchorStart + anchorWidth / 2;
	    // If the anchor is too narrow, align the arrow and the anchor center.
	    if (arrowCenter > anchorCenter) {
	      left = Math.max(0, left - (arrowCenter - anchorCenter));
	    }
	    // Arrow's left offset relative to the anchor.
	    arrowLeft = Math.min(ARROW_OFFSET, (anchorWidth - ARROW_WIDTH) / 2) | 0;
	    // Translate the coordinate to tooltip container
	    arrowLeft += anchorStart - left;
	    // Make sure the arrow remains in the tooltip container.
	    arrowLeft = Math.min(arrowLeft, width - ARROW_WIDTH);
	    arrowLeft = Math.max(arrowLeft, 0);
	  }

	  // Translate back to absolute coordinates by re-including viewport left margin.
	  left += viewportRect.left;

	  return {left, width, arrowLeft};
	};

	/**
	 * Get the bounding client rectangle for a given node, relative to a custom
	 * reference element (instead of the default for getBoundingClientRect which
	 * is always the element's ownerDocument).
	 */
	const getRelativeRect = function (node, relativeTo) {
	  // Width and Height can be taken from the rect.
	  let {width, height} = node.getBoundingClientRect();

	  let quads = node.getBoxQuads({relativeTo});
	  let top = quads[0].bounds.top;
	  let left = quads[0].bounds.left;

	  // Compute right and bottom coordinates using the rest of the data.
	  let right = left + width;
	  let bottom = top + height;

	  return {top, right, bottom, left, width, height};
	};

	/**
	 * The HTMLTooltip can display HTML content in a tooltip popup.
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 * @param {Object}
	 *        - {String} type
	 *          Display type of the tooltip. Possible values: "normal", "arrow"
	 *        - {Boolean} autofocus
	 *          Defaults to false. Should the tooltip be focused when opening it.
	 *        - {Boolean} consumeOutsideClicks
	 *          Defaults to true. The tooltip is closed when clicking outside.
	 *          Should this event be stopped and consumed or not.
	 *        - {Boolean} useXulWrapper
	 *          Defaults to false. If the tooltip is hosted in a XUL document, use a XUL panel
	 *          in order to use all the screen viewport available.
	 *        - {String} stylesheet
	 *          Style sheet URL to apply to the tooltip content.
	 */
	function HTMLTooltip(toolbox, {
	    type = "normal",
	    autofocus = false,
	    consumeOutsideClicks = true,
	    useXulWrapper = false,
	    stylesheet = "",
	  } = {}) {
	  EventEmitter.decorate(this);

	  this.doc = toolbox.doc;
	  this.type = type;
	  this.autofocus = autofocus;
	  this.consumeOutsideClicks = consumeOutsideClicks;
	  this.useXulWrapper = this._isXUL() && useXulWrapper;

	  // The top window is used to attach click event listeners to close the tooltip if the
	  // user clicks on the content page.
	  this.topWindow = this._getTopWindow();

	  this._position = null;

	  this._onClick = this._onClick.bind(this);

	  this._toggle = new TooltipToggle(this);
	  this.startTogglingOnHover = this._toggle.start.bind(this._toggle);
	  this.stopTogglingOnHover = this._toggle.stop.bind(this._toggle);

	  this.container = this._createContainer();

	  if (stylesheet) {
	    this._applyStylesheet(stylesheet);
	  }
	  if (this.useXulWrapper) {
	    // When using a XUL panel as the wrapper, the actual markup for the tooltip is as
	    // follows :
	    // <panel> <!-- XUL panel used to position the tooltip anywhere on screen -->
	    //   <div> <!-- div wrapper used to isolate the tooltip container -->
	    //     <div> <! the actual tooltip.container element -->
	    this.xulPanelWrapper = this._createXulPanelWrapper();
	    let inner = this.doc.createElementNS(XHTML_NS, "div");
	    inner.classList.add("tooltip-xul-wrapper-inner");

	    this.doc.documentElement.appendChild(this.xulPanelWrapper);
	    this.xulPanelWrapper.appendChild(inner);
	    inner.appendChild(this.container);
	  } else if (this._isXUL()) {
	    this.doc.documentElement.appendChild(this.container);
	  } else {
	    // In non-XUL context the container is ready to use as is.
	    this.doc.body.appendChild(this.container);
	  }
	}

	module.exports.HTMLTooltip = HTMLTooltip;

	HTMLTooltip.prototype = {
	  /**
	   * The tooltip panel is the parentNode of the tooltip content provided in
	   * setContent().
	   */
	  get panel() {
	    return this.container.querySelector(".tooltip-panel");
	  },

	  /**
	   * The arrow element. Might be null depending on the tooltip type.
	   */
	  get arrow() {
	    return this.container.querySelector(".tooltip-arrow");
	  },

	  /**
	   * Retrieve the displayed position used for the tooltip. Null if the tooltip is hidden.
	   */
	  get position() {
	    return this.isVisible() ? this._position : null;
	  },

	  /**
	   * Set the tooltip content element. The preferred width/height should also be
	   * specified here.
	   *
	   * @param {Element} content
	   *        The tooltip content, should be a HTML element.
	   * @param {Object}
	   *        - {Number} width: preferred width for the tooltip container. If not specified
	   *          the tooltip container will be measured before being displayed, and the
	   *          measured width will be used as preferred width.
	   *        - {Number} height: optional, preferred height for the tooltip container. If
	   *          not specified, the tooltip will be able to use all the height available.
	   */
	  setContent: function (content, {width = "auto", height = Infinity} = {}) {
	    this.preferredWidth = width;
	    this.preferredHeight = height;

	    this.panel.innerHTML = "";
	    this.panel.appendChild(content);
	  },

	  /**
	   * Show the tooltip next to the provided anchor element. A preferred position
	   * can be set. The event "shown" will be fired after the tooltip is displayed.
	   *
	   * @param {Element} anchor
	   *        The reference element with which the tooltip should be aligned
	   * @param {Object}
	   *        - {String} position: optional, possible values: top|bottom
	   *          If layout permits, the tooltip will be displayed on top/bottom
	   *          of the anchor. If ommitted, the tooltip will be displayed where
	   *          more space is available.
	   *        - {Number} x: optional, horizontal offset between the anchor and the tooltip
	   *        - {Number} y: optional, vertical offset between the anchor and the tooltip
	   */
	  show: Task.async(function* (anchor, {position, x = 0, y = 0} = {}) {
	    // Get anchor geometry
	    let anchorRect = getRelativeRect(anchor, this.doc);
	    if (this.useXulWrapper) {
	      anchorRect = this._convertToScreenRect(anchorRect);
	    }

	    // Get viewport size
	    let viewportRect = this._getViewportRect();

	    let themeHeight = EXTRA_HEIGHT[this.type] + 2 * EXTRA_BORDER[this.type];
	    let preferredHeight = this.preferredHeight + themeHeight;

	    let {top, height, computedPosition} =
	      calculateVerticalPosition(anchorRect, viewportRect, preferredHeight, position, y);

	    this._position = computedPosition;
	    // Apply height before measuring the content width (if width="auto").
	    let isTop = computedPosition === POSITION.TOP;
	    this.container.classList.toggle("tooltip-top", isTop);
	    this.container.classList.toggle("tooltip-bottom", !isTop);

	    // If the preferred height is set to Infinity, the tooltip container should grow based
	    // on its content's height and use as much height as possible.
	    this.container.classList.toggle("tooltip-flexible-height",
	      this.preferredHeight === Infinity);

	    this.container.style.height = height + "px";

	    let preferredWidth;
	    if (this.preferredWidth === "auto") {
	      preferredWidth = this._measureContainerWidth();
	    } else {
	      let themeWidth = 2 * EXTRA_BORDER[this.type];
	      preferredWidth = this.preferredWidth + themeWidth;
	    }

	    let anchorWin = anchor.ownerDocument.defaultView;
	    let isRtl = anchorWin.getComputedStyle(anchor).direction === "rtl";
	    let {left, width, arrowLeft} = calculateHorizontalPosition(
	      anchorRect, viewportRect, preferredWidth, this.type, x, isRtl);

	    this.container.style.width = width + "px";

	    if (this.type === TYPE.ARROW) {
	      this.arrow.style.left = arrowLeft + "px";
	    }

	    if (this.useXulWrapper) {
	      yield this._showXulWrapperAt(left, top);
	    } else {
	      this.container.style.left = left + "px";
	      this.container.style.top = top + "px";
	    }

	    this.container.classList.add("tooltip-visible");

	    // Keep a pointer on the focused element to refocus it when hiding the tooltip.
	    this._focusedElement = this.doc.activeElement;

	    this.doc.defaultView.clearTimeout(this.attachEventsTimer);
	    this.attachEventsTimer = this.doc.defaultView.setTimeout(() => {
	      this._maybeFocusTooltip();
	      // Updated the top window reference each time in case the host changes.
	      this.topWindow = this._getTopWindow();
	      this.topWindow.addEventListener("click", this._onClick, true);
	      this.emit("shown");
	    }, 0);
	  }),

	  /**
	   * Calculate the rect of the viewport that limits the tooltip dimensions. When using a
	   * XUL panel wrapper, the viewport will be able to use the whole screen (excluding space
	   * reserved by the OS for toolbars etc.). Otherwise, the viewport is limited to the
	   * tooltip's document.
	   *
	   * @return {Object} DOMRect-like object with the Number properties: top, right, bottom,
	   *         left, width, height
	   */
	  _getViewportRect: function () {
	    if (this.useXulWrapper) {
	      // availLeft/Top are the coordinates first pixel available on the screen for
	      // applications (excluding space dedicated for OS toolbars, menus etc...)
	      // availWidth/Height are the dimensions available to applications excluding all
	      // the OS reserved space
	      let {availLeft, availTop, availHeight, availWidth} = this.doc.defaultView.screen;
	      return {
	        top: availTop,
	        right: availLeft + availWidth,
	        bottom: availTop + availHeight,
	        left: availLeft,
	        width: availWidth,
	        height: availHeight,
	      };
	    }

	    return this.doc.documentElement.getBoundingClientRect();
	  },

	  _measureContainerWidth: function () {
	    let xulParent = this.container.parentNode;
	    if (this.useXulWrapper && !this.isVisible()) {
	      // Move the container out of the XUL Panel to measure it.
	      this.doc.documentElement.appendChild(this.container);
	    }

	    this.container.classList.add("tooltip-hidden");
	    this.container.style.width = "auto";
	    let width = this.container.getBoundingClientRect().width;
	    this.container.classList.remove("tooltip-hidden");

	    if (this.useXulWrapper && !this.isVisible()) {
	      xulParent.appendChild(this.container);
	    }

	    return width;
	  },

	  /**
	   * Hide the current tooltip. The event "hidden" will be fired when the tooltip
	   * is hidden.
	   */
	  hide: Task.async(function* () {
	    this.doc.defaultView.clearTimeout(this.attachEventsTimer);
	    if (!this.isVisible()) {
	      this.emit("hidden");
	      return;
	    }

	    this.topWindow.removeEventListener("click", this._onClick, true);
	    this.container.classList.remove("tooltip-visible");
	    if (this.useXulWrapper) {
	      yield this._hideXulWrapper();
	    }

	    this.emit("hidden");

	    let tooltipHasFocus = this.container.contains(this.doc.activeElement);
	    if (tooltipHasFocus && this._focusedElement) {
	      this._focusedElement.focus();
	      this._focusedElement = null;
	    }
	  }),

	  /**
	   * Check if the tooltip is currently displayed.
	   * @return {Boolean} true if the tooltip is visible
	   */
	  isVisible: function () {
	    return this.container.classList.contains("tooltip-visible");
	  },

	  /**
	   * Destroy the tooltip instance. Hide the tooltip if displayed, remove the
	   * tooltip container from the document.
	   */
	  destroy: function () {
	    this.hide();
	    this.container.remove();
	    if (this.xulPanelWrapper) {
	      this.xulPanelWrapper.remove();
	    }
	  },

	  _createContainer: function () {
	    let container = this.doc.createElementNS(XHTML_NS, "div");
	    container.setAttribute("type", this.type);
	    container.classList.add("tooltip-container");

	    let html = '<div class="tooltip-filler"></div>';
	    html += '<div class="tooltip-panel"></div>';

	    if (this.type === TYPE.ARROW) {
	      html += '<div class="tooltip-arrow"></div>';
	    }
	    container.innerHTML = html;
	    return container;
	  },

	  _onClick: function (e) {
	    if (this._isInTooltipContainer(e.target)) {
	      return;
	    }

	    this.hide();
	    if (this.consumeOutsideClicks && e.button === 0) {
	      // Consume only left click events (button === 0).
	      e.preventDefault();
	      e.stopPropagation();
	    }
	  },

	  _isInTooltipContainer: function (node) {
	    // Check if the target is the tooltip arrow.
	    if (this.arrow && this.arrow === node) {
	      return true;
	    }

	    let tooltipWindow = this.panel.ownerDocument.defaultView;
	    let win = node.ownerDocument.defaultView;

	    // Check if the tooltip panel contains the node if they live in the same document.
	    if (win === tooltipWindow) {
	      return this.panel.contains(node);
	    }

	    // Check if the node window is in the tooltip container.
	    while (win.parent && win.parent !== win) {
	      if (win.parent === tooltipWindow) {
	        // If the parent window is the tooltip window, check if the tooltip contains
	        // the current frame element.
	        return this.panel.contains(win.frameElement);
	      }
	      win = win.parent;
	    }

	    return false;
	  },

	  /**
	   * If the tootlip is configured to autofocus and a focusable element can be found,
	   * focus it.
	   */
	  _maybeFocusTooltip: function () {
	    // Simplied selector targetting elements that can receive the focus, full version at
	    // http://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus .
	    let focusableSelector = "a, button, iframe, input, select, textarea";
	    let focusableElement = this.panel.querySelector(focusableSelector);
	    if (this.autofocus && focusableElement) {
	      focusableElement.focus();
	    }
	  },

	  _getTopWindow: function () {
	    return this.doc.defaultView.top;
	  },

	  /**
	   * Check if the tooltip's owner document is a XUL document.
	   */
	  _isXUL: function () {
	    return this.doc.documentElement.namespaceURI === XUL_NS;
	  },

	  _createXulPanelWrapper: function () {
	    let panel = this.doc.createElementNS(XUL_NS, "panel");

	    // XUL panel is only a way to display DOM elements outside of the document viewport,
	    // so disable all features that impact the behavior.
	    panel.setAttribute("animate", false);
	    panel.setAttribute("consumeoutsideclicks", false);
	    panel.setAttribute("noautofocus", true);
	    panel.setAttribute("ignorekeys", true);

	    // Use type="arrow" to prevent side effects (see Bug 1285206)
	    panel.setAttribute("type", "arrow");

	    panel.setAttribute("level", "top");
	    panel.setAttribute("class", "tooltip-xul-wrapper");

	    return panel;
	  },

	  _showXulWrapperAt: function (left, top) {
	    let onPanelShown = listenOnce(this.xulPanelWrapper, "popupshown");
	    this.xulPanelWrapper.openPopupAtScreen(left, top, false);
	    return onPanelShown;
	  },

	  _hideXulWrapper: function () {
	    let onPanelHidden = listenOnce(this.xulPanelWrapper, "popuphidden");
	    this.xulPanelWrapper.hidePopup();
	    return onPanelHidden;
	  },

	  /**
	   * Convert from coordinates relative to the tooltip's document, to coordinates relative
	   * to the "available" screen. By "available" we mean the screen, excluding the OS bars
	   * display on screen edges.
	   */
	  _convertToScreenRect: function ({left, top, width, height}) {
	    // mozInnerScreenX/Y are the coordinates of the top left corner of the window's
	    // viewport, excluding chrome UI.
	    left += this.doc.defaultView.mozInnerScreenX;
	    top += this.doc.defaultView.mozInnerScreenY;
	    return {top, right: left + width, bottom: top + height, left, width, height};
	  },

	  /**
	   * Apply a scoped stylesheet to the container so that this css file only
	   * applies to it.
	   */
	  _applyStylesheet: function (url) {
	    let style = this.doc.createElementNS(XHTML_NS, "style");
	    style.setAttribute("scoped", "true");
	    url = url.replace(/"/g, "\\\"");
	    style.textContent = `@import url("${url}");`;
	    this.container.appendChild(style);
	  }
	};


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {Task} = __webpack_require__(17);

	const DEFAULT_TOGGLE_DELAY = 50;

	/**
	 * Tooltip helper designed to show/hide the tooltip when the mouse hovers over
	 * particular nodes.
	 *
	 * This works by tracking mouse movements on a base container node (baseNode)
	 * and showing the tooltip when the mouse stops moving. A callback can be
	 * provided to the start() method to know whether or not the node being
	 * hovered over should indeed receive the tooltip.
	 */
	function TooltipToggle(tooltip) {
	  this.tooltip = tooltip;
	  this.win = tooltip.doc.defaultView;

	  this._onMouseMove = this._onMouseMove.bind(this);
	  this._onMouseOut = this._onMouseOut.bind(this);

	  this._onTooltipMouseOver = this._onTooltipMouseOver.bind(this);
	  this._onTooltipMouseOut = this._onTooltipMouseOut.bind(this);
	}

	module.exports.TooltipToggle = TooltipToggle;

	TooltipToggle.prototype = {
	  /**
	   * Start tracking mouse movements on the provided baseNode to show the
	   * tooltip.
	   *
	   * 2 Ways to make this work:
	   * - Provide a single node to attach the tooltip to, as the baseNode, and
	   *   omit the second targetNodeCb argument
	   * - Provide a baseNode that is the container of possibly numerous children
	   *   elements that may receive a tooltip. In this case, provide the second
	   *   targetNodeCb argument to decide wether or not a child should receive
	   *   a tooltip.
	   *
	   * Note that if you call this function a second time, it will itself call
	   * stop() before adding mouse tracking listeners again.
	   *
	   * @param {node} baseNode
	   *        The container for all target nodes
	   * @param {Function} targetNodeCb
	   *        A function that accepts a node argument and that checks if a tooltip
	   *        should be displayed. Possible return values are:
	   *        - false (or a falsy value) if the tooltip should not be displayed
	   *        - true if the tooltip should be displayed
	   *        - a DOM node to display the tooltip on the returned anchor
	   *        The function can also return a promise that will resolve to one of
	   *        the values listed above.
	   *        If omitted, the tooltip will be shown everytime.
	   * @param {Object} options
	            Set of optional arguments:
	   *        - {Number} toggleDelay
	   *          An optional delay (in ms) that will be observed before showing
	   *          and before hiding the tooltip. Defaults to DEFAULT_TOGGLE_DELAY.
	   *        - {Boolean} interactive
	   *          If enabled, the tooltip is not hidden when mouse leaves the
	   *          target element and enters the tooltip. Allows the tooltip
	   *          content to be interactive.
	   */
	  start: function (baseNode, targetNodeCb,
	                   {toggleDelay = DEFAULT_TOGGLE_DELAY, interactive = false} = {}) {
	    this.stop();

	    if (!baseNode) {
	      // Calling tool is in the process of being destroyed.
	      return;
	    }

	    this._baseNode = baseNode;
	    this._targetNodeCb = targetNodeCb || (() => true);
	    this._toggleDelay = toggleDelay;
	    this._interactive = interactive;

	    baseNode.addEventListener("mousemove", this._onMouseMove);
	    baseNode.addEventListener("mouseout", this._onMouseOut);

	    if (this._interactive) {
	      this.tooltip.container.addEventListener("mouseover", this._onTooltipMouseOver);
	      this.tooltip.container.addEventListener("mouseout", this._onTooltipMouseOut);
	    }
	  },

	  /**
	   * If the start() function has been used previously, and you want to get rid
	   * of this behavior, then call this function to remove the mouse movement
	   * tracking
	   */
	  stop: function () {
	    this.win.clearTimeout(this.toggleTimer);

	    if (!this._baseNode) {
	      return;
	    }

	    this._baseNode.removeEventListener("mousemove", this._onMouseMove);
	    this._baseNode.removeEventListener("mouseout", this._onMouseOut);

	    if (this._interactive) {
	      this.tooltip.container.removeEventListener("mouseover", this._onTooltipMouseOver);
	      this.tooltip.container.removeEventListener("mouseout", this._onTooltipMouseOut);
	    }

	    this._baseNode = null;
	    this._targetNodeCb = null;
	    this._lastHovered = null;
	  },

	  _onMouseMove: function (event) {
	    if (event.target !== this._lastHovered) {
	      this._lastHovered = event.target;

	      this.win.clearTimeout(this.toggleTimer);
	      this.toggleTimer = this.win.setTimeout(() => {
	        this.tooltip.hide();
	        this.isValidHoverTarget(event.target).then(target => {
	          if (target === null) {
	            return;
	          }
	          this.tooltip.show(target);
	        }, reason => {
	          console.error("isValidHoverTarget rejected with unexpected reason:");
	          console.error(reason);
	        });
	      }, this._toggleDelay);
	    }
	  },

	  /**
	   * Is the given target DOMNode a valid node for toggling the tooltip on hover.
	   * This delegates to the user-defined _targetNodeCb callback.
	   * @return {Promise} a promise that will resolve the anchor to use for the
	   *         tooltip or null if no valid target was found.
	   */
	  isValidHoverTarget: Task.async(function* (target) {
	    let res = yield this._targetNodeCb(target, this.tooltip);
	    if (res) {
	      return res.nodeName ? res : target;
	    }

	    return null;
	  }),

	  _onMouseOut: function (event) {
	    // Only hide the tooltip if the mouse leaves baseNode.
	    if (event && this._baseNode && !this._baseNode.contains(event.relatedTarget)) {
	      return;
	    }

	    this._lastHovered = null;
	    this.win.clearTimeout(this.toggleTimer);
	    this.toggleTimer = this.win.setTimeout(() => {
	      this.tooltip.hide();
	    }, this._toggleDelay);
	  },

	  _onTooltipMouseOver() {
	    this.win.clearTimeout(this.toggleTimer);
	  },

	  _onTooltipMouseOut() {
	    this.win.clearTimeout(this.toggleTimer);
	    this.toggleTimer = this.win.setTimeout(() => {
	      this.tooltip.hide();
	    }, this._toggleDelay);
	  },

	  destroy: function () {
	    this.stop();
	  }
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Helpers for async functions. Async functions are generator functions that are
	 * run by Tasks. An async function returns a Promise for the resolution of the
	 * function. When the function returns, the promise is resolved with the
	 * returned value. If it throws the promise rejects with the thrown error.
	 *
	 * See Task documentation at https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Task.jsm.
	 */

	var {Task} = __webpack_require__(17);
	var Promise = __webpack_require__(4);

	/**
	 * Create an async function that only executes once per instance of an object.
	 * Once called on a given object, the same promise will be returned for any
	 * future calls for that object.
	 *
	 * @param Function func
	 *        The generator function that to wrap as an async function.
	 * @return Function
	 *         The async function.
	 */
	exports.asyncOnce = function asyncOnce(func) {
	  const promises = new WeakMap();
	  return function (...args) {
	    let promise = promises.get(this);
	    if (!promise) {
	      promise = Task.spawn(func.apply(this, args));
	      promises.set(this, promise);
	    }
	    return promise;
	  };
	};

	/**
	 * Adds an event listener to the given element, and then removes its event
	 * listener once the event is called, returning the event object as a promise.
	 * @param  nsIDOMElement element
	 *         The DOM element to listen on
	 * @param  String event
	 *         The name of the event type to listen for
	 * @param  Boolean useCapture
	 *         Should we initiate the capture phase?
	 * @return Promise
	 *         The promise resolved with the event object when the event first
	 *         happens
	 */
	exports.listenOnce = function listenOnce(element, event, useCapture) {
	  return new Promise(function (resolve, reject) {
	    let onEvent = function (ev) {
	      element.removeEventListener(event, onEvent, useCapture);
	      resolve(ev);
	    };
	    element.addEventListener(event, onEvent, useCapture);
	  });
	};

	/**
	 * Call a function that expects a callback as the last argument and returns a
	 * promise for the result. This simplifies using callback APIs from tasks and
	 * async functions.
	 *
	 * @param Any obj
	 *        The |this| value to call the function on.
	 * @param Function func
	 *        The callback-expecting function to call.
	 * @param Array args
	 *        Additional arguments to pass to the method.
	 * @return Promise
	 *         The promise for the result. If the callback is called with only one
	 *         argument, it is used as the resolution value. If there's multiple
	 *         arguments, an array containing the arguments is the resolution value.
	 *         If the method throws, the promise is rejected with the thrown value.
	 */
	function promisify(obj, func, args) {
	  return new Promise(resolve => {
	    args.push((...results) => {
	      resolve(results.length > 1 ? results : results[0]);
	    });
	    func.apply(obj, args);
	  });
	}

	/**
	 * Call a method that expects a callback as the last argument and returns a
	 * promise for the result.
	 *
	 * @see promisify
	 */
	exports.promiseInvoke = function promiseInvoke(obj, func, ...args) {
	  return promisify(obj, func, args);
	};

	/**
	 * Call a function that expects a callback as the last argument.
	 *
	 * @see promisify
	 */
	exports.promiseCall = function promiseCall(func, ...args) {
	  return promisify(undefined, func, args);
	};


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {LocalizationHelper} = __webpack_require__(39);
	const L10N = new LocalizationHelper("devtools/locale/inspector.properties");

	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	// Default image tooltip max dimension
	const MAX_DIMENSION = 200;
	const CONTAINER_MIN_WIDTH = 100;
	const LABEL_HEIGHT = 20;
	const IMAGE_PADDING = 4;

	/**
	 * Image preview tooltips should be provided with the naturalHeight and
	 * naturalWidth value for the image to display. This helper loads the provided
	 * image URL in an image object in order to retrieve the image dimensions after
	 * the load.
	 *
	 * @param {Document} doc the document element to use to create the image object
	 * @param {String} imageUrl the url of the image to measure
	 * @return {Promise} returns a promise that will resolve after the iamge load:
	 *         - {Number} naturalWidth natural width of the loaded image
	 *         - {Number} naturalHeight natural height of the loaded image
	 */
	function getImageDimensions(doc, imageUrl) {
	  return new Promise(resolve => {
	    let imgObj = new doc.defaultView.Image();
	    imgObj.onload = () => {
	      imgObj.onload = null;
	      let { naturalWidth, naturalHeight } = imgObj;
	      resolve({ naturalWidth, naturalHeight });
	    };
	    imgObj.src = imageUrl;
	  });
	}

	/**
	 * Set the tooltip content of a provided HTMLTooltip instance to display an
	 * image preview matching the provided imageUrl.
	 *
	 * @param {HTMLTooltip} tooltip
	 *        The tooltip instance on which the image preview content should be set
	 * @param {Document} doc
	 *        A document element to create the HTML elements needed for the tooltip
	 * @param {String} imageUrl
	 *        Absolute URL of the image to display in the tooltip
	 * @param {Object} options
	 *        - {Number} naturalWidth mandatory, width of the image to display
	 *        - {Number} naturalHeight mandatory, height of the image to display
	 *        - {Number} maxDim optional, max width/height of the preview
	 *        - {Boolean} hideDimensionLabel optional, pass true to hide the label
	 */
	function setImageTooltip(tooltip, doc, imageUrl, options) {
	  let {naturalWidth, naturalHeight, hideDimensionLabel, maxDim} = options;
	  maxDim = maxDim || MAX_DIMENSION;

	  let imgHeight = naturalHeight;
	  let imgWidth = naturalWidth;
	  if (imgHeight > maxDim || imgWidth > maxDim) {
	    let scale = maxDim / Math.max(imgHeight, imgWidth);
	    // Only allow integer values to avoid rounding errors.
	    imgHeight = Math.floor(scale * naturalHeight);
	    imgWidth = Math.ceil(scale * naturalWidth);
	  }

	  // Create tooltip content
	  let div = doc.createElementNS(XHTML_NS, "div");
	  div.style.cssText = `
	    height: 100%;
	    min-width: 100px;
	    display: flex;
	    flex-direction: column;
	    text-align: center;`;
	  let html = `
	    <div style="flex: 1;
	                display: flex;
	                padding: ${IMAGE_PADDING}px;
	                align-items: center;
	                justify-content: center;
	                min-height: 1px;">
	      <img style="height: ${imgHeight}px; max-height: 100%;" src="${imageUrl}"/>
	    </div>`;

	  if (!hideDimensionLabel) {
	    let label = naturalWidth + " \u00D7 " + naturalHeight;
	    html += `
	      <div style="height: ${LABEL_HEIGHT}px;
	                  text-align: center;">
	        <span class="theme-comment devtools-tooltip-caption">${label}</span>
	      </div>`;
	  }
	  div.innerHTML = html;

	  // Calculate tooltip dimensions
	  let height = imgHeight + 2 * IMAGE_PADDING;
	  if (!hideDimensionLabel) {
	    height += LABEL_HEIGHT;
	  }
	  let width = Math.max(CONTAINER_MIN_WIDTH, imgWidth + 2 * IMAGE_PADDING);

	  tooltip.setContent(div, {width, height});
	}

	/*
	 * Set the tooltip content of a provided HTMLTooltip instance to display a
	 * fallback error message when an image preview tooltip can not be displayed.
	 *
	 * @param {HTMLTooltip} tooltip
	 *        The tooltip instance on which the image preview content should be set
	 * @param {Document} doc
	 *        A document element to create the HTML elements needed for the tooltip
	 */
	function setBrokenImageTooltip(tooltip, doc) {
	  let div = doc.createElementNS(XHTML_NS, "div");
	  div.style.cssText = `
	    box-sizing: border-box;
	    height: 100%;
	    text-align: center;
	    line-height: 30px;`;

	  let message = L10N.getStr("previewTooltip.image.brokenImage");
	  div.textContent = message;
	  tooltip.setContent(div, {width: 150, height: 30});
	}

	module.exports.getImageDimensions = getImageDimensions;
	module.exports.setImageTooltip = setImageTooltip;
	module.exports.setBrokenImageTooltip = setBrokenImageTooltip;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {HTMLTooltip} = __webpack_require__(137);
	const {MdnDocsWidget} = __webpack_require__(142);
	const {KeyShortcuts} = __webpack_require__(15);
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	const TOOLTIP_WIDTH = 418;
	const TOOLTIP_HEIGHT = 308;

	/**
	 * Tooltip for displaying docs for CSS properties from MDN.
	 *
	 * @param {Toolbox} toolbox
	 *        Toolbox used to create the tooltip.
	 */
	function CssDocsTooltip(toolbox) {
	  this.tooltip = new HTMLTooltip(toolbox, {
	    type: "arrow",
	    consumeOutsideClicks: true,
	    autofocus: true,
	    useXulWrapper: true,
	    stylesheet: "chrome://devtools/content/shared/widgets/mdn-docs.css",
	  });
	  this.widget = this.setMdnDocsContent();
	  this._onVisitLink = this._onVisitLink.bind(this);
	  this.widget.on("visitlink", this._onVisitLink);

	  // Initialize keyboard shortcuts
	  this.shortcuts = new KeyShortcuts({ window: toolbox.win });
	  this._onShortcut = this._onShortcut.bind(this);

	  this.shortcuts.on("Escape", this._onShortcut);
	}

	module.exports.CssDocsTooltip = CssDocsTooltip;

	CssDocsTooltip.prototype = {
	  /**
	   * Load CSS docs for the given property,
	   * then display the tooltip.
	   */
	  show: function (anchor, propertyName) {
	    this.tooltip.once("shown", () => {
	      this.widget.loadCssDocs(propertyName);
	    });
	    this.tooltip.show(anchor);
	  },

	  hide: function () {
	    this.tooltip.hide();
	  },

	  _onShortcut: function (shortcut, event) {
	    if (!this.tooltip.isVisible()) {
	      return;
	    }
	    event.stopPropagation();
	    event.preventDefault();
	    this.hide();
	  },

	  _onVisitLink: function () {
	    this.hide();
	  },

	  /**
	   * Set the content of this tooltip to the MDN docs widget. This is called when the
	   * tooltip is first constructed.
	   * The caller can use the MdnDocsWidget to update the tooltip's  UI with new content
	   * each time the tooltip is shown.
	   *
	   * @return {MdnDocsWidget} the created MdnDocsWidget instance.
	   */
	  setMdnDocsContent: function () {
	    let container = this.tooltip.doc.createElementNS(XHTML_NS, "div");
	    container.setAttribute("class", "mdn-container theme-body");
	    this.tooltip.setContent(container, {width: TOOLTIP_WIDTH, height: TOOLTIP_HEIGHT});
	    return new MdnDocsWidget(container);
	  },

	  destroy: function () {
	    this.widget.off("visitlink", this._onVisitLink);
	    this.widget.destroy();

	    this.shortcuts.destroy();
	    this.tooltip.destroy();
	  }
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * This file contains functions to retrieve docs content from
	 * MDN (developer.mozilla.org) for particular items, and to display
	 * the content in a tooltip.
	 *
	 * At the moment it only supports fetching content for CSS properties,
	 * but it might support other types of content in the future
	 * (Web APIs, for example).
	 *
	 * It's split into two parts:
	 *
	 * - functions like getCssDocs that just fetch content from MDN,
	 * without any constraints on what to do with the content. If you
	 * want to embed the content in some custom way, use this.
	 *
	 * - the MdnDocsWidget class, that manages and updates a tooltip
	 * document whose content is taken from MDN. If you want to embed
	 * the content in a tooltip, use this in conjunction with Tooltip.js.
	 */

	"use strict";

	const Services = __webpack_require__(1);
	const defer = __webpack_require__(5);
	const {getCSSLexer} = __webpack_require__(123);
	const EventEmitter = __webpack_require__(6);
	const {gDevTools} = __webpack_require__(133);

	const {LocalizationHelper} = __webpack_require__(39);
	const L10N = new LocalizationHelper("devtools/locale/inspector.properties");

	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	// Parameters for the XHR request
	// see https://developer.mozilla.org/en-US/docs/MDN/Kuma/API#Document_parameters
	const XHR_PARAMS = "?raw&macros";
	// URL for the XHR request
	var XHR_CSS_URL = "https://developer.mozilla.org/en-US/docs/Web/CSS/";

	// Parameters for the link to MDN in the tooltip, so
	// so we know which MDN visits come from this feature
	const PAGE_LINK_PARAMS =
	  "?utm_source=mozilla&utm_medium=firefox-inspector&utm_campaign=default";
	// URL for the page link omits locale, so a locale-specific page will be loaded
	var PAGE_LINK_URL = "https://developer.mozilla.org/docs/Web/CSS/";
	exports.PAGE_LINK_URL = PAGE_LINK_URL;

	const PROPERTY_NAME_COLOR = "theme-fg-color5";
	const PROPERTY_VALUE_COLOR = "theme-fg-color1";
	const COMMENT_COLOR = "theme-comment";

	/**
	 * Turns a string containing a series of CSS declarations into
	 * a series of DOM nodes, with classes applied to provide syntax
	 * highlighting.
	 *
	 * It uses the CSS tokenizer to generate a stream of CSS tokens.
	 * https://dxr.mozilla.org/mozilla-central/source/dom/webidl/CSSLexer.webidl
	 * lists all the token types.
	 *
	 * - "whitespace", "comment", and "symbol" tokens are appended as TEXT nodes,
	 * and will inherit the default style for text.
	 *
	 * - "ident" tokens that we think are property names are considered to be
	 * a property name, and are appended as SPAN nodes with a distinct color class.
	 *
	 * - "ident" nodes which we do not think are property names, and nodes
	 * of all other types ("number", "url", "percentage", ...) are considered
	 * to be part of a property value, and are appended as SPAN nodes with
	 * a different color class.
	 *
	 * @param {Document} doc
	 * Used to create nodes.
	 *
	 * @param {String} syntaxText
	 * The CSS input. This is assumed to consist of a series of
	 * CSS declarations, with trailing semicolons.
	 *
	 * @param {DOM node} syntaxSection
	 * This is the parent for the output nodes. Generated nodes
	 * are appended to this as children.
	 */
	function appendSyntaxHighlightedCSS(cssText, parentElement) {
	  let doc = parentElement.ownerDocument;
	  let identClass = PROPERTY_NAME_COLOR;
	  let lexer = getCSSLexer(cssText);

	  /**
	   * Create a SPAN node with the given text content and class.
	   */
	  function createStyledNode(textContent, className) {
	    let newNode = doc.createElementNS(XHTML_NS, "span");
	    newNode.classList.add(className);
	    newNode.textContent = textContent;
	    return newNode;
	  }

	  /**
	   * If the symbol is ":", we will expect the next
	   * "ident" token to be part of a property value.
	   *
	   * If the symbol is ";", we will expect the next
	   * "ident" token to be a property name.
	   */
	  function updateIdentClass(tokenText) {
	    if (tokenText === ":") {
	      identClass = PROPERTY_VALUE_COLOR;
	    } else if (tokenText === ";") {
	      identClass = PROPERTY_NAME_COLOR;
	    }
	  }

	  /**
	   * Create the appropriate node for this token type.
	   *
	   * If this token is a symbol, also update our expectations
	   * for what the next "ident" token represents.
	   */
	  function tokenToNode(token, tokenText) {
	    switch (token.tokenType) {
	      case "ident":
	        return createStyledNode(tokenText, identClass);
	      case "symbol":
	        updateIdentClass(tokenText);
	        return doc.createTextNode(tokenText);
	      case "whitespace":
	        return doc.createTextNode(tokenText);
	      case "comment":
	        return createStyledNode(tokenText, COMMENT_COLOR);
	      default:
	        return createStyledNode(tokenText, PROPERTY_VALUE_COLOR);
	    }
	  }

	  let token = lexer.nextToken();
	  while (token) {
	    let tokenText = cssText.slice(token.startOffset, token.endOffset);
	    let newNode = tokenToNode(token, tokenText);
	    parentElement.appendChild(newNode);
	    token = lexer.nextToken();
	  }
	}

	exports.appendSyntaxHighlightedCSS = appendSyntaxHighlightedCSS;

	/**
	 * Fetch an MDN page.
	 *
	 * @param {string} pageUrl
	 * URL of the page to fetch.
	 *
	 * @return {promise}
	 * The promise is resolved with the page as an XML document.
	 *
	 * The promise is rejected with an error message if
	 * we could not load the page.
	 */
	function getMdnPage(pageUrl) {
	  let deferred = defer();

	  let xhr = new XMLHttpRequest();

	  xhr.addEventListener("load", onLoaded, false);
	  xhr.addEventListener("error", onError, false);

	  xhr.open("GET", pageUrl);
	  xhr.responseType = "document";
	  xhr.send();

	  function onLoaded(e) {
	    if (xhr.status != 200) {
	      deferred.reject({page: pageUrl, status: xhr.status});
	    } else {
	      deferred.resolve(xhr.responseXML);
	    }
	  }

	  function onError(e) {
	    deferred.reject({page: pageUrl, status: xhr.status});
	  }

	  return deferred.promise;
	}

	/**
	 * Gets some docs for the given CSS property.
	 * Loads an MDN page for the property and gets some
	 * information about the property.
	 *
	 * @param {string} cssProperty
	 * The property for which we want docs.
	 *
	 * @return {promise}
	 * The promise is resolved with an object containing:
	 * - summary: a short summary of the property
	 * - syntax: some example syntax
	 *
	 * The promise is rejected with an error message if
	 * we could not load the page.
	 */
	function getCssDocs(cssProperty) {
	  let deferred = defer();
	  let pageUrl = XHR_CSS_URL + cssProperty + XHR_PARAMS;

	  getMdnPage(pageUrl).then(parseDocsFromResponse, handleRejection);

	  function parseDocsFromResponse(responseDocument) {
	    let theDocs = {};
	    theDocs.summary = getSummary(responseDocument);
	    theDocs.syntax = getSyntax(responseDocument);
	    if (theDocs.summary || theDocs.syntax) {
	      deferred.resolve(theDocs);
	    } else {
	      deferred.reject("Couldn't find the docs in the page.");
	    }
	  }

	  function handleRejection(e) {
	    deferred.reject(e.status);
	  }

	  return deferred.promise;
	}

	exports.getCssDocs = getCssDocs;

	/**
	 * The MdnDocsWidget is used by tooltip code that needs to display docs
	 * from MDN in a tooltip.
	 *
	 * In the constructor, the widget does some general setup that's not
	 * dependent on the particular item we need docs for.
	 *
	 * After that, when the tooltip code needs to display docs for an item, it
	 * asks the widget to retrieve the docs and update the document with them.
	 *
	 * @param {Element} tooltipContainer
	 * A DOM element where the MdnDocs widget markup should be created.
	 */
	function MdnDocsWidget(tooltipContainer) {
	  EventEmitter.decorate(this);

	  tooltipContainer.innerHTML =
	    `<header>
	       <h1 class="mdn-property-name theme-fg-color5"></h1>
	     </header>
	     <div class="mdn-property-info">
	       <div class="mdn-summary"></div>
	       <pre class="mdn-syntax devtools-monospace"></pre>
	     </div>
	     <footer>
	       <a class="mdn-visit-page theme-link" href="#">Visit MDN (placeholder)</a>
	     </footer>`;

	  // fetch all the bits of the document that we will manipulate later
	  this.elements = {
	    heading: tooltipContainer.querySelector(".mdn-property-name"),
	    summary: tooltipContainer.querySelector(".mdn-summary"),
	    syntax: tooltipContainer.querySelector(".mdn-syntax"),
	    info: tooltipContainer.querySelector(".mdn-property-info"),
	    linkToMdn: tooltipContainer.querySelector(".mdn-visit-page")
	  };

	  // get the localized string for the link text
	  this.elements.linkToMdn.textContent = L10N.getStr("docsTooltip.visitMDN");

	  // listen for clicks and open in the browser window instead
	  let mainWindow = Services.wm.getMostRecentWindow(gDevTools.chromeWindowType);
	  this.elements.linkToMdn.addEventListener("click", (e) => {
	    e.stopPropagation();
	    e.preventDefault();
	    mainWindow.openUILinkIn(e.target.href, "tab");
	    this.emit("visitlink");
	  });
	}

	exports.MdnDocsWidget = MdnDocsWidget;

	MdnDocsWidget.prototype = {
	  /**
	   * This is called just before the tooltip is displayed, and is
	   * passed the CSS property for which we want to display help.
	   *
	   * Its job is to make sure the document contains the docs
	   * content for that CSS property.
	   *
	   * First, it initializes the document, setting the things it can
	   * set synchronously, resetting the things it needs to get
	   * asynchronously, and making sure the throbber is throbbing.
	   *
	   * Then it tries to get the content asynchronously, updating
	   * the document with the content or with an error message.
	   *
	   * It returns immediately, so the caller can display the tooltip
	   * without waiting for the asynch operation to complete.
	   *
	   * @param {string} propertyName
	   * The name of the CSS property for which we need to display help.
	   */
	  loadCssDocs: function (propertyName) {
	    /**
	     * Do all the setup we can do synchronously, and get the document in
	     * a state where it can be displayed while we are waiting for the
	     * MDN docs content to be retrieved.
	     */
	    function initializeDocument(propName) {
	      // set property name heading
	      elements.heading.textContent = propName;

	      // set link target
	      elements.linkToMdn.setAttribute("href",
	        PAGE_LINK_URL + propName + PAGE_LINK_PARAMS);

	      // clear docs summary and syntax
	      elements.summary.textContent = "";
	      while (elements.syntax.firstChild) {
	        elements.syntax.firstChild.remove();
	      }

	      // reset the scroll position
	      elements.info.scrollTop = 0;
	      elements.info.scrollLeft = 0;

	      // show the throbber
	      elements.info.classList.add("devtools-throbber");
	    }

	    /**
	     * This is called if we successfully got the docs content.
	     * Finishes setting up the tooltip content, and disables the throbber.
	     */
	    function finalizeDocument({summary, syntax}) {
	      // set docs summary and syntax
	      elements.summary.textContent = summary;
	      appendSyntaxHighlightedCSS(syntax, elements.syntax);

	      // hide the throbber
	      elements.info.classList.remove("devtools-throbber");

	      deferred.resolve(this);
	    }

	    /**
	     * This is called if we failed to get the docs content.
	     * Sets the content to contain an error message, and disables the throbber.
	     */
	    function gotError(error) {
	      // show error message
	      elements.summary.textContent = L10N.getStr("docsTooltip.loadDocsError");

	      // hide the throbber
	      elements.info.classList.remove("devtools-throbber");

	      // although gotError is called when there's an error, we have handled
	      // the error, so call resolve not reject.
	      deferred.resolve(this);
	    }

	    let deferred = defer();
	    let elements = this.elements;

	    initializeDocument(propertyName);
	    getCssDocs(propertyName).then(finalizeDocument, gotError);

	    return deferred.promise;
	  },

	  destroy: function () {
	    this.elements = null;
	  }
	};

	/**
	 * Test whether a node is all whitespace.
	 *
	 * @return {boolean}
	 * True if the node all whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
	  return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Test whether a node is a comment or whitespace node.
	 *
	 * @return {boolean}
	 * True if the node is a comment node or is all whitespace, otherwise false.
	 */
	function isIgnorable(node) {
	  // Comment nodes (8), text nodes (3) or whitespace
	  return (node.nodeType == 8) ||
	         ((node.nodeType == 3) && isAllWhitespace(node));
	}

	/**
	 * Get the next node, skipping comments and whitespace.
	 *
	 * @return {node}
	 * The next sibling node that is not a comment or whitespace, or null if
	 * there isn't one.
	 */
	function nodeAfter(sib) {
	  while ((sib = sib.nextSibling)) {
	    if (!isIgnorable(sib)) {
	      return sib;
	    }
	  }
	  return null;
	}

	/**
	 * Test whether the argument `node` is a node whose tag is `tagName`.
	 *
	 * @param {node} node
	 * The code to test. May be null.
	 *
	 * @param {string} tagName
	 * The tag name to test against.
	 *
	 * @return {boolean}
	 * True if the node is not null and has the tag name `tagName`,
	 * otherwise false.
	 */
	function hasTagName(node, tagName) {
	  return node && node.tagName &&
	         node.tagName.toLowerCase() == tagName.toLowerCase();
	}

	/**
	 * Given an MDN page, get the "summary" portion.
	 *
	 * This is the textContent of the first non-whitespace
	 * element in the #Summary section of the document.
	 *
	 * It's expected to be a <P> element.
	 *
	 * @param {Document} mdnDocument
	 * The document in which to look for the "summary" section.
	 *
	 * @return {string}
	 * The summary section as a string, or null if it could not be found.
	 */
	function getSummary(mdnDocument) {
	  let summary = mdnDocument.getElementById("Summary");
	  if (!hasTagName(summary, "H2")) {
	    return null;
	  }

	  let firstParagraph = nodeAfter(summary);
	  if (!hasTagName(firstParagraph, "P")) {
	    return null;
	  }

	  return firstParagraph.textContent;
	}

	/**
	 * Given an MDN page, get the "syntax" portion.
	 *
	 * First we get the #Syntax section of the document. The syntax
	 * section we want is somewhere inside there.
	 *
	 * If the page is in the old structure, then the *first two*
	 * non-whitespace elements in the #Syntax section will be <PRE>
	 * nodes, and the second of these will be the syntax section.
	 *
	 * If the page is in the new structure, then the only the *first*
	 * non-whitespace element in the #Syntax section will be a <PRE>
	 * node, and it will be the syntax section.
	 *
	 * @param {Document} mdnDocument
	 * The document in which to look for the "syntax" section.
	 *
	 * @return {string}
	 * The syntax section as a string, or null if it could not be found.
	 */
	function getSyntax(mdnDocument) {
	  let syntax = mdnDocument.getElementById("Syntax");
	  if (!hasTagName(syntax, "H2")) {
	    return null;
	  }

	  let firstParagraph = nodeAfter(syntax);
	  if (!hasTagName(firstParagraph, "PRE")) {
	    return null;
	  }

	  let secondParagraph = nodeAfter(firstParagraph);
	  if (hasTagName(secondParagraph, "PRE")) {
	    return secondParagraph.textContent;
	  }
	  return firstParagraph.textContent;
	}

	/**
	 * Use a different URL for CSS docs pages. Used only for testing.
	 *
	 * @param {string} baseUrl
	 * The baseURL to use.
	 */
	function setBaseCssDocsUrl(baseUrl) {
	  PAGE_LINK_URL = baseUrl;
	  XHR_CSS_URL = baseUrl;
	}

	exports.setBaseCssDocsUrl = setBaseCssDocsUrl;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const defer = __webpack_require__(5);
	const {Spectrum} = __webpack_require__(144);
	const {CubicBezierWidget} =
	      __webpack_require__(145);
	const {CSSFilterEditorWidget} = __webpack_require__(147);
	const {TooltipToggle} = __webpack_require__(138);
	const EventEmitter = __webpack_require__(6);
	const {colorUtils} = __webpack_require__(129);
	const Heritage = __webpack_require__(20);
	const {HTMLTooltip} = __webpack_require__(137);
	const {KeyShortcuts} = __webpack_require__(15);
	const {Task} = __webpack_require__(17);
	const {KeyCodes} = __webpack_require__(16);

	const XHTML_NS = "http://www.w3.org/1999/xhtml";
	const ESCAPE_KEYCODE = KeyCodes.DOM_VK_ESCAPE;
	const POPUP_EVENTS = ["shown", "hidden", "showing", "hiding"];

	/**
	 * Tooltip widget.
	 *
	 * This widget is intended at any tool that may need to show rich content in the
	 * form of floating panels.
	 * A common use case is image previewing in the CSS rule view, but more complex
	 * use cases may include color pickers, object inspection, etc...
	 *
	 * Tooltips are based on XUL (namely XUL arrow-type <panel>s), and therefore
	 * need a XUL Document to live in.
	 * This is pretty much the only requirement they have on their environment.
	 *
	 * The way to use a tooltip is simply by instantiating a tooltip yourself and
	 * attaching some content in it, or using one of the ready-made content types.
	 *
	 * A convenient `startTogglingOnHover` method may avoid having to register event
	 * handlers yourself if the tooltip has to be shown when hovering over a
	 * specific element or group of elements (which is usually the most common case)
	 */

	/**
	 * Container used for dealing with optional parameters.
	 *
	 * @param {Object} defaults
	 *        An object with all default options {p1: v1, p2: v2, ...}
	 * @param {Object} options
	 *        The actual values.
	 */
	function OptionsStore(defaults, options) {
	  this.defaults = defaults || {};
	  this.options = options || {};
	}

	OptionsStore.prototype = {
	  /**
	   * Get the value for a given option name.
	   * @return {Object} Returns the value for that option, coming either for the
	   *         actual values that have been set in the constructor, or from the
	   *         defaults if that options was not specified.
	   */
	  get: function (name) {
	    if (typeof this.options[name] !== "undefined") {
	      return this.options[name];
	    }
	    return this.defaults[name];
	  }
	};

	/**
	 * The low level structure of a tooltip is a XUL element (a <panel>).
	 */
	var PanelFactory = {
	  /**
	   * Get a new XUL panel instance.
	   * @param {XULDocument} doc
	   *        The XUL document to put that panel into
	   * @param {OptionsStore} options
	   *        An options store to get some configuration from
	   */
	  get: function (doc, options) {
	    // Create the tooltip
	    let panel = doc.createElement("panel");
	    panel.setAttribute("hidden", true);
	    panel.setAttribute("ignorekeys", true);
	    panel.setAttribute("animate", false);

	    panel.setAttribute("consumeoutsideclicks",
	                       options.get("consumeOutsideClick"));
	    panel.setAttribute("noautofocus", options.get("noAutoFocus"));
	    panel.setAttribute("type", "arrow");
	    panel.setAttribute("level", "top");

	    panel.setAttribute("class", "devtools-tooltip theme-tooltip-panel");
	    doc.querySelector("window").appendChild(panel);

	    return panel;
	  }
	};

	/**
	 * Tooltip class.
	 *
	 * Basic usage:
	 *   let t = new Tooltip(xulDoc);
	 *   t.content = someXulContent;
	 *   t.show();
	 *   t.hide();
	 *   t.destroy();
	 *
	 * Better usage:
	 *   let t = new Tooltip(xulDoc);
	 *   t.startTogglingOnHover(container, target => {
	 *     if (<condition based on target>) {
	 *       t.content = el;
	 *       return true;
	 *     }
	 *   });
	 *   t.destroy();
	 *
	 * @param {XULDocument} doc
	 *        The XUL document hosting this tooltip
	 * @param {Object} options
	 *        Optional options that give options to consumers:
	 *        - consumeOutsideClick {Boolean} Wether the first click outside of the
	 *        tooltip should close the tooltip and be consumed or not.
	 *        Defaults to false.
	 *        - closeOnKeys {Array} An array of key codes that should close the
	 *        tooltip. Defaults to [27] (escape key).
	 *        - closeOnEvents [{emitter: {Object}, event: {String},
	 *                          useCapture: {Boolean}}]
	 *        Provide an optional list of emitter objects and event names here to
	 *        trigger the closing of the tooltip when these events are fired by the
	 *        emitters. The emitter objects should either implement
	 *        on/off(event, cb) or addEventListener/removeEventListener(event, cb).
	 *        Defaults to [].
	 *        For instance, the following would close the tooltip whenever the
	 *        toolbox selects a new tool and when a DOM node gets scrolled:
	 *        new Tooltip(doc, {
	 *          closeOnEvents: [
	 *            {emitter: toolbox, event: "select"},
	 *            {emitter: myContainer, event: "scroll", useCapture: true}
	 *          ]
	 *        });
	 *        - noAutoFocus {Boolean} Should the focus automatically go to the panel
	 *        when it opens. Defaults to true.
	 *
	 * Fires these events:
	 * - showing : just before the tooltip shows
	 * - shown : when the tooltip is shown
	 * - hiding : just before the tooltip closes
	 * - hidden : when the tooltip gets hidden
	 * - keypress : when any key gets pressed, with keyCode
	 */
	function Tooltip(doc, options) {
	  EventEmitter.decorate(this);

	  this.doc = doc;
	  this.options = new OptionsStore({
	    consumeOutsideClick: false,
	    closeOnKeys: [ESCAPE_KEYCODE],
	    noAutoFocus: true,
	    closeOnEvents: []
	  }, options);
	  this.panel = PanelFactory.get(doc, this.options);

	  // Create tooltip toggle helper and decorate the Tooltip instance with
	  // shortcut methods.
	  this._toggle = new TooltipToggle(this);
	  this.startTogglingOnHover = this._toggle.start.bind(this._toggle);
	  this.stopTogglingOnHover = this._toggle.stop.bind(this._toggle);

	  // Emit show/hide events when the panel does.
	  for (let eventName of POPUP_EVENTS) {
	    this["_onPopup" + eventName] = (name => {
	      return e => {
	        if (e.target === this.panel) {
	          this.emit(name);
	        }
	      };
	    })(eventName);
	    this.panel.addEventListener("popup" + eventName,
	      this["_onPopup" + eventName], false);
	  }

	  // Listen to keypress events to close the tooltip if configured to do so
	  let win = this.doc.querySelector("window");
	  this._onKeyPress = event => {
	    if (this.panel.hidden) {
	      return;
	    }

	    this.emit("keypress", event.keyCode);
	    if (this.options.get("closeOnKeys").indexOf(event.keyCode) !== -1 &&
	        this.isShown()) {
	      event.stopPropagation();
	      this.hide();
	    }
	  };
	  win.addEventListener("keypress", this._onKeyPress, false);

	  // Listen to custom emitters' events to close the tooltip
	  this.hide = this.hide.bind(this);
	  let closeOnEvents = this.options.get("closeOnEvents");
	  for (let {emitter, event, useCapture} of closeOnEvents) {
	    for (let add of ["addEventListener", "on"]) {
	      if (add in emitter) {
	        emitter[add](event, this.hide, useCapture);
	        break;
	      }
	    }
	  }
	}

	module.exports.Tooltip = Tooltip;

	Tooltip.prototype = {
	  defaultPosition: "before_start",
	  // px
	  defaultOffsetX: 0,
	  // px
	  defaultOffsetY: 0,
	  // px

	  /**
	   * Show the tooltip. It might be wise to append some content first if you
	   * don't want the tooltip to be empty. You may access the content of the
	   * tooltip by setting a XUL node to t.content.
	   * @param {node} anchor
	   *        Which node should the tooltip be shown on
	   * @param {string} position [optional]
	   *        Optional tooltip position. Defaults to before_start
	   *        https://developer.mozilla.org/en-US/docs/XUL/PopupGuide/Positioning
	   * @param {number} x, y [optional]
	   *        The left and top offset coordinates, in pixels.
	   */
	  show: function (anchor,
	    position = this.defaultPosition,
	    x = this.defaultOffsetX,
	    y = this.defaultOffsetY) {
	    this.panel.hidden = false;
	    this.panel.openPopup(anchor, position, x, y);
	  },

	  /**
	   * Hide the tooltip
	   */
	  hide: function () {
	    this.panel.hidden = true;
	    this.panel.hidePopup();
	  },

	  isShown: function () {
	    return this.panel &&
	           this.panel.state !== "closed" &&
	           this.panel.state !== "hiding";
	  },

	  setSize: function (width, height) {
	    this.panel.sizeTo(width, height);
	  },

	  /**
	   * Empty the tooltip's content
	   */
	  empty: function () {
	    while (this.panel.hasChildNodes()) {
	      this.panel.removeChild(this.panel.firstChild);
	    }
	  },

	  /**
	   * Gets this panel's visibility state.
	   * @return boolean
	   */
	  isHidden: function () {
	    return this.panel.state == "closed" || this.panel.state == "hiding";
	  },

	  /**
	   * Gets if this panel has any child nodes.
	   * @return boolean
	   */
	  isEmpty: function () {
	    return !this.panel.hasChildNodes();
	  },

	  /**
	   * Get rid of references and event listeners
	   */
	  destroy: function () {
	    this.hide();

	    for (let eventName of POPUP_EVENTS) {
	      this.panel.removeEventListener("popup" + eventName,
	        this["_onPopup" + eventName], false);
	    }

	    let win = this.doc.querySelector("window");
	    win.removeEventListener("keypress", this._onKeyPress, false);

	    let closeOnEvents = this.options.get("closeOnEvents");
	    for (let {emitter, event, useCapture} of closeOnEvents) {
	      for (let remove of ["removeEventListener", "off"]) {
	        if (remove in emitter) {
	          emitter[remove](event, this.hide, useCapture);
	          break;
	        }
	      }
	    }

	    this.content = null;

	    this._toggle.destroy();

	    this.doc = null;

	    this.panel.remove();
	    this.panel = null;
	  },

	  /**
	   * Returns the outer container node (that includes the arrow etc.). Happens
	   * to be identical to this.panel here, can be different element in other
	   * Tooltip implementations.
	   */
	  get container() {
	    return this.panel;
	  },

	  /**
	   * Set the content of this tooltip. Will first empty the tooltip and then
	   * append the new content element.
	   * Consider using one of the set<type>Content() functions instead.
	   * @param {node} content
	   *        A node that can be appended in the tooltip XUL element
	   */
	  set content(content) {
	    if (this.content == content) {
	      return;
	    }

	    this.empty();
	    this.panel.removeAttribute("clamped-dimensions");
	    this.panel.removeAttribute("clamped-dimensions-no-min-height");
	    this.panel.removeAttribute("clamped-dimensions-no-max-or-min-height");
	    this.panel.removeAttribute("wide");

	    if (content) {
	      this.panel.appendChild(content);
	    }
	  },

	  get content() {
	    return this.panel.firstChild;
	  },

	  /**
	   * Sets some text as the content of this tooltip.
	   *
	   * @param {array} messages
	   *        A list of text messages.
	   * @param {string} messagesClass [optional]
	   *        A style class for the text messages.
	   * @param {string} containerClass [optional]
	   *        A style class for the text messages container.
	   * @param {boolean} isAlertTooltip [optional]
	   *        Pass true to add an alert image for your tooltip.
	   */
	  setTextContent: function (
	    {
	      messages,
	      messagesClass,
	      containerClass,
	      isAlertTooltip
	    },
	    extraButtons = []) {
	    messagesClass = messagesClass || "default-tooltip-simple-text-colors";
	    containerClass = containerClass || "default-tooltip-simple-text-colors";

	    let vbox = this.doc.createElement("vbox");
	    vbox.className = "devtools-tooltip-simple-text-container " + containerClass;
	    vbox.setAttribute("flex", "1");

	    for (let text of messages) {
	      let description = this.doc.createElement("description");
	      description.setAttribute("flex", "1");
	      description.className = "devtools-tooltip-simple-text " + messagesClass;
	      description.textContent = text;
	      vbox.appendChild(description);
	    }

	    for (let { label, className, command } of extraButtons) {
	      let button = this.doc.createElement("button");
	      button.className = className;
	      button.setAttribute("label", label);
	      button.addEventListener("command", command);
	      vbox.appendChild(button);
	    }

	    if (isAlertTooltip) {
	      let hbox = this.doc.createElement("hbox");
	      hbox.setAttribute("align", "start");

	      let alertImg = this.doc.createElement("image");
	      alertImg.className = "devtools-tooltip-alert-icon";
	      hbox.appendChild(alertImg);
	      hbox.appendChild(vbox);
	      this.content = hbox;
	    } else {
	      this.content = vbox;
	    }
	  },

	  /**
	   * Load a document into an iframe, and set the iframe
	   * to be the tooltip's content.
	   *
	   * Used by tooltips that want to load their interface
	   * into an iframe from a URL.
	   *
	   * @param {string} width
	   *        Width of the iframe.
	   * @param {string} height
	   *        Height of the iframe.
	   * @param {string} url
	   *        URL of the document to load into the iframe.
	   *
	   * @return {promise} A promise which is resolved with
	   * the iframe.
	   *
	   * This function creates an iframe, loads the specified document
	   * into it, sets the tooltip's content to the iframe, and returns
	   * a promise.
	   *
	   * When the document is loaded, the function gets the content window
	   * and resolves the promise with the content window.
	   */
	  setIFrameContent: function ({width, height}, url) {
	    let def = defer();

	    // Create an iframe
	    let iframe = this.doc.createElementNS(XHTML_NS, "iframe");
	    iframe.setAttribute("transparent", true);
	    iframe.setAttribute("width", width);
	    iframe.setAttribute("height", height);
	    iframe.setAttribute("flex", "1");
	    iframe.setAttribute("tooltip", "aHTMLTooltip");
	    iframe.setAttribute("class", "devtools-tooltip-iframe");

	    // Wait for the load to initialize the widget
	    function onLoad() {
	      iframe.removeEventListener("load", onLoad, true);
	      def.resolve(iframe);
	    }
	    iframe.addEventListener("load", onLoad, true);

	    // load the document from url into the iframe
	    iframe.setAttribute("src", url);

	    // Put the iframe in the tooltip
	    this.content = iframe;

	    return def.promise;
	  }
	};

	/**
	 * Base class for all (color, gradient, ...)-swatch based value editors inside
	 * tooltips
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 */
	function SwatchBasedEditorTooltip(toolbox, stylesheet) {
	  EventEmitter.decorate(this);
	  // Creating a tooltip instance
	  // This one will consume outside clicks as it makes more sense to let the user
	  // close the tooltip by clicking out
	  // It will also close on <escape> and <enter>
	  this.tooltip = new HTMLTooltip(toolbox, {
	    type: "arrow",
	    consumeOutsideClicks: true,
	    useXulWrapper: true,
	    stylesheet
	  });

	  // By default, swatch-based editor tooltips revert value change on <esc> and
	  // commit value change on <enter>
	  this.shortcuts = new KeyShortcuts({
	    window: this.tooltip.topWindow
	  });
	  this.shortcuts.on("Escape", (name, event) => {
	    if (!this.tooltip.isVisible()) {
	      return;
	    }
	    this.revert();
	    this.hide();
	    event.stopPropagation();
	    event.preventDefault();
	  });
	  this.shortcuts.on("Return", (name, event) => {
	    if (!this.tooltip.isVisible()) {
	      return;
	    }
	    this.commit();
	    this.hide();
	    event.stopPropagation();
	    event.preventDefault();
	  });

	  // All target swatches are kept in a map, indexed by swatch DOM elements
	  this.swatches = new Map();

	  // When a swatch is clicked, and for as long as the tooltip is shown, the
	  // activeSwatch property will hold the reference to the swatch DOM element
	  // that was clicked
	  this.activeSwatch = null;

	  this._onSwatchClick = this._onSwatchClick.bind(this);
	}

	SwatchBasedEditorTooltip.prototype = {
	  /**
	   * Show the editor tooltip for the currently active swatch.
	   *
	   * @return {Promise} a promise that resolves once the editor tooltip is displayed, or
	   *         immediately if there is no currently active swatch.
	   */
	  show: function () {
	    if (this.activeSwatch) {
	      let onShown = this.tooltip.once("shown");
	      this.tooltip.show(this.activeSwatch, "topcenter bottomleft");

	      // When the tooltip is closed by clicking outside the panel we want to
	      // commit any changes.
	      this.tooltip.once("hidden", () => {
	        if (!this._reverted && !this.eyedropperOpen) {
	          this.commit();
	        }
	        this._reverted = false;

	        // Once the tooltip is hidden we need to clean up any remaining objects.
	        if (!this.eyedropperOpen) {
	          this.activeSwatch = null;
	        }
	      });

	      return onShown;
	    }

	    return Promise.resolve();
	  },

	  hide: function () {
	    this.tooltip.hide();
	  },

	  /**
	   * Add a new swatch DOM element to the list of swatch elements this editor
	   * tooltip knows about. That means from now on, clicking on that swatch will
	   * toggle the editor.
	   *
	   * @param {node} swatchEl
	   *        The element to add
	   * @param {object} callbacks
	   *        Callbacks that will be executed when the editor wants to preview a
	   *        value change, or revert a change, or commit a change.
	   *        - onShow: will be called when one of the swatch tooltip is shown
	   *        - onPreview: will be called when one of the sub-classes calls
	   *        preview
	   *        - onRevert: will be called when the user ESCapes out of the tooltip
	   *        - onCommit: will be called when the user presses ENTER or clicks
	   *        outside the tooltip.
	   */
	  addSwatch: function (swatchEl, callbacks = {}) {
	    if (!callbacks.onShow) {
	      callbacks.onShow = function () {};
	    }
	    if (!callbacks.onPreview) {
	      callbacks.onPreview = function () {};
	    }
	    if (!callbacks.onRevert) {
	      callbacks.onRevert = function () {};
	    }
	    if (!callbacks.onCommit) {
	      callbacks.onCommit = function () {};
	    }

	    this.swatches.set(swatchEl, {
	      callbacks: callbacks
	    });
	    swatchEl.addEventListener("click", this._onSwatchClick, false);
	  },

	  removeSwatch: function (swatchEl) {
	    if (this.swatches.has(swatchEl)) {
	      if (this.activeSwatch === swatchEl) {
	        this.hide();
	        this.activeSwatch = null;
	      }
	      swatchEl.removeEventListener("click", this._onSwatchClick, false);
	      this.swatches.delete(swatchEl);
	    }
	  },

	  _onSwatchClick: function (event) {
	    let swatch = this.swatches.get(event.target);

	    if (event.shiftKey) {
	      event.stopPropagation();
	      return;
	    }
	    if (swatch) {
	      this.activeSwatch = event.target;
	      this.show();
	      swatch.callbacks.onShow();
	      event.stopPropagation();
	    }
	  },

	  /**
	   * Not called by this parent class, needs to be taken care of by sub-classes
	   */
	  preview: function (value) {
	    if (this.activeSwatch) {
	      let swatch = this.swatches.get(this.activeSwatch);
	      swatch.callbacks.onPreview(value);
	    }
	  },

	  /**
	   * This parent class only calls this on <esc> keypress
	   */
	  revert: function () {
	    if (this.activeSwatch) {
	      this._reverted = true;
	      let swatch = this.swatches.get(this.activeSwatch);
	      this.tooltip.once("hidden", () => {
	        swatch.callbacks.onRevert();
	      });
	    }
	  },

	  /**
	   * This parent class only calls this on <enter> keypress
	   */
	  commit: function () {
	    if (this.activeSwatch) {
	      let swatch = this.swatches.get(this.activeSwatch);
	      swatch.callbacks.onCommit();
	    }
	  },

	  destroy: function () {
	    this.swatches.clear();
	    this.activeSwatch = null;
	    this.tooltip.off("keypress", this._onTooltipKeypress);
	    this.tooltip.destroy();
	    this.shortcuts.destroy();
	  }
	};

	/**
	 * The swatch color picker tooltip class is a specific class meant to be used
	 * along with output-parser's generated color swatches.
	 * It extends the parent SwatchBasedEditorTooltip class.
	 * It just wraps a standard Tooltip and sets its content with an instance of a
	 * color picker.
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 * @param {InspectorPanel} inspector
	 *        The inspector panel, needed for the eyedropper.
	 */
	function SwatchColorPickerTooltip(toolbox, inspector) {
	  let stylesheet = "chrome://devtools/content/shared/widgets/spectrum.css";
	  SwatchBasedEditorTooltip.call(this, toolbox, stylesheet);

	  this.inspector = inspector;

	  // Creating a spectrum instance. this.spectrum will always be a promise that
	  // resolves to the spectrum instance
	  this.spectrum = this.setColorPickerContent([0, 0, 0, 1]);
	  this._onSpectrumColorChange = this._onSpectrumColorChange.bind(this);
	  this._openEyeDropper = this._openEyeDropper.bind(this);
	}

	module.exports.SwatchColorPickerTooltip = SwatchColorPickerTooltip;

	SwatchColorPickerTooltip.prototype =
	Heritage.extend(SwatchBasedEditorTooltip.prototype, {
	  /**
	   * Fill the tooltip with a new instance of the spectrum color picker widget
	   * initialized with the given color, and return the instance of spectrum
	   */
	  setColorPickerContent: function (color) {
	    let { doc } = this.tooltip;

	    let container = doc.createElementNS(XHTML_NS, "div");
	    container.id = "spectrum-tooltip";
	    let spectrumNode = doc.createElementNS(XHTML_NS, "div");
	    spectrumNode.id = "spectrum";
	    container.appendChild(spectrumNode);
	    let eyedropper = doc.createElementNS(XHTML_NS, "button");
	    eyedropper.id = "eyedropper-button";
	    eyedropper.className = "devtools-button";
	    container.appendChild(eyedropper);

	    this.tooltip.setContent(container, { width: 218, height: 224 });

	    let spectrum = new Spectrum(spectrumNode, color);

	    // Wait for the tooltip to be shown before calling spectrum.show
	    // as it expect to be visible in order to compute DOM element sizes.
	    this.tooltip.once("shown", () => {
	      spectrum.show();
	    });

	    return spectrum;
	  },

	  /**
	   * Overriding the SwatchBasedEditorTooltip.show function to set spectrum's
	   * color.
	   */
	  show: Task.async(function* () {
	    // Call then parent class' show function
	    yield SwatchBasedEditorTooltip.prototype.show.call(this);
	    // Then set spectrum's color and listen to color changes to preview them
	    if (this.activeSwatch) {
	      this.currentSwatchColor = this.activeSwatch.nextSibling;
	      this._originalColor = this.currentSwatchColor.textContent;
	      let color = this.activeSwatch.style.backgroundColor;
	      this.spectrum.off("changed", this._onSpectrumColorChange);
	      this.spectrum.rgb = this._colorToRgba(color);
	      this.spectrum.on("changed", this._onSpectrumColorChange);
	      this.spectrum.updateUI();
	    }

	    let {target} = this.inspector.toolbox;
	    target.actorHasMethod("inspector", "pickColorFromPage").then(value => {
	      let tooltipDoc = this.tooltip.doc;
	      let eyeButton = tooltipDoc.querySelector("#eyedropper-button");
	      if (value && this.inspector.selection.nodeFront.isInHTMLDocument) {
	        eyeButton.addEventListener("click", this._openEyeDropper);
	      } else {
	        eyeButton.style.display = "none";
	      }
	      this.emit("ready");
	    }, e => console.error(e));
	  }),

	  _onSpectrumColorChange: function (event, rgba, cssColor) {
	    this._selectColor(cssColor);
	  },

	  _selectColor: function (color) {
	    if (this.activeSwatch) {
	      this.activeSwatch.style.backgroundColor = color;
	      this.activeSwatch.parentNode.dataset.color = color;

	      color = this._toDefaultType(color);
	      this.currentSwatchColor.textContent = color;
	      this.preview(color);

	      if (this.eyedropperOpen) {
	        this.commit();
	      }
	    }
	  },

	  _openEyeDropper: function () {
	    let {inspector, toolbox, telemetry} = this.inspector;
	    telemetry.toolOpened("pickereyedropper");
	    inspector.pickColorFromPage(toolbox, {copyOnSelect: false}).then(() => {
	      this.eyedropperOpen = true;

	      // close the colorpicker tooltip so that only the eyedropper is open.
	      this.hide();

	      this.tooltip.emit("eyedropper-opened");
	    }, e => console.error(e));

	    inspector.once("color-picked", color => {
	      toolbox.win.focus();
	      this._selectColor(color);
	      this._onEyeDropperDone();
	    });

	    inspector.once("color-pick-canceled", () => {
	      this._onEyeDropperDone();
	    });
	  },

	  _onEyeDropperDone: function () {
	    this.eyedropperOpen = false;
	    this.activeSwatch = null;
	  },

	  _colorToRgba: function (color) {
	    color = new colorUtils.CssColor(color);
	    let rgba = color._getRGBATuple();
	    return [rgba.r, rgba.g, rgba.b, rgba.a];
	  },

	  _toDefaultType: function (color) {
	    let colorObj = new colorUtils.CssColor(color);
	    colorObj.setAuthoredUnitFromColor(this._originalColor);
	    return colorObj.toString();
	  },

	  destroy: function () {
	    SwatchBasedEditorTooltip.prototype.destroy.call(this);
	    this.inspector = null;
	    this.currentSwatchColor = null;
	    this.spectrum.off("changed", this._onSpectrumColorChange);
	    this.spectrum.destroy();
	  }
	});

	/**
	 * The swatch cubic-bezier tooltip class is a specific class meant to be used
	 * along with rule-view's generated cubic-bezier swatches.
	 * It extends the parent SwatchBasedEditorTooltip class.
	 * It just wraps a standard Tooltip and sets its content with an instance of a
	 * CubicBezierWidget.
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 */
	function SwatchCubicBezierTooltip(toolbox) {
	  let stylesheet = "chrome://devtools/content/shared/widgets/cubic-bezier.css";
	  SwatchBasedEditorTooltip.call(this, toolbox, stylesheet);

	  // Creating a cubic-bezier instance.
	  // this.widget will always be a promise that resolves to the widget instance
	  this.widget = this.setCubicBezierContent([0, 0, 1, 1]);
	  this._onUpdate = this._onUpdate.bind(this);
	}

	module.exports.SwatchCubicBezierTooltip = SwatchCubicBezierTooltip;

	SwatchCubicBezierTooltip.prototype =
	Heritage.extend(SwatchBasedEditorTooltip.prototype, {
	  /**
	   * Fill the tooltip with a new instance of the cubic-bezier widget
	   * initialized with the given value, and return a promise that resolves to
	   * the instance of the widget
	   */
	  setCubicBezierContent: function (bezier) {
	    let { doc } = this.tooltip;

	    let container = doc.createElementNS(XHTML_NS, "div");
	    container.className = "cubic-bezier-container";

	    this.tooltip.setContent(container, { width: 510, height: 370 });

	    let def = defer();

	    // Wait for the tooltip to be shown before calling instanciating the widget
	    // as it expect its DOM elements to be visible.
	    this.tooltip.once("shown", () => {
	      let widget = new CubicBezierWidget(container, bezier);
	      def.resolve(widget);
	    });

	    return def.promise;
	  },

	  /**
	   * Overriding the SwatchBasedEditorTooltip.show function to set the cubic
	   * bezier curve in the widget
	   */
	  show: Task.async(function* () {
	    // Call the parent class' show function
	    yield SwatchBasedEditorTooltip.prototype.show.call(this);
	    // Then set the curve and listen to changes to preview them
	    if (this.activeSwatch) {
	      this.currentBezierValue = this.activeSwatch.nextSibling;
	      this.widget.then(widget => {
	        widget.off("updated", this._onUpdate);
	        widget.cssCubicBezierValue = this.currentBezierValue.textContent;
	        widget.on("updated", this._onUpdate);
	        this.emit("ready");
	      });
	    }
	  }),

	  _onUpdate: function (event, bezier) {
	    if (!this.activeSwatch) {
	      return;
	    }

	    this.currentBezierValue.textContent = bezier + "";
	    this.preview(bezier + "");
	  },

	  destroy: function () {
	    SwatchBasedEditorTooltip.prototype.destroy.call(this);
	    this.currentBezierValue = null;
	    this.widget.then(widget => {
	      widget.off("updated", this._onUpdate);
	      widget.destroy();
	    });
	  }
	});

	/**
	 * The swatch-based css filter tooltip class is a specific class meant to be
	 * used along with rule-view's generated css filter swatches.
	 * It extends the parent SwatchBasedEditorTooltip class.
	 * It just wraps a standard Tooltip and sets its content with an instance of a
	 * CSSFilterEditorWidget.
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 */
	function SwatchFilterTooltip(toolbox) {
	  let stylesheet = "chrome://devtools/content/shared/widgets/filter-widget.css";
	  SwatchBasedEditorTooltip.call(this, toolbox, stylesheet);

	  // Creating a filter editor instance.
	  this.widget = this.setFilterContent("none");
	  this._onUpdate = this._onUpdate.bind(this);
	}

	exports.SwatchFilterTooltip = SwatchFilterTooltip;

	SwatchFilterTooltip.prototype =
	Heritage.extend(SwatchBasedEditorTooltip.prototype, {
	  /**
	   * Fill the tooltip with a new instance of the CSSFilterEditorWidget
	   * widget initialized with the given filter value, and return a promise
	   * that resolves to the instance of the widget when ready.
	   */
	  setFilterContent: function (filter) {
	    let { doc } = this.tooltip;

	    let container = doc.createElementNS(XHTML_NS, "div");
	    container.id = "filter-container";

	    this.tooltip.setContent(container, { width: 510, height: 200 });

	    return new CSSFilterEditorWidget(container, filter);
	  },

	  show: Task.async(function* () {
	    // Call the parent class' show function
	    yield SwatchBasedEditorTooltip.prototype.show.call(this);
	    // Then set the filter value and listen to changes to preview them
	    if (this.activeSwatch) {
	      this.currentFilterValue = this.activeSwatch.nextSibling;
	      this.widget.off("updated", this._onUpdate);
	      this.widget.on("updated", this._onUpdate);
	      this.widget.setCssValue(this.currentFilterValue.textContent);
	      this.widget.render();
	      this.emit("ready");
	    }
	  }),

	  _onUpdate: function (event, filters) {
	    if (!this.activeSwatch) {
	      return;
	    }

	    // Remove the old children and reparse the property value to
	    // recompute them.
	    while (this.currentFilterValue.firstChild) {
	      this.currentFilterValue.firstChild.remove();
	    }
	    let node = this._parser.parseCssProperty("filter", filters, this._options);
	    this.currentFilterValue.appendChild(node);

	    this.preview();
	  },

	  destroy: function () {
	    SwatchBasedEditorTooltip.prototype.destroy.call(this);
	    this.currentFilterValue = null;
	    this.widget.off("updated", this._onUpdate);
	    this.widget.destroy();
	  },

	  /**
	   * Like SwatchBasedEditorTooltip.addSwatch, but accepts a parser object
	   * to use when previewing the updated property value.
	   *
	   * @param {node} swatchEl
	   *        @see SwatchBasedEditorTooltip.addSwatch
	   * @param {object} callbacks
	   *        @see SwatchBasedEditorTooltip.addSwatch
	   * @param {object} parser
	   *        A parser object; @see OutputParser object
	   * @param {object} options
	   *        options to pass to the output parser, with
	   *          the option |filterSwatch| set.
	   */
	  addSwatch: function (swatchEl, callbacks, parser, options) {
	    SwatchBasedEditorTooltip.prototype.addSwatch.call(this, swatchEl,
	                                                      callbacks);
	    this._parser = parser;
	    this._options = options;
	  }
	});


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const EventEmitter = __webpack_require__(6);
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	/**
	 * Spectrum creates a color picker widget in any container you give it.
	 *
	 * Simple usage example:
	 *
	 * const {Spectrum} = require("devtools/client/shared/widgets/Spectrum");
	 * let s = new Spectrum(containerElement, [255, 126, 255, 1]);
	 * s.on("changed", (event, rgba, color) => {
	 *   console.log("rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " +
	 *     rgba[3] + ")");
	 * });
	 * s.show();
	 * s.destroy();
	 *
	 * Note that the color picker is hidden by default and you need to call show to
	 * make it appear. This 2 stages initialization helps in cases you are creating
	 * the color picker in a parent element that hasn't been appended anywhere yet
	 * or that is hidden. Calling show() when the parent element is appended and
	 * visible will allow spectrum to correctly initialize its various parts.
	 *
	 * Fires the following events:
	 * - changed : When the user changes the current color
	 */
	function Spectrum(parentEl, rgb) {
	  EventEmitter.decorate(this);

	  this.element = parentEl.ownerDocument.createElementNS(XHTML_NS, "div");
	  this.parentEl = parentEl;

	  this.element.className = "spectrum-container";
	  this.element.innerHTML = `
	    <div class="spectrum-top">
	      <div class="spectrum-fill"></div>
	      <div class="spectrum-top-inner">
	        <div class="spectrum-color spectrum-box">
	          <div class="spectrum-sat">
	            <div class="spectrum-val">
	              <div class="spectrum-dragger"></div>
	            </div>
	          </div>
	        </div>
	        <div class="spectrum-hue spectrum-box">
	          <div class="spectrum-slider spectrum-slider-control"></div>
	        </div>
	      </div>
	    </div>
	    <div class="spectrum-alpha spectrum-checker spectrum-box">
	      <div class="spectrum-alpha-inner">
	        <div class="spectrum-alpha-handle spectrum-slider-control"></div>
	      </div>
	    </div>
	  `;

	  this.onElementClick = this.onElementClick.bind(this);
	  this.element.addEventListener("click", this.onElementClick, false);

	  this.parentEl.appendChild(this.element);

	  this.slider = this.element.querySelector(".spectrum-hue");
	  this.slideHelper = this.element.querySelector(".spectrum-slider");
	  Spectrum.draggable(this.slider, this.onSliderMove.bind(this));

	  this.dragger = this.element.querySelector(".spectrum-color");
	  this.dragHelper = this.element.querySelector(".spectrum-dragger");
	  Spectrum.draggable(this.dragger, this.onDraggerMove.bind(this));

	  this.alphaSlider = this.element.querySelector(".spectrum-alpha");
	  this.alphaSliderInner = this.element.querySelector(".spectrum-alpha-inner");
	  this.alphaSliderHelper = this.element.querySelector(".spectrum-alpha-handle");
	  Spectrum.draggable(this.alphaSliderInner, this.onAlphaSliderMove.bind(this));

	  if (rgb) {
	    this.rgb = rgb;
	    this.updateUI();
	  }
	}

	module.exports.Spectrum = Spectrum;

	Spectrum.hsvToRgb = function (h, s, v, a) {
	  let r, g, b;

	  let i = Math.floor(h * 6);
	  let f = h * 6 - i;
	  let p = v * (1 - s);
	  let q = v * (1 - f * s);
	  let t = v * (1 - (1 - f) * s);

	  switch (i % 6) {
	    case 0: r = v; g = t; b = p; break;
	    case 1: r = q; g = v; b = p; break;
	    case 2: r = p; g = v; b = t; break;
	    case 3: r = p; g = q; b = v; break;
	    case 4: r = t; g = p; b = v; break;
	    case 5: r = v; g = p; b = q; break;
	  }

	  return [r * 255, g * 255, b * 255, a];
	};

	Spectrum.rgbToHsv = function (r, g, b, a) {
	  r = r / 255;
	  g = g / 255;
	  b = b / 255;

	  let max = Math.max(r, g, b), min = Math.min(r, g, b);
	  let h, s, v = max;

	  let d = max - min;
	  s = max == 0 ? 0 : d / max;

	  if (max == min) {
	    // achromatic
	    h = 0;
	  } else {
	    switch (max) {
	      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	      case g: h = (b - r) / d + 2; break;
	      case b: h = (r - g) / d + 4; break;
	    }
	    h /= 6;
	  }
	  return [h, s, v, a];
	};

	Spectrum.draggable = function (element, onmove, onstart, onstop) {
	  onmove = onmove || function () {};
	  onstart = onstart || function () {};
	  onstop = onstop || function () {};

	  let doc = element.ownerDocument;
	  let dragging = false;
	  let offset = {};
	  let maxHeight = 0;
	  let maxWidth = 0;

	  function prevent(e) {
	    e.stopPropagation();
	    e.preventDefault();
	  }

	  function move(e) {
	    if (dragging) {
	      if (e.buttons === 0) {
	        // The button is no longer pressed but we did not get a mouseup event.
	        stop();
	        return;
	      }
	      let pageX = e.pageX;
	      let pageY = e.pageY;

	      let dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
	      let dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

	      onmove.apply(element, [dragX, dragY]);
	    }
	  }

	  function start(e) {
	    let rightclick = e.which === 3;

	    if (!rightclick && !dragging) {
	      if (onstart.apply(element, arguments) !== false) {
	        dragging = true;
	        maxHeight = element.offsetHeight;
	        maxWidth = element.offsetWidth;

	        offset = element.getBoundingClientRect();

	        move(e);

	        doc.addEventListener("selectstart", prevent, false);
	        doc.addEventListener("dragstart", prevent, false);
	        doc.addEventListener("mousemove", move, false);
	        doc.addEventListener("mouseup", stop, false);

	        prevent(e);
	      }
	    }
	  }

	  function stop() {
	    if (dragging) {
	      doc.removeEventListener("selectstart", prevent, false);
	      doc.removeEventListener("dragstart", prevent, false);
	      doc.removeEventListener("mousemove", move, false);
	      doc.removeEventListener("mouseup", stop, false);
	      onstop.apply(element, arguments);
	    }
	    dragging = false;
	  }

	  element.addEventListener("mousedown", start, false);
	};

	Spectrum.prototype = {
	  set rgb(color) {
	    this.hsv = Spectrum.rgbToHsv(color[0], color[1], color[2], color[3]);
	  },

	  get rgb() {
	    let rgb = Spectrum.hsvToRgb(this.hsv[0], this.hsv[1], this.hsv[2],
	      this.hsv[3]);
	    return [Math.round(rgb[0]), Math.round(rgb[1]), Math.round(rgb[2]),
	      Math.round(rgb[3] * 100) / 100];
	  },

	  get rgbNoSatVal() {
	    let rgb = Spectrum.hsvToRgb(this.hsv[0], 1, 1);
	    return [Math.round(rgb[0]), Math.round(rgb[1]), Math.round(rgb[2]), rgb[3]];
	  },

	  get rgbCssString() {
	    let rgb = this.rgb;
	    return "rgba(" + rgb[0] + ", " + rgb[1] + ", " + rgb[2] + ", " +
	      rgb[3] + ")";
	  },

	  show: function () {
	    this.element.classList.add("spectrum-show");

	    this.slideHeight = this.slider.offsetHeight;
	    this.dragWidth = this.dragger.offsetWidth;
	    this.dragHeight = this.dragger.offsetHeight;
	    this.dragHelperHeight = this.dragHelper.offsetHeight;
	    this.slideHelperHeight = this.slideHelper.offsetHeight;
	    this.alphaSliderWidth = this.alphaSliderInner.offsetWidth;
	    this.alphaSliderHelperWidth = this.alphaSliderHelper.offsetWidth;

	    this.updateUI();
	  },

	  onElementClick: function (e) {
	    e.stopPropagation();
	  },

	  onSliderMove: function (dragX, dragY) {
	    this.hsv[0] = (dragY / this.slideHeight);
	    this.updateUI();
	    this.onChange();
	  },

	  onDraggerMove: function (dragX, dragY) {
	    this.hsv[1] = dragX / this.dragWidth;
	    this.hsv[2] = (this.dragHeight - dragY) / this.dragHeight;
	    this.updateUI();
	    this.onChange();
	  },

	  onAlphaSliderMove: function (dragX, dragY) {
	    this.hsv[3] = dragX / this.alphaSliderWidth;
	    this.updateUI();
	    this.onChange();
	  },

	  onChange: function () {
	    this.emit("changed", this.rgb, this.rgbCssString);
	  },

	  updateHelperLocations: function () {
	    // If the UI hasn't been shown yet then none of the dimensions will be
	    // correct
	    if (!this.element.classList.contains("spectrum-show")) {
	      return;
	    }

	    let h = this.hsv[0];
	    let s = this.hsv[1];
	    let v = this.hsv[2];

	    // Placing the color dragger
	    let dragX = s * this.dragWidth;
	    let dragY = this.dragHeight - (v * this.dragHeight);
	    let helperDim = this.dragHelperHeight / 2;

	    dragX = Math.max(
	      -helperDim,
	      Math.min(this.dragWidth - helperDim, dragX - helperDim)
	    );
	    dragY = Math.max(
	      -helperDim,
	      Math.min(this.dragHeight - helperDim, dragY - helperDim)
	    );

	    this.dragHelper.style.top = dragY + "px";
	    this.dragHelper.style.left = dragX + "px";

	    // Placing the hue slider
	    let slideY = (h * this.slideHeight) - this.slideHelperHeight / 2;
	    this.slideHelper.style.top = slideY + "px";

	    // Placing the alpha slider
	    let alphaSliderX = (this.hsv[3] * this.alphaSliderWidth) -
	      (this.alphaSliderHelperWidth / 2);
	    this.alphaSliderHelper.style.left = alphaSliderX + "px";
	  },

	  updateUI: function () {
	    this.updateHelperLocations();

	    let rgb = this.rgb;
	    let rgbNoSatVal = this.rgbNoSatVal;

	    let flatColor = "rgb(" + rgbNoSatVal[0] + ", " + rgbNoSatVal[1] + ", " +
	      rgbNoSatVal[2] + ")";

	    this.dragger.style.backgroundColor = flatColor;

	    let rgbNoAlpha = "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
	    let rgbAlpha0 = "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ", 0)";
	    let alphaGradient = "linear-gradient(to right, " + rgbAlpha0 + ", " +
	      rgbNoAlpha + ")";
	    this.alphaSliderInner.style.background = alphaGradient;
	  },

	  destroy: function () {
	    this.element.removeEventListener("click", this.onElementClick, false);

	    this.parentEl.removeChild(this.element);

	    this.slider = null;
	    this.dragger = null;
	    this.alphaSlider = this.alphaSliderInner = this.alphaSliderHelper = null;
	    this.parentEl = null;
	    this.element = null;
	  }
	};


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013 Lea Verou. All rights reserved.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a
	 * copy of this software and associated documentation files (the "Software"),
	 * to deal in the Software without restriction, including without limitation
	 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
	 * and/or sell copies of the Software, and to permit persons to whom the
	 * Software is furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	 * DEALINGS IN THE SOFTWARE.
	 */

	// Based on www.cubic-bezier.com by Lea Verou
	// See https://github.com/LeaVerou/cubic-bezier

	"use strict";

	const EventEmitter = __webpack_require__(6);
	const {
	  PREDEFINED,
	  PRESETS,
	  DEFAULT_PRESET_CATEGORY
	} = __webpack_require__(146);
	const {getCSSLexer} = __webpack_require__(123);
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	/**
	 * CubicBezier data structure helper
	 * Accepts an array of coordinates and exposes a few useful getters
	 * @param {Array} coordinates i.e. [.42, 0, .58, 1]
	 */
	function CubicBezier(coordinates) {
	  if (!coordinates) {
	    throw new Error("No offsets were defined");
	  }

	  this.coordinates = coordinates.map(n => +n);

	  for (let i = 4; i--;) {
	    let xy = this.coordinates[i];
	    if (isNaN(xy) || (!(i % 2) && (xy < 0 || xy > 1))) {
	      throw new Error(`Wrong coordinate at ${i}(${xy})`);
	    }
	  }

	  this.coordinates.toString = function () {
	    return this.map(n => {
	      return (Math.round(n * 100) / 100 + "").replace(/^0\./, ".");
	    }) + "";
	  };
	}

	exports.CubicBezier = CubicBezier;

	CubicBezier.prototype = {
	  get P1() {
	    return this.coordinates.slice(0, 2);
	  },

	  get P2() {
	    return this.coordinates.slice(2);
	  },

	  toString: function () {
	    // Check first if current coords are one of css predefined functions
	    let predefName = Object.keys(PREDEFINED)
	                           .find(key => coordsAreEqual(PREDEFINED[key],
	                                                       this.coordinates));

	    return predefName || "cubic-bezier(" + this.coordinates + ")";
	  }
	};

	/**
	 * Bezier curve canvas plotting class
	 * @param {DOMNode} canvas
	 * @param {CubicBezier} bezier
	 * @param {Array} padding Amount of horizontal,vertical padding around the graph
	 */
	function BezierCanvas(canvas, bezier, padding) {
	  this.canvas = canvas;
	  this.bezier = bezier;
	  this.padding = getPadding(padding);

	  // Convert to a cartesian coordinate system with axes from 0 to 1
	  this.ctx = this.canvas.getContext("2d");
	  let p = this.padding;

	  this.ctx.scale(canvas.width * (1 - p[1] - p[3]),
	                 -canvas.height * (1 - p[0] - p[2]));
	  this.ctx.translate(p[3] / (1 - p[1] - p[3]),
	                     -1 - p[0] / (1 - p[0] - p[2]));
	}

	exports.BezierCanvas = BezierCanvas;

	BezierCanvas.prototype = {
	  /**
	   * Get P1 and P2 current top/left offsets so they can be positioned
	   * @return {Array} Returns an array of 2 {top:String,left:String} objects
	   */
	  get offsets() {
	    let p = this.padding, w = this.canvas.width, h = this.canvas.height;

	    return [{
	      left: w * (this.bezier.coordinates[0] * (1 - p[3] - p[1]) - p[3]) + "px",
	      top: h * (1 - this.bezier.coordinates[1] * (1 - p[0] - p[2]) - p[0])
	           + "px"
	    }, {
	      left: w * (this.bezier.coordinates[2] * (1 - p[3] - p[1]) - p[3]) + "px",
	      top: h * (1 - this.bezier.coordinates[3] * (1 - p[0] - p[2]) - p[0])
	           + "px"
	    }];
	  },

	  /**
	   * Convert an element's left/top offsets into coordinates
	   */
	  offsetsToCoordinates: function (element) {
	    let p = this.padding, w = this.canvas.width, h = this.canvas.height;

	    // Convert padding percentage to actual padding
	    p = p.map((a, i) => a * (i % 2 ? w : h));

	    return [
	      (parseFloat(element.style.left) - p[3]) / (w + p[1] + p[3]),
	      (h - parseFloat(element.style.top) - p[2]) / (h - p[0] - p[2])
	    ];
	  },

	  /**
	   * Draw the cubic bezier curve for the current coordinates
	   */
	  plot: function (settings = {}) {
	    let xy = this.bezier.coordinates;

	    let defaultSettings = {
	      handleColor: "#666",
	      handleThickness: .008,
	      bezierColor: "#4C9ED9",
	      bezierThickness: .015,
	      drawHandles: true
	    };

	    for (let setting in settings) {
	      defaultSettings[setting] = settings[setting];
	    }

	    // Clear the canvas –making sure to clear the
	    // whole area by resetting the transform first.
	    this.ctx.save();
	    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
	    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
	    this.ctx.restore();

	    if (defaultSettings.drawHandles) {
	      // Draw control handles
	      this.ctx.beginPath();
	      this.ctx.fillStyle = defaultSettings.handleColor;
	      this.ctx.lineWidth = defaultSettings.handleThickness;
	      this.ctx.strokeStyle = defaultSettings.handleColor;

	      this.ctx.moveTo(0, 0);
	      this.ctx.lineTo(xy[0], xy[1]);
	      this.ctx.moveTo(1, 1);
	      this.ctx.lineTo(xy[2], xy[3]);

	      this.ctx.stroke();
	      this.ctx.closePath();

	      let circle = (ctx, cx, cy, r) => {
	        ctx.beginPath();
	        ctx.arc(cx, cy, r, 0, 2 * Math.PI, !1);
	        ctx.closePath();
	      };

	      circle(this.ctx, xy[0], xy[1], 1.5 * defaultSettings.handleThickness);
	      this.ctx.fill();
	      circle(this.ctx, xy[2], xy[3], 1.5 * defaultSettings.handleThickness);
	      this.ctx.fill();
	    }

	    // Draw bezier curve
	    this.ctx.beginPath();
	    this.ctx.lineWidth = defaultSettings.bezierThickness;
	    this.ctx.strokeStyle = defaultSettings.bezierColor;
	    this.ctx.moveTo(0, 0);
	    this.ctx.bezierCurveTo(xy[0], xy[1], xy[2], xy[3], 1, 1);
	    this.ctx.stroke();
	    this.ctx.closePath();
	  }
	};

	/**
	 * Cubic-bezier widget. Uses the BezierCanvas class to draw the curve and
	 * adds the control points and user interaction
	 * @param {DOMNode} parent The container where the graph should be created
	 * @param {Array} coordinates Coordinates of the curve to be drawn
	 *
	 * Emits "updated" events whenever the curve is changed. Along with the event is
	 * sent a CubicBezier object
	 */
	function CubicBezierWidget(parent,
	                           coordinates = PRESETS["ease-in"]["ease-in-sine"]) {
	  EventEmitter.decorate(this);

	  this.parent = parent;
	  let {curve, p1, p2} = this._initMarkup();

	  this.curveBoundingBox = curve.getBoundingClientRect();
	  this.curve = curve;
	  this.p1 = p1;
	  this.p2 = p2;

	  // Create and plot the bezier curve
	  this.bezierCanvas = new BezierCanvas(this.curve,
	    new CubicBezier(coordinates), [0.30, 0]);
	  this.bezierCanvas.plot();

	  // Place the control points
	  let offsets = this.bezierCanvas.offsets;
	  this.p1.style.left = offsets[0].left;
	  this.p1.style.top = offsets[0].top;
	  this.p2.style.left = offsets[1].left;
	  this.p2.style.top = offsets[1].top;

	  this._onPointMouseDown = this._onPointMouseDown.bind(this);
	  this._onPointKeyDown = this._onPointKeyDown.bind(this);
	  this._onCurveClick = this._onCurveClick.bind(this);
	  this._onNewCoordinates = this._onNewCoordinates.bind(this);

	  // Add preset preview menu
	  this.presets = new CubicBezierPresetWidget(parent);

	  // Add the timing function previewer
	  this.timingPreview = new TimingFunctionPreviewWidget(parent);

	  this._initEvents();
	}

	exports.CubicBezierWidget = CubicBezierWidget;

	CubicBezierWidget.prototype = {
	  _initMarkup: function () {
	    let doc = this.parent.ownerDocument;

	    let wrap = doc.createElementNS(XHTML_NS, "div");
	    wrap.className = "display-wrap";

	    let plane = doc.createElementNS(XHTML_NS, "div");
	    plane.className = "coordinate-plane";

	    let p1 = doc.createElementNS(XHTML_NS, "button");
	    p1.className = "control-point";
	    plane.appendChild(p1);

	    let p2 = doc.createElementNS(XHTML_NS, "button");
	    p2.className = "control-point";
	    plane.appendChild(p2);

	    let curve = doc.createElementNS(XHTML_NS, "canvas");
	    curve.setAttribute("width", 150);
	    curve.setAttribute("height", 370);
	    curve.className = "curve";

	    plane.appendChild(curve);
	    wrap.appendChild(plane);

	    this.parent.appendChild(wrap);

	    return {
	      p1,
	      p2,
	      curve
	    };
	  },

	  _removeMarkup: function () {
	    this.parent.querySelector(".display-wrap").remove();
	  },

	  _initEvents: function () {
	    this.p1.addEventListener("mousedown", this._onPointMouseDown);
	    this.p2.addEventListener("mousedown", this._onPointMouseDown);

	    this.p1.addEventListener("keydown", this._onPointKeyDown);
	    this.p2.addEventListener("keydown", this._onPointKeyDown);

	    this.curve.addEventListener("click", this._onCurveClick);

	    this.presets.on("new-coordinates", this._onNewCoordinates);
	  },

	  _removeEvents: function () {
	    this.p1.removeEventListener("mousedown", this._onPointMouseDown);
	    this.p2.removeEventListener("mousedown", this._onPointMouseDown);

	    this.p1.removeEventListener("keydown", this._onPointKeyDown);
	    this.p2.removeEventListener("keydown", this._onPointKeyDown);

	    this.curve.removeEventListener("click", this._onCurveClick);

	    this.presets.off("new-coordinates", this._onNewCoordinates);
	  },

	  _onPointMouseDown: function (event) {
	    // Updating the boundingbox in case it has changed
	    this.curveBoundingBox = this.curve.getBoundingClientRect();

	    let point = event.target;
	    let doc = point.ownerDocument;
	    let self = this;

	    doc.onmousemove = function drag(e) {
	      let x = e.pageX;
	      let y = e.pageY;
	      let left = self.curveBoundingBox.left;
	      let top = self.curveBoundingBox.top;

	      if (x === 0 && y == 0) {
	        return;
	      }

	      // Constrain x
	      x = Math.min(Math.max(left, x), left + self.curveBoundingBox.width);

	      point.style.left = x - left + "px";
	      point.style.top = y - top + "px";

	      self._updateFromPoints();
	    };

	    doc.onmouseup = function () {
	      point.focus();
	      doc.onmousemove = doc.onmouseup = null;
	    };
	  },

	  _onPointKeyDown: function (event) {
	    let point = event.target;
	    let code = event.keyCode;

	    if (code >= 37 && code <= 40) {
	      event.preventDefault();

	      // Arrow keys pressed
	      let left = parseInt(point.style.left, 10);
	      let top = parseInt(point.style.top, 10);
	      let offset = 3 * (event.shiftKey ? 10 : 1);

	      switch (code) {
	        case 37: point.style.left = left - offset + "px"; break;
	        case 38: point.style.top = top - offset + "px"; break;
	        case 39: point.style.left = left + offset + "px"; break;
	        case 40: point.style.top = top + offset + "px"; break;
	      }

	      this._updateFromPoints();
	    }
	  },

	  _onCurveClick: function (event) {
	    this.curveBoundingBox = this.curve.getBoundingClientRect();

	    let left = this.curveBoundingBox.left;
	    let top = this.curveBoundingBox.top;
	    let x = event.pageX - left;
	    let y = event.pageY - top;

	    // Find which point is closer
	    let distP1 = distance(x, y,
	      parseInt(this.p1.style.left, 10), parseInt(this.p1.style.top, 10));
	    let distP2 = distance(x, y,
	      parseInt(this.p2.style.left, 10), parseInt(this.p2.style.top, 10));

	    let point = distP1 < distP2 ? this.p1 : this.p2;
	    point.style.left = x + "px";
	    point.style.top = y + "px";

	    this._updateFromPoints();
	  },

	  _onNewCoordinates: function (event, coordinates) {
	    this.coordinates = coordinates;
	  },

	  /**
	   * Get the current point coordinates and redraw the curve to match
	   */
	  _updateFromPoints: function () {
	    // Get the new coordinates from the point's offsets
	    let coordinates = this.bezierCanvas.offsetsToCoordinates(this.p1);
	    coordinates = coordinates.concat(
	      this.bezierCanvas.offsetsToCoordinates(this.p2)
	    );

	    this.presets.refreshMenu(coordinates);
	    this._redraw(coordinates);
	  },

	  /**
	   * Redraw the curve
	   * @param {Array} coordinates The array of control point coordinates
	   */
	  _redraw: function (coordinates) {
	    // Provide a new CubicBezier to the canvas and plot the curve
	    this.bezierCanvas.bezier = new CubicBezier(coordinates);
	    this.bezierCanvas.plot();
	    this.emit("updated", this.bezierCanvas.bezier);

	    this.timingPreview.preview(this.bezierCanvas.bezier + "");
	  },

	  /**
	   * Set new coordinates for the control points and redraw the curve
	   * @param {Array} coordinates
	   */
	  set coordinates(coordinates) {
	    this._redraw(coordinates);

	    // Move the points
	    let offsets = this.bezierCanvas.offsets;
	    this.p1.style.left = offsets[0].left;
	    this.p1.style.top = offsets[0].top;
	    this.p2.style.left = offsets[1].left;
	    this.p2.style.top = offsets[1].top;
	  },

	  /**
	   * Set new coordinates for the control point and redraw the curve
	   * @param {String} value A string value. E.g. "linear",
	   * "cubic-bezier(0,0,1,1)"
	   */
	  set cssCubicBezierValue(value) {
	    if (!value) {
	      return;
	    }

	    value = value.trim();

	    // Try with one of the predefined values
	    let coordinates = parseTimingFunction(value);

	    this.presets.refreshMenu(coordinates);
	    this.coordinates = coordinates;
	  },

	  destroy: function () {
	    this._removeEvents();
	    this._removeMarkup();

	    this.timingPreview.destroy();
	    this.presets.destroy();

	    this.curve = this.p1 = this.p2 = null;
	  }
	};

	/**
	 * CubicBezierPreset widget.
	 * Builds a menu of presets from CubicBezierPresets
	 * @param {DOMNode} parent The container where the preset panel should be
	 * created
	 *
	 * Emits "new-coordinate" event along with the coordinates
	 * whenever a preset is selected.
	 */
	function CubicBezierPresetWidget(parent) {
	  this.parent = parent;

	  let {presetPane, presets, categories} = this._initMarkup();
	  this.presetPane = presetPane;
	  this.presets = presets;
	  this.categories = categories;

	  this._activeCategory = null;
	  this._activePresetList = null;
	  this._activePreset = null;

	  this._onCategoryClick = this._onCategoryClick.bind(this);
	  this._onPresetClick = this._onPresetClick.bind(this);

	  EventEmitter.decorate(this);
	  this._initEvents();
	}

	exports.CubicBezierPresetWidget = CubicBezierPresetWidget;

	CubicBezierPresetWidget.prototype = {
	  /*
	   * Constructs a list of all preset categories and a list
	   * of presets for each category.
	   *
	   * High level markup:
	   *  div .preset-pane
	   *    div .preset-categories
	   *      div .category
	   *      div .category
	   *      ...
	   *    div .preset-container
	   *      div .presetList
	   *        div .preset
	   *        ...
	   *      div .presetList
	   *        div .preset
	   *        ...
	   */
	  _initMarkup: function () {
	    let doc = this.parent.ownerDocument;

	    let presetPane = doc.createElementNS(XHTML_NS, "div");
	    presetPane.className = "preset-pane";

	    let categoryList = doc.createElementNS(XHTML_NS, "div");
	    categoryList.id = "preset-categories";

	    let presetContainer = doc.createElementNS(XHTML_NS, "div");
	    presetContainer.id = "preset-container";

	    Object.keys(PRESETS).forEach(categoryLabel => {
	      let category = this._createCategory(categoryLabel);
	      categoryList.appendChild(category);

	      let presetList = this._createPresetList(categoryLabel);
	      presetContainer.appendChild(presetList);
	    });

	    presetPane.appendChild(categoryList);
	    presetPane.appendChild(presetContainer);

	    this.parent.appendChild(presetPane);

	    let allCategories = presetPane.querySelectorAll(".category");
	    let allPresets = presetPane.querySelectorAll(".preset");

	    return {
	      presetPane: presetPane,
	      presets: allPresets,
	      categories: allCategories
	    };
	  },

	  _createCategory: function (categoryLabel) {
	    let doc = this.parent.ownerDocument;

	    let category = doc.createElementNS(XHTML_NS, "div");
	    category.id = categoryLabel;
	    category.classList.add("category");

	    let categoryDisplayLabel = this._normalizeCategoryLabel(categoryLabel);
	    category.textContent = categoryDisplayLabel;
	    category.setAttribute("title", categoryDisplayLabel);

	    return category;
	  },

	  _normalizeCategoryLabel: function (categoryLabel) {
	    return categoryLabel.replace("/-/g", " ");
	  },

	  _createPresetList: function (categoryLabel) {
	    let doc = this.parent.ownerDocument;

	    let presetList = doc.createElementNS(XHTML_NS, "div");
	    presetList.id = "preset-category-" + categoryLabel;
	    presetList.classList.add("preset-list");

	    Object.keys(PRESETS[categoryLabel]).forEach(presetLabel => {
	      let preset = this._createPreset(categoryLabel, presetLabel);
	      presetList.appendChild(preset);
	    });

	    return presetList;
	  },

	  _createPreset: function (categoryLabel, presetLabel) {
	    let doc = this.parent.ownerDocument;

	    let preset = doc.createElementNS(XHTML_NS, "div");
	    preset.classList.add("preset");
	    preset.id = presetLabel;
	    preset.coordinates = PRESETS[categoryLabel][presetLabel];
	    // Create preset preview
	    let curve = doc.createElementNS(XHTML_NS, "canvas");
	    let bezier = new CubicBezier(preset.coordinates);
	    curve.setAttribute("height", 50);
	    curve.setAttribute("width", 50);
	    preset.bezierCanvas = new BezierCanvas(curve, bezier, [0.15, 0]);
	    preset.bezierCanvas.plot({
	      drawHandles: false,
	      bezierThickness: 0.025
	    });
	    preset.appendChild(curve);

	    // Create preset label
	    let presetLabelElem = doc.createElementNS(XHTML_NS, "p");
	    let presetDisplayLabel = this._normalizePresetLabel(categoryLabel,
	                                                        presetLabel);
	    presetLabelElem.textContent = presetDisplayLabel;
	    preset.appendChild(presetLabelElem);
	    preset.setAttribute("title", presetDisplayLabel);

	    return preset;
	  },

	  _normalizePresetLabel: function (categoryLabel, presetLabel) {
	    return presetLabel.replace(categoryLabel + "-", "").replace("/-/g", " ");
	  },

	  _initEvents: function () {
	    for (let category of this.categories) {
	      category.addEventListener("click", this._onCategoryClick);
	    }

	    for (let preset of this.presets) {
	      preset.addEventListener("click", this._onPresetClick);
	    }
	  },

	  _removeEvents: function () {
	    for (let category of this.categories) {
	      category.removeEventListener("click", this._onCategoryClick);
	    }

	    for (let preset of this.presets) {
	      preset.removeEventListener("click", this._onPresetClick);
	    }
	  },

	  _onPresetClick: function (event) {
	    this.emit("new-coordinates", event.currentTarget.coordinates);
	    this.activePreset = event.currentTarget;
	  },

	  _onCategoryClick: function (event) {
	    this.activeCategory = event.target;
	  },

	  _setActivePresetList: function (presetListId) {
	    let presetList = this.presetPane.querySelector("#" + presetListId);
	    swapClassName("active-preset-list", this._activePresetList, presetList);
	    this._activePresetList = presetList;
	  },

	  set activeCategory(category) {
	    swapClassName("active-category", this._activeCategory, category);
	    this._activeCategory = category;
	    this._setActivePresetList("preset-category-" + category.id);
	  },

	  get activeCategory() {
	    return this._activeCategory;
	  },

	  set activePreset(preset) {
	    swapClassName("active-preset", this._activePreset, preset);
	    this._activePreset = preset;
	  },

	  get activePreset() {
	    return this._activePreset;
	  },

	  /**
	   * Called by CubicBezierWidget onload and when
	   * the curve is modified via the canvas.
	   * Attempts to match the new user setting with an
	   * existing preset.
	   * @param {Array} coordinates new coords [i, j, k, l]
	   */
	  refreshMenu: function (coordinates) {
	    // If we cannot find a matching preset, keep
	    // menu on last known preset category.
	    let category = this._activeCategory;

	    // If we cannot find a matching preset
	    // deselect any selected preset.
	    let preset = null;

	    // If a category has never been viewed before
	    // show the default category.
	    if (!category) {
	      category = this.parent.querySelector("#" + DEFAULT_PRESET_CATEGORY);
	    }

	    // If the new coordinates do match a preset,
	    // set its category and preset button as active.
	    Object.keys(PRESETS).forEach(categoryLabel => {
	      Object.keys(PRESETS[categoryLabel]).forEach(presetLabel => {
	        if (coordsAreEqual(PRESETS[categoryLabel][presetLabel], coordinates)) {
	          category = this.parent.querySelector("#" + categoryLabel);
	          preset = this.parent.querySelector("#" + presetLabel);
	        }
	      });
	    });

	    this.activeCategory = category;
	    this.activePreset = preset;
	  },

	  destroy: function () {
	    this._removeEvents();
	    this.parent.querySelector(".preset-pane").remove();
	  }
	};

	/**
	 * The TimingFunctionPreviewWidget animates a dot on a scale with a given
	 * timing-function
	 * @param {DOMNode} parent The container where this widget should go
	 */
	function TimingFunctionPreviewWidget(parent) {
	  this.previousValue = null;
	  this.autoRestartAnimation = null;

	  this.parent = parent;
	  this._initMarkup();
	}

	TimingFunctionPreviewWidget.prototype = {
	  PREVIEW_DURATION: 1000,

	  _initMarkup: function () {
	    let doc = this.parent.ownerDocument;

	    let container = doc.createElementNS(XHTML_NS, "div");
	    container.className = "timing-function-preview";

	    this.dot = doc.createElementNS(XHTML_NS, "div");
	    this.dot.className = "dot";
	    container.appendChild(this.dot);

	    let scale = doc.createElementNS(XHTML_NS, "div");
	    scale.className = "scale";
	    container.appendChild(scale);

	    this.parent.appendChild(container);
	  },

	  destroy: function () {
	    clearTimeout(this.autoRestartAnimation);
	    this.parent.querySelector(".timing-function-preview").remove();
	    this.parent = this.dot = null;
	  },

	  /**
	   * Preview a new timing function. The current preview will only be stopped if
	   * the supplied function value is different from the previous one. If the
	   * supplied function is invalid, the preview will stop.
	   * @param {String} value
	   */
	  preview: function (value) {
	    // Don't restart the preview animation if the value is the same
	    if (value === this.previousValue) {
	      return;
	    }

	    clearTimeout(this.autoRestartAnimation);

	    if (parseTimingFunction(value)) {
	      this.dot.style.animationTimingFunction = value;
	      this.restartAnimation();
	    }

	    this.previousValue = value;
	  },

	  /**
	   * Re-start the preview animation from the beginning
	   */
	  restartAnimation: function () {
	    // Just toggling the class won't do it unless there's a sync reflow
	    this.dot.animate([
	      { left: "-7px", offset: 0 },
	      { left: "143px", offset: 0.25 },
	      { left: "143px", offset: 0.5 },
	      { left: "-7px", offset: 0.75 },
	      { left: "-7px", offset: 1 }
	    ], {
	      duration: (this.PREVIEW_DURATION * 2),
	      fill: "forwards"
	    });

	    // Restart it again after a while
	    this.autoRestartAnimation = setTimeout(this.restartAnimation.bind(this),
	      this.PREVIEW_DURATION * 2);
	  }
	};

	// Helpers

	function getPadding(padding) {
	  let p = typeof padding === "number" ? [padding] : padding;

	  if (p.length === 1) {
	    p[1] = p[0];
	  }

	  if (p.length === 2) {
	    p[2] = p[0];
	  }

	  if (p.length === 3) {
	    p[3] = p[1];
	  }

	  return p;
	}

	function distance(x1, y1, x2, y2) {
	  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}

	/**
	 * Parse a string to see whether it is a valid timing function.
	 * If it is, return the coordinates as an array.
	 * Otherwise, return undefined.
	 * @param {String} value
	 * @return {Array} of coordinates, or undefined
	 */
	function parseTimingFunction(value) {
	  if (value in PREDEFINED) {
	    return PREDEFINED[value];
	  }

	  let tokenStream = getCSSLexer(value);
	  let getNextToken = () => {
	    while (true) {
	      let token = tokenStream.nextToken();
	      if (!token || (token.tokenType !== "whitespace" &&
	                     token.tokenType !== "comment")) {
	        return token;
	      }
	    }
	  };

	  let token = getNextToken();
	  if (token.tokenType !== "function" || token.text !== "cubic-bezier") {
	    return undefined;
	  }

	  let result = [];
	  for (let i = 0; i < 4; ++i) {
	    token = getNextToken();
	    if (!token || token.tokenType !== "number") {
	      return undefined;
	    }
	    result.push(token.number);

	    token = getNextToken();
	    if (!token || token.tokenType !== "symbol" ||
	        token.text !== (i == 3 ? ")" : ",")) {
	      return undefined;
	    }
	  }

	  return result;
	}

	// This is exported for testing.
	exports._parseTimingFunction = parseTimingFunction;

	/**
	 * Removes a class from a node and adds it to another.
	 * @param {String} className the class to swap
	 * @param {DOMNode} from the node to remove the class from
	 * @param {DOMNode} to the node to add the class to
	 */
	function swapClassName(className, from, to) {
	  if (from !== null) {
	    from.classList.remove(className);
	  }

	  if (to !== null) {
	    to.classList.add(className);
	  }
	}

	/**
	 * Compares two arrays of coordinates [i, j, k, l]
	 * @param {Array} c1 first coordinate array to compare
	 * @param {Array} c2 second coordinate array to compare
	 * @return {Boolean}
	 */
	function coordsAreEqual(c1, c2) {
	  return c1.reduce((prev, curr, index) => prev && (curr === c2[index]), true);
	}


/***/ },
/* 146 */
/***/ function(module, exports) {

	/**
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 */

	// Set of preset definitions for use with CubicBezierWidget
	// Credit: http://easings.net

	"use strict";

	const PREDEFINED = {
	  "ease": [0.25, 0.1, 0.25, 1],
	  "linear": [0, 0, 1, 1],
	  "ease-in": [0.42, 0, 1, 1],
	  "ease-out": [0, 0, 0.58, 1],
	  "ease-in-out": [0.42, 0, 0.58, 1]
	};

	const PRESETS = {
	  "ease-in": {
	    "ease-in-linear": [0, 0, 1, 1],
	    "ease-in-ease-in": [0.42, 0, 1, 1],
	    "ease-in-sine": [0.47, 0, 0.74, 0.71],
	    "ease-in-quadratic": [0.55, 0.09, 0.68, 0.53],
	    "ease-in-cubic": [0.55, 0.06, 0.68, 0.19],
	    "ease-in-quartic": [0.9, 0.03, 0.69, 0.22],
	    "ease-in-quintic": [0.76, 0.05, 0.86, 0.06],
	    "ease-in-exponential": [0.95, 0.05, 0.8, 0.04],
	    "ease-in-circular": [0.6, 0.04, 0.98, 0.34],
	    "ease-in-backward": [0.6, -0.28, 0.74, 0.05]
	  },
	  "ease-out": {
	    "ease-out-linear": [0, 0, 1, 1],
	    "ease-out-ease-out": [0, 0, 0.58, 1],
	    "ease-out-sine": [0.39, 0.58, 0.57, 1],
	    "ease-out-quadratic": [0.25, 0.46, 0.45, 0.94],
	    "ease-out-cubic": [0.22, 0.61, 0.36, 1],
	    "ease-out-quartic": [0.17, 0.84, 0.44, 1],
	    "ease-out-quintic": [0.23, 1, 0.32, 1],
	    "ease-out-exponential": [0.19, 1, 0.22, 1],
	    "ease-out-circular": [0.08, 0.82, 0.17, 1],
	    "ease-out-backward": [0.18, 0.89, 0.32, 1.28]
	  },
	  "ease-in-out": {
	    "ease-in-out-linear": [0, 0, 1, 1],
	    "ease-in-out-ease": [0.25, 0.1, 0.25, 1],
	    "ease-in-out-ease-in-out": [0.42, 0, 0.58, 1],
	    "ease-in-out-sine": [0.45, 0.05, 0.55, 0.95],
	    "ease-in-out-quadratic": [0.46, 0.03, 0.52, 0.96],
	    "ease-in-out-cubic": [0.65, 0.05, 0.36, 1],
	    "ease-in-out-quartic": [0.77, 0, 0.18, 1],
	    "ease-in-out-quintic": [0.86, 0, 0.07, 1],
	    "ease-in-out-exponential": [1, 0, 0, 1],
	    "ease-in-out-circular": [0.79, 0.14, 0.15, 0.86],
	    "ease-in-out-backward": [0.68, -0.55, 0.27, 1.55]
	  }
	};

	const DEFAULT_PRESET_CATEGORY = Object.keys(PRESETS)[0];

	exports.PRESETS = PRESETS;
	exports.PREDEFINED = PREDEFINED;
	exports.DEFAULT_PRESET_CATEGORY = DEFAULT_PRESET_CATEGORY;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	  * This is a CSS Filter Editor widget used
	  * for Rule View's filter swatches
	  */

	const EventEmitter = __webpack_require__(6);
	const { Cc, Ci } = __webpack_require__(11);
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	const { LocalizationHelper } = __webpack_require__(39);
	const STRINGS_URI = "devtools/locale/filterwidget.properties";
	const L10N = new LocalizationHelper(STRINGS_URI);

	const {cssTokenizer} = __webpack_require__(132);

	const asyncStorage = __webpack_require__(148);

	// loader.lazyGetter(this, "DOMUtils", () => {
	//   return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	// });

	const DEFAULT_FILTER_TYPE = "length";
	const UNIT_MAPPING = {
	  percentage: "%",
	  length: "px",
	  angle: "deg",
	  string: ""
	};

	const FAST_VALUE_MULTIPLIER = 10;
	const SLOW_VALUE_MULTIPLIER = 0.1;
	const DEFAULT_VALUE_MULTIPLIER = 1;

	const LIST_PADDING = 7;
	const LIST_ITEM_HEIGHT = 32;

	const filterList = [
	  {
	    "name": "blur",
	    "range": [0, Infinity],
	    "type": "length"
	  },
	  {
	    "name": "brightness",
	    "range": [0, Infinity],
	    "type": "percentage"
	  },
	  {
	    "name": "contrast",
	    "range": [0, Infinity],
	    "type": "percentage"
	  },
	  {
	    "name": "drop-shadow",
	    "placeholder": L10N.getStr("dropShadowPlaceholder"),
	    "type": "string"
	  },
	  {
	    "name": "grayscale",
	    "range": [0, 100],
	    "type": "percentage"
	  },
	  {
	    "name": "hue-rotate",
	    "range": [0, Infinity],
	    "type": "angle"
	  },
	  {
	    "name": "invert",
	    "range": [0, 100],
	    "type": "percentage"
	  },
	  {
	    "name": "opacity",
	    "range": [0, 100],
	    "type": "percentage"
	  },
	  {
	    "name": "saturate",
	    "range": [0, Infinity],
	    "type": "percentage"
	  },
	  {
	    "name": "sepia",
	    "range": [0, 100],
	    "type": "percentage"
	  },
	  {
	    "name": "url",
	    "placeholder": "example.svg#c1",
	    "type": "string"
	  }
	];

	// Valid values that shouldn't be parsed for filters.
	const SPECIAL_VALUES = new Set(["none", "unset", "initial", "inherit"]);

	/**
	 * A CSS Filter editor widget used to add/remove/modify
	 * filters.
	 *
	 * Normally, it takes a CSS filter value as input, parses it
	 * and creates the required elements / bindings.
	 *
	 * You can, however, use add/remove/update methods manually.
	 * See each method's comments for more details
	 *
	 * @param {nsIDOMNode} el
	 *        The widget container.
	 * @param {String} value
	 *        CSS filter value
	 */
	function CSSFilterEditorWidget(el, value = "") {
	  this.doc = el.ownerDocument;
	  this.win = this.doc.defaultView;
	  this.el = el;

	  this._addButtonClick = this._addButtonClick.bind(this);
	  this._removeButtonClick = this._removeButtonClick.bind(this);
	  this._mouseMove = this._mouseMove.bind(this);
	  this._mouseUp = this._mouseUp.bind(this);
	  this._mouseDown = this._mouseDown.bind(this);
	  this._keyDown = this._keyDown.bind(this);
	  this._input = this._input.bind(this);
	  this._presetClick = this._presetClick.bind(this);
	  this._savePreset = this._savePreset.bind(this);
	  this._togglePresets = this._togglePresets.bind(this);
	  this._resetFocus = this._resetFocus.bind(this);

	  // Passed to asyncStorage, requires binding
	  this.renderPresets = this.renderPresets.bind(this);

	  this._initMarkup();
	  this._buildFilterItemMarkup();
	  this._buildPresetItemMarkup();
	  this._addEventListeners();

	  EventEmitter.decorate(this);

	  this.filters = [];
	  this.setCssValue(value);
	  this.renderPresets();
	}

	exports.CSSFilterEditorWidget = CSSFilterEditorWidget;

	CSSFilterEditorWidget.prototype = {
	  _initMarkup: function () {
	    let filterListSelectPlaceholder =
	      L10N.getStr("filterListSelectPlaceholder");
	    let addNewFilterButton = L10N.getStr("addNewFilterButton");
	    let presetsToggleButton = L10N.getStr("presetsToggleButton");
	    let newPresetPlaceholder = L10N.getStr("newPresetPlaceholder");
	    let savePresetButton = L10N.getStr("savePresetButton");

	    this.el.innerHTML = `
	      <div class="filters-list">
	        <div id="filters"></div>
	        <div class="footer">
	          <select value="">
	            <option value="">${filterListSelectPlaceholder}</option>
	          </select>
	          <button id="add-filter" class="add">${addNewFilterButton}</button>
	          <button id="toggle-presets">${presetsToggleButton}</button>
	        </div>
	      </div>

	      <div class="presets-list">
	        <div id="presets"></div>
	        <div class="footer">
	          <input value="" class="devtools-textinput"
	                 placeholder="${newPresetPlaceholder}"></input>
	          <button class="add">${savePresetButton}</button>
	        </div>
	      </div>
	    `;
	    this.filtersList = this.el.querySelector("#filters");
	    this.presetsList = this.el.querySelector("#presets");
	    this.togglePresets = this.el.querySelector("#toggle-presets");
	    this.filterSelect = this.el.querySelector("select");
	    this.addPresetButton = this.el.querySelector(".presets-list .add");
	    this.addPresetInput = this.el.querySelector(".presets-list .footer input");

	    this.el.querySelector(".presets-list input").value = "";

	    this._populateFilterSelect();
	  },

	  _destroyMarkup: function () {
	    this._filterItemMarkup.remove();
	    this.el.remove();
	    this.el = this.filtersList = this._filterItemMarkup = null;
	    this.presetsList = this.togglePresets = this.filterSelect = null;
	    this.addPresetButton = null;
	  },

	  destroy: function () {
	    this._removeEventListeners();
	    this._destroyMarkup();
	  },

	  /**
	    * Creates <option> elements for each filter definition
	    * in filterList
	    */
	  _populateFilterSelect: function () {
	    let select = this.filterSelect;
	    filterList.forEach(filter => {
	      let option = this.doc.createElementNS(XHTML_NS, "option");
	      option.innerHTML = option.value = filter.name;
	      select.appendChild(option);
	    });
	  },

	  /**
	    * Creates a template for filter elements which is cloned and used in render
	    */
	  _buildFilterItemMarkup: function () {
	    let base = this.doc.createElementNS(XHTML_NS, "div");
	    base.className = "filter";

	    let name = this.doc.createElementNS(XHTML_NS, "div");
	    name.className = "filter-name";

	    let value = this.doc.createElementNS(XHTML_NS, "div");
	    value.className = "filter-value";

	    let drag = this.doc.createElementNS(XHTML_NS, "i");
	    drag.title = L10N.getStr("dragHandleTooltipText");

	    let label = this.doc.createElementNS(XHTML_NS, "label");

	    name.appendChild(drag);
	    name.appendChild(label);

	    let unitPreview = this.doc.createElementNS(XHTML_NS, "span");
	    let input = this.doc.createElementNS(XHTML_NS, "input");
	    input.classList.add("devtools-textinput");

	    value.appendChild(input);
	    value.appendChild(unitPreview);

	    let removeButton = this.doc.createElementNS(XHTML_NS, "button");
	    removeButton.className = "remove-button";

	    base.appendChild(name);
	    base.appendChild(value);
	    base.appendChild(removeButton);

	    this._filterItemMarkup = base;
	  },

	  _buildPresetItemMarkup: function () {
	    let base = this.doc.createElementNS(XHTML_NS, "div");
	    base.classList.add("preset");

	    let name = this.doc.createElementNS(XHTML_NS, "label");
	    base.appendChild(name);

	    let value = this.doc.createElementNS(XHTML_NS, "span");
	    base.appendChild(value);

	    let removeButton = this.doc.createElementNS(XHTML_NS, "button");
	    removeButton.classList.add("remove-button");

	    base.appendChild(removeButton);

	    this._presetItemMarkup = base;
	  },

	  _addEventListeners: function () {
	    this.addButton = this.el.querySelector("#add-filter");
	    this.addButton.addEventListener("click", this._addButtonClick);
	    this.filtersList.addEventListener("click", this._removeButtonClick);
	    this.filtersList.addEventListener("mousedown", this._mouseDown);
	    this.filtersList.addEventListener("keydown", this._keyDown);
	    this.el.addEventListener("mousedown", this._resetFocus);

	    this.presetsList.addEventListener("click", this._presetClick);
	    this.togglePresets.addEventListener("click", this._togglePresets);
	    this.addPresetButton.addEventListener("click", this._savePreset);

	    // These events are event delegators for
	    // drag-drop re-ordering and label-dragging
	    this.win.addEventListener("mousemove", this._mouseMove);
	    this.win.addEventListener("mouseup", this._mouseUp);

	    // Used to workaround float-precision problems
	    this.filtersList.addEventListener("input", this._input);
	  },

	  _removeEventListeners: function () {
	    this.addButton.removeEventListener("click", this._addButtonClick);
	    this.filtersList.removeEventListener("click", this._removeButtonClick);
	    this.filtersList.removeEventListener("mousedown", this._mouseDown);
	    this.filtersList.removeEventListener("keydown", this._keyDown);
	    this.el.removeEventListener("mousedown", this._resetFocus);

	    this.presetsList.removeEventListener("click", this._presetClick);
	    this.togglePresets.removeEventListener("click", this._togglePresets);
	    this.addPresetButton.removeEventListener("click", this._savePreset);

	    // These events are used for drag drop re-ordering
	    this.win.removeEventListener("mousemove", this._mouseMove);
	    this.win.removeEventListener("mouseup", this._mouseUp);

	    // Used to workaround float-precision problems
	    this.filtersList.removeEventListener("input", this._input);
	  },

	  _getFilterElementIndex: function (el) {
	    return [...this.filtersList.children].indexOf(el);
	  },

	  _keyDown: function (e) {
	    if (e.target.tagName.toLowerCase() !== "input" ||
	       (e.keyCode !== 40 && e.keyCode !== 38)) {
	      return;
	    }
	    let input = e.target;

	    const direction = e.keyCode === 40 ? -1 : 1;

	    let multiplier = DEFAULT_VALUE_MULTIPLIER;
	    if (e.altKey) {
	      multiplier = SLOW_VALUE_MULTIPLIER;
	    } else if (e.shiftKey) {
	      multiplier = FAST_VALUE_MULTIPLIER;
	    }

	    const filterEl = e.target.closest(".filter");
	    const index = this._getFilterElementIndex(filterEl);
	    const filter = this.filters[index];

	    // Filters that have units are number-type filters. For them,
	    // the value can be incremented/decremented simply.
	    // For other types of filters (e.g. drop-shadow) we need to check
	    // if the keypress happened close to a number first.
	    if (filter.unit) {
	      let startValue = parseFloat(e.target.value);
	      let value = startValue + direction * multiplier;

	      const [min, max] = this._definition(filter.name).range;
	      if (value < min) {
	        value = min;
	      } else if (value > max) {
	        value = max;
	      }

	      input.value = fixFloat(value);

	      this.updateValueAt(index, value);
	    } else {
	      let selectionStart = input.selectionStart;
	      let num = getNeighbourNumber(input.value, selectionStart);
	      if (!num) {
	        return;
	      }

	      let {start, end, value} = num;

	      let split = input.value.split("");
	      let computed = fixFloat(value + direction * multiplier);
	      let dotIndex = computed.indexOf(".0");
	      if (dotIndex > -1) {
	        computed = computed.slice(0, -2);

	        selectionStart = selectionStart > start + dotIndex ?
	                                          start + dotIndex :
	                                          selectionStart;
	      }
	      split.splice(start, end - start, computed);

	      value = split.join("");
	      input.value = value;
	      this.updateValueAt(index, value);
	      input.setSelectionRange(selectionStart, selectionStart);
	    }
	    e.preventDefault();
	  },

	  _input: function (e) {
	    let filterEl = e.target.closest(".filter");
	    let index = this._getFilterElementIndex(filterEl);
	    let filter = this.filters[index];
	    let def = this._definition(filter.name);

	    if (def.type !== "string") {
	      e.target.value = fixFloat(e.target.value);
	    }
	    this.updateValueAt(index, e.target.value);
	  },

	  _mouseDown: function (e) {
	    let filterEl = e.target.closest(".filter");

	    // re-ordering drag handle
	    if (e.target.tagName.toLowerCase() === "i") {
	      this.isReorderingFilter = true;
	      filterEl.startingY = e.pageY;
	      filterEl.classList.add("dragging");

	      this.el.classList.add("dragging");
	    // label-dragging
	    } else if (e.target.classList.contains("devtools-draglabel")) {
	      let label = e.target;
	      let input = filterEl.querySelector("input");
	      let index = this._getFilterElementIndex(filterEl);

	      this._dragging = {
	        index, label, input,
	        startX: e.pageX
	      };

	      this.isDraggingLabel = true;
	    }
	  },

	  _addButtonClick: function () {
	    const select = this.filterSelect;
	    if (!select.value) {
	      return;
	    }

	    const key = select.value;
	    this.add(key, null);

	    this.render();
	  },

	  _removeButtonClick: function (e) {
	    const isRemoveButton = e.target.classList.contains("remove-button");
	    if (!isRemoveButton) {
	      return;
	    }

	    let filterEl = e.target.closest(".filter");
	    let index = this._getFilterElementIndex(filterEl);
	    this.removeAt(index);
	  },

	  _mouseMove: function (e) {
	    if (this.isReorderingFilter) {
	      this._dragFilterElement(e);
	    } else if (this.isDraggingLabel) {
	      this._dragLabel(e);
	    }
	  },

	  _dragFilterElement: function (e) {
	    const rect = this.filtersList.getBoundingClientRect();
	    let top = e.pageY - LIST_PADDING;
	    let bottom = e.pageY + LIST_PADDING;
	    // don't allow dragging over top/bottom of list
	    if (top < rect.top || bottom > rect.bottom) {
	      return;
	    }

	    const filterEl = this.filtersList.querySelector(".dragging");

	    const delta = e.pageY - filterEl.startingY;
	    filterEl.style.top = delta + "px";

	    // change is the number of _steps_ taken from initial position
	    // i.e. how many elements we have passed
	    let change = delta / LIST_ITEM_HEIGHT;
	    if (change > 0) {
	      change = Math.floor(change);
	    } else if (change < 0) {
	      change = Math.ceil(change);
	    }

	    const children = this.filtersList.children;
	    const index = [...children].indexOf(filterEl);
	    const destination = index + change;

	    // If we're moving out, or there's no change at all, stop and return
	    if (destination >= children.length || destination < 0 || change === 0) {
	      return;
	    }

	    // Re-order filter objects
	    swapArrayIndices(this.filters, index, destination);

	    // Re-order the dragging element in markup
	    const target = change > 0 ? children[destination + 1]
	                              : children[destination];
	    if (target) {
	      this.filtersList.insertBefore(filterEl, target);
	    } else {
	      this.filtersList.appendChild(filterEl);
	    }

	    filterEl.removeAttribute("style");

	    const currentPosition = change * LIST_ITEM_HEIGHT;
	    filterEl.startingY = e.pageY + currentPosition - delta;
	  },

	  _dragLabel: function (e) {
	    let dragging = this._dragging;

	    let input = dragging.input;

	    let multiplier = DEFAULT_VALUE_MULTIPLIER;

	    if (e.altKey) {
	      multiplier = SLOW_VALUE_MULTIPLIER;
	    } else if (e.shiftKey) {
	      multiplier = FAST_VALUE_MULTIPLIER;
	    }

	    dragging.lastX = e.pageX;
	    const delta = e.pageX - dragging.startX;
	    const startValue = parseFloat(input.value);
	    let value = startValue + delta * multiplier;

	    const filter = this.filters[dragging.index];
	    const [min, max] = this._definition(filter.name).range;
	    if (value < min) {
	      value = min;
	    } else if (value > max) {
	      value = max;
	    }

	    input.value = fixFloat(value);

	    dragging.startX = e.pageX;

	    this.updateValueAt(dragging.index, value);
	  },

	  _mouseUp: function () {
	    // Label-dragging is disabled on mouseup
	    this._dragging = null;
	    this.isDraggingLabel = false;

	    // Filter drag/drop needs more cleaning
	    if (!this.isReorderingFilter) {
	      return;
	    }
	    let filterEl = this.filtersList.querySelector(".dragging");

	    this.isReorderingFilter = false;
	    filterEl.classList.remove("dragging");
	    this.el.classList.remove("dragging");
	    filterEl.removeAttribute("style");

	    this.emit("updated", this.getCssValue());
	    this.render();
	  },

	  _presetClick: function (e) {
	    let el = e.target;
	    let preset = el.closest(".preset");
	    if (!preset) {
	      return;
	    }

	    let id = +preset.dataset.id;

	    this.getPresets().then(presets => {
	      if (el.classList.contains("remove-button")) {
	        // If the click happened on the remove button.
	        presets.splice(id, 1);
	        this.setPresets(presets).then(this.renderPresets,
	                                      ex => console.error(ex));
	      } else {
	        // Or if the click happened on a preset.
	        let p = presets[id];

	        this.setCssValue(p.value);
	        this.addPresetInput.value = p.name;
	      }
	    }, ex => console.error(ex));
	  },

	  _togglePresets: function () {
	    this.el.classList.toggle("show-presets");
	    this.emit("render");
	  },

	  _savePreset: function (e) {
	    e.preventDefault();

	    let name = this.addPresetInput.value;
	    let value = this.getCssValue();

	    if (!name || !value || SPECIAL_VALUES.has(value)) {
	      this.emit("preset-save-error");
	      return;
	    }

	    this.getPresets().then(presets => {
	      let index = presets.findIndex(preset => preset.name === name);

	      if (index > -1) {
	        presets[index].value = value;
	      } else {
	        presets.push({name, value});
	      }

	      this.setPresets(presets).then(this.renderPresets,
	                                    ex => console.error(ex));
	    }, ex => console.error(ex));
	  },

	  /**
	   * Workaround needed to reset the focus when using a HTML select inside a XUL panel.
	   * See Bug 1294366.
	   */
	  _resetFocus: function () {
	    this.filterSelect.ownerDocument.defaultView.focus();
	  },

	  /**
	   * Clears the list and renders filters, binding required events.
	   * There are some delegated events bound in _addEventListeners method
	   */
	  render: function () {
	    if (!this.filters.length) {
	      this.filtersList.innerHTML = `<p> ${L10N.getStr("emptyFilterList")} <br />
	                                 ${L10N.getStr("addUsingList")} </p>`;
	      this.emit("render");
	      return;
	    }

	    this.filtersList.innerHTML = "";

	    let base = this._filterItemMarkup;

	    for (let filter of this.filters) {
	      const def = this._definition(filter.name);

	      let el = base.cloneNode(true);

	      let [name, value] = el.children;
	      let label = name.children[1];
	      let [input, unitPreview] = value.children;

	      let min, max;
	      if (def.range) {
	        [min, max] = def.range;
	      }

	      label.textContent = filter.name;
	      input.value = filter.value;

	      switch (def.type) {
	        case "percentage":
	        case "angle":
	        case "length":
	          input.type = "number";
	          input.min = min;
	          if (max !== Infinity) {
	            input.max = max;
	          }
	          input.step = "0.1";
	          break;
	        case "string":
	          input.type = "text";
	          input.placeholder = def.placeholder;
	          break;
	      }

	      // use photoshop-style label-dragging
	      // and show filters' unit next to their <input>
	      if (def.type !== "string") {
	        unitPreview.textContent = filter.unit;

	        label.classList.add("devtools-draglabel");
	        label.title = L10N.getStr("labelDragTooltipText");
	      } else {
	        // string-type filters have no unit
	        unitPreview.remove();
	      }

	      this.filtersList.appendChild(el);
	    }

	    let lastInput =
	        this.filtersList.querySelector(".filter:last-of-type input");
	    if (lastInput) {
	      lastInput.focus();
	      if (lastInput.type === "text") {
	        // move cursor to end of input
	        const end = lastInput.value.length;
	        lastInput.setSelectionRange(end, end);
	      }
	    }

	    this.emit("render");
	  },

	  renderPresets: function () {
	    this.getPresets().then(presets => {
	      // getPresets is async and the widget may be destroyed in between.
	      if (!this.presetsList) {
	        return;
	      }

	      if (!presets || !presets.length) {
	        this.presetsList.innerHTML = `<p>${L10N.getStr("emptyPresetList")}</p>`;
	        this.emit("render");
	        return;
	      }
	      let base = this._presetItemMarkup;

	      this.presetsList.innerHTML = "";

	      for (let [index, preset] of presets.entries()) {
	        let el = base.cloneNode(true);

	        let [label, span] = el.children;

	        el.dataset.id = index;

	        label.textContent = preset.name;
	        span.textContent = preset.value;

	        this.presetsList.appendChild(el);
	      }

	      this.emit("render");
	    });
	  },

	  /**
	    * returns definition of a filter as defined in filterList
	    *
	    * @param {String} name
	    *        filter name (e.g. blur)
	    * @return {Object}
	    *        filter's definition
	    */
	  _definition: function (name) {
	    name = name.toLowerCase();
	    return filterList.find(a => a.name === name);
	  },

	  /**
	    * Parses the CSS value specified, updating widget's filters
	    *
	    * @param {String} cssValue
	    *        css value to be parsed
	    */
	  setCssValue: function (cssValue) {
	    if (!cssValue) {
	      throw new Error("Missing CSS filter value in setCssValue");
	    }

	    this.filters = [];

	    if (SPECIAL_VALUES.has(cssValue)) {
	      this._specialValue = cssValue;
	      this.emit("updated", this.getCssValue());
	      this.render();
	      return;
	    }

	    for (let {name, value, quote} of tokenizeFilterValue(cssValue)) {
	      // If the specified value is invalid, replace it with the
	      // default.
	      if (name !== "url") {
	        if (!DOMUtils.cssPropertyIsValid("filter", name + "(" + value + ")")) {
	          value = null;
	        }
	      }

	      this.add(name, value, quote, true);
	    }

	    this.emit("updated", this.getCssValue());
	    this.render();
	  },

	  /**
	    * Creates a new [name] filter record with value
	    *
	    * @param {String} name
	    *        filter name (e.g. blur)
	    * @param {String} value
	    *        value of the filter (e.g. 30px, 20%)
	    *        If this is |null|, then a default value may be supplied.
	    * @param {String} quote
	    *        For a url filter, the quoting style.  This can be a
	    *        single quote, a double quote, or empty.
	    * @return {Number}
	    *        The index of the new filter in the current list of filters
	    * @param {Boolean}
	    *        By default, adding a new filter emits an "updated" event, but if
	    *        you're calling add in a loop and wait to emit a single event after
	    *        the loop yourself, set this parameter to true.
	    */
	  add: function (name, value, quote, noEvent) {
	    const def = this._definition(name);
	    if (!def) {
	      return false;
	    }

	    if (value === null) {
	      // UNIT_MAPPING[string] is an empty string (falsy), so
	      // using || doesn't work here
	      const unitLabel = typeof UNIT_MAPPING[def.type] === "undefined" ?
	                               UNIT_MAPPING[DEFAULT_FILTER_TYPE] :
	                               UNIT_MAPPING[def.type];

	      // string-type filters have no default value but a placeholder instead
	      if (!unitLabel) {
	        value = "";
	      } else {
	        value = def.range[0] + unitLabel;
	      }

	      if (name === "url") {
	        // Default quote.
	        quote = "\"";
	      }
	    }

	    let unit = def.type === "string"
	               ? ""
	               : (/[a-zA-Z%]+/.exec(value) || [])[0];

	    if (def.type !== "string") {
	      value = parseFloat(value);

	      // You can omit percentage values' and use a value between 0..1
	      if (def.type === "percentage" && !unit) {
	        value = value * 100;
	        unit = "%";
	      }

	      const [min, max] = def.range;
	      if (value < min) {
	        value = min;
	      } else if (value > max) {
	        value = max;
	      }
	    }

	    const index = this.filters.push({value, unit, name, quote}) - 1;
	    if (!noEvent) {
	      this.emit("updated", this.getCssValue());
	    }

	    return index;
	  },

	  /**
	    * returns value + unit of the specified filter
	    *
	    * @param {Number} index
	    *        filter index
	    * @return {String}
	    *        css value of filter
	    */
	  getValueAt: function (index) {
	    let filter = this.filters[index];
	    if (!filter) {
	      return null;
	    }

	    // Just return the value+unit for non-url functions.
	    if (filter.name !== "url") {
	      return filter.value + filter.unit;
	    }

	    // url values need to be quoted and escaped.
	    if (filter.quote === "'") {
	      return "'" + filter.value.replace(/\'/g, "\\'") + "'";
	    } else if (filter.quote === "\"") {
	      return "\"" + filter.value.replace(/\"/g, "\\\"") + "\"";
	    }

	    // Unquoted.  This approach might change the original input -- for
	    // example the original might be over-quoted.  But, this is
	    // correct and probably good enough.
	    return filter.value.replace(/[\\ \t()"']/g, "\\$&");
	  },

	  removeAt: function (index) {
	    if (!this.filters[index]) {
	      return;
	    }

	    this.filters.splice(index, 1);
	    this.emit("updated", this.getCssValue());
	    this.render();
	  },

	  /**
	    * Generates CSS filter value for filters of the widget
	    *
	    * @return {String}
	    *        css value of filters
	    */
	  getCssValue: function () {
	    return this.filters.map((filter, i) => {
	      return `${filter.name}(${this.getValueAt(i)})`;
	    }).join(" ") || this._specialValue || "none";
	  },

	  /**
	    * Updates specified filter's value
	    *
	    * @param {Number} index
	    *        The index of the filter in the current list of filters
	    * @param {number/string} value
	    *        value to set, string for string-typed filters
	    *        number for the rest (unit automatically determined)
	    */
	  updateValueAt: function (index, value) {
	    let filter = this.filters[index];
	    if (!filter) {
	      return;
	    }

	    const def = this._definition(filter.name);

	    if (def.type !== "string") {
	      const [min, max] = def.range;
	      if (value < min) {
	        value = min;
	      } else if (value > max) {
	        value = max;
	      }
	    }

	    filter.value = filter.unit ? fixFloat(value, true) : value;

	    this.emit("updated", this.getCssValue());
	  },

	  getPresets: function () {
	    return asyncStorage.getItem("cssFilterPresets").then(presets => {
	      if (!presets) {
	        return [];
	      }

	      return presets;
	    }, e => console.error(e));
	  },

	  setPresets: function (presets) {
	    return asyncStorage.setItem("cssFilterPresets", presets)
	      .catch(e => console.error(e));
	  }
	};

	// Fixes JavaScript's float precision
	function fixFloat(a, number) {
	  let fixed = parseFloat(a).toFixed(1);
	  return number ? parseFloat(fixed) : fixed;
	}

	/**
	 * Used to swap two filters' indexes
	 * after drag/drop re-ordering
	 *
	 * @param {Array} array
	 *        the array to swap elements of
	 * @param {Number} a
	 *        index of first element
	 * @param {Number} b
	 *        index of second element
	 */
	function swapArrayIndices(array, a, b) {
	  array[a] = array.splice(b, 1, array[a])[0];
	}

	/**
	 * Tokenizes a CSS Filter value and returns an array of {name, value} pairs.
	 *
	 * @param {String} css CSS Filter value to be parsed
	 * @return {Array} An array of {name, value} pairs
	 */
	function tokenizeFilterValue(css) {
	  let filters = [];
	  let depth = 0;

	  if (SPECIAL_VALUES.has(css)) {
	    return filters;
	  }

	  let state = "initial";
	  let name;
	  let contents;
	  for (let token of cssTokenizer(css)) {
	    switch (state) {
	      case "initial":
	        if (token.tokenType === "function") {
	          name = token.text;
	          contents = "";
	          state = "function";
	          depth = 1;
	        } else if (token.tokenType === "url" || token.tokenType === "bad_url") {
	          // Extract the quoting style from the url.
	          let originalText = css.substring(token.startOffset, token.endOffset);
	          let [, quote] = /^url\([ \t\r\n\f]*(["']?)/i.exec(originalText);

	          filters.push({name: "url", value: token.text.trim(), quote: quote});
	          // Leave state as "initial" because the URL token includes
	          // the trailing close paren.
	        }
	        break;

	      case "function":
	        if (token.tokenType === "symbol" && token.text === ")") {
	          --depth;
	          if (depth === 0) {
	            filters.push({name: name, value: contents.trim()});
	            state = "initial";
	            break;
	          }
	        }
	        contents += css.substring(token.startOffset, token.endOffset);
	        if (token.tokenType === "function" ||
	            (token.tokenType === "symbol" && token.text === "(")) {
	          ++depth;
	        }
	        break;
	    }
	  }

	  return filters;
	}

	/**
	  * Finds neighbour number characters of an index in a string
	  * the numbers may be floats (containing dots)
	  * It's assumed that the value given to this function is a valid number
	  *
	  * @param {String} string
	  *        The string containing numbers
	  * @param {Number} index
	  *        The index to look for neighbours for
	  * @return {Object}
	  *         returns null if no number is found
	  *         value: The number found
	  *         start: The number's starting index
	  *         end: The number's ending index
	  */
	function getNeighbourNumber(string, index) {
	  if (!/\d/.test(string)) {
	    return null;
	  }

	  let left = /-?[0-9.]*$/.exec(string.slice(0, index));
	  let right = /-?[0-9.]*/.exec(string.slice(index));

	  left = left ? left[0] : "";
	  right = right ? right[0] : "";

	  if (!right && !left) {
	    return null;
	  }

	  return {
	    value: fixFloat(left + right, true),
	    start: index - left.length,
	    end: index + right.length
	  };
	}


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *
	 * Adapted from https://github.com/mozilla-b2g/gaia/blob/f09993563fb5fec4393eb71816ce76cb00463190/shared/js/async_storage.js
	 * (converted to use Promises instead of callbacks).
	 *
	 * This file defines an asynchronous version of the localStorage API, backed by
	 * an IndexedDB database.  It creates a global asyncStorage object that has
	 * methods like the localStorage object.
	 *
	 * To store a value use setItem:
	 *
	 *   asyncStorage.setItem("key", "value");
	 *
	 * This returns a promise in case you want confirmation that the value has been stored.
	 *
	 *  asyncStorage.setItem("key", "newvalue").then(function() {
	 *    console.log("new value stored");
	 *  });
	 *
	 * To read a value, call getItem(), but note that you must wait for a promise
	 * resolution for the value to be retrieved.
	 *
	 *  asyncStorage.getItem("key").then(function(value) {
	 *    console.log("The value of key is:", value);
	 *  });
	 *
	 * Note that unlike localStorage, asyncStorage does not allow you to store and
	 * retrieve values by setting and querying properties directly. You cannot just
	 * write asyncStorage.key; you have to explicitly call setItem() or getItem().
	 *
	 * removeItem(), clear(), length(), and key() are like the same-named methods of
	 * localStorage, and all return a promise.
	 *
	 * The asynchronous nature of getItem() makes it tricky to retrieve multiple
	 * values. But unlike localStorage, asyncStorage does not require the values you
	 * store to be strings.  So if you need to save multiple values and want to
	 * retrieve them together, in a single asynchronous operation, just group the
	 * values into a single object. The properties of this object may not include
	 * DOM elements, but they may include things like Blobs and typed arrays.
	 *
	 */

	"use strict";

	const Promise = __webpack_require__(4);

	const DBNAME = "devtools-async-storage";
	const DBVERSION = 1;
	const STORENAME = "keyvaluepairs";
	var db = null;

	function withStore(type, onsuccess, onerror) {
	  if (db) {
	    let transaction = db.transaction(STORENAME, type);
	    let store = transaction.objectStore(STORENAME);
	    onsuccess(store);
	  } else {
	    let openreq = indexedDB.open(DBNAME, DBVERSION);
	    openreq.onerror = function withStoreOnError() {
	      onerror();
	    };
	    openreq.onupgradeneeded = function withStoreOnUpgradeNeeded() {
	      // First time setup: create an empty object store
	      openreq.result.createObjectStore(STORENAME);
	    };
	    openreq.onsuccess = function withStoreOnSuccess() {
	      db = openreq.result;
	      let transaction = db.transaction(STORENAME, type);
	      let store = transaction.objectStore(STORENAME);
	      onsuccess(store);
	    };
	  }
	}

	function getItem(itemKey) {
	  return new Promise((resolve, reject) => {
	    let req;
	    withStore("readonly", (store) => {
	      store.transaction.oncomplete = function onComplete() {
	        let value = req.result;
	        if (value === undefined) {
	          value = null;
	        }
	        resolve(value);
	      };
	      req = store.get(itemKey);
	      req.onerror = function getItemOnError() {
	        reject("Error in asyncStorage.getItem(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function setItem(itemKey, value) {
	  return new Promise((resolve, reject) => {
	    withStore("readwrite", (store) => {
	      store.transaction.oncomplete = resolve;
	      let req = store.put(value, itemKey);
	      req.onerror = function setItemOnError() {
	        reject("Error in asyncStorage.setItem(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function removeItem(itemKey) {
	  return new Promise((resolve, reject) => {
	    withStore("readwrite", (store) => {
	      store.transaction.oncomplete = resolve;
	      let req = store.delete(itemKey);
	      req.onerror = function removeItemOnError() {
	        reject("Error in asyncStorage.removeItem(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function clear() {
	  return new Promise((resolve, reject) => {
	    withStore("readwrite", (store) => {
	      store.transaction.oncomplete = resolve;
	      let req = store.clear();
	      req.onerror = function clearOnError() {
	        reject("Error in asyncStorage.clear(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function length() {
	  return new Promise((resolve, reject) => {
	    let req;
	    withStore("readonly", (store) => {
	      store.transaction.oncomplete = function onComplete() {
	        resolve(req.result);
	      };
	      req = store.count();
	      req.onerror = function lengthOnError() {
	        reject("Error in asyncStorage.length(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function key(n) {
	  return new Promise((resolve, reject) => {
	    if (n < 0) {
	      resolve(null);
	      return;
	    }

	    let req;
	    withStore("readonly", (store) => {
	      store.transaction.oncomplete = function onComplete() {
	        let cursor = req.result;
	        resolve(cursor ? cursor.key : null);
	      };
	      let advanced = false;
	      req = store.openCursor();
	      req.onsuccess = function keyOnSuccess() {
	        let cursor = req.result;
	        if (!cursor) {
	          // this means there weren"t enough keys
	          return;
	        }
	        if (n === 0 || advanced) {
	          // Either 1) we have the first key, return it if that's what they
	          // wanted, or 2) we"ve got the nth key.
	          return;
	        }

	        // Otherwise, ask the cursor to skip ahead n records
	        advanced = true;
	        cursor.advance(n);
	      };
	      req.onerror = function keyOnError() {
	        reject("Error in asyncStorage.key(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	exports.getItem = getItem;
	exports.setItem = setItem;
	exports.removeItem = removeItem;
	exports.clear = clear;
	exports.length = length;
	exports.key = key;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* globals gDevTools */

	"use strict";

	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);
	const Services = __webpack_require__(1);
	const {Task} = __webpack_require__(17);
	const {Tools} = __webpack_require__(38);
	const {l10n} = __webpack_require__(122);
	const {ELEMENT_STYLE} = __webpack_require__(124);
	const {OutputParser} = __webpack_require__(127);
	const {PrefObserver, PREF_ORIG_SOURCES} = __webpack_require__(130);
	const {ElementStyle} = __webpack_require__(150);
	const {Rule} = __webpack_require__(151);
	const {RuleEditor} = __webpack_require__(153);
	const {createChild, promiseWarn, throttle} = __webpack_require__(131);
	const {gDevTools} = __webpack_require__(133);
	const {getCssProperties} = __webpack_require__(18);

	const overlays = __webpack_require__(134);
	const EventEmitter = __webpack_require__(6);
	const StyleInspectorMenu = __webpack_require__(157);
	const {KeyShortcuts} = __webpack_require__(15);
	const clipboardHelper = __webpack_require__(158);

	const {AutocompletePopup} = __webpack_require__(159);

	const HTML_NS = "http://www.w3.org/1999/xhtml";
	const PREF_UA_STYLES = "devtools.inspector.showUserAgentStyles";
	const PREF_DEFAULT_COLOR_UNIT = "devtools.defaultColorUnit";
	const PREF_ENABLE_MDN_DOCS_TOOLTIP =
	      "devtools.inspector.mdnDocsTooltip.enabled";
	const FILTER_CHANGED_TIMEOUT = 150;

	// This is used to parse user input when filtering.
	const FILTER_PROP_RE = /\s*([^:\s]*)\s*:\s*(.*?)\s*;?$/;
	// This is used to parse the filter search value to see if the filter
	// should be strict or not
	const FILTER_STRICT_RE = /\s*`(.*?)`\s*$/;

	/**
	 * Our model looks like this:
	 *
	 * ElementStyle:
	 *   Responsible for keeping track of which properties are overridden.
	 *   Maintains a list of Rule objects that apply to the element.
	 * Rule:
	 *   Manages a single style declaration or rule.
	 *   Responsible for applying changes to the properties in a rule.
	 *   Maintains a list of TextProperty objects.
	 * TextProperty:
	 *   Manages a single property from the authoredText attribute of the
	 *     relevant declaration.
	 *   Maintains a list of computed properties that come from this
	 *     property declaration.
	 *   Changes to the TextProperty are sent to its related Rule for
	 *     application.
	 *
	 * View hierarchy mostly follows the model hierarchy.
	 *
	 * CssRuleView:
	 *   Owns an ElementStyle and creates a list of RuleEditors for its
	 *    Rules.
	 * RuleEditor:
	 *   Owns a Rule object and creates a list of TextPropertyEditors
	 *     for its TextProperties.
	 *   Manages creation of new text properties.
	 * TextPropertyEditor:
	 *   Owns a TextProperty object.
	 *   Manages changes to the TextProperty.
	 *   Can be expanded to display computed properties.
	 *   Can mark a property disabled or enabled.
	 */

	/**
	 * To figure out how shorthand properties are interpreted by the
	 * engine, we will set properties on a dummy element and observe
	 * how their .style attribute reflects them as computed values.
	 * This function creates the document in which those dummy elements
	 * will be created.
	 */
	var gDummyPromise;
	function createDummyDocument() {
	  if (gDummyPromise) {
	    return gDummyPromise;
	  }
	  const { getDocShell, create: makeFrame } = __webpack_require__(160);

	  let frame = makeFrame(Services.appShell.hiddenDOMWindow.document, {
	    nodeName: "iframe",
	    namespaceURI: "http://www.w3.org/1999/xhtml",
	    allowJavascript: false,
	    allowPlugins: false,
	    allowAuth: false
	  });
	  let docShell = getDocShell(frame);
	  let eventTarget = docShell.chromeEventHandler;
	  let ssm = Services.scriptSecurityManager;

	  // We probably need to call InheritFromDocShellToDoc to get the correct origin
	  // attributes, but right now we can't call it from JS.
	  let nullPrincipal = ssm.createNullPrincipal(docShell.getOriginAttributes());
	  docShell.createAboutBlankContentViewer(nullPrincipal);
	  let window = docShell.contentViewer.DOMDocument.defaultView;
	  window.location = "data:text/html,<html></html>";
	  let deferred = defer();
	  eventTarget.addEventListener("DOMContentLoaded", function handler() {
	    eventTarget.removeEventListener("DOMContentLoaded", handler, false);
	    deferred.resolve(window.document);
	    frame.remove();
	  }, false);
	  gDummyPromise = deferred.promise;
	  return gDummyPromise;
	}

	/**
	 * CssRuleView is a view of the style rules and declarations that
	 * apply to a given element.  After construction, the 'element'
	 * property will be available with the user interface.
	 *
	 * @param {Inspector} inspector
	 *        Inspector toolbox panel
	 * @param {Document} document
	 *        The document that will contain the rule view.
	 * @param {Object} store
	 *        The CSS rule view can use this object to store metadata
	 *        that might outlast the rule view, particularly the current
	 *        set of disabled properties.
	 * @param {PageStyleFront} pageStyle
	 *        The PageStyleFront for communicating with the remote server.
	 */
	function CssRuleView(inspector, document, store, pageStyle) {
	  this.inspector = inspector;
	  this.styleDocument = document;
	  this.styleWindow = this.styleDocument.defaultView;
	  this.store = store || {};
	  this.pageStyle = pageStyle;

	  // Allow tests to override throttling behavior, as this can cause intermittents.
	  this.throttle = throttle;

	  this.cssProperties = getCssProperties(inspector.toolbox);

	  this._outputParser = new OutputParser(document, this.cssProperties.supportsType);

	  this._onAddRule = this._onAddRule.bind(this);
	  this._onContextMenu = this._onContextMenu.bind(this);
	  this._onCopy = this._onCopy.bind(this);
	  this._onFilterStyles = this._onFilterStyles.bind(this);
	  this._onClearSearch = this._onClearSearch.bind(this);
	  this._onFilterTextboxContextMenu =
	    this._onFilterTextboxContextMenu.bind(this);
	  this._onTogglePseudoClassPanel = this._onTogglePseudoClassPanel.bind(this);
	  this._onTogglePseudoClass = this._onTogglePseudoClass.bind(this);

	  let doc = this.styleDocument;
	  this.element = doc.getElementById("ruleview-container-focusable");
	  this.addRuleButton = doc.getElementById("ruleview-add-rule-button");
	  this.searchField = doc.getElementById("ruleview-searchbox");
	  this.searchClearButton = doc.getElementById("ruleview-searchinput-clear");
	  this.pseudoClassPanel = doc.getElementById("pseudo-class-panel");
	  this.pseudoClassToggle = doc.getElementById("pseudo-class-panel-toggle");
	  this.hoverCheckbox = doc.getElementById("pseudo-hover-toggle");
	  this.activeCheckbox = doc.getElementById("pseudo-active-toggle");
	  this.focusCheckbox = doc.getElementById("pseudo-focus-toggle");

	  this.searchClearButton.hidden = true;

	  this.shortcuts = new KeyShortcuts({ window: this.styleWindow });
	  this._onShortcut = this._onShortcut.bind(this);
	  this.shortcuts.on("Escape", this._onShortcut);
	  this.shortcuts.on("Return", this._onShortcut);
	  this.shortcuts.on("Space", this._onShortcut);
	  this.shortcuts.on("CmdOrCtrl+F", this._onShortcut);
	  this.element.addEventListener("copy", this._onCopy);
	  this.element.addEventListener("contextmenu", this._onContextMenu);
	  this.addRuleButton.addEventListener("click", this._onAddRule);
	  this.searchField.addEventListener("input", this._onFilterStyles);
	  this.searchField.addEventListener("contextmenu",
	                                    this._onFilterTextboxContextMenu);
	  this.searchClearButton.addEventListener("click", this._onClearSearch);
	  this.pseudoClassToggle.addEventListener("click",
	                                          this._onTogglePseudoClassPanel);
	  this.hoverCheckbox.addEventListener("click", this._onTogglePseudoClass);
	  this.activeCheckbox.addEventListener("click", this._onTogglePseudoClass);
	  this.focusCheckbox.addEventListener("click", this._onTogglePseudoClass);

	  this._handlePrefChange = this._handlePrefChange.bind(this);
	  this._onSourcePrefChanged = this._onSourcePrefChanged.bind(this);

	  this._prefObserver = new PrefObserver("devtools.");
	  this._prefObserver.on(PREF_ORIG_SOURCES, this._onSourcePrefChanged);
	  this._prefObserver.on(PREF_UA_STYLES, this._handlePrefChange);
	  this._prefObserver.on(PREF_DEFAULT_COLOR_UNIT, this._handlePrefChange);
	  this._prefObserver.on(PREF_ENABLE_MDN_DOCS_TOOLTIP, this._handlePrefChange);

	  this.showUserAgentStyles = Services.prefs.getBoolPref(PREF_UA_STYLES);
	  this.enableMdnDocsTooltip =
	    Services.prefs.getBoolPref(PREF_ENABLE_MDN_DOCS_TOOLTIP);

	  let options = {
	    autoSelect: true,
	    theme: "auto"
	  };
	  this.popup = new AutocompletePopup(inspector._toolbox, options);

	  this._showEmpty();

	  this._contextmenu = new StyleInspectorMenu(this, { isRuleView: true });

	  // Add the tooltips and highlighters to the view
	  this.tooltips = new overlays.TooltipsOverlay(this);
	  this.tooltips.addToView();
	  this.highlighters = new overlays.HighlightersOverlay(this);
	  this.highlighters.addToView();

	  EventEmitter.decorate(this);
	}

	CssRuleView.prototype = {
	  // The element that we're inspecting.
	  _viewedElement: null,

	  // Used for cancelling timeouts in the style filter.
	  _filterChangedTimeout: null,

	  // Empty, unconnected element of the same type as this node, used
	  // to figure out how shorthand properties will be parsed.
	  _dummyElement: null,

	  // Get the dummy elemenet.
	  get dummyElement() {
	    return this._dummyElement;
	  },

	  // Get the filter search value.
	  get searchValue() {
	    return this.searchField.value.toLowerCase();
	  },

	  /**
	   * Get an instance of SelectorHighlighter (used to highlight nodes that match
	   * selectors in the rule-view). A new instance is only created the first time
	   * this function is called. The same instance will then be returned.
	   *
	   * @return {Promise} Resolves to the instance of the highlighter.
	   */
	  getSelectorHighlighter: Task.async(function* () {
	    let utils = this.inspector.toolbox.highlighterUtils;
	    if (!utils.supportsCustomHighlighters()) {
	      return null;
	    }

	    if (this.selectorHighlighter) {
	      return this.selectorHighlighter;
	    }

	    try {
	      let h = yield utils.getHighlighterByType("SelectorHighlighter");
	      this.selectorHighlighter = h;
	      return h;
	    } catch (e) {
	      // The SelectorHighlighter type could not be created in the
	      // current target.  It could be an older server, or a XUL page.
	      return null;
	    }
	  }),

	  /**
	   * Highlight/unhighlight all the nodes that match a given set of selectors
	   * inside the document of the current selected node.
	   * Only one selector can be highlighted at a time, so calling the method a
	   * second time with a different selector will first unhighlight the previously
	   * highlighted nodes.
	   * Calling the method a second time with the same selector will just
	   * unhighlight the highlighted nodes.
	   *
	   * @param {DOMNode} selectorIcon
	   *        The icon that was clicked to toggle the selector. The
	   *        class 'highlighted' will be added when the selector is
	   *        highlighted.
	   * @param {String} selector
	   *        The selector used to find nodes in the page.
	   */
	  toggleSelectorHighlighter: function (selectorIcon, selector) {
	    if (this.lastSelectorIcon) {
	      this.lastSelectorIcon.classList.remove("highlighted");
	    }
	    selectorIcon.classList.remove("highlighted");

	    this.unhighlightSelector().then(() => {
	      if (selector !== this.highlightedSelector) {
	        this.highlightedSelector = selector;
	        selectorIcon.classList.add("highlighted");
	        this.lastSelectorIcon = selectorIcon;
	        this.highlightSelector(selector).then(() => {
	          this.emit("ruleview-selectorhighlighter-toggled", true);
	        }, e => console.error(e));
	      } else {
	        this.highlightedSelector = null;
	        this.emit("ruleview-selectorhighlighter-toggled", false);
	      }
	    }, e => console.error(e));
	  },

	  highlightSelector: Task.async(function* (selector) {
	    let node = this.inspector.selection.nodeFront;

	    let highlighter = yield this.getSelectorHighlighter();
	    if (!highlighter) {
	      return;
	    }

	    yield highlighter.show(node, {
	      hideInfoBar: true,
	      hideGuides: true,
	      selector
	    });
	  }),

	  unhighlightSelector: Task.async(function* () {
	    let highlighter = yield this.getSelectorHighlighter();
	    if (!highlighter) {
	      return;
	    }

	    yield highlighter.hide();
	  }),

	  /**
	   * Get the type of a given node in the rule-view
	   *
	   * @param {DOMNode} node
	   *        The node which we want information about
	   * @return {Object} The type information object contains the following props:
	   * - type {String} One of the VIEW_NODE_XXX_TYPE const in
	   *   style-inspector-overlays
	   * - value {Object} Depends on the type of the node
	   * returns null of the node isn't anything we care about
	   */
	  getNodeInfo: function (node) {
	    if (!node) {
	      return null;
	    }

	    let type, value;
	    let classes = node.classList;
	    let prop = getParentTextProperty(node);

	    if (classes.contains("ruleview-propertyname") && prop) {
	      type = overlays.VIEW_NODE_PROPERTY_TYPE;
	      value = {
	        property: node.textContent,
	        value: getPropertyNameAndValue(node).value,
	        enabled: prop.enabled,
	        overridden: prop.overridden,
	        pseudoElement: prop.rule.pseudoElement,
	        sheetHref: prop.rule.domRule.href,
	        textProperty: prop
	      };
	    } else if (classes.contains("ruleview-propertyvalue") && prop) {
	      type = overlays.VIEW_NODE_VALUE_TYPE;
	      value = {
	        property: getPropertyNameAndValue(node).name,
	        value: node.textContent,
	        enabled: prop.enabled,
	        overridden: prop.overridden,
	        pseudoElement: prop.rule.pseudoElement,
	        sheetHref: prop.rule.domRule.href,
	        textProperty: prop
	      };
	    } else if (classes.contains("theme-link") &&
	               !classes.contains("ruleview-rule-source") && prop) {
	      type = overlays.VIEW_NODE_IMAGE_URL_TYPE;
	      value = {
	        property: getPropertyNameAndValue(node).name,
	        value: node.parentNode.textContent,
	        url: node.href,
	        enabled: prop.enabled,
	        overridden: prop.overridden,
	        pseudoElement: prop.rule.pseudoElement,
	        sheetHref: prop.rule.domRule.href,
	        textProperty: prop
	      };
	    } else if (classes.contains("ruleview-selector-unmatched") ||
	               classes.contains("ruleview-selector-matched") ||
	               classes.contains("ruleview-selectorcontainer") ||
	               classes.contains("ruleview-selector") ||
	               classes.contains("ruleview-selector-attribute") ||
	               classes.contains("ruleview-selector-pseudo-class") ||
	               classes.contains("ruleview-selector-pseudo-class-lock")) {
	      type = overlays.VIEW_NODE_SELECTOR_TYPE;
	      value = this._getRuleEditorForNode(node).selectorText.textContent;
	    } else if (classes.contains("ruleview-rule-source") ||
	               classes.contains("ruleview-rule-source-label")) {
	      type = overlays.VIEW_NODE_LOCATION_TYPE;
	      let rule = this._getRuleEditorForNode(node).rule;
	      value = (rule.sheet && rule.sheet.href) ? rule.sheet.href : rule.title;
	    } else {
	      return null;
	    }

	    return {type, value};
	  },

	  /**
	   * Retrieve the RuleEditor instance that should be stored on
	   * the offset parent of the node
	   */
	  _getRuleEditorForNode: function (node) {
	    if (!node.offsetParent) {
	      // some nodes don't have an offsetParent, but their parentNode does
	      node = node.parentNode;
	    }
	    return node.offsetParent._ruleEditor;
	  },

	  /**
	   * Context menu handler.
	   */
	  _onContextMenu: function (event) {
	    this._contextmenu.show(event);
	  },

	  /**
	   * Callback for copy event. Copy the selected text.
	   *
	   * @param {Event} event
	   *        copy event object.
	   */
	  _onCopy: function (event) {
	    if (event) {
	      this.copySelection(event.target);
	      event.preventDefault();
	    }
	  },

	  /**
	   * Copy the current selection. The current target is necessary
	   * if the selection is inside an input or a textarea
	   *
	   * @param {DOMNode} target
	   *        DOMNode target of the copy action
	   */
	  copySelection: function (target) {
	    try {
	      let text = "";

	      let nodeName = target && target.nodeName;
	      if (nodeName === "input" || nodeName == "textarea") {
	        let start = Math.min(target.selectionStart, target.selectionEnd);
	        let end = Math.max(target.selectionStart, target.selectionEnd);
	        let count = end - start;
	        text = target.value.substr(start, count);
	      } else {
	        text = this.styleWindow.getSelection().toString();

	        // Remove any double newlines.
	        text = text.replace(/(\r?\n)\r?\n/g, "$1");
	      }

	      clipboardHelper.copyString(text);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  /**
	   * A helper for _onAddRule that handles the case where the actor
	   * does not support as-authored styles.
	   */
	  _onAddNewRuleNonAuthored: function () {
	    let elementStyle = this._elementStyle;
	    let element = elementStyle.element;
	    let rules = elementStyle.rules;
	    let pseudoClasses = element.pseudoClassLocks;

	    this.pageStyle.addNewRule(element, pseudoClasses).then(options => {
	      let newRule = new Rule(elementStyle, options);
	      rules.push(newRule);
	      let editor = new RuleEditor(this, newRule);
	      newRule.editor = editor;

	      // Insert the new rule editor after the inline element rule
	      if (rules.length <= 1) {
	        this.element.appendChild(editor.element);
	      } else {
	        for (let rule of rules) {
	          if (rule.domRule.type === ELEMENT_STYLE) {
	            let referenceElement = rule.editor.element.nextSibling;
	            this.element.insertBefore(editor.element, referenceElement);
	            break;
	          }
	        }
	      }

	      // Focus and make the new rule's selector editable
	      editor.selectorText.click();
	      elementStyle._changed();
	    });
	  },

	  /**
	   * Add a new rule to the current element.
	   */
	  _onAddRule: function () {
	    let elementStyle = this._elementStyle;
	    let element = elementStyle.element;
	    let client = this.inspector.toolbox.target.client;
	    let pseudoClasses = element.pseudoClassLocks;

	    if (!client.traits.addNewRule) {
	      return;
	    }

	    if (!this.pageStyle.supportsAuthoredStyles) {
	      // We're talking to an old server.
	      this._onAddNewRuleNonAuthored();
	      return;
	    }

	    // Adding a new rule with authored styles will cause the actor to
	    // emit an event, which will in turn cause the rule view to be
	    // updated.  So, we wait for this update and for the rule creation
	    // request to complete, and then focus the new rule's selector.
	    let eventPromise = this.once("ruleview-refreshed");
	    let newRulePromise = this.pageStyle.addNewRule(element, pseudoClasses);
	    promise.all([eventPromise, newRulePromise]).then((values) => {
	      let options = values[1];
	      // Be sure the reference the correct |rules| here.
	      for (let rule of this._elementStyle.rules) {
	        if (options.rule === rule.domRule) {
	          rule.editor.selectorText.click();
	          elementStyle._changed();
	          break;
	        }
	      }
	    });
	  },

	  /**
	   * Disables add rule button when needed
	   */
	  refreshAddRuleButtonState: function () {
	    let shouldBeDisabled = !this._viewedElement ||
	                           !this.inspector.selection.isElementNode() ||
	                           this.inspector.selection.isAnonymousNode();
	    this.addRuleButton.disabled = shouldBeDisabled;
	  },

	  setPageStyle: function (pageStyle) {
	    this.pageStyle = pageStyle;
	  },

	  /**
	   * Return {Boolean} true if the rule view currently has an input
	   * editor visible.
	   */
	  get isEditing() {
	    return this.tooltips.isEditing ||
	      this.element.querySelectorAll(".styleinspector-propertyeditor")
	        .length > 0;
	  },

	  _handlePrefChange: function (pref) {
	    if (pref === PREF_UA_STYLES) {
	      this.showUserAgentStyles = Services.prefs.getBoolPref(pref);
	    }

	    // Reselect the currently selected element
	    let refreshOnPrefs = [PREF_UA_STYLES, PREF_DEFAULT_COLOR_UNIT];
	    if (refreshOnPrefs.indexOf(pref) > -1) {
	      this.selectElement(this._viewedElement, true);
	    }
	  },

	  /**
	   * Update source links when pref for showing original sources changes
	   */
	  _onSourcePrefChanged: function () {
	    if (this._elementStyle && this._elementStyle.rules) {
	      for (let rule of this._elementStyle.rules) {
	        if (rule.editor) {
	          rule.editor.updateSourceLink();
	        }
	      }
	      this.inspector.emit("rule-view-sourcelinks-updated");
	    }
	  },

	  /**
	   * Set the filter style search value.
	   * @param {String} value
	   *        The search value.
	   */
	  setFilterStyles: function (value = "") {
	    this.searchField.value = value;
	    this.searchField.focus();
	    this._onFilterStyles();
	  },

	  /**
	   * Called when the user enters a search term in the filter style search box.
	   */
	  _onFilterStyles: function () {
	    if (this._filterChangedTimeout) {
	      clearTimeout(this._filterChangedTimeout);
	    }

	    let filterTimeout = (this.searchValue.length > 0) ?
	                        FILTER_CHANGED_TIMEOUT : 0;
	    this.searchClearButton.hidden = this.searchValue.length === 0;

	    this._filterChangedTimeout = setTimeout(() => {
	      if (this.searchField.value.length > 0) {
	        this.searchField.setAttribute("filled", true);
	      } else {
	        this.searchField.removeAttribute("filled");
	      }

	      this.searchData = {
	        searchPropertyMatch: FILTER_PROP_RE.exec(this.searchValue),
	        searchPropertyName: this.searchValue,
	        searchPropertyValue: this.searchValue,
	        strictSearchValue: "",
	        strictSearchPropertyName: false,
	        strictSearchPropertyValue: false,
	        strictSearchAllValues: false
	      };

	      if (this.searchData.searchPropertyMatch) {
	        // Parse search value as a single property line and extract the
	        // property name and value. If the parsed property name or value is
	        // contained in backquotes (`), extract the value within the backquotes
	        // and set the corresponding strict search for the property to true.
	        if (FILTER_STRICT_RE.test(this.searchData.searchPropertyMatch[1])) {
	          this.searchData.strictSearchPropertyName = true;
	          this.searchData.searchPropertyName =
	            FILTER_STRICT_RE.exec(this.searchData.searchPropertyMatch[1])[1];
	        } else {
	          this.searchData.searchPropertyName =
	            this.searchData.searchPropertyMatch[1];
	        }

	        if (FILTER_STRICT_RE.test(this.searchData.searchPropertyMatch[2])) {
	          this.searchData.strictSearchPropertyValue = true;
	          this.searchData.searchPropertyValue =
	            FILTER_STRICT_RE.exec(this.searchData.searchPropertyMatch[2])[1];
	        } else {
	          this.searchData.searchPropertyValue =
	            this.searchData.searchPropertyMatch[2];
	        }

	        // Strict search for stylesheets will match the property line regex.
	        // Extract the search value within the backquotes to be used
	        // in the strict search for stylesheets in _highlightStyleSheet.
	        if (FILTER_STRICT_RE.test(this.searchValue)) {
	          this.searchData.strictSearchValue =
	            FILTER_STRICT_RE.exec(this.searchValue)[1];
	        }
	      } else if (FILTER_STRICT_RE.test(this.searchValue)) {
	        // If the search value does not correspond to a property line and
	        // is contained in backquotes, extract the search value within the
	        // backquotes and set the flag to perform a strict search for all
	        // the values (selector, stylesheet, property and computed values).
	        let searchValue = FILTER_STRICT_RE.exec(this.searchValue)[1];
	        this.searchData.strictSearchAllValues = true;
	        this.searchData.searchPropertyName = searchValue;
	        this.searchData.searchPropertyValue = searchValue;
	        this.searchData.strictSearchValue = searchValue;
	      }

	      this._clearHighlight(this.element);
	      this._clearRules();
	      this._createEditors();

	      this.inspector.emit("ruleview-filtered");

	      this._filterChangeTimeout = null;
	    }, filterTimeout);
	  },

	  /**
	   * Context menu handler for filter style search box.
	   */
	  _onFilterTextboxContextMenu: function (event) {
	    try {
	      this.styleWindow.focus();
	      let contextmenu = this.inspector.toolbox.textboxContextMenuPopup;
	      contextmenu.openPopupAtScreen(event.screenX, event.screenY, true);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  /**
	   * Called when the user clicks on the clear button in the filter style search
	   * box. Returns true if the search box is cleared and false otherwise.
	   */
	  _onClearSearch: function () {
	    if (this.searchField.value) {
	      this.setFilterStyles("");
	      return true;
	    }

	    return false;
	  },

	  destroy: function () {
	    this.isDestroyed = true;
	    this.clear();

	    this._dummyElement = null;
	    this.dummyElementPromise = null;
	    gDummyPromise = null;

	    this._prefObserver.off(PREF_ORIG_SOURCES, this._onSourcePrefChanged);
	    this._prefObserver.off(PREF_UA_STYLES, this._handlePrefChange);
	    this._prefObserver.off(PREF_DEFAULT_COLOR_UNIT, this._handlePrefChange);
	    this._prefObserver.destroy();

	    this._outputParser = null;

	    // Remove context menu
	    if (this._contextmenu) {
	      this._contextmenu.destroy();
	      this._contextmenu = null;
	    }

	    this.tooltips.destroy();
	    this.highlighters.destroy();

	    // Remove bound listeners
	    this.shortcuts.destroy();
	    this.element.removeEventListener("copy", this._onCopy);
	    this.element.removeEventListener("contextmenu", this._onContextMenu);
	    this.addRuleButton.removeEventListener("click", this._onAddRule);
	    this.searchField.removeEventListener("input", this._onFilterStyles);
	    this.searchField.removeEventListener("contextmenu",
	      this._onFilterTextboxContextMenu);
	    this.searchClearButton.removeEventListener("click", this._onClearSearch);
	    this.pseudoClassToggle.removeEventListener("click",
	      this._onTogglePseudoClassPanel);
	    this.hoverCheckbox.removeEventListener("click", this._onTogglePseudoClass);
	    this.activeCheckbox.removeEventListener("click", this._onTogglePseudoClass);
	    this.focusCheckbox.removeEventListener("click", this._onTogglePseudoClass);

	    this.searchField = null;
	    this.searchClearButton = null;
	    this.pseudoClassPanel = null;
	    this.pseudoClassToggle = null;
	    this.hoverCheckbox = null;
	    this.activeCheckbox = null;
	    this.focusCheckbox = null;

	    this.inspector = null;
	    this.styleDocument = null;
	    this.styleWindow = null;

	    if (this.element.parentNode) {
	      this.element.parentNode.removeChild(this.element);
	    }

	    if (this._elementStyle) {
	      this._elementStyle.destroy();
	    }

	    this.popup.destroy();
	  },

	  /**
	   * Mark the view as selecting an element, disabling all interaction, and
	   * visually clearing the view after a few milliseconds to avoid confusion
	   * about which element's styles the rule view shows.
	   */
	  _startSelectingElement: function () {
	    this.element.classList.add("non-interactive");
	  },

	  /**
	   * Mark the view as no longer selecting an element, re-enabling interaction.
	   */
	  _stopSelectingElement: function () {
	    this.element.classList.remove("non-interactive");
	  },

	  /**
	   * Update the view with a new selected element.
	   *
	   * @param {NodeActor} element
	   *        The node whose style rules we'll inspect.
	   * @param {Boolean} allowRefresh
	   *        Update the view even if the element is the same as last time.
	   */
	  selectElement: function (element, allowRefresh = false) {
	    let refresh = (this._viewedElement === element);
	    if (refresh && !allowRefresh) {
	      return promise.resolve(undefined);
	    }

	    if (this.popup.isOpen) {
	      this.popup.hidePopup();
	    }

	    this.clear(false);
	    this._viewedElement = element;

	    this.clearPseudoClassPanel();
	    this.refreshAddRuleButtonState();

	    if (!this._viewedElement) {
	      this._stopSelectingElement();
	      this._clearRules();
	      this._showEmpty();
	      this.refreshPseudoClassPanel();
	      return promise.resolve(undefined);
	    }

	    // To figure out how shorthand properties are interpreted by the
	    // engine, we will set properties on a dummy element and observe
	    // how their .style attribute reflects them as computed values.
	    this.dummyElementPromise = createDummyDocument().then(document => {
	      // ::before and ::after do not have a namespaceURI
	      let namespaceURI = this.element.namespaceURI ||
	          document.documentElement.namespaceURI;
	      this._dummyElement = document.createElementNS(namespaceURI,
	                                                   this.element.tagName);
	      document.documentElement.appendChild(this._dummyElement);
	      return this._dummyElement;
	    }).then(null, promiseWarn);

	    let elementStyle = new ElementStyle(element, this, this.store,
	      this.pageStyle, this.showUserAgentStyles);
	    this._elementStyle = elementStyle;

	    this._startSelectingElement();

	    return this.dummyElementPromise.then(() => {
	      if (this._elementStyle === elementStyle) {
	        return this._populate();
	      }
	      return undefined;
	    }).then(() => {
	      if (this._elementStyle === elementStyle) {
	        if (!refresh) {
	          this.element.scrollTop = 0;
	        }
	        this._stopSelectingElement();
	        this._elementStyle.onChanged = () => {
	          this._changed();
	        };
	      }
	    }).then(null, e => {
	      if (this._elementStyle === elementStyle) {
	        this._stopSelectingElement();
	        this._clearRules();
	      }
	      console.error(e);
	    });
	  },

	  /**
	   * Update the rules for the currently highlighted element.
	   */
	  refreshPanel: function () {
	    // Ignore refreshes during editing or when no element is selected.
	    if (this.isEditing || !this._elementStyle) {
	      return promise.resolve(undefined);
	    }

	    // Repopulate the element style once the current modifications are done.
	    let promises = [];
	    for (let rule of this._elementStyle.rules) {
	      if (rule._applyingModifications) {
	        promises.push(rule._applyingModifications);
	      }
	    }

	    return promise.all(promises).then(() => {
	      return this._populate();
	    });
	  },

	  /**
	   * Clear the pseudo class options panel by removing the checked and disabled
	   * attributes for each checkbox.
	   */
	  clearPseudoClassPanel: function () {
	    this.hoverCheckbox.checked = this.hoverCheckbox.disabled = false;
	    this.activeCheckbox.checked = this.activeCheckbox.disabled = false;
	    this.focusCheckbox.checked = this.focusCheckbox.disabled = false;
	  },

	  /**
	   * Update the pseudo class options for the currently highlighted element.
	   */
	  refreshPseudoClassPanel: function () {
	    if (!this._elementStyle || !this.inspector.selection.isElementNode()) {
	      this.hoverCheckbox.disabled = true;
	      this.activeCheckbox.disabled = true;
	      this.focusCheckbox.disabled = true;
	      return;
	    }

	    for (let pseudoClassLock of this._elementStyle.element.pseudoClassLocks) {
	      switch (pseudoClassLock) {
	        case ":hover": {
	          this.hoverCheckbox.checked = true;
	          break;
	        }
	        case ":active": {
	          this.activeCheckbox.checked = true;
	          break;
	        }
	        case ":focus": {
	          this.focusCheckbox.checked = true;
	          break;
	        }
	      }
	    }
	  },

	  _populate: function () {
	    let elementStyle = this._elementStyle;
	    return this._elementStyle.populate().then(() => {
	      if (this._elementStyle !== elementStyle || this.isDestroyed) {
	        return null;
	      }

	      this._clearRules();
	      let onEditorsReady = this._createEditors();
	      this.refreshPseudoClassPanel();

	      // Notify anyone that cares that we refreshed.
	      return onEditorsReady.then(() => {
	        this.emit("ruleview-refreshed");
	      }, e => console.error(e));
	    }).then(null, promiseWarn);
	  },

	  /**
	   * Show the user that the rule view has no node selected.
	   */
	  _showEmpty: function () {
	    if (this.styleDocument.getElementById("ruleview-no-results")) {
	      return;
	    }

	    createChild(this.element, "div", {
	      id: "ruleview-no-results",
	      textContent: l10n("rule.empty")
	    });
	  },

	  /**
	   * Clear the rules.
	   */
	  _clearRules: function () {
	    this.element.innerHTML = "";
	  },

	  /**
	   * Clear the rule view.
	   */
	  clear: function (clearDom = true) {
	    this.lastSelectorIcon = null;

	    if (clearDom) {
	      this._clearRules();
	    }
	    this._viewedElement = null;

	    if (this._elementStyle) {
	      this._elementStyle.destroy();
	      this._elementStyle = null;
	    }
	  },

	  /**
	   * Called when the user has made changes to the ElementStyle.
	   * Emits an event that clients can listen to.
	   */
	  _changed: function () {
	    this.emit("ruleview-changed");
	  },

	  /**
	   * Text for header that shows above rules for this element
	   */
	  get selectedElementLabel() {
	    if (this._selectedElementLabel) {
	      return this._selectedElementLabel;
	    }
	    this._selectedElementLabel = l10n("rule.selectedElement");
	    return this._selectedElementLabel;
	  },

	  /**
	   * Text for header that shows above rules for pseudo elements
	   */
	  get pseudoElementLabel() {
	    if (this._pseudoElementLabel) {
	      return this._pseudoElementLabel;
	    }
	    this._pseudoElementLabel = l10n("rule.pseudoElement");
	    return this._pseudoElementLabel;
	  },

	  get showPseudoElements() {
	    if (this._showPseudoElements === undefined) {
	      this._showPseudoElements =
	        Services.prefs.getBoolPref("devtools.inspector.show_pseudo_elements");
	    }
	    return this._showPseudoElements;
	  },

	  /**
	   * Creates an expandable container in the rule view
	   *
	   * @param  {String} label
	   *         The label for the container header
	   * @param  {Boolean} isPseudo
	   *         Whether or not the container will hold pseudo element rules
	   * @return {DOMNode} The container element
	   */
	  createExpandableContainer: function (label, isPseudo = false) {
	    let header = this.styleDocument.createElementNS(HTML_NS, "div");
	    header.className = this._getRuleViewHeaderClassName(true);
	    header.textContent = label;

	    let twisty = this.styleDocument.createElementNS(HTML_NS, "span");
	    twisty.className = "ruleview-expander theme-twisty";
	    twisty.setAttribute("open", "true");

	    header.insertBefore(twisty, header.firstChild);
	    this.element.appendChild(header);

	    let container = this.styleDocument.createElementNS(HTML_NS, "div");
	    container.classList.add("ruleview-expandable-container");
	    container.hidden = false;
	    this.element.appendChild(container);

	    header.addEventListener("dblclick", () => {
	      this._toggleContainerVisibility(twisty, container, isPseudo,
	        !this.showPseudoElements);
	    }, false);

	    twisty.addEventListener("click", () => {
	      this._toggleContainerVisibility(twisty, container, isPseudo,
	        !this.showPseudoElements);
	    }, false);

	    if (isPseudo) {
	      this._toggleContainerVisibility(twisty, container, isPseudo,
	        this.showPseudoElements);
	    }

	    return container;
	  },

	  /**
	   * Toggle the visibility of an expandable container
	   *
	   * @param  {DOMNode}  twisty
	   *         Clickable toggle DOM Node
	   * @param  {DOMNode}  container
	   *         Expandable container DOM Node
	   * @param  {Boolean}  isPseudo
	   *         Whether or not the container will hold pseudo element rules
	   * @param  {Boolean}  showPseudo
	   *         Whether or not pseudo element rules should be displayed
	   */
	  _toggleContainerVisibility: function (twisty, container, isPseudo,
	      showPseudo) {
	    let isOpen = twisty.getAttribute("open");

	    if (isPseudo) {
	      this._showPseudoElements = !!showPseudo;

	      Services.prefs.setBoolPref("devtools.inspector.show_pseudo_elements",
	        this.showPseudoElements);

	      container.hidden = !this.showPseudoElements;
	      isOpen = !this.showPseudoElements;
	    } else {
	      container.hidden = !container.hidden;
	    }

	    if (isOpen) {
	      twisty.removeAttribute("open");
	    } else {
	      twisty.setAttribute("open", "true");
	    }
	  },

	  _getRuleViewHeaderClassName: function (isPseudo) {
	    let baseClassName = "theme-gutter ruleview-header";
	    return isPseudo ? baseClassName + " ruleview-expandable-header" :
	      baseClassName;
	  },

	  /**
	   * Creates editor UI for each of the rules in _elementStyle.
	   */
	  _createEditors: function () {
	    // Run through the current list of rules, attaching
	    // their editors in order.  Create editors if needed.
	    let lastInheritedSource = "";
	    let lastKeyframes = null;
	    let seenPseudoElement = false;
	    let seenNormalElement = false;
	    let seenSearchTerm = false;
	    let container = null;

	    if (!this._elementStyle.rules) {
	      return promise.resolve();
	    }

	    let editorReadyPromises = [];
	    for (let rule of this._elementStyle.rules) {
	      if (rule.domRule.system) {
	        continue;
	      }

	      // Initialize rule editor
	      if (!rule.editor) {
	        rule.editor = new RuleEditor(this, rule);
	        editorReadyPromises.push(rule.editor.once("source-link-updated"));
	      }

	      // Filter the rules and highlight any matches if there is a search input
	      if (this.searchValue && this.searchData) {
	        if (this.highlightRule(rule)) {
	          seenSearchTerm = true;
	        } else if (rule.domRule.type !== ELEMENT_STYLE) {
	          continue;
	        }
	      }

	      // Only print header for this element if there are pseudo elements
	      if (seenPseudoElement && !seenNormalElement && !rule.pseudoElement) {
	        seenNormalElement = true;
	        let div = this.styleDocument.createElementNS(HTML_NS, "div");
	        div.className = this._getRuleViewHeaderClassName();
	        div.textContent = this.selectedElementLabel;
	        this.element.appendChild(div);
	      }

	      let inheritedSource = rule.inheritedSource;
	      if (inheritedSource && inheritedSource !== lastInheritedSource) {
	        let div = this.styleDocument.createElementNS(HTML_NS, "div");
	        div.className = this._getRuleViewHeaderClassName();
	        div.textContent = inheritedSource;
	        lastInheritedSource = inheritedSource;
	        this.element.appendChild(div);
	      }

	      if (!seenPseudoElement && rule.pseudoElement) {
	        seenPseudoElement = true;
	        container = this.createExpandableContainer(this.pseudoElementLabel,
	                                                   true);
	      }

	      let keyframes = rule.keyframes;
	      if (keyframes && keyframes !== lastKeyframes) {
	        lastKeyframes = keyframes;
	        container = this.createExpandableContainer(rule.keyframesName);
	      }

	      if (container && (rule.pseudoElement || keyframes)) {
	        container.appendChild(rule.editor.element);
	      } else {
	        this.element.appendChild(rule.editor.element);
	      }
	    }

	    if (this.searchValue && !seenSearchTerm) {
	      this.searchField.classList.add("devtools-style-searchbox-no-match");
	    } else {
	      this.searchField.classList.remove("devtools-style-searchbox-no-match");
	    }

	    return promise.all(editorReadyPromises);
	  },

	  /**
	   * Highlight rules that matches the filter search value and returns a
	   * boolean indicating whether or not rules were highlighted.
	   *
	   * @param  {Rule} rule
	   *         The rule object we're highlighting if its rule selectors or
	   *         property values match the search value.
	   * @return {Boolean} true if the rule was highlighted, false otherwise.
	   */
	  highlightRule: function (rule) {
	    let isRuleSelectorHighlighted = this._highlightRuleSelector(rule);
	    let isStyleSheetHighlighted = this._highlightStyleSheet(rule);
	    let isHighlighted = isRuleSelectorHighlighted || isStyleSheetHighlighted;

	    // Highlight search matches in the rule properties
	    for (let textProp of rule.textProps) {
	      if (!textProp.invisible && this._highlightProperty(textProp.editor)) {
	        isHighlighted = true;
	      }
	    }

	    return isHighlighted;
	  },

	  /**
	   * Highlights the rule selector that matches the filter search value and
	   * returns a boolean indicating whether or not the selector was highlighted.
	   *
	   * @param  {Rule} rule
	   *         The Rule object.
	   * @return {Boolean} true if the rule selector was highlighted,
	   *         false otherwise.
	   */
	  _highlightRuleSelector: function (rule) {
	    let isSelectorHighlighted = false;

	    let selectorNodes = [...rule.editor.selectorText.childNodes];
	    if (rule.domRule.type === CSSRule.KEYFRAME_RULE) {
	      selectorNodes = [rule.editor.selectorText];
	    } else if (rule.domRule.type === ELEMENT_STYLE) {
	      selectorNodes = [];
	    }

	    // Highlight search matches in the rule selectors
	    for (let selectorNode of selectorNodes) {
	      let selector = selectorNode.textContent.toLowerCase();
	      if ((this.searchData.strictSearchAllValues &&
	           selector === this.searchData.strictSearchValue) ||
	          (!this.searchData.strictSearchAllValues &&
	           selector.includes(this.searchValue))) {
	        selectorNode.classList.add("ruleview-highlight");
	        isSelectorHighlighted = true;
	      }
	    }

	    return isSelectorHighlighted;
	  },

	  /**
	   * Highlights the stylesheet source that matches the filter search value and
	   * returns a boolean indicating whether or not the stylesheet source was
	   * highlighted.
	   *
	   * @return {Boolean} true if the stylesheet source was highlighted, false
	   *         otherwise.
	   */
	  _highlightStyleSheet: function (rule) {
	    let styleSheetSource = rule.title.toLowerCase();
	    let isStyleSheetHighlighted = this.searchData.strictSearchValue ?
	      styleSheetSource === this.searchData.strictSearchValue :
	      styleSheetSource.includes(this.searchValue);

	    if (isStyleSheetHighlighted) {
	      rule.editor.source.classList.add("ruleview-highlight");
	    }

	    return isStyleSheetHighlighted;
	  },

	  /**
	   * Highlights the rule properties and computed properties that match the
	   * filter search value and returns a boolean indicating whether or not the
	   * property or computed property was highlighted.
	   *
	   * @param  {TextPropertyEditor} editor
	   *         The rule property TextPropertyEditor object.
	   * @return {Boolean} true if the property or computed property was
	   *         highlighted, false otherwise.
	   */
	  _highlightProperty: function (editor) {
	    let isPropertyHighlighted = this._highlightRuleProperty(editor);
	    let isComputedHighlighted = this._highlightComputedProperty(editor);

	    // Expand the computed list if a computed property is highlighted and the
	    // property rule is not highlighted
	    if (!isPropertyHighlighted && isComputedHighlighted &&
	        !editor.computed.hasAttribute("user-open")) {
	      editor.expandForFilter();
	    }

	    return isPropertyHighlighted || isComputedHighlighted;
	  },

	  /**
	   * Called when TextPropertyEditor is updated and updates the rule property
	   * highlight.
	   *
	   * @param  {TextPropertyEditor} editor
	   *         The rule property TextPropertyEditor object.
	   */
	  _updatePropertyHighlight: function (editor) {
	    if (!this.searchValue || !this.searchData) {
	      return;
	    }

	    this._clearHighlight(editor.element);

	    if (this._highlightProperty(editor)) {
	      this.searchField.classList.remove("devtools-style-searchbox-no-match");
	    }
	  },

	  /**
	   * Highlights the rule property that matches the filter search value
	   * and returns a boolean indicating whether or not the property was
	   * highlighted.
	   *
	   * @param  {TextPropertyEditor} editor
	   *         The rule property TextPropertyEditor object.
	   * @return {Boolean} true if the rule property was highlighted,
	   *         false otherwise.
	   */
	  _highlightRuleProperty: function (editor) {
	    // Get the actual property value displayed in the rule view
	    let propertyName = editor.prop.name.toLowerCase();
	    let propertyValue = editor.valueSpan.textContent.toLowerCase();

	    return this._highlightMatches(editor.container, propertyName,
	                                  propertyValue);
	  },

	  /**
	   * Highlights the computed property that matches the filter search value and
	   * returns a boolean indicating whether or not the computed property was
	   * highlighted.
	   *
	   * @param  {TextPropertyEditor} editor
	   *         The rule property TextPropertyEditor object.
	   * @return {Boolean} true if the computed property was highlighted, false
	   *         otherwise.
	   */
	  _highlightComputedProperty: function (editor) {
	    let isComputedHighlighted = false;

	    // Highlight search matches in the computed list of properties
	    editor._populateComputed();
	    for (let computed of editor.prop.computed) {
	      if (computed.element) {
	        // Get the actual property value displayed in the computed list
	        let computedName = computed.name.toLowerCase();
	        let computedValue = computed.parsedValue.toLowerCase();

	        isComputedHighlighted = this._highlightMatches(computed.element,
	          computedName, computedValue) ? true : isComputedHighlighted;
	      }
	    }

	    return isComputedHighlighted;
	  },

	  /**
	   * Helper function for highlightRules that carries out highlighting the given
	   * element if the search terms match the property, and returns a boolean
	   * indicating whether or not the search terms match.
	   *
	   * @param  {DOMNode} element
	   *         The node to highlight if search terms match
	   * @param  {String} propertyName
	   *         The property name of a rule
	   * @param  {String} propertyValue
	   *         The property value of a rule
	   * @return {Boolean} true if the given search terms match the property, false
	   *         otherwise.
	   */
	  _highlightMatches: function (element, propertyName, propertyValue) {
	    let {
	      searchPropertyName,
	      searchPropertyValue,
	      searchPropertyMatch,
	      strictSearchPropertyName,
	      strictSearchPropertyValue,
	      strictSearchAllValues,
	    } = this.searchData;
	    let matches = false;

	    // If the inputted search value matches a property line like
	    // `font-family: arial`, then check to make sure the name and value match.
	    // Otherwise, just compare the inputted search string directly against the
	    // name and value of the rule property.
	    let hasNameAndValue = searchPropertyMatch &&
	                          searchPropertyName &&
	                          searchPropertyValue;
	    let isMatch = (value, query, isStrict) => {
	      return isStrict ? value === query : query && value.includes(query);
	    };

	    if (hasNameAndValue) {
	      matches =
	        isMatch(propertyName, searchPropertyName, strictSearchPropertyName) &&
	        isMatch(propertyValue, searchPropertyValue, strictSearchPropertyValue);
	    } else {
	      matches =
	        isMatch(propertyName, searchPropertyName,
	                strictSearchPropertyName || strictSearchAllValues) ||
	        isMatch(propertyValue, searchPropertyValue,
	                strictSearchPropertyValue || strictSearchAllValues);
	    }

	    if (matches) {
	      element.classList.add("ruleview-highlight");
	    }

	    return matches;
	  },

	  /**
	   * Clear all search filter highlights in the panel, and close the computed
	   * list if toggled opened
	   */
	  _clearHighlight: function (element) {
	    for (let el of element.querySelectorAll(".ruleview-highlight")) {
	      el.classList.remove("ruleview-highlight");
	    }

	    for (let computed of element.querySelectorAll(
	          ".ruleview-computedlist[filter-open]")) {
	      computed.parentNode._textPropertyEditor.collapseForFilter();
	    }
	  },

	  /**
	   * Called when the pseudo class panel button is clicked and toggles
	   * the display of the pseudo class panel.
	   */
	  _onTogglePseudoClassPanel: function () {
	    if (this.pseudoClassPanel.hidden) {
	      this.pseudoClassToggle.setAttribute("checked", "true");
	      this.hoverCheckbox.setAttribute("tabindex", "0");
	      this.activeCheckbox.setAttribute("tabindex", "0");
	      this.focusCheckbox.setAttribute("tabindex", "0");
	    } else {
	      this.pseudoClassToggle.removeAttribute("checked");
	      this.hoverCheckbox.setAttribute("tabindex", "-1");
	      this.activeCheckbox.setAttribute("tabindex", "-1");
	      this.focusCheckbox.setAttribute("tabindex", "-1");
	    }

	    this.pseudoClassPanel.hidden = !this.pseudoClassPanel.hidden;
	  },

	  /**
	   * Called when a pseudo class checkbox is clicked and toggles
	   * the pseudo class for the current selected element.
	   */
	  _onTogglePseudoClass: function (event) {
	    let target = event.currentTarget;
	    this.inspector.togglePseudoClass(target.value);
	  },

	  /**
	   * Handle the keypress event in the rule view.
	   */
	  _onShortcut: function (name, event) {
	    if (!event.target.closest("#sidebar-panel-ruleview")) {
	      return;
	    }

	    if (name === "CmdOrCtrl+F") {
	      this.searchField.focus();
	      event.preventDefault();
	    } else if ((name === "Return" || name === "Space") &&
	               this.element.classList.contains("non-interactive")) {
	      event.preventDefault();
	    } else if (name === "Escape" &&
	               event.target === this.searchField &&
	               this._onClearSearch()) {
	      // Handle the search box's keypress event. If the escape key is pressed,
	      // clear the search box field.
	      event.preventDefault();
	      event.stopPropagation();
	    }
	  }

	};

	/**
	 * Helper functions
	 */

	/**
	 * Walk up the DOM from a given node until a parent property holder is found.
	 * For elements inside the computed property list, the non-computed parent
	 * property holder will be returned
	 *
	 * @param {DOMNode} node
	 *        The node to start from
	 * @return {DOMNode} The parent property holder node, or null if not found
	 */
	function getParentTextPropertyHolder(node) {
	  while (true) {
	    if (!node || !node.classList) {
	      return null;
	    }
	    if (node.classList.contains("ruleview-property")) {
	      return node;
	    }
	    node = node.parentNode;
	  }
	}

	/**
	 * For any given node, find the TextProperty it is in if any
	 * @param {DOMNode} node
	 *        The node to start from
	 * @return {TextProperty}
	 */
	function getParentTextProperty(node) {
	  let parent = getParentTextPropertyHolder(node);
	  if (!parent) {
	    return null;
	  }

	  let propValue = parent.querySelector(".ruleview-propertyvalue");
	  if (!propValue) {
	    return null;
	  }

	  return propValue.textProperty;
	}

	/**
	 * Walker up the DOM from a given node until a parent property holder is found,
	 * and return the textContent for the name and value nodes.
	 * Stops at the first property found, so if node is inside the computed property
	 * list, the computed property will be returned
	 *
	 * @param {DOMNode} node
	 *        The node to start from
	 * @return {Object} {name, value}
	 */
	function getPropertyNameAndValue(node) {
	  while (true) {
	    if (!node || !node.classList) {
	      return null;
	    }
	    // Check first for ruleview-computed since it's the deepest
	    if (node.classList.contains("ruleview-computed") ||
	        node.classList.contains("ruleview-property")) {
	      return {
	        name: node.querySelector(".ruleview-propertyname").textContent,
	        value: node.querySelector(".ruleview-propertyvalue").textContent
	      };
	    }
	    node = node.parentNode;
	  }
	}

	function RuleViewTool(inspector, window) {
	  this.inspector = inspector;
	  this.document = window.document;

	  this.view = new CssRuleView(this.inspector, this.document);

	  this.onLinkClicked = this.onLinkClicked.bind(this);
	  this.onSelected = this.onSelected.bind(this);
	  this.refresh = this.refresh.bind(this);
	  this.clearUserProperties = this.clearUserProperties.bind(this);
	  this.onPropertyChanged = this.onPropertyChanged.bind(this);
	  this.onViewRefreshed = this.onViewRefreshed.bind(this);
	  this.onPanelSelected = this.onPanelSelected.bind(this);
	  this.onMutations = this.onMutations.bind(this);
	  this.onResized = this.onResized.bind(this);

	  this.view.on("ruleview-changed", this.onPropertyChanged);
	  this.view.on("ruleview-refreshed", this.onViewRefreshed);
	  this.view.on("ruleview-linked-clicked", this.onLinkClicked);

	  this.inspector.selection.on("detached-front", this.onSelected);
	  this.inspector.selection.on("new-node-front", this.onSelected);
	  this.inspector.selection.on("pseudoclass", this.refresh);
	  this.inspector.target.on("navigate", this.clearUserProperties);
	  this.inspector.sidebar.on("ruleview-selected", this.onPanelSelected);
	  this.inspector.pageStyle.on("stylesheet-updated", this.refresh);
	  this.inspector.walker.on("mutations", this.onMutations);
	  this.inspector.walker.on("resize", this.onResized);

	  this.onSelected();
	}

	RuleViewTool.prototype = {
	  isSidebarActive: function () {
	    if (!this.view) {
	      return false;
	    }
	    return this.inspector.sidebar.getCurrentTabID() == "ruleview";
	  },

	  onSelected: function (event) {
	    // Ignore the event if the view has been destroyed, or if it's inactive.
	    // But only if the current selection isn't null. If it's been set to null,
	    // let the update go through as this is needed to empty the view on
	    // navigation.
	    if (!this.view) {
	      return;
	    }

	    let isInactive = !this.isSidebarActive() &&
	                     this.inspector.selection.nodeFront;
	    if (isInactive) {
	      return;
	    }

	    this.view.setPageStyle(this.inspector.pageStyle);

	    if (!this.inspector.selection.isConnected() ||
	        !this.inspector.selection.isElementNode()) {
	      this.view.selectElement(null);
	      return;
	    }

	    if (!event || event == "new-node-front") {
	      let done = this.inspector.updating("rule-view");
	      this.view.selectElement(this.inspector.selection.nodeFront)
	        .then(done, done);
	    }
	  },

	  refresh: function () {
	    if (this.isSidebarActive()) {
	      this.view.refreshPanel();
	    }
	  },

	  clearUserProperties: function () {
	    if (this.view && this.view.store && this.view.store.userProperties) {
	      this.view.store.userProperties.clear();
	    }
	  },

	  onPanelSelected: function () {
	    if (this.inspector.selection.nodeFront === this.view._viewedElement) {
	      this.refresh();
	    } else {
	      this.onSelected();
	    }
	  },

	  onLinkClicked: function (e, rule) {
	    let sheet = rule.parentStyleSheet;

	    // Chrome stylesheets are not listed in the style editor, so show
	    // these sheets in the view source window instead.
	    if (!sheet || sheet.isSystem) {
	      let href = rule.nodeHref || rule.href;
	      let toolbox = gDevTools.getToolbox(this.inspector.target);
	      toolbox.viewSource(href, rule.line);
	      return;
	    }

	    let location = promise.resolve(rule.location);
	    if (Services.prefs.getBoolPref(PREF_ORIG_SOURCES)) {
	      location = rule.getOriginalLocation();
	    }
	    location.then(({ source, href, line, column }) => {
	      let target = this.inspector.target;
	      if (Tools.styleEditor.isTargetSupported(target)) {
	        gDevTools.showToolbox(target, "styleeditor").then(function (toolbox) {
	          let url = source || href;
	          toolbox.getCurrentPanel().selectStyleSheet(url, line, column);
	        });
	      }
	      return;
	    });
	  },

	  onPropertyChanged: function () {
	    this.inspector.markDirty();
	  },

	  onViewRefreshed: function () {
	    this.inspector.emit("rule-view-refreshed");
	  },

	  /**
	   * When markup mutations occur, if an attribute of the selected node changes,
	   * we need to refresh the view as that might change the node's styles.
	   */
	  onMutations: function (mutations) {
	    for (let {type, target} of mutations) {
	      if (target === this.inspector.selection.nodeFront &&
	          type === "attributes") {
	        this.refresh();
	        break;
	      }
	    }
	  },

	  /**
	   * When the window gets resized, this may cause media-queries to match, and
	   * therefore, different styles may apply.
	   */
	  onResized: function () {
	    this.refresh();
	  },

	  destroy: function () {
	    this.inspector.walker.off("mutations", this.onMutations);
	    this.inspector.walker.off("resize", this.onResized);
	    this.inspector.selection.off("detached-front", this.onSelected);
	    this.inspector.selection.off("pseudoclass", this.refresh);
	    this.inspector.selection.off("new-node-front", this.onSelected);
	    this.inspector.target.off("navigate", this.clearUserProperties);
	    this.inspector.sidebar.off("ruleview-selected", this.onPanelSelected);
	    if (this.inspector.pageStyle) {
	      this.inspector.pageStyle.off("stylesheet-updated", this.refresh);
	    }

	    this.view.off("ruleview-linked-clicked", this.onLinkClicked);
	    this.view.off("ruleview-changed", this.onPropertyChanged);
	    this.view.off("ruleview-refreshed", this.onViewRefreshed);

	    this.view.destroy();

	    this.view = this.document = this.inspector = null;
	  }
	};

	exports.CssRuleView = CssRuleView;
	exports.RuleViewTool = RuleViewTool;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);
	const {Rule} = __webpack_require__(151);
	const {promiseWarn} = __webpack_require__(131);
	const {ELEMENT_STYLE} = __webpack_require__(124);
	const {getCssProperties} = __webpack_require__(18);

	/**
	 * ElementStyle is responsible for the following:
	 *   Keeps track of which properties are overridden.
	 *   Maintains a list of Rule objects for a given element.
	 *
	 * @param {Element} element
	 *        The element whose style we are viewing.
	 * @param {CssRuleView} ruleView
	 *        The instance of the rule-view panel.
	 * @param {Object} store
	 *        The ElementStyle can use this object to store metadata
	 *        that might outlast the rule view, particularly the current
	 *        set of disabled properties.
	 * @param {PageStyleFront} pageStyle
	 *        Front for the page style actor that will be providing
	 *        the style information.
	 * @param {Boolean} showUserAgentStyles
	 *        Should user agent styles be inspected?
	 */
	function ElementStyle(element, ruleView, store, pageStyle,
	    showUserAgentStyles) {
	  this.element = element;
	  this.ruleView = ruleView;
	  this.store = store || {};
	  this.pageStyle = pageStyle;
	  this.showUserAgentStyles = showUserAgentStyles;
	  this.rules = [];
	  this.cssProperties = getCssProperties(this.ruleView.inspector.toolbox);

	  // We don't want to overwrite this.store.userProperties so we only create it
	  // if it doesn't already exist.
	  if (!("userProperties" in this.store)) {
	    this.store.userProperties = new UserProperties();
	  }

	  if (!("disabled" in this.store)) {
	    this.store.disabled = new WeakMap();
	  }
	}

	ElementStyle.prototype = {
	  // The element we're looking at.
	  element: null,

	  destroy: function () {
	    if (this.destroyed) {
	      return;
	    }
	    this.destroyed = true;

	    for (let rule of this.rules) {
	      if (rule.editor) {
	        rule.editor.destroy();
	      }
	    }
	  },

	  /**
	   * Called by the Rule object when it has been changed through the
	   * setProperty* methods.
	   */
	  _changed: function () {
	    if (this.onChanged) {
	      this.onChanged();
	    }
	  },

	  /**
	   * Refresh the list of rules to be displayed for the active element.
	   * Upon completion, this.rules[] will hold a list of Rule objects.
	   *
	   * Returns a promise that will be resolved when the elementStyle is
	   * ready.
	   */
	  populate: function () {
	    let populated = this.pageStyle.getApplied(this.element, {
	      inherited: true,
	      matchedSelectors: true,
	      filter: this.showUserAgentStyles ? "ua" : undefined,
	    }).then(entries => {
	      if (this.destroyed) {
	        return promise.resolve(undefined);
	      }

	      if (this.populated !== populated) {
	        // Don't care anymore.
	        return promise.resolve(undefined);
	      }

	      // Store the current list of rules (if any) during the population
	      // process.  They will be reused if possible.
	      let existingRules = this.rules;

	      this.rules = [];

	      for (let entry of entries) {
	        this._maybeAddRule(entry, existingRules);
	      }

	      // Mark overridden computed styles.
	      this.markOverriddenAll();

	      this._sortRulesForPseudoElement();

	      // We're done with the previous list of rules.
	      for (let r of existingRules) {
	        if (r && r.editor) {
	          r.editor.destroy();
	        }
	      }

	      return undefined;
	    }).then(null, e => {
	      // populate is often called after a setTimeout,
	      // the connection may already be closed.
	      if (this.destroyed) {
	        return promise.resolve(undefined);
	      }
	      return promiseWarn(e);
	    });
	    this.populated = populated;
	    return this.populated;
	  },

	  /**
	   * Put pseudo elements in front of others.
	   */
	  _sortRulesForPseudoElement: function () {
	    this.rules = this.rules.sort((a, b) => {
	      return (a.pseudoElement || "z") > (b.pseudoElement || "z");
	    });
	  },

	  /**
	   * Add a rule if it's one we care about.  Filters out duplicates and
	   * inherited styles with no inherited properties.
	   *
	   * @param {Object} options
	   *        Options for creating the Rule, see the Rule constructor.
	   * @param {Array} existingRules
	   *        Rules to reuse if possible.  If a rule is reused, then it
	   *        it will be deleted from this array.
	   * @return {Boolean} true if we added the rule.
	   */
	  _maybeAddRule: function (options, existingRules) {
	    // If we've already included this domRule (for example, when a
	    // common selector is inherited), ignore it.
	    if (options.rule &&
	        this.rules.some(rule => rule.domRule === options.rule)) {
	      return false;
	    }

	    if (options.system) {
	      return false;
	    }

	    let rule = null;

	    // If we're refreshing and the rule previously existed, reuse the
	    // Rule object.
	    if (existingRules) {
	      let ruleIndex = existingRules.findIndex((r) => r.matches(options));
	      if (ruleIndex >= 0) {
	        rule = existingRules[ruleIndex];
	        rule.refresh(options);
	        existingRules.splice(ruleIndex, 1);
	      }
	    }

	    // If this is a new rule, create its Rule object.
	    if (!rule) {
	      rule = new Rule(this, options);
	    }

	    // Ignore inherited rules with no visible properties.
	    if (options.inherited && !rule.hasAnyVisibleProperties()) {
	      return false;
	    }

	    this.rules.push(rule);
	    return true;
	  },

	  /**
	   * Calls markOverridden with all supported pseudo elements
	   */
	  markOverriddenAll: function () {
	    this.markOverridden();
	    for (let pseudo of this.cssProperties.pseudoElements) {
	      this.markOverridden(pseudo);
	    }
	  },

	  /**
	   * Mark the properties listed in this.rules for a given pseudo element
	   * with an overridden flag if an earlier property overrides it.
	   *
	   * @param {String} pseudo
	   *        Which pseudo element to flag as overridden.
	   *        Empty string or undefined will default to no pseudo element.
	   */
	  markOverridden: function (pseudo = "") {
	    // Gather all the text properties applied by these rules, ordered
	    // from more- to less-specific. Text properties from keyframes rule are
	    // excluded from being marked as overridden since a number of criteria such
	    // as time, and animation overlay are required to be check in order to
	    // determine if the property is overridden.
	    let textProps = [];
	    for (let rule of this.rules) {
	      if ((rule.matchedSelectors.length > 0 ||
	           rule.domRule.type === ELEMENT_STYLE) &&
	          rule.pseudoElement === pseudo && !rule.keyframes) {
	        for (let textProp of rule.textProps.slice(0).reverse()) {
	          if (textProp.enabled) {
	            textProps.push(textProp);
	          }
	        }
	      }
	    }

	    // Gather all the computed properties applied by those text
	    // properties.
	    let computedProps = [];
	    for (let textProp of textProps) {
	      computedProps = computedProps.concat(textProp.computed);
	    }

	    // Walk over the computed properties.  As we see a property name
	    // for the first time, mark that property's name as taken by this
	    // property.
	    //
	    // If we come across a property whose name is already taken, check
	    // its priority against the property that was found first:
	    //
	    //   If the new property is a higher priority, mark the old
	    //   property overridden and mark the property name as taken by
	    //   the new property.
	    //
	    //   If the new property is a lower or equal priority, mark it as
	    //   overridden.
	    //
	    // _overriddenDirty will be set on each prop, indicating whether its
	    // dirty status changed during this pass.
	    let taken = {};
	    for (let computedProp of computedProps) {
	      let earlier = taken[computedProp.name];

	      // Prevent -webkit-gradient from being selected after unchecking
	      // linear-gradient in this case:
	      //  -moz-linear-gradient: ...;
	      //  -webkit-linear-gradient: ...;
	      //  linear-gradient: ...;
	      if (!computedProp.textProp.isValid()) {
	        computedProp.overridden = true;
	        continue;
	      }
	      let overridden;
	      if (earlier &&
	          computedProp.priority === "important" &&
	          earlier.priority !== "important" &&
	          (earlier.textProp.rule.inherited ||
	           !computedProp.textProp.rule.inherited)) {
	        // New property is higher priority.  Mark the earlier property
	        // overridden (which will reverse its dirty state).
	        earlier._overriddenDirty = !earlier._overriddenDirty;
	        earlier.overridden = true;
	        overridden = false;
	      } else {
	        overridden = !!earlier;
	      }

	      computedProp._overriddenDirty =
	        (!!computedProp.overridden !== overridden);
	      computedProp.overridden = overridden;
	      if (!computedProp.overridden && computedProp.textProp.enabled) {
	        taken[computedProp.name] = computedProp;
	      }
	    }

	    // For each TextProperty, mark it overridden if all of its
	    // computed properties are marked overridden.  Update the text
	    // property's associated editor, if any.  This will clear the
	    // _overriddenDirty state on all computed properties.
	    for (let textProp of textProps) {
	      // _updatePropertyOverridden will return true if the
	      // overridden state has changed for the text property.
	      if (this._updatePropertyOverridden(textProp)) {
	        textProp.updateEditor();
	      }
	    }
	  },

	  /**
	   * Mark a given TextProperty as overridden or not depending on the
	   * state of its computed properties.  Clears the _overriddenDirty state
	   * on all computed properties.
	   *
	   * @param {TextProperty} prop
	   *        The text property to update.
	   * @return {Boolean} true if the TextProperty's overridden state (or any of
	   *         its computed properties overridden state) changed.
	   */
	  _updatePropertyOverridden: function (prop) {
	    let overridden = true;
	    let dirty = false;
	    for (let computedProp of prop.computed) {
	      if (!computedProp.overridden) {
	        overridden = false;
	      }
	      dirty = computedProp._overriddenDirty || dirty;
	      delete computedProp._overriddenDirty;
	    }

	    dirty = (!!prop.overridden !== overridden) || dirty;
	    prop.overridden = overridden;
	    return dirty;
	  }
	};

	/**
	 * Store of CSSStyleDeclarations mapped to properties that have been changed by
	 * the user.
	 */
	function UserProperties() {
	  this.map = new Map();
	}

	UserProperties.prototype = {
	  /**
	   * Get a named property for a given CSSStyleDeclaration.
	   *
	   * @param {CSSStyleDeclaration} style
	   *        The CSSStyleDeclaration against which the property is mapped.
	   * @param {String} name
	   *        The name of the property to get.
	   * @param {String} value
	   *        Default value.
	   * @return {String}
	   *        The property value if it has previously been set by the user, null
	   *        otherwise.
	   */
	  getProperty: function (style, name, value) {
	    let key = this.getKey(style);
	    let entry = this.map.get(key, null);

	    if (entry && name in entry) {
	      return entry[name];
	    }
	    return value;
	  },

	  /**
	   * Set a named property for a given CSSStyleDeclaration.
	   *
	   * @param {CSSStyleDeclaration} style
	   *        The CSSStyleDeclaration against which the property is to be mapped.
	   * @param {String} bame
	   *        The name of the property to set.
	   * @param {String} userValue
	   *        The value of the property to set.
	   */
	  setProperty: function (style, bame, userValue) {
	    let key = this.getKey(style, bame);
	    let entry = this.map.get(key, null);

	    if (entry) {
	      entry[bame] = userValue;
	    } else {
	      let props = {};
	      props[bame] = userValue;
	      this.map.set(key, props);
	    }
	  },

	  /**
	   * Check whether a named property for a given CSSStyleDeclaration is stored.
	   *
	   * @param {CSSStyleDeclaration} style
	   *        The CSSStyleDeclaration against which the property would be mapped.
	   * @param {String} name
	   *        The name of the property to check.
	   */
	  contains: function (style, name) {
	    let key = this.getKey(style, name);
	    let entry = this.map.get(key, null);
	    return !!entry && name in entry;
	  },

	  getKey: function (style, name) {
	    return style.actorID + ":" + name;
	  },

	  clear: function () {
	    this.map.clear();
	  }
	};

	exports.ElementStyle = ElementStyle;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);
	const CssLogic = __webpack_require__(122);
	const {ELEMENT_STYLE} = __webpack_require__(124);
	const {TextProperty} =
	      __webpack_require__(152);
	const {promiseWarn} = __webpack_require__(131);
	const {parseDeclarations} = __webpack_require__(132);
	const Services = __webpack_require__(1);

	const STYLE_INSPECTOR_PROPERTIES = "devtools-shared/locale/styleinspector.properties";
	const {LocalizationHelper} = __webpack_require__(39);
	const STYLE_INSPECTOR_L10N = new LocalizationHelper(STYLE_INSPECTOR_PROPERTIES);

	/**
	 * Rule is responsible for the following:
	 *   Manages a single style declaration or rule.
	 *   Applies changes to the properties in a rule.
	 *   Maintains a list of TextProperty objects.
	 *
	 * @param {ElementStyle} elementStyle
	 *        The ElementStyle to which this rule belongs.
	 * @param {Object} options
	 *        The information used to construct this rule.  Properties include:
	 *          rule: A StyleRuleActor
	 *          inherited: An element this rule was inherited from.  If omitted,
	 *            the rule applies directly to the current element.
	 *          isSystem: Is this a user agent style?
	 *          isUnmatched: True if the rule does not match the current selected
	 *            element, otherwise, false.
	 */
	function Rule(elementStyle, options) {
	  this.elementStyle = elementStyle;
	  this.domRule = options.rule || null;
	  this.style = options.rule;
	  this.matchedSelectors = options.matchedSelectors || [];
	  this.pseudoElement = options.pseudoElement || "";

	  this.isSystem = options.isSystem;
	  this.isUnmatched = options.isUnmatched || false;
	  this.inherited = options.inherited || null;
	  this.keyframes = options.keyframes || null;
	  this._modificationDepth = 0;

	  if (this.domRule && this.domRule.mediaText) {
	    this.mediaText = this.domRule.mediaText;
	  }

	  this.cssProperties = this.elementStyle.ruleView.cssProperties;

	  // Populate the text properties with the style's current authoredText
	  // value, and add in any disabled properties from the store.
	  this.textProps = this._getTextProperties();
	  this.textProps = this.textProps.concat(this._getDisabledProperties());
	}

	Rule.prototype = {
	  mediaText: "",

	  get title() {
	    let title = CssLogic.shortSource(this.sheet);
	    if (this.domRule.type !== ELEMENT_STYLE && this.ruleLine > 0) {
	      title += ":" + this.ruleLine;
	    }

	    return title + (this.mediaText ? " @media " + this.mediaText : "");
	  },

	  get inheritedSource() {
	    if (this._inheritedSource) {
	      return this._inheritedSource;
	    }
	    this._inheritedSource = "";
	    if (this.inherited) {
	      let eltText = this.inherited.displayName;
	      if (this.inherited.id) {
	        eltText += "#" + this.inherited.id;
	      }
	      this._inheritedSource =
	        STYLE_INSPECTOR_L10N.getFormatStr("rule.inheritedFrom", eltText);
	    }
	    return this._inheritedSource;
	  },

	  get keyframesName() {
	    if (this._keyframesName) {
	      return this._keyframesName;
	    }
	    this._keyframesName = "";
	    if (this.keyframes) {
	      this._keyframesName =
	        STYLE_INSPECTOR_L10N.getFormatStr("rule.keyframe", this.keyframes.name);
	    }
	    return this._keyframesName;
	  },

	  get selectorText() {
	    return this.domRule.selectors ? this.domRule.selectors.join(", ") :
	      CssLogic.l10n("rule.sourceElement");
	  },

	  /**
	   * The rule's stylesheet.
	   */
	  get sheet() {
	    return this.domRule ? this.domRule.parentStyleSheet : null;
	  },

	  /**
	   * The rule's line within a stylesheet
	   */
	  get ruleLine() {
	    return this.domRule ? this.domRule.line : "";
	  },

	  /**
	   * The rule's column within a stylesheet
	   */
	  get ruleColumn() {
	    return this.domRule ? this.domRule.column : null;
	  },

	  /**
	   * Get display name for this rule based on the original source
	   * for this rule's style sheet.
	   *
	   * @return {Promise}
	   *         Promise which resolves with location as an object containing
	   *         both the full and short version of the source string.
	   */
	  getOriginalSourceStrings: function () {
	    return this.domRule.getOriginalLocation().then(({href,
	                                                     line, mediaText}) => {
	      let mediaString = mediaText ? " @" + mediaText : "";
	      let linePart = line > 0 ? (":" + line) : "";

	      let sourceStrings = {
	        full: (href || CssLogic.l10n("rule.sourceInline")) + linePart +
	          mediaString,
	        short: CssLogic.shortSource({href: href}) + linePart + mediaString
	      };

	      return sourceStrings;
	    });
	  },

	  /**
	   * Returns true if the rule matches the creation options
	   * specified.
	   *
	   * @param {Object} options
	   *        Creation options. See the Rule constructor for documentation.
	   */
	  matches: function (options) {
	    return this.style === options.rule;
	  },

	  /**
	   * Create a new TextProperty to include in the rule.
	   *
	   * @param {String} name
	   *        The text property name (such as "background" or "border-top").
	   * @param {String} value
	   *        The property's value (not including priority).
	   * @param {String} priority
	   *        The property's priority (either "important" or an empty string).
	   * @param {Boolean} enabled
	   *        True if the property should be enabled.
	   * @param {TextProperty} siblingProp
	   *        Optional, property next to which the new property will be added.
	   */
	  createProperty: function (name, value, priority, enabled, siblingProp) {
	    let prop = new TextProperty(this, name, value, priority, enabled);

	    let ind;
	    if (siblingProp) {
	      ind = this.textProps.indexOf(siblingProp) + 1;
	      this.textProps.splice(ind, 0, prop);
	    } else {
	      ind = this.textProps.length;
	      this.textProps.push(prop);
	    }

	    this.applyProperties((modifications) => {
	      modifications.createProperty(ind, name, value, priority);
	      // Now that the rule has been updated, the server might have given us data
	      // that changes the state of the property. Update it now.
	      prop.updateEditor();
	    });

	    return prop;
	  },

	  /**
	   * Helper function for applyProperties that is called when the actor
	   * does not support as-authored styles.  Store disabled properties
	   * in the element style's store.
	   */
	  _applyPropertiesNoAuthored: function (modifications) {
	    this.elementStyle.markOverriddenAll();

	    let disabledProps = [];

	    for (let prop of this.textProps) {
	      if (prop.invisible) {
	        continue;
	      }
	      if (!prop.enabled) {
	        disabledProps.push({
	          name: prop.name,
	          value: prop.value,
	          priority: prop.priority
	        });
	        continue;
	      }
	      if (prop.value.trim() === "") {
	        continue;
	      }

	      modifications.setProperty(-1, prop.name, prop.value, prop.priority);

	      prop.updateComputed();
	    }

	    // Store disabled properties in the disabled store.
	    let disabled = this.elementStyle.store.disabled;
	    if (disabledProps.length > 0) {
	      disabled.set(this.style, disabledProps);
	    } else {
	      disabled.delete(this.style);
	    }

	    return modifications.apply().then(() => {
	      let cssProps = {};
	      // Note that even though StyleRuleActors normally provide parsed
	      // declarations already, _applyPropertiesNoAuthored is only used when
	      // connected to older backend that do not provide them. So parse here.
	      for (let cssProp of parseDeclarations(this.cssProperties.isKnown,
	                                            this.style.authoredText)) {
	        cssProps[cssProp.name] = cssProp;
	      }

	      for (let textProp of this.textProps) {
	        if (!textProp.enabled) {
	          continue;
	        }
	        let cssProp = cssProps[textProp.name];

	        if (!cssProp) {
	          cssProp = {
	            name: textProp.name,
	            value: "",
	            priority: ""
	          };
	        }

	        textProp.priority = cssProp.priority;
	      }
	    });
	  },

	  /**
	   * A helper for applyProperties that applies properties in the "as
	   * authored" case; that is, when the StyleRuleActor supports
	   * setRuleText.
	   */
	  _applyPropertiesAuthored: function (modifications) {
	    return modifications.apply().then(() => {
	      // The rewriting may have required some other property values to
	      // change, e.g., to insert some needed terminators.  Update the
	      // relevant properties here.
	      for (let index in modifications.changedDeclarations) {
	        let newValue = modifications.changedDeclarations[index];
	        this.textProps[index].noticeNewValue(newValue);
	      }
	      // Recompute and redisplay the computed properties.
	      for (let prop of this.textProps) {
	        if (!prop.invisible && prop.enabled) {
	          prop.updateComputed();
	          prop.updateEditor();
	        }
	      }
	    });
	  },

	  /**
	   * Reapply all the properties in this rule, and update their
	   * computed styles.  Will re-mark overridden properties.  Sets the
	   * |_applyingModifications| property to a promise which will resolve
	   * when the edit has completed.
	   *
	   * @param {Function} modifier a function that takes a RuleModificationList
	   *        (or RuleRewriter) as an argument and that modifies it
	   *        to apply the desired edit
	   * @return {Promise} a promise which will resolve when the edit
	   *        is complete
	   */
	  applyProperties: function (modifier) {
	    // If there is already a pending modification, we have to wait
	    // until it settles before applying the next modification.
	    let resultPromise =
	        promise.resolve(this._applyingModifications).then(() => {
	          let modifications = this.style.startModifyingProperties(
	            this.cssProperties);
	          modifier(modifications);
	          if (this.style.canSetRuleText) {
	            return this._applyPropertiesAuthored(modifications);
	          }
	          return this._applyPropertiesNoAuthored(modifications);
	        }).then(() => {
	          this.elementStyle.markOverriddenAll();

	          if (resultPromise === this._applyingModifications) {
	            this._applyingModifications = null;
	            this.elementStyle._changed();
	          }
	        }).catch(promiseWarn);

	    this._applyingModifications = resultPromise;
	    return resultPromise;
	  },

	  /**
	   * Renames a property.
	   *
	   * @param {TextProperty} property
	   *        The property to rename.
	   * @param {String} name
	   *        The new property name (such as "background" or "border-top").
	   */
	  setPropertyName: function (property, name) {
	    if (name === property.name) {
	      return;
	    }

	    let oldName = property.name;
	    property.name = name;
	    let index = this.textProps.indexOf(property);
	    this.applyProperties((modifications) => {
	      modifications.renameProperty(index, oldName, name);
	    });
	  },

	  /**
	   * Sets the value and priority of a property, then reapply all properties.
	   *
	   * @param {TextProperty} property
	   *        The property to manipulate.
	   * @param {String} value
	   *        The property's value (not including priority).
	   * @param {String} priority
	   *        The property's priority (either "important" or an empty string).
	   */
	  setPropertyValue: function (property, value, priority) {
	    if (value === property.value && priority === property.priority) {
	      return;
	    }

	    property.value = value;
	    property.priority = priority;

	    let index = this.textProps.indexOf(property);
	    this.applyProperties((modifications) => {
	      modifications.setProperty(index, property.name, value, priority);
	    });
	  },

	  /**
	   * Just sets the value and priority of a property, in order to preview its
	   * effect on the content document.
	   *
	   * @param {TextProperty} property
	   *        The property which value will be previewed
	   * @param {String} value
	   *        The value to be used for the preview
	   * @param {String} priority
	   *        The property's priority (either "important" or an empty string).
	   */
	  previewPropertyValue: function (property, value, priority) {
	    let modifications = this.style.startModifyingProperties(this.cssProperties);
	    modifications.setProperty(this.textProps.indexOf(property),
	                              property.name, value, priority);
	    modifications.apply().then(() => {
	      // Ensure dispatching a ruleview-changed event
	      // also for previews
	      this.elementStyle._changed();
	    });
	  },

	  /**
	   * Disables or enables given TextProperty.
	   *
	   * @param {TextProperty} property
	   *        The property to enable/disable
	   * @param {Boolean} value
	   */
	  setPropertyEnabled: function (property, value) {
	    if (property.enabled === !!value) {
	      return;
	    }
	    property.enabled = !!value;
	    let index = this.textProps.indexOf(property);
	    this.applyProperties((modifications) => {
	      modifications.setPropertyEnabled(index, property.name, property.enabled);
	    });
	  },

	  /**
	   * Remove a given TextProperty from the rule and update the rule
	   * accordingly.
	   *
	   * @param {TextProperty} property
	   *        The property to be removed
	   */
	  removeProperty: function (property) {
	    let index = this.textProps.indexOf(property);
	    this.textProps.splice(index, 1);
	    // Need to re-apply properties in case removing this TextProperty
	    // exposes another one.
	    this.applyProperties((modifications) => {
	      modifications.removeProperty(index, property.name);
	    });
	  },

	  /**
	   * Get the list of TextProperties from the style. Needs
	   * to parse the style's authoredText.
	   */
	  _getTextProperties: function () {
	    let textProps = [];
	    let store = this.elementStyle.store;

	    // Starting with FF49, StyleRuleActors provide parsed declarations.
	    let props = this.style.declarations;
	    if (!props.length) {
	      props = parseDeclarations(this.cssProperties.isKnown,
	                                this.style.authoredText, true);
	    }

	    for (let prop of props) {
	      let name = prop.name;
	      // If the authored text has an invalid property, it will show up
	      // as nameless.  Skip these as we don't currently have a good
	      // way to display them.
	      if (!name) {
	        continue;
	      }
	      // In an inherited rule, we only show inherited properties.
	      // However, we must keep all properties in order for rule
	      // rewriting to work properly.  So, compute the "invisible"
	      // property here.
	      let invisible = this.inherited && !this.cssProperties.isInherited(name);
	      let value = store.userProperties.getProperty(this.style, name,
	                                                   prop.value);
	      let textProp = new TextProperty(this, name, value, prop.priority,
	                                      !("commentOffsets" in prop),
	                                      invisible);
	      textProps.push(textProp);
	    }

	    return textProps;
	  },

	  /**
	   * Return the list of disabled properties from the store for this rule.
	   */
	  _getDisabledProperties: function () {
	    let store = this.elementStyle.store;

	    // Include properties from the disabled property store, if any.
	    let disabledProps = store.disabled.get(this.style);
	    if (!disabledProps) {
	      return [];
	    }

	    let textProps = [];

	    for (let prop of disabledProps) {
	      let value = store.userProperties.getProperty(this.style, prop.name,
	                                                   prop.value);
	      let textProp = new TextProperty(this, prop.name, value, prop.priority);
	      textProp.enabled = false;
	      textProps.push(textProp);
	    }

	    return textProps;
	  },

	  /**
	   * Reread the current state of the rules and rebuild text
	   * properties as needed.
	   */
	  refresh: function (options) {
	    this.matchedSelectors = options.matchedSelectors || [];
	    let newTextProps = this._getTextProperties();

	    // Update current properties for each property present on the style.
	    // This will mark any touched properties with _visited so we
	    // can detect properties that weren't touched (because they were
	    // removed from the style).
	    // Also keep track of properties that didn't exist in the current set
	    // of properties.
	    let brandNewProps = [];
	    for (let newProp of newTextProps) {
	      if (!this._updateTextProperty(newProp)) {
	        brandNewProps.push(newProp);
	      }
	    }

	    // Refresh editors and disabled state for all the properties that
	    // were updated.
	    for (let prop of this.textProps) {
	      // Properties that weren't touched during the update
	      // process must no longer exist on the node.  Mark them disabled.
	      if (!prop._visited) {
	        prop.enabled = false;
	        prop.updateEditor();
	      } else {
	        delete prop._visited;
	      }
	    }

	    // Add brand new properties.
	    this.textProps = this.textProps.concat(brandNewProps);

	    // Refresh the editor if one already exists.
	    if (this.editor) {
	      this.editor.populate();
	    }
	  },

	  /**
	   * Update the current TextProperties that match a given property
	   * from the authoredText.  Will choose one existing TextProperty to update
	   * with the new property's value, and will disable all others.
	   *
	   * When choosing the best match to reuse, properties will be chosen
	   * by assigning a rank and choosing the highest-ranked property:
	   *   Name, value, and priority match, enabled. (6)
	   *   Name, value, and priority match, disabled. (5)
	   *   Name and value match, enabled. (4)
	   *   Name and value match, disabled. (3)
	   *   Name matches, enabled. (2)
	   *   Name matches, disabled. (1)
	   *
	   * If no existing properties match the property, nothing happens.
	   *
	   * @param {TextProperty} newProp
	   *        The current version of the property, as parsed from the
	   *        authoredText in Rule._getTextProperties().
	   * @return {Boolean} true if a property was updated, false if no properties
	   *         were updated.
	   */
	  _updateTextProperty: function (newProp) {
	    let match = { rank: 0, prop: null };

	    for (let prop of this.textProps) {
	      if (prop.name !== newProp.name) {
	        continue;
	      }

	      // Mark this property visited.
	      prop._visited = true;

	      // Start at rank 1 for matching name.
	      let rank = 1;

	      // Value and Priority matches add 2 to the rank.
	      // Being enabled adds 1.  This ranks better matches higher,
	      // with priority breaking ties.
	      if (prop.value === newProp.value) {
	        rank += 2;
	        if (prop.priority === newProp.priority) {
	          rank += 2;
	        }
	      }

	      if (prop.enabled) {
	        rank += 1;
	      }

	      if (rank > match.rank) {
	        if (match.prop) {
	          // We outrank a previous match, disable it.
	          match.prop.enabled = false;
	          match.prop.updateEditor();
	        }
	        match.rank = rank;
	        match.prop = prop;
	      } else if (rank) {
	        // A previous match outranks us, disable ourself.
	        prop.enabled = false;
	        prop.updateEditor();
	      }
	    }

	    // If we found a match, update its value with the new text property
	    // value.
	    if (match.prop) {
	      match.prop.set(newProp);
	      return true;
	    }

	    return false;
	  },

	  /**
	   * Jump between editable properties in the UI. If the focus direction is
	   * forward, begin editing the next property name if available or focus the
	   * new property editor otherwise. If the focus direction is backward,
	   * begin editing the previous property value or focus the selector editor if
	   * this is the first element in the property list.
	   *
	   * @param {TextProperty} textProperty
	   *        The text property that will be left to focus on a sibling.
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  editClosestTextProperty: function (textProperty, direction) {
	    let index = this.textProps.indexOf(textProperty);

	    if (direction === Services.focus.MOVEFOCUS_FORWARD) {
	      for (++index; index < this.textProps.length; ++index) {
	        if (!this.textProps[index].invisible) {
	          break;
	        }
	      }
	      if (index === this.textProps.length) {
	        textProperty.rule.editor.closeBrace.click();
	      } else {
	        this.textProps[index].editor.nameSpan.click();
	      }
	    } else if (direction === Services.focus.MOVEFOCUS_BACKWARD) {
	      for (--index; index >= 0; --index) {
	        if (!this.textProps[index].invisible) {
	          break;
	        }
	      }
	      if (index < 0) {
	        textProperty.editor.ruleEditor.selectorText.click();
	      } else {
	        this.textProps[index].editor.valueSpan.click();
	      }
	    }
	  },

	  /**
	   * Return a string representation of the rule.
	   */
	  stringifyRule: function () {
	    let selectorText = this.selectorText;
	    let cssText = "";
	    let terminator = Services.appinfo.OS === "WINNT" ? "\r\n" : "\n";

	    for (let textProp of this.textProps) {
	      if (!textProp.invisible) {
	        cssText += "\t" + textProp.stringifyProperty() + terminator;
	      }
	    }

	    return selectorText + " {" + terminator + cssText + "}";
	  },

	  /**
	   * See whether this rule has any non-invisible properties.
	   * @return {Boolean} true if there is any visible property, or false
	   *         if all properties are invisible
	   */
	  hasAnyVisibleProperties: function () {
	    for (let prop of this.textProps) {
	      if (!prop.invisible) {
	        return true;
	      }
	    }
	    return false;
	  }
	};

	exports.Rule = Rule;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {escapeCSSComment} = __webpack_require__(132);
	const {getCssProperties} = __webpack_require__(18);

	/**
	 * TextProperty is responsible for the following:
	 *   Manages a single property from the authoredText attribute of the
	 *     relevant declaration.
	 *   Maintains a list of computed properties that come from this
	 *     property declaration.
	 *   Changes to the TextProperty are sent to its related Rule for
	 *     application.
	 *
	 * @param {Rule} rule
	 *        The rule this TextProperty came from.
	 * @param {String} name
	 *        The text property name (such as "background" or "border-top").
	 * @param {String} value
	 *        The property's value (not including priority).
	 * @param {String} priority
	 *        The property's priority (either "important" or an empty string).
	 * @param {Boolean} enabled
	 *        Whether the property is enabled.
	 * @param {Boolean} invisible
	 *        Whether the property is invisible.  An invisible property
	 *        does not show up in the UI; these are needed so that the
	 *        index of a property in Rule.textProps is the same as the index
	 *        coming from parseDeclarations.
	 */
	function TextProperty(rule, name, value, priority, enabled = true,
	                      invisible = false) {
	  this.rule = rule;
	  this.name = name;
	  this.value = value;
	  this.priority = priority;
	  this.enabled = !!enabled;
	  this.invisible = invisible;
	  this.updateComputed();

	  const toolbox = this.rule.elementStyle.ruleView.inspector.toolbox;
	  this.cssProperties = getCssProperties(toolbox);
	}

	TextProperty.prototype = {
	  /**
	   * Update the editor associated with this text property,
	   * if any.
	   */
	  updateEditor: function () {
	    if (this.editor) {
	      this.editor.update();
	    }
	  },

	  /**
	   * Update the list of computed properties for this text property.
	   */
	  updateComputed: function () {
	    if (!this.name) {
	      return;
	    }

	    // This is a bit funky.  To get the list of computed properties
	    // for this text property, we'll set the property on a dummy element
	    // and see what the computed style looks like.
	    let dummyElement = this.rule.elementStyle.ruleView.dummyElement;
	    let dummyStyle = dummyElement.style;
	    dummyStyle.cssText = "";
	    dummyStyle.setProperty(this.name, this.value, this.priority);

	    this.computed = [];

	    try {
	      // Manually get all the properties that are set when setting a value on
	      // this.name and check the computed style on dummyElement for each one.
	      // If we just read dummyStyle, it would skip properties when value === "".
	      let subProps = domUtils.getSubpropertiesForCSSProperty(this.name);

	      for (let prop of subProps) {
	        this.computed.push({
	          textProp: this,
	          name: prop,
	          value: dummyStyle.getPropertyValue(prop),
	          priority: dummyStyle.getPropertyPriority(prop),
	        });
	      }
	    } catch (e) {
	      // This is a partial property name, probably from cutting and pasting
	      // text. At this point don't check for computed properties.
	    }
	  },

	  /**
	   * Set all the values from another TextProperty instance into
	   * this TextProperty instance.
	   *
	   * @param {TextProperty} prop
	   *        The other TextProperty instance.
	   */
	  set: function (prop) {
	    let changed = false;
	    for (let item of ["name", "value", "priority", "enabled"]) {
	      if (this[item] !== prop[item]) {
	        this[item] = prop[item];
	        changed = true;
	      }
	    }

	    if (changed) {
	      this.updateEditor();
	    }
	  },

	  setValue: function (value, priority, force = false) {
	    let store = this.rule.elementStyle.store;

	    if (this.editor && value !== this.editor.committed.value || force) {
	      store.userProperties.setProperty(this.rule.style, this.name, value);
	    }

	    this.rule.setPropertyValue(this, value, priority);
	    this.updateEditor();
	  },

	  /**
	   * Called when the property's value has been updated externally, and
	   * the property and editor should update.
	   */
	  noticeNewValue: function (value) {
	    if (value !== this.value) {
	      this.value = value;
	      this.updateEditor();
	    }
	  },

	  setName: function (name) {
	    let store = this.rule.elementStyle.store;

	    if (name !== this.name) {
	      store.userProperties.setProperty(this.rule.style, name,
	                                       this.editor.committed.value);
	    }

	    this.rule.setPropertyName(this, name);
	    this.updateEditor();
	  },

	  setEnabled: function (value) {
	    this.rule.setPropertyEnabled(this, value);
	    this.updateEditor();
	  },

	  remove: function () {
	    this.rule.removeProperty(this);
	  },

	  /**
	   * Return a string representation of the rule property.
	   */
	  stringifyProperty: function () {
	    // Get the displayed property value
	    let declaration = this.name + ": " + this.editor.valueSpan.textContent +
	      ";";

	    // Comment out property declarations that are not enabled
	    if (!this.enabled) {
	      declaration = "/* " + escapeCSSComment(declaration) + " */";
	    }

	    return declaration;
	  },

	  /**
	   * See whether this property's name is known.
	   *
	   * @return {Boolean} true if the property name is known, false otherwise.
	   */
	  isKnownProperty: function () {
	    return this.cssProperties.isKnown(this.name);
	  },

	  /**
	   * Validate this property. Does it make sense for this value to be assigned
	   * to this property name?
	   *
	   * @return {Boolean} true if the property value is valid, false otherwise.
	   */
	  isValid: function () {
	    // Starting with FF49, StyleRuleActors provide a list of parsed
	    // declarations, with data about their validity, but if we don't have this,
	    // compute validity locally (which might not be correct, but better than
	    // nothing).
	    if (!this.rule.domRule.declarations) {
	      return domUtils.cssPropertyIsValid(this.name, this.value);
	    }

	    let selfIndex = this.rule.textProps.indexOf(this);

	    // When adding a new property in the rule-view, the TextProperty object is
	    // created right away before the rule gets updated on the server, so we're
	    // not going to find the corresponding declaration object yet. Default to
	    // true.
	    if (!this.rule.domRule.declarations[selfIndex]) {
	      return true;
	    }

	    return this.rule.domRule.declarations[selfIndex].isValid;
	  }
	};

	exports.TextProperty = TextProperty;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {l10n} = __webpack_require__(122);
	const {ELEMENT_STYLE} = __webpack_require__(124);
	const {PREF_ORIG_SOURCES} = __webpack_require__(130);
	const {Rule} = __webpack_require__(151);
	const {InplaceEditor, editableField, editableItem} =
	      __webpack_require__(154);
	const {TextPropertyEditor} =
	      __webpack_require__(156);
	const {
	  createChild,
	  blurOnMultipleProperties,
	  promiseWarn
	} = __webpack_require__(131);
	const {
	  parseDeclarations,
	  parsePseudoClassesAndAttributes,
	  SELECTOR_ATTRIBUTE,
	  SELECTOR_ELEMENT,
	  SELECTOR_PSEUDO_CLASS
	} = __webpack_require__(132);
	const promise = __webpack_require__(4);
	const Services = __webpack_require__(1);
	const EventEmitter = __webpack_require__(6);

	const STYLE_INSPECTOR_PROPERTIES = "devtools-shared/locale/styleinspector.properties";
	const {LocalizationHelper} = __webpack_require__(39);
	const STYLE_INSPECTOR_L10N = new LocalizationHelper(STYLE_INSPECTOR_PROPERTIES);

	const HTML_NS = "http://www.w3.org/1999/xhtml";
	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";

	/**
	 * RuleEditor is responsible for the following:
	 *   Owns a Rule object and creates a list of TextPropertyEditors
	 *     for its TextProperties.
	 *   Manages creation of new text properties.
	 *
	 * One step of a RuleEditor's instantiation is figuring out what's the original
	 * source link to the parent stylesheet (in case of source maps). This step is
	 * asynchronous and is triggered as soon as the RuleEditor is instantiated (see
	 * updateSourceLink). If you need to know when the RuleEditor is done with this,
	 * you need to listen to the source-link-updated event.
	 *
	 * @param {CssRuleView} ruleView
	 *        The CssRuleView containg the document holding this rule editor.
	 * @param {Rule} rule
	 *        The Rule object we're editing.
	 */
	function RuleEditor(ruleView, rule) {
	  EventEmitter.decorate(this);

	  this.ruleView = ruleView;
	  this.doc = this.ruleView.styleDocument;
	  this.toolbox = this.ruleView.inspector.toolbox;
	  this.rule = rule;

	  this.isEditable = !rule.isSystem;
	  // Flag that blocks updates of the selector and properties when it is
	  // being edited
	  this.isEditing = false;

	  this._onNewProperty = this._onNewProperty.bind(this);
	  this._newPropertyDestroy = this._newPropertyDestroy.bind(this);
	  this._onSelectorDone = this._onSelectorDone.bind(this);
	  this._locationChanged = this._locationChanged.bind(this);
	  this.updateSourceLink = this.updateSourceLink.bind(this);

	  this.rule.domRule.on("location-changed", this._locationChanged);
	  this.toolbox.on("tool-registered", this.updateSourceLink);
	  this.toolbox.on("tool-unregistered", this.updateSourceLink);

	  this._create();
	}

	RuleEditor.prototype = {
	  destroy: function () {
	    this.rule.domRule.off("location-changed");
	    this.toolbox.off("tool-registered", this.updateSourceLink);
	    this.toolbox.off("tool-unregistered", this.updateSourceLink);
	  },

	  get isSelectorEditable() {
	    let trait = this.isEditable &&
	      this.toolbox.target.client.traits.selectorEditable &&
	      this.rule.domRule.type !== ELEMENT_STYLE &&
	      this.rule.domRule.type !== CSSRule.KEYFRAME_RULE;

	    // Do not allow editing anonymousselectors until we can
	    // detect mutations on  pseudo elements in Bug 1034110.
	    return trait && !this.rule.elementStyle.element.isAnonymous;
	  },

	  _create: function () {
	    this.element = this.doc.createElementNS(HTML_NS, "div");
	    this.element.className = "ruleview-rule theme-separator";
	    this.element.setAttribute("uneditable", !this.isEditable);
	    this.element.setAttribute("unmatched", this.rule.isUnmatched);
	    this.element._ruleEditor = this;

	    // Give a relative position for the inplace editor's measurement
	    // span to be placed absolutely against.
	    this.element.style.position = "relative";

	    // Add the source link.
	    this.source = createChild(this.element, "div", {
	      class: "ruleview-rule-source theme-link"
	    });
	    this.source.addEventListener("click", function () {
	      if (this.source.hasAttribute("unselectable")) {
	        return;
	      }
	      let rule = this.rule.domRule;
	      this.ruleView.emit("ruleview-linked-clicked", rule);
	    }.bind(this));
	    let sourceLabel = this.doc.createElementNS(XUL_NS, "label");
	    sourceLabel.setAttribute("crop", "center");
	    sourceLabel.classList.add("ruleview-rule-source-label");
	    this.source.appendChild(sourceLabel);

	    this.updateSourceLink();

	    let code = createChild(this.element, "div", {
	      class: "ruleview-code"
	    });

	    let header = createChild(code, "div", {});

	    this.selectorText = createChild(header, "span", {
	      class: "ruleview-selectorcontainer theme-fg-color3",
	      tabindex: this.isSelectorEditable ? "0" : "-1",
	    });

	    if (this.isSelectorEditable) {
	      this.selectorText.addEventListener("click", event => {
	        // Clicks within the selector shouldn't propagate any further.
	        event.stopPropagation();
	      }, false);

	      editableField({
	        element: this.selectorText,
	        done: this._onSelectorDone,
	        cssProperties: this.rule.cssProperties
	      });
	    }

	    if (this.rule.domRule.type !== CSSRule.KEYFRAME_RULE &&
	        this.rule.domRule.selectors) {
	      let selector = this.rule.domRule.selectors.join(", ");

	      let selectorHighlighter = createChild(header, "span", {
	        class: "ruleview-selectorhighlighter" +
	               (this.ruleView.highlightedSelector === selector ?
	                " highlighted" : ""),
	        title: l10n("rule.selectorHighlighter.tooltip")
	      });
	      selectorHighlighter.addEventListener("click", () => {
	        this.ruleView.toggleSelectorHighlighter(selectorHighlighter, selector);
	      });
	    }

	    this.openBrace = createChild(header, "span", {
	      class: "ruleview-ruleopen",
	      textContent: " {"
	    });

	    this.propertyList = createChild(code, "ul", {
	      class: "ruleview-propertylist"
	    });

	    this.populate();

	    this.closeBrace = createChild(code, "div", {
	      class: "ruleview-ruleclose",
	      tabindex: this.isEditable ? "0" : "-1",
	      textContent: "}"
	    });

	    if (this.isEditable) {
	      // A newProperty editor should only be created when no editor was
	      // previously displayed. Since the editors are cleared on blur,
	      // check this.ruleview.isEditing on mousedown
	      this._ruleViewIsEditing = false;

	      code.addEventListener("mousedown", () => {
	        this._ruleViewIsEditing = this.ruleView.isEditing;
	      });

	      code.addEventListener("click", () => {
	        let selection = this.doc.defaultView.getSelection();
	        if (selection.isCollapsed && !this._ruleViewIsEditing) {
	          this.newProperty();
	        }
	        // Cleanup the _ruleViewIsEditing flag
	        this._ruleViewIsEditing = false;
	      }, false);

	      this.element.addEventListener("mousedown", () => {
	        this.doc.defaultView.focus();
	      }, false);

	      // Create a property editor when the close brace is clicked.
	      editableItem({ element: this.closeBrace }, () => {
	        this.newProperty();
	      });
	    }
	  },

	  /**
	   * Event handler called when a property changes on the
	   * StyleRuleActor.
	   */
	  _locationChanged: function () {
	    this.updateSourceLink();
	  },

	  updateSourceLink: function () {
	    let sourceLabel = this.element.querySelector(".ruleview-rule-source-label");
	    let title = this.rule.title;
	    let sourceHref = (this.rule.sheet && this.rule.sheet.href) ?
	      this.rule.sheet.href : title;
	    let sourceLine = this.rule.ruleLine > 0 ? ":" + this.rule.ruleLine : "";

	    sourceLabel.setAttribute("tooltiptext", sourceHref + sourceLine);

	    if (this.toolbox.isToolRegistered("styleeditor")) {
	      this.source.removeAttribute("unselectable");
	    } else {
	      this.source.setAttribute("unselectable", true);
	    }

	    if (this.rule.isSystem) {
	      let uaLabel = STYLE_INSPECTOR_L10N.getStr("rule.userAgentStyles");
	      sourceLabel.setAttribute("value", uaLabel + " " + title);

	      // Special case about:PreferenceStyleSheet, as it is generated on the
	      // fly and the URI is not registered with the about: handler.
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=935803#c37
	      if (sourceHref === "about:PreferenceStyleSheet") {
	        this.source.setAttribute("unselectable", "true");
	        sourceLabel.setAttribute("value", uaLabel);
	        sourceLabel.removeAttribute("tooltiptext");
	      }
	    } else {
	      sourceLabel.setAttribute("value", title);
	      if (this.rule.ruleLine === -1 && this.rule.domRule.parentStyleSheet) {
	        this.source.setAttribute("unselectable", "true");
	      }
	    }

	    let showOrig = Services.prefs.getBoolPref(PREF_ORIG_SOURCES);
	    if (showOrig && !this.rule.isSystem &&
	        this.rule.domRule.type !== ELEMENT_STYLE) {
	      // Only get the original source link if the right pref is set, if the rule
	      // isn't a system rule and if it isn't an inline rule.
	      this.rule.getOriginalSourceStrings().then((strings) => {
	        sourceLabel.setAttribute("value", strings.short);
	        sourceLabel.setAttribute("tooltiptext", strings.full);
	      }, e => console.error(e)).then(() => {
	        this.emit("source-link-updated");
	      });
	    } else {
	      // If we're not getting the original source link, then we can emit the
	      // event immediately (but still asynchronously to give consumers a chance
	      // to register it after having instantiated the RuleEditor).
	      promise.resolve().then(() => {
	        this.emit("source-link-updated");
	      });
	    }
	  },

	  /**
	   * Update the rule editor with the contents of the rule.
	   */
	  populate: function () {
	    // Clear out existing viewers.
	    while (this.selectorText.hasChildNodes()) {
	      this.selectorText.removeChild(this.selectorText.lastChild);
	    }

	    // If selector text comes from a css rule, highlight selectors that
	    // actually match.  For custom selector text (such as for the 'element'
	    // style, just show the text directly.
	    if (this.rule.domRule.type === ELEMENT_STYLE) {
	      this.selectorText.textContent = this.rule.selectorText;
	    } else if (this.rule.domRule.type === CSSRule.KEYFRAME_RULE) {
	      this.selectorText.textContent = this.rule.domRule.keyText;
	    } else {
	      this.rule.domRule.selectors.forEach((selector, i) => {
	        if (i !== 0) {
	          createChild(this.selectorText, "span", {
	            class: "ruleview-selector-separator",
	            textContent: ", "
	          });
	        }

	        let containerClass =
	          (this.rule.matchedSelectors.indexOf(selector) > -1) ?
	          "ruleview-selector-matched" : "ruleview-selector-unmatched";
	        let selectorContainer = createChild(this.selectorText, "span", {
	          class: containerClass
	        });

	        let parsedSelector = parsePseudoClassesAndAttributes(selector);

	        for (let selectorText of parsedSelector) {
	          let selectorClass = "";

	          switch (selectorText.type) {
	            case SELECTOR_ATTRIBUTE:
	              selectorClass = "ruleview-selector-attribute";
	              break;
	            case SELECTOR_ELEMENT:
	              selectorClass = "ruleview-selector";
	              break;
	            case SELECTOR_PSEUDO_CLASS:
	              selectorClass = [":active", ":focus", ":hover"].some(
	                  pseudo => selectorText.value === pseudo) ?
	                "ruleview-selector-pseudo-class-lock" :
	                "ruleview-selector-pseudo-class";
	              break;
	            default:
	              break;
	          }

	          createChild(selectorContainer, "span", {
	            textContent: selectorText.value,
	            class: selectorClass
	          });
	        }
	      });
	    }

	    for (let prop of this.rule.textProps) {
	      if (!prop.editor && !prop.invisible) {
	        let editor = new TextPropertyEditor(this, prop);
	        this.propertyList.appendChild(editor.element);
	      }
	    }
	  },

	  /**
	   * Programatically add a new property to the rule.
	   *
	   * @param {String} name
	   *        Property name.
	   * @param {String} value
	   *        Property value.
	   * @param {String} priority
	   *        Property priority.
	   * @param {Boolean} enabled
	   *        True if the property should be enabled.
	   * @param {TextProperty} siblingProp
	   *        Optional, property next to which the new property will be added.
	   * @return {TextProperty}
	   *        The new property
	   */
	  addProperty: function (name, value, priority, enabled, siblingProp) {
	    let prop = this.rule.createProperty(name, value, priority, enabled,
	      siblingProp);
	    let index = this.rule.textProps.indexOf(prop);
	    let editor = new TextPropertyEditor(this, prop);

	    // Insert this node before the DOM node that is currently at its new index
	    // in the property list.  There is currently one less node in the DOM than
	    // in the property list, so this causes it to appear after siblingProp.
	    // If there is no node at its index, as is the case where this is the last
	    // node being inserted, then this behaves as appendChild.
	    this.propertyList.insertBefore(editor.element,
	      this.propertyList.children[index]);

	    return prop;
	  },

	  /**
	   * Programatically add a list of new properties to the rule.  Focus the UI
	   * to the proper location after adding (either focus the value on the
	   * last property if it is empty, or create a new property and focus it).
	   *
	   * @param {Array} properties
	   *        Array of properties, which are objects with this signature:
	   *        {
	   *          name: {string},
	   *          value: {string},
	   *          priority: {string}
	   *        }
	   * @param {TextProperty} siblingProp
	   *        Optional, the property next to which all new props should be added.
	   */
	  addProperties: function (properties, siblingProp) {
	    if (!properties || !properties.length) {
	      return;
	    }

	    let lastProp = siblingProp;
	    for (let p of properties) {
	      let isCommented = Boolean(p.commentOffsets);
	      let enabled = !isCommented;
	      lastProp = this.addProperty(p.name, p.value, p.priority, enabled,
	        lastProp);
	    }

	    // Either focus on the last value if incomplete, or start a new one.
	    if (lastProp && lastProp.value.trim() === "") {
	      lastProp.editor.valueSpan.click();
	    } else {
	      this.newProperty();
	    }
	  },

	  /**
	   * Create a text input for a property name.  If a non-empty property
	   * name is given, we'll create a real TextProperty and add it to the
	   * rule.
	   */
	  newProperty: function () {
	    // If we're already creating a new property, ignore this.
	    if (!this.closeBrace.hasAttribute("tabindex")) {
	      return;
	    }

	    // While we're editing a new property, it doesn't make sense to
	    // start a second new property editor, so disable focusing the
	    // close brace for now.
	    this.closeBrace.removeAttribute("tabindex");

	    this.newPropItem = createChild(this.propertyList, "li", {
	      class: "ruleview-property ruleview-newproperty",
	    });

	    this.newPropSpan = createChild(this.newPropItem, "span", {
	      class: "ruleview-propertyname",
	      tabindex: "0"
	    });

	    this.multipleAddedProperties = null;

	    this.editor = new InplaceEditor({
	      element: this.newPropSpan,
	      done: this._onNewProperty,
	      destroy: this._newPropertyDestroy,
	      advanceChars: ":",
	      contentType: InplaceEditor.CONTENT_TYPES.CSS_PROPERTY,
	      popup: this.ruleView.popup,
	      cssProperties: this.rule.cssProperties
	    });

	    // Auto-close the input if multiple rules get pasted into new property.
	    this.editor.input.addEventListener("paste",
	      blurOnMultipleProperties(this.rule.cssProperties), false);
	  },

	  /**
	   * Called when the new property input has been dismissed.
	   *
	   * @param {String} value
	   *        The value in the editor.
	   * @param {Boolean} commit
	   *        True if the value should be committed.
	   */
	  _onNewProperty: function (value, commit) {
	    if (!value || !commit) {
	      return;
	    }

	    // parseDeclarations allows for name-less declarations, but in the present
	    // case, we're creating a new declaration, it doesn't make sense to accept
	    // these entries
	    this.multipleAddedProperties =
	      parseDeclarations(this.rule.cssProperties.isKnown, value, true)
	      .filter(d => d.name);

	    // Blur the editor field now and deal with adding declarations later when
	    // the field gets destroyed (see _newPropertyDestroy)
	    this.editor.input.blur();
	  },

	  /**
	   * Called when the new property editor is destroyed.
	   * This is where the properties (type TextProperty) are actually being
	   * added, since we want to wait until after the inplace editor `destroy`
	   * event has been fired to keep consistent UI state.
	   */
	  _newPropertyDestroy: function () {
	    // We're done, make the close brace focusable again.
	    this.closeBrace.setAttribute("tabindex", "0");

	    this.propertyList.removeChild(this.newPropItem);
	    delete this.newPropItem;
	    delete this.newPropSpan;

	    // If properties were added, we want to focus the proper element.
	    // If the last new property has no value, focus the value on it.
	    // Otherwise, start a new property and focus that field.
	    if (this.multipleAddedProperties && this.multipleAddedProperties.length) {
	      this.addProperties(this.multipleAddedProperties);
	    }
	  },

	  /**
	   * Called when the selector's inplace editor is closed.
	   * Ignores the change if the user pressed escape, otherwise
	   * commits it.
	   *
	   * @param {String} value
	   *        The value contained in the editor.
	   * @param {Boolean} commit
	   *        True if the change should be applied.
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  _onSelectorDone: function (value, commit, direction) {
	    if (!commit || this.isEditing || value === "" ||
	        value === this.rule.selectorText) {
	      return;
	    }

	    let ruleView = this.ruleView;
	    let elementStyle = ruleView._elementStyle;
	    let element = elementStyle.element;
	    let supportsUnmatchedRules =
	      this.rule.domRule.supportsModifySelectorUnmatched;

	    this.isEditing = true;

	    this.rule.domRule.modifySelector(element, value).then(response => {
	      this.isEditing = false;

	      if (!supportsUnmatchedRules) {
	        if (response) {
	          this.ruleView.refreshPanel();
	        }
	        return;
	      }

	      let {ruleProps, isMatching} = response;
	      if (!ruleProps) {
	        // Notify for changes, even when nothing changes,
	        // just to allow tests being able to track end of this request.
	        ruleView.emit("ruleview-invalid-selector");
	        return;
	      }

	      ruleProps.isUnmatched = !isMatching;
	      let newRule = new Rule(elementStyle, ruleProps);
	      let editor = new RuleEditor(ruleView, newRule);
	      let rules = elementStyle.rules;

	      rules.splice(rules.indexOf(this.rule), 1);
	      rules.push(newRule);
	      elementStyle._changed();
	      elementStyle.markOverriddenAll();

	      this.element.parentNode.replaceChild(editor.element, this.element);

	      // Remove highlight for modified selector
	      if (ruleView.highlightedSelector) {
	        ruleView.toggleSelectorHighlighter(ruleView.lastSelectorIcon,
	          ruleView.highlightedSelector);
	      }

	      editor._moveSelectorFocus(direction);
	    }).then(null, err => {
	      this.isEditing = false;
	      promiseWarn(err);
	    });
	  },

	  /**
	   * Handle moving the focus change after a tab or return keypress in the
	   * selector inplace editor.
	   *
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  _moveSelectorFocus: function (direction) {
	    if (!direction || direction === Services.focus.MOVEFOCUS_BACKWARD) {
	      return;
	    }

	    if (this.rule.textProps.length > 0) {
	      this.rule.textProps[0].editor.nameSpan.click();
	    } else {
	      this.propertyList.click();
	    }
	  }
	};

	exports.RuleEditor = RuleEditor;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Basic use:
	 * let spanToEdit = document.getElementById("somespan");
	 *
	 * editableField({
	 *   element: spanToEdit,
	 *   done: function(value, commit, direction) {
	 *     if (commit) {
	 *       spanToEdit.textContent = value;
	 *     }
	 *   },
	 *   trigger: "dblclick"
	 * });
	 *
	 * See editableField() for more options.
	 */

	"use strict";

	const Services = __webpack_require__(1);
	const focusManager = Services.focus;
	const {KeyCodes} = __webpack_require__(16);

	const HTML_NS = "http://www.w3.org/1999/xhtml";
	const CONTENT_TYPES = {
	  PLAIN_TEXT: 0,
	  CSS_VALUE: 1,
	  CSS_MIXED: 2,
	  CSS_PROPERTY: 3,
	};

	// The limit of 500 autocomplete suggestions should not be reached but is kept
	// for safety.
	const MAX_POPUP_ENTRIES = 500;

	const FOCUS_FORWARD = focusManager.MOVEFOCUS_FORWARD;
	const FOCUS_BACKWARD = focusManager.MOVEFOCUS_BACKWARD;

	const EventEmitter = __webpack_require__(6);
	const { findMostRelevantCssPropertyIndex } = __webpack_require__(155);

	/**
	 * Helper to check if the provided key matches one of the expected keys.
	 * Keys will be prefixed with DOM_VK_ and should match a key in KeyCodes.
	 *
	 * @param {String} key
	 *        the key to check (can be a keyCode).
	 * @param {...String} keys
	 *        list of possible keys allowed.
	 * @return {Boolean} true if the key matches one of the keys.
	 */
	function isKeyIn(key, ...keys) {
	  return keys.some(expectedKey => {
	    return key === KeyCodes["DOM_VK_" + expectedKey];
	  });
	}

	/**
	 * Mark a span editable.  |editableField| will listen for the span to
	 * be focused and create an InlineEditor to handle text input.
	 * Changes will be committed when the InlineEditor's input is blurred
	 * or dropped when the user presses escape.
	 *
	 * @param {Object} options
	 *    Options for the editable field, including:
	 *    {Element} element:
	 *      (required) The span to be edited on focus.
	 *    {Function} canEdit:
	 *       Will be called before creating the inplace editor.  Editor
	 *       won't be created if canEdit returns false.
	 *    {Function} start:
	 *       Will be called when the inplace editor is initialized.
	 *    {Function} change:
	 *       Will be called when the text input changes.  Will be called
	 *       with the current value of the text input.
	 *    {Function} done:
	 *       Called when input is committed or blurred.  Called with
	 *       current value, a boolean telling the caller whether to
	 *       commit the change, and the direction of the next element to be
	 *       selected. Direction may be one of Services.focus.MOVEFOCUS_FORWARD,
	 *       Services.focus.MOVEFOCUS_BACKWARD, or null (no movement).
	 *       This function is called before the editor has been torn down.
	 *    {Function} destroy:
	 *       Called when the editor is destroyed and has been torn down.
	 *    {Object} advanceChars:
	 *       This can be either a string or a function.
	 *       If it is a string, then if any characters in it are typed,
	 *       focus will advance to the next element.
	 *       Otherwise, if it is a function, then the function will
	 *       be called with three arguments: a key code, the current text,
	 *       and the insertion point.  If the function returns true,
	 *       then the focus advance takes place.  If it returns false,
	 *       then the character is inserted instead.
	 *    {Boolean} stopOnReturn:
	 *       If true, the return key will not advance the editor to the next
	 *       focusable element.
	 *    {Boolean} stopOnTab:
	 *       If true, the tab key will not advance the editor to the next
	 *       focusable element.
	 *    {Boolean} stopOnShiftTab:
	 *       If true, shift tab will not advance the editor to the previous
	 *       focusable element.
	 *    {String} trigger: The DOM event that should trigger editing,
	 *      defaults to "click"
	 *    {Boolean} multiline: Should the editor be a multiline textarea?
	 *      defaults to false
	 *    {Function or Number} maxWidth:
	 *       Should the editor wrap to remain below the provided max width. Only
	 *       available if multiline is true. If a function is provided, it will be
	 *       called when replacing the element by the inplace input.
	 *    {Boolean} trimOutput: Should the returned string be trimmed?
	 *      defaults to true
	 *    {Boolean} preserveTextStyles: If true, do not copy text-related styles
	 *              from `element` to the new input.
	 *      defaults to false
	 *    {Object} cssProperties: An instance of CSSProperties.
	 */
	function editableField(options) {
	  return editableItem(options, function (element, event) {
	    if (!options.element.inplaceEditor) {
	      new InplaceEditor(options, event);
	    }
	  });
	}

	exports.editableField = editableField;

	/**
	 * Handle events for an element that should respond to
	 * clicks and sit in the editing tab order, and call
	 * a callback when it is activated.
	 *
	 * @param {Object} options
	 *    The options for this editor, including:
	 *    {Element} element: The DOM element.
	 *    {String} trigger: The DOM event that should trigger editing,
	 *      defaults to "click"
	 * @param {Function} callback
	 *        Called when the editor is activated.
	 * @return {Function} function which calls callback
	 */
	function editableItem(options, callback) {
	  let trigger = options.trigger || "click";
	  let element = options.element;
	  element.addEventListener(trigger, function (evt) {
	    if (evt.target.nodeName !== "a") {
	      let win = this.ownerDocument.defaultView;
	      let selection = win.getSelection();
	      if (trigger != "click" || selection.isCollapsed) {
	        callback(element, evt);
	      }
	      evt.stopPropagation();
	    }
	  }, false);

	  // If focused by means other than a click, start editing by
	  // pressing enter or space.
	  element.addEventListener("keypress", function (evt) {
	    if (isKeyIn(evt.keyCode, "RETURN") || isKeyIn(evt.charCode, "SPACE")) {
	      callback(element);
	    }
	  }, true);

	  // Ugly workaround - the element is focused on mousedown but
	  // the editor is activated on click/mouseup.  This leads
	  // to an ugly flash of the focus ring before showing the editor.
	  // So hide the focus ring while the mouse is down.
	  element.addEventListener("mousedown", function (evt) {
	    if (evt.target.nodeName !== "a") {
	      let cleanup = function () {
	        element.style.removeProperty("outline-style");
	        element.removeEventListener("mouseup", cleanup, false);
	        element.removeEventListener("mouseout", cleanup, false);
	      };
	      element.style.setProperty("outline-style", "none");
	      element.addEventListener("mouseup", cleanup, false);
	      element.addEventListener("mouseout", cleanup, false);
	    }
	  }, false);

	  // Mark the element editable field for tab
	  // navigation while editing.
	  element._editable = true;

	  // Save the trigger type so we can dispatch this later
	  element._trigger = trigger;

	  // Add button semantics to the element, to indicate that it can be activated.
	  element.setAttribute("role", "button");

	  return function turnOnEditMode() {
	    callback(element);
	  };
	}

	exports.editableItem = editableItem;

	/*
	 * Various API consumers (especially tests) sometimes want to grab the
	 * inplaceEditor expando off span elements. However, when each global has its
	 * own compartment, those expandos live on Xray wrappers that are only visible
	 * within this JSM. So we provide a little workaround here.
	 */

	function getInplaceEditorForSpan(span) {
	  return span.inplaceEditor;
	}

	exports.getInplaceEditorForSpan = getInplaceEditorForSpan;

	function InplaceEditor(options, event) {
	  this.elt = options.element;
	  let doc = this.elt.ownerDocument;
	  this.doc = doc;
	  this.elt.inplaceEditor = this;
	  this.cssProperties = options.cssProperties;
	  this.change = options.change;
	  this.done = options.done;
	  this.destroy = options.destroy;
	  this.initial = options.initial ? options.initial : this.elt.textContent;
	  this.multiline = options.multiline || false;
	  this.maxWidth = options.maxWidth;
	  if (typeof this.maxWidth == "function") {
	    this.maxWidth = this.maxWidth();
	  }

	  this.trimOutput = options.trimOutput === undefined
	                    ? true
	                    : !!options.trimOutput;
	  this.stopOnShiftTab = !!options.stopOnShiftTab;
	  this.stopOnTab = !!options.stopOnTab;
	  this.stopOnReturn = !!options.stopOnReturn;
	  this.contentType = options.contentType || CONTENT_TYPES.PLAIN_TEXT;
	  this.property = options.property;
	  this.popup = options.popup;
	  this.preserveTextStyles = options.preserveTextStyles === undefined
	                          ? false
	                          : !!options.preserveTextStyles;

	  this._onBlur = this._onBlur.bind(this);
	  this._onWindowBlur = this._onWindowBlur.bind(this);
	  this._onKeyPress = this._onKeyPress.bind(this);
	  this._onInput = this._onInput.bind(this);
	  this._onKeyup = this._onKeyup.bind(this);
	  this._onAutocompletePopupClick = this._onAutocompletePopupClick.bind(this);

	  this._createInput();

	  // Hide the provided element and add our editor.
	  this.originalDisplay = this.elt.style.display;
	  this.elt.style.display = "none";
	  this.elt.parentNode.insertBefore(this.input, this.elt);

	  // After inserting the input to have all CSS styles applied, start autosizing.
	  this._autosize();

	  this.inputCharDimensions = this._getInputCharDimensions();
	  // Pull out character codes for advanceChars, listing the
	  // characters that should trigger a blur.
	  if (typeof options.advanceChars === "function") {
	    this._advanceChars = options.advanceChars;
	  } else {
	    let advanceCharcodes = {};
	    let advanceChars = options.advanceChars || "";
	    for (let i = 0; i < advanceChars.length; i++) {
	      advanceCharcodes[advanceChars.charCodeAt(i)] = true;
	    }
	    this._advanceChars = charCode => charCode in advanceCharcodes;
	  }

	  this.input.focus();

	  if (typeof options.selectAll == "undefined" || options.selectAll) {
	    this.input.select();
	  }

	  if (this.contentType == CONTENT_TYPES.CSS_VALUE && this.input.value == "") {
	    this._maybeSuggestCompletion(false);
	  }

	  this.input.addEventListener("blur", this._onBlur, false);
	  this.input.addEventListener("keypress", this._onKeyPress, false);
	  this.input.addEventListener("input", this._onInput, false);
	  this.input.addEventListener("dblclick", this._stopEventPropagation, false);
	  this.input.addEventListener("click", this._stopEventPropagation, false);
	  this.input.addEventListener("mousedown", this._stopEventPropagation, false);
	  this.doc.defaultView.addEventListener("blur", this._onWindowBlur, false);

	  this.validate = options.validate;

	  if (this.validate) {
	    this.input.addEventListener("keyup", this._onKeyup, false);
	  }

	  this._updateSize();

	  EventEmitter.decorate(this);

	  if (options.start) {
	    options.start(this, event);
	  }
	}

	exports.InplaceEditor = InplaceEditor;

	InplaceEditor.CONTENT_TYPES = CONTENT_TYPES;

	InplaceEditor.prototype = {

	  get currentInputValue() {
	    let val = this.trimOutput ? this.input.value.trim() : this.input.value;
	    return val;
	  },

	  _createInput: function () {
	    this.input =
	      this.doc.createElementNS(HTML_NS, this.multiline ? "textarea" : "input");
	    this.input.inplaceEditor = this;

	    if (this.multiline) {
	      // Hide the textarea resize handle.
	      this.input.style.resize = "none";
	      this.input.style.overflow = "hidden";
	    }

	    this.input.classList.add("styleinspector-propertyeditor");
	    this.input.value = this.initial;
	    if (!this.preserveTextStyles) {
	      copyTextStyles(this.elt, this.input);
	    }
	  },

	  /**
	   * Get rid of the editor.
	   */
	  _clear: function () {
	    if (!this.input) {
	      // Already cleared.
	      return;
	    }

	    this.input.removeEventListener("blur", this._onBlur, false);
	    this.input.removeEventListener("keypress", this._onKeyPress, false);
	    this.input.removeEventListener("keyup", this._onKeyup, false);
	    this.input.removeEventListener("input", this._onInput, false);
	    this.input.removeEventListener("dblclick", this._stopEventPropagation,
	      false);
	    this.input.removeEventListener("click", this._stopEventPropagation, false);
	    this.input.removeEventListener("mousedown", this._stopEventPropagation,
	      false);
	    this.doc.defaultView.removeEventListener("blur", this._onWindowBlur, false);

	    this._stopAutosize();

	    this.elt.style.display = this.originalDisplay;

	    if (this.doc.activeElement == this.input) {
	      this.elt.focus();
	    }

	    this.input.remove();
	    this.input = null;

	    delete this.elt.inplaceEditor;
	    delete this.elt;

	    if (this.destroy) {
	      this.destroy();
	    }
	  },

	  /**
	   * Keeps the editor close to the size of its input string.  This is pretty
	   * crappy, suggestions for improvement welcome.
	   */
	  _autosize: function () {
	    // Create a hidden, absolutely-positioned span to measure the text
	    // in the input.  Boo.

	    // We can't just measure the original element because a) we don't
	    // change the underlying element's text ourselves (we leave that
	    // up to the client), and b) without tweaking the style of the
	    // original element, it might wrap differently or something.
	    this._measurement =
	      this.doc.createElementNS(HTML_NS, this.multiline ? "pre" : "span");
	    this._measurement.className = "autosizer";
	    this.elt.parentNode.appendChild(this._measurement);
	    let style = this._measurement.style;
	    style.visibility = "hidden";
	    style.position = "absolute";
	    style.top = "0";
	    style.left = "0";

	    if (this.multiline) {
	      style.whiteSpace = "pre-wrap";
	      style.wordWrap = "break-word";
	      if (this.maxWidth) {
	        style.maxWidth = this.maxWidth + "px";
	        // Use position fixed to measure dimensions without any influence from
	        // the container of the editor.
	        style.position = "fixed";
	      }
	    }

	    copyAllStyles(this.input, this._measurement);
	    this._updateSize();
	  },

	  /**
	   * Clean up the mess created by _autosize().
	   */
	  _stopAutosize: function () {
	    if (!this._measurement) {
	      return;
	    }
	    this._measurement.remove();
	    delete this._measurement;
	  },

	  /**
	   * Size the editor to fit its current contents.
	   */
	  _updateSize: function () {
	    // Replace spaces with non-breaking spaces.  Otherwise setting
	    // the span's textContent will collapse spaces and the measurement
	    // will be wrong.
	    let content = this.input.value;
	    let unbreakableSpace = "\u00a0";

	    // Make sure the content is not empty.
	    if (content === "") {
	      content = unbreakableSpace;
	    }

	    // If content ends with a new line, add a blank space to force the autosize
	    // element to adapt its height.
	    if (content.lastIndexOf("\n") === content.length - 1) {
	      content = content + unbreakableSpace;
	    }

	    if (!this.multiline) {
	      content = content.replace(/ /g, unbreakableSpace);
	    }

	    this._measurement.textContent = content;

	    // Do not use offsetWidth: it will round floating width values.
	    let width = this._measurement.getBoundingClientRect().width + 2;
	    if (this.multiline) {
	      if (this.maxWidth) {
	        width = Math.min(this.maxWidth, width);
	      }
	      let height = this._measurement.getBoundingClientRect().height;
	      this.input.style.height = height + "px";
	    }
	    this.input.style.width = width + "px";
	  },

	  /**
	   * Get the width and height of a single character in the input to properly
	   * position the autocompletion popup.
	   */
	  _getInputCharDimensions: function () {
	    // Just make the text content to be 'x' to get the width and height of any
	    // character in a monospace font.
	    this._measurement.textContent = "x";
	    let width = this._measurement.clientWidth;
	    let height = this._measurement.clientHeight;
	    return { width, height };
	  },

	   /**
	   * Increment property values in rule view.
	   *
	   * @param {Number} increment
	   *        The amount to increase/decrease the property value.
	   * @return {Boolean} true if value has been incremented.
	   */
	  _incrementValue: function (increment) {
	    let value = this.input.value;
	    let selectionStart = this.input.selectionStart;
	    let selectionEnd = this.input.selectionEnd;

	    let newValue = this._incrementCSSValue(value, increment, selectionStart,
	                                           selectionEnd);

	    if (!newValue) {
	      return false;
	    }

	    this.input.value = newValue.value;
	    this.input.setSelectionRange(newValue.start, newValue.end);
	    this._doValidation();

	    // Call the user's change handler if available.
	    if (this.change) {
	      this.change(this.currentInputValue);
	    }

	    return true;
	  },

	  /**
	   * Increment the property value based on the property type.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} increment
	   *        Amount to increase/decrease the property value.
	   * @param {Number} selStart
	   *        Starting index of the value.
	   * @param {Number} selEnd
	   *        Ending index of the value.
	   * @return {Object} object with properties 'value', 'start', and 'end'.
	   */
	  _incrementCSSValue: function (value, increment, selStart, selEnd) {
	    let range = this._parseCSSValue(value, selStart);
	    let type = (range && range.type) || "";
	    let rawValue = range ? value.substring(range.start, range.end) : "";
	    let preRawValue = range ? value.substr(0, range.start) : "";
	    let postRawValue = range ? value.substr(range.end) : "";
	    let info;

	    let incrementedValue = null, selection;
	    if (type === "num") {
	      if (rawValue == "0") {
	        info = {};
	        info.units = this._findCompatibleUnit(preRawValue, postRawValue);
	      }

	      let newValue = this._incrementRawValue(rawValue, increment, info);
	      if (newValue !== null) {
	        incrementedValue = newValue;
	        selection = [0, incrementedValue.length];
	      }
	    } else if (type === "hex") {
	      let exprOffset = selStart - range.start;
	      let exprOffsetEnd = selEnd - range.start;
	      let newValue = this._incHexColor(rawValue, increment, exprOffset,
	                                       exprOffsetEnd);
	      if (newValue) {
	        incrementedValue = newValue.value;
	        selection = newValue.selection;
	      }
	    } else {
	      if (type === "rgb" || type === "hsl") {
	        info = {};
	        let part = value.substring(range.start, selStart).split(",").length - 1;
	        if (part === 3) {
	          // alpha
	          info.minValue = 0;
	          info.maxValue = 1;
	        } else if (type === "rgb") {
	          info.minValue = 0;
	          info.maxValue = 255;
	        } else if (part !== 0) {
	          // hsl percentage
	          info.minValue = 0;
	          info.maxValue = 100;

	          // select the previous number if the selection is at the end of a
	          // percentage sign.
	          if (value.charAt(selStart - 1) === "%") {
	            --selStart;
	          }
	        }
	      }
	      return this._incrementGenericValue(value, increment, selStart, selEnd,
	                                         info);
	    }

	    if (incrementedValue === null) {
	      return null;
	    }

	    return {
	      value: preRawValue + incrementedValue + postRawValue,
	      start: range.start + selection[0],
	      end: range.start + selection[1]
	    };
	  },

	  /**
	   * Find a compatible unit to use for a CSS number value inserted between the
	   * provided beforeValue and afterValue. The compatible unit will be picked
	   * from a selection of default units corresponding to supported CSS value
	   * dimensions (distance, angle, duration).
	   *
	   * @param {String} beforeValue
	   *        The string preceeding the number value in the current property
	   *        value.
	   * @param {String} afterValue
	   *        The string following the number value in the current property value.
	   * @return {String} a valid unit that can be used for this number value or
	   *         empty string if no match could be found.
	   */
	  _findCompatibleUnit: function (beforeValue, afterValue) {
	    if (!this.property || !this.property.name) {
	      return "";
	    }

	    // A DOM element is used to test the validity of various units. This is to
	    // avoid having to do an async call to the server to get this information.
	    let el = this.doc.createElement("div");
	    let units = ["px", "deg", "s"];
	    for (let unit of units) {
	      let value = beforeValue + "1" + unit + afterValue;
	      el.style.setProperty(this.property.name, "");
	      el.style.setProperty(this.property.name, value);
	      if (el.style.getPropertyValue(this.property.name) !== "") {
	        return unit;
	      }
	    }
	    return "";
	  },

	  /**
	   * Parses the property value and type.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} offset
	   *        Starting index of value.
	   * @return {Object} object with properties 'value', 'start', 'end', and
	   *         'type'.
	   */
	  _parseCSSValue: function (value, offset) {
	    /* eslint-disable max-len */
	    const reSplitCSS = /(url\("?[^"\)]+"?\)?)|(rgba?\([^)]*\)?)|(hsla?\([^)]*\)?)|(#[\dA-Fa-f]+)|(-?\d*\.?\d+(%|[a-z]{1,4})?)|"([^"]*)"?|'([^']*)'?|([^,\s\/!\(\)]+)|(!(.*)?)/;
	    /* eslint-enable */
	    let start = 0;
	    let m;

	    // retreive values from left to right until we find the one at our offset
	    while ((m = reSplitCSS.exec(value)) &&
	          (m.index + m[0].length < offset)) {
	      value = value.substr(m.index + m[0].length);
	      start += m.index + m[0].length;
	      offset -= m.index + m[0].length;
	    }

	    if (!m) {
	      return null;
	    }

	    let type;
	    if (m[1]) {
	      type = "url";
	    } else if (m[2]) {
	      type = "rgb";
	    } else if (m[3]) {
	      type = "hsl";
	    } else if (m[4]) {
	      type = "hex";
	    } else if (m[5]) {
	      type = "num";
	    }

	    return {
	      value: m[0],
	      start: start + m.index,
	      end: start + m.index + m[0].length,
	      type: type
	    };
	  },

	  /**
	   * Increment the property value for types other than
	   * number or hex, such as rgb, hsl, and file names.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} increment
	   *        Amount to increment/decrement.
	   * @param {Number} offset
	   *        Starting index of the property value.
	   * @param {Number} offsetEnd
	   *        Ending index of the property value.
	   * @param {Object} info
	   *        Object with details about the property value.
	   * @return {Object} object with properties 'value', 'start', and 'end'.
	   */
	  _incrementGenericValue: function (value, increment, offset, offsetEnd, info) {
	    // Try to find a number around the cursor to increment.
	    let start, end;
	    // Check if we are incrementing in a non-number context (such as a URL)
	    if (/^-?[0-9.]/.test(value.substring(offset, offsetEnd)) &&
	      !(/\d/.test(value.charAt(offset - 1) + value.charAt(offsetEnd)))) {
	      // We have a number selected, possibly with a suffix, and we are not in
	      // the disallowed case of just part of a known number being selected.
	      // Use that number.
	      start = offset;
	      end = offsetEnd;
	    } else {
	      // Parse periods as belonging to the number only if we are in a known
	      // number context. (This makes incrementing the 1 in 'image1.gif' work.)
	      let pattern = "[" + (info ? "0-9." : "0-9") + "]*";
	      let before = new RegExp(pattern + "$")
	        .exec(value.substr(0, offset))[0].length;
	      let after = new RegExp("^" + pattern)
	        .exec(value.substr(offset))[0].length;

	      start = offset - before;
	      end = offset + after;

	      // Expand the number to contain an initial minus sign if it seems
	      // free-standing.
	      if (value.charAt(start - 1) === "-" &&
	         (start - 1 === 0 || /[ (:,='"]/.test(value.charAt(start - 2)))) {
	        --start;
	      }
	    }

	    if (start !== end) {
	      // Include percentages as part of the incremented number (they are
	      // common enough).
	      if (value.charAt(end) === "%") {
	        ++end;
	      }

	      let first = value.substr(0, start);
	      let mid = value.substring(start, end);
	      let last = value.substr(end);

	      mid = this._incrementRawValue(mid, increment, info);

	      if (mid !== null) {
	        return {
	          value: first + mid + last,
	          start: start,
	          end: start + mid.length
	        };
	      }
	    }

	    return null;
	  },

	  /**
	   * Increment the property value for numbers.
	   *
	   * @param {String} rawValue
	   *        Raw value to increment.
	   * @param {Number} increment
	   *        Amount to increase/decrease the raw value.
	   * @param {Object} info
	   *        Object with info about the property value.
	   * @return {String} the incremented value.
	   */
	  _incrementRawValue: function (rawValue, increment, info) {
	    let num = parseFloat(rawValue);

	    if (isNaN(num)) {
	      return null;
	    }

	    let number = /\d+(\.\d+)?/.exec(rawValue);

	    let units = rawValue.substr(number.index + number[0].length);
	    if (info && "units" in info) {
	      units = info.units;
	    }

	    // avoid rounding errors
	    let newValue = Math.round((num + increment) * 1000) / 1000;

	    if (info && "minValue" in info) {
	      newValue = Math.max(newValue, info.minValue);
	    }
	    if (info && "maxValue" in info) {
	      newValue = Math.min(newValue, info.maxValue);
	    }

	    newValue = newValue.toString();

	    return newValue + units;
	  },

	  /**
	   * Increment the property value for hex.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} increment
	   *        Amount to increase/decrease the property value.
	   * @param {Number} offset
	   *        Starting index of the property value.
	   * @param {Number} offsetEnd
	   *        Ending index of the property value.
	   * @return {Object} object with properties 'value' and 'selection'.
	   */
	  _incHexColor: function (rawValue, increment, offset, offsetEnd) {
	    // Return early if no part of the rawValue is selected.
	    if (offsetEnd > rawValue.length && offset >= rawValue.length) {
	      return null;
	    }
	    if (offset < 1 && offsetEnd <= 1) {
	      return null;
	    }
	    // Ignore the leading #.
	    rawValue = rawValue.substr(1);
	    --offset;
	    --offsetEnd;

	    // Clamp the selection to within the actual value.
	    offset = Math.max(offset, 0);
	    offsetEnd = Math.min(offsetEnd, rawValue.length);
	    offsetEnd = Math.max(offsetEnd, offset);

	    // Normalize #ABC -> #AABBCC.
	    if (rawValue.length === 3) {
	      rawValue = rawValue.charAt(0) + rawValue.charAt(0) +
	                 rawValue.charAt(1) + rawValue.charAt(1) +
	                 rawValue.charAt(2) + rawValue.charAt(2);
	      offset *= 2;
	      offsetEnd *= 2;
	    }

	    // Normalize #ABCD -> #AABBCCDD.
	    if (rawValue.length === 4) {
	      rawValue = rawValue.charAt(0) + rawValue.charAt(0) +
	                 rawValue.charAt(1) + rawValue.charAt(1) +
	                 rawValue.charAt(2) + rawValue.charAt(2) +
	                 rawValue.charAt(3) + rawValue.charAt(3);
	      offset *= 2;
	      offsetEnd *= 2;
	    }

	    if (rawValue.length !== 6 && rawValue.length !== 8) {
	      return null;
	    }

	    // If no selection, increment an adjacent color, preferably one to the left.
	    if (offset === offsetEnd) {
	      if (offset === 0) {
	        offsetEnd = 1;
	      } else {
	        offset = offsetEnd - 1;
	      }
	    }

	    // Make the selection cover entire parts.
	    offset -= offset % 2;
	    offsetEnd += offsetEnd % 2;

	    // Remap the increments from [0.1, 1, 10] to [1, 1, 16].
	    if (increment > -1 && increment < 1) {
	      increment = (increment < 0 ? -1 : 1);
	    }
	    if (Math.abs(increment) === 10) {
	      increment = (increment < 0 ? -16 : 16);
	    }

	    let isUpper = (rawValue.toUpperCase() === rawValue);

	    for (let pos = offset; pos < offsetEnd; pos += 2) {
	      // Increment the part in [pos, pos+2).
	      let mid = rawValue.substr(pos, 2);
	      let value = parseInt(mid, 16);

	      if (isNaN(value)) {
	        return null;
	      }

	      mid = Math.min(Math.max(value + increment, 0), 255).toString(16);

	      while (mid.length < 2) {
	        mid = "0" + mid;
	      }
	      if (isUpper) {
	        mid = mid.toUpperCase();
	      }

	      rawValue = rawValue.substr(0, pos) + mid + rawValue.substr(pos + 2);
	    }

	    return {
	      value: "#" + rawValue,
	      selection: [offset + 1, offsetEnd + 1]
	    };
	  },

	  /**
	   * Cycle through the autocompletion suggestions in the popup.
	   *
	   * @param {Boolean} reverse
	   *        true to select previous item from the popup.
	   * @param {Boolean} noSelect
	   *        true to not select the text after selecting the newly selectedItem
	   *        from the popup.
	   */
	  _cycleCSSSuggestion: function (reverse, noSelect) {
	    // selectedItem can be null when nothing is selected in an empty editor.
	    let {label, preLabel} = this.popup.selectedItem ||
	                            {label: "", preLabel: ""};
	    if (reverse) {
	      this.popup.selectPreviousItem();
	    } else {
	      this.popup.selectNextItem();
	    }

	    this._selectedIndex = this.popup.selectedIndex;
	    let input = this.input;
	    let pre = "";

	    if (input.selectionStart < input.selectionEnd) {
	      pre = input.value.slice(0, input.selectionStart);
	    } else {
	      pre = input.value.slice(0, input.selectionStart - label.length +
	                              preLabel.length);
	    }

	    let post = input.value.slice(input.selectionEnd, input.value.length);
	    let item = this.popup.selectedItem;
	    let toComplete = item.label.slice(item.preLabel.length);
	    input.value = pre + toComplete + post;

	    if (!noSelect) {
	      input.setSelectionRange(pre.length, pre.length + toComplete.length);
	    } else {
	      input.setSelectionRange(pre.length + toComplete.length,
	                              pre.length + toComplete.length);
	    }

	    this._updateSize();
	    // This emit is mainly for the purpose of making the test flow simpler.
	    this.emit("after-suggest");
	  },

	  /**
	   * Call the client's done handler and clear out.
	   */
	  _apply: function (event, direction) {
	    if (this._applied) {
	      return null;
	    }

	    this._applied = true;

	    if (this.done) {
	      let val = this.cancelled ? this.initial : this.currentInputValue;
	      return this.done(val, !this.cancelled, direction);
	    }

	    return null;
	  },

	  /**
	   * Hide the popup and cancel any pending popup opening.
	   */
	  _onWindowBlur: function () {
	    if (this.popup && this.popup.isOpen) {
	      this.popup.hidePopup();
	    }

	    if (this._openPopupTimeout) {
	      this.doc.defaultView.clearTimeout(this._openPopupTimeout);
	    }
	  },

	  /**
	   * Event handler called when the inplace-editor's input loses focus.
	   */
	  _onBlur: function (event) {
	    if (event && this.popup && this.popup.isOpen &&
	      this.popup.selectedIndex >= 0) {
	      this._acceptPopupSuggestion();
	    } else {
	      this._apply();
	      this._clear();
	    }
	  },

	  /**
	   * Event handler called by the autocomplete popup when receiving a click
	   * event.
	   */
	  _onAutocompletePopupClick: function () {
	    this._acceptPopupSuggestion();
	  },

	  _acceptPopupSuggestion: function () {
	    let label, preLabel;

	    if (this._selectedIndex === undefined) {
	      ({label, preLabel} = this.popup.getItemAtIndex(this.popup.selectedIndex));
	    } else {
	      ({label, preLabel} = this.popup.getItemAtIndex(this._selectedIndex));
	    }

	    let input = this.input;

	    let pre = "";

	    // CSS_MIXED needs special treatment here to make it so that
	    // multiple presses of tab will cycle through completions, but
	    // without selecting the completed text.  However, this same
	    // special treatment will do the wrong thing for other editing
	    // styles.
	    if (input.selectionStart < input.selectionEnd ||
	        this.contentType !== CONTENT_TYPES.CSS_MIXED) {
	      pre = input.value.slice(0, input.selectionStart);
	    } else {
	      pre = input.value.slice(0, input.selectionStart - label.length +
	                              preLabel.length);
	    }
	    let post = input.value.slice(input.selectionEnd, input.value.length);
	    let item = this.popup.selectedItem;
	    this._selectedIndex = this.popup.selectedIndex;
	    let toComplete = item.label.slice(item.preLabel.length);
	    input.value = pre + toComplete + post;
	    input.setSelectionRange(pre.length + toComplete.length,
	                            pre.length + toComplete.length);
	    this._updateSize();
	    // Wait for the popup to hide and then focus input async otherwise it does
	    // not work.
	    let onPopupHidden = () => {
	      this.popup.off("popup-closed", onPopupHidden);
	      this.doc.defaultView.setTimeout(()=> {
	        input.focus();
	        this.emit("after-suggest");
	      }, 0);
	    };
	    this.popup.on("popup-closed", onPopupHidden);
	    this._hideAutocompletePopup();
	  },

	  /**
	   * Handle the input field's keypress event.
	   */
	  _onKeyPress: function (event) {
	    let prevent = false;

	    let key = event.keyCode;
	    let input = this.input;

	    let multilineNavigation = !this._isSingleLine() &&
	      isKeyIn(key, "UP", "DOWN", "LEFT", "RIGHT");
	    let isPlainText = this.contentType == CONTENT_TYPES.PLAIN_TEXT;
	    let isPopupOpen = this.popup && this.popup.isOpen;

	    let increment = 0;
	    if (!isPlainText && !multilineNavigation) {
	      increment = this._getIncrement(event);
	    }

	    if (isKeyIn(key, "PAGE_UP", "PAGE_DOWN")) {
	      this._preventSuggestions = true;
	    }

	    let cycling = false;
	    if (increment && this._incrementValue(increment)) {
	      this._updateSize();
	      prevent = true;
	      cycling = true;
	    }

	    if (isPopupOpen && isKeyIn(key, "UP", "DOWN", "PAGE_UP", "PAGE_DOWN")) {
	      prevent = true;
	      cycling = true;
	      this._cycleCSSSuggestion(isKeyIn(key, "UP", "PAGE_UP"));
	      this._doValidation();
	    }

	    if (isKeyIn(key, "BACK_SPACE", "DELETE", "LEFT", "RIGHT", "HOME", "END")) {
	      if (isPopupOpen) {
	        this._hideAutocompletePopup();
	      }
	    } else if (!cycling && !multilineNavigation &&
	      !event.metaKey && !event.altKey && !event.ctrlKey) {
	      this._maybeSuggestCompletion(true);
	    }

	    if (this.multiline && event.shiftKey && isKeyIn(key, "RETURN")) {
	      prevent = false;
	    } else if (
	      this._advanceChars(event.charCode, input.value, input.selectionStart) ||
	      isKeyIn(key, "RETURN", "TAB")) {
	      prevent = true;

	      let direction;
	      if ((this.stopOnReturn && isKeyIn(key, "RETURN")) ||
	          (this.stopOnTab && !event.shiftKey && isKeyIn(key, "TAB")) ||
	          (this.stopOnShiftTab && event.shiftKey && isKeyIn(key, "TAB"))) {
	        direction = null;
	      } else if (event.shiftKey && isKeyIn(key, "TAB")) {
	        direction = FOCUS_BACKWARD;
	      } else {
	        direction = FOCUS_FORWARD;
	      }

	      // Now we don't want to suggest anything as we are moving out.
	      this._preventSuggestions = true;
	      // But we still want to show suggestions for css values. i.e. moving out
	      // of css property input box in forward direction
	      if (this.contentType == CONTENT_TYPES.CSS_PROPERTY &&
	          direction == FOCUS_FORWARD) {
	        this._preventSuggestions = false;
	      }

	      if (isKeyIn(key, "TAB") && this.contentType == CONTENT_TYPES.CSS_MIXED) {
	        if (this.popup && input.selectionStart < input.selectionEnd) {
	          event.preventDefault();
	          input.setSelectionRange(input.selectionEnd, input.selectionEnd);
	          this.emit("after-suggest");
	          return;
	        } else if (this.popup && this.popup.isOpen) {
	          event.preventDefault();
	          this._cycleCSSSuggestion(event.shiftKey, true);
	          return;
	        }
	      }

	      this._apply(event, direction);

	      // Close the popup if open
	      if (this.popup && this.popup.isOpen) {
	        this._hideAutocompletePopup();
	      }

	      if (direction !== null && focusManager.focusedElement === input) {
	        // If the focused element wasn't changed by the done callback,
	        // move the focus as requested.
	        let next = moveFocus(this.doc.defaultView, direction);

	        // If the next node to be focused has been tagged as an editable
	        // node, trigger editing using the configured event
	        if (next && next.ownerDocument === this.doc && next._editable) {
	          let e = this.doc.createEvent("Event");
	          e.initEvent(next._trigger, true, true);
	          next.dispatchEvent(e);
	        }
	      }

	      this._clear();
	    } else if (isKeyIn(key, "ESCAPE")) {
	      // Cancel and blur ourselves.
	      // Now we don't want to suggest anything as we are moving out.
	      this._preventSuggestions = true;
	      // Close the popup if open
	      if (this.popup && this.popup.isOpen) {
	        this._hideAutocompletePopup();
	      }
	      prevent = true;
	      this.cancelled = true;
	      this._apply();
	      this._clear();
	      event.stopPropagation();
	    } else if (isKeyIn(key, "SPACE")) {
	      // No need for leading spaces here.  This is particularly
	      // noticable when adding a property: it's very natural to type
	      // <name>: (which advances to the next property) then spacebar.
	      prevent = !input.value;
	    }

	    if (prevent) {
	      event.preventDefault();
	    }
	  },

	  /**
	   * Open the autocomplete popup, adding a custom click handler and classname.
	   *
	   * @param {Number} offset
	   *        X-offset relative to the input starting edge.
	   * @param {Number} selectedIndex
	   *        The index of the item that should be selected. Use -1 to have no
	   *        item selected.
	   */
	  _openAutocompletePopup: function (offset, selectedIndex) {
	    this.popup.on("popup-click", this._onAutocompletePopupClick);
	    this.popup.openPopup(this.input, offset, 0, selectedIndex);
	  },

	  /**
	   * Remove the custom classname and click handler and close the autocomplete
	   * popup.
	   */
	  _hideAutocompletePopup: function () {
	    this.popup.off("popup-click", this._onAutocompletePopupClick);
	    this.popup.hidePopup();
	  },

	  /**
	   * Get the increment/decrement step to use for the provided key event.
	   */
	  _getIncrement: function (event) {
	    const largeIncrement = 100;
	    const mediumIncrement = 10;
	    const smallIncrement = 0.1;

	    let increment = 0;
	    let key = event.keyCode;

	    if (isKeyIn(key, "UP", "PAGE_UP")) {
	      increment = 1;
	    } else if (isKeyIn(key, "DOWN", "PAGE_DOWN")) {
	      increment = -1;
	    }

	    if (event.shiftKey && !event.altKey) {
	      if (isKeyIn(key, "PAGE_UP", "PAGE_DOWN")) {
	        increment *= largeIncrement;
	      } else {
	        increment *= mediumIncrement;
	      }
	    } else if (event.altKey && !event.shiftKey) {
	      increment *= smallIncrement;
	    }

	    return increment;
	  },

	  /**
	   * Handle the input field's keyup event.
	   */
	  _onKeyup: function () {
	    this._applied = false;
	  },

	  /**
	   * Handle changes to the input text.
	   */
	  _onInput: function () {
	    // Validate the entered value.
	    this._doValidation();

	    // Update size if we're autosizing.
	    if (this._measurement) {
	      this._updateSize();
	    }

	    // Call the user's change handler if available.
	    if (this.change) {
	      this.change(this.currentInputValue);
	    }
	  },

	  /**
	   * Stop propagation on the provided event
	   */
	  _stopEventPropagation: function (e) {
	    e.stopPropagation();
	  },

	  /**
	   * Fire validation callback with current input
	   */
	  _doValidation: function () {
	    if (this.validate && this.input) {
	      this.validate(this.input.value);
	    }
	  },

	  /**
	   * Handles displaying suggestions based on the current input.
	   *
	   * @param {Boolean} autoInsert
	   *        Pass true to automatically insert the most relevant suggestion.
	   */
	  _maybeSuggestCompletion: function (autoInsert) {
	    // Input can be null in cases when you intantaneously switch out of it.
	    if (!this.input) {
	      return;
	    }
	    let preTimeoutQuery = this.input.value;

	    // Since we are calling this method from a keypress event handler, the
	    // |input.value| does not include currently typed character. Thus we perform
	    // this method async.
	    this._openPopupTimeout = this.doc.defaultView.setTimeout(() => {
	      if (this._preventSuggestions) {
	        this._preventSuggestions = false;
	        return;
	      }
	      if (this.contentType == CONTENT_TYPES.PLAIN_TEXT) {
	        return;
	      }
	      if (!this.input) {
	        return;
	      }
	      let input = this.input;
	      // The length of input.value should be increased by 1
	      if (input.value.length - preTimeoutQuery.length > 1) {
	        return;
	      }
	      let query = input.value.slice(0, input.selectionStart);
	      let startCheckQuery = query;
	      if (query == null) {
	        return;
	      }
	      // If nothing is selected and there is a word (\w) character after the cursor, do
	      // not autocomplete.
	      if (input.selectionStart == input.selectionEnd &&
	          input.selectionStart < input.value.length) {
	        let nextChar = input.value.slice(input.selectionStart)[0];
	        // Check if the next character is a valid word character, no suggestion should be
	        // provided when preceeding a word.
	        if (/[\w-]/.test(nextChar)) {
	          // This emit is mainly to make the test flow simpler.
	          this.emit("after-suggest", "nothing to autocomplete");
	          return;
	        }
	      }
	      let list = [];
	      if (this.contentType == CONTENT_TYPES.CSS_PROPERTY) {
	        list = this._getCSSPropertyList();
	      } else if (this.contentType == CONTENT_TYPES.CSS_VALUE) {
	        // Get the last query to be completed before the caret.
	        let match = /([^\s,.\/]+$)/.exec(query);
	        if (match) {
	          startCheckQuery = match[0];
	        } else {
	          startCheckQuery = "";
	        }

	        list =
	          ["!important",
	           ...this._getCSSValuesForPropertyName(this.property.name)];

	        if (query == "") {
	          // Do not suggest '!important' without any manually typed character.
	          list.splice(0, 1);
	        }
	      } else if (this.contentType == CONTENT_TYPES.CSS_MIXED &&
	                 /^\s*style\s*=/.test(query)) {
	        // Check if the style attribute is closed before the selection.
	        let styleValue = query.replace(/^\s*style\s*=\s*/, "");
	        // Look for a quote matching the opening quote (single or double).
	        if (/^("[^"]*"|'[^']*')/.test(styleValue)) {
	          // This emit is mainly to make the test flow simpler.
	          this.emit("after-suggest", "nothing to autocomplete");
	          return;
	        }

	        // Detecting if cursor is at property or value;
	        let match = query.match(/([:;"'=]?)\s*([^"';:=]+)?$/);
	        if (match && match.length >= 2) {
	          if (match[1] == ":") {
	            // We are in CSS value completion
	            let propertyName =
	              query.match(/[;"'=]\s*([^"';:= ]+)\s*:\s*[^"';:=]*$/)[1];
	            list =
	              ["!important;",
	               ...this._getCSSValuesForPropertyName(propertyName)];
	            let matchLastQuery = /([^\s,.\/]+$)/.exec(match[2] || "");
	            if (matchLastQuery) {
	              startCheckQuery = matchLastQuery[0];
	            } else {
	              startCheckQuery = "";
	            }
	            if (!match[2]) {
	              // Don't suggest '!important' without any manually typed character
	              list.splice(0, 1);
	            }
	          } else if (match[1]) {
	            // We are in CSS property name completion
	            list = this._getCSSPropertyList();
	            startCheckQuery = match[2];
	          }
	          if (startCheckQuery == null) {
	            // This emit is mainly to make the test flow simpler.
	            this.emit("after-suggest", "nothing to autocomplete");
	            return;
	          }
	        }
	      }

	      if (!this.popup) {
	        // This emit is mainly to make the test flow simpler.
	        this.emit("after-suggest", "no popup");
	        return;
	      }

	      let finalList = [];
	      let length = list.length;
	      for (let i = 0, count = 0; i < length && count < MAX_POPUP_ENTRIES; i++) {
	        if (startCheckQuery != null && list[i].startsWith(startCheckQuery)) {
	          count++;
	          finalList.push({
	            preLabel: startCheckQuery,
	            label: list[i]
	          });
	        } else if (count > 0) {
	          // Since count was incremented, we had already crossed the entries
	          // which would have started with query, assuming that list is sorted.
	          break;
	        } else if (startCheckQuery != null && list[i][0] > startCheckQuery[0]) {
	          // We have crossed all possible matches alphabetically.
	          break;
	        }
	      }

	      // Sort items starting with [a-z0-9] first, to make sure vendor-prefixed
	      // values and "!important" are suggested only after standard values.
	      finalList.sort((item1, item2) => {
	        // Get the expected alphabetical comparison between the items.
	        let comparison = item1.label.localeCompare(item2.label);
	        if (/^\w/.test(item1.label) != /^\w/.test(item2.label)) {
	          // One starts with [a-z0-9], one does not: flip the comparison.
	          comparison = -1 * comparison;
	        }
	        return comparison;
	      });

	      let index = 0;
	      if (startCheckQuery) {
	        // Only select a "best" suggestion when the user started a query.
	        let cssValues = finalList.map(item => item.label);
	        index = findMostRelevantCssPropertyIndex(cssValues);
	      }

	      // Insert the most relevant item from the final list as the input value.
	      if (autoInsert && finalList[index]) {
	        let item = finalList[index].label;
	        input.value = query + item.slice(startCheckQuery.length) +
	                      input.value.slice(query.length);
	        input.setSelectionRange(query.length, query.length + item.length -
	                                              startCheckQuery.length);
	        this._updateSize();
	      }

	      // Display the list of suggestions if there are more than one.
	      if (finalList.length > 1) {
	        // Calculate the popup horizontal offset.
	        let indent = this.input.selectionStart - startCheckQuery.length;
	        let offset = indent * this.inputCharDimensions.width;
	        offset = this._isSingleLine() ? offset : 0;

	        // Select the most relevantItem if autoInsert is allowed
	        let selectedIndex = autoInsert ? index : -1;

	        // Open the suggestions popup.
	        this.popup.setItems(finalList);
	        this._openAutocompletePopup(offset, selectedIndex);
	      } else {
	        this._hideAutocompletePopup();
	      }
	      // This emit is mainly for the purpose of making the test flow simpler.
	      this.emit("after-suggest");
	      this._doValidation();
	    }, 0);
	  },

	  /**
	   * Check if the current input is displaying more than one line of text.
	   *
	   * @return {Boolean} true if the input has a single line of text
	   */
	  _isSingleLine: function () {
	    let inputRect = this.input.getBoundingClientRect();
	    return inputRect.height < 2 * this.inputCharDimensions.height;
	  },

	  /**
	   * Returns the list of CSS properties to use for the autocompletion. This
	   * method is overridden by tests in order to use mocked suggestion lists.
	   *
	   * @return {Array} array of CSS property names (Strings)
	   */
	  _getCSSPropertyList: function () {
	    return this.cssProperties.getNames().sort();
	  },

	  /**
	   * Returns a list of CSS values valid for a provided property name to use for
	   * the autocompletion. This method is overridden by tests in order to use
	   * mocked suggestion lists.
	   *
	   * @param {String} propertyName
	   * @return {Array} array of CSS property values (Strings)
	   */
	  _getCSSValuesForPropertyName: function (propertyName) {
	    return this.cssProperties.getValues(propertyName);
	  },
	};

	/**
	 * Copy text-related styles from one element to another.
	 */
	function copyTextStyles(from, to) {
	  let win = from.ownerDocument.defaultView;
	  let style = win.getComputedStyle(from);
	  let getCssText = name => style.getPropertyCSSValue(name).cssText;

	  to.style.fontFamily = getCssText("font-family");
	  to.style.fontSize = getCssText("font-size");
	  to.style.fontWeight = getCssText("font-weight");
	  to.style.fontStyle = getCssText("font-style");
	}

	/**
	 * Copy all styles which could have an impact on the element size.
	 */
	function copyAllStyles(from, to) {
	  let win = from.ownerDocument.defaultView;
	  let style = win.getComputedStyle(from);
	  let getCssText = name => style.getPropertyCSSValue(name).cssText;

	  copyTextStyles(from, to);
	  to.style.lineHeight = getCssText("line-height");

	  // If box-sizing is set to border-box, box model styles also need to be
	  // copied.
	  let boxSizing = getCssText("box-sizing");
	  if (boxSizing === "border-box") {
	    to.style.boxSizing = boxSizing;
	    copyBoxModelStyles(from, to);
	  }
	}

	/**
	 * Copy box model styles that can impact width and height measurements when box-
	 * sizing is set to "border-box" instead of "content-box".
	 *
	 * @param {DOMNode} from
	 *        the element from which styles are copied
	 * @param {DOMNode} to
	 *        the element on which copied styles are applied
	 */
	function copyBoxModelStyles(from, to) {
	  let win = from.ownerDocument.defaultView;
	  let style = win.getComputedStyle(from);
	  let getCssText = name => style.getPropertyCSSValue(name).cssText;

	  // Copy all paddings.
	  to.style.paddingTop = getCssText("padding-top");
	  to.style.paddingRight = getCssText("padding-right");
	  to.style.paddingBottom = getCssText("padding-bottom");
	  to.style.paddingLeft = getCssText("padding-left");

	  // Copy border styles.
	  to.style.borderTopStyle = getCssText("border-top-style");
	  to.style.borderRightStyle = getCssText("border-right-style");
	  to.style.borderBottomStyle = getCssText("border-bottom-style");
	  to.style.borderLeftStyle = getCssText("border-left-style");

	  // Copy border widths.
	  to.style.borderTopWidth = getCssText("border-top-width");
	  to.style.borderRightWidth = getCssText("border-right-width");
	  to.style.borderBottomWidth = getCssText("border-bottom-width");
	  to.style.borderLeftWidth = getCssText("border-left-width");
	}

	/**
	 * Trigger a focus change similar to pressing tab/shift-tab.
	 */
	function moveFocus(win, direction) {
	  return focusManager.moveFocus(win, null, direction, 0);
	}


/***/ },
/* 155 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Allows to find the lowest ranking index in an index
	 * of suggestions, by comparing it to another array of "most relevant" items
	 * which has been sorted by relevance.
	 *
	 * Example usage:
	 *  let sortedBrowsers = ["firefox", "safari", "edge", "chrome"];
	 *  let myBrowsers = ["brave", "chrome", "firefox"];
	 *  let bestBrowserIndex = findMostRelevantIndex(myBrowsers, sortedBrowsers);
	 *  // returns "2", the index of firefox in myBrowsers array
	 *
	 * @param {Array} items
	 *        Array of items to compare against sortedItems.
	 * @param {Array} sortedItems
	 *        Array of sorted items that suggestions are evaluated against. Array
	 *        should be sorted by relevance, most relevant item first.
	 * @return {Number}
	 */
	function findMostRelevantIndex(items, sortedItems) {
	  if (!Array.isArray(items) || !Array.isArray(sortedItems)) {
	    throw new Error("Please provide valid items and sortedItems arrays.");
	  }

	  // If the items array is empty, no valid index can be found.
	  if (!items.length) {
	    return -1;
	  }

	  // Return 0 if no match was found in the suggestion list.
	  let bestIndex = 0;
	  let lowestIndex = Infinity;
	  items.forEach((item, i) => {
	    let index = sortedItems.indexOf(item);
	    if (index !== -1 && index <= lowestIndex) {
	      lowestIndex = index;
	      bestIndex = i;
	    }
	  });

	  return bestIndex;
	}

	/**
	 * Top 100 CSS property names sorted by relevance, most relevant first.
	 *
	 * List based on the one used by Chrome devtools :
	 * https://code.google.com/p/chromium/codesearch#chromium/src/third_party/
	 * WebKit/Source/devtools/front_end/sdk/CSSMetadata.js&q=CSSMetadata&
	 * sq=package:chromium&type=cs&l=676
	 *
	 * The data is a mix of https://www.chromestatus.com/metrics/css and usage
	 * metrics from popular sites collected via https://gist.github.com/NV/3751436
	 *
	 * @type {Array}
	 */
	const SORTED_CSS_PROPERTIES = [
	  "width",
	  "margin",
	  "height",
	  "padding",
	  "font-size",
	  "border",
	  "display",
	  "position",
	  "text-align",
	  "background",
	  "background-color",
	  "top",
	  "font-weight",
	  "color",
	  "overflow",
	  "font-family",
	  "margin-top",
	  "float",
	  "opacity",
	  "cursor",
	  "left",
	  "text-decoration",
	  "background-image",
	  "right",
	  "line-height",
	  "margin-left",
	  "visibility",
	  "margin-bottom",
	  "padding-top",
	  "z-index",
	  "margin-right",
	  "background-position",
	  "vertical-align",
	  "padding-left",
	  "background-repeat",
	  "border-bottom",
	  "padding-right",
	  "border-top",
	  "padding-bottom",
	  "clear",
	  "white-space",
	  "bottom",
	  "border-color",
	  "max-width",
	  "border-radius",
	  "border-right",
	  "outline",
	  "border-left",
	  "font-style",
	  "content",
	  "min-width",
	  "min-height",
	  "box-sizing",
	  "list-style",
	  "border-width",
	  "box-shadow",
	  "font",
	  "border-collapse",
	  "text-shadow",
	  "text-indent",
	  "border-style",
	  "max-height",
	  "text-overflow",
	  "background-size",
	  "text-transform",
	  "zoom",
	  "list-style-type",
	  "border-spacing",
	  "word-wrap",
	  "overflow-y",
	  "transition",
	  "border-top-color",
	  "border-bottom-color",
	  "border-top-right-radius",
	  "letter-spacing",
	  "border-top-left-radius",
	  "border-bottom-left-radius",
	  "border-bottom-right-radius",
	  "overflow-x",
	  "pointer-events",
	  "border-right-color",
	  "transform",
	  "border-top-width",
	  "border-bottom-width",
	  "border-right-width",
	  "direction",
	  "animation",
	  "border-left-color",
	  "clip",
	  "border-left-width",
	  "table-layout",
	  "src",
	  "resize",
	  "word-break",
	  "background-clip",
	  "transform-origin",
	  "font-variant",
	  "filter",
	  "quotes",
	  "word-spacing"
	];

	/**
	 * Helper to find the most relevant CSS property name in a provided array.
	 *
	 * @param items {Array}
	 *              Array of CSS property names.
	 */
	function findMostRelevantCssPropertyIndex(items) {
	  return findMostRelevantIndex(items, SORTED_CSS_PROPERTIES);
	}

	exports.findMostRelevantIndex = findMostRelevantIndex;
	exports.findMostRelevantCssPropertyIndex = findMostRelevantCssPropertyIndex;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {l10n} = __webpack_require__(122);
	const {getCssProperties} = __webpack_require__(18);
	const {InplaceEditor, editableField} =
	      __webpack_require__(154);
	const {
	  createChild,
	  appendText,
	  advanceValidate,
	  blurOnMultipleProperties
	} = __webpack_require__(131);
	const {
	  parseDeclarations,
	  parseSingleValue,
	} = __webpack_require__(132);
	const Services = __webpack_require__(1);

	const HTML_NS = "http://www.w3.org/1999/xhtml";

	const SHARED_SWATCH_CLASS = "ruleview-swatch";
	const COLOR_SWATCH_CLASS = "ruleview-colorswatch";
	const BEZIER_SWATCH_CLASS = "ruleview-bezierswatch";
	const FILTER_SWATCH_CLASS = "ruleview-filterswatch";
	const ANGLE_SWATCH_CLASS = "ruleview-angleswatch";

	/*
	 * An actionable element is an element which on click triggers a specific action
	 * (e.g. shows a color tooltip, opens a link, …).
	 */
	const ACTIONABLE_ELEMENTS_SELECTORS = [
	  `.${COLOR_SWATCH_CLASS}`,
	  `.${BEZIER_SWATCH_CLASS}`,
	  `.${FILTER_SWATCH_CLASS}`,
	  `.${ANGLE_SWATCH_CLASS}`,
	  "a"
	];

	/**
	 * TextPropertyEditor is responsible for the following:
	 *   Owns a TextProperty object.
	 *   Manages changes to the TextProperty.
	 *   Can be expanded to display computed properties.
	 *   Can mark a property disabled or enabled.
	 *
	 * @param {RuleEditor} ruleEditor
	 *        The rule editor that owns this TextPropertyEditor.
	 * @param {TextProperty} property
	 *        The text property to edit.
	 */
	function TextPropertyEditor(ruleEditor, property) {
	  this.ruleEditor = ruleEditor;
	  this.ruleView = this.ruleEditor.ruleView;
	  this.doc = this.ruleEditor.doc;
	  this.popup = this.ruleView.popup;
	  this.prop = property;
	  this.prop.editor = this;
	  this.browserWindow = this.doc.defaultView.top;
	  this._populatedComputed = false;
	  this._hasPendingClick = false;
	  this._clickedElementOptions = null;

	  const toolbox = this.ruleView.inspector.toolbox;
	  this.cssProperties = getCssProperties(toolbox);

	  this._onEnableClicked = this._onEnableClicked.bind(this);
	  this._onExpandClicked = this._onExpandClicked.bind(this);
	  this._onStartEditing = this._onStartEditing.bind(this);
	  this._onNameDone = this._onNameDone.bind(this);
	  this._onValueDone = this._onValueDone.bind(this);
	  this._onSwatchCommit = this._onSwatchCommit.bind(this);
	  this._onSwatchPreview = this._onSwatchPreview.bind(this);
	  this._onSwatchRevert = this._onSwatchRevert.bind(this);
	  this._onValidate = this.ruleView.throttle(this._previewValue, 10, this);
	  this.update = this.update.bind(this);
	  this.updatePropertyState = this.updatePropertyState.bind(this);

	  this._create();
	  this.update();
	}

	TextPropertyEditor.prototype = {
	  /**
	   * Boolean indicating if the name or value is being currently edited.
	   */
	  get editing() {
	    return !!(this.nameSpan.inplaceEditor || this.valueSpan.inplaceEditor ||
	      this.ruleView.tooltips.isEditing) || this.popup.isOpen;
	  },

	  /**
	   * Get the rule to the current text property
	   */
	  get rule() {
	    return this.prop.rule;
	  },

	  /**
	   * Create the property editor's DOM.
	   */
	  _create: function () {
	    this.element = this.doc.createElementNS(HTML_NS, "li");
	    this.element.classList.add("ruleview-property");
	    this.element._textPropertyEditor = this;

	    this.container = createChild(this.element, "div", {
	      class: "ruleview-propertycontainer"
	    });

	    // The enable checkbox will disable or enable the rule.
	    this.enable = createChild(this.container, "div", {
	      class: "ruleview-enableproperty theme-checkbox",
	      tabindex: "-1"
	    });

	    // Click to expand the computed properties of the text property.
	    this.expander = createChild(this.container, "span", {
	      class: "ruleview-expander theme-twisty"
	    });
	    this.expander.addEventListener("click", this._onExpandClicked, true);

	    this.nameContainer = createChild(this.container, "span", {
	      class: "ruleview-namecontainer"
	    });

	    // Property name, editable when focused.  Property name
	    // is committed when the editor is unfocused.
	    this.nameSpan = createChild(this.nameContainer, "span", {
	      class: "ruleview-propertyname theme-fg-color5",
	      tabindex: this.ruleEditor.isEditable ? "0" : "-1",
	    });

	    appendText(this.nameContainer, ": ");

	    // Create a span that will hold the property and semicolon.
	    // Use this span to create a slightly larger click target
	    // for the value.
	    this.valueContainer = createChild(this.container, "span", {
	      class: "ruleview-propertyvaluecontainer"
	    });

	    // Property value, editable when focused.  Changes to the
	    // property value are applied as they are typed, and reverted
	    // if the user presses escape.
	    this.valueSpan = createChild(this.valueContainer, "span", {
	      class: "ruleview-propertyvalue theme-fg-color1",
	      tabindex: this.ruleEditor.isEditable ? "0" : "-1",
	    });

	    // Storing the TextProperty on the elements for easy access
	    // (for instance by the tooltip)
	    this.valueSpan.textProperty = this.prop;
	    this.nameSpan.textProperty = this.prop;

	    // If the value is a color property we need to put it through the parser
	    // so that colors can be coerced into the default color type. This prevents
	    // us from thinking that when colors are coerced they have been changed by
	    // the user.
	    let outputParser = this.ruleView._outputParser;
	    let frag = outputParser.parseCssProperty(this.prop.name, this.prop.value);
	    let parsedValue = frag.textContent;

	    // Save the initial value as the last committed value,
	    // for restoring after pressing escape.
	    this.committed = { name: this.prop.name,
	                       value: parsedValue,
	                       priority: this.prop.priority };

	    appendText(this.valueContainer, ";");

	    this.warning = createChild(this.container, "div", {
	      class: "ruleview-warning",
	      hidden: "",
	      title: l10n("rule.warning.title"),
	    });

	    // Filter button that filters for the current property name and is
	    // displayed when the property is overridden by another rule.
	    this.filterProperty = createChild(this.container, "div", {
	      class: "ruleview-overridden-rule-filter",
	      hidden: "",
	      title: l10n("rule.filterProperty.title"),
	    });

	    this.filterProperty.addEventListener("click", event => {
	      this.ruleEditor.ruleView.setFilterStyles("`" + this.prop.name + "`");
	      event.stopPropagation();
	    }, false);

	    // Holds the viewers for the computed properties.
	    // will be populated in |_updateComputed|.
	    this.computed = createChild(this.element, "ul", {
	      class: "ruleview-computedlist",
	    });

	    // Only bind event handlers if the rule is editable.
	    if (this.ruleEditor.isEditable) {
	      this.enable.addEventListener("click", this._onEnableClicked, true);

	      this.nameContainer.addEventListener("click", (event) => {
	        // Clicks within the name shouldn't propagate any further.
	        event.stopPropagation();

	        // Forward clicks on nameContainer to the editable nameSpan
	        if (event.target === this.nameContainer) {
	          this.nameSpan.click();
	        }
	      }, false);

	      editableField({
	        start: this._onStartEditing,
	        element: this.nameSpan,
	        done: this._onNameDone,
	        destroy: this.updatePropertyState,
	        advanceChars: ":",
	        contentType: InplaceEditor.CONTENT_TYPES.CSS_PROPERTY,
	        popup: this.popup,
	        cssProperties: this.cssProperties
	      });

	      // Auto blur name field on multiple CSS rules get pasted in.
	      this.nameContainer.addEventListener("paste",
	        blurOnMultipleProperties(this.cssProperties), false);

	      this.valueContainer.addEventListener("click", (event) => {
	        // Clicks within the value shouldn't propagate any further.
	        event.stopPropagation();

	        // Forward clicks on valueContainer to the editable valueSpan
	        if (event.target === this.valueContainer) {
	          this.valueSpan.click();
	        }
	      }, false);

	      // The mousedown event could trigger a blur event on nameContainer, which
	      // will trigger a call to the update function. The update function clears
	      // valueSpan's markup. Thus the regular click event does not bubble up, and
	      // listener's callbacks are not called.
	      // So we need to remember where the user clicks in order to re-trigger the click
	      // after the valueSpan's markup is re-populated. We only need to track this for
	      // valueSpan's child elements, because direct click on valueSpan will always
	      // trigger a click event.
	      this.valueSpan.addEventListener("mousedown", (event) => {
	        let clickedEl = event.target;
	        if (clickedEl === this.valueSpan) {
	          return;
	        }
	        this._hasPendingClick = true;

	        let matchedSelector = ACTIONABLE_ELEMENTS_SELECTORS.find(
	          (selector) => clickedEl.matches(selector));
	        if (matchedSelector) {
	          let similarElements = [...this.valueSpan.querySelectorAll(matchedSelector)];
	          this._clickedElementOptions = {
	            selector: matchedSelector,
	            index: similarElements.indexOf(clickedEl)
	          };
	        }
	      }, false);

	      this.valueSpan.addEventListener("mouseup", (event) => {
	        this._clickedElementOptions = null;
	        this._hasPendingClick = false;
	      }, false);

	      this.valueSpan.addEventListener("click", (event) => {
	        let target = event.target;

	        if (target.nodeName === "a") {
	          event.stopPropagation();
	          event.preventDefault();
	          this.browserWindow.openUILinkIn(target.href, "tab");
	        }
	      }, false);

	      editableField({
	        start: this._onStartEditing,
	        element: this.valueSpan,
	        done: this._onValueDone,
	        destroy: this.update,
	        validate: this._onValidate,
	        advanceChars: advanceValidate,
	        contentType: InplaceEditor.CONTENT_TYPES.CSS_VALUE,
	        property: this.prop,
	        popup: this.popup,
	        multiline: true,
	        maxWidth: () => this.container.getBoundingClientRect().width,
	        cssProperties: this.cssProperties
	      });
	    }
	  },

	  /**
	   * Get the path from which to resolve requests for this
	   * rule's stylesheet.
	   *
	   * @return {String} the stylesheet's href.
	   */
	  get sheetHref() {
	    let domRule = this.rule.domRule;
	    if (domRule) {
	      return domRule.href || domRule.nodeHref;
	    }
	    return undefined;
	  },

	  /**
	   * Populate the span based on changes to the TextProperty.
	   */
	  update: function () {
	    if (this.ruleView.isDestroyed) {
	      return;
	    }

	    this.updatePropertyState();

	    let name = this.prop.name;
	    this.nameSpan.textContent = name;

	    // Combine the property's value and priority into one string for
	    // the value.
	    let store = this.rule.elementStyle.store;
	    let val = store.userProperties.getProperty(this.rule.style, name,
	                                               this.prop.value);
	    if (this.prop.priority) {
	      val += " !" + this.prop.priority;
	    }

	    let propDirty = store.userProperties.contains(this.rule.style, name);

	    if (propDirty) {
	      this.element.setAttribute("dirty", "");
	    } else {
	      this.element.removeAttribute("dirty");
	    }

	    let outputParser = this.ruleView._outputParser;
	    let parserOptions = {
	      colorSwatchClass: SHARED_SWATCH_CLASS + " " + COLOR_SWATCH_CLASS,
	      colorClass: "ruleview-color",
	      bezierSwatchClass: SHARED_SWATCH_CLASS + " " + BEZIER_SWATCH_CLASS,
	      bezierClass: "ruleview-bezier",
	      filterSwatchClass: SHARED_SWATCH_CLASS + " " + FILTER_SWATCH_CLASS,
	      filterClass: "ruleview-filter",
	      angleSwatchClass: SHARED_SWATCH_CLASS + " " + ANGLE_SWATCH_CLASS,
	      angleClass: "ruleview-angle",
	      defaultColorType: !propDirty,
	      urlClass: "theme-link",
	      baseURI: this.sheetHref
	    };
	    let frag = outputParser.parseCssProperty(name, val, parserOptions);
	    this.valueSpan.innerHTML = "";
	    this.valueSpan.appendChild(frag);

	    this.ruleView.emit("property-value-updated", this.valueSpan);

	    // Attach the color picker tooltip to the color swatches
	    this._colorSwatchSpans =
	      this.valueSpan.querySelectorAll("." + COLOR_SWATCH_CLASS);
	    if (this.ruleEditor.isEditable) {
	      for (let span of this._colorSwatchSpans) {
	        // Adding this swatch to the list of swatches our colorpicker
	        // knows about
	        this.ruleView.tooltips.colorPicker.addSwatch(span, {
	          onShow: this._onStartEditing,
	          onPreview: this._onSwatchPreview,
	          onCommit: this._onSwatchCommit,
	          onRevert: this._onSwatchRevert
	        });
	        span.on("unit-change", this._onSwatchCommit);
	        let title = l10n("rule.colorSwatch.tooltip");
	        span.setAttribute("title", title);
	      }
	    }

	    // Attach the cubic-bezier tooltip to the bezier swatches
	    this._bezierSwatchSpans =
	      this.valueSpan.querySelectorAll("." + BEZIER_SWATCH_CLASS);
	    if (this.ruleEditor.isEditable) {
	      for (let span of this._bezierSwatchSpans) {
	        // Adding this swatch to the list of swatches our colorpicker
	        // knows about
	        this.ruleView.tooltips.cubicBezier.addSwatch(span, {
	          onShow: this._onStartEditing,
	          onPreview: this._onSwatchPreview,
	          onCommit: this._onSwatchCommit,
	          onRevert: this._onSwatchRevert
	        });
	        let title = l10n("rule.bezierSwatch.tooltip");
	        span.setAttribute("title", title);
	      }
	    }

	    // Attach the filter editor tooltip to the filter swatch
	    let span = this.valueSpan.querySelector("." + FILTER_SWATCH_CLASS);
	    if (this.ruleEditor.isEditable) {
	      if (span) {
	        parserOptions.filterSwatch = true;

	        this.ruleView.tooltips.filterEditor.addSwatch(span, {
	          onShow: this._onStartEditing,
	          onPreview: this._onSwatchPreview,
	          onCommit: this._onSwatchCommit,
	          onRevert: this._onSwatchRevert
	        }, outputParser, parserOptions);
	        let title = l10n("rule.filterSwatch.tooltip");
	        span.setAttribute("title", title);
	      }
	    }

	    this.angleSwatchSpans =
	      this.valueSpan.querySelectorAll("." + ANGLE_SWATCH_CLASS);
	    if (this.ruleEditor.isEditable) {
	      for (let angleSpan of this.angleSwatchSpans) {
	        angleSpan.on("unit-change", this._onSwatchCommit);
	        let title = l10n("rule.angleSwatch.tooltip");
	        angleSpan.setAttribute("title", title);
	      }
	    }

	    // Now that we have updated the property's value, we might have a pending
	    // click on the value container. If we do, we have to trigger a click event
	    // on the right element.
	    if (this._hasPendingClick) {
	      this._hasPendingClick = false;
	      let elToClick;

	      if (this._clickedElementOptions !== null) {
	        let {selector, index} = this._clickedElementOptions;
	        elToClick = this.valueSpan.querySelectorAll(selector)[index];

	        this._clickedElementOptions = null;
	      }

	      if (!elToClick) {
	        elToClick = this.valueSpan;
	      }
	      elToClick.click();
	    }

	    // Populate the computed styles.
	    this._updateComputed();

	    // Update the rule property highlight.
	    this.ruleView._updatePropertyHighlight(this);
	  },

	  _onStartEditing: function () {
	    this.element.classList.remove("ruleview-overridden");
	    this.enable.style.visibility = "hidden";
	  },

	  /**
	   * Update the visibility of the enable checkbox, the warning indicator and
	   * the filter property, as well as the overriden state of the property.
	   */
	  updatePropertyState: function () {
	    if (this.prop.enabled) {
	      this.enable.style.removeProperty("visibility");
	      this.enable.setAttribute("checked", "");
	    } else {
	      this.enable.style.visibility = "visible";
	      this.enable.removeAttribute("checked");
	    }

	    this.warning.hidden = this.editing || this.isValid();
	    this.filterProperty.hidden = this.editing ||
	                                 !this.isValid() ||
	                                 !this.prop.overridden ||
	                                 this.ruleEditor.rule.isUnmatched;

	    if (!this.editing &&
	        (this.prop.overridden || !this.prop.enabled ||
	         !this.prop.isKnownProperty())) {
	      this.element.classList.add("ruleview-overridden");
	    } else {
	      this.element.classList.remove("ruleview-overridden");
	    }
	  },

	  /**
	   * Update the indicator for computed styles. The computed styles themselves
	   * are populated on demand, when they become visible.
	   */
	  _updateComputed: function () {
	    this.computed.innerHTML = "";

	    let showExpander = this.prop.computed.some(c => c.name !== this.prop.name);
	    this.expander.style.visibility = showExpander ? "visible" : "hidden";

	    this._populatedComputed = false;
	    if (this.expander.hasAttribute("open")) {
	      this._populateComputed();
	    }
	  },

	  /**
	   * Populate the list of computed styles.
	   */
	  _populateComputed: function () {
	    if (this._populatedComputed) {
	      return;
	    }
	    this._populatedComputed = true;

	    for (let computed of this.prop.computed) {
	      // Don't bother to duplicate information already
	      // shown in the text property.
	      if (computed.name === this.prop.name) {
	        continue;
	      }

	      let li = createChild(this.computed, "li", {
	        class: "ruleview-computed"
	      });

	      if (computed.overridden) {
	        li.classList.add("ruleview-overridden");
	      }

	      createChild(li, "span", {
	        class: "ruleview-propertyname theme-fg-color5",
	        textContent: computed.name
	      });
	      appendText(li, ": ");

	      let outputParser = this.ruleView._outputParser;
	      let frag = outputParser.parseCssProperty(
	        computed.name, computed.value, {
	          colorSwatchClass: "ruleview-swatch ruleview-colorswatch",
	          urlClass: "theme-link",
	          baseURI: this.sheetHref
	        }
	      );

	      // Store the computed property value that was parsed for output
	      computed.parsedValue = frag.textContent;

	      createChild(li, "span", {
	        class: "ruleview-propertyvalue theme-fg-color1",
	        child: frag
	      });

	      appendText(li, ";");

	      // Store the computed style element for easy access when highlighting
	      // styles
	      computed.element = li;
	    }
	  },

	  /**
	   * Handles clicks on the disabled property.
	   */
	  _onEnableClicked: function (event) {
	    let checked = this.enable.hasAttribute("checked");
	    if (checked) {
	      this.enable.removeAttribute("checked");
	    } else {
	      this.enable.setAttribute("checked", "");
	    }
	    this.prop.setEnabled(!checked);
	    event.stopPropagation();
	  },

	  /**
	   * Handles clicks on the computed property expander. If the computed list is
	   * open due to user expanding or style filtering, collapse the computed list
	   * and close the expander. Otherwise, add user-open attribute which is used to
	   * expand the computed list and tracks whether or not the computed list is
	   * expanded by manually by the user.
	   */
	  _onExpandClicked: function (event) {
	    if (this.computed.hasAttribute("filter-open") ||
	        this.computed.hasAttribute("user-open")) {
	      this.expander.removeAttribute("open");
	      this.computed.removeAttribute("filter-open");
	      this.computed.removeAttribute("user-open");
	    } else {
	      this.expander.setAttribute("open", "true");
	      this.computed.setAttribute("user-open", "");
	      this._populateComputed();
	    }

	    event.stopPropagation();
	  },

	  /**
	   * Expands the computed list when a computed property is matched by the style
	   * filtering. The filter-open attribute is used to track whether or not the
	   * computed list was toggled opened by the filter.
	   */
	  expandForFilter: function () {
	    if (!this.computed.hasAttribute("user-open")) {
	      this.expander.setAttribute("open", "true");
	      this.computed.setAttribute("filter-open", "");
	      this._populateComputed();
	    }
	  },

	  /**
	   * Collapses the computed list that was expanded by style filtering.
	   */
	  collapseForFilter: function () {
	    this.computed.removeAttribute("filter-open");

	    if (!this.computed.hasAttribute("user-open")) {
	      this.expander.removeAttribute("open");
	    }
	  },

	  /**
	   * Called when the property name's inplace editor is closed.
	   * Ignores the change if the user pressed escape, otherwise
	   * commits it.
	   *
	   * @param {String} value
	   *        The value contained in the editor.
	   * @param {Boolean} commit
	   *        True if the change should be applied.
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  _onNameDone: function (value, commit, direction) {
	    let isNameUnchanged = (!commit && !this.ruleEditor.isEditing) ||
	                          this.committed.name === value;
	    if (this.prop.value && isNameUnchanged) {
	      return;
	    }

	    // Remove a property if the name is empty
	    if (!value.trim()) {
	      this.remove(direction);
	      return;
	    }

	    // Remove a property if the property value is empty and the property
	    // value is not about to be focused
	    if (!this.prop.value &&
	        direction !== Services.focus.MOVEFOCUS_FORWARD) {
	      this.remove(direction);
	      return;
	    }

	    // Adding multiple rules inside of name field overwrites the current
	    // property with the first, then adds any more onto the property list.
	    let properties = parseDeclarations(this.cssProperties.isKnown, value);

	    if (properties.length) {
	      this.prop.setName(properties[0].name);
	      this.committed.name = this.prop.name;

	      if (!this.prop.enabled) {
	        this.prop.setEnabled(true);
	      }

	      if (properties.length > 1) {
	        this.prop.setValue(properties[0].value, properties[0].priority);
	        this.ruleEditor.addProperties(properties.slice(1), this.prop);
	      }
	    }
	  },

	  /**
	   * Remove property from style and the editors from DOM.
	   * Begin editing next or previous available property given the focus
	   * direction.
	   *
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  remove: function (direction) {
	    if (this._colorSwatchSpans && this._colorSwatchSpans.length) {
	      for (let span of this._colorSwatchSpans) {
	        this.ruleView.tooltips.colorPicker.removeSwatch(span);
	        span.off("unit-change", this._onSwatchCommit);
	      }
	    }

	    if (this.angleSwatchSpans && this.angleSwatchSpans.length) {
	      for (let span of this.angleSwatchSpans) {
	        span.off("unit-change", this._onSwatchCommit);
	      }
	    }

	    this.element.parentNode.removeChild(this.element);
	    this.ruleEditor.rule.editClosestTextProperty(this.prop, direction);
	    this.nameSpan.textProperty = null;
	    this.valueSpan.textProperty = null;
	    this.prop.remove();
	  },

	  /**
	   * Called when a value editor closes.  If the user pressed escape,
	   * revert to the value this property had before editing.
	   *
	   * @param {String} value
	   *        The value contained in the editor.
	   * @param {Boolean} commit
	   *        True if the change should be applied.
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  _onValueDone: function (value = "", commit, direction) {
	    let parsedProperties = this._getValueAndExtraProperties(value);
	    let val = parseSingleValue(this.cssProperties.isKnown,
	                               parsedProperties.firstValue);
	    let isValueUnchanged = (!commit && !this.ruleEditor.isEditing) ||
	                           !parsedProperties.propertiesToAdd.length &&
	                           this.committed.value === val.value &&
	                           this.committed.priority === val.priority;
	    // If the value is not empty and unchanged, revert the property back to
	    // its original value and enabled or disabled state
	    if (value.trim() && isValueUnchanged) {
	      this.ruleEditor.rule.previewPropertyValue(this.prop, val.value,
	                                                val.priority);
	      this.rule.setPropertyEnabled(this.prop, this.prop.enabled);
	      return;
	    }

	    // First, set this property value (common case, only modified a property)
	    this.prop.setValue(val.value, val.priority);

	    if (!this.prop.enabled) {
	      this.prop.setEnabled(true);
	    }

	    this.committed.value = this.prop.value;
	    this.committed.priority = this.prop.priority;

	    // If needed, add any new properties after this.prop.
	    this.ruleEditor.addProperties(parsedProperties.propertiesToAdd, this.prop);

	    // If the input value is empty and the focus is moving forward to the next
	    // editable field, then remove the whole property.
	    // A timeout is used here to accurately check the state, since the inplace
	    // editor `done` and `destroy` events fire before the next editor
	    // is focused.
	    if (!value.trim() && direction !== Services.focus.MOVEFOCUS_BACKWARD) {
	      setTimeout(() => {
	        if (!this.editing) {
	          this.remove(direction);
	        }
	      }, 0);
	    }
	  },

	  /**
	   * Called when the swatch editor wants to commit a value change.
	   */
	  _onSwatchCommit: function () {
	    this._onValueDone(this.valueSpan.textContent, true);
	    this.update();
	  },

	  /**
	   * Called when the swatch editor wants to preview a value change.
	   */
	  _onSwatchPreview: function () {
	    this._previewValue(this.valueSpan.textContent);
	  },

	  /**
	   * Called when the swatch editor closes from an ESC. Revert to the original
	   * value of this property before editing.
	   */
	  _onSwatchRevert: function () {
	    this._previewValue(this.prop.value, true);
	    this.update();
	  },

	  /**
	   * Parse a value string and break it into pieces, starting with the
	   * first value, and into an array of additional properties (if any).
	   *
	   * Example: Calling with "red; width: 100px" would return
	   * { firstValue: "red", propertiesToAdd: [{ name: "width", value: "100px" }] }
	   *
	   * @param {String} value
	   *        The string to parse
	   * @return {Object} An object with the following properties:
	   *        firstValue: A string containing a simple value, like
	   *                    "red" or "100px!important"
	   *        propertiesToAdd: An array with additional properties, following the
	   *                         parseDeclarations format of {name,value,priority}
	   */
	  _getValueAndExtraProperties: function (value) {
	    // The inplace editor will prevent manual typing of multiple properties,
	    // but we need to deal with the case during a paste event.
	    // Adding multiple properties inside of value editor sets value with the
	    // first, then adds any more onto the property list (below this property).
	    let firstValue = value;
	    let propertiesToAdd = [];

	    let properties = parseDeclarations(this.cssProperties.isKnown, value);

	    // Check to see if the input string can be parsed as multiple properties
	    if (properties.length) {
	      // Get the first property value (if any), and any remaining
	      // properties (if any)
	      if (!properties[0].name && properties[0].value) {
	        firstValue = properties[0].value;
	        propertiesToAdd = properties.slice(1);
	      } else if (properties[0].name && properties[0].value) {
	        // In some cases, the value could be a property:value pair
	        // itself.  Join them as one value string and append
	        // potentially following properties
	        firstValue = properties[0].name + ": " + properties[0].value;
	        propertiesToAdd = properties.slice(1);
	      }
	    }

	    return {
	      propertiesToAdd: propertiesToAdd,
	      firstValue: firstValue
	    };
	  },

	  /**
	   * Live preview this property, without committing changes.
	   *
	   * @param {String} value
	   *        The value to set the current property to.
	   * @param {Boolean} reverting
	   *        True if we're reverting the previously previewed value
	   */
	  _previewValue: function (value, reverting = false) {
	    // Since function call is throttled, we need to make sure we are still
	    // editing, and any selector modifications have been completed
	    if (!reverting && (!this.editing || this.ruleEditor.isEditing)) {
	      return;
	    }

	    let val = parseSingleValue(this.cssProperties.isKnown, value);
	    this.ruleEditor.rule.previewPropertyValue(this.prop, val.value,
	                                              val.priority);
	  },

	  /**
	   * Validate this property. Does it make sense for this value to be assigned
	   * to this property name? This does not apply the property value
	   *
	   * @return {Boolean} true if the property value is valid, false otherwise.
	   */
	  isValid: function () {
	    return this.prop.isValid();
	  }
	};

	exports.TextPropertyEditor = TextPropertyEditor;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {PREF_ORIG_SOURCES} = __webpack_require__(130);
	const Services = __webpack_require__(1);
	const {Task} = __webpack_require__(17);

	const Menu = __webpack_require__(35);
	const MenuItem = __webpack_require__(36);

	const overlays = __webpack_require__(134);
	const clipboardHelper = __webpack_require__(158);

	const STYLE_INSPECTOR_PROPERTIES = "devtools-shared/locale/styleinspector.properties";
	const {LocalizationHelper} = __webpack_require__(39);
	const STYLE_INSPECTOR_L10N = new LocalizationHelper(STYLE_INSPECTOR_PROPERTIES);

	const PREF_ENABLE_MDN_DOCS_TOOLTIP =
	  "devtools.inspector.mdnDocsTooltip.enabled";

	/**
	 * Style inspector context menu
	 *
	 * @param {RuleView|ComputedView} view
	 *        RuleView or ComputedView instance controlling this menu
	 * @param {Object} options
	 *        Option menu configuration
	 */
	function StyleInspectorMenu(view, options) {
	  this.view = view;
	  this.inspector = this.view.inspector;
	  this.styleDocument = this.view.styleDocument;
	  this.styleWindow = this.view.styleWindow;

	  this.isRuleView = options.isRuleView;

	  this._onAddNewRule = this._onAddNewRule.bind(this);
	  this._onCopy = this._onCopy.bind(this);
	  this._onCopyColor = this._onCopyColor.bind(this);
	  this._onCopyImageDataUrl = this._onCopyImageDataUrl.bind(this);
	  this._onCopyLocation = this._onCopyLocation.bind(this);
	  this._onCopyPropertyDeclaration = this._onCopyPropertyDeclaration.bind(this);
	  this._onCopyPropertyName = this._onCopyPropertyName.bind(this);
	  this._onCopyPropertyValue = this._onCopyPropertyValue.bind(this);
	  this._onCopyRule = this._onCopyRule.bind(this);
	  this._onCopySelector = this._onCopySelector.bind(this);
	  this._onCopyUrl = this._onCopyUrl.bind(this);
	  this._onSelectAll = this._onSelectAll.bind(this);
	  this._onShowMdnDocs = this._onShowMdnDocs.bind(this);
	  this._onToggleOrigSources = this._onToggleOrigSources.bind(this);
	}

	module.exports = StyleInspectorMenu;

	StyleInspectorMenu.prototype = {
	  /**
	   * Display the style inspector context menu
	   */
	  show: function (event) {
	    try {
	      this._openMenu({
	        target: event.explicitOriginalTarget,
	        screenX: event.screenX,
	        screenY: event.screenY,
	      });
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  _openMenu: function ({ target, screenX = 0, screenY = 0 } = { }) {
	    // In the sidebar we do not have this.styleDocument.popupNode
	    // so we need to save the node ourselves.
	    this.styleDocument.popupNode = target;
	    this.styleWindow.focus();

	    let menu = new Menu();

	    let menuitemCopy = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copy"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copy.accessKey"),
	      click: () => {
	        this._onCopy();
	      },
	      disabled: !this._hasTextSelected(),
	    });
	    let menuitemCopyLocation = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyLocation"),
	      click: () => {
	        this._onCopyLocation();
	      },
	      visible: false,
	    });
	    let menuitemCopyRule = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyRule"),
	      click: () => {
	        this._onCopyRule();
	      },
	      visible: this.isRuleView,
	    });
	    let copyColorAccessKey = "styleinspector.contextmenu.copyColor.accessKey";
	    let menuitemCopyColor = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyColor"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(copyColorAccessKey),
	      click: () => {
	        this._onCopyColor();
	      },
	      visible: this._isColorPopup(),
	    });
	    let copyUrlAccessKey = "styleinspector.contextmenu.copyUrl.accessKey";
	    let menuitemCopyUrl = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyUrl"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(copyUrlAccessKey),
	      click: () => {
	        this._onCopyUrl();
	      },
	      visible: this._isImageUrl(),
	    });
	    let copyImageAccessKey = "styleinspector.contextmenu.copyImageDataUrl.accessKey";
	    let menuitemCopyImageDataUrl = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyImageDataUrl"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(copyImageAccessKey),
	      click: () => {
	        this._onCopyImageDataUrl();
	      },
	      visible: this._isImageUrl(),
	    });
	    let copyPropDeclarationLabel = "styleinspector.contextmenu.copyPropertyDeclaration";
	    let menuitemCopyPropertyDeclaration = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr(copyPropDeclarationLabel),
	      click: () => {
	        this._onCopyPropertyDeclaration();
	      },
	      visible: false,
	    });
	    let menuitemCopyPropertyName = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyPropertyName"),
	      click: () => {
	        this._onCopyPropertyName();
	      },
	      visible: false,
	    });
	    let menuitemCopyPropertyValue = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyPropertyValue"),
	      click: () => {
	        this._onCopyPropertyValue();
	      },
	      visible: false,
	    });
	    let menuitemCopySelector = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copySelector"),
	      click: () => {
	        this._onCopySelector();
	      },
	      visible: false,
	    });

	    this._clickedNodeInfo = this._getClickedNodeInfo();
	    if (this.isRuleView && this._clickedNodeInfo) {
	      switch (this._clickedNodeInfo.type) {
	        case overlays.VIEW_NODE_PROPERTY_TYPE :
	          menuitemCopyPropertyDeclaration.visible = true;
	          menuitemCopyPropertyName.visible = true;
	          break;
	        case overlays.VIEW_NODE_VALUE_TYPE :
	          menuitemCopyPropertyDeclaration.visible = true;
	          menuitemCopyPropertyValue.visible = true;
	          break;
	        case overlays.VIEW_NODE_SELECTOR_TYPE :
	          menuitemCopySelector.visible = true;
	          break;
	        case overlays.VIEW_NODE_LOCATION_TYPE :
	          menuitemCopyLocation.visible = true;
	          break;
	      }
	    }

	    menu.append(menuitemCopy);
	    menu.append(menuitemCopyLocation);
	    menu.append(menuitemCopyRule);
	    menu.append(menuitemCopyColor);
	    menu.append(menuitemCopyUrl);
	    menu.append(menuitemCopyImageDataUrl);
	    menu.append(menuitemCopyPropertyDeclaration);
	    menu.append(menuitemCopyPropertyName);
	    menu.append(menuitemCopyPropertyValue);
	    menu.append(menuitemCopySelector);

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    // Select All
	    let selectAllAccessKey = "styleinspector.contextmenu.selectAll.accessKey";
	    let menuitemSelectAll = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.selectAll"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(selectAllAccessKey),
	      click: () => {
	        this._onSelectAll();
	      },
	    });
	    menu.append(menuitemSelectAll);

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    // Add new rule
	    let addRuleAccessKey = "styleinspector.contextmenu.addNewRule.accessKey";
	    let menuitemAddRule = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.addNewRule"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(addRuleAccessKey),
	      click: () => {
	        this._onAddNewRule();
	      },
	      visible: this.isRuleView,
	      disabled: !this.isRuleView ||
	                this.inspector.selection.isAnonymousNode(),
	    });
	    menu.append(menuitemAddRule);

	    // Show MDN Docs
	    let mdnDocsAccessKey = "styleinspector.contextmenu.showMdnDocs.accessKey";
	    let menuitemShowMdnDocs = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.showMdnDocs"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(mdnDocsAccessKey),
	      click: () => {
	        this._onShowMdnDocs();
	      },
	      visible: (Services.prefs.getBoolPref(PREF_ENABLE_MDN_DOCS_TOOLTIP) &&
	                                                    this._isPropertyName()),
	    });
	    menu.append(menuitemShowMdnDocs);

	    // Show Original Sources
	    let sourcesAccessKey = "styleinspector.contextmenu.toggleOrigSources.accessKey";
	    let menuitemSources = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.toggleOrigSources"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(sourcesAccessKey),
	      click: () => {
	        this._onToggleOrigSources();
	      },
	      type: "checkbox",
	      checked: Services.prefs.getBoolPref(PREF_ORIG_SOURCES),
	    });
	    menu.append(menuitemSources);

	    menu.popup(screenX, screenY, this.inspector._toolbox);
	    return menu;
	  },

	  _hasTextSelected: function () {
	    let hasTextSelected;
	    let selection = this.styleWindow.getSelection();

	    let node = this._getClickedNode();
	    if (node.nodeName == "input" || node.nodeName == "textarea") {
	      let { selectionStart, selectionEnd } = node;
	      hasTextSelected = isFinite(selectionStart) && isFinite(selectionEnd)
	        && selectionStart !== selectionEnd;
	    } else {
	      hasTextSelected = selection.toString() && !selection.isCollapsed;
	    }

	    return hasTextSelected;
	  },

	  /**
	   * Get the type of the currently clicked node
	   */
	  _getClickedNodeInfo: function () {
	    let node = this._getClickedNode();
	    return this.view.getNodeInfo(node);
	  },

	  /**
	   * A helper that determines if the popup was opened with a click to a color
	   * value and saves the color to this._colorToCopy.
	   *
	   * @return {Boolean}
	   *         true if click on color opened the popup, false otherwise.
	   */
	  _isColorPopup: function () {
	    this._colorToCopy = "";

	    let container = this._getClickedNode();
	    if (!container) {
	      return false;
	    }

	    let isColorNode = el => el.dataset && "color" in el.dataset;

	    while (!isColorNode(container)) {
	      container = container.parentNode;
	      if (!container) {
	        return false;
	      }
	    }

	    this._colorToCopy = container.dataset.color;
	    return true;
	  },

	  _isPropertyName: function () {
	    let nodeInfo = this._getClickedNodeInfo();
	    if (!nodeInfo) {
	      return false;
	    }
	    return nodeInfo.type == overlays.VIEW_NODE_PROPERTY_TYPE;
	  },

	  /**
	   * Check if the current node (clicked node) is an image URL
	   *
	   * @return {Boolean} true if the node is an image url
	   */
	  _isImageUrl: function () {
	    let nodeInfo = this._getClickedNodeInfo();
	    if (!nodeInfo) {
	      return false;
	    }
	    return nodeInfo.type == overlays.VIEW_NODE_IMAGE_URL_TYPE;
	  },

	  /**
	   * Get the DOM Node container for the current popupNode.
	   * If popupNode is a textNode, return the parent node, otherwise return
	   * popupNode itself.
	   *
	   * @return {DOMNode}
	   */
	  _getClickedNode: function () {
	    let container = null;
	    let node = this.styleDocument.popupNode;

	    if (node) {
	      let isTextNode = node.nodeType == node.TEXT_NODE;
	      container = isTextNode ? node.parentElement : node;
	    }

	    return container;
	  },

	  /**
	   * Select all text.
	   */
	  _onSelectAll: function () {
	    let selection = this.styleWindow.getSelection();
	    selection.selectAllChildren(this.view.element);
	  },

	  /**
	   * Copy the most recently selected color value to clipboard.
	   */
	  _onCopy: function () {
	    this.view.copySelection(this.styleDocument.popupNode);
	  },

	  /**
	   * Copy the most recently selected color value to clipboard.
	   */
	  _onCopyColor: function () {
	    clipboardHelper.copyString(this._colorToCopy);
	  },

	  /*
	   * Retrieve the url for the selected image and copy it to the clipboard
	   */
	  _onCopyUrl: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value.url);
	  },

	  /**
	   * Retrieve the image data for the selected image url and copy it to the
	   * clipboard
	   */
	  _onCopyImageDataUrl: Task.async(function* () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    let message;
	    try {
	      let inspectorFront = this.inspector.inspector;
	      let imageUrl = this._clickedNodeInfo.value.url;
	      let data = yield inspectorFront.getImageDataFromURL(imageUrl);
	      message = yield data.data.string();
	    } catch (e) {
	      message =
	        STYLE_INSPECTOR_L10N.getStr("styleinspector.copyImageDataUrlError");
	    }

	    clipboardHelper.copyString(message);
	  }),

	  /**
	   *  Show docs from MDN for a CSS property.
	   */
	  _onShowMdnDocs: function () {
	    let cssPropertyName = this.styleDocument.popupNode.textContent;
	    let anchor = this.styleDocument.popupNode.parentNode;
	    let cssDocsTooltip = this.view.tooltips.cssDocs;
	    cssDocsTooltip.show(anchor, cssPropertyName);
	  },

	  /**
	   * Add a new rule to the current element.
	   */
	  _onAddNewRule: function () {
	    this.view._onAddRule();
	  },

	  /**
	   * Copy the rule source location of the current clicked node.
	   */
	  _onCopyLocation: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value);
	  },

	  /**
	   * Copy the rule property declaration of the current clicked node.
	   */
	  _onCopyPropertyDeclaration: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    let textProp = this._clickedNodeInfo.value.textProperty;
	    clipboardHelper.copyString(textProp.stringifyProperty());
	  },

	  /**
	   * Copy the rule property name of the current clicked node.
	   */
	  _onCopyPropertyName: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value.property);
	  },

	  /**
	   * Copy the rule property value of the current clicked node.
	   */
	  _onCopyPropertyValue: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value.value);
	  },

	  /**
	   * Copy the rule of the current clicked node.
	   */
	  _onCopyRule: function () {
	    let ruleEditor =
	      this.styleDocument.popupNode.parentNode.offsetParent._ruleEditor;
	    let rule = ruleEditor.rule;
	    clipboardHelper.copyString(rule.stringifyRule());
	  },

	  /**
	   * Copy the rule selector of the current clicked node.
	   */
	  _onCopySelector: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value);
	  },

	  /**
	   *  Toggle the original sources pref.
	   */
	  _onToggleOrigSources: function () {
	    let isEnabled = Services.prefs.getBoolPref(PREF_ORIG_SOURCES);
	    Services.prefs.setBoolPref(PREF_ORIG_SOURCES, !isEnabled);
	  },

	  destroy: function () {
	    this.popupNode = null;
	    this.styleDocument.popupNode = null;
	    this.view = null;
	    this.inspector = null;
	    this.styleDocument = null;
	    this.styleWindow = null;
	  }
	};


/***/ },
/* 158 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Helpers for clipboard handling.

	/* globals document */

	"use strict";

	function copyString(string) {
	  let doCopy = function (e) {
	    e.clipboardData.setData("text/plain", string);
	    e.preventDefault();
	  };

	  document.addEventListener("copy", doCopy);
	  document.execCommand("copy", false, null);
	  document.removeEventListener("copy", doCopy);
	}

	function getCurrentFlavors() {
	  // See bug 1295692.
	  return [];
	}

	function getData() {
	  // See bug 1295692.
	  return null;
	}

	exports.copyString = copyString;
	exports.getCurrentFlavors = getCurrentFlavors;
	exports.getData = getData;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const HTML_NS = "http://www.w3.org/1999/xhtml";
	const Services = __webpack_require__(1);
	const {gDevTools} = __webpack_require__(133);
	const {HTMLTooltip} = __webpack_require__(137);
	const EventEmitter = __webpack_require__(6);

	let itemIdCounter = 0;
	/**
	 * Autocomplete popup UI implementation.
	 *
	 * @constructor
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox required to instanciate the HTMLTooltip.
	 * @param {Object} options
	 *        An object consiting any of the following options:
	 *        - listId {String} The id for the list <LI> element.
	 *        - position {String} The position for the tooltip ("top" or "bottom").
	 *        - theme {String} String related to the theme of the popup
	 *        - autoSelect {Boolean} Boolean to allow the first entry of the popup
	 *          panel to be automatically selected when the popup shows.
	 *        - onSelect {String} Callback called when the selected index is updated.
	 *        - onClick {String} Callback called when the autocomplete popup receives a click
	 *          event. The selectedIndex will already be updated if need be.
	 */
	function AutocompletePopup(toolbox, options = {}) {
	  EventEmitter.decorate(this);

	  this._document = toolbox.doc;

	  this.autoSelect = options.autoSelect || false;
	  this.position = options.position || "bottom";
	  let theme = options.theme || "dark";

	  this.onSelectCallback = options.onSelect;
	  this.onClickCallback = options.onClick;

	  // If theme is auto, use the devtools.theme pref
	  if (theme === "auto") {
	    theme = Services.prefs.getCharPref("devtools.theme");
	    this.autoThemeEnabled = true;
	    // Setup theme change listener.
	    this._handleThemeChange = this._handleThemeChange.bind(this);
	    gDevTools.on("pref-changed", this._handleThemeChange);
	  }

	  // Create HTMLTooltip instance
	  this._tooltip = new HTMLTooltip(toolbox);
	  this._tooltip.panel.classList.add(
	    "devtools-autocomplete-popup",
	    "devtools-monospace",
	    theme + "-theme");
	  // Stop this appearing as an alert to accessibility.
	  this._tooltip.panel.setAttribute("role", "presentation");

	  this._list = this._document.createElementNS(HTML_NS, "ul");
	  this._list.setAttribute("flex", "1");

	  // The list clone will be inserted in the same document as the anchor, and will receive
	  // a copy of the main list innerHTML to allow screen readers to access the list.
	  this._listClone = this._document.createElementNS(HTML_NS, "ul");
	  this._listClone.className = "devtools-autocomplete-list-aria-clone";

	  if (options.listId) {
	    this._list.setAttribute("id", options.listId);
	  }
	  this._list.className = "devtools-autocomplete-listbox " + theme + "-theme";

	  this._tooltip.setContent(this._list);

	  this.onClick = this.onClick.bind(this);
	  this._list.addEventListener("click", this.onClick, false);

	  // Array of raw autocomplete items
	  this.items = [];
	  // Map of autocompleteItem to HTMLElement
	  this.elements = new WeakMap();

	  this.selectedIndex = -1;
	}
	exports.AutocompletePopup = AutocompletePopup;

	AutocompletePopup.prototype = {
	  _document: null,
	  _tooltip: null,
	  _list: null,

	  onSelect: function (e) {
	    if (this.onSelectCallback) {
	      this.onSelectCallback(e);
	    }
	  },

	  onClick: function (e) {
	    let item = e.target.closest(".autocomplete-item");
	    if (item && typeof item.dataset.index !== "undefined") {
	      this.selectedIndex = parseInt(item.dataset.index, 10);
	    }

	    this.emit("popup-click");
	    if (this.onClickCallback) {
	      this.onClickCallback(e);
	    }
	  },

	  /**
	   * Open the autocomplete popup panel.
	   *
	   * @param {nsIDOMNode} anchor
	   *        Optional node to anchor the panel to.
	   * @param {Number} xOffset
	   *        Horizontal offset in pixels from the left of the node to the left
	   *        of the popup.
	   * @param {Number} yOffset
	   *        Vertical offset in pixels from the top of the node to the starting
	   *        of the popup.
	   * @param {Number} index
	   *        The position of item to select.
	   */
	  openPopup: function (anchor, xOffset = 0, yOffset = 0, index) {
	    this.__maxLabelLength = -1;
	    this._updateSize();

	    // Retrieve the anchor's document active element to add accessibility metadata.
	    this._activeElement = anchor.ownerDocument.activeElement;

	    this._tooltip.show(anchor, {
	      x: xOffset,
	      y: yOffset,
	      position: this.position,
	    });

	    this._tooltip.once("shown", () => {
	      if (this.autoSelect) {
	        this.selectItemAtIndex(index);
	      }

	      this.emit("popup-opened");
	    });
	  },

	  /**
	   * Select item at the provided index.
	   *
	   * @param {Number} index
	   *        The position of the item to select.
	   */
	  selectItemAtIndex: function (index) {
	    if (typeof index !== "number") {
	      // If no index was provided, select the item closest to the input.
	      let isAboveInput = this.position === "top";
	      index = isAboveInput ? this.itemCount - 1 : 0;
	    }
	    this.selectedIndex = index;
	  },

	  /**
	   * Hide the autocomplete popup panel.
	   */
	  hidePopup: function () {
	    this._tooltip.once("hidden", () => {
	      this.emit("popup-closed");
	    });

	    this._clearActiveDescendant();
	    this._activeElement = null;
	    this._tooltip.hide();
	  },

	  /**
	   * Check if the autocomplete popup is open.
	   */
	  get isOpen() {
	    return this._tooltip && this._tooltip.isVisible();
	  },

	  /**
	   * Destroy the object instance. Please note that the panel DOM elements remain
	   * in the DOM, because they might still be in use by other instances of the
	   * same code. It is the responsability of the client code to perform DOM
	   * cleanup.
	   */
	  destroy: function () {
	    if (this.isOpen) {
	      this.hidePopup();
	    }

	    this._list.removeEventListener("click", this.onClick, false);

	    if (this.autoThemeEnabled) {
	      gDevTools.off("pref-changed", this._handleThemeChange);
	    }

	    this._list.remove();
	    this._listClone.remove();
	    this._tooltip.destroy();
	    this._document = null;
	    this._list = null;
	    this._tooltip = null;
	  },

	  /**
	   * Get the autocomplete items array.
	   *
	   * @param {Number} index
	   *        The index of the item what is wanted.
	   *
	   * @return {Object} The autocomplete item at index index.
	   */
	  getItemAtIndex: function (index) {
	    return this.items[index];
	  },

	  /**
	   * Get the autocomplete items array.
	   *
	   * @return {Array} The array of autocomplete items.
	   */
	  getItems: function () {
	    // Return a copy of the array to avoid side effects from the caller code.
	    return this.items.slice(0);
	  },

	  /**
	   * Set the autocomplete items list, in one go.
	   *
	   * @param {Array} items
	   *        The list of items you want displayed in the popup list.
	   * @param {Number} index
	   *        The position of the item to select.
	   */
	  setItems: function (items, index) {
	    this.clearItems();
	    items.forEach(this.appendItem, this);

	    if (this.isOpen && this.autoSelect) {
	      this.selectItemAtIndex(index);
	    }
	  },

	  __maxLabelLength: -1,

	  get _maxLabelLength() {
	    if (this.__maxLabelLength !== -1) {
	      return this.__maxLabelLength;
	    }

	    let max = 0;
	    for (let {label, count} of this.items) {
	      if (count) {
	        label += count + "";
	      }
	      max = Math.max(label.length, max);
	    }

	    this.__maxLabelLength = max;
	    return this.__maxLabelLength;
	  },

	  /**
	   * Update the panel size to fit the content.
	   */
	  _updateSize: function () {
	    if (!this._tooltip) {
	      return;
	    }

	    this._list.style.width = (this._maxLabelLength + 3) + "ch";
	    let selectedItem = this.selectedItem;
	    if (selectedItem) {
	      this._scrollElementIntoViewIfNeeded(this.elements.get(selectedItem));
	    }
	  },

	  _scrollElementIntoViewIfNeeded: function (element) {
	    let quads = element.getBoxQuads({relativeTo: this._tooltip.panel});
	    if (!quads || !quads[0]) {
	      return;
	    }

	    let {top, height} = quads[0].bounds;
	    let containerHeight = this._tooltip.panel.getBoundingClientRect().height;
	    if (top < 0) {
	      // Element is above container.
	      element.scrollIntoView(true);
	    } else if ((top + height) > containerHeight) {
	      // Element is beloew container.
	      element.scrollIntoView(false);
	    }
	  },

	  /**
	   * Clear all the items from the autocomplete list.
	   */
	  clearItems: function () {
	    // Reset the selectedIndex to -1 before clearing the list
	    this.selectedIndex = -1;
	    this._list.innerHTML = "";
	    this.__maxLabelLength = -1;
	    this.items = [];
	    this.elements = new WeakMap();
	  },

	  /**
	   * Getter for the index of the selected item.
	   *
	   * @type {Number}
	   */
	  get selectedIndex() {
	    return this._selectedIndex;
	  },

	  /**
	   * Setter for the selected index.
	   *
	   * @param {Number} index
	   *        The number (index) of the item you want to select in the list.
	   */
	  set selectedIndex(index) {
	    let previousSelected = this._list.querySelector(".autocomplete-selected");
	    if (previousSelected) {
	      previousSelected.classList.remove("autocomplete-selected");
	    }

	    let item = this.items[index];
	    if (this.isOpen && item) {
	      let element = this.elements.get(item);

	      element.classList.add("autocomplete-selected");
	      this._scrollElementIntoViewIfNeeded(element);
	      this._setActiveDescendant(element.id);
	    } else {
	      this._clearActiveDescendant();
	    }
	    this._selectedIndex = index;

	    if (this.isOpen && item && this.onSelectCallback) {
	      // Call the user-defined select callback if defined.
	      this.onSelectCallback();
	    }
	  },

	  /**
	   * Getter for the selected item.
	   * @type Object
	   */
	  get selectedItem() {
	    return this.items[this._selectedIndex];
	  },

	  /**
	   * Setter for the selected item.
	   *
	   * @param {Object} item
	   *        The object you want selected in the list.
	   */
	  set selectedItem(item) {
	    let index = this.items.indexOf(item);
	    if (index !== -1 && this.isOpen) {
	      this.selectedIndex = index;
	    }
	  },

	  /**
	   * Update the aria-activedescendant attribute on the current active element for
	   * accessibility.
	   *
	   * @param {String} id
	   *        The id (as in DOM id) of the currently selected autocomplete suggestion
	   */
	  _setActiveDescendant: function (id) {
	    if (!this._activeElement) {
	      return;
	    }

	    // Make sure the list clone is in the same document as the anchor.
	    let anchorDoc = this._activeElement.ownerDocument;
	    if (!this._listClone.parentNode || this._listClone.ownerDocument !== anchorDoc) {
	      anchorDoc.documentElement.appendChild(this._listClone);
	    }

	    // Update the clone content to match the current list content.
	    this._listClone.innerHTML = this._list.innerHTML;

	    this._activeElement.setAttribute("aria-activedescendant", id);
	  },

	  /**
	   * Clear the aria-activedescendant attribute on the current active element.
	   */
	  _clearActiveDescendant: function () {
	    if (!this._activeElement) {
	      return;
	    }

	    this._activeElement.removeAttribute("aria-activedescendant");
	  },

	  /**
	   * Append an item into the autocomplete list.
	   *
	   * @param {Object} item
	   *        The item you want appended to the list.
	   *        The item object can have the following properties:
	   *        - label {String} Property which is used as the displayed value.
	   *        - preLabel {String} [Optional] The String that will be displayed
	   *                   before the label indicating that this is the already
	   *                   present text in the input box, and label is the text
	   *                   that will be auto completed. When this property is
	   *                   present, |preLabel.length| starting characters will be
	   *                   removed from label.
	   *        - count {Number} [Optional] The number to represent the count of
	   *                autocompleted label.
	   */
	  appendItem: function (item) {
	    let listItem = this._document.createElementNS(HTML_NS, "li");
	    // Items must have an id for accessibility.
	    listItem.setAttribute("id", "autocomplete-item-" + itemIdCounter++);
	    listItem.className = "autocomplete-item";
	    listItem.setAttribute("data-index", this.items.length);
	    if (this.direction) {
	      listItem.setAttribute("dir", this.direction);
	    }
	    let label = this._document.createElementNS(HTML_NS, "span");
	    label.textContent = item.label;
	    label.className = "autocomplete-value";
	    if (item.preLabel) {
	      let preDesc = this._document.createElementNS(HTML_NS, "span");
	      preDesc.textContent = item.preLabel;
	      preDesc.className = "initial-value";
	      listItem.appendChild(preDesc);
	      label.textContent = item.label.slice(item.preLabel.length);
	    }
	    listItem.appendChild(label);
	    if (item.count && item.count > 1) {
	      let countDesc = this._document.createElementNS(HTML_NS, "span");
	      countDesc.textContent = item.count;
	      countDesc.setAttribute("flex", "1");
	      countDesc.className = "autocomplete-count";
	      listItem.appendChild(countDesc);
	    }

	    this._list.appendChild(listItem);
	    this.items.push(item);
	    this.elements.set(item, listItem);
	  },

	  /**
	   * Remove an item from the popup list.
	   *
	   * @param {Object} item
	   *        The item you want removed.
	   */
	  removeItem: function (item) {
	    if (!this.items.includes(item)) {
	      return;
	    }

	    let itemIndex = this.items.indexOf(item);
	    let selectedIndex = this.selectedIndex;

	    // Remove autocomplete item.
	    this.items.splice(itemIndex, 1);

	    // Remove corresponding DOM element from the elements WeakMap and from the DOM.
	    let elementToRemove = this.elements.get(item);
	    this.elements.delete(elementToRemove);
	    elementToRemove.remove();

	    if (itemIndex <= selectedIndex) {
	      // If the removed item index was before or equal to the selected index, shift the
	      // selected index by 1.
	      this.selectedIndex = Math.max(0, selectedIndex - 1);
	    }
	  },

	  /**
	   * Getter for the number of items in the popup.
	   * @type {Number}
	   */
	  get itemCount() {
	    return this.items.length;
	  },

	  /**
	   * Getter for the height of each item in the list.
	   *
	   * @type {Number}
	   */
	  get _itemsPerPane() {
	    if (this.items.length) {
	      let listHeight = this._tooltip.panel.clientHeight;
	      let element = this.elements.get(this.items[0]);
	      let elementHeight = element.getBoundingClientRect().height;
	      return Math.floor(listHeight / elementHeight);
	    }
	    return 0;
	  },

	  /**
	   * Select the next item in the list.
	   *
	   * @return {Object}
	   *         The newly selected item object.
	   */
	  selectNextItem: function () {
	    if (this.selectedIndex < (this.items.length - 1)) {
	      this.selectedIndex++;
	    } else {
	      this.selectedIndex = 0;
	    }
	    return this.selectedItem;
	  },

	  /**
	   * Select the previous item in the list.
	   *
	   * @return {Object}
	   *         The newly-selected item object.
	   */
	  selectPreviousItem: function () {
	    if (this.selectedIndex > 0) {
	      this.selectedIndex--;
	    } else {
	      this.selectedIndex = this.items.length - 1;
	    }

	    return this.selectedItem;
	  },

	  /**
	   * Select the top-most item in the next page of items or
	   * the last item in the list.
	   *
	   * @return {Object}
	   *         The newly-selected item object.
	   */
	  selectNextPageItem: function () {
	    let nextPageIndex = this.selectedIndex + this._itemsPerPane + 1;
	    this.selectedIndex = Math.min(nextPageIndex, this.itemCount - 1);
	    return this.selectedItem;
	  },

	  /**
	   * Select the bottom-most item in the previous page of items,
	   * or the first item in the list.
	   *
	   * @return {Object}
	   *         The newly-selected item object.
	   */
	  selectPreviousPageItem: function () {
	    let prevPageIndex = this.selectedIndex - this._itemsPerPane - 1;
	    this.selectedIndex = Math.max(prevPageIndex, 0);
	    return this.selectedItem;
	  },

	  /**
	   * Manages theme switching for the popup based on the devtools.theme pref.
	   *
	   * @private
	   *
	   * @param {String} event
	   *        The name of the event. In this case, "pref-changed".
	   * @param {Object} data
	   *        An object passed by the emitter of the event. In this case, the
	   *        object consists of three properties:
	   *        - pref {String} The name of the preference that was modified.
	   *        - newValue {Object} The new value of the preference.
	   *        - oldValue {Object} The old value of the preference.
	   */
	  _handleThemeChange: function (event, data) {
	    if (data.pref === "devtools.theme") {
	      this._tooltip.panel.classList.toggle(data.oldValue + "-theme", false);
	      this._tooltip.panel.classList.toggle(data.newValue + "-theme", true);
	      this._list.classList.toggle(data.oldValue + "-theme", false);
	      this._list.classList.toggle(data.newValue + "-theme", true);
	    }
	  },

	  /**
	   * Used by tests.
	   */
	  get _panel() {
	    return this._tooltip.panel;
	  },

	  /**
	   * Used by tests.
	   */
	  get _window() {
	    return this._document.defaultView;
	  },
	};


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	'use strict';

	module.metadata = {
	  "stability": "experimental"
	};

	const { Ci } = __webpack_require__(11);
	const XUL = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';

	function eventTarget(frame) {
	  return getDocShell(frame).chromeEventHandler;
	}
	exports.eventTarget = eventTarget;

	function getDocShell(frame) {
	  let { frameLoader } = frame.QueryInterface(Ci.nsIFrameLoaderOwner);
	  return frameLoader && frameLoader.docShell;
	}
	exports.getDocShell = getDocShell;

	/**
	 * Creates a XUL `browser` element in a privileged document.
	 * @params {nsIDOMDocument} document
	 * @params {String} options.type
	 *    By default is 'content' for possible values see:
	 *    https://developer.mozilla.org/en/XUL/iframe#a-browser.type
	 * @params {String} options.uri
	 *    URI of the document to be loaded into created frame.
	 * @params {Boolean} options.remote
	 *    If `true` separate process will be used for this frame, also in such
	 *    case all the following options are ignored.
	 * @params {Boolean} options.allowAuth
	 *    Whether to allow auth dialogs. Defaults to `false`.
	 * @params {Boolean} options.allowJavascript
	 *    Whether to allow Javascript execution. Defaults to `false`.
	 * @params {Boolean} options.allowPlugins
	 *    Whether to allow plugin execution. Defaults to `false`.
	 */
	function create(target, options) {
	  target = target instanceof Ci.nsIDOMDocument ? target.documentElement :
	           target instanceof Ci.nsIDOMWindow ? target.document.documentElement :
	           target;
	  options = options || {};
	  let remote = options.remote || false;
	  let namespaceURI = options.namespaceURI || XUL;
	  let isXUL = namespaceURI === XUL;
	  let nodeName = isXUL && options.browser ? 'browser' : 'iframe';
	  let document = target.ownerDocument;

	  let frame = document.createElementNS(namespaceURI, nodeName);
	  // Type="content" is mandatory to enable stuff here:
	  // http://mxr.mozilla.org/mozilla-central/source/content/base/src/nsFrameLoader.cpp#1776
	  frame.setAttribute('type', options.type || 'content');
	  frame.setAttribute('src', options.uri || 'about:blank');

	  // Must set the remote attribute before attaching the frame to the document
	  if (remote && isXUL) {
	    // We remove XBL binding to avoid execution of code that is not going to
	    // work because browser has no docShell attribute in remote mode
	    // (for example)
	    frame.setAttribute('style', '-moz-binding: none;');
	    frame.setAttribute('remote', 'true');
	  }

	  target.appendChild(frame);

	  // Load in separate process if `options.remote` is `true`.
	  // http://mxr.mozilla.org/mozilla-central/source/content/base/src/nsFrameLoader.cpp#1347
	  if (remote && !isXUL) {
	    frame.QueryInterface(Ci.nsIMozBrowserFrame);
	    frame.createRemoteFrameLoader(null);
	  }

	  // If browser is remote it won't have a `docShell`.
	  if (!remote) {
	    let docShell = getDocShell(frame);
	    docShell.allowAuth = options.allowAuth || false;
	    docShell.allowJavascript = options.allowJavascript || false;
	    docShell.allowPlugins = options.allowPlugins || false;
	    docShell.allowWindowControl = options.allowWindowControl || false;
	  }

	  return frame;
	}
	exports.create = create;

	function swapFrameLoaders(from, to) {
	  return from.QueryInterface(Ci.nsIFrameLoaderOwner).swapFrameLoaders(to);
	}
	exports.swapFrameLoaders = swapFrameLoaders;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)(module)))

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {Task} = __webpack_require__(17);
	const {InplaceEditor, editableItem} =
	      __webpack_require__(154);
	const {ReflowFront} = __webpack_require__(162);
	const {LocalizationHelper} = __webpack_require__(39);
	const {getCssProperties} = __webpack_require__(18);

	const STRINGS_URI = "devtools/locale/shared.properties";
	const STRINGS_INSPECTOR = "devtools-shared/locale/styleinspector.properties";
	const SHARED_L10N = new LocalizationHelper(STRINGS_URI);
	const INSPECTOR_L10N = new LocalizationHelper(STRINGS_INSPECTOR);
	const NUMERIC = /^-?[\d\.]+$/;
	const LONG_TEXT_ROTATE_LIMIT = 3;

	/**
	 * An instance of EditingSession tracks changes that have been made during the
	 * modification of box model values. All of these changes can be reverted by
	 * calling revert. The main parameter is the LayoutView that created it.
	 *
	 * @param inspector The inspector panel.
	 * @param doc       A DOM document that can be used to test style rules.
	 * @param rules     An array of the style rules defined for the node being
	 *                  edited. These should be in order of priority, least
	 *                  important first.
	 */
	function EditingSession({inspector, doc, elementRules}) {
	  this._doc = doc;
	  this._rules = elementRules;
	  this._modifications = new Map();
	  this._cssProperties = getCssProperties(inspector.toolbox);
	}

	EditingSession.prototype = {
	  /**
	   * Gets the value of a single property from the CSS rule.
	   *
	   * @param {StyleRuleFront} rule The CSS rule.
	   * @param {String} property The name of the property.
	   * @return {String} The value.
	   */
	  getPropertyFromRule: function (rule, property) {
	    // Use the parsed declarations in the StyleRuleFront object if available.
	    let index = this.getPropertyIndex(property, rule);
	    if (index !== -1) {
	      return rule.declarations[index].value;
	    }

	    // Fallback to parsing the cssText locally otherwise.
	    let dummyStyle = this._element.style;
	    dummyStyle.cssText = rule.cssText;
	    return dummyStyle.getPropertyValue(property);
	  },

	  /**
	   * Returns the current value for a property as a string or the empty string if
	   * no style rules affect the property.
	   *
	   * @param property  The name of the property as a string
	   */
	  getProperty: function (property) {
	    // Create a hidden element for getPropertyFromRule to use
	    let div = this._doc.createElement("div");
	    div.setAttribute("style", "display: none");
	    this._doc.getElementById("sidebar-panel-computedview").appendChild(div);
	    this._element = this._doc.createElement("p");
	    div.appendChild(this._element);

	    // As the rules are in order of priority we can just iterate until we find
	    // the first that defines a value for the property and return that.
	    for (let rule of this._rules) {
	      let value = this.getPropertyFromRule(rule, property);
	      if (value !== "") {
	        div.remove();
	        return value;
	      }
	    }
	    div.remove();
	    return "";
	  },

	  /**
	   * Get the index of a given css property name in a CSS rule.
	   * Or -1, if there are no properties in the rule yet.
	   * @param {String} name The property name.
	   * @param {StyleRuleFront} rule Optional, defaults to the element style rule.
	   * @return {Number} The property index in the rule.
	   */
	  getPropertyIndex: function (name, rule = this._rules[0]) {
	    let elementStyleRule = this._rules[0];
	    if (!elementStyleRule.declarations.length) {
	      return -1;
	    }

	    return elementStyleRule.declarations.findIndex(p => p.name === name);
	  },

	  /**
	   * Sets a number of properties on the node.
	   * @param properties  An array of properties, each is an object with name and
	   *                    value properties. If the value is "" then the property
	   *                    is removed.
	   * @return {Promise} Resolves when the modifications are complete.
	   */
	  setProperties: Task.async(function* (properties) {
	    for (let property of properties) {
	      // Get a RuleModificationList or RuleRewriter helper object from the
	      // StyleRuleActor to make changes to CSS properties.
	      // Note that RuleRewriter doesn't support modifying several properties at
	      // once, so we do this in a sequence here.
	      let modifications = this._rules[0].startModifyingProperties(
	        this._cssProperties);

	      // Remember the property so it can be reverted.
	      if (!this._modifications.has(property.name)) {
	        this._modifications.set(property.name,
	          this.getPropertyFromRule(this._rules[0], property.name));
	      }

	      // Find the index of the property to be changed, or get the next index to
	      // insert the new property at.
	      let index = this.getPropertyIndex(property.name);
	      if (index === -1) {
	        index = this._rules[0].declarations.length;
	      }

	      if (property.value == "") {
	        modifications.removeProperty(index, property.name);
	      } else {
	        modifications.setProperty(index, property.name, property.value, "");
	      }

	      yield modifications.apply();
	    }
	  }),

	  /**
	   * Reverts all of the property changes made by this instance.
	   * @return {Promise} Resolves when all properties have been reverted.
	   */
	  revert: Task.async(function* () {
	    // Revert each property that we modified previously, one by one. See
	    // setProperties for information about why.
	    for (let [property, value] of this._modifications) {
	      let modifications = this._rules[0].startModifyingProperties(
	        this._cssProperties);

	      // Find the index of the property to be reverted.
	      let index = this.getPropertyIndex(property);

	      if (value != "") {
	        // If the property doesn't exist anymore, insert at the beginning of the
	        // rule.
	        if (index === -1) {
	          index = 0;
	        }
	        modifications.setProperty(index, property, value, "");
	      } else {
	        // If the property doesn't exist anymore, no need to remove it. It had
	        // not been added after all.
	        if (index === -1) {
	          continue;
	        }
	        modifications.removeProperty(index, property);
	      }

	      yield modifications.apply();
	    }
	  }),

	  destroy: function () {
	    this._doc = null;
	    this._rules = null;
	    this._modifications.clear();
	  }
	};

	/**
	 * The layout-view panel
	 * @param {InspectorPanel} inspector
	 *        An instance of the inspector-panel currently loaded in the toolbox
	 * @param {Document} document
	 *        The document that will contain the layout view.
	 */
	function LayoutView(inspector, document) {
	  this.inspector = inspector;
	  this.doc = document;
	  this.wrapper = this.doc.getElementById("layout-wrapper");
	  this.container = this.doc.getElementById("layout-container");
	  this.expander = this.doc.getElementById("layout-expander");
	  this.sizeLabel = this.doc.querySelector(".layout-size > span");
	  this.sizeHeadingLabel = this.doc.getElementById("layout-element-size");
	  this._geometryEditorHighlighter = null;
	  this._cssProperties = getCssProperties(inspector.toolbox);

	  this.init();
	}

	LayoutView.prototype = {
	  init: function () {
	    this.update = this.update.bind(this);

	    this.onNewSelection = this.onNewSelection.bind(this);
	    this.inspector.selection.on("new-node-front", this.onNewSelection);

	    this.onNewNode = this.onNewNode.bind(this);
	    this.inspector.sidebar.on("computedview-selected", this.onNewNode);

	    this.onSidebarSelect = this.onSidebarSelect.bind(this);
	    this.inspector.sidebar.on("select", this.onSidebarSelect);

	    this.onToggleExpander = this.onToggleExpander.bind(this);
	    this.expander.addEventListener("click", this.onToggleExpander);
	    let header = this.doc.getElementById("layout-header");
	    header.addEventListener("dblclick", this.onToggleExpander);

	    this.onFilterComputedView = this.onFilterComputedView.bind(this);
	    this.inspector.on("computed-view-filtered",
	      this.onFilterComputedView);

	    this.onPickerStarted = this.onPickerStarted.bind(this);
	    this.onMarkupViewLeave = this.onMarkupViewLeave.bind(this);
	    this.onMarkupViewNodeHover = this.onMarkupViewNodeHover.bind(this);
	    this.onWillNavigate = this.onWillNavigate.bind(this);

	    this.initBoxModelHighlighter();

	    // Store for the different dimensions of the node.
	    // 'selector' refers to the element that holds the value in view.xhtml;
	    // 'property' is what we are measuring;
	    // 'value' is the computed dimension, computed in update().
	    this.map = {
	      position: {
	        selector: "#layout-element-position",
	        property: "position",
	        value: undefined
	      },
	      marginTop: {
	        selector: ".layout-margin.layout-top > span",
	        property: "margin-top",
	        value: undefined
	      },
	      marginBottom: {
	        selector: ".layout-margin.layout-bottom > span",
	        property: "margin-bottom",
	        value: undefined
	      },
	      marginLeft: {
	        selector: ".layout-margin.layout-left > span",
	        property: "margin-left",
	        value: undefined
	      },
	      marginRight: {
	        selector: ".layout-margin.layout-right > span",
	        property: "margin-right",
	        value: undefined
	      },
	      paddingTop: {
	        selector: ".layout-padding.layout-top > span",
	        property: "padding-top",
	        value: undefined
	      },
	      paddingBottom: {
	        selector: ".layout-padding.layout-bottom > span",
	        property: "padding-bottom",
	        value: undefined
	      },
	      paddingLeft: {
	        selector: ".layout-padding.layout-left > span",
	        property: "padding-left",
	        value: undefined
	      },
	      paddingRight: {
	        selector: ".layout-padding.layout-right > span",
	        property: "padding-right",
	        value: undefined
	      },
	      borderTop: {
	        selector: ".layout-border.layout-top > span",
	        property: "border-top-width",
	        value: undefined
	      },
	      borderBottom: {
	        selector: ".layout-border.layout-bottom > span",
	        property: "border-bottom-width",
	        value: undefined
	      },
	      borderLeft: {
	        selector: ".layout-border.layout-left > span",
	        property: "border-left-width",
	        value: undefined
	      },
	      borderRight: {
	        selector: ".layout-border.layout-right > span",
	        property: "border-right-width",
	        value: undefined
	      }
	    };

	    // Make each element the dimensions editable
	    for (let i in this.map) {
	      if (i == "position") {
	        continue;
	      }

	      let dimension = this.map[i];
	      editableItem({
	        element: this.doc.querySelector(dimension.selector)
	      }, (element, event) => {
	        this.initEditor(element, event, dimension);
	      });
	    }

	    this.onNewNode();

	    let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	    this.onGeometryButtonClick = this.onGeometryButtonClick.bind(this);
	    nodeGeometry.addEventListener("click", this.onGeometryButtonClick);
	  },

	  initBoxModelHighlighter: function () {
	    let highlightElts = this.doc.querySelectorAll("#layout-container *[title]");
	    this.onHighlightMouseOver = this.onHighlightMouseOver.bind(this);
	    this.onHighlightMouseOut = this.onHighlightMouseOut.bind(this);

	    for (let element of highlightElts) {
	      element.addEventListener("mouseover", this.onHighlightMouseOver, true);
	      element.addEventListener("mouseout", this.onHighlightMouseOut, true);
	    }
	  },

	  /**
	   * Start listening to reflows in the current tab.
	   */
	  trackReflows: function () {
	    if (!this.reflowFront) {
	      let toolbox = this.inspector.toolbox;
	      if (toolbox.target.form.reflowActor) {
	        this.reflowFront = ReflowFront(toolbox.target.client,
	                                       toolbox.target.form);
	      } else {
	        return;
	      }
	    }

	    this.reflowFront.on("reflows", this.update);
	    this.reflowFront.start();
	  },

	  /**
	   * Stop listening to reflows in the current tab.
	   */
	  untrackReflows: function () {
	    if (!this.reflowFront) {
	      return;
	    }

	    this.reflowFront.off("reflows", this.update);
	    this.reflowFront.stop();
	  },

	  /**
	   * Called when the user clicks on one of the editable values in the layoutview
	   */
	  initEditor: function (element, event, dimension) {
	    let { property } = dimension;
	    let session = new EditingSession(this);
	    let initialValue = session.getProperty(property);

	    let editor = new InplaceEditor({
	      element: element,
	      initial: initialValue,
	      contentType: InplaceEditor.CONTENT_TYPES.CSS_VALUE,
	      property: {
	        name: dimension.property
	      },
	      start: self => {
	        self.elt.parentNode.classList.add("layout-editing");
	      },

	      change: value => {
	        if (NUMERIC.test(value)) {
	          value += "px";
	        }

	        let properties = [
	          { name: property, value: value }
	        ];

	        if (property.substring(0, 7) == "border-") {
	          let bprop = property.substring(0, property.length - 5) + "style";
	          let style = session.getProperty(bprop);
	          if (!style || style == "none" || style == "hidden") {
	            properties.push({ name: bprop, value: "solid" });
	          }
	        }

	        session.setProperties(properties).catch(e => console.error(e));
	      },

	      done: (value, commit) => {
	        editor.elt.parentNode.classList.remove("layout-editing");
	        if (!commit) {
	          session.revert().then(() => {
	            session.destroy();
	          }, e => console.error(e));
	        }
	      },
	      cssProperties: this._cssProperties
	    }, event);
	  },

	  /**
	   * Is the layoutview visible in the sidebar.
	   * @return {Boolean}
	   */
	  isViewVisible: function () {
	    return this.inspector &&
	           this.inspector.sidebar.getCurrentTabID() == "computedview";
	  },

	  /**
	   * Is the layoutview visible in the sidebar and is the current node valid to
	   * be displayed in the view.
	   * @return {Boolean}
	   */
	  isViewVisibleAndNodeValid: function () {
	    return this.isViewVisible() &&
	           this.inspector.selection.isConnected() &&
	           this.inspector.selection.isElementNode();
	  },

	  /**
	   * Destroy the nodes. Remove listeners.
	   */
	  destroy: function () {
	    let highlightElts = this.doc.querySelectorAll("#layout-container *[title]");

	    for (let element of highlightElts) {
	      element.removeEventListener("mouseover", this.onHighlightMouseOver, true);
	      element.removeEventListener("mouseout", this.onHighlightMouseOut, true);
	    }

	    this.expander.removeEventListener("click", this.onToggleExpander);
	    let header = this.doc.getElementById("layout-header");
	    header.removeEventListener("dblclick", this.onToggleExpander);

	    let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	    nodeGeometry.removeEventListener("click", this.onGeometryButtonClick);

	    this.inspector.off("picker-started", this.onPickerStarted);

	    // Inspector Panel will destroy `markup` object on "will-navigate" event,
	    // therefore we have to check if it's still available in case LayoutView
	    // is destroyed immediately after.
	    if (this.inspector.markup) {
	      this.inspector.markup.off("leave", this.onMarkupViewLeave);
	      this.inspector.markup.off("node-hover", this.onMarkupViewNodeHover);
	    }

	    this.inspector.sidebar.off("computedview-selected", this.onNewNode);
	    this.inspector.selection.off("new-node-front", this.onNewSelection);
	    this.inspector.sidebar.off("select", this.onSidebarSelect);
	    this.inspector._target.off("will-navigate", this.onWillNavigate);
	    this.inspector.off("computed-view-filtered", this.onFilterComputedView);

	    this.inspector = null;
	    this.doc = null;
	    this.wrapper = null;
	    this.container = null;
	    this.expander = null;
	    this.sizeLabel = null;
	    this.sizeHeadingLabel = null;

	    if (this.reflowFront) {
	      this.untrackReflows();
	      this.reflowFront.destroy();
	      this.reflowFront = null;
	    }
	  },

	  onSidebarSelect: function (e, sidebar) {
	    this.setActive(sidebar === "computedview");
	  },

	  /**
	   * Selection 'new-node-front' event handler.
	   */
	  onNewSelection: function () {
	    let done = this.inspector.updating("computed-view");
	    this.onNewNode()
	      .then(() => this.hideGeometryEditor())
	      .then(done, (err) => {
	        console.error(err);
	        done();
	      }).catch(console.error);
	  },

	  /**
	   * @return a promise that resolves when the view has been updated
	   */
	  onNewNode: function () {
	    this.setActive(this.isViewVisibleAndNodeValid());
	    return this.update();
	  },

	  onHighlightMouseOver: function (e) {
	    let region = e.target.getAttribute("data-box");
	    if (!region) {
	      return;
	    }

	    this.showBoxModel({
	      region,
	      showOnly: region,
	      onlyRegionArea: true
	    });
	  },

	  onHighlightMouseOut: function () {
	    this.hideBoxModel();
	  },

	  onGeometryButtonClick: function ({target}) {
	    if (target.hasAttribute("checked")) {
	      target.removeAttribute("checked");
	      this.hideGeometryEditor();
	    } else {
	      target.setAttribute("checked", "true");
	      this.showGeometryEditor();
	    }
	  },

	  onPickerStarted: function () {
	    this.hideGeometryEditor();
	  },

	  onToggleExpander: function () {
	    let isOpen = this.expander.hasAttribute("open");

	    if (isOpen) {
	      this.container.hidden = true;
	      this.expander.removeAttribute("open");
	    } else {
	      this.container.hidden = false;
	      this.expander.setAttribute("open", "");
	    }
	  },

	  onMarkupViewLeave: function () {
	    this.showGeometryEditor(true);
	  },

	  onMarkupViewNodeHover: function () {
	    this.hideGeometryEditor(false);
	  },

	  onWillNavigate: function () {
	    this._geometryEditorHighlighter.release().catch(console.error);
	    this._geometryEditorHighlighter = null;
	  },

	  /**
	   * Event handler that responds to the computed view being filtered
	   * @param {String} reason
	   * @param {Boolean} hidden
	   *        Whether or not to hide the layout wrapper
	   */
	  onFilterComputedView: function (reason, hidden) {
	    this.wrapper.hidden = hidden;
	  },

	  /**
	   * Stop tracking reflows and hide all values when no node is selected or the
	   * layout-view is hidden, otherwise track reflows and show values.
	   * @param {Boolean} isActive
	   */
	  setActive: function (isActive) {
	    if (isActive === this.isActive) {
	      return;
	    }
	    this.isActive = isActive;

	    if (isActive) {
	      this.trackReflows();
	    } else {
	      this.untrackReflows();
	    }
	  },

	  /**
	   * Compute the dimensions of the node and update the values in
	   * the inspector.xul document.
	   * @return a promise that will be resolved when complete.
	   */
	  update: function () {
	    let lastRequest = Task.spawn((function* () {
	      if (!this.isViewVisibleAndNodeValid()) {
	        this.wrapper.hidden = true;
	        this.inspector.emit("layoutview-updated");
	        return null;
	      }

	      let node = this.inspector.selection.nodeFront;
	      let layout = yield this.inspector.pageStyle.getLayout(node, {
	        autoMargins: this.isActive
	      });
	      let styleEntries = yield this.inspector.pageStyle.getApplied(node, {});

	      yield this.updateGeometryButton();

	      // If a subsequent request has been made, wait for that one instead.
	      if (this._lastRequest != lastRequest) {
	        return this._lastRequest;
	      }

	      this._lastRequest = null;
	      let width = layout.width;
	      let height = layout.height;
	      let newLabel = SHARED_L10N.getFormatStr("dimensions", width, height);

	      if (this.sizeHeadingLabel.textContent != newLabel) {
	        this.sizeHeadingLabel.textContent = newLabel;
	      }

	      for (let i in this.map) {
	        let property = this.map[i].property;
	        if (!(property in layout)) {
	          // Depending on the actor version, some properties
	          // might be missing.
	          continue;
	        }
	        let parsedValue = parseFloat(layout[property]);
	        if (Number.isNaN(parsedValue)) {
	          // Not a number. We use the raw string.
	          // Useful for "position" for example.
	          this.map[i].value = layout[property];
	        } else {
	          this.map[i].value = parsedValue;
	        }
	      }

	      let margins = layout.autoMargins;
	      if ("top" in margins) {
	        this.map.marginTop.value = "auto";
	      }
	      if ("right" in margins) {
	        this.map.marginRight.value = "auto";
	      }
	      if ("bottom" in margins) {
	        this.map.marginBottom.value = "auto";
	      }
	      if ("left" in margins) {
	        this.map.marginLeft.value = "auto";
	      }

	      for (let i in this.map) {
	        let selector = this.map[i].selector;
	        let span = this.doc.querySelector(selector);
	        this.updateSourceRuleTooltip(span, this.map[i].property, styleEntries);
	        if (span.textContent.length > 0 &&
	            span.textContent == this.map[i].value) {
	          continue;
	        }
	        span.textContent = this.map[i].value;
	        this.manageOverflowingText(span);
	      }

	      width -= this.map.borderLeft.value + this.map.borderRight.value +
	               this.map.paddingLeft.value + this.map.paddingRight.value;
	      width = parseFloat(width.toPrecision(6));
	      height -= this.map.borderTop.value + this.map.borderBottom.value +
	                this.map.paddingTop.value + this.map.paddingBottom.value;
	      height = parseFloat(height.toPrecision(6));

	      let newValue = width + "\u00D7" + height;
	      if (this.sizeLabel.textContent != newValue) {
	        this.sizeLabel.textContent = newValue;
	      }

	      this.elementRules = styleEntries.map(e => e.rule);

	      this.wrapper.hidden = false;

	      this.inspector.emit("layoutview-updated");
	      return null;
	    }).bind(this)).catch(console.error);

	    this._lastRequest = lastRequest;
	    return this._lastRequest;
	  },

	  /**
	   * Update the text in the tooltip shown when hovering over a value to provide
	   * information about the source CSS rule that sets this value.
	   * @param {DOMNode} el The element that will receive the tooltip.
	   * @param {String} property The name of the CSS property for the tooltip.
	   * @param {Array} rules An array of applied rules retrieved by
	   * styleActor.getApplied.
	   */
	  updateSourceRuleTooltip: function (el, property, rules) {
	    // Dummy element used to parse the cssText of applied rules.
	    let dummyEl = this.doc.createElement("div");

	    // Rules are in order of priority so iterate until we find the first that
	    // defines a value for the property.
	    let sourceRule, value;
	    for (let {rule} of rules) {
	      dummyEl.style.cssText = rule.cssText;
	      value = dummyEl.style.getPropertyValue(property);
	      if (value !== "") {
	        sourceRule = rule;
	        break;
	      }
	    }

	    let title = property;
	    if (sourceRule && sourceRule.selectors) {
	      title += "\n" + sourceRule.selectors.join(", ");
	    }
	    if (sourceRule && sourceRule.parentStyleSheet) {
	      if (sourceRule.parentStyleSheet.href) {
	        title += "\n" + sourceRule.parentStyleSheet.href + ":" + sourceRule.line;
	      } else {
	        title += "\n" + INSPECTOR_L10N.getStr("rule.sourceInline") +
	          ":" + sourceRule.line;
	      }
	    }

	    el.setAttribute("title", title);
	  },

	  /**
	   * Show the box-model highlighter on the currently selected element
	   * @param {Object} options Options passed to the highlighter actor
	   */
	  showBoxModel: function (options = {}) {
	    let toolbox = this.inspector.toolbox;
	    let nodeFront = this.inspector.selection.nodeFront;

	    toolbox.highlighterUtils.highlightNodeFront(nodeFront, options);
	  },

	  /**
	   * Hide the box-model highlighter on the currently selected element
	   */
	  hideBoxModel: function () {
	    let toolbox = this.inspector.toolbox;

	    toolbox.highlighterUtils.unhighlight();
	  },

	  /**
	   * Show the geometry editor highlighter on the currently selected element
	   * @param {Boolean} [showOnlyIfActive=false]
	   *   Indicates if the Geometry Editor should be shown only if it's active but
	   *   hidden.
	   */
	  showGeometryEditor: function (showOnlyIfActive = false) {
	    let toolbox = this.inspector.toolbox;
	    let nodeFront = this.inspector.selection.nodeFront;
	    let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	    let isActive = nodeGeometry.hasAttribute("checked");

	    if (showOnlyIfActive && !isActive) {
	      return;
	    }

	    if (this._geometryEditorHighlighter) {
	      this._geometryEditorHighlighter.show(nodeFront).catch(console.error);
	      return;
	    }

	    // instantiate Geometry Editor highlighter
	    toolbox.highlighterUtils
	      .getHighlighterByType("GeometryEditorHighlighter").then(highlighter => {
	        highlighter.show(nodeFront).catch(console.error);
	        this._geometryEditorHighlighter = highlighter;

	        // Hide completely the geometry editor if the picker is clicked
	        toolbox.on("picker-started", this.onPickerStarted);

	        // Temporary hide the geometry editor
	        this.inspector.markup.on("leave", this.onMarkupViewLeave);
	        this.inspector.markup.on("node-hover", this.onMarkupViewNodeHover);

	        // Release the actor on will-navigate event
	        this.inspector._target.once("will-navigate", this.onWillNavigate);
	      });
	  },

	  /**
	   * Hide the geometry editor highlighter on the currently selected element
	   * @param {Boolean} [updateButton=true]
	   *   Indicates if the Geometry Editor's button needs to be unchecked too
	   */
	  hideGeometryEditor: function (updateButton = true) {
	    if (this._geometryEditorHighlighter) {
	      this._geometryEditorHighlighter.hide().catch(console.error);
	    }

	    if (updateButton) {
	      let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	      nodeGeometry.removeAttribute("checked");
	    }
	  },

	  /**
	   * Update the visibility and the state of the geometry editor button,
	   * based on the selected node.
	   */
	  updateGeometryButton: Task.async(function* () {
	    let node = this.inspector.selection.nodeFront;
	    let isEditable = false;

	    if (node) {
	      isEditable = yield this.inspector.pageStyle.isPositionEditable(node);
	    }

	    let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	    nodeGeometry.style.visibility = isEditable ? "visible" : "hidden";
	  }),

	  manageOverflowingText: function (span) {
	    let classList = span.parentNode.classList;

	    if (classList.contains("layout-left") ||
	        classList.contains("layout-right")) {
	      let force = span.textContent.length > LONG_TEXT_ROTATE_LIMIT;
	      classList.toggle("layout-rotate", force);
	    }
	  }
	};

	exports.LayoutView = LayoutView;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {reflowSpec} = __webpack_require__(163);
	const protocol = __webpack_require__(19);

	/**
	 * Usage example of the reflow front:
	 *
	 * let front = ReflowFront(toolbox.target.client, toolbox.target.form);
	 * front.on("reflows", this._onReflows);
	 * front.start();
	 * // now wait for events to come
	 */
	const ReflowFront = protocol.FrontClassWithSpec(reflowSpec, {
	  initialize: function (client, {reflowActor}) {
	    protocol.Front.prototype.initialize.call(this, client, {actor: reflowActor});
	    this.manage(this);
	  },

	  destroy: function () {
	    protocol.Front.prototype.destroy.call(this);
	  },
	});

	exports.ReflowFront = ReflowFront;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {Arg, generateActorSpec} = __webpack_require__(19);

	const reflowSpec = generateActorSpec({
	  typeName: "reflow",

	  events: {
	    /**
	     * The reflows event is emitted when reflows have been detected. The event
	     * is sent with an array of reflows that occured. Each item has the
	     * following properties:
	     * - start {Number}
	     * - end {Number}
	     * - isInterruptible {Boolean}
	     */
	    reflows: {
	      type: "reflows",
	      reflows: Arg(0, "array:json")
	    }
	  },

	  methods: {
	    start: {oneway: true},
	    stop: {oneway: true},
	  },
	});

	exports.reflowSpec = reflowSpec;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {gDevTools} = __webpack_require__(133);
	const Services = __webpack_require__(1);

	const DEFAULT_PREVIEW_TEXT = "Abc";
	const PREVIEW_UPDATE_DELAY = 150;

	const {Task} = __webpack_require__(17);

	function FontInspector(inspector, window) {
	  this.inspector = inspector;
	  this.pageStyle = this.inspector.pageStyle;
	  this.chromeDoc = window.document;
	  this.init();
	}

	FontInspector.prototype = {
	  init: function () {
	    this.update = this.update.bind(this);
	    this.onNewNode = this.onNewNode.bind(this);
	    this.onThemeChanged = this.onThemeChanged.bind(this);
	    this.inspector.selection.on("new-node-front", this.onNewNode);
	    this.inspector.sidebar.on("fontinspector-selected", this.onNewNode);
	    this.showAll = this.showAll.bind(this);
	    this.showAllLink = this.chromeDoc.getElementById("font-showall");
	    this.showAllLink.addEventListener("click", this.showAll);
	    this.previewTextChanged = this.previewTextChanged.bind(this);
	    this.previewInput =
	      this.chromeDoc.getElementById("font-preview-text-input");
	    this.previewInput.addEventListener("input", this.previewTextChanged);

	    // Listen for theme changes as the color of the previews depend on the theme
	    gDevTools.on("theme-switched", this.onThemeChanged);

	    this.update();
	  },

	  /**
	   * Is the fontinspector visible in the sidebar?
	   */
	  isActive: function () {
	    return this.inspector.sidebar &&
	           this.inspector.sidebar.getCurrentTabID() == "fontinspector";
	  },

	  /**
	   * Remove listeners.
	   */
	  destroy: function () {
	    this.chromeDoc = null;
	    this.inspector.sidebar.off("fontinspector-selected", this.onNewNode);
	    this.inspector.selection.off("new-node-front", this.onNewNode);
	    this.showAllLink.removeEventListener("click", this.showAll);
	    this.previewInput.removeEventListener("input", this.previewTextChanged);

	    gDevTools.off("theme-switched", this.onThemeChanged);

	    if (this._previewUpdateTimeout) {
	      clearTimeout(this._previewUpdateTimeout);
	    }
	  },

	  /**
	   * Selection 'new-node' event handler.
	   */
	  onNewNode: function () {
	    if (this.isActive() &&
	        this.inspector.selection.isConnected() &&
	        this.inspector.selection.isElementNode()) {
	      this.undim();
	      this.update();
	    } else {
	      this.dim();
	    }
	  },

	  /**
	   * The text to use for previews. Returns either the value user has typed to
	   * the preview input or DEFAULT_PREVIEW_TEXT if the input is empty or contains
	   * only whitespace.
	   */
	  getPreviewText: function () {
	    let inputText = this.previewInput.value.trim();
	    if (inputText === "") {
	      return DEFAULT_PREVIEW_TEXT;
	    }

	    return inputText;
	  },

	  /**
	   * Preview input 'input' event handler.
	   */
	  previewTextChanged: function () {
	    if (this._previewUpdateTimeout) {
	      clearTimeout(this._previewUpdateTimeout);
	    }

	    this._previewUpdateTimeout = setTimeout(() => {
	      this.update(this._lastUpdateShowedAllFonts);
	    }, PREVIEW_UPDATE_DELAY);
	  },

	  /**
	   * Callback for the theme-switched event.
	   */
	  onThemeChanged: function (event, frame) {
	    if (frame === this.chromeDoc.defaultView) {
	      this.update(this._lastUpdateShowedAllFonts);
	    }
	  },

	  /**
	   * Hide the font list. No node are selected.
	   */
	  dim: function () {
	    let panel = this.chromeDoc.getElementById("sidebar-panel-fontinspector");
	    panel.classList.add("dim");
	    this.clear();
	  },

	  /**
	   * Show the font list. A node is selected.
	   */
	  undim: function () {
	    let panel = this.chromeDoc.getElementById("sidebar-panel-fontinspector");
	    panel.classList.remove("dim");
	  },

	  /**
	   * Clears the font list.
	   */
	  clear: function () {
	    this.chromeDoc.querySelector("#all-fonts").innerHTML = "";
	  },

	 /**
	  * Retrieve all the font info for the selected node and display it.
	  */
	  update: Task.async(function* (showAllFonts) {
	    let node = this.inspector.selection.nodeFront;
	    let panel = this.chromeDoc.getElementById("sidebar-panel-fontinspector");

	    if (!node ||
	        !this.isActive() ||
	        !this.inspector.selection.isConnected() ||
	        !this.inspector.selection.isElementNode() ||
	        panel.classList.contains("dim")) {
	      return;
	    }

	    this._lastUpdateShowedAllFonts = showAllFonts;

	    // Assume light theme colors as the default (see also bug 1118179).
	    let fillStyle = (Services.prefs.getCharPref("devtools.theme") == "dark") ?
	        "white" : "black";

	    let options = {
	      includePreviews: true,
	      previewText: this.getPreviewText(),
	      previewFillStyle: fillStyle
	    };

	    let fonts = [];
	    if (showAllFonts) {
	      fonts = yield this.pageStyle.getAllUsedFontFaces(options)
	                      .then(null, console.error);
	    } else {
	      fonts = yield this.pageStyle.getUsedFontFaces(node, options)
	                      .then(null, console.error);
	    }

	    if (!fonts || !fonts.length) {
	      // No fonts to display. Clear the previously shown fonts.
	      this.clear();
	      return;
	    }

	    for (let font of fonts) {
	      font.previewUrl = yield font.preview.data.string();
	    }

	    // in case we've been destroyed in the meantime
	    if (!this.chromeDoc) {
	      return;
	    }

	    // Make room for the new fonts.
	    this.clear();

	    for (let font of fonts) {
	      this.render(font);
	    }

	    this.inspector.emit("fontinspector-updated");
	  }),

	  /**
	   * Display the information of one font.
	   */
	  render: function (font) {
	    let s = this.chromeDoc.querySelector("#font-template > section");
	    s = s.cloneNode(true);

	    s.querySelector(".font-name").textContent = font.name;
	    s.querySelector(".font-css-name").textContent = font.CSSFamilyName;

	    if (font.URI) {
	      s.classList.add("is-remote");
	    } else {
	      s.classList.add("is-local");
	    }

	    let formatElem = s.querySelector(".font-format");
	    if (font.format) {
	      formatElem.textContent = font.format;
	    } else {
	      formatElem.hidden = true;
	    }

	    s.querySelector(".font-url").value = font.URI;

	    if (font.rule) {
	      // This is the @font-face{…} code.
	      let cssText = font.ruleText;

	      s.classList.add("has-code");
	      s.querySelector(".font-css-code").textContent = cssText;
	    }
	    let preview = s.querySelector(".font-preview");
	    preview.src = font.previewUrl;

	    this.chromeDoc.querySelector("#all-fonts").appendChild(s);
	  },

	  /**
	   * Show all fonts for the document (including iframes)
	   */
	  showAll: function () {
	    this.update(true);
	  },
	};

	exports.FontInspector = FontInspector;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);

	const {ELLIPSIS} = __webpack_require__(39);

	const MAX_LABEL_LENGTH = 40;

	const NS_XHTML = "http://www.w3.org/1999/xhtml";
	const SCROLL_REPEAT_MS = 100;

	const EventEmitter = __webpack_require__(6);
	const {KeyShortcuts} = __webpack_require__(15);

	// Some margin may be required for visible element detection.
	const SCROLL_MARGIN = 1;

	/**
	 * Component to replicate functionality of XUL arrowscrollbox
	 * for breadcrumbs
	 *
	 * @param {Window} win The window containing the breadcrumbs
	 * @parem {DOMNode} container The element in which to put the scroll box
	 */
	function ArrowScrollBox(win, container) {
	  this.win = win;
	  this.doc = win.document;
	  this.container = container;
	  EventEmitter.decorate(this);
	  this.init();
	}

	ArrowScrollBox.prototype = {

	  // Scroll behavior, exposed for testing
	  scrollBehavior: "smooth",

	  /**
	   * Build the HTML, add to the DOM and start listening to
	   * events
	   */
	  init: function () {
	    this.constructHtml();

	    this.onUnderflow();

	    this.onScroll = this.onScroll.bind(this);
	    this.onStartBtnClick = this.onStartBtnClick.bind(this);
	    this.onEndBtnClick = this.onEndBtnClick.bind(this);
	    this.onStartBtnDblClick = this.onStartBtnDblClick.bind(this);
	    this.onEndBtnDblClick = this.onEndBtnDblClick.bind(this);
	    this.onUnderflow = this.onUnderflow.bind(this);
	    this.onOverflow = this.onOverflow.bind(this);

	    this.inner.addEventListener("scroll", this.onScroll, false);
	    this.startBtn.addEventListener("mousedown", this.onStartBtnClick, false);
	    this.endBtn.addEventListener("mousedown", this.onEndBtnClick, false);
	    this.startBtn.addEventListener("dblclick", this.onStartBtnDblClick, false);
	    this.endBtn.addEventListener("dblclick", this.onEndBtnDblClick, false);

	    // Overflow and underflow are moz specific events
	    this.inner.addEventListener("underflow", this.onUnderflow, false);
	    this.inner.addEventListener("overflow", this.onOverflow, false);
	  },

	  /**
	   * Determine whether the current text directionality is RTL
	   */
	  isRtl: function () {
	    return this.win.getComputedStyle(this.container).direction === "rtl";
	  },

	  /**
	   * Scroll to the specified element using the current scroll behavior
	   * @param {Element} element element to scroll
	   * @param {String} block desired alignment of element after scrolling
	   */
	  scrollToElement: function (element, block) {
	    element.scrollIntoView({ block: block, behavior: this.scrollBehavior });
	  },

	  /**
	   * Call the given function once; then continuously
	   * while the mouse button is held
	   * @param {Function} repeatFn the function to repeat while the button is held
	   */
	  clickOrHold: function (repeatFn) {
	    let timer;
	    let container = this.container;

	    function handleClick() {
	      cancelHold();
	      repeatFn();
	    }

	    let window = this.win;
	    function cancelHold() {
	      window.clearTimeout(timer);
	      container.removeEventListener("mouseout", cancelHold, false);
	      container.removeEventListener("mouseup", handleClick, false);
	    }

	    function repeated() {
	      repeatFn();
	      timer = window.setTimeout(repeated, SCROLL_REPEAT_MS);
	    }

	    container.addEventListener("mouseout", cancelHold, false);
	    container.addEventListener("mouseup", handleClick, false);
	    timer = window.setTimeout(repeated, SCROLL_REPEAT_MS);
	  },

	  /**
	   * When start button is dbl clicked scroll to first element
	   */
	  onStartBtnDblClick: function () {
	    let children = this.inner.childNodes;
	    if (children.length < 1) {
	      return;
	    }

	    let element = this.inner.childNodes[0];
	    this.scrollToElement(element, "start");
	  },

	  /**
	   * When end button is dbl clicked scroll to last element
	   */
	  onEndBtnDblClick: function () {
	    let children = this.inner.childNodes;
	    if (children.length < 1) {
	      return;
	    }

	    let element = children[children.length - 1];
	    this.scrollToElement(element, "start");
	  },

	  /**
	   * When start arrow button is clicked scroll towards first element
	   */
	  onStartBtnClick: function () {
	    let scrollToStart = () => {
	      let element = this.getFirstInvisibleElement();
	      if (!element) {
	        return;
	      }

	      let block = this.isRtl() ? "end" : "start";
	      this.scrollToElement(element, block);
	    };

	    this.clickOrHold(scrollToStart);
	  },

	  /**
	   * When end arrow button is clicked scroll towards last element
	   */
	  onEndBtnClick: function () {
	    let scrollToEnd = () => {
	      let element = this.getLastInvisibleElement();
	      if (!element) {
	        return;
	      }

	      let block = this.isRtl() ? "start" : "end";
	      this.scrollToElement(element, block);
	    };

	    this.clickOrHold(scrollToEnd);
	  },

	  /**
	   * Event handler for scrolling, update the
	   * enabled/disabled status of the arrow buttons
	   */
	  onScroll: function () {
	    let first = this.getFirstInvisibleElement();
	    if (!first) {
	      this.startBtn.setAttribute("disabled", "true");
	    } else {
	      this.startBtn.removeAttribute("disabled");
	    }

	    let last = this.getLastInvisibleElement();
	    if (!last) {
	      this.endBtn.setAttribute("disabled", "true");
	    } else {
	      this.endBtn.removeAttribute("disabled");
	    }
	  },

	  /**
	   * On underflow, make the arrow buttons invisible
	   */
	  onUnderflow: function () {
	    this.startBtn.style.visibility = "collapse";
	    this.endBtn.style.visibility = "collapse";
	    this.emit("underflow");
	  },

	  /**
	   * On overflow, show the arrow buttons
	   */
	  onOverflow: function () {
	    this.startBtn.style.visibility = "visible";
	    this.endBtn.style.visibility = "visible";
	    this.emit("overflow");
	  },

	  /**
	   * Check whether the element is to the left of its container but does
	   * not also span the entire container.
	   * @param {Number} left the left scroll point of the container
	   * @param {Number} right the right edge of the container
	   * @param {Number} elementLeft the left edge of the element
	   * @param {Number} elementRight the right edge of the element
	   */
	  elementLeftOfContainer: function (left, right, elementLeft, elementRight) {
	    return elementLeft < (left - SCROLL_MARGIN)
	           && elementRight < (right - SCROLL_MARGIN);
	  },

	  /**
	   * Check whether the element is to the right of its container but does
	   * not also span the entire container.
	   * @param {Number} left the left scroll point of the container
	   * @param {Number} right the right edge of the container
	   * @param {Number} elementLeft the left edge of the element
	   * @param {Number} elementRight the right edge of the element
	   */
	  elementRightOfContainer: function (left, right, elementLeft, elementRight) {
	    return elementLeft > (left + SCROLL_MARGIN)
	           && elementRight > (right + SCROLL_MARGIN);
	  },

	  /**
	   * Get the first (i.e. furthest left for LTR)
	   * non or partly visible element in the scroll box
	   */
	  getFirstInvisibleElement: function () {
	    let elementsList = Array.from(this.inner.childNodes).reverse();

	    let predicate = this.isRtl() ?
	      this.elementRightOfContainer : this.elementLeftOfContainer;
	    return this.findFirstWithBounds(elementsList, predicate);
	  },

	  /**
	   * Get the last (i.e. furthest right for LTR)
	   * non or partly visible element in the scroll box
	   */
	  getLastInvisibleElement: function () {
	    let predicate = this.isRtl() ?
	      this.elementLeftOfContainer : this.elementRightOfContainer;
	    return this.findFirstWithBounds(this.inner.childNodes, predicate);
	  },

	  /**
	   * Find the first element that matches the given predicate, called with bounds
	   * information
	   * @param {Array} elements an ordered list of elements
	   * @param {Function} predicate a function to be called with bounds
	   * information
	   */
	  findFirstWithBounds: function (elements, predicate) {
	    let left = this.inner.scrollLeft;
	    let right = left + this.inner.clientWidth;
	    for (let element of elements) {
	      let elementLeft = element.offsetLeft - element.parentElement.offsetLeft;
	      let elementRight = elementLeft + element.offsetWidth;

	      // Check that the starting edge of the element is out of the visible area
	      // and that the ending edge does not span the whole container
	      if (predicate(left, right, elementLeft, elementRight)) {
	        return element;
	      }
	    }

	    return null;
	  },

	  /**
	   * Build the HTML for the scroll box and insert it into the DOM
	   */
	  constructHtml: function () {
	    this.startBtn = this.createElement("div", "scrollbutton-up",
	                                       this.container);
	    this.createElement("div", "toolbarbutton-icon", this.startBtn);

	    this.createElement("div", "arrowscrollbox-overflow-start-indicator",
	                       this.container);
	    this.inner = this.createElement("div", "html-arrowscrollbox-inner",
	                                    this.container);
	    this.createElement("div", "arrowscrollbox-overflow-end-indicator",
	                       this.container);

	    this.endBtn = this.createElement("div", "scrollbutton-down",
	                                     this.container);
	    this.createElement("div", "toolbarbutton-icon", this.endBtn);
	  },

	  /**
	   * Create an XHTML element with the given class name, and append it to the
	   * parent.
	   * @param {String} tagName name of the tag to create
	   * @param {String} className class of the element
	   * @param {DOMNode} parent the parent node to which it should be appended
	   * @return {DOMNode} The new element
	   */
	  createElement: function (tagName, className, parent) {
	    let el = this.doc.createElementNS(NS_XHTML, tagName);
	    el.className = className;
	    if (parent) {
	      parent.appendChild(el);
	    }

	    return el;
	  },

	  /**
	   * Remove event handlers and clean up
	   */
	  destroy: function () {
	    this.inner.removeEventListener("scroll", this.onScroll, false);
	    this.startBtn.removeEventListener("mousedown",
	                                      this.onStartBtnClick, false);
	    this.endBtn.removeEventListener("mousedown", this.onEndBtnClick, false);
	    this.startBtn.removeEventListener("dblclick",
	                                      this.onStartBtnDblClick, false);
	    this.endBtn.removeEventListener("dblclick",
	                                    this.onRightBtnDblClick, false);

	    // Overflow and underflow are moz specific events
	    this.inner.removeEventListener("underflow", this.onUnderflow, false);
	    this.inner.removeEventListener("overflow", this.onOverflow, false);
	  },
	};

	/**
	 * Display the ancestors of the current node and its children.
	 * Only one "branch" of children are displayed (only one line).
	 *
	 * Mechanism:
	 * - If no nodes displayed yet:
	 *   then display the ancestor of the selected node and the selected node;
	 *   else select the node;
	 * - If the selected node is the last node displayed, append its first (if any).
	 *
	 * @param {InspectorPanel} inspector The inspector hosting this widget.
	 */
	function HTMLBreadcrumbs(inspector) {
	  this.inspector = inspector;
	  this.selection = this.inspector.selection;
	  this.win = this.inspector.panelWin;
	  this.doc = this.inspector.panelDoc;
	  this._init();
	}

	exports.HTMLBreadcrumbs = HTMLBreadcrumbs;

	HTMLBreadcrumbs.prototype = {
	  get walker() {
	    return this.inspector.walker;
	  },

	  _init: function () {
	    this.outer = this.doc.getElementById("inspector-breadcrumbs");
	    this.arrowScrollBox = new ArrowScrollBox(
	        this.win,
	        this.outer);

	    this.container = this.arrowScrollBox.inner;
	    this.scroll = this.scroll.bind(this);
	    this.arrowScrollBox.on("overflow", this.scroll);

	    // These separators are used for CSS purposes only, and are positioned
	    // off screen, but displayed with -moz-element.
	    this.separators = this.doc.createElementNS(NS_XHTML, "div");
	    this.separators.className = "breadcrumb-separator-container";
	    this.separators.innerHTML =
	                      "<div id='breadcrumb-separator-before'></div>" +
	                      "<div id='breadcrumb-separator-after'></div>" +
	                      "<div id='breadcrumb-separator-normal'></div>";
	    this.container.parentNode.appendChild(this.separators);

	    this.outer.addEventListener("click", this, true);
	    this.outer.addEventListener("mouseover", this, true);
	    this.outer.addEventListener("mouseout", this, true);
	    this.outer.addEventListener("focus", this, true);

	    this.shortcuts = new KeyShortcuts({ window: this.win, target: this.outer });
	    this.handleShortcut = this.handleShortcut.bind(this);

	    this.shortcuts.on("Right", this.handleShortcut);
	    this.shortcuts.on("Left", this.handleShortcut);

	    // We will save a list of already displayed nodes in this array.
	    this.nodeHierarchy = [];

	    // Last selected node in nodeHierarchy.
	    this.currentIndex = -1;

	    // Used to build a unique breadcrumb button Id.
	    this.breadcrumbsWidgetItemId = 0;

	    this.update = this.update.bind(this);
	    this.updateSelectors = this.updateSelectors.bind(this);
	    this.selection.on("new-node-front", this.update);
	    this.selection.on("pseudoclass", this.updateSelectors);
	    this.selection.on("attribute-changed", this.updateSelectors);
	    this.inspector.on("markupmutation", this.update);
	    this.update();
	  },

	  /**

	   * Build a string that represents the node: tagName#id.class1.class2.
	   * @param {NodeFront} node The node to pretty-print
	   * @return {String}
	   */
	  prettyPrintNodeAsText: function (node) {
	    let text = node.displayName;
	    if (node.isPseudoElement) {
	      text = node.isBeforePseudoElement ? "::before" : "::after";
	    }

	    if (node.id) {
	      text += "#" + node.id;
	    }

	    if (node.className) {
	      let classList = node.className.split(/\s+/);
	      for (let i = 0; i < classList.length; i++) {
	        text += "." + classList[i];
	      }
	    }

	    for (let pseudo of node.pseudoClassLocks) {
	      text += pseudo;
	    }

	    return text;
	  },

	  /**
	   * Build <span>s that represent the node:
	   *   <span class="breadcrumbs-widget-item-tag">tagName</span>
	   *   <span class="breadcrumbs-widget-item-id">#id</span>
	   *   <span class="breadcrumbs-widget-item-classes">.class1.class2</span>
	   * @param {NodeFront} node The node to pretty-print
	   * @returns {DocumentFragment}
	   */
	  prettyPrintNodeAsXHTML: function (node) {
	    let tagLabel = this.doc.createElementNS(NS_XHTML, "span");
	    tagLabel.className = "breadcrumbs-widget-item-tag plain";

	    let idLabel = this.doc.createElementNS(NS_XHTML, "span");
	    idLabel.className = "breadcrumbs-widget-item-id plain";

	    let classesLabel = this.doc.createElementNS(NS_XHTML, "span");
	    classesLabel.className = "breadcrumbs-widget-item-classes plain";

	    let pseudosLabel = this.doc.createElementNS(NS_XHTML, "span");
	    pseudosLabel.className = "breadcrumbs-widget-item-pseudo-classes plain";

	    let tagText = node.displayName;
	    if (node.isPseudoElement) {
	      tagText = node.isBeforePseudoElement ? "::before" : "::after";
	    }
	    let idText = node.id ? ("#" + node.id) : "";
	    let classesText = "";

	    if (node.className) {
	      let classList = node.className.split(/\s+/);
	      for (let i = 0; i < classList.length; i++) {
	        classesText += "." + classList[i];
	      }
	    }

	    // Figure out which element (if any) needs ellipsing.
	    // Substring for that element, then clear out any extras
	    // (except for pseudo elements).
	    let maxTagLength = MAX_LABEL_LENGTH;
	    let maxIdLength = MAX_LABEL_LENGTH - tagText.length;
	    let maxClassLength = MAX_LABEL_LENGTH - tagText.length - idText.length;

	    if (tagText.length > maxTagLength) {
	      tagText = tagText.substr(0, maxTagLength) + ELLIPSIS;
	      idText = classesText = "";
	    } else if (idText.length > maxIdLength) {
	      idText = idText.substr(0, maxIdLength) + ELLIPSIS;
	      classesText = "";
	    } else if (classesText.length > maxClassLength) {
	      classesText = classesText.substr(0, maxClassLength) + ELLIPSIS;
	    }

	    tagLabel.textContent = tagText;
	    idLabel.textContent = idText;
	    classesLabel.textContent = classesText;
	    pseudosLabel.textContent = node.pseudoClassLocks.join("");

	    let fragment = this.doc.createDocumentFragment();
	    fragment.appendChild(tagLabel);
	    fragment.appendChild(idLabel);
	    fragment.appendChild(classesLabel);
	    fragment.appendChild(pseudosLabel);

	    return fragment;
	  },

	  /**
	   * Generic event handler.
	   * @param {DOMEvent} event.
	   */
	  handleEvent: function (event) {
	    if (event.type == "click" && event.button == 0) {
	      this.handleClick(event);
	    } else if (event.type == "mouseover") {
	      this.handleMouseOver(event);
	    } else if (event.type == "mouseout") {
	      this.handleMouseOut(event);
	    } else if (event.type == "focus") {
	      this.handleFocus(event);
	    }
	  },

	  /**
	   * Focus event handler. When breadcrumbs container gets focus,
	   * aria-activedescendant needs to be updated to currently selected
	   * breadcrumb. Ensures that the focus stays on the container at all times.
	   * @param {DOMEvent} event.
	   */
	  handleFocus: function (event) {
	    event.stopPropagation();

	    let node = this.nodeHierarchy[this.currentIndex];
	    if (node) {
	      this.outer.setAttribute("aria-activedescendant", node.button.id);
	    } else {
	      this.outer.removeAttribute("aria-activedescendant");
	    }

	    this.outer.focus();
	  },

	  /**
	   * On click navigate to the correct node.
	   * @param {DOMEvent} event.
	   */
	  handleClick: function (event) {
	    let target = event.originalTarget;
	    if (target.tagName == "button") {
	      target.onBreadcrumbsClick();
	    }
	  },

	  /**
	   * On mouse over, highlight the corresponding content DOM Node.
	   * @param {DOMEvent} event.
	   */
	  handleMouseOver: function (event) {
	    let target = event.originalTarget;
	    if (target.tagName == "button") {
	      target.onBreadcrumbsHover();
	    }
	  },

	  /**
	   * On mouse out, make sure to unhighlight.
	   * @param {DOMEvent} event.
	   */
	  handleMouseOut: function (event) {
	    this.inspector.toolbox.highlighterUtils.unhighlight();
	  },

	  /**
	   * Handle a keyboard shortcut supported by the breadcrumbs widget.
	   *
	   * @param {String} name
	   *        Name of the keyboard shortcut received.
	   * @param {DOMEvent} event
	   *        Original event that triggered the shortcut.
	   */
	  handleShortcut: function (name, event) {
	    if (!this.selection.isElementNode()) {
	      return;
	    }

	    event.preventDefault();
	    event.stopPropagation();

	    this.keyPromise = (this.keyPromise || promise.resolve(null)).then(() => {
	      let currentnode;
	      if (name === "Left" && this.currentIndex != 0) {
	        currentnode = this.nodeHierarchy[this.currentIndex - 1];
	      } else if (name === "Right" && this.currentIndex < this.nodeHierarchy.length - 1) {
	        currentnode = this.nodeHierarchy[this.currentIndex + 1];
	      } else {
	        return null;
	      }

	      this.outer.setAttribute("aria-activedescendant", currentnode.button.id);
	      return this.selection.setNodeFront(currentnode.node, "breadcrumbs");
	    });
	  },

	  /**
	   * Remove nodes and clean up.
	   */
	  destroy: function () {
	    this.selection.off("new-node-front", this.update);
	    this.selection.off("pseudoclass", this.updateSelectors);
	    this.selection.off("attribute-changed", this.updateSelectors);
	    this.inspector.off("markupmutation", this.update);

	    this.container.removeEventListener("click", this, true);
	    this.container.removeEventListener("mouseover", this, true);
	    this.container.removeEventListener("mouseout", this, true);
	    this.container.removeEventListener("focus", this, true);
	    this.shortcuts.destroy();

	    this.empty();
	    this.separators.remove();

	    this.arrowScrollBox.off("overflow", this.scroll);
	    this.arrowScrollBox.destroy();
	    this.arrowScrollBox = null;
	    this.outer = null;
	    this.container = null;
	    this.separators = null;
	    this.nodeHierarchy = null;

	    this.isDestroyed = true;
	  },

	  /**
	   * Empty the breadcrumbs container.
	   */
	  empty: function () {
	    while (this.container.hasChildNodes()) {
	      this.container.firstChild.remove();
	    }
	  },

	  /**
	   * Set which button represent the selected node.
	   * @param {Number} index Index of the displayed-button to select.
	   */
	  setCursor: function (index) {
	    // Unselect the previously selected button
	    if (this.currentIndex > -1
	        && this.currentIndex < this.nodeHierarchy.length) {
	      this.nodeHierarchy[this.currentIndex].button.removeAttribute("checked");
	    }
	    if (index > -1) {
	      this.nodeHierarchy[index].button.setAttribute("checked", "true");
	    } else {
	      // Unset active active descendant when all buttons are unselected.
	      this.outer.removeAttribute("aria-activedescendant");
	    }
	    this.currentIndex = index;
	  },

	  /**
	   * Get the index of the node in the cache.
	   * @param {NodeFront} node.
	   * @returns {Number} The index for this node or -1 if not found.
	   */
	  indexOf: function (node) {
	    for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
	      if (this.nodeHierarchy[i].node === node) {
	        return i;
	      }
	    }
	    return -1;
	  },

	  /**
	   * Remove all the buttons and their references in the cache after a given
	   * index.
	   * @param {Number} index.
	   */
	  cutAfter: function (index) {
	    while (this.nodeHierarchy.length > (index + 1)) {
	      let toRemove = this.nodeHierarchy.pop();
	      this.container.removeChild(toRemove.button);
	    }
	  },

	  /**
	   * Build a button representing the node.
	   * @param {NodeFront} node The node from the page.
	   * @return {DOMNode} The <button> for this node.
	   */
	  buildButton: function (node) {
	    let button = this.doc.createElementNS(NS_XHTML, "button");
	    button.appendChild(this.prettyPrintNodeAsXHTML(node));
	    button.className = "breadcrumbs-widget-item";
	    button.id = "breadcrumbs-widget-item-" + this.breadcrumbsWidgetItemId++;

	    button.setAttribute("tabindex", "-1");
	    button.setAttribute("title", this.prettyPrintNodeAsText(node));

	    button.onclick = () => {
	      button.focus();
	    };

	    button.onBreadcrumbsClick = () => {
	      this.selection.setNodeFront(node, "breadcrumbs");
	    };

	    button.onBreadcrumbsHover = () => {
	      this.inspector.toolbox.highlighterUtils.highlightNodeFront(node);
	    };

	    return button;
	  },

	  /**
	   * Connecting the end of the breadcrumbs to a node.
	   * @param {NodeFront} node The node to reach.
	   */
	  expand: function (node) {
	    let fragment = this.doc.createDocumentFragment();
	    let lastButtonInserted = null;
	    let originalLength = this.nodeHierarchy.length;
	    let stopNode = null;
	    if (originalLength > 0) {
	      stopNode = this.nodeHierarchy[originalLength - 1].node;
	    }
	    while (node && node != stopNode) {
	      if (node.tagName) {
	        let button = this.buildButton(node);
	        fragment.insertBefore(button, lastButtonInserted);
	        lastButtonInserted = button;
	        this.nodeHierarchy.splice(originalLength, 0, {
	          node,
	          button,
	          currentPrettyPrintText: this.prettyPrintNodeAsText(node)
	        });
	      }
	      node = node.parentNode();
	    }
	    this.container.appendChild(fragment, this.container.firstChild);
	  },

	  /**
	   * Find the "youngest" ancestor of a node which is already in the breadcrumbs.
	   * @param {NodeFront} node.
	   * @return {Number} Index of the ancestor in the cache, or -1 if not found.
	   */
	  getCommonAncestor: function (node) {
	    while (node) {
	      let idx = this.indexOf(node);
	      if (idx > -1) {
	        return idx;
	      }
	      node = node.parentNode();
	    }
	    return -1;
	  },

	  /**
	   * Ensure the selected node is visible.
	   */
	  scroll: function () {
	    // FIXME bug 684352: make sure its immediate neighbors are visible too.
	    if (!this.isDestroyed) {
	      let element = this.nodeHierarchy[this.currentIndex].button;
	      this.arrowScrollBox.scrollToElement(element, "end");
	    }
	  },

	  /**
	   * Update all button outputs.
	   */
	  updateSelectors: function () {
	    if (this.isDestroyed) {
	      return;
	    }

	    for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
	      let {node, button, currentPrettyPrintText} = this.nodeHierarchy[i];

	      // If the output of the node doesn't change, skip the update.
	      let textOutput = this.prettyPrintNodeAsText(node);
	      if (currentPrettyPrintText === textOutput) {
	        continue;
	      }

	      // Otherwise, update the whole markup for the button.
	      while (button.hasChildNodes()) {
	        button.firstChild.remove();
	      }
	      button.appendChild(this.prettyPrintNodeAsXHTML(node));
	      button.setAttribute("title", textOutput);

	      this.nodeHierarchy[i].currentPrettyPrintText = textOutput;
	    }
	  },

	  /**
	   * Given a list of mutation changes (passed by the markupmutation event),
	   * decide whether or not they are "interesting" to the current state of the
	   * breadcrumbs widget, i.e. at least one of them should cause part of the
	   * widget to be updated.
	   * @param {Array} mutations The mutations array.
	   * @return {Boolean}
	   */
	  _hasInterestingMutations: function (mutations) {
	    if (!mutations || !mutations.length) {
	      return false;
	    }

	    for (let {type, added, removed, target, attributeName} of mutations) {
	      if (type === "childList") {
	        // Only interested in childList mutations if the added or removed
	        // nodes are currently displayed.
	        return added.some(node => this.indexOf(node) > -1) ||
	               removed.some(node => this.indexOf(node) > -1);
	      } else if (type === "attributes" && this.indexOf(target) > -1) {
	        // Only interested in attributes mutations if the target is
	        // currently displayed, and the attribute is either id or class.
	        return attributeName === "class" || attributeName === "id";
	      }
	    }

	    // Catch all return in case the mutations array was empty, or in case none
	    // of the changes iterated above were interesting.
	    return false;
	  },

	  /**
	   * Update the breadcrumbs display when a new node is selected.
	   * @param {String} reason The reason for the update, if any.
	   * @param {Array} mutations An array of mutations in case this was called as
	   * the "markupmutation" event listener.
	   */
	  update: function (reason, mutations) {
	    if (this.isDestroyed) {
	      return;
	    }

	    let hasInterestingMutations = this._hasInterestingMutations(mutations);
	    if (reason === "markupmutation" && !hasInterestingMutations) {
	      return;
	    }

	    if (!this.selection.isConnected()) {
	      // remove all the crumbs
	      this.cutAfter(-1);
	      return;
	    }

	    // If this was an interesting deletion; then trim the breadcrumb trail
	    let trimmed = false;
	    if (reason === "markupmutation") {
	      for (let {type, removed} of mutations) {
	        if (type !== "childList") {
	          continue;
	        }

	        for (let node of removed) {
	          let removedIndex = this.indexOf(node);
	          if (removedIndex > -1) {
	            this.cutAfter(removedIndex - 1);
	            trimmed = true;
	          }
	        }
	      }
	    }

	    if (!this.selection.isElementNode()) {
	      // no selection
	      this.setCursor(-1);
	      if (trimmed) {
	        // Since something changed, notify the interested parties.
	        this.inspector.emit("breadcrumbs-updated", this.selection.nodeFront);
	      }
	      return;
	    }

	    let idx = this.indexOf(this.selection.nodeFront);

	    // Is the node already displayed in the breadcrumbs?
	    // (and there are no mutations that need re-display of the crumbs)
	    if (idx > -1 && !hasInterestingMutations) {
	      // Yes. We select it.
	      this.setCursor(idx);
	    } else {
	      // No. Is the breadcrumbs display empty?
	      if (this.nodeHierarchy.length > 0) {
	        // No. We drop all the element that are not direct ancestors
	        // of the selection
	        let parent = this.selection.nodeFront.parentNode();
	        let ancestorIdx = this.getCommonAncestor(parent);
	        this.cutAfter(ancestorIdx);
	      }
	      // we append the missing button between the end of the breadcrumbs display
	      // and the current node.
	      this.expand(this.selection.nodeFront);

	      // we select the current node button
	      idx = this.indexOf(this.selection.nodeFront);
	      this.setCursor(idx);
	    }

	    let doneUpdating = this.inspector.updating("breadcrumbs");

	    this.updateSelectors();

	    // Make sure the selected node and its neighbours are visible.
	    setTimeout(() => {
	      try {
	        this.scroll();
	        this.inspector.emit("breadcrumbs-updated", this.selection.nodeFront);
	        doneUpdating();
	      } catch (e) {
	        // Only log this as an error if we haven't been destroyed in the meantime.
	        if (!this.isDestroyed) {
	          console.error(e);
	        }
	      }
	    }, 0);
	  }
	};


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);
	const {Task} = __webpack_require__(17);
	const {KeyCodes} = __webpack_require__(16);

	const EventEmitter = __webpack_require__(6);
	const {AutocompletePopup} = __webpack_require__(159);
	const Services = __webpack_require__(1);

	// Maximum number of selector suggestions shown in the panel.
	const MAX_SUGGESTIONS = 15;

	/**
	 * Converts any input field into a document search box.
	 *
	 * @param {InspectorPanel} inspector
	 *        The InspectorPanel whose `walker` attribute should be used for
	 *        document traversal.
	 * @param {DOMNode} input
	 *        The input element to which the panel will be attached and from where
	 *        search input will be taken.
	 * @param {DOMNode} clearBtn
	 *        The clear button in the input field that will clear the input value.
	 *
	 * Emits the following events:
	 * - search-cleared: when the search box is emptied
	 * - search-result: when a search is made and a result is selected
	 */
	function InspectorSearch(inspector, input, clearBtn) {
	  this.inspector = inspector;
	  this.searchBox = input;
	  this.searchClearButton = clearBtn;
	  this._lastSearched = null;

	  this.searchClearButton.hidden = true;

	  this._onKeyDown = this._onKeyDown.bind(this);
	  this._onInput = this._onInput.bind(this);
	  this._onClearSearch = this._onClearSearch.bind(this);
	  this._onFilterTextboxContextMenu =
	    this._onFilterTextboxContextMenu.bind(this);
	  this.searchBox.addEventListener("keydown", this._onKeyDown, true);
	  this.searchBox.addEventListener("input", this._onInput, true);
	  this.searchBox.addEventListener("contextmenu",
	    this._onFilterTextboxContextMenu);
	  this.searchClearButton.addEventListener("click", this._onClearSearch);

	  // For testing, we need to be able to wait for the most recent node request
	  // to finish.  Tests can watch this promise for that.
	  this._lastQuery = promise.resolve(null);

	  this.autocompleter = new SelectorAutocompleter(inspector, input);
	  EventEmitter.decorate(this);
	}

	exports.InspectorSearch = InspectorSearch;

	InspectorSearch.prototype = {
	  get walker() {
	    return this.inspector.walker;
	  },

	  destroy: function () {
	    this.searchBox.removeEventListener("keydown", this._onKeyDown, true);
	    this.searchBox.removeEventListener("input", this._onInput, true);
	    this.searchBox.removeEventListener("contextmenu",
	      this._onFilterTextboxContextMenu);
	    this.searchClearButton.removeEventListener("click", this._onClearSearch);
	    this.searchBox = null;
	    this.searchClearButton = null;
	    this.autocompleter.destroy();
	  },

	  _onSearch: function (reverse = false) {
	    this.doFullTextSearch(this.searchBox.value, reverse)
	        .catch(e => console.error(e));
	  },

	  doFullTextSearch: Task.async(function* (query, reverse) {
	    let lastSearched = this._lastSearched;
	    this._lastSearched = query;

	    if (query.length === 0) {
	      this.searchBox.classList.remove("devtools-style-searchbox-no-match");
	      if (!lastSearched || lastSearched.length > 0) {
	        this.emit("search-cleared");
	      }
	      return;
	    }

	    let res = yield this.walker.search(query, { reverse });

	    // Value has changed since we started this request, we're done.
	    if (query !== this.searchBox.value) {
	      return;
	    }

	    if (res) {
	      this.inspector.selection.setNodeFront(res.node, "inspectorsearch");
	      this.searchBox.classList.remove("devtools-style-searchbox-no-match");

	      res.query = query;
	      this.emit("search-result", res);
	    } else {
	      this.searchBox.classList.add("devtools-style-searchbox-no-match");
	      this.emit("search-result");
	    }
	  }),

	  _onInput: function () {
	    if (this.searchBox.value.length === 0) {
	      this.searchClearButton.hidden = true;
	      this.searchBox.removeAttribute("filled");
	      this._onSearch();
	    } else {
	      this.searchClearButton.hidden = false;
	      this.searchBox.setAttribute("filled", true);
	    }
	  },

	  _onKeyDown: function (event) {
	    if (event.keyCode === KeyCodes.DOM_VK_RETURN) {
	      this._onSearch(event.shiftKey);
	    }

	    const modifierKey = Services.appinfo.OS === "Darwin"
	                        ? event.metaKey : event.ctrlKey;
	    if (event.keyCode === KeyCodes.DOM_VK_G && modifierKey) {
	      this._onSearch(event.shiftKey);
	      event.preventDefault();
	    }
	  },

	  /**
	   * Context menu handler for filter search box.
	   */
	  _onFilterTextboxContextMenu: function (event) {
	    try {
	      let contextmenu = this.inspector.toolbox.textboxContextMenuPopup;
	      contextmenu.openPopupAtScreen(event.screenX, event.screenY, true);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  _onClearSearch: function () {
	    this.searchBox.classList.remove("devtools-style-searchbox-no-match");
	    this.searchBox.value = "";
	    this.searchClearButton.hidden = true;
	    this.emit("search-cleared");
	  }
	};

	/**
	 * Converts any input box on a page to a CSS selector search and suggestion box.
	 *
	 * Emits 'processing-done' event when it is done processing the current
	 * keypress, search request or selection from the list, whether that led to a
	 * search or not.
	 *
	 * @constructor
	 * @param InspectorPanel inspector
	 *        The InspectorPanel whose `walker` attribute should be used for
	 *        document traversal.
	 * @param nsiInputElement inputNode
	 *        The input element to which the panel will be attached and from where
	 *        search input will be taken.
	 */
	function SelectorAutocompleter(inspector, inputNode) {
	  this.inspector = inspector;
	  this.searchBox = inputNode;
	  this.panelDoc = this.searchBox.ownerDocument;

	  this.showSuggestions = this.showSuggestions.bind(this);
	  this._onSearchKeypress = this._onSearchKeypress.bind(this);
	  this._onSearchPopupClick = this._onSearchPopupClick.bind(this);
	  this._onMarkupMutation = this._onMarkupMutation.bind(this);

	  // Options for the AutocompletePopup.
	  let options = {
	    listId: "searchbox-panel-listbox",
	    autoSelect: true,
	    position: "top",
	    theme: "auto",
	    onClick: this._onSearchPopupClick,
	  };

	  this.searchPopup = new AutocompletePopup(inspector._toolbox, options);

	  this.searchBox.addEventListener("input", this.showSuggestions, true);
	  this.searchBox.addEventListener("keypress", this._onSearchKeypress, true);
	  this.inspector.on("markupmutation", this._onMarkupMutation);

	  // For testing, we need to be able to wait for the most recent node request
	  // to finish.  Tests can watch this promise for that.
	  this._lastQuery = promise.resolve(null);
	  EventEmitter.decorate(this);
	}

	exports.SelectorAutocompleter = SelectorAutocompleter;

	SelectorAutocompleter.prototype = {
	  get walker() {
	    return this.inspector.walker;
	  },

	  // The possible states of the query.
	  States: {
	    CLASS: "class",
	    ID: "id",
	    TAG: "tag",
	    ATTRIBUTE: "attribute",
	  },

	  // The current state of the query.
	  _state: null,

	  // The query corresponding to last state computation.
	  _lastStateCheckAt: null,

	  /**
	   * Computes the state of the query. State refers to whether the query
	   * currently requires a class suggestion, or a tag, or an Id suggestion.
	   * This getter will effectively compute the state by traversing the query
	   * character by character each time the query changes.
	   *
	   * @example
	   *        '#f' requires an Id suggestion, so the state is States.ID
	   *        'div > .foo' requires class suggestion, so state is States.CLASS
	   */
	  get state() {
	    if (!this.searchBox || !this.searchBox.value) {
	      return null;
	    }

	    let query = this.searchBox.value;
	    if (this._lastStateCheckAt == query) {
	      // If query is the same, return early.
	      return this._state;
	    }
	    this._lastStateCheckAt = query;

	    this._state = null;
	    let subQuery = "";
	    // Now we iterate over the query and decide the state character by
	    // character.
	    // The logic here is that while iterating, the state can go from one to
	    // another with some restrictions. Like, if the state is Class, then it can
	    // never go to Tag state without a space or '>' character; Or like, a Class
	    // state with only '.' cannot go to an Id state without any [a-zA-Z] after
	    // the '.' which means that '.#' is a selector matching a class name '#'.
	    // Similarily for '#.' which means a selctor matching an id '.'.
	    for (let i = 1; i <= query.length; i++) {
	      // Calculate the state.
	      subQuery = query.slice(0, i);
	      let [secondLastChar, lastChar] = subQuery.slice(-2);
	      switch (this._state) {
	        case null:
	          // This will happen only in the first iteration of the for loop.
	          lastChar = secondLastChar;

	        case this.States.TAG: // eslint-disable-line
	          if (lastChar === ".") {
	            this._state = this.States.CLASS;
	          } else if (lastChar === "#") {
	            this._state = this.States.ID;
	          } else if (lastChar === "[") {
	            this._state = this.States.ATTRIBUTE;
	          } else {
	            this._state = this.States.TAG;
	          }
	          break;

	        case this.States.CLASS:
	          if (subQuery.match(/[\.]+[^\.]*$/)[0].length > 2) {
	            // Checks whether the subQuery has atleast one [a-zA-Z] after the
	            // '.'.
	            if (lastChar === " " || lastChar === ">") {
	              this._state = this.States.TAG;
	            } else if (lastChar === "#") {
	              this._state = this.States.ID;
	            } else if (lastChar === "[") {
	              this._state = this.States.ATTRIBUTE;
	            } else {
	              this._state = this.States.CLASS;
	            }
	          }
	          break;

	        case this.States.ID:
	          if (subQuery.match(/[#]+[^#]*$/)[0].length > 2) {
	            // Checks whether the subQuery has atleast one [a-zA-Z] after the
	            // '#'.
	            if (lastChar === " " || lastChar === ">") {
	              this._state = this.States.TAG;
	            } else if (lastChar === ".") {
	              this._state = this.States.CLASS;
	            } else if (lastChar === "[") {
	              this._state = this.States.ATTRIBUTE;
	            } else {
	              this._state = this.States.ID;
	            }
	          }
	          break;

	        case this.States.ATTRIBUTE:
	          if (subQuery.match(/[\[][^\]]+[\]]/) !== null) {
	            // Checks whether the subQuery has at least one ']' after the '['.
	            if (lastChar === " " || lastChar === ">") {
	              this._state = this.States.TAG;
	            } else if (lastChar === ".") {
	              this._state = this.States.CLASS;
	            } else if (lastChar === "#") {
	              this._state = this.States.ID;
	            } else {
	              this._state = this.States.ATTRIBUTE;
	            }
	          }
	          break;
	      }
	    }
	    return this._state;
	  },

	  /**
	   * Removes event listeners and cleans up references.
	   */
	  destroy: function () {
	    this.searchBox.removeEventListener("input", this.showSuggestions, true);
	    this.searchBox.removeEventListener("keypress",
	      this._onSearchKeypress, true);
	    this.inspector.off("markupmutation", this._onMarkupMutation);
	    this.searchPopup.destroy();
	    this.searchPopup = null;
	    this.searchBox = null;
	    this.panelDoc = null;
	  },

	  /**
	   * Handles keypresses inside the input box.
	   */
	  _onSearchKeypress: function (event) {
	    let popup = this.searchPopup;

	    switch (event.keyCode) {
	      case KeyCodes.DOM_VK_RETURN:
	      case KeyCodes.DOM_VK_TAB:
	        if (popup.isOpen) {
	          if (popup.selectedItem) {
	            this.searchBox.value = popup.selectedItem.label;
	          }
	          this.hidePopup();
	        } else if (!popup.isOpen) {
	          // When tab is pressed with focus on searchbox and closed popup,
	          // do not prevent the default to avoid a keyboard trap and move focus
	          // to next/previous element.
	          this.emit("processing-done");
	          return;
	        }
	        break;

	      case KeyCodes.DOM_VK_UP:
	        if (popup.isOpen && popup.itemCount > 0) {
	          if (popup.selectedIndex === 0) {
	            popup.selectedIndex = popup.itemCount - 1;
	          } else {
	            popup.selectedIndex--;
	          }
	          this.searchBox.value = popup.selectedItem.label;
	        }
	        break;

	      case KeyCodes.DOM_VK_DOWN:
	        if (popup.isOpen && popup.itemCount > 0) {
	          if (popup.selectedIndex === popup.itemCount - 1) {
	            popup.selectedIndex = 0;
	          } else {
	            popup.selectedIndex++;
	          }
	          this.searchBox.value = popup.selectedItem.label;
	        }
	        break;

	      case KeyCodes.DOM_VK_ESCAPE:
	        if (popup.isOpen) {
	          this.hidePopup();
	        }
	        break;

	      default:
	        return;
	    }

	    event.preventDefault();
	    event.stopPropagation();
	    this.emit("processing-done");
	  },

	  /**
	   * Handles click events from the autocomplete popup.
	   */
	  _onSearchPopupClick: function (event) {
	    let selectedItem = this.searchPopup.selectedItem;
	    if (selectedItem) {
	      this.searchBox.value = selectedItem.label;
	    }
	    this.hidePopup();

	    event.preventDefault();
	    event.stopPropagation();
	  },

	  /**
	   * Reset previous search results on markup-mutations to make sure we search
	   * again after nodes have been added/removed/changed.
	   */
	  _onMarkupMutation: function () {
	    this._searchResults = null;
	    this._lastSearched = null;
	  },

	  /**
	   * Populates the suggestions list and show the suggestion popup.
	   *
	   * @return {Promise} promise that will resolve when the autocomplete popup is fully
	   * displayed or hidden.
	   */
	  _showPopup: function (list, firstPart, popupState) {
	    let total = 0;
	    let query = this.searchBox.value;
	    let items = [];

	    for (let [value, , state] of list) {
	      if (query.match(/[\s>+]$/)) {
	        // for cases like 'div ' or 'div >' or 'div+'
	        value = query + value;
	      } else if (query.match(/[\s>+][\.#a-zA-Z][^\s>+\.#\[]*$/)) {
	        // for cases like 'div #a' or 'div .a' or 'div > d' and likewise
	        let lastPart = query.match(/[\s>+][\.#a-zA-Z][^\s>+\.#\[]*$/)[0];
	        value = query.slice(0, -1 * lastPart.length + 1) + value;
	      } else if (query.match(/[a-zA-Z][#\.][^#\.\s+>]*$/)) {
	        // for cases like 'div.class' or '#foo.bar' and likewise
	        let lastPart = query.match(/[a-zA-Z][#\.][^#\.\s+>]*$/)[0];
	        value = query.slice(0, -1 * lastPart.length + 1) + value;
	      } else if (query.match(/[a-zA-Z]*\[[^\]]*\][^\]]*/)) {
	        // for cases like '[foo].bar' and likewise
	        let attrPart = query.substring(0, query.lastIndexOf("]") + 1);
	        value = attrPart + value;
	      }

	      let item = {
	        preLabel: query,
	        label: value
	      };

	      // In case the query's state is tag and the item's state is id or class
	      // adjust the preLabel
	      if (popupState === this.States.TAG && state === this.States.CLASS) {
	        item.preLabel = "." + item.preLabel;
	      }
	      if (popupState === this.States.TAG && state === this.States.ID) {
	        item.preLabel = "#" + item.preLabel;
	      }

	      items.unshift(item);
	      if (++total > MAX_SUGGESTIONS - 1) {
	        break;
	      }
	    }

	    if (total > 0) {
	      let onPopupOpened = this.searchPopup.once("popup-opened");
	      this.searchPopup.once("popup-closed", () => {
	        this.searchPopup.setItems(items);
	        this.searchPopup.openPopup(this.searchBox);
	      });
	      this.searchPopup.hidePopup();
	      return onPopupOpened;
	    }

	    return this.hidePopup();
	  },

	  /**
	   * Hide the suggestion popup if necessary.
	   */
	  hidePopup: function () {
	    let onPopupClosed = this.searchPopup.once("popup-closed");
	    this.searchPopup.hidePopup();
	    return onPopupClosed;
	  },

	  /**
	   * Suggests classes,ids and tags based on the user input as user types in the
	   * searchbox.
	   */
	  showSuggestions: function () {
	    let query = this.searchBox.value;
	    let state = this.state;
	    let firstPart = "";

	    if (query.endsWith("*") || state === this.States.ATTRIBUTE) {
	      // Hide the popup if the query ends with * (because we don't want to
	      // suggest all nodes) or if it is an attribute selector (because
	      // it would give a lot of useless results).
	      this.hidePopup();
	      return;
	    }

	    if (state === this.States.TAG) {
	      // gets the tag that is being completed. For ex. 'div.foo > s' returns
	      // 's', 'di' returns 'di' and likewise.
	      firstPart = (query.match(/[\s>+]?([a-zA-Z]*)$/) || ["", query])[1];
	      query = query.slice(0, query.length - firstPart.length);
	    } else if (state === this.States.CLASS) {
	      // gets the class that is being completed. For ex. '.foo.b' returns 'b'
	      firstPart = query.match(/\.([^\.]*)$/)[1];
	      query = query.slice(0, query.length - firstPart.length - 1);
	    } else if (state === this.States.ID) {
	      // gets the id that is being completed. For ex. '.foo#b' returns 'b'
	      firstPart = query.match(/#([^#]*)$/)[1];
	      query = query.slice(0, query.length - firstPart.length - 1);
	    }
	    // TODO: implement some caching so that over the wire request is not made
	    // everytime.
	    if (/[\s+>~]$/.test(query)) {
	      query += "*";
	    }

	    let suggestionsPromise = this.walker.getSuggestionsForQuery(
	      query, firstPart, state);
	    this._lastQuery = suggestionsPromise.then(result => {
	      this.emit("processing-done");
	      if (result.query !== query) {
	        // This means that this response is for a previous request and the user
	        // as since typed something extra leading to a new request.
	        return promise.resolve(null);
	      }

	      if (state === this.States.CLASS) {
	        firstPart = "." + firstPart;
	      } else if (state === this.States.ID) {
	        firstPart = "#" + firstPart;
	      }

	      // If there is a single tag match and it's what the user typed, then
	      // don't need to show a popup.
	      if (result.suggestions.length === 1 &&
	          result.suggestions[0][0] === firstPart) {
	        result.suggestions = [];
	      }

	      // Wait for the autocomplete-popup to fire its popup-opened event, to make sure
	      // the autoSelect item has been selected.
	      return this._showPopup(result.suggestions, firstPart, state);
	    });

	    return;
	  }
	};


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* globals template */

	"use strict";

	// Page size for pageup/pagedown
	const PAGE_SIZE = 10;
	const DEFAULT_MAX_CHILDREN = 100;
	const COLLAPSE_DATA_URL_REGEX = /^data.+base64/;
	const COLLAPSE_DATA_URL_LENGTH = 60;
	const NEW_SELECTION_HIGHLIGHTER_TIMER = 1000;
	const DRAG_DROP_AUTOSCROLL_EDGE_MAX_DISTANCE = 50;
	const DRAG_DROP_AUTOSCROLL_EDGE_RATIO = 0.1;
	const DRAG_DROP_MIN_AUTOSCROLL_SPEED = 2;
	const DRAG_DROP_MAX_AUTOSCROLL_SPEED = 8;
	const DRAG_DROP_MIN_INITIAL_DISTANCE = 10;
	const DRAG_DROP_HEIGHT_TO_SPEED = 500;
	const DRAG_DROP_HEIGHT_TO_SPEED_MIN = 0.5;
	const DRAG_DROP_HEIGHT_TO_SPEED_MAX = 1;
	const ATTR_COLLAPSE_ENABLED_PREF = "devtools.markup.collapseAttributes";
	const ATTR_COLLAPSE_LENGTH_PREF = "devtools.markup.collapseAttributeLength";
	const PREVIEW_MAX_DIM_PREF = "devtools.inspector.imagePreviewTooltipSize";

	// Contains only void (without end tag) HTML elements
	const HTML_VOID_ELEMENTS = [ "area", "base", "br", "col", "command", "embed",
	  "hr", "img", "input", "keygen", "link", "meta", "param", "source",
	  "track", "wbr" ];

	const {UndoStack} = __webpack_require__(168);
	const {editableField, InplaceEditor} =
	      __webpack_require__(154);
	const {HTMLEditor} = __webpack_require__(169);
	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);
	const Services = __webpack_require__(1);
	const {HTMLTooltip} = __webpack_require__(137);
	const {setImageTooltip, setBrokenImageTooltip} =
	      __webpack_require__(140);
	const {setEventTooltip} = __webpack_require__(184);
	const EventEmitter = __webpack_require__(6);
	const Heritage = __webpack_require__(20);
	const {parseAttribute} =
	      __webpack_require__(189);
	const {Task} = __webpack_require__(17);
	const {scrollIntoViewIfNeeded} = __webpack_require__(190);
	const {PrefObserver} = __webpack_require__(130);
	const {KeyShortcuts} = __webpack_require__(15);
	const {template} = __webpack_require__(191);
	const nodeConstants = __webpack_require__(33);
	const nodeFilterConstants = __webpack_require__(192);
	const {getCssProperties} = __webpack_require__(18);
	const {KeyCodes} = __webpack_require__(16);

	const {AutocompletePopup} = __webpack_require__(159);
	const clipboardHelper = __webpack_require__(158);

	const {PluralForm} = __webpack_require__(193);
	const {LocalizationHelper} = __webpack_require__(39);
	const INSPECTOR_L10N = new LocalizationHelper("devtools/locale/inspector.properties");

	/**
	 * Vocabulary for the purposes of this file:
	 *
	 * MarkupContainer - the structure that holds an editor and its
	 *  immediate children in the markup panel.
	 *  - MarkupElementContainer: markup container for element nodes
	 *  - MarkupTextContainer: markup container for text / comment nodes
	 *  - MarkupReadonlyContainer: markup container for other nodes
	 * Node - A content node.
	 * object.elt - A UI element in the markup panel.
	 */

	/**
	 * The markup tree.  Manages the mapping of nodes to MarkupContainers,
	 * updating based on mutations, and the undo/redo bindings.
	 *
	 * @param  {Inspector} inspector
	 *         The inspector we're watching.
	 * @param  {iframe} frame
	 *         An iframe in which the caller has kindly loaded markup.xhtml.
	 */
	function MarkupView(inspector, frame, controllerWindow) {
	  this._inspector = inspector;
	  this.walker = this._inspector.walker;
	  this._frame = frame;
	  this.win = this._frame.contentWindow;
	  this.doc = this._frame.contentDocument;
	  this._elt = this.doc.querySelector("#root");
	  this.htmlEditor = new HTMLEditor(this.doc);

	  try {
	    this.maxChildren = Services.prefs.getIntPref("devtools.markup.pagesize");
	  } catch (ex) {
	    this.maxChildren = DEFAULT_MAX_CHILDREN;
	  }

	  this.collapseAttributes =
	    Services.prefs.getBoolPref(ATTR_COLLAPSE_ENABLED_PREF);
	  this.collapseAttributeLength =
	    Services.prefs.getIntPref(ATTR_COLLAPSE_LENGTH_PREF);

	  // Creating the popup to be used to show CSS suggestions.
	  let options = {
	    autoSelect: true,
	    theme: "auto",
	  };

	  this.popup = new AutocompletePopup(inspector._toolbox, options);

	  this.undo = new UndoStack();
	  this.undo.installController(controllerWindow);

	  this._containers = new Map();

	  // Binding functions that need to be called in scope.
	  this._handleRejectionIfNotDestroyed = this._handleRejectionIfNotDestroyed.bind(this);
	  this._mutationObserver = this._mutationObserver.bind(this);
	  this._onDisplayChange = this._onDisplayChange.bind(this);
	  this._onMouseClick = this._onMouseClick.bind(this);
	  this._onMouseUp = this._onMouseUp.bind(this);
	  this._onNewSelection = this._onNewSelection.bind(this);
	  this._onCopy = this._onCopy.bind(this);
	  this._onFocus = this._onFocus.bind(this);
	  this._onMouseMove = this._onMouseMove.bind(this);
	  this._onMouseOut = this._onMouseOut.bind(this);
	  this._onToolboxPickerHover = this._onToolboxPickerHover.bind(this);
	  this._onCollapseAttributesPrefChange =
	    this._onCollapseAttributesPrefChange.bind(this);
	  this._isImagePreviewTarget = this._isImagePreviewTarget.bind(this);
	  this._onBlur = this._onBlur.bind(this);

	  EventEmitter.decorate(this);

	  // Listening to various events.
	  this._elt.addEventListener("click", this._onMouseClick, false);
	  this._elt.addEventListener("mousemove", this._onMouseMove, false);
	  this._elt.addEventListener("mouseout", this._onMouseOut, false);
	  this._elt.addEventListener("blur", this._onBlur, true);
	  this.win.addEventListener("mouseup", this._onMouseUp);
	  this.win.addEventListener("copy", this._onCopy);
	  this._frame.addEventListener("focus", this._onFocus, false);
	  this.walker.on("mutations", this._mutationObserver);
	  this.walker.on("display-change", this._onDisplayChange);
	  this._inspector.selection.on("new-node-front", this._onNewSelection);
	  this._inspector.toolbox.on("picker-node-hovered", this._onToolboxPickerHover);

	  this._onNewSelection();
	  this._initTooltips();

	  this._prefObserver = new PrefObserver("devtools.markup");
	  this._prefObserver.on(ATTR_COLLAPSE_ENABLED_PREF,
	                        this._onCollapseAttributesPrefChange);
	  this._prefObserver.on(ATTR_COLLAPSE_LENGTH_PREF,
	                        this._onCollapseAttributesPrefChange);

	  this._initShortcuts();
	}

	MarkupView.prototype = {
	  /**
	   * How long does a node flash when it mutates (in ms).
	   */
	  CONTAINER_FLASHING_DURATION: 500,

	  _selectedContainer: null,

	  /**
	   * Handle promise rejections for various asynchronous actions, and only log errors if
	   * the markup view still exists.
	   * This is useful to silence useless errors that happen when the markup view is
	   * destroyed while still initializing (and making protocol requests).
	   */
	  _handleRejectionIfNotDestroyed: function (e) {
	    if (!this._destroyer) {
	      console.error(e);
	    }
	  },

	  _initTooltips: function () {
	    this.eventDetailsTooltip = new HTMLTooltip(this._inspector.toolbox,
	      {type: "arrow"});
	    this.imagePreviewTooltip = new HTMLTooltip(this._inspector.toolbox,
	      {type: "arrow", useXulWrapper: "true"});
	    this._enableImagePreviewTooltip();
	  },

	  _enableImagePreviewTooltip: function () {
	    this.imagePreviewTooltip.startTogglingOnHover(this._elt,
	      this._isImagePreviewTarget);
	  },

	  _disableImagePreviewTooltip: function () {
	    this.imagePreviewTooltip.stopTogglingOnHover();
	  },

	  _onToolboxPickerHover: function (event, nodeFront) {
	    this.showNode(nodeFront).then(() => {
	      this._showContainerAsHovered(nodeFront);
	    }, e => console.error(e));
	  },

	  isDragging: false,

	  _onMouseMove: function (event) {
	    let target = event.target;

	    // Auto-scroll if we're dragging.
	    if (this.isDragging) {
	      event.preventDefault();
	      this._autoScroll(event);
	      return;
	    }

	    // Show the current container as hovered and highlight it.
	    // This requires finding the current MarkupContainer (walking up the DOM).
	    while (!target.container) {
	      if (target.tagName.toLowerCase() === "body") {
	        return;
	      }
	      target = target.parentNode;
	    }

	    let container = target.container;
	    if (this._hoveredNode !== container.node) {
	      if (container.node.nodeType !== nodeConstants.TEXT_NODE) {
	        this._showBoxModel(container.node);
	      } else {
	        this._hideBoxModel();
	      }
	    }
	    this._showContainerAsHovered(container.node);

	    this.emit("node-hover");
	  },

	  /**
	   * If focus is moved outside of the markup view document and there is a
	   * selected container, make its contents not focusable by a keyboard.
	   */
	  _onBlur: function (event) {
	    if (!this._selectedContainer) {
	      return;
	    }

	    let {relatedTarget} = event;
	    if (relatedTarget && relatedTarget.ownerDocument === this.doc) {
	      return;
	    }

	    if (this._selectedContainer) {
	      this._selectedContainer.clearFocus();
	    }
	  },

	  /**
	   * Executed on each mouse-move while a node is being dragged in the view.
	   * Auto-scrolls the view to reveal nodes below the fold to drop the dragged
	   * node in.
	   */
	  _autoScroll: function (event) {
	    let docEl = this.doc.documentElement;

	    if (this._autoScrollAnimationFrame) {
	      this.win.cancelAnimationFrame(this._autoScrollAnimationFrame);
	    }

	    // Auto-scroll when the mouse approaches top/bottom edge.
	    let fromBottom = docEl.clientHeight - event.pageY + this.win.scrollY;
	    let fromTop = event.pageY - this.win.scrollY;
	    let edgeDistance = Math.min(DRAG_DROP_AUTOSCROLL_EDGE_MAX_DISTANCE,
	           docEl.clientHeight * DRAG_DROP_AUTOSCROLL_EDGE_RATIO);

	    // The smaller the screen, the slower the movement.
	    let heightToSpeedRatio =
	      Math.max(DRAG_DROP_HEIGHT_TO_SPEED_MIN,
	        Math.min(DRAG_DROP_HEIGHT_TO_SPEED_MAX,
	          docEl.clientHeight / DRAG_DROP_HEIGHT_TO_SPEED));

	    if (fromBottom <= edgeDistance) {
	      // Map our distance range to a speed range so that the speed is not too
	      // fast or too slow.
	      let speed = map(
	        fromBottom,
	        0, edgeDistance,
	        DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);

	      this._runUpdateLoop(() => {
	        docEl.scrollTop -= heightToSpeedRatio *
	          (speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED);
	      });
	    }

	    if (fromTop <= edgeDistance) {
	      let speed = map(
	        fromTop,
	        0, edgeDistance,
	        DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);

	      this._runUpdateLoop(() => {
	        docEl.scrollTop += heightToSpeedRatio *
	          (speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED);
	      });
	    }
	  },

	  /**
	   * Run a loop on the requestAnimationFrame.
	   */
	  _runUpdateLoop: function (update) {
	    let loop = () => {
	      update();
	      this._autoScrollAnimationFrame = this.win.requestAnimationFrame(loop);
	    };
	    loop();
	  },

	  _onMouseClick: function (event) {
	    // From the target passed here, let's find the parent MarkupContainer
	    // and ask it if the tooltip should be shown
	    let parentNode = event.target;
	    let container;
	    while (parentNode !== this.doc.body) {
	      if (parentNode.container) {
	        container = parentNode.container;
	        break;
	      }
	      parentNode = parentNode.parentNode;
	    }

	    if (container instanceof MarkupElementContainer) {
	      // With the newly found container, delegate the tooltip content creation
	      // and decision to show or not the tooltip
	      container._buildEventTooltipContent(event.target,
	        this.eventDetailsTooltip);
	    }
	  },

	  _onMouseUp: function () {
	    this.indicateDropTarget(null);
	    this.indicateDragTarget(null);
	    if (this._autoScrollAnimationFrame) {
	      this.win.cancelAnimationFrame(this._autoScrollAnimationFrame);
	    }
	  },

	  _onCollapseAttributesPrefChange: function () {
	    this.collapseAttributes =
	      Services.prefs.getBoolPref(ATTR_COLLAPSE_ENABLED_PREF);
	    this.collapseAttributeLength =
	      Services.prefs.getIntPref(ATTR_COLLAPSE_LENGTH_PREF);
	    this.update();
	  },

	  cancelDragging: function () {
	    if (!this.isDragging) {
	      return;
	    }

	    for (let [, container] of this._containers) {
	      if (container.isDragging) {
	        container.cancelDragging();
	        break;
	      }
	    }

	    this.indicateDropTarget(null);
	    this.indicateDragTarget(null);
	    if (this._autoScrollAnimationFrame) {
	      this.win.cancelAnimationFrame(this._autoScrollAnimationFrame);
	    }
	  },

	  _hoveredNode: null,

	  /**
	   * Show a NodeFront's container as being hovered
	   *
	   * @param  {NodeFront} nodeFront
	   *         The node to show as hovered
	   */
	  _showContainerAsHovered: function (nodeFront) {
	    if (this._hoveredNode === nodeFront) {
	      return;
	    }

	    if (this._hoveredNode) {
	      this.getContainer(this._hoveredNode).hovered = false;
	    }

	    this.getContainer(nodeFront).hovered = true;
	    this._hoveredNode = nodeFront;
	  },

	  _onMouseOut: function (event) {
	    // Emulate mouseleave by skipping any relatedTarget inside the markup-view.
	    if (this._elt.contains(event.relatedTarget)) {
	      return;
	    }

	    if (this._autoScrollAnimationFrame) {
	      this.win.cancelAnimationFrame(this._autoScrollAnimationFrame);
	    }
	    if (this.isDragging) {
	      return;
	    }

	    this._hideBoxModel(true);
	    if (this._hoveredNode) {
	      this.getContainer(this._hoveredNode).hovered = false;
	    }
	    this._hoveredNode = null;

	    this.emit("leave");
	  },

	  /**
	   * Show the box model highlighter on a given node front
	   *
	   * @param  {NodeFront} nodeFront
	   *         The node to show the highlighter for
	   * @return {Promise} Resolves when the highlighter for this nodeFront is
	   *         shown, taking into account that there could already be highlighter
	   *         requests queued up
	   */
	  _showBoxModel: function (nodeFront) {
	    return this._inspector.toolbox.highlighterUtils
	      .highlightNodeFront(nodeFront);
	  },

	  /**
	   * Hide the box model highlighter on a given node front
	   *
	   * @param  {NodeFront} nodeFront
	   *         The node to hide the highlighter for
	   * @param  {Boolean} forceHide
	   *         See toolbox-highlighter-utils/unhighlight
	   * @return {Promise} Resolves when the highlighter for this nodeFront is
	   *         hidden, taking into account that there could already be highlighter
	   *         requests queued up
	   */
	  _hideBoxModel: function (forceHide) {
	    return this._inspector.toolbox.highlighterUtils.unhighlight(forceHide);
	  },

	  _briefBoxModelTimer: null,

	  _clearBriefBoxModelTimer: function () {
	    if (this._briefBoxModelTimer) {
	      clearTimeout(this._briefBoxModelTimer);
	      this._briefBoxModelPromise.resolve();
	      this._briefBoxModelPromise = null;
	      this._briefBoxModelTimer = null;
	    }
	  },

	  _brieflyShowBoxModel: function (nodeFront) {
	    this._clearBriefBoxModelTimer();
	    let onShown = this._showBoxModel(nodeFront);
	    this._briefBoxModelPromise = defer();

	    this._briefBoxModelTimer = setTimeout(() => {
	      this._hideBoxModel()
	          .then(this._briefBoxModelPromise.resolve,
	                this._briefBoxModelPromise.resolve);
	    }, NEW_SELECTION_HIGHLIGHTER_TIMER);

	    return promise.all([onShown, this._briefBoxModelPromise.promise]);
	  },

	  template: function (name, dest, options = {stack: "markup.xhtml"}) {
	    let node = this.doc.getElementById("template-" + name).cloneNode(true);
	    node.removeAttribute("id");
	    template(node, dest, options);
	    return node;
	  },

	  /**
	   * Get the MarkupContainer object for a given node, or undefined if
	   * none exists.
	   */
	  getContainer: function (node) {
	    return this._containers.get(node);
	  },

	  update: function () {
	    let updateChildren = (node) => {
	      this.getContainer(node).update();
	      for (let child of node.treeChildren()) {
	        updateChildren(child);
	      }
	    };

	    // Start with the documentElement
	    let documentElement;
	    for (let node of this._rootNode.treeChildren()) {
	      if (node.isDocumentElement === true) {
	        documentElement = node;
	        break;
	      }
	    }

	    // Recursively update each node starting with documentElement.
	    updateChildren(documentElement);
	  },

	  /**
	   * Executed when the mouse hovers over a target in the markup-view and is used
	   * to decide whether this target should be used to display an image preview
	   * tooltip.
	   * Delegates the actual decision to the corresponding MarkupContainer instance
	   * if one is found.
	   *
	   * @return {Promise} the promise returned by
	   *         MarkupElementContainer._isImagePreviewTarget
	   */
	  _isImagePreviewTarget: Task.async(function* (target) {
	    // From the target passed here, let's find the parent MarkupContainer
	    // and ask it if the tooltip should be shown
	    if (this.isDragging) {
	      return false;
	    }

	    let parent = target, container;
	    while (parent !== this.doc.body) {
	      if (parent.container) {
	        container = parent.container;
	        break;
	      }
	      parent = parent.parentNode;
	    }

	    if (container instanceof MarkupElementContainer) {
	      // With the newly found container, delegate the tooltip content creation
	      // and decision to show or not the tooltip
	      return container.isImagePreviewTarget(target, this.imagePreviewTooltip);
	    }

	    return false;
	  }),

	  /**
	   * Given the known reason, should the current selection be briefly highlighted
	   * In a few cases, we don't want to highlight the node:
	   * - If the reason is null (used to reset the selection),
	   * - if it's "inspector-open" (when the inspector opens up, let's not
	   * highlight the default node)
	   * - if it's "navigateaway" (since the page is being navigated away from)
	   * - if it's "test" (this is a special case for mochitest. In tests, we often
	   * need to select elements but don't necessarily want the highlighter to come
	   * and go after a delay as this might break test scenarios)
	   * We also do not want to start a brief highlight timeout if the node is
	   * already being hovered over, since in that case it will already be
	   * highlighted.
	   */
	  _shouldNewSelectionBeHighlighted: function () {
	    let reason = this._inspector.selection.reason;
	    let unwantedReasons = [
	      "inspector-open",
	      "navigateaway",
	      "nodeselected",
	      "test"
	    ];
	    let isHighlight = this._hoveredNode === this._inspector.selection.nodeFront;
	    return !isHighlight && reason && unwantedReasons.indexOf(reason) === -1;
	  },

	  /**
	   * React to new-node-front selection events.
	   * Highlights the node if needed, and make sure it is shown and selected in
	   * the view.
	   */
	  _onNewSelection: function () {
	    let selection = this._inspector.selection;

	    this.htmlEditor.hide();
	    if (this._hoveredNode && this._hoveredNode !== selection.nodeFront) {
	      this.getContainer(this._hoveredNode).hovered = false;
	      this._hoveredNode = null;
	    }

	    if (!selection.isNode()) {
	      this.unmarkSelectedNode();
	      return;
	    }

	    let done = this._inspector.updating("markup-view");
	    let onShowBoxModel, onShow;

	    // Highlight the element briefly if needed.
	    if (this._shouldNewSelectionBeHighlighted()) {
	      onShowBoxModel = this._brieflyShowBoxModel(selection.nodeFront);
	    }

	    onShow = this.showNode(selection.nodeFront).then(() => {
	      // We could be destroyed by now.
	      if (this._destroyer) {
	        return promise.reject("markupview destroyed");
	      }

	      // Mark the node as selected.
	      this.markNodeAsSelected(selection.nodeFront);

	      // Make sure the new selection is navigated to.
	      this.maybeNavigateToNewSelection();
	      return undefined;
	    }).catch(this._handleRejectionIfNotDestroyed);

	    promise.all([onShowBoxModel, onShow]).then(done);
	  },

	  /**
	   * Maybe make selected the current node selection's MarkupContainer depending
	   * on why the current node got selected.
	   */
	  maybeNavigateToNewSelection: function () {
	    let {reason, nodeFront} = this._inspector.selection;

	    // The list of reasons that should lead to navigating to the node.
	    let reasonsToNavigate = [
	      // If the user picked an element with the element picker.
	      "picker-node-picked",
	      // If the user selected an element with the browser context menu.
	      "browser-context-menu",
	      // If the user added a new node by clicking in the inspector toolbar.
	      "node-inserted"
	    ];

	    if (reasonsToNavigate.includes(reason)) {
	      this.getContainer(this._rootNode).elt.focus();
	      this.navigate(this.getContainer(nodeFront));
	    }
	  },

	  /**
	   * Create a TreeWalker to find the next/previous
	   * node for selection.
	   */
	  _selectionWalker: function (start) {
	    let walker = this.doc.createTreeWalker(
	      start || this._elt,
	      nodeFilterConstants.SHOW_ELEMENT,
	      function (element) {
	        if (element.container &&
	            element.container.elt === element &&
	            element.container.visible) {
	          return nodeFilterConstants.FILTER_ACCEPT;
	        }
	        return nodeFilterConstants.FILTER_SKIP;
	      }
	    );
	    walker.currentNode = this._selectedContainer.elt;
	    return walker;
	  },

	  _onCopy: function (evt) {
	    // Ignore copy events from editors
	    if (this._isInputOrTextarea(evt.target)) {
	      return;
	    }

	    let selection = this._inspector.selection;
	    if (selection.isNode()) {
	      this._inspector.copyOuterHTML();
	    }
	    evt.stopPropagation();
	    evt.preventDefault();
	  },

	  /**
	   * Register all key shortcuts.
	   */
	  _initShortcuts: function () {
	    let shortcuts = new KeyShortcuts({
	      window: this.win,
	    });

	    this._onShortcut = this._onShortcut.bind(this);

	    // Process localizable keys
	    ["markupView.hide.key",
	     "markupView.edit.key",
	     "markupView.scrollInto.key"].forEach(name => {
	       let key = INSPECTOR_L10N.getStr(name);
	       shortcuts.on(key, (_, event) => this._onShortcut(name, event));
	     });

	    // Process generic keys:
	    ["Delete", "Backspace", "Home", "Left", "Right", "Up", "Down", "PageUp",
	     "PageDown", "Esc", "Enter", "Space"].forEach(key => {
	       shortcuts.on(key, this._onShortcut);
	     });
	  },

	  /**
	   * Key shortcut listener.
	   */
	  _onShortcut(name, event) {
	    if (this._isInputOrTextarea(event.target)) {
	      return;
	    }
	    switch (name) {
	      // Localizable keys
	      case "markupView.hide.key": {
	        let node = this._selectedContainer.node;
	        if (node.hidden) {
	          this.walker.unhideNode(node);
	        } else {
	          this.walker.hideNode(node);
	        }
	        break;
	      }
	      case "markupView.edit.key": {
	        this.beginEditingOuterHTML(this._selectedContainer.node);
	        break;
	      }
	      case "markupView.scrollInto.key": {
	        let selection = this._selectedContainer.node;
	        this._inspector.scrollNodeIntoView(selection);
	        break;
	      }
	      // Generic keys
	      case "Delete": {
	        this.deleteNodeOrAttribute();
	        break;
	      }
	      case "Backspace": {
	        this.deleteNodeOrAttribute(true);
	        break;
	      }
	      case "Home": {
	        let rootContainer = this.getContainer(this._rootNode);
	        this.navigate(rootContainer.children.firstChild.container);
	        break;
	      }
	      case "Left": {
	        if (this._selectedContainer.expanded) {
	          this.collapseNode(this._selectedContainer.node);
	        } else {
	          let parent = this._selectionWalker().parentNode();
	          if (parent) {
	            this.navigate(parent.container);
	          }
	        }
	        break;
	      }
	      case "Right": {
	        if (!this._selectedContainer.expanded &&
	            this._selectedContainer.hasChildren) {
	          this._expandContainer(this._selectedContainer);
	        } else {
	          let next = this._selectionWalker().nextNode();
	          if (next) {
	            this.navigate(next.container);
	          }
	        }
	        break;
	      }
	      case "Up": {
	        let previousNode = this._selectionWalker().previousNode();
	        if (previousNode) {
	          this.navigate(previousNode.container);
	        }
	        break;
	      }
	      case "Down": {
	        let nextNode = this._selectionWalker().nextNode();
	        if (nextNode) {
	          this.navigate(nextNode.container);
	        }
	        break;
	      }
	      case "PageUp": {
	        let walker = this._selectionWalker();
	        let selection = this._selectedContainer;
	        for (let i = 0; i < PAGE_SIZE; i++) {
	          let previousNode = walker.previousNode();
	          if (!previousNode) {
	            break;
	          }
	          selection = previousNode.container;
	        }
	        this.navigate(selection);
	        break;
	      }
	      case "PageDown": {
	        let walker = this._selectionWalker();
	        let selection = this._selectedContainer;
	        for (let i = 0; i < PAGE_SIZE; i++) {
	          let nextNode = walker.nextNode();
	          if (!nextNode) {
	            break;
	          }
	          selection = nextNode.container;
	        }
	        this.navigate(selection);
	        break;
	      }
	      case "Enter":
	      case "Space": {
	        if (!this._selectedContainer.canFocus) {
	          this._selectedContainer.canFocus = true;
	          this._selectedContainer.focus();
	        } else {
	          // Return early to prevent cancelling the event.
	          return;
	        }
	        break;
	      }
	      case "Esc": {
	        if (this.isDragging) {
	          this.cancelDragging();
	        } else {
	          // Return early to prevent cancelling the event when not
	          // dragging, to allow the split console to be toggled.
	          return;
	        }
	        break;
	      }
	      default:
	        console.error("Unexpected markup-view key shortcut", name);
	        return;
	    }
	    // Prevent default for this action
	    event.stopPropagation();
	    event.preventDefault();
	  },

	  /**
	   * Check if a node is an input or textarea
	   */
	  _isInputOrTextarea: function (element) {
	    let name = element.tagName.toLowerCase();
	    return name === "input" || name === "textarea";
	  },

	  /**
	   * If there's an attribute on the current node that's currently focused, then
	   * delete this attribute, otherwise delete the node itself.
	   *
	   * @param  {Boolean} moveBackward
	   *         If set to true and if we're deleting the node, focus the previous
	   *         sibling after deletion, otherwise the next one.
	   */
	  deleteNodeOrAttribute: function (moveBackward) {
	    let focusedAttribute = this.doc.activeElement
	                           ? this.doc.activeElement.closest(".attreditor")
	                           : null;
	    if (focusedAttribute) {
	      // The focused attribute might not be in the current selected container.
	      let container = focusedAttribute.closest("li.child").container;
	      container.removeAttribute(focusedAttribute.dataset.attr);
	    } else {
	      this.deleteNode(this._selectedContainer.node, moveBackward);
	    }
	  },

	  /**
	   * Delete a node from the DOM.
	   * This is an undoable action.
	   *
	   * @param  {NodeFront} node
	   *         The node to remove.
	   * @param  {Boolean} moveBackward
	   *         If set to true, focus the previous sibling, otherwise the next one.
	   */
	  deleteNode: function (node, moveBackward) {
	    if (node.isDocumentElement ||
	        node.nodeType == nodeConstants.DOCUMENT_TYPE_NODE ||
	        node.isAnonymous) {
	      return;
	    }

	    let container = this.getContainer(node);

	    // Retain the node so we can undo this...
	    this.walker.retainNode(node).then(() => {
	      let parent = node.parentNode();
	      let nextSibling = null;
	      this.undo.do(() => {
	        this.walker.removeNode(node).then(siblings => {
	          nextSibling = siblings.nextSibling;
	          let prevSibling = siblings.previousSibling;
	          let focusNode = moveBackward ? prevSibling : nextSibling;

	          // If we can't move as the user wants, we move to the other direction.
	          // If there is no sibling elements anymore, move to the parent node.
	          if (!focusNode) {
	            focusNode = nextSibling || prevSibling || parent;
	          }

	          let isNextSiblingText = nextSibling ?
	            nextSibling.nodeType === nodeConstants.TEXT_NODE : false;
	          let isPrevSiblingText = prevSibling ?
	            prevSibling.nodeType === nodeConstants.TEXT_NODE : false;

	          // If the parent had two children and the next or previous sibling
	          // is a text node, then it now has only a single text node, is about
	          // to be in-lined; and focus should move to the parent.
	          if (parent.numChildren === 2
	              && (isNextSiblingText || isPrevSiblingText)) {
	            focusNode = parent;
	          }

	          if (container.selected) {
	            this.navigate(this.getContainer(focusNode));
	          }
	        });
	      }, () => {
	        let isValidSibling = nextSibling && !nextSibling.isPseudoElement;
	        nextSibling = isValidSibling ? nextSibling : null;
	        this.walker.insertBefore(node, parent, nextSibling);
	      });
	    }).then(null, console.error);
	  },

	  /**
	   * If an editable item is focused, select its container.
	   */
	  _onFocus: function (event) {
	    let parent = event.target;
	    while (!parent.container) {
	      parent = parent.parentNode;
	    }
	    if (parent) {
	      this.navigate(parent.container);
	    }
	  },

	  /**
	   * Handle a user-requested navigation to a given MarkupContainer,
	   * updating the inspector's currently-selected node.
	   *
	   * @param  {MarkupContainer} container
	   *         The container we're navigating to.
	   */
	  navigate: function (container) {
	    if (!container) {
	      return;
	    }

	    let node = container.node;
	    this.markNodeAsSelected(node, "treepanel");
	  },

	  /**
	   * Make sure a node is included in the markup tool.
	   *
	   * @param  {NodeFront} node
	   *         The node in the content document.
	   * @param  {Boolean} flashNode
	   *         Whether the newly imported node should be flashed
	   * @return {MarkupContainer} The MarkupContainer object for this element.
	   */
	  importNode: function (node, flashNode) {
	    if (!node) {
	      return null;
	    }

	    if (this._containers.has(node)) {
	      return this.getContainer(node);
	    }

	    let container;
	    let {nodeType, isPseudoElement} = node;
	    if (node === this.walker.rootNode) {
	      container = new RootContainer(this, node);
	      this._elt.appendChild(container.elt);
	      this._rootNode = node;
	    } else if (nodeType == nodeConstants.ELEMENT_NODE && !isPseudoElement) {
	      container = new MarkupElementContainer(this, node, this._inspector);
	    } else if (nodeType == nodeConstants.COMMENT_NODE ||
	               nodeType == nodeConstants.TEXT_NODE) {
	      container = new MarkupTextContainer(this, node, this._inspector);
	    } else {
	      container = new MarkupReadOnlyContainer(this, node, this._inspector);
	    }

	    if (flashNode) {
	      container.flashMutation();
	    }

	    this._containers.set(node, container);
	    container.childrenDirty = true;

	    this._updateChildren(container);

	    this._inspector.emit("container-created", container);

	    return container;
	  },

	  /**
	   * Mutation observer used for included nodes.
	   */
	  _mutationObserver: function (mutations) {
	    for (let mutation of mutations) {
	      let type = mutation.type;
	      let target = mutation.target;

	      if (mutation.type === "documentUnload") {
	        // Treat this as a childList change of the child (maybe the protocol
	        // should do this).
	        type = "childList";
	        target = mutation.targetParent;
	        if (!target) {
	          continue;
	        }
	      }

	      let container = this.getContainer(target);
	      if (!container) {
	        // Container might not exist if this came from a load event for a node
	        // we're not viewing.
	        continue;
	      }

	      if (type === "attributes" && mutation.attributeName === "class") {
	        container.updateIsDisplayed();
	      }
	      if (type === "attributes" || type === "characterData"
	        || type === "events" || type === "pseudoClassLock") {
	        container.update();
	      } else if (type === "childList" || type === "nativeAnonymousChildList") {
	        container.childrenDirty = true;
	        // Update the children to take care of changes in the markup view DOM
	        // and update container (and its subtree) DOM tree depth level for
	        // accessibility where necessary.
	        this._updateChildren(container, {flash: true}).then(() =>
	          container.updateLevel());
	      } else if (type === "inlineTextChild") {
	        container.childrenDirty = true;
	        this._updateChildren(container, {flash: true});
	        container.update();
	      }
	    }

	    this._waitForChildren().then(() => {
	      if (this._destroyer) {
	        // Could not fully update after markup mutations, the markup-view was destroyed
	        // while waiting for children. Bail out silently.
	        return;
	      }
	      this._flashMutatedNodes(mutations);
	      this._inspector.emit("markupmutation", mutations);

	      // Since the htmlEditor is absolutely positioned, a mutation may change
	      // the location in which it should be shown.
	      this.htmlEditor.refresh();
	    });
	  },

	  /**
	   * React to display-change events from the walker
	   *
	   * @param  {Array} nodes
	   *         An array of nodeFronts
	   */
	  _onDisplayChange: function (nodes) {
	    for (let node of nodes) {
	      let container = this.getContainer(node);
	      if (container) {
	        container.updateIsDisplayed();
	      }
	    }
	  },

	  /**
	   * Given a list of mutations returned by the mutation observer, flash the
	   * corresponding containers to attract attention.
	   */
	  _flashMutatedNodes: function (mutations) {
	    let addedOrEditedContainers = new Set();
	    let removedContainers = new Set();

	    for (let {type, target, added, removed, newValue} of mutations) {
	      let container = this.getContainer(target);

	      if (container) {
	        if (type === "characterData") {
	          addedOrEditedContainers.add(container);
	        } else if (type === "attributes" && newValue === null) {
	          // Removed attributes should flash the entire node.
	          // New or changed attributes will flash the attribute itself
	          // in ElementEditor.flashAttribute.
	          addedOrEditedContainers.add(container);
	        } else if (type === "childList") {
	          // If there has been removals, flash the parent
	          if (removed.length) {
	            removedContainers.add(container);
	          }

	          // If there has been additions, flash the nodes if their associated
	          // container exist (so if their parent is expanded in the inspector).
	          added.forEach(node => {
	            let addedContainer = this.getContainer(node);
	            if (addedContainer) {
	              addedOrEditedContainers.add(addedContainer);

	              // The node may be added as a result of an append, in which case
	              // it will have been removed from another container first, but in
	              // these cases we don't want to flash both the removal and the
	              // addition
	              removedContainers.delete(container);
	            }
	          });
	        }
	      }
	    }

	    for (let container of removedContainers) {
	      container.flashMutation();
	    }
	    for (let container of addedOrEditedContainers) {
	      container.flashMutation();
	    }
	  },

	  /**
	   * Make sure the given node's parents are expanded and the
	   * node is scrolled on to screen.
	   */
	  showNode: function (node, centered = true) {
	    let parent = node;

	    this.importNode(node);

	    while ((parent = parent.parentNode())) {
	      this.importNode(parent);
	      this.expandNode(parent);
	    }

	    return this._waitForChildren().then(() => {
	      if (this._destroyer) {
	        return promise.reject("markupview destroyed");
	      }
	      return this._ensureVisible(node);
	    }).then(() => {
	      scrollIntoViewIfNeeded(this.getContainer(node).editor.elt, centered);
	    }, this._handleRejectionIfNotDestroyed);
	  },

	  /**
	   * Expand the container's children.
	   */
	  _expandContainer: function (container) {
	    return this._updateChildren(container, {expand: true}).then(() => {
	      if (this._destroyer) {
	        // Could not expand the node, the markup-view was destroyed in the meantime. Just
	        // silently give up.
	        return;
	      }
	      container.setExpanded(true);
	    });
	  },

	  /**
	   * Expand the node's children.
	   */
	  expandNode: function (node) {
	    let container = this.getContainer(node);
	    this._expandContainer(container);
	  },

	  /**
	   * Expand the entire tree beneath a container.
	   *
	   * @param  {MarkupContainer} container
	   *         The container to expand.
	   */
	  _expandAll: function (container) {
	    return this._expandContainer(container).then(() => {
	      let child = container.children.firstChild;
	      let promises = [];
	      while (child) {
	        promises.push(this._expandAll(child.container));
	        child = child.nextSibling;
	      }
	      return promise.all(promises);
	    }).then(null, console.error);
	  },

	  /**
	   * Expand the entire tree beneath a node.
	   *
	   * @param  {DOMNode} node
	   *         The node to expand, or null to start from the top.
	   */
	  expandAll: function (node) {
	    node = node || this._rootNode;
	    return this._expandAll(this.getContainer(node));
	  },

	  /**
	   * Collapse the node's children.
	   */
	  collapseNode: function (node) {
	    let container = this.getContainer(node);
	    container.setExpanded(false);
	  },

	  /**
	   * Returns either the innerHTML or the outerHTML for a remote node.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to get the outerHTML / innerHTML for.
	   * @param  {Boolean} isOuter
	   *         If true, makes the function return the outerHTML,
	   *         otherwise the innerHTML.
	   * @return {Promise} that will be resolved with the outerHTML / innerHTML.
	   */
	  _getNodeHTML: function (node, isOuter) {
	    let walkerPromise = null;

	    if (isOuter) {
	      walkerPromise = this.walker.outerHTML(node);
	    } else {
	      walkerPromise = this.walker.innerHTML(node);
	    }

	    return walkerPromise.then(longstr => {
	      return longstr.string().then(html => {
	        longstr.release().then(null, console.error);
	        return html;
	      });
	    });
	  },

	  /**
	   * Retrieve the outerHTML for a remote node.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to get the outerHTML for.
	   * @return {Promise} that will be resolved with the outerHTML.
	   */
	  getNodeOuterHTML: function (node) {
	    return this._getNodeHTML(node, true);
	  },

	  /**
	   * Retrieve the innerHTML for a remote node.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to get the innerHTML for.
	   * @return {Promise} that will be resolved with the innerHTML.
	   */
	  getNodeInnerHTML: function (node) {
	    return this._getNodeHTML(node);
	  },

	  /**
	   * Listen to mutations, expect a given node to be removed and try and select
	   * the node that sits at the same place instead.
	   * This is useful when changing the outerHTML or the tag name so that the
	   * newly inserted node gets selected instead of the one that just got removed.
	   */
	  reselectOnRemoved: function (removedNode, reason) {
	    // Only allow one removed node reselection at a time, so that when there are
	    // more than 1 request in parallel, the last one wins.
	    this.cancelReselectOnRemoved();

	    // Get the removedNode index in its parent node to reselect the right node.
	    let isHTMLTag = removedNode.tagName.toLowerCase() === "html";
	    let oldContainer = this.getContainer(removedNode);
	    let parentContainer = this.getContainer(removedNode.parentNode());
	    let childIndex = parentContainer.getChildContainers().indexOf(oldContainer);

	    let onMutations = this._removedNodeObserver = (e, mutations) => {
	      let isNodeRemovalMutation = false;
	      for (let mutation of mutations) {
	        let containsRemovedNode = mutation.removed &&
	                                  mutation.removed.some(n => n === removedNode);
	        if (mutation.type === "childList" &&
	            (containsRemovedNode || isHTMLTag)) {
	          isNodeRemovalMutation = true;
	          break;
	        }
	      }
	      if (!isNodeRemovalMutation) {
	        return;
	      }

	      this._inspector.off("markupmutation", onMutations);
	      this._removedNodeObserver = null;

	      // Don't select the new node if the user has already changed the current
	      // selection.
	      if (this._inspector.selection.nodeFront === parentContainer.node ||
	          (this._inspector.selection.nodeFront === removedNode && isHTMLTag)) {
	        let childContainers = parentContainer.getChildContainers();
	        if (childContainers && childContainers[childIndex]) {
	          this.markNodeAsSelected(childContainers[childIndex].node, reason);
	          if (childContainers[childIndex].hasChildren) {
	            this.expandNode(childContainers[childIndex].node);
	          }
	          this.emit("reselectedonremoved");
	        }
	      }
	    };

	    // Start listening for mutations until we find a childList change that has
	    // removedNode removed.
	    this._inspector.on("markupmutation", onMutations);
	  },

	  /**
	   * Make sure to stop listening for node removal markupmutations and not
	   * reselect the corresponding node when that happens.
	   * Useful when the outerHTML/tagname edition failed.
	   */
	  cancelReselectOnRemoved: function () {
	    if (this._removedNodeObserver) {
	      this._inspector.off("markupmutation", this._removedNodeObserver);
	      this._removedNodeObserver = null;
	      this.emit("canceledreselectonremoved");
	    }
	  },

	  /**
	   * Replace the outerHTML of any node displayed in the inspector with
	   * some other HTML code
	   *
	   * @param  {NodeFront} node
	   *         Node which outerHTML will be replaced.
	   * @param  {String} newValue
	   *         The new outerHTML to set on the node.
	   * @param  {String} oldValue
	   *         The old outerHTML that will be used if the user undoes the update.
	   * @return {Promise} that will resolve when the outer HTML has been updated.
	   */
	  updateNodeOuterHTML: function (node, newValue) {
	    let container = this.getContainer(node);
	    if (!container) {
	      return promise.reject();
	    }

	    // Changing the outerHTML removes the node which outerHTML was changed.
	    // Listen to this removal to reselect the right node afterwards.
	    this.reselectOnRemoved(node, "outerhtml");
	    return this.walker.setOuterHTML(node, newValue).then(null, () => {
	      this.cancelReselectOnRemoved();
	    });
	  },

	  /**
	   * Replace the innerHTML of any node displayed in the inspector with
	   * some other HTML code
	   * @param  {Node} node
	   *         node which innerHTML will be replaced.
	   * @param  {String} newValue
	   *         The new innerHTML to set on the node.
	   * @param  {String} oldValue
	   *         The old innerHTML that will be used if the user undoes the update.
	   * @return {Promise} that will resolve when the inner HTML has been updated.
	   */
	  updateNodeInnerHTML: function (node, newValue, oldValue) {
	    let container = this.getContainer(node);
	    if (!container) {
	      return promise.reject();
	    }

	    let def = defer();

	    container.undo.do(() => {
	      this.walker.setInnerHTML(node, newValue).then(def.resolve, def.reject);
	    }, () => {
	      this.walker.setInnerHTML(node, oldValue);
	    });

	    return def.promise;
	  },

	  /**
	   * Insert adjacent HTML to any node displayed in the inspector.
	   *
	   * @param  {NodeFront} node
	   *         The reference node.
	   * @param  {String} position
	   *         The position as specified for Element.insertAdjacentHTML
	   *         (i.e. "beforeBegin", "afterBegin", "beforeEnd", "afterEnd").
	   * @param  {String} newValue
	   *         The adjacent HTML.
	   * @return {Promise} that will resolve when the adjacent HTML has
	   *         been inserted.
	   */
	  insertAdjacentHTMLToNode: function (node, position, value) {
	    let container = this.getContainer(node);
	    if (!container) {
	      return promise.reject();
	    }

	    let def = defer();

	    let injectedNodes = [];
	    container.undo.do(() => {
	      this.walker.insertAdjacentHTML(node, position, value).then(nodeArray => {
	        injectedNodes = nodeArray.nodes;
	        return nodeArray;
	      }).then(def.resolve, def.reject);
	    }, () => {
	      this.walker.removeNodes(injectedNodes);
	    });

	    return def.promise;
	  },

	  /**
	   * Open an editor in the UI to allow editing of a node's outerHTML.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to edit.
	   */
	  beginEditingOuterHTML: function (node) {
	    this.getNodeOuterHTML(node).then(oldValue => {
	      let container = this.getContainer(node);
	      if (!container) {
	        return;
	      }
	      this.htmlEditor.show(container.tagLine, oldValue);
	      this.htmlEditor.once("popuphidden", (e, commit, value) => {
	        // Need to focus the <html> element instead of the frame / window
	        // in order to give keyboard focus back to doc (from editor).
	        this.doc.documentElement.focus();

	        if (commit) {
	          this.updateNodeOuterHTML(node, value, oldValue);
	        }
	      });
	    });
	  },

	  /**
	   * Mark the given node expanded.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to mark as expanded.
	   * @param  {Boolean} expanded
	   *         Whether the expand or collapse.
	   * @param  {Boolean} expandDescendants
	   *         Whether to expand all descendants too
	   */
	  setNodeExpanded: function (node, expanded, expandDescendants) {
	    if (expanded) {
	      if (expandDescendants) {
	        this.expandAll(node);
	      } else {
	        this.expandNode(node);
	      }
	    } else {
	      this.collapseNode(node);
	    }
	  },

	  /**
	   * Mark the given node selected, and update the inspector.selection
	   * object's NodeFront to keep consistent state between UI and selection.
	   *
	   * @param  {NodeFront} aNode
	   *         The NodeFront to mark as selected.
	   * @param  {String} reason
	   *         The reason for marking the node as selected.
	   * @return {Boolean} False if the node is already marked as selected, true
	   *         otherwise.
	   */
	  markNodeAsSelected: function (node, reason) {
	    let container = this.getContainer(node);

	    if (this._selectedContainer === container) {
	      return false;
	    }

	    // Un-select and remove focus from the previous container.
	    if (this._selectedContainer) {
	      this._selectedContainer.selected = false;
	      this._selectedContainer.clearFocus();
	    }

	    // Select the new container.
	    this._selectedContainer = container;
	    if (node) {
	      this._selectedContainer.selected = true;
	    }

	    // Change the current selection if needed.
	    if (this._inspector.selection.nodeFront !== node) {
	      this._inspector.selection.setNodeFront(node, reason || "nodeselected");
	    }

	    return true;
	  },

	  /**
	   * Make sure that every ancestor of the selection are updated
	   * and included in the list of visible children.
	   */
	  _ensureVisible: function (node) {
	    while (node) {
	      let container = this.getContainer(node);
	      let parent = node.parentNode();
	      if (!container.elt.parentNode) {
	        let parentContainer = this.getContainer(parent);
	        if (parentContainer) {
	          parentContainer.childrenDirty = true;
	          this._updateChildren(parentContainer, {expand: true});
	        }
	      }

	      node = parent;
	    }
	    return this._waitForChildren();
	  },

	  /**
	   * Unmark selected node (no node selected).
	   */
	  unmarkSelectedNode: function () {
	    if (this._selectedContainer) {
	      this._selectedContainer.selected = false;
	      this._selectedContainer = null;
	    }
	  },

	  /**
	   * Check if the current selection is a descendent of the container.
	   * if so, make sure it's among the visible set for the container,
	   * and set the dirty flag if needed.
	   *
	   * @return The node that should be made visible, if any.
	   */
	  _checkSelectionVisible: function (container) {
	    let centered = null;
	    let node = this._inspector.selection.nodeFront;
	    while (node) {
	      if (node.parentNode() === container.node) {
	        centered = node;
	        break;
	      }
	      node = node.parentNode();
	    }

	    return centered;
	  },

	  /**
	   * Make sure all children of the given container's node are
	   * imported and attached to the container in the right order.
	   *
	   * Children need to be updated only in the following circumstances:
	   * a) We just imported this node and have never seen its children.
	   *    container.childrenDirty will be set by importNode in this case.
	   * b) We received a childList mutation on the node.
	   *    container.childrenDirty will be set in that case too.
	   * c) We have changed the selection, and the path to that selection
	   *    wasn't loaded in a previous children request (because we only
	   *    grab a subset).
	   *    container.childrenDirty should be set in that case too!
	   *
	   * @param  {MarkupContainer} container
	   *         The markup container whose children need updating
	   * @param  {Object} options
	   *         Options are {expand:boolean,flash:boolean}
	   * @return {Promise} that will be resolved when the children are ready
	   *         (which may be immediately).
	   */
	  _updateChildren: function (container, options) {
	    let expand = options && options.expand;
	    let flash = options && options.flash;

	    container.hasChildren = container.node.hasChildren;
	    // Accessibility should either ignore empty children or semantically
	    // consider them a group.
	    container.setChildrenRole();

	    if (!this._queuedChildUpdates) {
	      this._queuedChildUpdates = new Map();
	    }

	    if (this._queuedChildUpdates.has(container)) {
	      return this._queuedChildUpdates.get(container);
	    }

	    if (!container.childrenDirty) {
	      return promise.resolve(container);
	    }

	    if (container.inlineTextChild
	        && container.inlineTextChild != container.node.inlineTextChild) {
	      // This container was doing double duty as a container for a single
	      // text child, back that out.
	      this._containers.delete(container.inlineTextChild);
	      container.clearInlineTextChild();

	      if (container.hasChildren && container.selected) {
	        container.setExpanded(true);
	      }
	    }

	    if (container.node.inlineTextChild) {
	      container.setExpanded(false);
	      // this container will do double duty as the container for the single
	      // text child.
	      while (container.children.firstChild) {
	        container.children.removeChild(container.children.firstChild);
	      }

	      container.setInlineTextChild(container.node.inlineTextChild);

	      this._containers.set(container.node.inlineTextChild, container);
	      container.childrenDirty = false;
	      return promise.resolve(container);
	    }

	    if (!container.hasChildren) {
	      while (container.children.firstChild) {
	        container.children.removeChild(container.children.firstChild);
	      }
	      container.childrenDirty = false;
	      container.setExpanded(false);
	      return promise.resolve(container);
	    }

	    // If we're not expanded (or asked to update anyway), we're done for
	    // now.  Note that this will leave the childrenDirty flag set, so when
	    // expanded we'll refresh the child list.
	    if (!(container.expanded || expand)) {
	      return promise.resolve(container);
	    }

	    // We're going to issue a children request, make sure it includes the
	    // centered node.
	    let centered = this._checkSelectionVisible(container);

	    // Children aren't updated yet, but clear the childrenDirty flag anyway.
	    // If the dirty flag is re-set while we're fetching we'll need to fetch
	    // again.
	    container.childrenDirty = false;
	    let updatePromise =
	      this._getVisibleChildren(container, centered).then(children => {
	        if (!this._containers) {
	          return promise.reject("markup view destroyed");
	        }
	        this._queuedChildUpdates.delete(container);

	        // If children are dirty, we got a change notification for this node
	        // while the request was in progress, we need to do it again.
	        if (container.childrenDirty) {
	          return this._updateChildren(container, {expand: centered});
	        }

	        let fragment = this.doc.createDocumentFragment();

	        for (let child of children.nodes) {
	          let childContainer = this.importNode(child, flash);
	          fragment.appendChild(childContainer.elt);
	        }

	        while (container.children.firstChild) {
	          container.children.removeChild(container.children.firstChild);
	        }

	        if (!(children.hasFirst && children.hasLast)) {
	          let nodesCount = container.node.numChildren;
	          let showAllString = PluralForm.get(nodesCount,
	            INSPECTOR_L10N.getStr("markupView.more.showAll2"));
	          let data = {
	            showing: INSPECTOR_L10N.getStr("markupView.more.showing"),
	            showAll: showAllString.replace("#1", nodesCount),
	            allButtonClick: () => {
	              container.maxChildren = -1;
	              container.childrenDirty = true;
	              this._updateChildren(container);
	            }
	          };

	          if (!children.hasFirst) {
	            let span = this.template("more-nodes", data);
	            fragment.insertBefore(span, fragment.firstChild);
	          }
	          if (!children.hasLast) {
	            let span = this.template("more-nodes", data);
	            fragment.appendChild(span);
	          }
	        }

	        container.children.appendChild(fragment);
	        return container;
	      }).catch(this._handleRejectionIfNotDestroyed);
	    this._queuedChildUpdates.set(container, updatePromise);
	    return updatePromise;
	  },

	  _waitForChildren: function () {
	    if (!this._queuedChildUpdates) {
	      return promise.resolve(undefined);
	    }

	    return promise.all([...this._queuedChildUpdates.values()]);
	  },

	  /**
	   * Return a list of the children to display for this container.
	   */
	  _getVisibleChildren: function (container, centered) {
	    let maxChildren = container.maxChildren || this.maxChildren;
	    if (maxChildren == -1) {
	      maxChildren = undefined;
	    }

	    return this.walker.children(container.node, {
	      maxNodes: maxChildren,
	      center: centered
	    });
	  },

	  /**
	   * Tear down the markup panel.
	   */
	  destroy: function () {
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    this._destroyer = promise.resolve();

	    this._clearBriefBoxModelTimer();

	    this._hoveredNode = null;

	    this.htmlEditor.destroy();
	    this.htmlEditor = null;

	    this.undo.destroy();
	    this.undo = null;

	    this.popup.destroy();
	    this.popup = null;

	    this._elt.removeEventListener("click", this._onMouseClick, false);
	    this._elt.removeEventListener("mousemove", this._onMouseMove, false);
	    this._elt.removeEventListener("mouseout", this._onMouseOut, false);
	    this._elt.removeEventListener("blur", this._onBlur, true);
	    this.win.removeEventListener("mouseup", this._onMouseUp);
	    this.win.removeEventListener("copy", this._onCopy);
	    this._frame.removeEventListener("focus", this._onFocus, false);
	    this.walker.off("mutations", this._mutationObserver);
	    this.walker.off("display-change", this._onDisplayChange);
	    this._inspector.selection.off("new-node-front", this._onNewSelection);
	    this._inspector.toolbox.off("picker-node-hovered",
	                                this._onToolboxPickerHover);

	    this._prefObserver.off(ATTR_COLLAPSE_ENABLED_PREF,
	                           this._onCollapseAttributesPrefChange);
	    this._prefObserver.off(ATTR_COLLAPSE_LENGTH_PREF,
	                           this._onCollapseAttributesPrefChange);
	    this._prefObserver.destroy();

	    this._elt = null;

	    for (let [, container] of this._containers) {
	      container.destroy();
	    }
	    this._containers = null;

	    this.eventDetailsTooltip.destroy();
	    this.eventDetailsTooltip = null;

	    this.imagePreviewTooltip.destroy();
	    this.imagePreviewTooltip = null;

	    this.win = null;
	    this.doc = null;

	    this._lastDropTarget = null;
	    this._lastDragTarget = null;

	    return this._destroyer;
	  },

	  /**
	   * Find the closest element with class tag-line. These are used to indicate
	   * drag and drop targets.
	   *
	   * @param  {DOMNode} el
	   * @return {DOMNode}
	   */
	  findClosestDragDropTarget: function (el) {
	    return el.classList.contains("tag-line")
	           ? el
	           : el.querySelector(".tag-line") || el.closest(".tag-line");
	  },

	  /**
	   * Takes an element as it's only argument and marks the element
	   * as the drop target
	   */
	  indicateDropTarget: function (el) {
	    if (this._lastDropTarget) {
	      this._lastDropTarget.classList.remove("drop-target");
	    }

	    if (!el) {
	      return;
	    }

	    let target = this.findClosestDragDropTarget(el);
	    if (target) {
	      target.classList.add("drop-target");
	      this._lastDropTarget = target;
	    }
	  },

	  /**
	   * Takes an element to mark it as indicator of dragging target's initial place
	   */
	  indicateDragTarget: function (el) {
	    if (this._lastDragTarget) {
	      this._lastDragTarget.classList.remove("drag-target");
	    }

	    if (!el) {
	      return;
	    }

	    let target = this.findClosestDragDropTarget(el);
	    if (target) {
	      target.classList.add("drag-target");
	      this._lastDragTarget = target;
	    }
	  },

	  /**
	   * Used to get the nodes required to modify the markup after dragging the
	   * element (parent/nextSibling).
	   */
	  get dropTargetNodes() {
	    let target = this._lastDropTarget;

	    if (!target) {
	      return null;
	    }

	    let parent, nextSibling;

	    if (target.previousElementSibling &&
	        target.previousElementSibling.nodeName.toLowerCase() === "ul") {
	      parent = target.parentNode.container.node;
	      nextSibling = null;
	    } else {
	      parent = target.parentNode.container.node.parentNode();
	      nextSibling = target.parentNode.container.node;
	    }

	    if (nextSibling && nextSibling.isBeforePseudoElement) {
	      nextSibling = target.parentNode.parentNode.children[1].container.node;
	    }
	    if (nextSibling && nextSibling.isAfterPseudoElement) {
	      parent = target.parentNode.container.node.parentNode();
	      nextSibling = null;
	    }

	    if (parent.nodeType !== nodeConstants.ELEMENT_NODE) {
	      return null;
	    }

	    return {parent, nextSibling};
	  }
	};

	/**
	 * The main structure for storing a document node in the markup
	 * tree.  Manages creation of the editor for the node and
	 * a <ul> for placing child elements, and expansion/collapsing
	 * of the element.
	 *
	 * This should not be instantiated directly, instead use one of:
	 *    MarkupReadOnlyContainer
	 *    MarkupTextContainer
	 *    MarkupElementContainer
	 */
	function MarkupContainer() { }

	/**
	 * Unique identifier used to set markup container node id.
	 * @type {Number}
	 */
	let markupContainerID = 0;

	MarkupContainer.prototype = {
	  /*
	   * Initialize the MarkupContainer.  Should be called while one
	   * of the other contain classes is instantiated.
	   *
	   * @param  {MarkupView} markupView
	   *         The markup view that owns this container.
	   * @param  {NodeFront} node
	   *         The node to display.
	   * @param  {String} templateID
	   *         Which template to render for this container
	   */
	  initialize: function (markupView, node, templateID) {
	    this.markup = markupView;
	    this.node = node;
	    this.undo = this.markup.undo;
	    this.win = this.markup._frame.contentWindow;
	    this.id = "treeitem-" + markupContainerID++;
	    this.htmlElt = this.win.document.documentElement;

	    // The template will fill the following properties
	    this.elt = null;
	    this.expander = null;
	    this.tagState = null;
	    this.tagLine = null;
	    this.children = null;
	    this.markup.template(templateID, this);
	    this.elt.container = this;

	    this._onMouseDown = this._onMouseDown.bind(this);
	    this._onToggle = this._onToggle.bind(this);
	    this._onMouseUp = this._onMouseUp.bind(this);
	    this._onMouseMove = this._onMouseMove.bind(this);
	    this._onKeyDown = this._onKeyDown.bind(this);

	    // Binding event listeners
	    this.elt.addEventListener("mousedown", this._onMouseDown, false);
	    this.win.addEventListener("mouseup", this._onMouseUp, true);
	    this.win.addEventListener("mousemove", this._onMouseMove, true);
	    this.elt.addEventListener("dblclick", this._onToggle, false);
	    if (this.expander) {
	      this.expander.addEventListener("click", this._onToggle, false);
	    }

	    // Marking the node as shown or hidden
	    this.updateIsDisplayed();
	  },

	  toString: function () {
	    return "[MarkupContainer for " + this.node + "]";
	  },

	  isPreviewable: function () {
	    if (this.node.tagName && !this.node.isPseudoElement) {
	      let tagName = this.node.tagName.toLowerCase();
	      let srcAttr = this.editor.getAttributeElement("src");
	      let isImage = tagName === "img" && srcAttr;
	      let isCanvas = tagName === "canvas";

	      return isImage || isCanvas;
	    }

	    return false;
	  },

	  /**
	   * Show whether the element is displayed or not
	   * If an element has the attribute `display: none` or has been hidden with
	   * the H key, it is not displayed (faded in markup view).
	   * Otherwise, it is displayed.
	   */
	  updateIsDisplayed: function () {
	    this.elt.classList.remove("not-displayed");
	    if (!this.node.isDisplayed || this.node.hidden) {
	      this.elt.classList.add("not-displayed");
	    }
	  },

	  /**
	   * True if the current node has children. The MarkupView
	   * will set this attribute for the MarkupContainer.
	   */
	  _hasChildren: false,

	  get hasChildren() {
	    return this._hasChildren;
	  },

	  set hasChildren(value) {
	    this._hasChildren = value;
	    this.updateExpander();
	  },

	  /**
	   * A list of all elements with tabindex that are not in container's children.
	   */
	  get focusableElms() {
	    return [...this.tagLine.querySelectorAll("[tabindex]")];
	  },

	  /**
	   * An indicator that the container internals are focusable.
	   */
	  get canFocus() {
	    return this._canFocus;
	  },

	  /**
	   * Toggle focusable state for container internals.
	   */
	  set canFocus(value) {
	    if (this._canFocus === value) {
	      return;
	    }

	    this._canFocus = value;

	    if (value) {
	      this.tagLine.addEventListener("keydown", this._onKeyDown, true);
	      this.focusableElms.forEach(elm => elm.setAttribute("tabindex", "0"));
	    } else {
	      this.tagLine.removeEventListener("keydown", this._onKeyDown, true);
	      // Exclude from tab order.
	      this.focusableElms.forEach(elm => elm.setAttribute("tabindex", "-1"));
	    }
	  },

	  /**
	   * If conatiner and its contents are focusable, exclude them from tab order,
	   * and, if necessary, remove focus.
	   */
	  clearFocus: function () {
	    if (!this.canFocus) {
	      return;
	    }

	    this.canFocus = false;
	    let doc = this.markup.doc;

	    if (!doc.activeElement || doc.activeElement === doc.body) {
	      return;
	    }

	    let parent = doc.activeElement;

	    while (parent && parent !== this.elt) {
	      parent = parent.parentNode;
	    }

	    if (parent) {
	      doc.activeElement.blur();
	    }
	  },

	  /**
	   * True if the current node can be expanded.
	   */
	  get canExpand() {
	    return this._hasChildren && !this.node.inlineTextChild;
	  },

	  /**
	   * True if this is the root <html> element and can't be collapsed.
	   */
	  get mustExpand() {
	    return this.node._parent === this.markup.walker.rootNode;
	  },

	  /**
	   * True if current node can be expanded and collapsed.
	   */
	  get showExpander() {
	    return this.canExpand && !this.mustExpand;
	  },

	  updateExpander: function () {
	    if (!this.expander) {
	      return;
	    }

	    if (this.showExpander) {
	      this.expander.style.visibility = "visible";
	      // Update accessibility expanded state.
	      this.tagLine.setAttribute("aria-expanded", this.expanded);
	    } else {
	      this.expander.style.visibility = "hidden";
	      // No need for accessible expanded state indicator when expander is not
	      // shown.
	      this.tagLine.removeAttribute("aria-expanded");
	    }
	  },

	  /**
	   * If current node has no children, ignore them. Otherwise, consider them a
	   * group from the accessibility point of view.
	   */
	  setChildrenRole: function () {
	    this.children.setAttribute("role",
	      this.hasChildren ? "group" : "presentation");
	  },

	  /**
	   * Set an appropriate DOM tree depth level for a node and its subtree.
	   */
	  updateLevel: function () {
	    // ARIA level should already be set when container template is rendered.
	    let currentLevel = this.tagLine.getAttribute("aria-level");
	    let newLevel = this.level;
	    if (currentLevel === newLevel) {
	      // If level did not change, ignore this node and its subtree.
	      return;
	    }

	    this.tagLine.setAttribute("aria-level", newLevel);
	    let childContainers = this.getChildContainers();
	    if (childContainers) {
	      childContainers.forEach(container => container.updateLevel());
	    }
	  },

	  /**
	   * If the node has children, return the list of containers for all these
	   * children.
	   */
	  getChildContainers: function () {
	    if (!this.hasChildren) {
	      return null;
	    }

	    return [...this.children.children].map(node => node.container);
	  },

	  /**
	   * True if the node has been visually expanded in the tree.
	   */
	  get expanded() {
	    return !this.elt.classList.contains("collapsed");
	  },

	  setExpanded: function (value) {
	    if (!this.expander) {
	      return;
	    }

	    if (!this.canExpand) {
	      value = false;
	    }
	    if (this.mustExpand) {
	      value = true;
	    }

	    if (value && this.elt.classList.contains("collapsed")) {
	      // Expanding a node means cloning its "inline" closing tag into a new
	      // tag-line that the user can interact with and showing the children.
	      let closingTag = this.elt.querySelector(".close");
	      if (closingTag) {
	        if (!this.closeTagLine) {
	          let line = this.markup.doc.createElement("div");
	          line.classList.add("tag-line");
	          // Closing tag is not important for accessibility.
	          line.setAttribute("role", "presentation");

	          let tagState = this.markup.doc.createElement("div");
	          tagState.classList.add("tag-state");
	          line.appendChild(tagState);

	          line.appendChild(closingTag.cloneNode(true));

	          flashElementOff(line);
	          this.closeTagLine = line;
	        }
	        this.elt.appendChild(this.closeTagLine);
	      }

	      this.elt.classList.remove("collapsed");
	      this.expander.setAttribute("open", "");
	      this.hovered = false;
	      this.markup.emit("expanded");
	    } else if (!value) {
	      if (this.closeTagLine) {
	        this.elt.removeChild(this.closeTagLine);
	        this.closeTagLine = undefined;
	      }
	      this.elt.classList.add("collapsed");
	      this.expander.removeAttribute("open");
	      this.markup.emit("collapsed");
	    }
	    if (this.showExpander) {
	      this.tagLine.setAttribute("aria-expanded", this.expanded);
	    }
	  },

	  parentContainer: function () {
	    return this.elt.parentNode ? this.elt.parentNode.container : null;
	  },

	  /**
	   * Determine tree depth level of a given node. This is used to specify ARIA
	   * level for node tree items and to give them better semantic context.
	   */
	  get level() {
	    let level = 1;
	    let parent = this.node.parentNode();
	    while (parent && parent !== this.markup.walker.rootNode) {
	      level++;
	      parent = parent.parentNode();
	    }
	    return level;
	  },

	  _isDragging: false,
	  _dragStartY: 0,

	  set isDragging(isDragging) {
	    let rootElt = this.markup.getContainer(this.markup._rootNode).elt;
	    this._isDragging = isDragging;
	    this.markup.isDragging = isDragging;
	    this.tagLine.setAttribute("aria-grabbed", isDragging);

	    if (isDragging) {
	      this.htmlElt.classList.add("dragging");
	      this.elt.classList.add("dragging");
	      this.markup.doc.body.classList.add("dragging");
	      rootElt.setAttribute("aria-dropeffect", "move");
	    } else {
	      this.htmlElt.classList.remove("dragging");
	      this.elt.classList.remove("dragging");
	      this.markup.doc.body.classList.remove("dragging");
	      rootElt.setAttribute("aria-dropeffect", "none");
	    }
	  },

	  get isDragging() {
	    return this._isDragging;
	  },

	  /**
	   * Check if element is draggable.
	   */
	  isDraggable: function () {
	    let tagName = this.node.tagName && this.node.tagName.toLowerCase();

	    return !this.node.isPseudoElement &&
	           !this.node.isAnonymous &&
	           !this.node.isDocumentElement &&
	           tagName !== "body" &&
	           tagName !== "head" &&
	           this.win.getSelection().isCollapsed &&
	           this.node.parentNode().tagName !== null;
	  },

	  /**
	   * Move keyboard focus to a next/previous focusable element inside container
	   * that is not part of its children (only if current focus is on first or last
	   * element).
	   *
	   * @param  {DOMNode} current  currently focused element
	   * @param  {Boolean} back     direction
	   * @return {DOMNode}          newly focused element if any
	   */
	  _wrapMoveFocus: function (current, back) {
	    let elms = this.focusableElms;
	    let next;
	    if (back) {
	      if (elms.indexOf(current) === 0) {
	        next = elms[elms.length - 1];
	        next.focus();
	      }
	    } else if (elms.indexOf(current) === elms.length - 1) {
	      next = elms[0];
	      next.focus();
	    }
	    return next;
	  },

	  _onKeyDown: function (event) {
	    let {target, keyCode, shiftKey} = event;
	    let isInput = this.markup._isInputOrTextarea(target);

	    // Ignore all keystrokes that originated in editors except for when 'Tab' is
	    // pressed.
	    if (isInput && keyCode !== KeyCodes.DOM_VK_TAB) {
	      return;
	    }

	    switch (keyCode) {
	      case KeyCodes.DOM_VK_TAB:
	        // Only handle 'Tab' if tabbable element is on the edge (first or last).
	        if (isInput) {
	          // Corresponding tabbable element is editor's next sibling.
	          let next = this._wrapMoveFocus(target.nextSibling, shiftKey);
	          if (next) {
	            event.preventDefault();
	            // Keep the editing state if possible.
	            if (next._editable) {
	              let e = this.markup.doc.createEvent("Event");
	              e.initEvent(next._trigger, true, true);
	              next.dispatchEvent(e);
	            }
	          }
	        } else {
	          let next = this._wrapMoveFocus(target, shiftKey);
	          if (next) {
	            event.preventDefault();
	          }
	        }
	        break;
	      case KeyCodes.DOM_VK_ESCAPE:
	        this.clearFocus();
	        this.markup.getContainer(this.markup._rootNode).elt.focus();
	        if (this.isDragging) {
	          // Escape when dragging is handled by markup view itself.
	          return;
	        }
	        event.preventDefault();
	        break;
	      default:
	        return;
	    }
	    event.stopPropagation();
	  },

	  _onMouseDown: function (event) {
	    let {target, button, metaKey, ctrlKey} = event;
	    let isLeftClick = button === 0;
	    let isMiddleClick = button === 1;
	    let isMetaClick = isLeftClick && (metaKey || ctrlKey);

	    // The "show more nodes" button already has its onclick, so early return.
	    if (target.nodeName === "button") {
	      return;
	    }

	    // target is the MarkupContainer itself.
	    this.hovered = false;
	    this.markup.navigate(this);
	    // Make container tabbable descendants tabbable and focus in.
	    this.canFocus = true;
	    this.focus();
	    event.stopPropagation();

	    // Preventing the default behavior will avoid the body to gain focus on
	    // mouseup (through bubbling) when clicking on a non focusable node in the
	    // line. So, if the click happened outside of a focusable element, do
	    // prevent the default behavior, so that the tagname or textcontent gains
	    // focus.
	    if (!target.closest(".editor [tabindex]")) {
	      event.preventDefault();
	    }

	    // Follow attribute links if middle or meta click.
	    if (isMiddleClick || isMetaClick) {
	      let link = target.dataset.link;
	      let type = target.dataset.type;
	      // Make container tabbable descendants not tabbable (by default).
	      this.canFocus = false;
	      this.markup._inspector.followAttributeLink(type, link);
	      return;
	    }

	    // Start node drag & drop (if the mouse moved, see _onMouseMove).
	    if (isLeftClick && this.isDraggable()) {
	      this._isPreDragging = true;
	      this._dragStartY = event.pageY;
	    }
	  },

	  /**
	   * On mouse up, stop dragging.
	   */
	  _onMouseUp: Task.async(function* () {
	    this._isPreDragging = false;

	    if (this.isDragging) {
	      this.cancelDragging();

	      let dropTargetNodes = this.markup.dropTargetNodes;

	      if (!dropTargetNodes) {
	        return;
	      }

	      yield this.markup.walker.insertBefore(this.node, dropTargetNodes.parent,
	                                            dropTargetNodes.nextSibling);
	      this.markup.emit("drop-completed");
	    }
	  }),

	  /**
	   * On mouse move, move the dragged element and indicate the drop target.
	   */
	  _onMouseMove: function (event) {
	    // If this is the first move after mousedown, only start dragging after the
	    // mouse has travelled a few pixels and then indicate the start position.
	    let initialDiff = Math.abs(event.pageY - this._dragStartY);
	    if (this._isPreDragging && initialDiff >= DRAG_DROP_MIN_INITIAL_DISTANCE) {
	      this._isPreDragging = false;
	      this.isDragging = true;

	      // If this is the last child, use the closing <div.tag-line> of parent as
	      // indicator.
	      let position = this.elt.nextElementSibling ||
	                     this.markup.getContainer(this.node.parentNode())
	                                .closeTagLine;
	      this.markup.indicateDragTarget(position);
	    }

	    if (this.isDragging) {
	      let x = 0;
	      let y = event.pageY - this.win.scrollY;

	      // Ensure we keep the dragged element within the markup view.
	      if (y < 0) {
	        y = 0;
	      } else if (y >= this.markup.doc.body.offsetHeight - this.win.scrollY) {
	        y = this.markup.doc.body.offsetHeight - this.win.scrollY - 1;
	      }

	      let diff = y - this._dragStartY + this.win.scrollY;
	      this.elt.style.top = diff + "px";

	      let el = this.markup.doc.elementFromPoint(x, y);
	      this.markup.indicateDropTarget(el);
	    }
	  },

	  cancelDragging: function () {
	    if (!this.isDragging) {
	      return;
	    }

	    this._isPreDragging = false;
	    this.isDragging = false;
	    this.elt.style.removeProperty("top");
	  },

	  /**
	   * Temporarily flash the container to attract attention.
	   * Used for markup mutations.
	   */
	  flashMutation: function () {
	    if (!this.selected) {
	      flashElementOn(this.tagState, this.editor.elt);
	      if (this._flashMutationTimer) {
	        clearTimeout(this._flashMutationTimer);
	        this._flashMutationTimer = null;
	      }
	      this._flashMutationTimer = setTimeout(() => {
	        flashElementOff(this.tagState, this.editor.elt);
	      }, this.markup.CONTAINER_FLASHING_DURATION);
	    }
	  },

	  _hovered: false,

	  /**
	   * Highlight the currently hovered tag + its closing tag if necessary
	   * (that is if the tag is expanded)
	   */
	  set hovered(value) {
	    this.tagState.classList.remove("flash-out");
	    this._hovered = value;
	    if (value) {
	      if (!this.selected) {
	        this.tagState.classList.add("theme-bg-darker");
	      }
	      if (this.closeTagLine) {
	        this.closeTagLine.querySelector(".tag-state").classList.add(
	          "theme-bg-darker");
	      }
	    } else {
	      this.tagState.classList.remove("theme-bg-darker");
	      if (this.closeTagLine) {
	        this.closeTagLine.querySelector(".tag-state").classList.remove(
	          "theme-bg-darker");
	      }
	    }
	  },

	  /**
	   * True if the container is visible in the markup tree.
	   */
	  get visible() {
	    return this.elt.getBoundingClientRect().height > 0;
	  },

	  /**
	   * True if the container is currently selected.
	   */
	  _selected: false,

	  get selected() {
	    return this._selected;
	  },

	  set selected(value) {
	    this.tagState.classList.remove("flash-out");
	    this._selected = value;
	    this.editor.selected = value;
	    // Markup tree item should have accessible selected state.
	    this.tagLine.setAttribute("aria-selected", value);
	    if (this._selected) {
	      this.markup.getContainer(this.markup._rootNode).elt.setAttribute(
	        "aria-activedescendant", this.id);
	      this.tagLine.setAttribute("selected", "");
	      this.tagState.classList.add("theme-selected");
	    } else {
	      this.tagLine.removeAttribute("selected");
	      this.tagState.classList.remove("theme-selected");
	    }
	  },

	  /**
	   * Update the container's editor to the current state of the
	   * viewed node.
	   */
	  update: function () {
	    if (this.node.pseudoClassLocks.length) {
	      this.elt.classList.add("pseudoclass-locked");
	    } else {
	      this.elt.classList.remove("pseudoclass-locked");
	    }

	    if (this.editor.update) {
	      this.editor.update();
	    }
	  },

	  /**
	   * Try to put keyboard focus on the current editor.
	   */
	  focus: function () {
	    // Elements with tabindex of -1 are not focusable.
	    let focusable = this.editor.elt.querySelector("[tabindex='0']");
	    if (focusable) {
	      focusable.focus();
	    }
	  },

	  _onToggle: function (event) {
	    this.markup.navigate(this);
	    if (this.hasChildren) {
	      this.markup.setNodeExpanded(this.node, !this.expanded, event.altKey);
	    }
	    event.stopPropagation();
	  },

	  /**
	   * Get rid of event listeners and references, when the container is no longer
	   * needed
	   */
	  destroy: function () {
	    // Remove event listeners
	    this.elt.removeEventListener("mousedown", this._onMouseDown, false);
	    this.elt.removeEventListener("dblclick", this._onToggle, false);
	    this.tagLine.removeEventListener("keydown", this._onKeyDown, true);
	    if (this.win) {
	      this.win.removeEventListener("mouseup", this._onMouseUp, true);
	      this.win.removeEventListener("mousemove", this._onMouseMove, true);
	    }

	    this.win = null;
	    this.htmlElt = null;

	    if (this.expander) {
	      this.expander.removeEventListener("click", this._onToggle, false);
	    }

	    // Recursively destroy children containers
	    let firstChild = this.children.firstChild;
	    while (firstChild) {
	      // Not all children of a container are containers themselves
	      // ("show more nodes" button is one example)
	      if (firstChild.container) {
	        firstChild.container.destroy();
	      }
	      this.children.removeChild(firstChild);
	      firstChild = this.children.firstChild;
	    }

	    this.editor.destroy();
	  }
	};

	/**
	 * An implementation of MarkupContainer for Pseudo Elements,
	 * Doctype nodes, or any other type generic node that doesn't
	 * fit for other editors.
	 * Does not allow any editing, just viewing / selecting.
	 *
	 * @param  {MarkupView} markupView
	 *         The markup view that owns this container.
	 * @param  {NodeFront} node
	 *         The node to display.
	 */
	function MarkupReadOnlyContainer(markupView, node) {
	  MarkupContainer.prototype.initialize.call(this, markupView, node,
	    "readonlycontainer");

	  this.editor = new GenericEditor(this, node);
	  this.tagLine.appendChild(this.editor.elt);
	}

	MarkupReadOnlyContainer.prototype =
	  Heritage.extend(MarkupContainer.prototype, {});

	/**
	 * An implementation of MarkupContainer for text node and comment nodes.
	 * Allows basic text editing in a textarea.
	 *
	 * @param  {MarkupView} markupView
	 *         The markup view that owns this container.
	 * @param  {NodeFront} node
	 *         The node to display.
	 * @param  {Inspector} inspector
	 *         The inspector tool container the markup-view
	 */
	function MarkupTextContainer(markupView, node) {
	  MarkupContainer.prototype.initialize.call(this, markupView, node,
	    "textcontainer");

	  if (node.nodeType == nodeConstants.TEXT_NODE) {
	    this.editor = new TextEditor(this, node, "text");
	  } else if (node.nodeType == nodeConstants.COMMENT_NODE) {
	    this.editor = new TextEditor(this, node, "comment");
	  } else {
	    throw new Error("Invalid node for MarkupTextContainer");
	  }

	  this.tagLine.appendChild(this.editor.elt);
	}

	MarkupTextContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});

	/**
	 * An implementation of MarkupContainer for Elements that can contain
	 * child nodes.
	 * Allows editing of tag name, attributes, expanding / collapsing.
	 *
	 * @param  {MarkupView} markupView
	 *         The markup view that owns this container.
	 * @param  {NodeFront} node
	 *         The node to display.
	 */
	function MarkupElementContainer(markupView, node) {
	  MarkupContainer.prototype.initialize.call(this, markupView, node,
	    "elementcontainer");

	  if (node.nodeType === nodeConstants.ELEMENT_NODE) {
	    this.editor = new ElementEditor(this, node);
	  } else {
	    throw new Error("Invalid node for MarkupElementContainer");
	  }

	  this.tagLine.appendChild(this.editor.elt);
	}

	MarkupElementContainer.prototype = Heritage.extend(MarkupContainer.prototype, {
	  _buildEventTooltipContent: Task.async(function* (target, tooltip) {
	    if (target.hasAttribute("data-event")) {
	      yield tooltip.hide();

	      let listenerInfo = yield this.node.getEventListenerInfo();

	      let toolbox = this.markup._inspector.toolbox;
	      setEventTooltip(tooltip, listenerInfo, toolbox);
	      // Disable the image preview tooltip while we display the event details
	      this.markup._disableImagePreviewTooltip();
	      tooltip.once("hidden", () => {
	        // Enable the image preview tooltip after closing the event details
	        this.markup._enableImagePreviewTooltip();
	      });
	      tooltip.show(target);
	    }
	  }),

	  /**
	   * Generates the an image preview for this Element. The element must be an
	   * image or canvas (@see isPreviewable).
	   *
	   * @return {Promise} that is resolved with an object of form
	   *         { data, size: { naturalWidth, naturalHeight, resizeRatio } } where
	   *         - data is the data-uri for the image preview.
	   *         - size contains information about the original image size and if
	   *         the preview has been resized.
	   *
	   * If this element is not previewable or the preview cannot be generated for
	   * some reason, the Promise is rejected.
	   */
	  _getPreview: function () {
	    if (!this.isPreviewable()) {
	      return promise.reject("_getPreview called on a non-previewable element.");
	    }

	    if (this.tooltipDataPromise) {
	      // A preview request is already pending. Re-use that request.
	      return this.tooltipDataPromise;
	    }

	    // Fetch the preview from the server.
	    this.tooltipDataPromise = Task.spawn(function* () {
	      let maxDim = Services.prefs.getIntPref(PREVIEW_MAX_DIM_PREF);
	      let preview = yield this.node.getImageData(maxDim);
	      let data = yield preview.data.string();

	      // Clear the pending preview request. We can't reuse the results later as
	      // the preview contents might have changed.
	      this.tooltipDataPromise = null;
	      return { data, size: preview.size };
	    }.bind(this));

	    return this.tooltipDataPromise;
	  },

	  /**
	   * Executed by MarkupView._isImagePreviewTarget which is itself called when
	   * the mouse hovers over a target in the markup-view.
	   * Checks if the target is indeed something we want to have an image tooltip
	   * preview over and, if so, inserts content into the tooltip.
	   *
	   * @return {Promise} that resolves when the tooltip content is ready. Resolves
	   * true if the tooltip should be displayed, false otherwise.
	   */
	  isImagePreviewTarget: Task.async(function* (target, tooltip) {
	    // Is this Element previewable.
	    if (!this.isPreviewable()) {
	      return false;
	    }

	    // If the Element has an src attribute, the tooltip is shown when hovering
	    // over the src url. If not, the tooltip is shown when hovering over the tag
	    // name.
	    let src = this.editor.getAttributeElement("src");
	    let expectedTarget = src ? src.querySelector(".link") : this.editor.tag;
	    if (target !== expectedTarget) {
	      return false;
	    }

	    try {
	      let { data, size } = yield this._getPreview();
	      // The preview is ready.
	      let options = {
	        naturalWidth: size.naturalWidth,
	        naturalHeight: size.naturalHeight,
	        maxDim: Services.prefs.getIntPref(PREVIEW_MAX_DIM_PREF)
	      };

	      setImageTooltip(tooltip, this.markup.doc, data, options);
	    } catch (e) {
	      // Indicate the failure but show the tooltip anyway.
	      setBrokenImageTooltip(tooltip, this.markup.doc);
	    }
	    return true;
	  }),

	  copyImageDataUri: function () {
	    // We need to send again a request to gettooltipData even if one was sent
	    // for the tooltip, because we want the full-size image
	    this.node.getImageData().then(data => {
	      data.data.string().then(str => {
	        clipboardHelper.copyString(str);
	      });
	    });
	  },

	  setInlineTextChild: function (inlineTextChild) {
	    this.inlineTextChild = inlineTextChild;
	    this.editor.updateTextEditor();
	  },

	  clearInlineTextChild: function () {
	    this.inlineTextChild = undefined;
	    this.editor.updateTextEditor();
	  },

	  /**
	   * Trigger new attribute field for input.
	   */
	  addAttribute: function () {
	    this.editor.newAttr.editMode();
	  },

	  /**
	   * Trigger attribute field for editing.
	   */
	  editAttribute: function (attrName) {
	    this.editor.attrElements.get(attrName).editMode();
	  },

	  /**
	   * Remove attribute from container.
	   * This is an undoable action.
	   */
	  removeAttribute: function (attrName) {
	    let doMods = this.editor._startModifyingAttributes();
	    let undoMods = this.editor._startModifyingAttributes();
	    this.editor._saveAttribute(attrName, undoMods);
	    doMods.removeAttribute(attrName);
	    this.undo.do(() => {
	      doMods.apply();
	    }, () => {
	      undoMods.apply();
	    });
	  }
	});

	/**
	 * Dummy container node used for the root document element.
	 */
	function RootContainer(markupView, node) {
	  this.doc = markupView.doc;
	  this.elt = this.doc.createElement("ul");
	  // Root container has tree semantics for accessibility.
	  this.elt.setAttribute("role", "tree");
	  this.elt.setAttribute("tabindex", "0");
	  this.elt.setAttribute("aria-dropeffect", "none");
	  this.elt.container = this;
	  this.children = this.elt;
	  this.node = node;
	  this.toString = () => "[root container]";
	}

	RootContainer.prototype = {
	  hasChildren: true,
	  expanded: true,
	  update: function () {},
	  destroy: function () {},

	  /**
	   * If the node has children, return the list of containers for all these
	   * children.
	   */
	  getChildContainers: function () {
	    return [...this.children.children].map(node => node.container);
	  },

	  /**
	   * Set the expanded state of the container node.
	   * @param  {Boolean} value
	   */
	  setExpanded: function () {},

	  /**
	   * Set an appropriate role of the container's children node.
	   */
	  setChildrenRole: function () {},

	  /**
	   * Set an appropriate DOM tree depth level for a node and its subtree.
	   */
	  updateLevel: function () {}
	};

	/**
	 * Creates an editor for non-editable nodes.
	 */
	function GenericEditor(container, node) {
	  this.container = container;
	  this.markup = this.container.markup;
	  this.template = this.markup.template.bind(this.markup);
	  this.elt = null;
	  this.template("generic", this);

	  if (node.isPseudoElement) {
	    this.tag.classList.add("theme-fg-color5");
	    this.tag.textContent = node.isBeforePseudoElement ? "::before" : "::after";
	  } else if (node.nodeType == nodeConstants.DOCUMENT_TYPE_NODE) {
	    this.elt.classList.add("comment");
	    this.tag.textContent = node.doctypeString;
	  } else {
	    this.tag.textContent = node.nodeName;
	  }
	}

	GenericEditor.prototype = {
	  destroy: function () {
	    this.elt.remove();
	  },

	  /**
	   * Stub method for consistency with ElementEditor.
	   */
	  getInfoAtNode: function () {
	    return null;
	  }
	};

	/**
	 * Creates a simple text editor node, used for TEXT and COMMENT
	 * nodes.
	 *
	 * @param  {MarkupContainer} container
	 *         The container owning this editor.
	 * @param  {DOMNode} node
	 *         The node being edited.
	 * @param  {String} templateId
	 *         The template id to use to build the editor.
	 */
	function TextEditor(container, node, templateId) {
	  this.container = container;
	  this.markup = this.container.markup;
	  this.node = node;
	  this.template = this.markup.template.bind(templateId);
	  this._selected = false;

	  this.markup.template(templateId, this);

	  editableField({
	    element: this.value,
	    stopOnReturn: true,
	    trigger: "dblclick",
	    multiline: true,
	    maxWidth: () => getAutocompleteMaxWidth(this.value, this.container.elt),
	    trimOutput: false,
	    done: (val, commit) => {
	      if (!commit) {
	        return;
	      }
	      this.node.getNodeValue().then(longstr => {
	        longstr.string().then(oldValue => {
	          longstr.release().then(null, console.error);

	          this.container.undo.do(() => {
	            this.node.setNodeValue(val);
	          }, () => {
	            this.node.setNodeValue(oldValue);
	          });
	        });
	      });
	    },
	    cssProperties: getCssProperties(this.markup._inspector.toolbox)
	  });

	  this.update();
	}

	TextEditor.prototype = {
	  get selected() {
	    return this._selected;
	  },

	  set selected(value) {
	    if (value === this._selected) {
	      return;
	    }
	    this._selected = value;
	    this.update();
	  },

	  update: function () {
	    let longstr = null;
	    this.node.getNodeValue().then(ret => {
	      longstr = ret;
	      return longstr.string();
	    }).then(str => {
	      longstr.release().then(null, console.error);
	      this.value.textContent = str;
	    }).then(null, console.error);
	  },

	  destroy: function () {},

	  /**
	   * Stub method for consistency with ElementEditor.
	   */
	  getInfoAtNode: function () {
	    return null;
	  }
	};

	/**
	 * Creates an editor for an Element node.
	 *
	 * @param  {MarkupContainer} container
	 *         The container owning this editor.
	 * @param  {Element} node
	 *         The node being edited.
	 */
	function ElementEditor(container, node) {
	  this.container = container;
	  this.node = node;
	  this.markup = this.container.markup;
	  this.template = this.markup.template.bind(this.markup);
	  this.doc = this.markup.doc;
	  this._cssProperties = getCssProperties(this.markup._inspector.toolbox);

	  this.attrElements = new Map();
	  this.animationTimers = {};

	  // The templates will fill the following properties
	  this.elt = null;
	  this.tag = null;
	  this.closeTag = null;
	  this.attrList = null;
	  this.newAttr = null;
	  this.closeElt = null;

	  // Create the main editor
	  this.template("element", this);

	  // Make the tag name editable (unless this is a remote node or
	  // a document element)
	  if (!node.isDocumentElement) {
	    // Make the tag optionally tabbable but not by default.
	    this.tag.setAttribute("tabindex", "-1");
	    editableField({
	      element: this.tag,
	      multiline: true,
	      maxWidth: () => getAutocompleteMaxWidth(this.tag, this.container.elt),
	      trigger: "dblclick",
	      stopOnReturn: true,
	      done: this.onTagEdit.bind(this),
	      cssProperties: this._cssProperties
	    });
	  }

	  // Make the new attribute space editable.
	  this.newAttr.editMode = editableField({
	    element: this.newAttr,
	    multiline: true,
	    maxWidth: () => getAutocompleteMaxWidth(this.newAttr, this.container.elt),
	    trigger: "dblclick",
	    stopOnReturn: true,
	    contentType: InplaceEditor.CONTENT_TYPES.CSS_MIXED,
	    popup: this.markup.popup,
	    done: (val, commit) => {
	      if (!commit) {
	        return;
	      }

	      let doMods = this._startModifyingAttributes();
	      let undoMods = this._startModifyingAttributes();
	      this._applyAttributes(val, null, doMods, undoMods);
	      this.container.undo.do(() => {
	        doMods.apply();
	      }, function () {
	        undoMods.apply();
	      });
	    },
	    cssProperties: this._cssProperties
	  });

	  let displayName = this.node.displayName;
	  this.tag.textContent = displayName;
	  this.closeTag.textContent = displayName;

	  let isVoidElement = HTML_VOID_ELEMENTS.includes(displayName);
	  if (node.isInHTMLDocument && isVoidElement) {
	    this.elt.classList.add("void-element");
	  }

	  this.update();
	  this.initialized = true;
	}

	ElementEditor.prototype = {
	  set selected(value) {
	    if (this.textEditor) {
	      this.textEditor.selected = value;
	    }
	  },

	  flashAttribute: function (attrName) {
	    if (this.animationTimers[attrName]) {
	      clearTimeout(this.animationTimers[attrName]);
	    }

	    flashElementOn(this.getAttributeElement(attrName));

	    this.animationTimers[attrName] = setTimeout(() => {
	      flashElementOff(this.getAttributeElement(attrName));
	    }, this.markup.CONTAINER_FLASHING_DURATION);
	  },

	  /**
	   * Returns information about node in the editor.
	   *
	   * @param  {DOMNode} node
	   *         The node to get information from.
	   * @return {Object} An object literal with the following information:
	   *         {type: "attribute", name: "rel", value: "index", el: node}
	   */
	  getInfoAtNode: function (node) {
	    if (!node) {
	      return null;
	    }

	    let type = null;
	    let name = null;
	    let value = null;

	    // Attribute
	    let attribute = node.closest(".attreditor");
	    if (attribute) {
	      type = "attribute";
	      name = attribute.querySelector(".attr-name").textContent;
	      value = attribute.querySelector(".attr-value").textContent;
	    }

	    return {type, name, value, el: node};
	  },

	  /**
	   * Update the state of the editor from the node.
	   */
	  update: function () {
	    let nodeAttributes = this.node.attributes || [];

	    // Keep the data model in sync with attributes on the node.
	    let currentAttributes = new Set(nodeAttributes.map(a => a.name));
	    for (let name of this.attrElements.keys()) {
	      if (!currentAttributes.has(name)) {
	        this.removeAttribute(name);
	      }
	    }

	    // Only loop through the current attributes on the node.  Missing
	    // attributes have already been removed at this point.
	    for (let attr of nodeAttributes) {
	      let el = this.attrElements.get(attr.name);
	      let valueChanged = el &&
	        el.dataset.value !== attr.value;
	      let isEditing = el && el.querySelector(".editable").inplaceEditor;
	      let canSimplyShowEditor = el && (!valueChanged || isEditing);

	      if (canSimplyShowEditor) {
	        // Element already exists and doesn't need to be recreated.
	        // Just show it (it's hidden by default due to the template).
	        el.style.removeProperty("display");
	      } else {
	        // Create a new editor, because the value of an existing attribute
	        // has changed.
	        let attribute = this._createAttribute(attr, el);
	        attribute.style.removeProperty("display");

	        // Temporarily flash the attribute to highlight the change.
	        // But not if this is the first time the editor instance has
	        // been created.
	        if (this.initialized) {
	          this.flashAttribute(attr.name);
	        }
	      }
	    }

	    // Update the event bubble display
	    this.eventNode.style.display = this.node.hasEventListeners ?
	      "inline-block" : "none";

	    this.updateTextEditor();
	  },

	  /**
	   * Update the inline text editor in case of a single text child node.
	   */
	  updateTextEditor: function () {
	    let node = this.node.inlineTextChild;

	    if (this.textEditor && this.textEditor.node != node) {
	      this.elt.removeChild(this.textEditor.elt);
	      this.textEditor = null;
	    }

	    if (node && !this.textEditor) {
	      // Create a text editor added to this editor.
	      // This editor won't receive an update automatically, so we rely on
	      // child text editors to let us know that we need updating.
	      this.textEditor = new TextEditor(this.container, node, "text");
	      this.elt.insertBefore(this.textEditor.elt,
	                            this.elt.firstChild.nextSibling.nextSibling);
	    }

	    if (this.textEditor) {
	      this.textEditor.update();
	    }
	  },

	  _startModifyingAttributes: function () {
	    return this.node.startModifyingAttributes();
	  },

	  /**
	   * Get the element used for one of the attributes of this element.
	   *
	   * @param  {String} attrName
	   *         The name of the attribute to get the element for
	   * @return {DOMNode}
	   */
	  getAttributeElement: function (attrName) {
	    return this.attrList.querySelector(
	      ".attreditor[data-attr=" + CSS.escape(attrName) + "] .attr-value");
	  },

	  /**
	   * Remove an attribute from the attrElements object and the DOM.
	   *
	   * @param  {String} attrName
	   *         The name of the attribute to remove
	   */
	  removeAttribute: function (attrName) {
	    let attr = this.attrElements.get(attrName);
	    if (attr) {
	      this.attrElements.delete(attrName);
	      attr.remove();
	    }
	  },

	  _createAttribute: function (attribute, before = null) {
	    // Create the template editor, which will save some variables here.
	    let data = {
	      attrName: attribute.name,
	      tabindex: this.container.canFocus ? "0" : "-1",
	    };
	    this.template("attribute", data);
	    let {attr, inner, name, val} = data;

	    // Double quotes need to be handled specially to prevent DOMParser failing.
	    // name="v"a"l"u"e" when editing -> name='v"a"l"u"e"'
	    // name="v'a"l'u"e" when editing -> name="v'a&quot;l'u&quot;e"
	    let editValueDisplayed = attribute.value || "";
	    let hasDoubleQuote = editValueDisplayed.includes('"');
	    let hasSingleQuote = editValueDisplayed.includes("'");
	    let initial = attribute.name + '="' + editValueDisplayed + '"';

	    // Can't just wrap value with ' since the value contains both " and '.
	    if (hasDoubleQuote && hasSingleQuote) {
	      editValueDisplayed = editValueDisplayed.replace(/\"/g, "&quot;");
	      initial = attribute.name + '="' + editValueDisplayed + '"';
	    }

	    // Wrap with ' since there are no single quotes in the attribute value.
	    if (hasDoubleQuote && !hasSingleQuote) {
	      initial = attribute.name + "='" + editValueDisplayed + "'";
	    }

	    // Make the attribute editable.
	    attr.editMode = editableField({
	      element: inner,
	      trigger: "dblclick",
	      stopOnReturn: true,
	      selectAll: false,
	      initial: initial,
	      multiline: true,
	      maxWidth: () => getAutocompleteMaxWidth(inner, this.container.elt),
	      contentType: InplaceEditor.CONTENT_TYPES.CSS_MIXED,
	      popup: this.markup.popup,
	      start: (editor, event) => {
	        // If the editing was started inside the name or value areas,
	        // select accordingly.
	        if (event && event.target === name) {
	          editor.input.setSelectionRange(0, name.textContent.length);
	        } else if (event && event.target.closest(".attr-value") === val) {
	          let length = editValueDisplayed.length;
	          let editorLength = editor.input.value.length;
	          let start = editorLength - (length + 1);
	          editor.input.setSelectionRange(start, start + length);
	        } else {
	          editor.input.select();
	        }
	      },
	      done: (newValue, commit, direction) => {
	        if (!commit || newValue === initial) {
	          return;
	        }

	        let doMods = this._startModifyingAttributes();
	        let undoMods = this._startModifyingAttributes();

	        // Remove the attribute stored in this editor and re-add any attributes
	        // parsed out of the input element. Restore original attribute if
	        // parsing fails.
	        this.refocusOnEdit(attribute.name, attr, direction);
	        this._saveAttribute(attribute.name, undoMods);
	        doMods.removeAttribute(attribute.name);
	        this._applyAttributes(newValue, attr, doMods, undoMods);
	        this.container.undo.do(() => {
	          doMods.apply();
	        }, () => {
	          undoMods.apply();
	        });
	      },
	      cssProperties: this._cssProperties
	    });

	    // Figure out where we should place the attribute.
	    if (attribute.name == "id") {
	      before = this.attrList.firstChild;
	    } else if (attribute.name == "class") {
	      let idNode = this.attrElements.get("id");
	      before = idNode ? idNode.nextSibling : this.attrList.firstChild;
	    }
	    this.attrList.insertBefore(attr, before);

	    this.removeAttribute(attribute.name);
	    this.attrElements.set(attribute.name, attr);

	    // Parse the attribute value to detect whether there are linkable parts in
	    // it (make sure to pass a complete list of existing attributes to the
	    // parseAttribute function, by concatenating attribute, because this could
	    // be a newly added attribute not yet on this.node).
	    let attributes = this.node.attributes.filter(existingAttribute => {
	      return existingAttribute.name !== attribute.name;
	    });
	    attributes.push(attribute);
	    let parsedLinksData = parseAttribute(this.node.namespaceURI,
	      this.node.tagName, attributes, attribute.name);

	    // Create links in the attribute value, and collapse long attributes if
	    // needed.
	    let collapse = value => {
	      if (value && value.match(COLLAPSE_DATA_URL_REGEX)) {
	        return truncateString(value, COLLAPSE_DATA_URL_LENGTH);
	      }
	      return this.markup.collapseAttributes
	        ? truncateString(value, this.markup.collapseAttributeLength)
	        : value;
	    };

	    val.innerHTML = "";
	    for (let token of parsedLinksData) {
	      if (token.type === "string") {
	        val.appendChild(this.doc.createTextNode(collapse(token.value)));
	      } else {
	        let link = this.doc.createElement("span");
	        link.classList.add("link");
	        link.setAttribute("data-type", token.type);
	        link.setAttribute("data-link", token.value);
	        link.textContent = collapse(token.value);
	        val.appendChild(link);
	      }
	    }

	    name.textContent = attribute.name;

	    return attr;
	  },

	  /**
	   * Parse a user-entered attribute string and apply the resulting
	   * attributes to the node. This operation is undoable.
	   *
	   * @param  {String} value
	   *         The user-entered value.
	   * @param  {DOMNode} attrNode
	   *         The attribute editor that created this
	   *         set of attributes, used to place new attributes where the
	   *         user put them.
	   */
	  _applyAttributes: function (value, attrNode, doMods, undoMods) {
	    let attrs = parseAttributeValues(value, this.doc);
	    for (let attr of attrs) {
	      // Create an attribute editor next to the current attribute if needed.
	      this._createAttribute(attr, attrNode ? attrNode.nextSibling : null);
	      this._saveAttribute(attr.name, undoMods);
	      doMods.setAttribute(attr.name, attr.value);
	    }
	  },

	  /**
	   * Saves the current state of the given attribute into an attribute
	   * modification list.
	   */
	  _saveAttribute: function (name, undoMods) {
	    let node = this.node;
	    if (node.hasAttribute(name)) {
	      let oldValue = node.getAttribute(name);
	      undoMods.setAttribute(name, oldValue);
	    } else {
	      undoMods.removeAttribute(name);
	    }
	  },

	  /**
	   * Listen to mutations, and when the attribute list is regenerated
	   * try to focus on the attribute after the one that's being edited now.
	   * If the attribute order changes, go to the beginning of the attribute list.
	   */
	  refocusOnEdit: function (attrName, attrNode, direction) {
	    // Only allow one refocus on attribute change at a time, so when there's
	    // more than 1 request in parallel, the last one wins.
	    if (this._editedAttributeObserver) {
	      this.markup._inspector.off("markupmutation",
	        this._editedAttributeObserver);
	      this._editedAttributeObserver = null;
	    }

	    let container = this.markup.getContainer(this.node);

	    let activeAttrs = [...this.attrList.childNodes]
	      .filter(el => el.style.display != "none");
	    let attributeIndex = activeAttrs.indexOf(attrNode);

	    let onMutations = this._editedAttributeObserver = (e, mutations) => {
	      let isDeletedAttribute = false;
	      let isNewAttribute = false;

	      for (let mutation of mutations) {
	        let inContainer =
	          this.markup.getContainer(mutation.target) === container;
	        if (!inContainer) {
	          continue;
	        }

	        let isOriginalAttribute = mutation.attributeName === attrName;

	        isDeletedAttribute = isDeletedAttribute || isOriginalAttribute &&
	                             mutation.newValue === null;
	        isNewAttribute = isNewAttribute || mutation.attributeName !== attrName;
	      }

	      let isModifiedOrder = isDeletedAttribute && isNewAttribute;
	      this._editedAttributeObserver = null;

	      // "Deleted" attributes are merely hidden, so filter them out.
	      let visibleAttrs = [...this.attrList.childNodes]
	        .filter(el => el.style.display != "none");
	      let activeEditor;
	      if (visibleAttrs.length > 0) {
	        if (!direction) {
	          // No direction was given; stay on current attribute.
	          activeEditor = visibleAttrs[attributeIndex];
	        } else if (isModifiedOrder) {
	          // The attribute was renamed, reordering the existing attributes.
	          // So let's go to the beginning of the attribute list for consistency.
	          activeEditor = visibleAttrs[0];
	        } else {
	          let newAttributeIndex;
	          if (isDeletedAttribute) {
	            newAttributeIndex = attributeIndex;
	          } else if (direction == Services.focus.MOVEFOCUS_FORWARD) {
	            newAttributeIndex = attributeIndex + 1;
	          } else if (direction == Services.focus.MOVEFOCUS_BACKWARD) {
	            newAttributeIndex = attributeIndex - 1;
	          }

	          // The number of attributes changed (deleted), or we moved through
	          // the array so check we're still within bounds.
	          if (newAttributeIndex >= 0 &&
	              newAttributeIndex <= visibleAttrs.length - 1) {
	            activeEditor = visibleAttrs[newAttributeIndex];
	          }
	        }
	      }

	      // Either we have no attributes left,
	      // or we just edited the last attribute and want to move on.
	      if (!activeEditor) {
	        activeEditor = this.newAttr;
	      }

	      // Refocus was triggered by tab or shift-tab.
	      // Continue in edit mode.
	      if (direction) {
	        activeEditor.editMode();
	      } else {
	        // Refocus was triggered by enter.
	        // Exit edit mode (but restore focus).
	        let editable = activeEditor === this.newAttr ?
	          activeEditor : activeEditor.querySelector(".editable");
	        editable.focus();
	      }

	      this.markup.emit("refocusedonedit");
	    };

	    // Start listening for mutations until we find an attributes change
	    // that modifies this attribute.
	    this.markup._inspector.once("markupmutation", onMutations);
	  },

	  /**
	   * Called when the tag name editor has is done editing.
	   */
	  onTagEdit: function (newTagName, isCommit) {
	    if (!isCommit ||
	        newTagName.toLowerCase() === this.node.tagName.toLowerCase() ||
	        !("editTagName" in this.markup.walker)) {
	      return;
	    }

	    // Changing the tagName removes the node. Make sure the replacing node gets
	    // selected afterwards.
	    this.markup.reselectOnRemoved(this.node, "edittagname");
	    this.markup.walker.editTagName(this.node, newTagName).then(null, () => {
	      // Failed to edit the tag name, cancel the reselection.
	      this.markup.cancelReselectOnRemoved();
	    });
	  },

	  destroy: function () {
	    for (let key in this.animationTimers) {
	      clearTimeout(this.animationTimers[key]);
	    }
	    this.animationTimers = null;
	  }
	};

	function truncateString(str, maxLength) {
	  if (!str || str.length <= maxLength) {
	    return str;
	  }

	  return str.substring(0, Math.ceil(maxLength / 2)) +
	         "…" +
	         str.substring(str.length - Math.floor(maxLength / 2));
	}

	/**
	 * Parse attribute names and values from a string.
	 *
	 * @param  {String} attr
	 *         The input string for which names/values are to be parsed.
	 * @param  {HTMLDocument} doc
	 *         A document that can be used to test valid attributes.
	 * @return {Array}
	 *         An array of attribute names and their values.
	 */
	function parseAttributeValues(attr, doc) {
	  attr = attr.trim();

	  let parseAndGetNode = str => {
	    return new DOMParser().parseFromString(str, "text/html").body.childNodes[0];
	  };

	  // Handle bad user inputs by appending a " or ' if it fails to parse without
	  // them. Also note that a SVG tag is used to make sure the HTML parser
	  // preserves mixed-case attributes
	  let el = parseAndGetNode("<svg " + attr + "></svg>") ||
	           parseAndGetNode("<svg " + attr + "\"></svg>") ||
	           parseAndGetNode("<svg " + attr + "'></svg>");

	  let div = doc.createElement("div");
	  let attributes = [];
	  for (let {name, value} of el.attributes) {
	    // Try to set on an element in the document, throws exception on bad input.
	    // Prevents InvalidCharacterError - "String contains an invalid character".
	    try {
	      div.setAttribute(name, value);
	      attributes.push({ name, value });
	    } catch (e) {
	      // This may throw exceptions on bad input.
	      // Prevents InvalidCharacterError - "String contains an invalid
	      // character".
	    }
	  }

	  return attributes;
	}

	/**
	 * Apply a 'flashed' background and foreground color to elements. Intended
	 * to be used with flashElementOff as a way of drawing attention to an element.
	 *
	 * @param  {Node} backgroundElt
	 *         The element to set the highlighted background color on.
	 * @param  {Node} foregroundElt
	 *         The element to set the matching foreground color on.
	 *         Optional.  This will equal backgroundElt if not set.
	 */
	function flashElementOn(backgroundElt, foregroundElt = backgroundElt) {
	  if (!backgroundElt || !foregroundElt) {
	    return;
	  }

	  // Make sure the animation class is not here
	  backgroundElt.classList.remove("flash-out");

	  // Change the background
	  backgroundElt.classList.add("theme-bg-contrast");

	  foregroundElt.classList.add("theme-fg-contrast");
	  [].forEach.call(
	    foregroundElt.querySelectorAll("[class*=theme-fg-color]"),
	    span => span.classList.add("theme-fg-contrast")
	  );
	}

	/**
	 * Remove a 'flashed' background and foreground color to elements.
	 * See flashElementOn.
	 *
	 * @param  {Node} backgroundElt
	 *         The element to reomve the highlighted background color on.
	 * @param  {Node} foregroundElt
	 *         The element to remove the matching foreground color on.
	 *         Optional.  This will equal backgroundElt if not set.
	 */
	function flashElementOff(backgroundElt, foregroundElt = backgroundElt) {
	  if (!backgroundElt || !foregroundElt) {
	    return;
	  }

	  // Add the animation class to smoothly remove the background
	  backgroundElt.classList.add("flash-out");

	  // Remove the background
	  backgroundElt.classList.remove("theme-bg-contrast");

	  foregroundElt.classList.remove("theme-fg-contrast");
	  [].forEach.call(
	    foregroundElt.querySelectorAll("[class*=theme-fg-color]"),
	    span => span.classList.remove("theme-fg-contrast")
	  );
	}

	/**
	 * Map a number from one range to another.
	 */
	function map(value, oldMin, oldMax, newMin, newMax) {
	  let ratio = oldMax - oldMin;
	  if (ratio == 0) {
	    return value;
	  }
	  return newMin + (newMax - newMin) * ((value - oldMin) / ratio);
	}

	/**
	 * Retrieve the available width between a provided element left edge and a container right
	 * edge. This used can be used as a max-width for inplace-editor (autocomplete) widgets
	 * replacing Editor elements of the the markup-view;
	 */
	function getAutocompleteMaxWidth(element, container) {
	  let elementRect = element.getBoundingClientRect();
	  let containerRect = container.getBoundingClientRect();
	  return containerRect.right - elementRect.left - 2;
	}

	exports.MarkupView = MarkupView;


/***/ },
/* 168 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * A simple undo stack manager.
	 *
	 * Actions are added along with the necessary code to
	 * reverse the action.
	 *
	 * @param integer maxUndo Maximum number of undo steps.
	 *   defaults to 50.
	 */
	function UndoStack(maxUndo) {
	  this.maxUndo = maxUndo || 50;
	  this._stack = [];
	}

	exports.UndoStack = UndoStack;

	UndoStack.prototype = {
	  // Current index into the undo stack.  Is positioned after the last
	  // currently-applied change.
	  _index: 0,

	  // The current batch depth (see startBatch() for details)
	  _batchDepth: 0,

	  destroy: function () {
	    this.uninstallController();
	    delete this._stack;
	  },

	  /**
	   * Start a collection of related changes.  Changes will be batched
	   * together into one undo/redo item until endBatch() is called.
	   *
	   * Batches can be nested, in which case the outer batch will contain
	   * all items from the inner batches.  This allows larger user
	   * actions made up of a collection of smaller actions to be
	   * undone as a single action.
	   */
	  startBatch: function () {
	    if (this._batchDepth++ === 0) {
	      this._batch = [];
	    }
	  },

	  /**
	   * End a batch of related changes, performing its action and adding
	   * it to the undo stack.
	   */
	  endBatch: function () {
	    if (--this._batchDepth > 0) {
	      return;
	    }

	    // Cut off the end of the undo stack at the current index,
	    // and the beginning to prevent a stack larger than maxUndo.
	    let start = Math.max((this._index + 1) - this.maxUndo, 0);
	    this._stack = this._stack.slice(start, this._index);

	    let batch = this._batch;
	    delete this._batch;
	    let entry = {
	      do: function () {
	        for (let item of batch) {
	          item.do();
	        }
	      },
	      undo: function () {
	        for (let i = batch.length - 1; i >= 0; i--) {
	          batch[i].undo();
	        }
	      }
	    };
	    this._stack.push(entry);
	    this._index = this._stack.length;
	    entry.do();
	    this._change();
	  },

	  /**
	   * Perform an action, adding it to the undo stack.
	   *
	   * @param function toDo Called to perform the action.
	   * @param function undo Called to reverse the action.
	   */
	  do: function (toDo, undo) {
	    this.startBatch();
	    this._batch.push({ do: toDo, undo });
	    this.endBatch();
	  },

	  /*
	   * Returns true if undo() will do anything.
	   */
	  canUndo: function () {
	    return this._index > 0;
	  },

	  /**
	   * Undo the top of the undo stack.
	   *
	   * @return true if an action was undone.
	   */
	  undo: function () {
	    if (!this.canUndo()) {
	      return false;
	    }
	    this._stack[--this._index].undo();
	    this._change();
	    return true;
	  },

	  /**
	   * Returns true if redo() will do anything.
	   */
	  canRedo: function () {
	    return this._stack.length > this._index;
	  },

	  /**
	   * Redo the most recently undone action.
	   *
	   * @return true if an action was redone.
	   */
	  redo: function () {
	    if (!this.canRedo()) {
	      return false;
	    }
	    this._stack[this._index++].do();
	    this._change();
	    return true;
	  },

	  _change: function () {
	    if (this._controllerWindow) {
	      this._controllerWindow.goUpdateCommand("cmd_undo");
	      this._controllerWindow.goUpdateCommand("cmd_redo");
	    }
	  },

	  /**
	   * ViewController implementation for undo/redo.
	   */

	  /**
	   * Install this object as a command controller.
	   */
	  installController: function (controllerWindow) {
	    this._controllerWindow = controllerWindow;
	    // controllerWindow.controllers.appendController(this);
	  },

	  /**
	   * Uninstall this object from the command controller.
	   */
	  uninstallController: function () {
	    if (!this._controllerWindow) {
	      return;
	    }
	    // this._controllerWindow.controllers.removeController(this);
	  },

	  supportsCommand: function (command) {
	    return (command == "cmd_undo" ||
	            command == "cmd_redo");
	  },

	  isCommandEnabled: function (command) {
	    switch (command) {
	      case "cmd_undo": return this.canUndo();
	      case "cmd_redo": return this.canRedo();
	    }
	    return false;
	  },

	  doCommand: function (command) {
	    switch (command) {
	      case "cmd_undo": return this.undo();
	      case "cmd_redo": return this.redo();
	      default: return null;
	    }
	  },

	  onEvent: function (event) {},
	};


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const Editor = __webpack_require__(170);
	const Services = __webpack_require__(1);
	const EventEmitter = __webpack_require__(6);

	/**
	 * A wrapper around the Editor component, that allows editing of HTML.
	 *
	 * The main functionality this provides around the Editor is the ability
	 * to show/hide/position an editor inplace. It only appends once to the
	 * body, and uses CSS to position the editor.  The reason it is done this
	 * way is that the editor is loaded in an iframe, and calling appendChild
	 * causes it to reload.
	 *
	 * Meant to be embedded inside of an HTML page, as in markup.xhtml.
	 *
	 * @param HTMLDocument htmlDocument
	 *        The document to attach the editor to.  Will also use this
	 *        document as a basis for listening resize events.
	 */
	function HTMLEditor(htmlDocument) {
	  this.doc = htmlDocument;
	  this.container = this.doc.createElement("div");
	  this.container.className = "html-editor theme-body";
	  this.container.style.display = "none";
	  this.editorInner = this.doc.createElement("div");
	  this.editorInner.className = "html-editor-inner";
	  this.container.appendChild(this.editorInner);

	  this.doc.body.appendChild(this.container);
	  this.hide = this.hide.bind(this);
	  this.refresh = this.refresh.bind(this);

	  EventEmitter.decorate(this);

	  this.doc.defaultView.addEventListener("resize",
	    this.refresh, true);

	  let config = {
	    mode: Editor.modes.html,
	    lineWrapping: true,
	    styleActiveLine: false,
	    extraKeys: {},
	    theme: "mozilla markup-view"
	  };

	  config.extraKeys[ctrl("Enter")] = this.hide;
	  config.extraKeys.F2 = this.hide;
	  config.extraKeys.Esc = this.hide.bind(this, false);

	  this.container.addEventListener("click", this.hide, false);
	  this.editorInner.addEventListener("click", stopPropagation, false);
	  this.editor = new Editor(config);

	  let iframe = this.editorInner.ownerDocument.createElement("iframe");
	  this.editor.appendTo(this.editorInner, iframe).then(() => {
	    this.hide(false);
	  }).then(null, (err) => console.log(err.message));
	}

	HTMLEditor.prototype = {

	  /**
	   * Need to refresh position by manually setting CSS values, so this will
	   * need to be called on resizes and other sizing changes.
	   */
	  refresh: function () {
	    let element = this._attachedElement;

	    if (element) {
	      this.container.style.top = element.offsetTop + "px";
	      this.container.style.left = element.offsetLeft + "px";
	      this.container.style.width = element.offsetWidth + "px";
	      this.container.style.height = element.parentNode.offsetHeight + "px";
	      this.editor.refresh();
	    }
	  },

	  /**
	   * Anchor the editor to a particular element.
	   *
	   * @param DOMNode element
	   *        The element that the editor will be anchored to.
	   *        Should belong to the HTMLDocument passed into the constructor.
	   */
	  _attach: function (element) {
	    this._detach();
	    this._attachedElement = element;
	    element.classList.add("html-editor-container");
	    this.refresh();
	  },

	  /**
	   * Unanchor the editor from an element.
	   */
	  _detach: function () {
	    if (this._attachedElement) {
	      this._attachedElement.classList.remove("html-editor-container");
	      this._attachedElement = undefined;
	    }
	  },

	  /**
	   * Anchor the editor to a particular element, and show the editor.
	   *
	   * @param DOMNode element
	   *        The element that the editor will be anchored to.
	   *        Should belong to the HTMLDocument passed into the constructor.
	   * @param string text
	   *        Value to set the contents of the editor to
	   * @param function cb
	   *        The function to call when hiding
	   */
	  show: function (element, text) {
	    if (this._visible) {
	      return;
	    }

	    this._originalValue = text;
	    this.editor.setText(text);
	    this._attach(element);
	    this.container.style.display = "flex";
	    this._visible = true;

	    this.editor.refresh();
	    this.editor.focus();

	    this.emit("popupshown");
	  },

	  /**
	   * Hide the editor, optionally committing the changes
	   *
	   * @param bool shouldCommit
	   *             A change will be committed by default.  If this param
	   *             strictly equals false, no change will occur.
	   */
	  hide: function (shouldCommit) {
	    if (!this._visible) {
	      return;
	    }

	    this.container.style.display = "none";
	    this._detach();

	    let newValue = this.editor.getText();
	    let valueHasChanged = this._originalValue !== newValue;
	    let preventCommit = shouldCommit === false || !valueHasChanged;
	    this._originalValue = undefined;
	    this._visible = undefined;
	    this.emit("popuphidden", !preventCommit, newValue);
	  },

	  /**
	   * Destroy this object and unbind all event handlers
	   */
	  destroy: function () {
	    this.doc.defaultView.removeEventListener("resize",
	      this.refresh, true);
	    this.container.removeEventListener("click", this.hide, false);
	    this.editorInner.removeEventListener("click", stopPropagation, false);

	    this.hide(false);
	    this.container.remove();
	    this.editor.destroy();
	  }
	};

	function ctrl(k) {
	  return (Services.appinfo.OS == "Darwin" ? "Cmd-" : "Ctrl-") + k;
	}

	function stopPropagation(e) {
	  e.stopPropagation();
	}

	exports.HTMLEditor = HTMLEditor;


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2; fill-column: 80 -*- */
	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {
	  EXPAND_TAB,
	  TAB_SIZE,
	  DETECT_INDENT,
	  getIndentationFromIteration
	} = __webpack_require__(171);

	const ENABLE_CODE_FOLDING = "devtools.editor.enableCodeFolding";
	const KEYMAP = "devtools.editor.keymap";
	const AUTO_CLOSE = "devtools.editor.autoclosebrackets";
	const AUTOCOMPLETE = "devtools.editor.autocomplete";
	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	const VALID_KEYMAPS = new Set(["emacs", "vim", "sublime"]);

	// Maximum allowed margin (in number of lines) from top or bottom of the editor
	// while shifting to a line which was initially out of view.
	const MAX_VERTICAL_OFFSET = 3;

	// Match @Scratchpad/N:LINE[:COLUMN] or (LINE[:COLUMN]) anywhere at an end of
	// line in text selection.
	const RE_SCRATCHPAD_ERROR = /(?:@Scratchpad\/\d+:|\()(\d+):?(\d+)?(?:\)|\n)/;
	const RE_JUMP_TO_LINE = /^(\d+):?(\d+)?/;

	const Services = __webpack_require__(1);
	const promise = __webpack_require__(4);
	const events = __webpack_require__(6);
	const { PrefObserver } = __webpack_require__(130);
	const { getClientCssProperties } = __webpack_require__(18);

	const {LocalizationHelper} = __webpack_require__(39);
	const L10N = new LocalizationHelper("devtools/locale/sourceeditor.properties");

	const { OS } = Services.appinfo;

	// CM_STYLES, CM_SCRIPTS and CM_IFRAME represent the HTML,
	// JavaScript and CSS that is injected into an iframe in
	// order to initialize a CodeMirror instance.

	const CM_STYLES = [
	  "chrome://devtools/content/sourceeditor/codemirror/lib/codemirror.css",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/dialog/dialog.css",
	  "chrome://devtools/content/sourceeditor/codemirror/mozilla.css"
	];

	const CM_SCRIPTS = [
	  "chrome://devtools/content/shared/theme-switching.js",
	  "chrome://devtools/content/sourceeditor/codemirror/lib/codemirror.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/dialog/dialog.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/search/searchcursor.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/search/search.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/edit/matchbrackets.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/edit/closebrackets.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/comment/comment.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/javascript.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/xml.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/css.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/htmlmixed.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/clike.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/wasm.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/selection/active-line.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/edit/trailingspace.js",
	  "chrome://devtools/content/sourceeditor/codemirror/keymap/emacs.js",
	  "chrome://devtools/content/sourceeditor/codemirror/keymap/vim.js",
	  "chrome://devtools/content/sourceeditor/codemirror/keymap/sublime.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/foldcode.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/brace-fold.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/comment-fold.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/xml-fold.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/foldgutter.js"
	];

	const CM_IFRAME =
	  "data:text/html;charset=utf8,<!DOCTYPE html>" +
	  "<html dir='ltr'>" +
	  "  <head>" +
	  "    <style>" +
	  "      html, body { height: 100%; }" +
	  "      body { margin: 0; overflow: hidden; }" +
	  "      .CodeMirror { width: 100%; height: 100% !important; " +
	  "line-height: 1.25 !important;}" +
	  "    </style>" +
	  CM_STYLES.map(style => "<link rel='stylesheet' href='" + style + "'>").join("\n") +
	  "  </head>" +
	  "  <body class='theme-body devtools-monospace'></body>" +
	  "</html>";

	const CM_MAPPING = [
	  "focus",
	  "hasFocus",
	  "lineCount",
	  "somethingSelected",
	  "getCursor",
	  "setSelection",
	  "getSelection",
	  "replaceSelection",
	  "extendSelection",
	  "undo",
	  "redo",
	  "clearHistory",
	  "openDialog",
	  "refresh",
	  "getScrollInfo",
	  "getViewport"
	];

	const editors = new WeakMap();

	Editor.modes = {
	  text: { name: "text" },
	  html: { name: "htmlmixed" },
	  css: { name: "css" },
	  wasm: { name: "wasm" },
	  js: { name: "javascript" },
	  vs: { name: "x-shader/x-vertex" },
	  fs: { name: "x-shader/x-fragment" }
	};

	/**
	 * A very thin wrapper around CodeMirror. Provides a number
	 * of helper methods to make our use of CodeMirror easier and
	 * another method, appendTo, to actually create and append
	 * the CodeMirror instance.
	 *
	 * Note that Editor doesn't expose CodeMirror instance to the
	 * outside world.
	 *
	 * Constructor accepts one argument, config. It is very
	 * similar to the CodeMirror configuration object so for most
	 * properties go to CodeMirror's documentation (see below).
	 *
	 * Other than that, it accepts one additional and optional
	 * property contextMenu. This property should be an element, or
	 * an ID of an element that we can use as a context menu.
	 *
	 * This object is also an event emitter.
	 *
	 * CodeMirror docs: http://codemirror.net/doc/manual.html
	 */
	function Editor(config) {
	  const tabSize = Services.prefs.getIntPref(TAB_SIZE);
	  const useTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
	  const useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);

	  this.version = null;
	  this.config = {
	    value: "",
	    mode: Editor.modes.text,
	    indentUnit: tabSize,
	    tabSize: tabSize,
	    contextMenu: null,
	    matchBrackets: true,
	    extraKeys: {},
	    indentWithTabs: useTabs,
	    inputStyle: "textarea",
	    styleActiveLine: true,
	    autoCloseBrackets: "()[]{}''\"\"``",
	    autoCloseEnabled: useAutoClose,
	    theme: "mozilla",
	    themeSwitching: true,
	    autocomplete: false,
	    autocompleteOpts: {}
	  };

	  // Additional shortcuts.
	  this.config.extraKeys[Editor.keyFor("jumpToLine")] = () => this.jumpToLine();
	  this.config.extraKeys[Editor.keyFor("moveLineUp", { noaccel: true })] =
	    () => this.moveLineUp();
	  this.config.extraKeys[Editor.keyFor("moveLineDown", { noaccel: true })] =
	    () => this.moveLineDown();
	  this.config.extraKeys[Editor.keyFor("toggleComment")] = "toggleComment";

	  // Disable ctrl-[ and ctrl-] because toolbox uses those shortcuts.
	  this.config.extraKeys[Editor.keyFor("indentLess")] = false;
	  this.config.extraKeys[Editor.keyFor("indentMore")] = false;

	  // Overwrite default config with user-provided, if needed.
	  Object.keys(config).forEach(k => {
	    if (k != "extraKeys") {
	      this.config[k] = config[k];
	      return;
	    }

	    if (!config.extraKeys) {
	      return;
	    }

	    Object.keys(config.extraKeys).forEach(key => {
	      this.config.extraKeys[key] = config.extraKeys[key];
	    });
	  });

	  if (!this.config.gutters) {
	    this.config.gutters = [];
	  }
	  if (this.config.lineNumbers
	      && this.config.gutters.indexOf("CodeMirror-linenumbers") === -1) {
	    this.config.gutters.push("CodeMirror-linenumbers");
	  }

	  // Remember the initial value of autoCloseBrackets.
	  this.config.autoCloseBracketsSaved = this.config.autoCloseBrackets;

	  // Overwrite default tab behavior. If something is selected,
	  // indent those lines. If nothing is selected and we're
	  // indenting with tabs, insert one tab. Otherwise insert N
	  // whitespaces where N == indentUnit option.
	  this.config.extraKeys.Tab = cm => {
	    if (cm.somethingSelected()) {
	      cm.indentSelection("add");
	      return;
	    }

	    if (this.config.indentWithTabs) {
	      cm.replaceSelection("\t", "end", "+input");
	      return;
	    }

	    let num = cm.getOption("indentUnit");
	    if (cm.getCursor().ch !== 0) {
	      num -= 1;
	    }
	    cm.replaceSelection(" ".repeat(num), "end", "+input");
	  };

	  // Allow add-ons to inject scripts for their editor instances
	  if (!this.config.externalScripts) {
	    this.config.externalScripts = [];
	  }

	  if (this.config.cssProperties) {
	    // Ensure that autocompletion has cssProperties if it's passed in via the options.
	    this.config.autocompleteOpts.cssProperties = this.config.cssProperties;
	  } else {
	    // Use a static client-side database of CSS values if none is provided.
	    this.config.cssProperties = getClientCssProperties();
	  }

	  events.decorate(this);
	}

	Editor.prototype = {
	  container: null,
	  version: null,
	  config: null,
	  Doc: null,

	  /**
	   * Appends the current Editor instance to the element specified by
	   * 'el'. You can also provide your won iframe to host the editor as
	   * an optional second parameter. This method actually creates and
	   * loads CodeMirror and all its dependencies.
	   *
	   * This method is asynchronous and returns a promise.
	   */
	  appendTo: function (el, env) {
	    let def = promise.defer();
	    let cm = editors.get(this);

	    if (!env) {
	      env = el.ownerDocument.createElementNS(XUL_NS, "iframe");
	    }

	    env.flex = 1;

	    if (cm) {
	      throw new Error("You can append an editor only once.");
	    }

	    let onLoad = () => {
	      // Once the iframe is loaded, we can inject CodeMirror
	      // and its dependencies into its DOM.

	      env.removeEventListener("load", onLoad, true);
	      let win = env.contentWindow.wrappedJSObject;

	      if (!this.config.themeSwitching) {
	        win.document.documentElement.setAttribute("force-theme", "light");
	      }

	      let scriptsToInject = CM_SCRIPTS.concat(this.config.externalScripts);
	      scriptsToInject.forEach(url => {
	        if (url.startsWith("chrome://")) {
	          Services.scriptloader.loadSubScript(url, win, "utf8");
	        }
	      });
	      // Replace the propertyKeywords, colorKeywords and valueKeywords
	      // properties of the CSS MIME type with the values provided by the CSS properties
	      // database.

	      const {
	        propertyKeywords,
	        colorKeywords,
	        valueKeywords
	      } = getCSSKeywords(this.config.cssProperties);

	      let cssSpec = win.CodeMirror.resolveMode("text/css");
	      cssSpec.propertyKeywords = propertyKeywords;
	      cssSpec.colorKeywords = colorKeywords;
	      cssSpec.valueKeywords = valueKeywords;
	      win.CodeMirror.defineMIME("text/css", cssSpec);

	      let scssSpec = win.CodeMirror.resolveMode("text/x-scss");
	      scssSpec.propertyKeywords = propertyKeywords;
	      scssSpec.colorKeywords = colorKeywords;
	      scssSpec.valueKeywords = valueKeywords;
	      win.CodeMirror.defineMIME("text/x-scss", scssSpec);

	      win.CodeMirror.commands.save = () => this.emit("saveRequested");

	      // Create a CodeMirror instance add support for context menus,
	      // overwrite the default controller (otherwise items in the top and
	      // context menus won't work).

	      cm = win.CodeMirror(win.document.body, this.config);
	      this.Doc = win.CodeMirror.Doc;

	      // Disable APZ for source editors. It currently causes the line numbers to
	      // "tear off" and swim around on top of the content. Bug 1160601 tracks
	      // finding a solution that allows APZ to work with CodeMirror.
	      cm.getScrollerElement().addEventListener("wheel", ev => {
	        // By handling the wheel events ourselves, we force the platform to
	        // scroll synchronously, like it did before APZ. However, we lose smooth
	        // scrolling for users with mouse wheels. This seems acceptible vs.
	        // doing nothing and letting the gutter slide around.
	        ev.preventDefault();

	        let { deltaX, deltaY } = ev;

	        if (ev.deltaMode == ev.DOM_DELTA_LINE) {
	          deltaX *= cm.defaultCharWidth();
	          deltaY *= cm.defaultTextHeight();
	        } else if (ev.deltaMode == ev.DOM_DELTA_PAGE) {
	          deltaX *= cm.getWrapperElement().clientWidth;
	          deltaY *= cm.getWrapperElement().clientHeight;
	        }

	        cm.getScrollerElement().scrollBy(deltaX, deltaY);
	      });

	      cm.getWrapperElement().addEventListener("contextmenu", ev => {
	        ev.preventDefault();

	        if (!this.config.contextMenu) {
	          return;
	        }

	        let popup = this.config.contextMenu;
	        if (typeof popup == "string") {
	          popup = el.ownerDocument.getElementById(this.config.contextMenu);
	        }

	        this.emit("popupOpen", ev, popup);
	        popup.openPopupAtScreen(ev.screenX, ev.screenY, true);
	      }, false);

	      // Intercept the find and find again keystroke on CodeMirror, to avoid
	      // the browser's search

	      let findKey = L10N.getStr("find.commandkey");
	      let findAgainKey = L10N.getStr("findAgain.commandkey");
	      let [accel, modifier] = OS === "Darwin"
	                                      ? ["metaKey", "altKey"]
	                                      : ["ctrlKey", "shiftKey"];

	      cm.getWrapperElement().addEventListener("keydown", ev => {
	        let key = ev.key.toUpperCase();
	        let node = ev.originalTarget;
	        let isInput = node.tagName === "INPUT";
	        let isSearchInput = isInput && node.type === "search";

	        // replace box is a different input instance than search, and it is
	        // located in a code mirror dialog
	        let isDialogInput = isInput &&
	                       node.parentNode &&
	                       node.parentNode.classList.contains("CodeMirror-dialog");

	        if (!ev[accel] || !(isSearchInput || isDialogInput)) {
	          return;
	        }

	        if (key === findKey) {
	          ev.preventDefault();

	          if (isSearchInput || ev[modifier]) {
	            node.select();
	          }
	        } else if (key === findAgainKey) {
	          ev.preventDefault();

	          if (!isSearchInput) {
	            return;
	          }

	          let query = node.value;

	          // If there isn't a search state, or the text in the input does not
	          // match with the current search state, we need to create a new one
	          if (!cm.state.search || cm.state.search.query !== query) {
	            cm.state.search = {
	              posFrom: null,
	              posTo: null,
	              overlay: null,
	              query
	            };
	          }

	          if (ev.shiftKey) {
	            cm.execCommand("findPrev");
	          } else {
	            cm.execCommand("findNext");
	          }
	        }
	      });

	      cm.on("focus", () => this.emit("focus"));
	      cm.on("scroll", () => this.emit("scroll"));
	      cm.on("change", () => {
	        this.emit("change");
	        if (!this._lastDirty) {
	          this._lastDirty = true;
	          this.emit("dirty-change");
	        }
	      });
	      cm.on("cursorActivity", () => this.emit("cursorActivity"));

	      cm.on("gutterClick", (cmArg, line, gutter, ev) => {
	        let head = { line: line, ch: 0 };
	        let tail = { line: line, ch: this.getText(line).length };

	        // Shift-click on a gutter selects the whole line.
	        if (ev.shiftKey) {
	          cmArg.setSelection(head, tail);
	          return;
	        }

	        this.emit("gutterClick", line, ev.button);
	      });

	      win.CodeMirror.defineExtension("l10n", (name) => {
	        return L10N.getStr(name);
	      });

	      cm.getInputField().controllers.insertControllerAt(0, controller(this));

	      this.container = env;
	      editors.set(this, cm);

	      this.reloadPreferences = this.reloadPreferences.bind(this);
	      this._prefObserver = new PrefObserver("devtools.editor.");
	      this._prefObserver.on(TAB_SIZE, this.reloadPreferences);
	      this._prefObserver.on(EXPAND_TAB, this.reloadPreferences);
	      this._prefObserver.on(KEYMAP, this.reloadPreferences);
	      this._prefObserver.on(AUTO_CLOSE, this.reloadPreferences);
	      this._prefObserver.on(AUTOCOMPLETE, this.reloadPreferences);
	      this._prefObserver.on(DETECT_INDENT, this.reloadPreferences);
	      this._prefObserver.on(ENABLE_CODE_FOLDING, this.reloadPreferences);

	      this.reloadPreferences();

	      win.editor = this;
	      let editorReadyEvent = new win.CustomEvent("editorReady");
	      win.dispatchEvent(editorReadyEvent);

	      def.resolve();
	    };

	    env.addEventListener("load", onLoad, true);
	    env.setAttribute("src", CM_IFRAME);
	    el.appendChild(env);

	    this.once("destroy", () => el.removeChild(env));
	    return def.promise;
	  },

	  /**
	   * Returns a boolean indicating whether the editor is ready to
	   * use. Use appendTo(el).then(() => {}) for most cases
	   */
	  isAppended: function () {
	    return editors.has(this);
	  },

	  /**
	   * Returns the currently active highlighting mode.
	   * See Editor.modes for the list of all suppoert modes.
	   */
	  getMode: function () {
	    return this.getOption("mode");
	  },

	  /**
	   * Loads a script into editor's containing window.
	   */
	  loadScript: function (url) {
	    if (!this.container) {
	      throw new Error("Can't load a script until the editor is loaded.");
	    }
	    let win = this.container.contentWindow.wrappedJSObject;
	    Services.scriptloader.loadSubScript(url, win, "utf8");
	  },

	  /**
	   * Creates a CodeMirror Document
	   * @returns CodeMirror.Doc
	   */
	  createDocument: function () {
	    return new this.Doc("");
	  },

	  /**
	   * Replaces the current document with a new source document
	   */
	  replaceDocument: function (doc) {
	    let cm = editors.get(this);
	    cm.swapDoc(doc);
	  },

	  /**
	   * Changes the value of a currently used highlighting mode.
	   * See Editor.modes for the list of all supported modes.
	   */
	  setMode: function (value) {
	    this.setOption("mode", value);

	    // If autocomplete was set up and the mode is changing, then
	    // turn it off and back on again so the proper mode can be used.
	    if (this.config.autocomplete) {
	      this.setOption("autocomplete", false);
	      this.setOption("autocomplete", true);
	    }
	  },

	  /**
	   * Returns text from the text area. If line argument is provided
	   * the method returns only that line.
	   */
	  getText: function (line) {
	    let cm = editors.get(this);

	    if (line == null) {
	      return cm.getValue();
	    }

	    let info = cm.lineInfo(line);
	    return info ? cm.lineInfo(line).text : "";
	  },

	  /**
	   * Replaces whatever is in the text area with the contents of
	   * the 'value' argument.
	   */
	  setText: function (value) {
	    let cm = editors.get(this);
	    cm.setValue(value);

	    this.resetIndentUnit();
	  },

	  /**
	   * Reloads the state of the editor based on all current preferences.
	   * This is called automatically when any of the relevant preferences
	   * change.
	   */
	  reloadPreferences: function () {
	    // Restore the saved autoCloseBrackets value if it is preffed on.
	    let useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);
	    this.setOption("autoCloseBrackets",
	      useAutoClose ? this.config.autoCloseBracketsSaved : false);

	    // If alternative keymap is provided, use it.
	    const keyMap = Services.prefs.getCharPref(KEYMAP);
	    if (VALID_KEYMAPS.has(keyMap)) {
	      this.setOption("keyMap", keyMap);
	    } else {
	      this.setOption("keyMap", "default");
	    }
	    this.updateCodeFoldingGutter();

	    this.resetIndentUnit();
	    this.setupAutoCompletion();
	  },

	  /**
	   * Sets the editor's indentation based on the current prefs and
	   * re-detect indentation if we should.
	   */
	  resetIndentUnit: function () {
	    let cm = editors.get(this);

	    let iterFn = function (start, end, callback) {
	      cm.eachLine(start, end, (line) => {
	        return callback(line.text);
	      });
	    };

	    let {indentUnit, indentWithTabs} = getIndentationFromIteration(iterFn);

	    cm.setOption("tabSize", indentUnit);
	    cm.setOption("indentUnit", indentUnit);
	    cm.setOption("indentWithTabs", indentWithTabs);
	  },

	  /**
	   * Replaces contents of a text area within the from/to {line, ch}
	   * range. If neither `from` nor `to` arguments are provided works
	   * exactly like setText. If only `from` object is provided, inserts
	   * text at that point, *overwriting* as many characters as needed.
	   */
	  replaceText: function (value, from, to) {
	    let cm = editors.get(this);

	    if (!from) {
	      this.setText(value);
	      return;
	    }

	    if (!to) {
	      let text = cm.getRange({ line: 0, ch: 0 }, from);
	      this.setText(text + value);
	      return;
	    }

	    cm.replaceRange(value, from, to);
	  },

	  /**
	   * Inserts text at the specified {line, ch} position, shifting existing
	   * contents as necessary.
	   */
	  insertText: function (value, at) {
	    let cm = editors.get(this);
	    cm.replaceRange(value, at, at);
	  },

	  /**
	   * Deselects contents of the text area.
	   */
	  dropSelection: function () {
	    if (!this.somethingSelected()) {
	      return;
	    }

	    this.setCursor(this.getCursor());
	  },

	  /**
	   * Returns true if there is more than one selection in the editor.
	   */
	  hasMultipleSelections: function () {
	    let cm = editors.get(this);
	    return cm.listSelections().length > 1;
	  },

	  /**
	   * Gets the first visible line number in the editor.
	   */
	  getFirstVisibleLine: function () {
	    let cm = editors.get(this);
	    return cm.lineAtHeight(0, "local");
	  },

	  /**
	   * Scrolls the view such that the given line number is the first visible line.
	   */
	  setFirstVisibleLine: function (line) {
	    let cm = editors.get(this);
	    let { top } = cm.charCoords({line: line, ch: 0}, "local");
	    cm.scrollTo(0, top);
	  },

	  /**
	   * Sets the cursor to the specified {line, ch} position with an additional
	   * option to align the line at the "top", "center" or "bottom" of the editor
	   * with "top" being default value.
	   */
	  setCursor: function ({line, ch}, align) {
	    let cm = editors.get(this);
	    this.alignLine(line, align);
	    cm.setCursor({line: line, ch: ch});
	    this.emit("cursorActivity");
	  },

	  /**
	   * Aligns the provided line to either "top", "center" or "bottom" of the
	   * editor view with a maximum margin of MAX_VERTICAL_OFFSET lines from top or
	   * bottom.
	   */
	  alignLine: function (line, align) {
	    let cm = editors.get(this);
	    let from = cm.lineAtHeight(0, "page");
	    let to = cm.lineAtHeight(cm.getWrapperElement().clientHeight, "page");
	    let linesVisible = to - from;
	    let halfVisible = Math.round(linesVisible / 2);

	    // If the target line is in view, skip the vertical alignment part.
	    if (line <= to && line >= from) {
	      return;
	    }

	    // Setting the offset so that the line always falls in the upper half
	    // of visible lines (lower half for bottom aligned).
	    // MAX_VERTICAL_OFFSET is the maximum allowed value.
	    let offset = Math.min(halfVisible, MAX_VERTICAL_OFFSET);

	    let topLine = {
	      "center": Math.max(line - halfVisible, 0),
	      "bottom": Math.max(line - linesVisible + offset, 0),
	      "top": Math.max(line - offset, 0)
	    }[align || "top"] || offset;

	    // Bringing down the topLine to total lines in the editor if exceeding.
	    topLine = Math.min(topLine, this.lineCount());
	    this.setFirstVisibleLine(topLine);
	  },

	  /**
	   * Returns whether a marker of a specified class exists in a line's gutter.
	   */
	  hasMarker: function (line, gutterName, markerClass) {
	    let marker = this.getMarker(line, gutterName);
	    if (!marker) {
	      return false;
	    }

	    return marker.classList.contains(markerClass);
	  },

	  /**
	   * Adds a marker with a specified class to a line's gutter. If another marker
	   * exists on that line, the new marker class is added to its class list.
	   */
	  addMarker: function (line, gutterName, markerClass) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) {
	      return;
	    }

	    let gutterMarkers = info.gutterMarkers;
	    let marker;
	    if (gutterMarkers) {
	      marker = gutterMarkers[gutterName];
	      if (marker) {
	        marker.classList.add(markerClass);
	        return;
	      }
	    }

	    marker = cm.getWrapperElement().ownerDocument.createElement("div");
	    marker.className = markerClass;
	    cm.setGutterMarker(info.line, gutterName, marker);
	  },

	  /**
	   * The reverse of addMarker. Removes a marker of a specified class from a
	   * line's gutter.
	   */
	  removeMarker: function (line, gutterName, markerClass) {
	    if (!this.hasMarker(line, gutterName, markerClass)) {
	      return;
	    }

	    let cm = editors.get(this);
	    cm.lineInfo(line).gutterMarkers[gutterName].classList.remove(markerClass);
	  },

	  /**
	   * Adds a marker with a specified class and an HTML content to a line's
	   * gutter. If another marker exists on that line, it is overwritten by a new
	   * marker.
	   */
	  addContentMarker: function (line, gutterName, markerClass, content) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) {
	      return;
	    }

	    let marker = cm.getWrapperElement().ownerDocument.createElement("div");
	    marker.className = markerClass;
	    marker.innerHTML = content;
	    cm.setGutterMarker(info.line, gutterName, marker);
	  },

	  /**
	   * The reverse of addContentMarker. Removes any line's markers in the
	   * specified gutter.
	   */
	  removeContentMarker: function (line, gutterName) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) {
	      return;
	    }

	    cm.setGutterMarker(info.line, gutterName, null);
	  },

	  getMarker: function (line, gutterName) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) {
	      return null;
	    }

	    let gutterMarkers = info.gutterMarkers;
	    if (!gutterMarkers) {
	      return null;
	    }

	    return gutterMarkers[gutterName];
	  },

	  /**
	   * Removes all gutter markers in the gutter with the given name.
	   */
	  removeAllMarkers: function (gutterName) {
	    let cm = editors.get(this);
	    cm.clearGutter(gutterName);
	  },

	  /**
	   * Handles attaching a set of events listeners on a marker. They should
	   * be passed as an object literal with keys as event names and values as
	   * function listeners. The line number, marker node and optional data
	   * will be passed as arguments to the function listener.
	   *
	   * You don't need to worry about removing these event listeners.
	   * They're automatically orphaned when clearing markers.
	   */
	  setMarkerListeners: function (line, gutterName, markerClass, eventsArg, data) {
	    if (!this.hasMarker(line, gutterName, markerClass)) {
	      return;
	    }

	    let cm = editors.get(this);
	    let marker = cm.lineInfo(line).gutterMarkers[gutterName];

	    for (let name in eventsArg) {
	      let listener = eventsArg[name].bind(this, line, marker, data);
	      marker.addEventListener(name, listener);
	    }
	  },

	  /**
	   * Returns whether a line is decorated using the specified class name.
	   */
	  hasLineClass: function (line, className) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);

	    if (!info || !info.wrapClass) {
	      return false;
	    }

	    return info.wrapClass.split(" ").indexOf(className) != -1;
	  },

	  /**
	   * Sets a CSS class name for the given line, including the text and gutter.
	   */
	  addLineClass: function (line, className) {
	    let cm = editors.get(this);
	    cm.addLineClass(line, "wrap", className);
	  },

	  /**
	   * The reverse of addLineClass.
	   */
	  removeLineClass: function (line, className) {
	    let cm = editors.get(this);
	    cm.removeLineClass(line, "wrap", className);
	  },

	  /**
	   * Mark a range of text inside the two {line, ch} bounds. Since the range may
	   * be modified, for example, when typing text, this method returns a function
	   * that can be used to remove the mark.
	   */
	  markText: function (from, to, className = "marked-text") {
	    let cm = editors.get(this);
	    let text = cm.getRange(from, to);
	    let span = cm.getWrapperElement().ownerDocument.createElement("span");
	    span.className = className;
	    span.textContent = text;

	    let mark = cm.markText(from, to, { replacedWith: span });
	    return {
	      anchor: span,
	      clear: () => mark.clear()
	    };
	  },

	  /**
	   * Calculates and returns one or more {line, ch} objects for
	   * a zero-based index who's value is relative to the start of
	   * the editor's text.
	   *
	   * If only one argument is given, this method returns a single
	   * {line,ch} object. Otherwise it returns an array.
	   */
	  getPosition: function (...args) {
	    let cm = editors.get(this);
	    let res = args.map((ind) => cm.posFromIndex(ind));
	    return args.length === 1 ? res[0] : res;
	  },

	  /**
	   * The reverse of getPosition. Similarly to getPosition this
	   * method returns a single value if only one argument was given
	   * and an array otherwise.
	   */
	  getOffset: function (...args) {
	    let cm = editors.get(this);
	    let res = args.map((pos) => cm.indexFromPos(pos));
	    return args.length > 1 ? res : res[0];
	  },

	  /**
	   * Returns a {line, ch} object that corresponds to the
	   * left, top coordinates.
	   */
	  getPositionFromCoords: function ({left, top}) {
	    let cm = editors.get(this);
	    return cm.coordsChar({ left: left, top: top });
	  },

	  /**
	   * The reverse of getPositionFromCoords. Similarly, returns a {left, top}
	   * object that corresponds to the specified line and character number.
	   */
	  getCoordsFromPosition: function ({line, ch}) {
	    let cm = editors.get(this);
	    return cm.charCoords({ line: ~~line, ch: ~~ch });
	  },

	  /**
	   * Returns true if there's something to undo and false otherwise.
	   */
	  canUndo: function () {
	    let cm = editors.get(this);
	    return cm.historySize().undo > 0;
	  },

	  /**
	   * Returns true if there's something to redo and false otherwise.
	   */
	  canRedo: function () {
	    let cm = editors.get(this);
	    return cm.historySize().redo > 0;
	  },

	  /**
	   * Marks the contents as clean and returns the current
	   * version number.
	   */
	  setClean: function () {
	    let cm = editors.get(this);
	    this.version = cm.changeGeneration();
	    this._lastDirty = false;
	    this.emit("dirty-change");
	    return this.version;
	  },

	  /**
	   * Returns true if contents of the text area are
	   * clean i.e. no changes were made since the last version.
	   */
	  isClean: function () {
	    let cm = editors.get(this);
	    return cm.isClean(this.version);
	  },

	  /**
	   * This method opens an in-editor dialog asking for a line to
	   * jump to. Once given, it changes cursor to that line.
	   */
	  jumpToLine: function () {
	    let doc = editors.get(this).getWrapperElement().ownerDocument;
	    let div = doc.createElement("div");
	    let inp = doc.createElement("input");
	    let txt =
	      doc.createTextNode(L10N.getStr("gotoLineCmd.promptTitle"));

	    inp.type = "text";
	    inp.style.width = "10em";
	    inp.style.marginInlineStart = "1em";

	    div.appendChild(txt);
	    div.appendChild(inp);

	    if (!this.hasMultipleSelections()) {
	      let cm = editors.get(this);
	      let sel = cm.getSelection();
	      // Scratchpad inserts and selects a comment after an error happens:
	      // "@Scratchpad/1:10:2". Parse this to get the line and column.
	      // In the string above this is line 10, column 2.
	      let match = sel.match(RE_SCRATCHPAD_ERROR);
	      if (match) {
	        let [, line, column ] = match;
	        inp.value = column ? line + ":" + column : line;
	        inp.selectionStart = inp.selectionEnd = inp.value.length;
	      }
	    }

	    this.openDialog(div, (line) => {
	      // Handle LINE:COLUMN as well as LINE
	      let match = line.toString().match(RE_JUMP_TO_LINE);
	      if (match) {
	        let [, matchLine, column ] = match;
	        this.setCursor({line: matchLine - 1, ch: column ? column - 1 : 0 });
	      }
	    });
	  },

	  /**
	   * Moves the content of the current line or the lines selected up a line.
	   */
	  moveLineUp: function () {
	    let cm = editors.get(this);
	    let start = cm.getCursor("start");
	    let end = cm.getCursor("end");

	    if (start.line === 0) {
	      return;
	    }

	    // Get the text in the lines selected or the current line of the cursor
	    // and append the text of the previous line.
	    let value;
	    if (start.line !== end.line) {
	      value = cm.getRange({ line: start.line, ch: 0 },
	        { line: end.line, ch: cm.getLine(end.line).length }) + "\n";
	    } else {
	      value = cm.getLine(start.line) + "\n";
	    }
	    value += cm.getLine(start.line - 1);

	    // Replace the previous line and the currently selected lines with the new
	    // value and maintain the selection of the text.
	    cm.replaceRange(value, { line: start.line - 1, ch: 0 },
	      { line: end.line, ch: cm.getLine(end.line).length });
	    cm.setSelection({ line: start.line - 1, ch: start.ch },
	      { line: end.line - 1, ch: end.ch });
	  },

	  /**
	   * Moves the content of the current line or the lines selected down a line.
	   */
	  moveLineDown: function () {
	    let cm = editors.get(this);
	    let start = cm.getCursor("start");
	    let end = cm.getCursor("end");

	    if (end.line + 1 === cm.lineCount()) {
	      return;
	    }

	    // Get the text of next line and append the text in the lines selected
	    // or the current line of the cursor.
	    let value = cm.getLine(end.line + 1) + "\n";
	    if (start.line !== end.line) {
	      value += cm.getRange({ line: start.line, ch: 0 },
	        { line: end.line, ch: cm.getLine(end.line).length });
	    } else {
	      value += cm.getLine(start.line);
	    }

	    // Replace the currently selected lines and the next line with the new
	    // value and maintain the selection of the text.
	    cm.replaceRange(value, { line: start.line, ch: 0 },
	      { line: end.line + 1, ch: cm.getLine(end.line + 1).length});
	    cm.setSelection({ line: start.line + 1, ch: start.ch },
	      { line: end.line + 1, ch: end.ch });
	  },

	  /**
	   * Returns current font size for the editor area, in pixels.
	   */
	  getFontSize: function () {
	    let cm = editors.get(this);
	    let el = cm.getWrapperElement();
	    let win = el.ownerDocument.defaultView;

	    return parseInt(win.getComputedStyle(el).getPropertyValue("font-size"), 10);
	  },

	  /**
	   * Sets font size for the editor area.
	   */
	  setFontSize: function (size) {
	    let cm = editors.get(this);
	    cm.getWrapperElement().style.fontSize = parseInt(size, 10) + "px";
	    cm.refresh();
	  },

	  /**
	   * Sets an option for the editor.  For most options it just defers to
	   * CodeMirror.setOption, but certain ones are maintained within the editor
	   * instance.
	   */
	  setOption: function (o, v) {
	    let cm = editors.get(this);

	    // Save the state of a valid autoCloseBrackets string, so we can reset
	    // it if it gets preffed off and back on.
	    if (o === "autoCloseBrackets" && v) {
	      this.config.autoCloseBracketsSaved = v;
	    }

	    if (o === "autocomplete") {
	      this.config.autocomplete = v;
	      this.setupAutoCompletion();
	    } else {
	      cm.setOption(o, v);
	      this.config[o] = v;
	    }

	    if (o === "enableCodeFolding") {
	      // The new value maybe explicitly force foldGUtter on or off, ignoring
	      // the prefs service.
	      this.updateCodeFoldingGutter();
	    }
	  },

	  /**
	   * Gets an option for the editor.  For most options it just defers to
	   * CodeMirror.getOption, but certain ones are maintained within the editor
	   * instance.
	   */
	  getOption: function (o) {
	    let cm = editors.get(this);
	    if (o === "autocomplete") {
	      return this.config.autocomplete;
	    }

	    return cm.getOption(o);
	  },

	  /**
	   * Sets up autocompletion for the editor. Lazily imports the required
	   * dependencies because they vary by editor mode.
	   *
	   * Autocompletion is special, because we don't want to automatically use
	   * it just because it is preffed on (it still needs to be requested by the
	   * editor), but we do want to always disable it if it is preffed off.
	   */
	  setupAutoCompletion: function () {
	    // The autocomplete module will overwrite this.initializeAutoCompletion
	    // with a mode specific autocompletion handler.
	    if (!this.initializeAutoCompletion) {
	      this.extend(__webpack_require__(172));
	    }

	    if (this.config.autocomplete && Services.prefs.getBoolPref(AUTOCOMPLETE)) {
	      this.initializeAutoCompletion(this.config.autocompleteOpts);
	    } else {
	      this.destroyAutoCompletion();
	    }
	  },

	  /**
	   * Extends an instance of the Editor object with additional
	   * functions. Each function will be called with context as
	   * the first argument. Context is a {ed, cm} object where
	   * 'ed' is an instance of the Editor object and 'cm' is an
	   * instance of the CodeMirror object. Example:
	   *
	   * function hello(ctx, name) {
	   *   let { cm, ed } = ctx;
	   *   cm;   // CodeMirror instance
	   *   ed;   // Editor instance
	   *   name; // 'Mozilla'
	   * }
	   *
	   * editor.extend({ hello: hello });
	   * editor.hello('Mozilla');
	   */
	  extend: function (funcs) {
	    Object.keys(funcs).forEach(name => {
	      let cm = editors.get(this);
	      let ctx = { ed: this, cm: cm, Editor: Editor};

	      if (name === "initialize") {
	        funcs[name](ctx);
	        return;
	      }

	      this[name] = funcs[name].bind(null, ctx);
	    });
	  },

	  destroy: function () {
	    this.container = null;
	    this.config = null;
	    this.version = null;

	    if (this._prefObserver) {
	      this._prefObserver.off(TAB_SIZE, this.reloadPreferences);
	      this._prefObserver.off(EXPAND_TAB, this.reloadPreferences);
	      this._prefObserver.off(KEYMAP, this.reloadPreferences);
	      this._prefObserver.off(AUTO_CLOSE, this.reloadPreferences);
	      this._prefObserver.off(AUTOCOMPLETE, this.reloadPreferences);
	      this._prefObserver.off(DETECT_INDENT, this.reloadPreferences);
	      this._prefObserver.off(ENABLE_CODE_FOLDING, this.reloadPreferences);
	      this._prefObserver.destroy();
	    }

	    this.emit("destroy");
	  },

	  updateCodeFoldingGutter: function () {
	    let shouldFoldGutter = this.config.enableCodeFolding;
	    let foldGutterIndex = this.config.gutters.indexOf("CodeMirror-foldgutter");
	    let cm = editors.get(this);

	    if (shouldFoldGutter === undefined) {
	      shouldFoldGutter = Services.prefs.getBoolPref(ENABLE_CODE_FOLDING);
	    }

	    if (shouldFoldGutter) {
	      // Add the gutter before enabling foldGutter
	      if (foldGutterIndex === -1) {
	        let gutters = this.config.gutters.slice();
	        gutters.push("CodeMirror-foldgutter");
	        this.setOption("gutters", gutters);
	      }

	      this.setOption("foldGutter", true);
	    } else {
	      // No code should remain folded when folding is off.
	      if (cm) {
	        cm.execCommand("unfoldAll");
	      }

	      // Remove the gutter so it doesn't take up space
	      if (foldGutterIndex !== -1) {
	        let gutters = this.config.gutters.slice();
	        gutters.splice(foldGutterIndex, 1);
	        this.setOption("gutters", gutters);
	      }

	      this.setOption("foldGutter", false);
	    }
	  }
	};

	// Since Editor is a thin layer over CodeMirror some methods
	// are mapped directly—without any changes.

	CM_MAPPING.forEach(name => {
	  Editor.prototype[name] = function (...args) {
	    let cm = editors.get(this);
	    return cm[name].apply(cm, args);
	  };
	});

	// Static methods on the Editor object itself.

	/**
	 * Returns a string representation of a shortcut 'key' with
	 * a OS specific modifier. Cmd- for Macs, Ctrl- for other
	 * platforms. Useful with extraKeys configuration option.
	 *
	 * CodeMirror defines all keys with modifiers in the following
	 * order: Shift - Ctrl/Cmd - Alt - Key
	 */
	Editor.accel = function (key, modifiers = {}) {
	  return (modifiers.shift ? "Shift-" : "") +
	         (Services.appinfo.OS == "Darwin" ? "Cmd-" : "Ctrl-") +
	         (modifiers.alt ? "Alt-" : "") + key;
	};

	/**
	 * Returns a string representation of a shortcut for a
	 * specified command 'cmd'. Append Cmd- for macs, Ctrl- for other
	 * platforms unless noaccel is specified in the options. Useful when overwriting
	 * or disabling default shortcuts.
	 */
	Editor.keyFor = function (cmd, opts = { noaccel: false }) {
	  let key = L10N.getStr(cmd + ".commandkey");
	  return opts.noaccel ? key : Editor.accel(key);
	};

	/**
	 * We compute the CSS property names, values, and color names to be used with
	 * CodeMirror to more closely reflect what is supported by the target platform.
	 * The database is used to replace the values used in CodeMirror while initiating
	 * an editor object. This is done here instead of the file codemirror/css.js so
	 * as to leave that file untouched and easily upgradable.
	 */
	function getCSSKeywords(cssProperties) {
	  function keySet(array) {
	    let keys = {};
	    for (let i = 0; i < array.length; ++i) {
	      keys[array[i]] = true;
	    }
	    return keys;
	  }

	  let propertyKeywords = cssProperties.getNames();
	  let colorKeywords = {};
	  let valueKeywords = {};

	  propertyKeywords.forEach(property => {
	    if (property.includes("color")) {
	      cssProperties.getValues(property).forEach(value => {
	        colorKeywords[value] = true;
	      });
	    } else {
	      cssProperties.getValues(property).forEach(value => {
	        valueKeywords[value] = true;
	      });
	    }
	  });

	  return {
	    propertyKeywords: keySet(propertyKeywords),
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords
	  };
	}

	/**
	 * Returns a controller object that can be used for
	 * editor-specific commands such as find, jump to line,
	 * copy/paste, etc.
	 */
	function controller(ed) {
	  return {
	    supportsCommand: function (cmd) {
	      switch (cmd) {
	        case "cmd_find":
	        case "cmd_findAgain":
	        case "cmd_findPrevious":
	        case "cmd_gotoLine":
	        case "cmd_undo":
	        case "cmd_redo":
	        case "cmd_delete":
	        case "cmd_selectAll":
	          return true;
	      }

	      return false;
	    },

	    isCommandEnabled: function (cmd) {
	      let cm = editors.get(ed);

	      switch (cmd) {
	        case "cmd_find":
	        case "cmd_gotoLine":
	        case "cmd_selectAll":
	          return true;
	        case "cmd_findAgain":
	          return cm.state.search != null && cm.state.search.query != null;
	        case "cmd_undo":
	          return ed.canUndo();
	        case "cmd_redo":
	          return ed.canRedo();
	        case "cmd_delete":
	          return ed.somethingSelected();
	      }

	      return false;
	    },

	    doCommand: function (cmd) {
	      let cm = editors.get(ed);
	      let map = {
	        "cmd_selectAll": "selectAll",
	        "cmd_find": "find",
	        "cmd_undo": "undo",
	        "cmd_redo": "redo",
	        "cmd_delete": "delCharAfter",
	        "cmd_findAgain": "findNext"
	      };

	      if (map[cmd]) {
	        cm.execCommand(map[cmd]);
	        return;
	      }

	      if (cmd == "cmd_gotoLine") {
	        ed.jumpToLine();
	      }
	    },

	    onEvent: function () {}
	  };
	}

	module.exports = Editor;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2; fill-column: 80 -*- */
	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);

	const EXPAND_TAB = "devtools.editor.expandtab";
	const TAB_SIZE = "devtools.editor.tabsize";
	const DETECT_INDENT = "devtools.editor.detectindentation";
	const DETECT_INDENT_MAX_LINES = 500;

	/**
	 * Get the indentation to use in an editor, or return false if the user has
	 * asked for the indentation to be guessed from some text.
	 *
	 * @return {false | Object}
	 *        Returns false if the "detect indentation" pref is set.
	 *        an object of the form {indentUnit, indentWithTabs}.
	 *        |indentUnit| is the number of indentation units to use
	 *        to indent a "block".
	 *        |indentWithTabs| is a boolean which is true if indentation
	 *        should be done using tabs.
	 */
	function getIndentationFromPrefs() {
	  let shouldDetect = Services.prefs.getBoolPref(DETECT_INDENT);
	  if (shouldDetect) {
	    return false;
	  }

	  let indentWithTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
	  let indentUnit = Services.prefs.getIntPref(TAB_SIZE);
	  return {indentUnit, indentWithTabs};
	}

	/**
	 * Given a function that can iterate over some text, compute the indentation to
	 * use.  This consults various prefs to arrive at a decision.
	 *
	 * @param {Function} iterFunc A function of three arguments:
	 *        (start, end, callback); where |start| and |end| describe
	 *        the range of text lines to examine, and |callback| is a function
	 *        to be called with the text of each line.
	 *
	 * @return {Object} an object of the form {indentUnit, indentWithTabs}.
	 *        |indentUnit| is the number of indentation units to use
	 *        to indent a "block".
	 *        |indentWithTabs| is a boolean which is true if indentation
	 *        should be done using tabs.
	 */
	function getIndentationFromIteration(iterFunc) {
	  let indentWithTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
	  let indentUnit = Services.prefs.getIntPref(TAB_SIZE);
	  let shouldDetect = Services.prefs.getBoolPref(DETECT_INDENT);

	  if (shouldDetect) {
	    let indent = detectIndentation(iterFunc);
	    if (indent != null) {
	      indentWithTabs = indent.tabs;
	      indentUnit = indent.spaces ? indent.spaces : indentUnit;
	    }
	  }

	  return {indentUnit, indentWithTabs};
	}

	/**
	 * A wrapper for @see getIndentationFromIteration which computes the
	 * indentation of a given string.
	 *
	 * @param {String} string the input text
	 * @return {Object} an object of the same form as returned by
	 *                  getIndentationFromIteration
	 */
	function getIndentationFromString(string) {
	  let iteratorFn = function (start, end, callback) {
	    let split = string.split(/\r\n|\r|\n|\f/);
	    split.slice(start, end).forEach(callback);
	  };
	  return getIndentationFromIteration(iteratorFn);
	}

	/**
	 * Detect the indentation used in an editor. Returns an object
	 * with 'tabs' - whether this is tab-indented and 'spaces' - the
	 * width of one indent in spaces. Or `null` if it's inconclusive.
	 */
	function detectIndentation(textIteratorFn) {
	  // # spaces indent -> # lines with that indent
	  let spaces = {};
	  // indentation width of the last line we saw
	  let last = 0;
	  // # of lines that start with a tab
	  let tabs = 0;
	  // # of indented lines (non-zero indent)
	  let total = 0;

	  textIteratorFn(0, DETECT_INDENT_MAX_LINES, (text) => {
	    if (text.startsWith("\t")) {
	      tabs++;
	      total++;
	      return;
	    }
	    let width = 0;
	    while (text[width] === " ") {
	      width++;
	    }
	    // don't count lines that are all spaces
	    if (width == text.length) {
	      last = 0;
	      return;
	    }
	    if (width > 1) {
	      total++;
	    }

	    // see how much this line is offset from the line above it
	    let indent = Math.abs(width - last);
	    if (indent > 1 && indent <= 8) {
	      spaces[indent] = (spaces[indent] || 0) + 1;
	    }
	    last = width;
	  });

	  // this file is not indented at all
	  if (total == 0) {
	    return null;
	  }

	  // mark as tabs if they start more than half the lines
	  if (tabs >= total / 2) {
	    return { tabs: true };
	  }

	  // find most frequent non-zero width difference between adjacent lines
	  let freqIndent = null, max = 1;
	  for (let width in spaces) {
	    width = parseInt(width, 10);
	    let tally = spaces[width];
	    if (tally > max) {
	      max = tally;
	      freqIndent = width;
	    }
	  }
	  if (!freqIndent) {
	    return null;
	  }

	  return { tabs: false, spaces: freqIndent };
	}

	exports.EXPAND_TAB = EXPAND_TAB;
	exports.TAB_SIZE = TAB_SIZE;
	exports.DETECT_INDENT = DETECT_INDENT;
	exports.getIndentationFromPrefs = getIndentationFromPrefs;
	exports.getIndentationFromIteration = getIndentationFromIteration;
	exports.getIndentationFromString = getIndentationFromString;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const CSSCompleter = __webpack_require__(173);
	const { AutocompletePopup } = __webpack_require__(159);
	const {KeyCodes} = __webpack_require__(16);

	const CM_TERN_SCRIPTS = [
	  "chrome://devtools/content/sourceeditor/codemirror/addon/tern/tern.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/hint/show-hint.js"
	];

	const autocompleteMap = new WeakMap();

	/**
	 * Prepares an editor instance for autocompletion.
	 */
	function initializeAutoCompletion(ctx, options = {}) {
	  let { cm, ed, Editor } = ctx;
	  if (autocompleteMap.has(ed)) {
	    return;
	  }

	  let win = ed.container.contentWindow.wrappedJSObject;
	  let { CodeMirror, document } = win;

	  let completer = null;
	  let autocompleteKey = "Ctrl-" +
	                        Editor.keyFor("autocompletion", { noaccel: true });
	  if (ed.config.mode == Editor.modes.js) {
	    let defs = [
	      __webpack_require__(174),
	      __webpack_require__(175),
	    ];

	    CM_TERN_SCRIPTS.forEach(ed.loadScript, ed);
	    win.tern = __webpack_require__(176);
	    cm.tern = new CodeMirror.TernServer({
	      defs: defs,
	      typeTip: function (data) {
	        let tip = document.createElement("span");
	        tip.className = "CodeMirror-Tern-information";
	        let tipType = document.createElement("strong");
	        let tipText = document.createTextNode(data.type ||
	          cm.l10n("autocompletion.notFound"));
	        tipType.appendChild(tipText);
	        tip.appendChild(tipType);

	        if (data.doc) {
	          tip.appendChild(document.createTextNode(" — " + data.doc));
	        }

	        if (data.url) {
	          tip.appendChild(document.createTextNode(" "));
	          let docLink = document.createElement("a");
	          docLink.textContent = "[" + cm.l10n("autocompletion.docsLink") + "]";
	          docLink.href = data.url;
	          docLink.className = "theme-link";
	          docLink.setAttribute("target", "_blank");
	          tip.appendChild(docLink);
	        }

	        return tip;
	      }
	    });

	    let keyMap = {};
	    let updateArgHintsCallback = cm.tern.updateArgHints.bind(cm.tern, cm);
	    cm.on("cursorActivity", updateArgHintsCallback);

	    keyMap[autocompleteKey] = cmArg => {
	      cmArg.tern.getHint(cmArg, data => {
	        CodeMirror.on(data, "shown", () => ed.emit("before-suggest"));
	        CodeMirror.on(data, "close", () => ed.emit("after-suggest"));
	        CodeMirror.on(data, "select", () => ed.emit("suggestion-entered"));
	        CodeMirror.showHint(cmArg, (cmIgnore, cb) => cb(data), { async: true });
	      });
	    };

	    keyMap[Editor.keyFor("showInformation2", { noaccel: true })] = cmArg => {
	      cmArg.tern.showType(cmArg, null, () => {
	        ed.emit("show-information");
	      });
	    };
	    cm.addKeyMap(keyMap);

	    let destroyTern = function () {
	      ed.off("destroy", destroyTern);
	      cm.off("cursorActivity", updateArgHintsCallback);
	      cm.removeKeyMap(keyMap);
	      win.tern = cm.tern = null;
	      autocompleteMap.delete(ed);
	    };

	    ed.on("destroy", destroyTern);

	    autocompleteMap.set(ed, {
	      destroy: destroyTern
	    });

	    // TODO: Integrate tern autocompletion with this autocomplete API.
	    return;
	  } else if (ed.config.mode == Editor.modes.css) {
	    completer = new CSSCompleter({walker: options.walker,
	                                  cssProperties: options.cssProperties});
	  }

	  function insertSelectedPopupItem() {
	    let autocompleteState = autocompleteMap.get(ed);
	    if (!popup || !popup.isOpen || !autocompleteState) {
	      return false;
	    }

	    if (!autocompleteState.suggestionInsertedOnce && popup.selectedItem) {
	      autocompleteMap.get(ed).insertingSuggestion = true;
	      insertPopupItem(ed, popup.selectedItem);
	    }

	    popup.once("popup-closed", () => {
	      // This event is used in tests.
	      ed.emit("popup-hidden");
	    });
	    popup.hidePopup();
	    return true;
	  }

	  // Give each popup a new name to avoid sharing the elements.

	  let popup = new AutocompletePopup({ doc: win.parent.document }, {
	    position: "bottom",
	    theme: "auto",
	    autoSelect: true,
	    onClick: insertSelectedPopupItem
	  });

	  let cycle = reverse => {
	    if (popup && popup.isOpen) {
	      cycleSuggestions(ed, reverse == true);
	      return null;
	    }

	    return CodeMirror.Pass;
	  };

	  let keyMap = {
	    "Tab": cycle,
	    "Down": cycle,
	    "Shift-Tab": cycle.bind(null, true),
	    "Up": cycle.bind(null, true),
	    "Enter": () => {
	      let wasHandled = insertSelectedPopupItem();
	      return wasHandled ? true : CodeMirror.Pass;
	    }
	  };

	  let autoCompleteCallback = autoComplete.bind(null, ctx);
	  let keypressCallback = onEditorKeypress.bind(null, ctx);
	  keyMap[autocompleteKey] = autoCompleteCallback;
	  cm.addKeyMap(keyMap);

	  cm.on("keydown", keypressCallback);
	  ed.on("change", autoCompleteCallback);
	  ed.on("destroy", destroy);

	  function destroy() {
	    ed.off("destroy", destroy);
	    cm.off("keydown", keypressCallback);
	    ed.off("change", autoCompleteCallback);
	    cm.removeKeyMap(keyMap);
	    popup.destroy();
	    keyMap = popup = completer = null;
	    autocompleteMap.delete(ed);
	  }

	  autocompleteMap.set(ed, {
	    popup: popup,
	    completer: completer,
	    keyMap: keyMap,
	    destroy: destroy,
	    insertingSuggestion: false,
	    suggestionInsertedOnce: false
	  });
	}

	/**
	 * Destroy autocompletion on an editor instance.
	 */
	function destroyAutoCompletion(ctx) {
	  let { ed } = ctx;
	  if (!autocompleteMap.has(ed)) {
	    return;
	  }

	  let {destroy} = autocompleteMap.get(ed);
	  destroy();
	}

	/**
	 * Provides suggestions to autocomplete the current token/word being typed.
	 */
	function autoComplete({ ed, cm }) {
	  let autocompleteOpts = autocompleteMap.get(ed);
	  let { completer, popup } = autocompleteOpts;
	  if (!completer || autocompleteOpts.insertingSuggestion ||
	      autocompleteOpts.doNotAutocomplete) {
	    autocompleteOpts.insertingSuggestion = false;
	    return;
	  }
	  let cur = ed.getCursor();
	  completer.complete(cm.getRange({line: 0, ch: 0}, cur), cur).then(suggestions => {
	    if (!suggestions || !suggestions.length || suggestions[0].preLabel == null) {
	      autocompleteOpts.suggestionInsertedOnce = false;
	      popup.once("popup-closed", () => {
	        // This event is used in tests.
	        ed.emit("after-suggest");
	      });
	      popup.hidePopup();
	      return;
	    }
	    // The cursor is at the end of the currently entered part of the token,
	    // like "backgr|" but we need to open the popup at the beginning of the
	    // character "b". Thus we need to calculate the width of the entered part
	    // of the token ("backgr" here). 4 comes from the popup's left padding.

	    let cursorElement = cm.display.cursorDiv.querySelector(".CodeMirror-cursor");
	    let left = suggestions[0].preLabel.length * cm.defaultCharWidth() + 4;
	    popup.hidePopup();
	    popup.setItems(suggestions);

	    popup.once("popup-opened", () => {
	      // This event is used in tests.
	      ed.emit("after-suggest");
	    });
	    popup.openPopup(cursorElement, -1 * left, 0);
	    autocompleteOpts.suggestionInsertedOnce = false;
	  }).then(null, e => console.error(e));
	}

	/**
	 * Inserts a popup item into the current cursor location
	 * in the editor.
	 */
	function insertPopupItem(ed, popupItem) {
	  let {preLabel, text} = popupItem;
	  let cur = ed.getCursor();
	  let textBeforeCursor = ed.getText(cur.line).substring(0, cur.ch);
	  let backwardsTextBeforeCursor = textBeforeCursor.split("").reverse().join("");
	  let backwardsPreLabel = preLabel.split("").reverse().join("");

	  // If there is additional text in the preLabel vs the line, then
	  // just insert the entire autocomplete text.  An example:
	  // if you type 'a' and select '#about' from the autocomplete menu,
	  // then the final text needs to the end up as '#about'.
	  if (backwardsPreLabel.indexOf(backwardsTextBeforeCursor) === 0) {
	    ed.replaceText(text, {line: cur.line, ch: 0}, cur);
	  } else {
	    ed.replaceText(text.slice(preLabel.length), cur, cur);
	  }
	}

	/**
	 * Cycles through provided suggestions by the popup in a top to bottom manner
	 * when `reverse` is not true. Opposite otherwise.
	 */
	function cycleSuggestions(ed, reverse) {
	  let autocompleteOpts = autocompleteMap.get(ed);
	  let { popup } = autocompleteOpts;
	  let cur = ed.getCursor();
	  autocompleteOpts.insertingSuggestion = true;
	  if (!autocompleteOpts.suggestionInsertedOnce) {
	    autocompleteOpts.suggestionInsertedOnce = true;
	    let firstItem;
	    if (reverse) {
	      firstItem = popup.getItemAtIndex(popup.itemCount - 1);
	      popup.selectPreviousItem();
	    } else {
	      firstItem = popup.getItemAtIndex(0);
	      if (firstItem.label == firstItem.preLabel && popup.itemCount > 1) {
	        firstItem = popup.getItemAtIndex(1);
	        popup.selectNextItem();
	      }
	    }
	    if (popup.itemCount == 1) {
	      popup.hidePopup();
	    }
	    insertPopupItem(ed, firstItem);
	  } else {
	    let fromCur = {
	      line: cur.line,
	      ch: cur.ch - popup.selectedItem.text.length
	    };
	    if (reverse) {
	      popup.selectPreviousItem();
	    } else {
	      popup.selectNextItem();
	    }
	    ed.replaceText(popup.selectedItem.text, fromCur, cur);
	  }
	  // This event is used in tests.
	  ed.emit("suggestion-entered");
	}

	/**
	 * onkeydown handler for the editor instance to prevent autocompleting on some
	 * keypresses.
	 */
	function onEditorKeypress({ ed, Editor }, cm, event) {
	  let autocompleteOpts = autocompleteMap.get(ed);

	  // Do not try to autocomplete with multiple selections.
	  if (ed.hasMultipleSelections()) {
	    autocompleteOpts.doNotAutocomplete = true;
	    autocompleteOpts.popup.hidePopup();
	    return;
	  }

	  if ((event.ctrlKey || event.metaKey) && event.keyCode == KeyCodes.DOM_VK_SPACE) {
	    // When Ctrl/Cmd + Space is pressed, two simultaneous keypresses are emitted
	    // first one for just the Ctrl/Cmd and second one for combo. The first one
	    // leave the autocompleteOpts.doNotAutocomplete as true, so we have to make
	    // it false
	    autocompleteOpts.doNotAutocomplete = false;
	    return;
	  }

	  if (event.ctrlKey || event.metaKey || event.altKey) {
	    autocompleteOpts.doNotAutocomplete = true;
	    autocompleteOpts.popup.hidePopup();
	    return;
	  }

	  switch (event.keyCode) {
	    case KeyCodes.DOM_VK_RETURN:
	      autocompleteOpts.doNotAutocomplete = true;
	      break;
	    case KeyCodes.DOM_VK_ESCAPE:
	      if (autocompleteOpts.popup.isOpen) {
	        event.preventDefault();
	      }
	      break;
	    case KeyCodes.DOM_VK_LEFT:
	    case KeyCodes.DOM_VK_RIGHT:
	    case KeyCodes.DOM_VK_HOME:
	    case KeyCodes.DOM_VK_END:
	      autocompleteOpts.doNotAutocomplete = true;
	      autocompleteOpts.popup.hidePopup();
	      break;
	    case KeyCodes.DOM_VK_BACK_SPACE:
	    case KeyCodes.DOM_VK_DELETE:
	      if (ed.config.mode == Editor.modes.css) {
	        autocompleteOpts.completer.invalidateCache(ed.getCursor().line);
	      }
	      autocompleteOpts.doNotAutocomplete = true;
	      autocompleteOpts.popup.hidePopup();
	      break;
	    default:
	      autocompleteOpts.doNotAutocomplete = false;
	  }
	}

	/**
	 * Returns the private popup. This method is used by tests to test the feature.
	 */
	function getPopup({ ed }) {
	  if (autocompleteMap.has(ed)) {
	    return autocompleteMap.get(ed).popup;
	  }

	  return null;
	}

	/**
	 * Returns contextual information about the token covered by the caret if the
	 * implementation of completer supports it.
	 */
	function getInfoAt({ ed }, caret) {
	  if (autocompleteMap.has(ed)) {
	    let completer = autocompleteMap.get(ed).completer;
	    if (completer && completer.getInfoAt) {
	      return completer.getInfoAt(ed.getText(), caret);
	    }
	  }

	  return null;
	}

	/**
	 * Returns whether autocompletion is enabled for this editor.
	 * Used for testing
	 */
	function isAutocompletionEnabled({ ed }) {
	  return autocompleteMap.has(ed);
	}

	// Export functions

	module.exports.initializeAutoCompletion = initializeAutoCompletion;
	module.exports.destroyAutoCompletion = destroyAutoCompletion;
	module.exports.getAutocompletionPopup = getPopup;
	module.exports.getInfoAt = getInfoAt;
	module.exports.isAutocompletionEnabled = isAutocompletionEnabled;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* eslint-disable complexity */
	const {cssTokenizer, cssTokenizerWithLineColumn} = __webpack_require__(132);
	const {getClientCssProperties} = __webpack_require__(18);

	/**
	 * Here is what this file (+ css-parsing-utils.js) do.
	 *
	 * The main objective here is to provide as much suggestions to the user editing
	 * a stylesheet in Style Editor. The possible things that can be suggested are:
	 *  - CSS property names
	 *  - CSS property values
	 *  - CSS Selectors
	 *  - Some other known CSS keywords
	 *
	 * Gecko provides a list of both property names and their corresponding values.
	 * We take out a list of matching selectors using the Inspector actor's
	 * `getSuggestionsForQuery` method. Now the only thing is to parse the CSS being
	 * edited by the user, figure out what token or word is being written and last
	 * but the most difficult, what is being edited.
	 *
	 * The file 'css-parsing-utils' helps to convert the CSS into meaningful tokens,
	 * each having a certain type associated with it. These tokens help us to figure
	 * out the currently edited word and to write a CSS state machine to figure out
	 * what the user is currently editing. By that, I mean, whether he is editing a
	 * selector or a property or a value, or even fine grained information like an
	 * id in the selector.
	 *
	 * The `resolveState` method iterated over the tokens spitted out by the
	 * tokenizer, using switch cases, follows a state machine logic and finally
	 * figures out these informations:
	 *  - The state of the CSS at the cursor (one out of CSS_STATES)
	 *  - The current token that is being edited `cmpleting`
	 *  - If the state is "selector", the selector state (one of SELECTOR_STATES)
	 *  - If the state is "selector", the current selector till the cursor
	 *  - If the state is "value", the corresponding property name
	 *
	 * In case of "value" and "property" states, we simply use the information
	 * provided by Gecko to filter out the possible suggestions.
	 * For "selector" state, we request the Inspector actor to query the page DOM
	 * and filter out the possible suggestions.
	 * For "media" and "keyframes" state, the only possible suggestions for now are
	 * "media" and "keyframes" respectively, although "media" can have suggestions
	 * like "max-width", "orientation" etc. Similarly "value" state can also have
	 * much better logical suggestions if we fine grain identify a sub state just
	 * like we do for the "selector" state.
	 */

	// Autocompletion types.

	/* eslint-disable no-inline-comments */
	const CSS_STATES = {
	  "null": "null",
	  property: "property",    // foo { bar|: … }
	  value: "value",          // foo {bar: baz|}
	  selector: "selector",    // f| {bar: baz}
	  media: "media",          // @med| , or , @media scr| { }
	  keyframes: "keyframes",  // @keyf|
	  frame: "frame",          // @keyframs foobar { t|
	};

	const SELECTOR_STATES = {
	  "null": "null",
	  id: "id",                // #f|
	  class: "class",          // #foo.b|
	  tag: "tag",              // fo|
	  pseudo: "pseudo",        // foo:|
	  attribute: "attribute",  // foo[b|
	  value: "value",          // foo[bar=b|
	};
	/* eslint-enable no-inline-comments */

	/**
	 * Constructor for the autocompletion object.
	 *
	 * @param options {Object} An options object containing the following options:
	 *        - walker {Object} The object used for query selecting from the current
	 *                 target's DOM.
	 *        - maxEntries {Number} Maximum selectors suggestions to display.
	 *        - cssProperties {Object} The database of CSS properties.
	 */
	function CSSCompleter(options = {}) {
	  this.walker = options.walker;
	  this.maxEntries = options.maxEntries || 15;
	  // If no css properties database is passed in, default to the client list.
	  this.cssProperties = options.cssProperties || getClientCssProperties();

	  this.propertyNames = this.cssProperties.getNames().sort();

	  // Array containing the [line, ch, scopeStack] for the locations where the
	  // CSS state is "null"
	  this.nullStates = [];
	}

	CSSCompleter.prototype = {

	  /**
	   * Returns a list of suggestions based on the caret position.
	   *
	   * @param source {String} String of the source code.
	   * @param caret {Object} Cursor location with line and ch properties.
	   *
	   * @returns [{object}] A sorted list of objects containing the following
	   *          peroperties:
	   *          - label {String} Full keyword for the suggestion
	   *          - preLabel {String} Already entered part of the label
	   */
	  complete: function (source, caret) {
	    // Getting the context from the caret position.
	    if (!this.resolveState(source, caret)) {
	      // We couldn't resolve the context, we won't be able to complete.
	      return Promise.resolve([]);
	    }

	    // Properly suggest based on the state.
	    switch (this.state) {
	      case CSS_STATES.property:
	        return this.completeProperties(this.completing);

	      case CSS_STATES.value:
	        return this.completeValues(this.propertyName, this.completing);

	      case CSS_STATES.selector:
	        return this.suggestSelectors();

	      case CSS_STATES.media:
	      case CSS_STATES.keyframes:
	        if ("media".startsWith(this.completing)) {
	          return Promise.resolve([{
	            label: "media",
	            preLabel: this.completing,
	            text: "media"
	          }]);
	        } else if ("keyframes".startsWith(this.completing)) {
	          return Promise.resolve([{
	            label: "keyframes",
	            preLabel: this.completing,
	            text: "keyframes"
	          }]);
	        }
	    }
	    return Promise.resolve([]);
	  },

	  /**
	   * Resolves the state of CSS at the cursor location. This method implements a
	   * custom written CSS state machine. The various switch statements provide the
	   * transition rules for the state. It also finds out various informatino about
	   * the nearby CSS like the property name being completed, the complete
	   * selector, etc.
	   *
	   * @param source {String} String of the source code.
	   * @param caret {Object} Cursor location with line and ch properties.
	   *
	   * @returns CSS_STATE
	   *          One of CSS_STATE enum or null if the state cannot be resolved.
	   */
	  resolveState: function (source, {line, ch}) {
	    // Function to return the last element of an array
	    let peek = arr => arr[arr.length - 1];
	    // _state can be one of CSS_STATES;
	    let _state = CSS_STATES.null;
	    let selector = "";
	    let selectorState = SELECTOR_STATES.null;
	    let propertyName = null;
	    let scopeStack = [];
	    let selectors = [];

	    // Fetch the closest null state line, ch from cached null state locations
	    let matchedStateIndex = this.findNearestNullState(line);
	    if (matchedStateIndex > -1) {
	      let state = this.nullStates[matchedStateIndex];
	      line -= state[0];
	      if (line == 0) {
	        ch -= state[1];
	      }
	      source = source.split("\n").slice(state[0]);
	      source[0] = source[0].slice(state[1]);
	      source = source.join("\n");
	      scopeStack = [...state[2]];
	      this.nullStates.length = matchedStateIndex + 1;
	    } else {
	      this.nullStates = [];
	    }
	    let tokens = cssTokenizerWithLineColumn(source);
	    let tokIndex = tokens.length - 1;
	    if (tokIndex >= 0 &&
	        (tokens[tokIndex].loc.end.line < line ||
	         (tokens[tokIndex].loc.end.line === line &&
	          tokens[tokIndex].loc.end.column < ch))) {
	      // If the last token ends before the cursor location, we didn't
	      // tokenize it correctly.  This special case can happen if the
	      // final token is a comment.
	      return null;
	    }

	    let cursor = 0;
	    // This will maintain a stack of paired elements like { & }, @m & }, : & ;
	    // etc
	    let token = null;
	    let selectorBeforeNot = null;
	    while (cursor <= tokIndex && (token = tokens[cursor++])) {
	      switch (_state) {
	        case CSS_STATES.property:
	          // From CSS_STATES.property, we can either go to CSS_STATES.value
	          // state when we hit the first ':' or CSS_STATES.selector if "}" is
	          // reached.
	          if (token.tokenType === "symbol") {
	            switch (token.text) {
	              case ":":
	                scopeStack.push(":");
	                if (tokens[cursor - 2].tokenType != "whitespace") {
	                  propertyName = tokens[cursor - 2].text;
	                } else {
	                  propertyName = tokens[cursor - 3].text;
	                }
	                _state = CSS_STATES.value;
	                break;

	              case "}":
	                if (/[{f]/.test(peek(scopeStack))) {
	                  let popped = scopeStack.pop();
	                  if (popped == "f") {
	                    _state = CSS_STATES.frame;
	                  } else {
	                    selector = "";
	                    selectors = [];
	                    _state = CSS_STATES.null;
	                  }
	                }
	                break;
	            }
	          }
	          break;

	        case CSS_STATES.value:
	          // From CSS_STATES.value, we can go to one of CSS_STATES.property,
	          // CSS_STATES.frame, CSS_STATES.selector and CSS_STATES.null
	          if (token.tokenType === "symbol") {
	            switch (token.text) {
	              case ";":
	                if (/[:]/.test(peek(scopeStack))) {
	                  scopeStack.pop();
	                  _state = CSS_STATES.property;
	                }
	                break;

	              case "}":
	                if (peek(scopeStack) == ":") {
	                  scopeStack.pop();
	                }

	                if (/[{f]/.test(peek(scopeStack))) {
	                  let popped = scopeStack.pop();
	                  if (popped == "f") {
	                    _state = CSS_STATES.frame;
	                  } else {
	                    selector = "";
	                    selectors = [];
	                    _state = CSS_STATES.null;
	                  }
	                }
	                break;
	            }
	          }
	          break;

	        case CSS_STATES.selector:
	          // From CSS_STATES.selector, we can only go to CSS_STATES.property
	          // when we hit "{"
	          if (token.tokenType === "symbol" && token.text == "{") {
	            scopeStack.push("{");
	            _state = CSS_STATES.property;
	            selectors.push(selector);
	            selector = "";
	            break;
	          }

	          switch (selectorState) {
	            case SELECTOR_STATES.id:
	            case SELECTOR_STATES.class:
	            case SELECTOR_STATES.tag:
	              switch (token.tokenType) {
	                case "hash":
	                case "id":
	                  selectorState = SELECTOR_STATES.id;
	                  selector += "#" + token.text;
	                  break;

	                case "symbol":
	                  if (token.text == ".") {
	                    selectorState = SELECTOR_STATES.class;
	                    selector += ".";
	                    if (cursor <= tokIndex &&
	                        tokens[cursor].tokenType == "ident") {
	                      token = tokens[cursor++];
	                      selector += token.text;
	                    }
	                  } else if (token.text == "#") {
	                    selectorState = SELECTOR_STATES.id;
	                    selector += "#";
	                  } else if (/[>~+]/.test(token.text)) {
	                    selectorState = SELECTOR_STATES.null;
	                    selector += token.text;
	                  } else if (token.text == ",") {
	                    selectorState = SELECTOR_STATES.null;
	                    selectors.push(selector);
	                    selector = "";
	                  } else if (token.text == ":") {
	                    selectorState = SELECTOR_STATES.pseudo;
	                    selector += ":";
	                    if (cursor > tokIndex) {
	                      break;
	                    }

	                    token = tokens[cursor++];
	                    switch (token.tokenType) {
	                      case "function":
	                        if (token.text == "not") {
	                          selectorBeforeNot = selector;
	                          selector = "";
	                          scopeStack.push("(");
	                        } else {
	                          selector += token.text + "(";
	                        }
	                        selectorState = SELECTOR_STATES.null;
	                        break;

	                      case "ident":
	                        selector += token.text;
	                        break;
	                    }
	                  } else if (token.text == "[") {
	                    selectorState = SELECTOR_STATES.attribute;
	                    scopeStack.push("[");
	                    selector += "[";
	                  } else if (token.text == ")") {
	                    if (peek(scopeStack) == "(") {
	                      scopeStack.pop();
	                      selector = selectorBeforeNot + "not(" + selector + ")";
	                      selectorBeforeNot = null;
	                    } else {
	                      selector += ")";
	                    }
	                    selectorState = SELECTOR_STATES.null;
	                  }
	                  break;

	                case "whitespace":
	                  selectorState = SELECTOR_STATES.null;
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.null:
	              // From SELECTOR_STATES.null state, we can go to one of
	              // SELECTOR_STATES.id, SELECTOR_STATES.class or
	              // SELECTOR_STATES.tag
	              switch (token.tokenType) {
	                case "hash":
	                case "id":
	                  selectorState = SELECTOR_STATES.id;
	                  selector += "#" + token.text;
	                  break;

	                case "ident":
	                  selectorState = SELECTOR_STATES.tag;
	                  selector += token.text;
	                  break;

	                case "symbol":
	                  if (token.text == ".") {
	                    selectorState = SELECTOR_STATES.class;
	                    selector += ".";
	                    if (cursor <= tokIndex &&
	                        tokens[cursor].tokenType == "ident") {
	                      token = tokens[cursor++];
	                      selector += token.text;
	                    }
	                  } else if (token.text == "#") {
	                    selectorState = SELECTOR_STATES.id;
	                    selector += "#";
	                  } else if (token.text == "*") {
	                    selectorState = SELECTOR_STATES.tag;
	                    selector += "*";
	                  } else if (/[>~+]/.test(token.text)) {
	                    selector += token.text;
	                  } else if (token.text == ",") {
	                    selectorState = SELECTOR_STATES.null;
	                    selectors.push(selector);
	                    selector = "";
	                  } else if (token.text == ":") {
	                    selectorState = SELECTOR_STATES.pseudo;
	                    selector += ":";
	                    if (cursor > tokIndex) {
	                      break;
	                    }

	                    token = tokens[cursor++];
	                    switch (token.tokenType) {
	                      case "function":
	                        if (token.text == "not") {
	                          selectorBeforeNot = selector;
	                          selector = "";
	                          scopeStack.push("(");
	                        } else {
	                          selector += token.text + "(";
	                        }
	                        selectorState = SELECTOR_STATES.null;
	                        break;

	                      case "ident":
	                        selector += token.text;
	                        break;
	                    }
	                  } else if (token.text == "[") {
	                    selectorState = SELECTOR_STATES.attribute;
	                    scopeStack.push("[");
	                    selector += "[";
	                  } else if (token.text == ")") {
	                    if (peek(scopeStack) == "(") {
	                      scopeStack.pop();
	                      selector = selectorBeforeNot + "not(" + selector + ")";
	                      selectorBeforeNot = null;
	                    } else {
	                      selector += ")";
	                    }
	                    selectorState = SELECTOR_STATES.null;
	                  }
	                  break;

	                case "whitespace":
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.pseudo:
	              switch (token.tokenType) {
	                case "symbol":
	                  if (/[>~+]/.test(token.text)) {
	                    selectorState = SELECTOR_STATES.null;
	                    selector += token.text;
	                  } else if (token.text == ",") {
	                    selectorState = SELECTOR_STATES.null;
	                    selectors.push(selector);
	                    selector = "";
	                  } else if (token.text == ":") {
	                    selectorState = SELECTOR_STATES.pseudo;
	                    selector += ":";
	                    if (cursor > tokIndex) {
	                      break;
	                    }

	                    token = tokens[cursor++];
	                    switch (token.tokenType) {
	                      case "function":
	                        if (token.text == "not") {
	                          selectorBeforeNot = selector;
	                          selector = "";
	                          scopeStack.push("(");
	                        } else {
	                          selector += token.text + "(";
	                        }
	                        selectorState = SELECTOR_STATES.null;
	                        break;

	                      case "ident":
	                        selector += token.text;
	                        break;
	                    }
	                  } else if (token.text == "[") {
	                    selectorState = SELECTOR_STATES.attribute;
	                    scopeStack.push("[");
	                    selector += "[";
	                  }
	                  break;

	                case "whitespace":
	                  selectorState = SELECTOR_STATES.null;
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.attribute:
	              switch (token.tokenType) {
	                case "symbol":
	                  if (/[~|^$*]/.test(token.text)) {
	                    selector += token.text;
	                    token = tokens[cursor++];
	                  } else if (token.text == "=") {
	                    selectorState = SELECTOR_STATES.value;
	                    selector += token.text;
	                  } else if (token.text == "]") {
	                    if (peek(scopeStack) == "[") {
	                      scopeStack.pop();
	                    }

	                    selectorState = SELECTOR_STATES.null;
	                    selector += "]";
	                  }
	                  break;

	                case "ident":
	                case "string":
	                  selector += token.text;
	                  break;

	                case "whitespace":
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.value:
	              switch (token.tokenType) {
	                case "string":
	                case "ident":
	                  selector += token.text;
	                  break;

	                case "symbol":
	                  if (token.text == "]") {
	                    if (peek(scopeStack) == "[") {
	                      scopeStack.pop();
	                    }

	                    selectorState = SELECTOR_STATES.null;
	                    selector += "]";
	                  }
	                  break;

	                case "whitespace":
	                  selector && (selector += " ");
	                  break;
	              }
	              break;
	          }
	          break;

	        case CSS_STATES.null:
	          // From CSS_STATES.null state, we can go to either CSS_STATES.media or
	          // CSS_STATES.selector.
	          switch (token.tokenType) {
	            case "hash":
	            case "id":
	              selectorState = SELECTOR_STATES.id;
	              selector = "#" + token.text;
	              _state = CSS_STATES.selector;
	              break;

	            case "ident":
	              selectorState = SELECTOR_STATES.tag;
	              selector = token.text;
	              _state = CSS_STATES.selector;
	              break;

	            case "symbol":
	              if (token.text == ".") {
	                selectorState = SELECTOR_STATES.class;
	                selector = ".";
	                _state = CSS_STATES.selector;
	                if (cursor <= tokIndex &&
	                    tokens[cursor].tokenType == "ident") {
	                  token = tokens[cursor++];
	                  selector += token.text;
	                }
	              } else if (token.text == "#") {
	                selectorState = SELECTOR_STATES.id;
	                selector = "#";
	                _state = CSS_STATES.selector;
	              } else if (token.text == "*") {
	                selectorState = SELECTOR_STATES.tag;
	                selector = "*";
	                _state = CSS_STATES.selector;
	              } else if (token.text == ":") {
	                _state = CSS_STATES.selector;
	                selectorState = SELECTOR_STATES.pseudo;
	                selector += ":";
	                if (cursor > tokIndex) {
	                  break;
	                }

	                token = tokens[cursor++];
	                switch (token.tokenType) {
	                  case "function":
	                    if (token.text == "not") {
	                      selectorBeforeNot = selector;
	                      selector = "";
	                      scopeStack.push("(");
	                    } else {
	                      selector += token.text + "(";
	                    }
	                    selectorState = SELECTOR_STATES.null;
	                    break;

	                  case "ident":
	                    selector += token.text;
	                    break;
	                }
	              } else if (token.text == "[") {
	                _state = CSS_STATES.selector;
	                selectorState = SELECTOR_STATES.attribute;
	                scopeStack.push("[");
	                selector += "[";
	              } else if (token.text == "}") {
	                if (peek(scopeStack) == "@m") {
	                  scopeStack.pop();
	                }
	              }
	              break;

	            case "at":
	              _state = token.text.startsWith("m") ? CSS_STATES.media
	                                                   : CSS_STATES.keyframes;
	              break;
	          }
	          break;

	        case CSS_STATES.media:
	          // From CSS_STATES.media, we can only go to CSS_STATES.null state when
	          // we hit the first '{'
	          if (token.tokenType == "symbol" && token.text == "{") {
	            scopeStack.push("@m");
	            _state = CSS_STATES.null;
	          }
	          break;

	        case CSS_STATES.keyframes:
	          // From CSS_STATES.keyframes, we can only go to CSS_STATES.frame state
	          // when we hit the first '{'
	          if (token.tokenType == "symbol" && token.text == "{") {
	            scopeStack.push("@k");
	            _state = CSS_STATES.frame;
	          }
	          break;

	        case CSS_STATES.frame:
	          // From CSS_STATES.frame, we can either go to CSS_STATES.property
	          // state when we hit the first '{' or to CSS_STATES.selector when we
	          // hit '}'
	          if (token.tokenType == "symbol") {
	            if (token.text == "{") {
	              scopeStack.push("f");
	              _state = CSS_STATES.property;
	            } else if (token.text == "}") {
	              if (peek(scopeStack) == "@k") {
	                scopeStack.pop();
	              }

	              _state = CSS_STATES.null;
	            }
	          }
	          break;
	      }
	      if (_state == CSS_STATES.null) {
	        if (this.nullStates.length == 0) {
	          this.nullStates.push([token.loc.end.line, token.loc.end.column,
	                                [...scopeStack]]);
	          continue;
	        }
	        let tokenLine = token.loc.end.line;
	        let tokenCh = token.loc.end.column;
	        if (tokenLine == 0) {
	          continue;
	        }
	        if (matchedStateIndex > -1) {
	          tokenLine += this.nullStates[matchedStateIndex][0];
	        }
	        this.nullStates.push([tokenLine, tokenCh, [...scopeStack]]);
	      }
	    }
	    this.state = _state;
	    this.propertyName = _state == CSS_STATES.value ? propertyName : null;
	    this.selectorState = _state == CSS_STATES.selector ? selectorState : null;
	    this.selectorBeforeNot = selectorBeforeNot == null ?
	                             null : selectorBeforeNot;
	    if (token) {
	      selector = selector.slice(0, selector.length + token.loc.end.column - ch);
	      this.selector = selector;
	    } else {
	      this.selector = "";
	    }
	    this.selectors = selectors;

	    if (token && token.tokenType != "whitespace") {
	      let text;
	      if (token.tokenType == "dimension" || !token.text) {
	        text = source.substring(token.startOffset, token.endOffset);
	      } else {
	        text = token.text;
	      }
	      this.completing = (text.slice(0, ch - token.loc.start.column)
	                         .replace(/^[.#]$/, ""));
	    } else {
	      this.completing = "";
	    }
	    // Special case the situation when the user just entered ":" after typing a
	    // property name.
	    if (this.completing == ":" && _state == CSS_STATES.value) {
	      this.completing = "";
	    }

	    // Special check for !important; case.
	    if (token && tokens[cursor - 2] && tokens[cursor - 2].text == "!" &&
	        this.completing == "important".slice(0, this.completing.length)) {
	      this.completing = "!" + this.completing;
	    }
	    return _state;
	  },

	  /**
	   * Queries the DOM Walker actor for suggestions regarding the selector being
	   * completed
	   */
	  suggestSelectors: function () {
	    let walker = this.walker;
	    if (!walker) {
	      return Promise.resolve([]);
	    }

	    let query = this.selector;
	    // Even though the selector matched atleast one node, there is still
	    // possibility of suggestions.
	    switch (this.selectorState) {
	      case SELECTOR_STATES.null:
	        if (this.completing === ",") {
	          return Promise.resolve([]);
	        }

	        query += "*";
	        break;

	      case SELECTOR_STATES.tag:
	        query = query.slice(0, query.length - this.completing.length);
	        break;

	      case SELECTOR_STATES.id:
	      case SELECTOR_STATES.class:
	      case SELECTOR_STATES.pseudo:
	        if (/^[.:#]$/.test(this.completing)) {
	          query = query.slice(0, query.length - this.completing.length);
	          this.completing = "";
	        } else {
	          query = query.slice(0, query.length - this.completing.length - 1);
	        }
	        break;
	    }

	    if (/[\s+>~]$/.test(query) &&
	        this.selectorState != SELECTOR_STATES.attribute &&
	        this.selectorState != SELECTOR_STATES.value) {
	      query += "*";
	    }

	    // Set the values that this request was supposed to suggest to.
	    this._currentQuery = query;
	    return walker.getSuggestionsForQuery(query, this.completing,
	                                         this.selectorState)
	                 .then(result => this.prepareSelectorResults(result));
	  },

	 /**
	  * Prepares the selector suggestions returned by the walker actor.
	  */
	  prepareSelectorResults: function (result) {
	    if (this._currentQuery != result.query) {
	      return [];
	    }

	    result = result.suggestions;
	    let query = this.selector;
	    let completion = [];
	    for (let [value, count, state] of result) {
	      switch (this.selectorState) {
	        case SELECTOR_STATES.id:
	        case SELECTOR_STATES.class:
	        case SELECTOR_STATES.pseudo:
	          if (/^[.:#]$/.test(this.completing)) {
	            value = query.slice(0, query.length - this.completing.length) +
	                       value;
	          } else {
	            value = query.slice(0, query.length - this.completing.length - 1) +
	                       value;
	          }
	          break;

	        case SELECTOR_STATES.tag:
	          value = query.slice(0, query.length - this.completing.length) +
	                    value;
	          break;

	        case SELECTOR_STATES.null:
	          value = query + value;
	          break;

	        default:
	          value = query.slice(0, query.length - this.completing.length) +
	                    value;
	      }

	      let item = {
	        label: value,
	        preLabel: query,
	        text: value,
	        score: count
	      };

	      // In case the query's state is tag and the item's state is id or class
	      // adjust the preLabel
	      if (this.selectorState === SELECTOR_STATES.tag &&
	          state === SELECTOR_STATES.class) {
	        item.preLabel = "." + item.preLabel;
	      }
	      if (this.selectorState === SELECTOR_STATES.tag &&
	          state === SELECTOR_STATES.id) {
	        item.preLabel = "#" + item.preLabel;
	      }

	      completion.push(item);

	      if (completion.length > this.maxEntries - 1) {
	        break;
	      }
	    }
	    return completion;
	  },

	  /**
	   * Returns CSS property name suggestions based on the input.
	   *
	   * @param startProp {String} Initial part of the property being completed.
	   */
	  completeProperties: function (startProp) {
	    let finalList = [];
	    if (!startProp) {
	      return Promise.resolve(finalList);
	    }

	    let length = this.propertyNames.length;
	    let i = 0, count = 0;
	    for (; i < length && count < this.maxEntries; i++) {
	      if (this.propertyNames[i].startsWith(startProp)) {
	        count++;
	        let propName = this.propertyNames[i];
	        finalList.push({
	          preLabel: startProp,
	          label: propName,
	          text: propName + ": "
	        });
	      } else if (this.propertyNames[i] > startProp) {
	        // We have crossed all possible matches alphabetically.
	        break;
	      }
	    }
	    return Promise.resolve(finalList);
	  },

	  /**
	   * Returns CSS value suggestions based on the corresponding property.
	   *
	   * @param propName {String} The property to which the value being completed
	   *        belongs.
	   * @param startValue {String} Initial part of the value being completed.
	   */
	  completeValues: function (propName, startValue) {
	    let finalList = [];
	    let list = ["!important;", ...this.cssProperties.getValues(propName)];
	    // If there is no character being completed, we are showing an initial list
	    // of possible values. Skipping '!important' in this case.
	    if (!startValue) {
	      list.splice(0, 1);
	    }

	    let length = list.length;
	    let i = 0, count = 0;
	    for (; i < length && count < this.maxEntries; i++) {
	      if (list[i].startsWith(startValue)) {
	        count++;
	        let value = list[i];
	        finalList.push({
	          preLabel: startValue,
	          label: value,
	          text: value
	        });
	      } else if (list[i] > startValue) {
	        // We have crossed all possible matches alphabetically.
	        break;
	      }
	    }
	    return Promise.resolve(finalList);
	  },

	  /**
	   * A biased binary search in a sorted array where the middle element is
	   * calculated based on the values at the lower and the upper index in each
	   * iteration.
	   *
	   * This method returns the index of the closest null state from the passed
	   * `line` argument. Once we have the closest null state, we can start applying
	   * the state machine logic from that location instead of the absolute starting
	   * of the CSS source. This speeds up the tokenizing and the state machine a
	   * lot while using autocompletion at high line numbers in a CSS source.
	   */
	  findNearestNullState: function (line) {
	    let arr = this.nullStates;
	    let high = arr.length - 1;
	    let low = 0;
	    let target = 0;

	    if (high < 0) {
	      return -1;
	    }
	    if (arr[high][0] <= line) {
	      return high;
	    }
	    if (arr[low][0] > line) {
	      return -1;
	    }

	    while (high > low) {
	      if (arr[low][0] <= line && arr[low [0] + 1] > line) {
	        return low;
	      }
	      if (arr[high][0] > line && arr[high - 1][0] <= line) {
	        return high - 1;
	      }

	      target = (((line - arr[low][0]) / (arr[high][0] - arr[low][0])) *
	                (high - low)) | 0;

	      if (arr[target][0] <= line && arr[target + 1][0] > line) {
	        return target;
	      } else if (line > arr[target][0]) {
	        low = target + 1;
	        high--;
	      } else {
	        high = target - 1;
	        low++;
	      }
	    }

	    return -1;
	  },

	  /**
	   * Invalidates the state cache for and above the line.
	   */
	  invalidateCache: function (line) {
	    this.nullStates.length = this.findNearestNullState(line) + 1;
	  },

	  /**
	   * Get the state information about a token surrounding the {line, ch} position
	   *
	   * @param {string} source
	   *        The complete source of the CSS file. Unlike resolve state method,
	   *        this method requires the full source.
	   * @param {object} caret
	   *        The line, ch position of the caret.
	   *
	   * @returns {object}
	   *          An object containing the state of token covered by the caret.
	   *          The object has following properties when the the state is
	   *          "selector", "value" or "property", null otherwise:
	   *           - state {string} one of CSS_STATES - "selector", "value" etc.
	   *           - selector {string} The selector at the caret when `state` is
	   *                      selector. OR
	   *           - selectors {[string]} Array of selector strings in case when
	   *                       `state` is "value" or "property"
	   *           - propertyName {string} The property name at the current caret or
	   *                          the property name corresponding to the value at
	   *                          the caret.
	   *           - value {string} The css value at the current caret.
	   *           - loc {object} An object containing the starting and the ending
	   *                 caret position of the whole selector, value or property.
	   *                  - { start: {line, ch}, end: {line, ch}}
	   */
	  getInfoAt: function (source, caret) {
	    // Limits the input source till the {line, ch} caret position
	    function limit(sourceArg, {line, ch}) {
	      line++;
	      let list = sourceArg.split("\n");
	      if (list.length < line) {
	        return sourceArg;
	      }
	      if (line == 1) {
	        return list[0].slice(0, ch);
	      }
	      return [...list.slice(0, line - 1),
	              list[line - 1].slice(0, ch)].join("\n");
	    }

	    // Get the state at the given line, ch
	    let state = this.resolveState(limit(source, caret), caret);
	    let propertyName = this.propertyName;
	    let {line, ch} = caret;
	    let sourceArray = source.split("\n");
	    let limitedSource = limit(source, caret);

	    /**
	     * Method to traverse forwards from the caret location to figure out the
	     * ending point of a selector or css value.
	     *
	     * @param {function} check
	     *        A method which takes the current state as an input and determines
	     *        whether the state changed or not.
	     */
	    let traverseForward = check => {
	      let location;
	      // Backward loop to determine the beginning location of the selector.
	      do {
	        let lineText = sourceArray[line];
	        if (line == caret.line) {
	          lineText = lineText.substring(caret.ch);
	        }

	        let prevToken = undefined;
	        let tokens = cssTokenizer(lineText);
	        let found = false;
	        let ech = line == caret.line ? caret.ch : 0;
	        for (let token of tokens) {
	          // If the line is completely spaces, handle it differently
	          if (lineText.trim() == "") {
	            limitedSource += lineText;
	          } else {
	            limitedSource += sourceArray[line]
	                              .substring(ech + token.startOffset,
	                                         ech + token.endOffset);
	          }

	          // Whitespace cannot change state.
	          if (token.tokenType == "whitespace") {
	            prevToken = token;
	            continue;
	          }

	          let forwState = this.resolveState(limitedSource, {
	            line: line,
	            ch: token.endOffset + ech
	          });
	          if (check(forwState)) {
	            if (prevToken && prevToken.tokenType == "whitespace") {
	              token = prevToken;
	            }
	            location = {
	              line: line,
	              ch: token.startOffset + ech
	            };
	            found = true;
	            break;
	          }
	          prevToken = token;
	        }
	        limitedSource += "\n";
	        if (found) {
	          break;
	        }
	      } while (line++ < sourceArray.length);
	      return location;
	    };

	    /**
	     * Method to traverse backwards from the caret location to figure out the
	     * starting point of a selector or css value.
	     *
	     * @param {function} check
	     *        A method which takes the current state as an input and determines
	     *        whether the state changed or not.
	     * @param {boolean} isValue
	     *        true if the traversal is being done for a css value state.
	     */
	    let traverseBackwards = (check, isValue) => {
	      let location;
	      // Backward loop to determine the beginning location of the selector.
	      do {
	        let lineText = sourceArray[line];
	        if (line == caret.line) {
	          lineText = lineText.substring(0, caret.ch);
	        }

	        let tokens = Array.from(cssTokenizer(lineText));
	        let found = false;
	        for (let i = tokens.length - 1; i >= 0; i--) {
	          let token = tokens[i];
	          // If the line is completely spaces, handle it differently
	          if (lineText.trim() == "") {
	            limitedSource = limitedSource.slice(0, -1 * lineText.length);
	          } else {
	            let length = token.endOffset - token.startOffset;
	            limitedSource = limitedSource.slice(0, -1 * length);
	          }

	          // Whitespace cannot change state.
	          if (token.tokenType == "whitespace") {
	            continue;
	          }

	          let backState = this.resolveState(limitedSource, {
	            line: line,
	            ch: token.startOffset
	          });
	          if (check(backState)) {
	            if (tokens[i + 1] && tokens[i + 1].tokenType == "whitespace") {
	              token = tokens[i + 1];
	            }
	            location = {
	              line: line,
	              ch: isValue ? token.endOffset : token.startOffset
	            };
	            found = true;
	            break;
	          }
	        }
	        limitedSource = limitedSource.slice(0, -1);
	        if (found) {
	          break;
	        }
	      } while (line-- >= 0);
	      return location;
	    };

	    if (state == CSS_STATES.selector) {
	      // For selector state, the ending and starting point of the selector is
	      // either when the state changes or the selector becomes empty and a
	      // single selector can span multiple lines.
	      // Backward loop to determine the beginning location of the selector.
	      let start = traverseBackwards(backState => {
	        return (backState != CSS_STATES.selector ||
	               (this.selector == "" && this.selectorBeforeNot == null));
	      });

	      line = caret.line;
	      limitedSource = limit(source, caret);
	      // Forward loop to determine the ending location of the selector.
	      let end = traverseForward(forwState => {
	        return (forwState != CSS_STATES.selector ||
	               (this.selector == "" && this.selectorBeforeNot == null));
	      });

	      // Since we have start and end positions, figure out the whole selector.
	      let selector = source.split("\n").slice(start.line, end.line + 1);
	      selector[selector.length - 1] =
	        selector[selector.length - 1].substring(0, end.ch);
	      selector[0] = selector[0].substring(start.ch);
	      selector = selector.join("\n");
	      return {
	        state: state,
	        selector: selector,
	        loc: {
	          start: start,
	          end: end
	        }
	      };
	    } else if (state == CSS_STATES.property) {
	      // A property can only be a single word and thus very easy to calculate.
	      let tokens = cssTokenizer(sourceArray[line]);
	      for (let token of tokens) {
	        // Note that, because we're tokenizing a single line, the
	        // token's offset is also the column number.
	        if (token.startOffset <= ch && token.endOffset >= ch) {
	          return {
	            state: state,
	            propertyName: token.text,
	            selectors: this.selectors,
	            loc: {
	              start: {
	                line: line,
	                ch: token.startOffset
	              },
	              end: {
	                line: line,
	                ch: token.endOffset
	              }
	            }
	          };
	        }
	      }
	    } else if (state == CSS_STATES.value) {
	      // CSS value can be multiline too, so we go forward and backwards to
	      // determine the bounds of the value at caret
	      let start = traverseBackwards(backState => backState != CSS_STATES.value, true);

	      line = caret.line;
	      limitedSource = limit(source, caret);
	      let end = traverseForward(forwState => forwState != CSS_STATES.value);

	      let value = source.split("\n").slice(start.line, end.line + 1);
	      value[value.length - 1] = value[value.length - 1].substring(0, end.ch);
	      value[0] = value[0].substring(start.ch);
	      value = value.join("\n");
	      return {
	        state: state,
	        propertyName: propertyName,
	        selectors: this.selectors,
	        value: value,
	        loc: {
	          start: start,
	          end: end
	        }
	      };
	    }
	    return null;
	  }
	};

	module.exports = CSSCompleter;


/***/ },
/* 174 */
/***/ function(module, exports) {

	module.exports = {
	  "!name": "browser",
	  "location": {
	    "assign": {
	      "!type": "fn(url: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "Load the document at the provided URL."
	    },
	    "replace": {
	      "!type": "fn(url: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "Replace the current document with the one at the provided URL. The difference from the assign() method is that after using replace() the current page will not be saved in session history, meaning the user won't be able to use the Back button to navigate to it."
	    },
	    "reload": {
	      "!type": "fn()",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "Reload the document from the current URL. forceget is a boolean, which, when it is true, causes the page to always be reloaded from the server. If it is false or not specified, the browser may reload the page from its cache."
	    },
	    "origin": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The origin of the URL."
	    },
	    "hash": {
	      "!type": "string",
	      "!url": "https://developer.mthat follows the # symbol, including the # symbol."
	    },
	    "search": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The part of the URL that follows the ? symbol, including the ? symbol."
	    },
	    "pathname": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The path (relative to the host)."
	    },
	    "port": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The port number of the URL."
	    },
	    "hostname": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The host name (without the port number or square brackets)."
	    },
	    "host": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The host name and port number."
	    },
	    "protocol": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The protocol of the URL."
	    },
	    "href": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The entire URL."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	    "!doc": "Returns a location object with information about the current location of the document. Assigning to the location property changes the current page to the new address."
	  },
	  "Node": {
	    "!type": "fn()",
	    "prototype": {
	      "parentElement": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.parentElement",
	        "!doc": "Returns the DOM node's parent Element, or null if the node either has no parent, or its parent isn't a DOM Element."
	      },
	      "textContent": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.textContent",
	        "!doc": "Gets or sets the text content of a node and its descendants."
	      },
	      "baseURI": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.baseURI",
	        "!doc": "The absolute base URI of a node or null if unable to obtain an absolute URI."
	      },
	      "localName": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.localName",
	        "!doc": "Returns the local part of the qualified name of this node."
	      },
	      "prefix": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.prefix",
	        "!doc": "Returns the namespace prefix of the specified node, or null if no prefix is specified. This property is read only."
	      },
	      "namespaceURI": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.namespaceURI",
	        "!doc": "The namespace URI of the node, or null if the node is not in a namespace (read-only). When the node is a document, it returns the XML namespace for the current document."
	      },
	      "ownerDocument": {
	        "!type": "+Document",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.ownerDocument",
	        "!doc": "The ownerDocument property returns the top-level document object for this node."
	      },
	      "attributes": {
	        "!type": "+NamedNodeMap",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.attributes",
	        "!doc": "A collection of all attribute nodes registered to the specified node. It is a NamedNodeMap,not an Array, so it has no Array methods and the Attr nodes' indexes may differ among browsers."
	      },
	      "nextSibling": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nextSibling",
	        "!doc": "Returns the node immediately following the specified one in its parent's childNodes list, or null if the specified node is the last node in that list."
	      },
	      "previousSibling": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.previousSibling",
	        "!doc": "Returns the node immediately preceding the specified one in its parent's childNodes list, null if the specified node is the first in that list."
	      },
	      "lastChild": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.lastChild",
	        "!doc": "Returns the last child of a node."
	      },
	      "firstChild": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.firstChild",
	        "!doc": "Returns the node's first child in the tree, or null if the node is childless. If the node is a Document, it returns the first node in the list of its direct children."
	      },
	      "childNodes": {
	        "!type": "+NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.childNodes",
	        "!doc": "Returns a collection of child nodes of the given element."
	      },
	      "parentNode": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.parentNode",
	        "!doc": "Returns the parent of the specified node in the DOM tree."
	      },
	      "nodeType": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeType",
	        "!doc": "Returns an integer code representing the type of the node."
	      },
	      "nodeValue": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeValue",
	        "!doc": "Returns or sets the value of the current node."
	      },
	      "nodeName": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeName",
	        "!doc": "Returns the name of the current node as a string."
	      },
	      "tagName": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeName",
	        "!doc": "Returns the name of the current node as a string."
	      },
	      "insertBefore": {
	        "!type": "fn(newElt: +Element, before: +Element) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.insertBefore",
	        "!doc": "Inserts the specified node before a reference element as a child of the current node."
	      },
	      "replaceChild": {
	        "!type": "fn(newElt: +Element, oldElt: +Element) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.replaceChild",
	        "!doc": "Replaces one child node of the specified element with another."
	      },
	      "removeChild": {
	        "!type": "fn(oldElt: +Element) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.removeChild",
	        "!doc": "Removes a child node from the DOM. Returns removed node."
	      },
	      "appendChild": {
	        "!type": "fn(newElt: +Element) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.appendChild",
	        "!doc": "Adds a node to the end of the list of children of a specified parent node. If the node already exists it is removed from current parent node, then added to new parent node."
	      },
	      "hasChildNodes": {
	        "!type": "fn() -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.hasChildNodes",
	        "!doc": "Returns a Boolean value indicating whether the current Node has child nodes or not."
	      },
	      "cloneNode": {
	        "!type": "fn(deep: bool) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.cloneNode",
	        "!doc": "Returns a duplicate of the node on which this method was called."
	      },
	      "normalize": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.normalize",
	        "!doc": "Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized subtree, no text nodes in the subtree are empty and there are no adjacent text nodes."
	      },
	      "isSupported": {
	        "!type": "fn(features: string, version: number) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isSupported",
	        "!doc": "Tests whether the DOM implementation implements a specific feature and that feature is supported by this node."
	      },
	      "hasAttributes": {
	        "!type": "fn() -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.hasAttributes",
	        "!doc": "Returns a boolean value of true or false, indicating if the current element has any attributes or not."
	      },
	      "lookupPrefix": {
	        "!type": "fn(uri: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.lookupPrefix",
	        "!doc": "Returns the prefix for a given namespaceURI if present, and null if not. When multiple prefixes are possible, the result is implementation-dependent."
	      },
	      "isDefaultNamespace": {
	        "!type": "fn(uri: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isDefaultNamespace",
	        "!doc": "Accepts a namespace URI as an argument and returns true if the namespace is the default namespace on the given node or false if not."
	      },
	      "lookupNamespaceURI": {
	        "!type": "fn(uri: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.lookupNamespaceURI",
	        "!doc": "Takes a prefix and returns the namespaceURI associated with it on the given node if found (and null if not). Supplying null for the prefix will return the default namespace."
	      },
	      "addEventListener": {
	        "!type": "fn(type: string, listener: fn(e: +Event), capture: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.addEventListener",
	        "!doc": "Registers a single event listener on a single target. The event target may be a single element in a document, the document itself, a window, or an XMLHttpRequest."
	      },
	      "removeEventListener": {
	        "!type": "fn(type: string, listener: fn(), capture: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.removeEventListener",
	        "!doc": "Allows the removal of event listeners from the event target."
	      },
	      "isSameNode": {
	        "!type": "fn(other: +Node) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isSameNode",
	        "!doc": "Tests whether two nodes are the same, that is they reference the same object."
	      },
	      "isEqualNode": {
	        "!type": "fn(other: +Node) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isEqualNode",
	        "!doc": "Tests whether two nodes are equal."
	      },
	      "compareDocumentPosition": {
	        "!type": "fn(other: +Node) -> number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.compareDocumentPosition",
	        "!doc": "Compares the position of the current node against another node in any other document."
	      },
	      "contains": {
	        "!type": "fn(other: +Node) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.contains",
	        "!doc": "Indicates whether a node is a descendent of a given node."
	      },
	      "dispatchEvent": {
	        "!type": "fn(event: +Event) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.dispatchEvent",
	        "!doc": "Dispatches an event into the event system. The event is subject to the same capturing and bubbling behavior as directly dispatched events."
	      },
	      "ELEMENT_NODE": "number",
	      "ATTRIBUTE_NODE": "number",
	      "TEXT_NODE": "number",
	      "CDATA_SECTION_NODE": "number",
	      "ENTITY_REFERENCE_NODE": "number",
	      "ENTITY_NODE": "number",
	      "PROCESSING_INSTRUCTION_NODE": "number",
	      "COMMENT_NODE": "number",
	      "DOCUMENT_NODE": "number",
	      "DOCUMENT_TYPE_NODE": "number",
	      "DOCUMENT_FRAGMENT_NODE": "number",
	      "NOTATION_NODE": "number",
	      "DOCUMENT_POSITION_DISCONNECTED": "number",
	      "DOCUMENT_POSITION_PRECEDING": "number",
	      "DOCUMENT_POSITION_FOLLOWING": "number",
	      "DOCUMENT_POSITION_CONTAINS": "number",
	      "DOCUMENT_POSITION_CONTAINED_BY": "number",
	      "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Node",
	    "!doc": "A Node is an interface from which a number of DOM types inherit, and allows these various types to be treated (or tested) similarly."
	  },
	  "Element": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Node.prototype",
	      "getAttribute": {
	        "!type": "fn(name: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttribute",
	        "!doc": "Returns the value of the named attribute on the specified element. If the named attribute does not exist, the value returned will either be null or \"\" (the empty string)."
	      },
	      "setAttribute": {
	        "!type": "fn(name: string, value: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttribute",
	        "!doc": "Adds a new attribute or changes the value of an existing attribute on the specified element."
	      },
	      "removeAttribute": {
	        "!type": "fn(name: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.removeAttribute",
	        "!doc": "Removes an attribute from the specified element."
	      },
	      "getAttributeNode": {
	        "!type": "fn(name: string) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttributeNode",
	        "!doc": "Returns the specified attribute of the specified element, as an Attr node."
	      },
	      "getElementsByTagName": {
	        "!type": "fn(tagName: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getElementsByTagName",
	        "!doc": "Returns a list of elements with the given tag name. The subtree underneath the specified element is searched, excluding the element itself. The returned list is live, meaning that it updates itself with the DOM tree automatically. Consequently, there is no need to call several times element.getElementsByTagName with the same element and arguments."
	      },
	      "getElementsByTagNameNS": {
	        "!type": "fn(ns: string, tagName: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getElementsByTagNameNS",
	        "!doc": "Returns a list of elements with the given tag name belonging to the given namespace."
	      },
	      "getAttributeNS": {
	        "!type": "fn(ns: string, name: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttributeNS",
	        "!doc": "Returns the string value of the attribute with the specified namespace and name. If the named attribute does not exist, the value returned will either be null or \"\" (the empty string)."
	      },
	      "setAttributeNS": {
	        "!type": "fn(ns: string, name: string, value: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttributeNS",
	        "!doc": "Adds a new attribute or changes the value of an attribute with the given namespace and name."
	      },
	      "removeAttributeNS": {
	        "!type": "fn(ns: string, name: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.removeAttributeNS",
	        "!doc": "removeAttributeNS removes the specified attribute from an element."
	      },
	      "getAttributeNodeNS": {
	        "!type": "fn(ns: string, name: string) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttributeNodeNS",
	        "!doc": "Returns the Attr node for the attribute with the given namespace and name."
	      },
	      "hasAttribute": {
	        "!type": "fn(name: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.hasAttribute",
	        "!doc": "hasAttribute returns a boolean value indicating whether the specified element has the specified attribute or not."
	      },
	      "hasAttributeNS": {
	        "!type": "fn(ns: string, name: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.hasAttributeNS",
	        "!doc": "hasAttributeNS returns a boolean value indicating whether the current element has the specified attribute."
	      },
	      "focus": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.focus",
	        "!doc": "Sets focus on the specified element, if it can be focused."
	      },
	      "blur": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.blur",
	        "!doc": "The blur method removes keyboard focus from the current element."
	      },
	      "scrollIntoView": {
	        "!type": "fn(top: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollIntoView",
	        "!doc": "The scrollIntoView() method scrolls the element into view."
	      },
	      "scrollByLines": {
	        "!type": "fn(lines: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollByLines",
	        "!doc": "Scrolls the document by the given number of lines."
	      },
	      "scrollByPages": {
	        "!type": "fn(pages: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollByPages",
	        "!doc": "Scrolls the current document by the specified number of pages."
	      },
	      "getElementsByClassName": {
	        "!type": "fn(name: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByClassName",
	        "!doc": "Returns a set of elements which have all the given class names. When called on the document object, the complete document is searched, including the root node. You may also call getElementsByClassName on any element; it will return only elements which are descendants of the specified root element with the given class names."
	      },
	      "querySelector": {
	        "!type": "fn(selectors: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.querySelector",
	        "!doc": "Returns the first element that is a descendent of the element on which it is invoked that matches the specified group of selectors."
	      },
	      "querySelectorAll": {
	        "!type": "fn(selectors: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.querySelectorAll",
	        "!doc": "Returns a non-live NodeList of all elements descended from the element on which it is invoked that match the specified group of CSS selectors."
	      },
	      "getClientRects": {
	        "!type": "fn() -> [+ClientRect]",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Returns a collection of rectangles that indicate the bounding rectangles for each box in a client."
	      },
	      "getBoundingClientRect": {
	        "!type": "fn() -> +ClientRect",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getBoundingClientRect",
	        "!doc": "Returns a text rectangle object that encloses a group of text rectangles."
	      },
	      "setAttributeNode": {
	        "!type": "fn(attr: +Attr) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttributeNode",
	        "!doc": "Adds a new Attr node to the specified element."
	      },
	      "removeAttributeNode": {
	        "!type": "fn(attr: +Attr) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.removeAttributeNode",
	        "!doc": "Removes the specified attribute from the current element."
	      },
	      "setAttributeNodeNS": {
	        "!type": "fn(attr: +Attr) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttributeNodeNS",
	        "!doc": "Adds a new namespaced attribute node to an element."
	      },
	      "insertAdjacentHTML": {
	        "!type": "fn(position: string, text: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.insertAdjacentHTML",
	        "!doc": "Parses the specified text as HTML or XML and inserts the resulting nodes into the DOM tree at a specified position. It does not reparse the element it is being used on and thus it does not corrupt the existing elements inside the element. This, and avoiding the extra step of serialization make it much faster than direct innerHTML manipulation."
	      },
	      "children": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.children",
	        "!doc": "Returns a collection of child elements of the given element."
	      },
	      "childElementCount": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.childElementCount",
	        "!doc": "Returns the number of child elements of the given element."
	      },
	      "className": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.className",
	        "!doc": "Gets and sets the value of the class attribute of the specified element."
	      },
	      "style": {
	        "cssText": "string",
	        "alignmentBaseline": "string",
	        "background": "string",
	        "backgroundAttachment": "string",
	        "backgroundClip": "string",
	        "backgroundColor": "string",
	        "backgroundImage": "string",
	        "backgroundOrigin": "string",
	        "backgroundPosition": "string",
	        "backgroundPositionX": "string",
	        "backgroundPositionY": "string",
	        "backgroundRepeat": "string",
	        "backgroundRepeatX": "string",
	        "backgroundRepeatY": "string",
	        "backgroundSize": "string",
	        "baselineShift": "string",
	        "border": "string",
	        "borderBottom": "string",
	        "borderBottomColor": "string",
	        "borderBottomLeftRadius": "string",
	        "borderBottomRightRadius": "string",
	        "borderBottomStyle": "string",
	        "borderBottomWidth": "string",
	        "borderCollapse": "string",
	        "borderColor": "string",
	        "borderImage": "string",
	        "borderImageOutset": "string",
	        "borderImageRepeat": "string",
	        "borderImageSlice": "string",
	        "borderImageSource": "string",
	        "borderImageWidth": "string",
	        "borderLeft": "string",
	        "borderLeftColor": "string",
	        "borderLeftStyle": "string",
	        "borderLeftWidth": "string",
	        "borderRadius": "string",
	        "borderRight": "string",
	        "borderRightColor": "string",
	        "borderRightStyle": "string",
	        "borderRightWidth": "string",
	        "borderSpacing": "string",
	        "borderStyle": "string",
	        "borderTop": "string",
	        "borderTopColor": "string",
	        "borderTopLeftRadius": "string",
	        "borderTopRightRadius": "string",
	        "borderTopStyle": "string",
	        "borderTopWidth": "string",
	        "borderWidth": "string",
	        "bottom": "string",
	        "boxShadow": "string",
	        "boxSizing": "string",
	        "captionSide": "string",
	        "clear": "string",
	        "clip": "string",
	        "clipPath": "string",
	        "clipRule": "string",
	        "color": "string",
	        "colorInterpolation": "string",
	        "colorInterpolationFilters": "string",
	        "colorProfile": "string",
	        "colorRendering": "string",
	        "content": "string",
	        "counterIncrement": "string",
	        "counterReset": "string",
	        "cursor": "string",
	        "direction": "string",
	        "display": "string",
	        "dominantBaseline": "string",
	        "emptyCells": "string",
	        "enableBackground": "string",
	        "fill": "string",
	        "fillOpacity": "string",
	        "fillRule": "string",
	        "filter": "string",
	        "float": "string",
	        "floodColor": "string",
	        "floodOpacity": "string",
	        "font": "string",
	        "fontFamily": "string",
	        "fontSize": "string",
	        "fontStretch": "string",
	        "fontStyle": "string",
	        "fontVariant": "string",
	        "fontWeight": "string",
	        "glyphOrientationHorizontal": "string",
	        "glyphOrientationVertical": "string",
	        "height": "string",
	        "imageRendering": "string",
	        "kerning": "string",
	        "left": "string",
	        "letterSpacing": "string",
	        "lightingColor": "string",
	        "lineHeight": "string",
	        "listStyle": "string",
	        "listStyleImage": "string",
	        "listStylePosition": "string",
	        "listStyleType": "string",
	        "margin": "string",
	        "marginBottom": "string",
	        "marginLeft": "string",
	        "marginRight": "string",
	        "marginTop": "string",
	        "marker": "string",
	        "markerEnd": "string",
	        "markerMid": "string",
	        "markerStart": "string",
	        "mask": "string",
	        "maxHeight": "string",
	        "maxWidth": "string",
	        "minHeight": "string",
	        "minWidth": "string",
	        "opacity": "string",
	        "orphans": "string",
	        "outline": "string",
	        "outlineColor": "string",
	        "outlineOffset": "string",
	        "outlineStyle": "string",
	        "outlineWidth": "string",
	        "overflow": "string",
	        "overflowWrap": "string",
	        "overflowX": "string",
	        "overflowY": "string",
	        "padding": "string",
	        "paddingBottom": "string",
	        "paddingLeft": "string",
	        "paddingRight": "string",
	        "paddingTop": "string",
	        "page": "string",
	        "pageBreakAfter": "string",
	        "pageBreakBefore": "string",
	        "pageBreakInside": "string",
	        "pointerEvents": "string",
	        "position": "string",
	        "quotes": "string",
	        "resize": "string",
	        "right": "string",
	        "shapeRendering": "string",
	        "size": "string",
	        "speak": "string",
	        "src": "string",
	        "stopColor": "string",
	        "stopOpacity": "string",
	        "stroke": "string",
	        "strokeDasharray": "string",
	        "strokeDashoffset": "string",
	        "strokeLinecap": "string",
	        "strokeLinejoin": "string",
	        "strokeMiterlimit": "string",
	        "strokeOpacity": "string",
	        "strokeWidth": "string",
	        "tabSize": "string",
	        "tableLayout": "string",
	        "textAlign": "string",
	        "textAnchor": "string",
	        "textDecoration": "string",
	        "textIndent": "string",
	        "textLineThrough": "string",
	        "textLineThroughColor": "string",
	        "textLineThroughMode": "string",
	        "textLineThroughStyle": "string",
	        "textLineThroughWidth": "string",
	        "textOverflow": "string",
	        "textOverline": "string",
	        "textOverlineColor": "string",
	        "textOverlineMode": "string",
	        "textOverlineStyle": "string",
	        "textOverlineWidth": "string",
	        "textRendering": "string",
	        "textShadow": "string",
	        "textTransform": "string",
	        "textUnderline": "string",
	        "textUnderlineColor": "string",
	        "textUnderlineMode": "string",
	        "textUnderlineStyle": "string",
	        "textUnderlineWidth": "string",
	        "top": "string",
	        "unicodeBidi": "string",
	        "unicodeRange": "string",
	        "vectorEffect": "string",
	        "verticalAlign": "string",
	        "visibility": "string",
	        "whiteSpace": "string",
	        "width": "string",
	        "wordBreak": "string",
	        "wordSpacing": "string",
	        "wordWrap": "string",
	        "writingMode": "string",
	        "zIndex": "string",
	        "zoom": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.style",
	        "!doc": "Returns an object that represents the element's style attribute."
	      },
	      "classList": {
	        "!type": "+DOMTokenList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.classList",
	        "!doc": "Returns a token list of the class attribute of the element."
	      },
	      "contentEditable": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.contentEditable",
	        "!doc": "Indicates whether or not the element is editable."
	      },
	      "firstElementChild": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.firstElementChild",
	        "!doc": "Returns the element's first child element or null if there are no child elements."
	      },
	      "lastElementChild": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.lastElementChild",
	        "!doc": "Returns the element's last child element or null if there are no child elements."
	      },
	      "nextElementSibling": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.nextElementSibling",
	        "!doc": "Returns the element immediately following the specified one in its parent's children list, or null if the specified element is the last one in the list."
	      },
	      "previousElementSibling": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.previousElementSibling",
	        "!doc": "Returns the element immediately prior to the specified one in its parent's children list, or null if the specified element is the first one in the list."
	      },
	      "tabIndex": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.tabIndex",
	        "!doc": "Gets/sets the tab order of the current element."
	      },
	      "title": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.title",
	        "!doc": "Establishes the text to be displayed in a 'tool tip' popup when the mouse is over the displayed node."
	      },
	      "width": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetWidth",
	        "!doc": "Returns the layout width of an element."
	      },
	      "height": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetHeight",
	        "!doc": "Height of an element relative to the element's offsetParent."
	      },
	      "getContext": {
	        "!type": "fn(id: string) -> CanvasRenderingContext2D",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCanvasElement",
	        "!doc": "DOM canvas elements expose the HTMLCanvasElement interface, which provides properties and methods for manipulating the layout and presentation of canvas elements. The HTMLCanvasElement interface inherits the properties and methods of the element object interface."
	      },
	      "supportsContext": "fn(id: string) -> bool",
	      "oncopy": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.oncopy",
	        "!doc": "The oncopy property returns the onCopy event handler code on the current element."
	      },
	      "oncut": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.oncut",
	        "!doc": "The oncut property returns the onCut event handler code on the current element."
	      },
	      "onpaste": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onpaste",
	        "!doc": "The onpaste property returns the onPaste event handler code on the current element."
	      },
	      "onbeforeunload": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/HTML/Element/body",
	        "!doc": "The HTML <body> element represents the main content of an HTML document. There is only one <body> element in a document."
	      },
	      "onfocus": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onfocus",
	        "!doc": "The onfocus property returns the onFocus event handler code on the current element."
	      },
	      "onblur": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onblur",
	        "!doc": "The onblur property returns the onBlur event handler code, if any, that exists on the current element."
	      },
	      "onchange": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onchange",
	        "!doc": "The onchange property sets and returns the onChange event handler code for the current element."
	      },
	      "onclick": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onclick",
	        "!doc": "The onclick property returns the onClick event handler code on the current element."
	      },
	      "ondblclick": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.ondblclick",
	        "!doc": "The ondblclick property returns the onDblClick event handler code on the current element."
	      },
	      "onmousedown": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmousedown",
	        "!doc": "The onmousedown property returns the onMouseDown event handler code on the current element."
	      },
	      "onmouseup": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseup",
	        "!doc": "The onmouseup property returns the onMouseUp event handler code on the current element."
	      },
	      "onmousewheel": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/wheel",
	        "!doc": "The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. This event deprecates the legacy mousewheel event."
	      },
	      "onmouseover": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseover",
	        "!doc": "The onmouseover property returns the onMouseOver event handler code on the current element."
	      },
	      "onmouseout": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseout",
	        "!doc": "The onmouseout property returns the onMouseOut event handler code on the current element."
	      },
	      "onmousemove": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmousemove",
	        "!doc": "The onmousemove property returns the mousemove event handler code on the current element."
	      },
	      "oncontextmenu": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/window.oncontextmenu",
	        "!doc": "An event handler property for right-click events on the window. Unless the default behavior is prevented, the browser context menu will activate. Note that this event will occur with any non-disabled right-click event and does not depend on an element possessing the \"contextmenu\" attribute."
	      },
	      "onkeydown": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeydown",
	        "!doc": "The onkeydown property returns the onKeyDown event handler code on the current element."
	      },
	      "onkeyup": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeyup",
	        "!doc": "The onkeyup property returns the onKeyUp event handler code for the current element."
	      },
	      "onkeypress": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeypress",
	        "!doc": "The onkeypress property sets and returns the onKeyPress event handler code for the current element."
	      },
	      "onresize": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onresize",
	        "!doc": "onresize returns the element's onresize event handler code. It can also be used to set the code to be executed when the resize event occurs."
	      },
	      "onscroll": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onscroll",
	        "!doc": "The onscroll property returns the onScroll event handler code on the current element."
	      },
	      "ondragstart": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	        "!doc": "The following describes the steps that occur during a drag and drop operation."
	      },
	      "ondragover": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragover",
	        "!doc": "The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds)."
	      },
	      "ondragleave": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragleave",
	        "!doc": "The dragleave event is fired when a dragged element or text selection leaves a valid drop target."
	      },
	      "ondragenter": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragenter",
	        "!doc": "The dragenter event is fired when a dragged element or text selection enters a valid drop target."
	      },
	      "ondragend": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragend",
	        "!doc": "The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key)."
	      },
	      "ondrag": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/drag",
	        "!doc": "The drag event is fired when an element or text selection is being dragged (every few hundred milliseconds)."
	      },
	      "offsetTop": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetTop",
	        "!doc": "Returns the distance of the current element relative to the top of the offsetParent node."
	      },
	      "offsetLeft": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetLeft",
	        "!doc": "Returns the number of pixels that the upper left corner of the current element is offset to the left within the offsetParent node."
	      },
	      "offsetHeight": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetHeight",
	        "!doc": "Height of an element relative to the element's offsetParent."
	      },
	      "offsetWidth": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetWidth",
	        "!doc": "Returns the layout width of an element."
	      },
	      "scrollTop": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollTop",
	        "!doc": "Gets or sets the number of pixels that the content of an element is scrolled upward."
	      },
	      "scrollLeft": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollLeft",
	        "!doc": "Gets or sets the number of pixels that an element's content is scrolled to the left."
	      },
	      "scrollHeight": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollHeight",
	        "!doc": "Height of the scroll view of an element; it includes the element padding but not its margin."
	      },
	      "scrollWidth": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollWidth",
	        "!doc": "Read-only property that returns either the width in pixels of the content of an element or the width of the element itself, whichever is greater."
	      },
	      "clientTop": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientTop",
	        "!doc": "The width of the top border of an element in pixels. It does not include the top margin or padding. clientTop is read-only."
	      },
	      "clientLeft": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientLeft",
	        "!doc": "The width of the left border of an element in pixels. It includes the width of the vertical scrollbar if the text direction of the element is right-to-left and if there is an overflow causing a left vertical scrollbar to be rendered. clientLeft does not include the left margin or the left padding. clientLeft is read-only."
	      },
	      "clientHeight": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientHeight",
	        "!doc": "Returns the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin."
	      },
	      "clientWidth": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientWidth",
	        "!doc": "The inner width of an element in pixels. It includes padding but not the vertical scrollbar (if present, if rendered), border or margin."
	      },
	      "innerHTML": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.innerHTML",
	        "!doc": "Sets or gets the HTML syntax describing the element's descendants."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Element",
	    "!doc": "Represents an element in an HTML or XML document."
	  },
	  "Text": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Node.prototype",
	      "wholeText": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Text.wholeText",
	        "!doc": "Returns all text of all Text nodes logically adjacent to the node.  The text is concatenated in document order.  This allows you to specify any text node and obtain all adjacent text as a single string."
	      },
	      "splitText": {
	        "!type": "fn(offset: number) -> +Text",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Text.splitText",
	        "!doc": "Breaks the Text node into two nodes at the specified offset, keeping both nodes in the tree as siblings."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Text",
	    "!doc": "In the DOM, the Text interface represents the textual content of an Element or Attr.  If an element has no markup within its content, it has a single child implementing Text that contains the element's text.  However, if the element contains markup, it is parsed into information items and Text nodes that form its children."
	  },
	  "Document": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Node.prototype",
	      "activeElement": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.activeElement",
	        "!doc": "Returns the currently focused element, that is, the element that will get keystroke events if the user types any. This attribute is read only."
	      },
	      "compatMode": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.compatMode",
	        "!doc": "Indicates whether the document is rendered in Quirks mode or Strict mode."
	      },
	      "designMode": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.designMode",
	        "!doc": "Can be used to make any document editable, for example in a <iframe />:"
	      },
	      "dir": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Document.dir",
	        "!doc": "This property should indicate and allow the setting of the directionality of the text of the document, whether left to right (default) or right to left."
	      },
	      "height": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.height",
	        "!doc": "Returns the height of the <body> element of the current document."
	      },
	      "width": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.width",
	        "!doc": "Returns the width of the <body> element of the current document in pixels."
	      },
	      "characterSet": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.characterSet",
	        "!doc": "Returns the character encoding of the current document."
	      },
	      "readyState": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.readyState",
	        "!doc": "Returns \"loading\" while the document is loading, \"interactive\" once it is finished parsing but still loading sub-resources, and \"complete\" once it has loaded."
	      },
	      "location": {
	        "!type": "location",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.location",
	        "!doc": "Returns a Location object, which contains information about the URL of the document and provides methods for changing that URL."
	      },
	      "lastModified": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.lastModified",
	        "!doc": "Returns a string containing the date and time on which the current document was last modified."
	      },
	      "head": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.head",
	        "!doc": "Returns the <head> element of the current document. If there are more than one <head> elements, the first one is returned."
	      },
	      "body": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.body",
	        "!doc": "Returns the <body> or <frameset> node of the current document."
	      },
	      "cookie": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.cookie",
	        "!doc": "Get and set the cookies associated with the current document."
	      },
	      "URL": "string",
	      "domain": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.domain",
	        "!doc": "Gets/sets the domain portion of the origin of the current document, as used by the same origin policy."
	      },
	      "referrer": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.referrer",
	        "!doc": "Returns the URI of the page that linked to this page."
	      },
	      "title": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.title",
	        "!doc": "Gets or sets the title of the document."
	      },
	      "defaultView": {
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.defaultView",
	        "!doc": "In browsers returns the window object associated with the document or null if none available."
	      },
	      "documentURI": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.documentURI",
	        "!doc": "Returns the document location as string. It is read-only per DOM4 specification."
	      },
	      "xmlStandalone": "bool",
	      "xmlVersion": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.xmlVersion",
	        "!doc": "Returns the version number as specified in the XML declaration (e.g., <?xml version=\"1.0\"?>) or \"1.0\" if the declaration is absent."
	      },
	      "xmlEncoding": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Document.xmlEncoding",
	        "!doc": "Returns the encoding as determined by the XML declaration. Should be null if unspecified or unknown."
	      },
	      "inputEncoding": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.inputEncoding",
	        "!doc": "Returns a string representing the encoding under which the document was parsed (e.g. ISO-8859-1)."
	      },
	      "documentElement": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.documentElement",
	        "!doc": "Read-only"
	      },
	      "implementation": {
	        "hasFeature": "fn(feature: string, version: number) -> bool",
	        "createDocumentType": {
	          "!type": "fn(qualifiedName: string, publicId: string, systemId: string) -> +Node",
	          "!url": "https://developer.mozilla.org/en/docs/DOM/DOMImplementation.createDocumentType",
	          "!doc": "Returns a DocumentType object which can either be used with DOMImplementation.createDocument upon document creation or they can be put into the document via Node.insertBefore() or Node.replaceChild(): http://www.w3.org/TR/DOM-Level-3-Cor...l#ID-B63ED1A31 (less ideal due to features not likely being as accessible: http://www.w3.org/TR/DOM-Level-3-Cor...createDocument ). In any case, entity declarations and notations will not be available: http://www.w3.org/TR/DOM-Level-3-Cor...-createDocType   "
	        },
	        "createHTMLDocument": {
	          "!type": "fn(title: string) -> +Document",
	          "!url": "https://developer.mozilla.org/en/docs/DOM/DOMImplementation.createHTMLDocument",
	          "!doc": "This method (available from document.implementation) creates a new HTML document."
	        },
	        "createDocument": {
	          "!type": "fn(namespaceURI: string, qualifiedName: string, type: +Node) -> +Document",
	          "!url": "https://developer.mozilla.org/en-US/docs/DOM/DOMImplementation.createHTMLDocument",
	          "!doc": "This method creates a new HTML document."
	        },
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.implementation",
	        "!doc": "Returns a DOMImplementation object associated with the current document."
	      },
	      "doctype": {
	        "!type": "+Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.doctype",
	        "!doc": "Returns the Document Type Declaration (DTD) associated with current document. The returned object implements the DocumentType interface. Use DOMImplementation.createDocumentType() to create a DocumentType."
	      },
	      "open": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.open",
	        "!doc": "The document.open() method opens a document for writing."
	      },
	      "close": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.close",
	        "!doc": "The document.close() method finishes writing to a document, opened with document.open()."
	      },
	      "write": {
	        "!type": "fn(html: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.write",
	        "!doc": "Writes a string of text to a document stream opened by document.open()."
	      },
	      "writeln": {
	        "!type": "fn(html: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.writeln",
	        "!doc": "Writes a string of text followed by a newline character to a document."
	      },
	      "clear": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.clear",
	        "!doc": "In recent versions of Mozilla-based applications as well as in Internet Explorer and Netscape 4 this method does nothing."
	      },
	      "hasFocus": {
	        "!type": "fn() -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.hasFocus",
	        "!doc": "Returns a Boolean value indicating whether the document or any element inside the document has focus. This method can be used to determine whether the active element in a document has focus."
	      },
	      "createElement": {
	        "!type": "fn(tagName: string) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createElement",
	        "!doc": "Creates the specified element."
	      },
	      "createElementNS": {
	        "!type": "fn(ns: string, tagName: string) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createElementNS",
	        "!doc": "Creates an element with the specified namespace URI and qualified name."
	      },
	      "createDocumentFragment": {
	        "!type": "fn() -> +DocumentFragment",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment",
	        "!doc": "Creates a new empty DocumentFragment."
	      },
	      "createTextNode": {
	        "!type": "fn(content: string) -> +Text",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createTextNode",
	        "!doc": "Creates a new Text node."
	      },
	      "createComment": {
	        "!type": "fn(content: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createComment",
	        "!doc": "Creates a new comment node, and returns it."
	      },
	      "createCDATASection": {
	        "!type": "fn(content: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createCDATASection",
	        "!doc": "Creates a new CDATA section node, and returns it. "
	      },
	      "createProcessingInstruction": {
	        "!type": "fn(content: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createProcessingInstruction",
	        "!doc": "Creates a new processing instruction node, and returns it."
	      },
	      "createAttribute": {
	        "!type": "fn(name: string) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createAttribute",
	        "!doc": "Creates a new attribute node, and returns it."
	      },
	      "createAttributeNS": {
	        "!type": "fn(ns: string, name: string) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	      },
	      "importNode": {
	        "!type": "fn(node: +Node, deep: bool) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.importNode",
	        "!doc": "Creates a copy of a node from an external document that can be inserted into the current document."
	      },
	      "getElementById": {
	        "!type": "fn(id: string) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementById",
	        "!doc": "Returns a reference to the element by its ID."
	      },
	      "getElementsByTagName": {
	        "!type": "fn(tagName: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByTagName",
	        "!doc": "Returns a NodeList of elements with the given tag name. The complete document is searched, including the root node. The returned NodeList is live, meaning that it updates itself automatically to stay in sync with the DOM tree without having to call document.getElementsByTagName again."
	      },
	      "getElementsByTagNameNS": {
	        "!type": "fn(ns: string, tagName: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByTagNameNS",
	        "!doc": "Returns a list of elements with the given tag name belonging to the given namespace. The complete document is searched, including the root node."
	      },
	      "createEvent": {
	        "!type": "fn(type: string) -> +Event",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createEvent",
	        "!doc": "Creates an event of the type specified. The returned object should be first initialized and can then be passed to element.dispatchEvent."
	      },
	      "createRange": {
	        "!type": "fn() -> +Range",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createRange",
	        "!doc": "Returns a new Range object."
	      },
	      "evaluate": {
	        "!type": "fn(expr: ?) -> +XPathResult",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.evaluate",
	        "!doc": "Returns an XPathResult based on an XPath expression and other given parameters."
	      },
	      "execCommand": {
	        "!type": "fn(cmd: string)",
	        "!url": "https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla#Executing_Commands",
	        "!doc": "Run command to manipulate the contents of an editable region."
	      },
	      "queryCommandEnabled": {
	        "!type": "fn(cmd: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	        "!doc": "Returns true if the Midas command can be executed on the current range."
	      },
	      "queryCommandIndeterm": {
	        "!type": "fn(cmd: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	        "!doc": "Returns true if the Midas command is in a indeterminate state on the current range."
	      },
	      "queryCommandState": {
	        "!type": "fn(cmd: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	        "!doc": "Returns true if the Midas command has been executed on the current range."
	      },
	      "queryCommandSupported": {
	        "!type": "fn(cmd: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.queryCommandSupported",
	        "!doc": "Reports whether or not the specified editor query command is supported by the browser."
	      },
	      "queryCommandValue": {
	        "!type": "fn(cmd: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	        "!doc": "Returns the current value of the current range for Midas command."
	      },
	      "getElementsByName": {
	        "!type": "fn(name: string) -> +HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByName",
	        "!doc": "Returns a list of elements with a given name in the HTML document."
	      },
	      "elementFromPoint": {
	        "!type": "fn(x: number, y: number) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.elementFromPoint",
	        "!doc": "Returns the element from the document whose elementFromPoint method is being called which is the topmost element which lies under the given point.  To get an element, specify the point via coordinates, in CSS pixels, relative to the upper-left-most point in the window or frame containing the document."
	      },
	      "getSelection": {
	        "!type": "fn() -> +Selection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getSelection",
	        "!doc": "The DOM getSelection() method is available on the Window and Document interfaces."
	      },
	      "adoptNode": {
	        "!type": "fn(node: +Node) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.adoptNode",
	        "!doc": "Adopts a node from an external document. The node and its subtree is removed from the document it's in (if any), and its ownerDocument is changed to the current document. The node can then be inserted into the current document."
	      },
	      "createTreeWalker": {
	        "!type": "fn(root: +Node, mask: number) -> ?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createTreeWalker",
	        "!doc": "Returns a new TreeWalker object."
	      },
	      "createExpression": {
	        "!type": "fn(text: string) -> ?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createExpression",
	        "!doc": "This method compiles an XPathExpression which can then be used for (repeated) evaluations."
	      },
	      "createNSResolver": {
	        "!type": "fn(node: +Node)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createNSResolver",
	        "!doc": "Creates an XPathNSResolver which resolves namespaces with respect to the definitions in scope for a specified node."
	      },
	      "scripts": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Document.scripts",
	        "!doc": "Returns a list of the <script> elements in the document. The returned object is an HTMLCollection."
	      },
	      "plugins": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.plugins",
	        "!doc": "Returns an HTMLCollection object containing one or more HTMLEmbedElements or null which represent the <embed> elements in the current document."
	      },
	      "embeds": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.embeds",
	        "!doc": "Returns a list of the embedded OBJECTS within the current document."
	      },
	      "anchors": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.anchors",
	        "!doc": "Returns a list of all of the anchors in the document."
	      },
	      "links": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.links",
	        "!doc": "The links property returns a collection of all AREA elements and anchor elements in a document with a value for the href attribute. "
	      },
	      "forms": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.forms",
	        "!doc": "Returns a collection (an HTMLCollection) of the form elements within the current document."
	      },
	      "styleSheets": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.styleSheets",
	        "!doc": "Returns a list of stylesheet objects for stylesheets explicitly linked into or embedded in a document."
	      },
	      "querySelector": "Element.prototype.querySelector",
	      "querySelectorAll": "Element.prototype.querySelectorAll"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	    "!doc": "Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."
	  },
	  "document": {
	    "!type": "+Document",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	    "!doc": "Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."
	  },
	  "XMLDocument": {
	    "!type": "fn()",
	    "prototype": "Document.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/Parsing_and_serializing_XML",
	    "!doc": "The Web platform provides the following objects for parsing and serializing XML:"
	  },
	  "Attr": {
	    "!type": "fn()",
	    "prototype": {
	      "isId": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	      },
	      "name": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	      },
	      "value": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	    "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	  },
	  "NodeList": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.length",
	        "!doc": "Returns the number of items in a NodeList."
	      },
	      "item": {
	        "!type": "fn(i: number) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NodeList.item",
	        "!doc": "Returns a node from a NodeList by index."
	      },
	      "<i>": "+Element"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/NodeList",
	    "!doc": "NodeList objects are collections of nodes returned by getElementsByTagName, getElementsByTagNameNS, Node.childNodes, querySelectorAll, getElementsByClassName, etc."
	  },
	  "HTMLCollection": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
	        "!doc": "The number of items in the collection."
	      },
	      "item": {
	        "!type": "fn(i: number) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
	        "!doc": "Returns the specific node at the given zero-based index into the list. Returns null if the index is out of range."
	      },
	      "namedItem": {
	        "!type": "fn(name: string) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
	        "!doc": "Returns the specific node whose ID or, as a fallback, name matches the string specified by name. Matching by name is only done as a last resort, only in HTML, and only if the referenced element supports the name attribute. Returns null if no node exists by the given name."
	      },
	      "<i>": "+Element"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
	    "!doc": "HTMLCollection is an interface representing a generic collection of elements (in document order) and offers methods and properties for traversing the list."
	  },
	  "NamedNodeMap": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "The number of items in the map."
	      },
	      "getNamedItem": {
	        "!type": "fn(name: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Gets a node by name."
	      },
	      "setNamedItem": {
	        "!type": "fn(node: +Node) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Adds (or replaces) a node by its nodeName."
	      },
	      "removeNamedItem": {
	        "!type": "fn(name: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Removes a node (or if an attribute, may reveal a default if present)."
	      },
	      "item": {
	        "!type": "fn(i: number) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Returns the item at the given index (or null if the index is higher or equal to the number of nodes)."
	      },
	      "getNamedItemNS": {
	        "!type": "fn(ns: string, name: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Gets a node by namespace and localName."
	      },
	      "setNamedItemNS": {
	        "!type": "fn(node: +Node) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Adds (or replaces) a node by its localName and namespaceURI."
	      },
	      "removeNamedItemNS": {
	        "!type": "fn(ns: string, name: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Removes a node (or if an attribute, may reveal a default if present)."
	      },
	      "<i>": "+Node"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	    "!doc": "A collection of nodes returned by Element.attributes (also potentially for DocumentType.entities, DocumentType.notations). NamedNodeMaps are not in any particular order (unlike NodeList), although they may be accessed by an index as in an array (they may also be accessed with the item() method). A NamedNodeMap object are live and will thus be auto-updated if changes are made to their contents internally or elsewhere."
	  },
	  "DocumentFragment": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Node.prototype"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment",
	    "!doc": "Creates a new empty DocumentFragment."
	  },
	  "DOMTokenList": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "The amount of items in the list."
	      },
	      "item": {
	        "!type": "fn(i: number) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Returns an item in the list by its index."
	      },
	      "contains": {
	        "!type": "fn(token: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Return true if the underlying string contains token, otherwise false."
	      },
	      "add": {
	        "!type": "fn(token: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Adds token to the underlying string."
	      },
	      "remove": {
	        "!type": "fn(token: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Remove token from the underlying string."
	      },
	      "toggle": {
	        "!type": "fn(token: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Removes token from string and returns false. If token doesn't exist it's added and the function returns true."
	      },
	      "<i>": "string"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	    "!doc": "This type represents a set of space-separated tokens. Commonly returned by HTMLElement.classList, HTMLLinkElement.relList, HTMLAnchorElement.relList or HTMLAreaElement.relList. It is indexed beginning with 0 as with JavaScript arrays. DOMTokenList is always case-sensitive."
	  },
	  "XPathResult": {
	    "!type": "fn()",
	    "prototype": {
	      "boolValue": "bool",
	      "invalidIteratorState": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
	        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
	      },
	      "numberValue": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/XPathResult",
	        "!doc": "Refer to nsIDOMXPathResult for more detail."
	      },
	      "resultType": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.evaluate",
	        "!doc": "Returns an XPathResult based on an XPath expression and other given parameters."
	      },
	      "singleNodeValue": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
	        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
	      },
	      "snapshotLength": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/XPathResult",
	        "!doc": "Refer to nsIDOMXPathResult for more detail."
	      },
	      "stringValue": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
	        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
	      },
	      "iterateNext": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
	        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
	      },
	      "snapshotItem": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en-US/docs/XPathResult#snapshotItem()"
	      },
	      "ANY_TYPE": "number",
	      "NUMBER_TYPE": "number",
	      "STRING_TYPE": "number",
	      "BOOL_TYPE": "number",
	      "UNORDERED_NODE_ITERATOR_TYPE": "number",
	      "ORDERED_NODE_ITERATOR_TYPE": "number",
	      "UNORDERED_NODE_SNAPSHOT_TYPE": "number",
	      "ORDERED_NODE_SNAPSHOT_TYPE": "number",
	      "ANY_UNORDERED_NODE_TYPE": "number",
	      "FIRST_ORDERED_NODE_TYPE": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/XPathResult",
	    "!doc": "Refer to nsIDOMXPathResult for more detail."
	  },
	  "ClientRect": {
	    "!type": "fn()",
	    "prototype": {
	      "top": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Top of the box, in pixels, relative to the viewport."
	      },
	      "left": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Left of the box, in pixels, relative to the viewport."
	      },
	      "bottom": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Bottom of the box, in pixels, relative to the viewport."
	      },
	      "right": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Right of the box, in pixels, relative to the viewport."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	    "!doc": "Returns a collection of rectangles that indicate the bounding rectangles for each box in a client."
	  },
	  "Event": {
	    "!type": "fn()",
	    "prototype": {
	      "stopPropagation": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.stopPropagation",
	        "!doc": "Prevents further propagation of the current event."
	      },
	      "preventDefault": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.preventDefault",
	        "!doc": "Cancels the event if it is cancelable, without stopping further propagation of the event."
	      },
	      "initEvent": {
	        "!type": "fn(type: string, bubbles: bool, cancelable: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.initEvent",
	        "!doc": "The initEvent method is used to initialize the value of an event created using document.createEvent."
	      },
	      "stopImmediatePropagation": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.stopImmediatePropagation",
	        "!doc": "Prevents other listeners of the same event to be called."
	      },
	      "NONE": "number",
	      "CAPTURING_PHASE": "number",
	      "AT_TARGET": "number",
	      "BUBBLING_PHASE": "number",
	      "MOUSEDOWN": "number",
	      "MOUSEUP": "number",
	      "MOUSEOVER": "number",
	      "MOUSEOUT": "number",
	      "MOUSEMOVE": "number",
	      "MOUSEDRAG": "number",
	      "CLICK": "number",
	      "DBLCLICK": "number",
	      "KEYDOWN": "number",
	      "KEYUP": "number",
	      "KEYPRESS": "number",
	      "DRAGDROP": "number",
	      "FOCUS": "number",
	      "BLUR": "number",
	      "SELECT": "number",
	      "CHANGE": "number",
	      "target": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget",
	        "!doc": "An EventTarget is a DOM interface implemented by objects that can receive DOM events and have listeners for them. The most common EventTargets are DOM elements, although other objects can be EventTargets too, for example document, window, XMLHttpRequest, and others."
	      },
	      "relatedTarget": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.relatedTarget",
	        "!doc": "Identifies a secondary target for the event."
	      },
	      "pageX": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.pageX",
	        "!doc": "Returns the horizontal coordinate of the event relative to whole document."
	      },
	      "pageY": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.pageY",
	        "!doc": "Returns the vertical coordinate of the event relative to the whole document."
	      },
	      "clientX": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.clientX",
	        "!doc": "Returns the horizontal coordinate within the application's client area at which the event occurred (as opposed to the coordinates within the page). For example, clicking in the top-left corner of the client area will always result in a mouse event with a clientX value of 0, regardless of whether the page is scrolled horizontally."
	      },
	      "clientY": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.clientY",
	        "!doc": "Returns the vertical coordinate within the application's client area at which the event occurred (as opposed to the coordinates within the page). For example, clicking in the top-left corner of the client area will always result in a mouse event with a clientY value of 0, regardless of whether the page is scrolled vertically."
	      },
	      "keyCode": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.keyCode",
	        "!doc": "Returns the Unicode value of a non-character key in a keypress event or any key in any other type of keyboard event."
	      },
	      "charCode": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.charCode",
	        "!doc": "Returns the Unicode value of a character key pressed during a keypress event."
	      },
	      "which": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.which",
	        "!doc": "Returns the numeric keyCode of the key pressed, or the character code (charCode) for an alphanumeric key pressed."
	      },
	      "button": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.button",
	        "!doc": "Indicates which mouse button caused the event."
	      },
	      "shiftKey": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.shiftKey",
	        "!doc": "Indicates whether the SHIFT key was pressed when the event fired."
	      },
	      "ctrlKey": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.ctrlKey",
	        "!doc": "Indicates whether the CTRL key was pressed when the event fired."
	      },
	      "altKey": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.altKey",
	        "!doc": "Indicates whether the ALT key was pressed when the event fired."
	      },
	      "metaKey": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.metaKey",
	        "!doc": "Indicates whether the META key was pressed when the event fired."
	      },
	      "returnValue": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/window.onbeforeunload",
	        "!doc": "An event that fires when a window is about to unload its resources. The document is still visible and the event is still cancelable."
	      },
	      "cancelBubble": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.cancelBubble",
	        "!doc": "bool is the boolean value of true or false."
	      },
	      "dataTransfer": {
	        "dropEffect": {
	          "!type": "string",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
	          "!doc": "The actual effect that will be used, and should always be one of the possible values of effectAllowed."
	        },
	        "effectAllowed": {
	          "!type": "string",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Specifies the effects that are allowed for this drag."
	        },
	        "files": {
	          "!type": "+FileList",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
	          "!doc": "Contains a list of all the local files available on the data transfer."
	        },
	        "types": {
	          "!type": "[string]",
	          "!url": "https://developer.mozilla.org/en-US/docs/DragDrop/DataTransfer",
	          "!doc": "Holds a list of the format types of the data that is stored for the first item, in the same order the data was added. An empty list will be returned if no data was added."
	        },
	        "addElement": {
	          "!type": "fn(element: +Element)",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
	          "!doc": "Set the drag source."
	        },
	        "clearData": {
	          "!type": "fn(type?: string)",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Remove the data associated with a given type."
	        },
	        "getData": {
	          "!type": "fn(type: string) -> string",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Retrieves the data for a given type, or an empty string if data for that type does not exist or the data transfer contains no data."
	        },
	        "setData": {
	          "!type": "fn(type: string, data: string)",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Set the data for a given type."
	        },
	        "setDragImage": {
	          "!type": "fn(image: +Element)",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Set the image to be used for dragging if a custom one is desired."
	        },
	        "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
	        "!doc": "This object is available from the dataTransfer property of all drag events. It cannot be created separately."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/event",
	    "!doc": "The DOM Event interface is accessible from within the handler function, via the event object passed as the first argument."
	  },
	  "TouchEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Touch_events",
	    "!doc": "In order to provide quality support for touch-based user interfaces, touch events offer the ability to interpret finger activity on touch screens or trackpads."
	  },
	  "WheelEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/WheelEvent",
	    "!doc": "The DOM WheelEvent represents events that occur due to the user moving a mouse wheel or similar input device."
	  },
	  "MouseEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/MouseEvent",
	    "!doc": "The DOM MouseEvent represents events that occur due to the user interacting with a pointing device (such as a mouse). It's represented by the nsINSDOMMouseEvent interface, which extends the nsIDOMMouseEvent interface."
	  },
	  "KeyboardEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/KeyboardEvent",
	    "!doc": "KeyboardEvent objects describe a user interaction with the keyboard. Each event describes a key; the event type (keydown, keypress, or keyup) identifies what kind of activity was performed."
	  },
	  "HashChangeEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onhashchange",
	    "!doc": "The hashchange event fires when a window's hash changes."
	  },
	  "ErrorEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/error",
	    "!doc": "The error event is fired whenever a resource fails to load."
	  },
	  "CustomEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Event/CustomEvent",
	    "!doc": "The DOM CustomEvent are events initialized by an application for any purpose."
	  },
	  "BeforeLoadEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window",
	    "!doc": "This section provides a brief reference for all of the methods, properties, and events available through the DOM window object. The window object implements the Window interface, which in turn inherits from the AbstractView interface. Some additional global functions, namespaces objects, and constructors, not typically associated with the window, but available on it, are listed in the JavaScript Reference."
	  },
	  "WebSocket": {
	    "!type": "fn(url: string)",
	    "prototype": {
	      "close": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/CloseEvent",
	        "!doc": "A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute."
	      },
	      "send": {
	        "!type": "fn(data: string)",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "binaryType": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "bufferedAmount": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications",
	        "!doc": "WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."
	      },
	      "extensions": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "onclose": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/CloseEvent",
	        "!doc": "A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute."
	      },
	      "onerror": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications",
	        "!doc": "WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."
	      },
	      "onmessage": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "onopen": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "protocol": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets",
	        "!doc": "WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply."
	      },
	      "url": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications",
	        "!doc": "WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."
	      },
	      "CONNECTING": "number",
	      "OPEN": "number",
	      "CLOSING": "number",
	      "CLOSED": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/WebSockets",
	    "!doc": "WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply."
	  },
	  "Worker": {
	    "!type": "fn(scriptURL: string)",
	    "prototype": {
	      "postMessage": {
	        "!type": "fn(message: ?)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	        "!doc": "Sends a message to the worker's inner scope. This accepts a single parameter, which is the data to send to the worker. The data may be any value or JavaScript object handled by the structured clone algorithm, which includes cyclical references."
	      },
	      "terminate": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	        "!doc": "Immediately terminates the worker. This does not offer the worker an opportunity to finish its operations; it is simply stopped at once."
	      },
	      "onmessage": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	        "!doc": "An event listener that is called whenever a MessageEvent with type message bubbles through the worker. The message is stored in the event's data member."
	      },
	      "onerror": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	        "!doc": "An event listener that is called whenever an ErrorEvent with type error bubbles through the worker."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	    "!doc": "Workers are background tasks that can be easily created and can send messages back to their creators. Creating a worker is as simple as calling the Worker() constructor, specifying a script to be run in the worker thread."
	  },
	  "localStorage": {
	    "setItem": {
	      "!type": "fn(name: string, value: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	      "!doc": "Store an item in storage."
	    },
	    "getItem": {
	      "!type": "fn(name: string) -> string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	      "!doc": "Retrieve an item from storage."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	    "!doc": "The DOM Storage mechanism is a means through which string key/value pairs can be securely stored and later retrieved for use."
	  },
	  "sessionStorage": {
	    "setItem": {
	      "!type": "fn(name: string, value: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	      "!doc": "Store an item in storage."
	    },
	    "getItem": {
	      "!type": "fn(name: string) -> string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	      "!doc": "Retrieve an item from storage."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	    "!doc": "This is a global object (sessionStorage) that maintains a storage area that's available for the duration of the page session. A page session lasts for as long as the browser is open and survives over page reloads and restores. Opening a page in a new tab or window will cause a new session to be initiated."
	  },
	  "FileList": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileList",
	        "!doc": "A read-only value indicating the number of files in the list."
	      },
	      "item": {
	        "!type": "fn(i: number) -> +File",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileList",
	        "!doc": "Returns a File object representing the file at the specified index in the file list."
	      },
	      "<i>": "+File"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/FileList",
	    "!doc": "An object of this type is returned by the files property of the HTML input element; this lets you access the list of files selected with the <input type=\"file\"> element. It's also used for a list of files dropped into web content when using the drag and drop API."
	  },
	  "File": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Blob.prototype",
	      "fileName": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/File.fileName",
	        "!doc": "Returns the name of the file. For security reasons the path is excluded from this property."
	      },
	      "fileSize": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/File.fileSize",
	        "!doc": "Returns the size of a file in bytes."
	      },
	      "lastModifiedDate": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/File.lastModifiedDate",
	        "!doc": "Returns the last modified date of the file. Files without a known last modified date use the current date instead."
	      },
	      "name": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/File.name",
	        "!doc": "Returns the name of the file. For security reasons, the path is excluded from this property."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/File",
	    "!doc": "The File object provides information about -- and access to the contents of -- files. These are generally retrieved from a FileList object returned as a result of a user selecting files using the input element, or from a drag and drop operation's DataTransfer object."
	  },
	  "Blob": {
	    "!type": "fn(parts: [?], properties?: ?)",
	    "prototype": {
	      "size": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
	        "!doc": "The size, in bytes, of the data contained in the Blob object. Read only."
	      },
	      "type": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
	        "!doc": "An ASCII-encoded string, in all lower case, indicating the MIME type of the data contained in the Blob. If the type is unknown, this string is empty. Read only."
	      },
	      "slice": {
	        "!type": "fn(start: number, end?: number, type?: string) -> +Blob",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
	        "!doc": "Returns a new Blob object containing the data in the specified range of bytes of the source Blob."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
	    "!doc": "A Blob object represents a file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system."
	  },
	  "FileReader": {
	    "!type": "fn()",
	    "prototype": {
	      "abort": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Aborts the read operation. Upon return, the readyState will be DONE."
	      },
	      "readAsArrayBuffer": {
	        "!type": "fn(blob: +Blob)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Starts reading the contents of the specified Blob, producing an ArrayBuffer."
	      },
	      "readAsBinaryString": {
	        "!type": "fn(blob: +Blob)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Starts reading the contents of the specified Blob, producing raw binary data."
	      },
	      "readAsDataURL": {
	        "!type": "fn(blob: +Blob)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Starts reading the contents of the specified Blob, producing a data: url."
	      },
	      "readAsText": {
	        "!type": "fn(blob: +Blob, encoding?: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Starts reading the contents of the specified Blob, producing a string."
	      },
	      "EMPTY": "number",
	      "LOADING": "number",
	      "DONE": "number",
	      "error": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "The error that occurred while reading the file. Read only."
	      },
	      "readyState": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Indicates the state of the FileReader. This will be one of the State constants. Read only."
	      },
	      "result": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "The file's contents. This property is only valid after the read operation is complete, and the format of the data depends on which of the methods was used to initiate the read operation. Read only."
	      },
	      "onabort": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when the read operation is aborted."
	      },
	      "onerror": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when an error occurs."
	      },
	      "onload": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when the read operation is successfully completed."
	      },
	      "onloadend": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when the read is completed, whether successful or not. This is called after either onload or onerror."
	      },
	      "onloadstart": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when reading the data is about to begin."
	      },
	      "onprogress": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called periodically while the data is being read."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	    "!doc": "The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. File objects may be obtained from a FileList object returned as a result of a user selecting files using the <input> element, from a drag and drop operation's DataTransfer object, or from the mozGetAsFile() API on an HTMLCanvasElement."
	  },
	  "Range": {
	    "!type": "fn()",
	    "prototype": {
	      "collapsed": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.collapsed",
	        "!doc": "Returns a boolean indicating whether the range's start and end points are at the same position."
	      },
	      "commonAncestorContainer": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.commonAncestorContainer",
	        "!doc": "Returns the deepest Node that contains the  startContainer and  endContainer Nodes."
	      },
	      "endContainer": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.endContainer",
	        "!doc": "Returns the Node within which the Range ends."
	      },
	      "endOffset": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.endOffset",
	        "!doc": "Returns a number representing where in the  endContainer the Range ends."
	      },
	      "startContainer": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.startContainer",
	        "!doc": "Returns the Node within which the Range starts."
	      },
	      "startOffset": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.startOffset",
	        "!doc": "Returns a number representing where in the startContainer the Range starts."
	      },
	      "setStart": {
	        "!type": "fn(node: +Element, offset: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setStart",
	        "!doc": "Sets the start position of a Range."
	      },
	      "setEnd": {
	        "!type": "fn(node: +Element, offset: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setEnd",
	        "!doc": "Sets the end position of a Range."
	      },
	      "setStartBefore": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setStartBefore",
	        "!doc": "Sets the start position of a Range relative to another Node."
	      },
	      "setStartAfter": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setStartAfter",
	        "!doc": "Sets the start position of a Range relative to a Node."
	      },
	      "setEndBefore": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setEndBefore",
	        "!doc": "Sets the end position of a Range relative to another Node."
	      },
	      "setEndAfter": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setEndAfter",
	        "!doc": "Sets the end position of a Range relative to another Node."
	      },
	      "selectNode": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.selectNode",
	        "!doc": "Sets the Range to contain the Node and its contents."
	      },
	      "selectNodeContents": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.selectNodeContents",
	        "!doc": "Sets the Range to contain the contents of a Node."
	      },
	      "collapse": {
	        "!type": "fn(toStart: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.collapse",
	        "!doc": "Collapses the Range to one of its boundary points."
	      },
	      "cloneContents": {
	        "!type": "fn() -> +DocumentFragment",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.cloneContents",
	        "!doc": "Returns a DocumentFragment copying the Nodes of a Range."
	      },
	      "deleteContents": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.deleteContents",
	        "!doc": "Removes the contents of a Range from the Document."
	      },
	      "extractContents": {
	        "!type": "fn() -> +DocumentFragment",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.extractContents",
	        "!doc": "Moves contents of a Range from the document tree into a DocumentFragment."
	      },
	      "insertNode": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.insertNode",
	        "!doc": "Insert a node at the start of a Range."
	      },
	      "surroundContents": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.surroundContents",
	        "!doc": "Moves content of a Range into a new node, placing the new node at the start of the specified range."
	      },
	      "compareBoundaryPoints": {
	        "!type": "fn(how: number, other: +Range) -> number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.compareBoundaryPoints",
	        "!doc": "Compares the boundary points of two Ranges."
	      },
	      "cloneRange": {
	        "!type": "fn() -> +Range",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.cloneRange",
	        "!doc": "Returns a Range object with boundary points identical to the cloned Range."
	      },
	      "detach": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.detach",
	        "!doc": "Releases a Range from use to improve performance. This lets the browser choose to release resources associated with this Range. Subsequent attempts to use the detached range will result in a DOMException being thrown with an error code of INVALID_STATE_ERR."
	      },
	      "END_TO_END": "number",
	      "END_TO_START": "number",
	      "START_TO_END": "number",
	      "START_TO_START": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/range.detach",
	    "!doc": "Releases a Range from use to improve performance. This lets the browser choose to release resources associated with this Range. Subsequent attempts to use the detached range will result in a DOMException being thrown with an error code of INVALID_STATE_ERR."
	  },
	  "XMLHttpRequest": {
	    "!type": "fn()",
	    "prototype": {
	      "abort": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Aborts the request if it has already been sent."
	      },
	      "getAllResponseHeaders": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Returns all the response headers as a string, or null if no response has been received. Note: For multipart requests, this returns the headers from the current part of the request, not from the original channel."
	      },
	      "getResponseHeader": {
	        "!type": "fn(header: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Returns the string containing the text of the specified header, or null if either the response has not yet been received or the header doesn't exist in the response."
	      },
	      "open": {
	        "!type": "fn(method: string, url: string, async?: bool, user?: string, password?: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Initializes a request."
	      },
	      "overrideMimeType": {
	        "!type": "fn(type: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Overrides the MIME type returned by the server."
	      },
	      "send": {
	        "!type": "fn(data?: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent. If the request is synchronous, this method doesn't return until the response has arrived."
	      },
	      "setRequestHeader": {
	        "!type": "fn(header: string, value: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Sets the value of an HTTP request header.You must call setRequestHeader() after open(), but before send()."
	      },
	      "onreadystatechange": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "A JavaScript function object that is called whenever the readyState attribute changes."
	      },
	      "readyState": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The state of the request. (0=unsent, 1=opened, 2=headers_received, 3=loading, 4=done)"
	      },
	      "response": {
	        "!type": "+Document",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The response entity body according to responseType, as an ArrayBuffer, Blob, Document, JavaScript object (for \"json\"), or string. This is null if the request is not complete or was not successful."
	      },
	      "responseText": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The response to the request as text, or null if the request was unsuccessful or has not yet been sent."
	      },
	      "responseType": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Can be set to change the response type."
	      },
	      "responseXML": {
	        "!type": "+Document",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The response to the request as a DOM Document object, or null if the request was unsuccessful, has not yet been sent, or cannot be parsed as XML or HTML."
	      },
	      "status": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The status of the response to the request. This is the HTTP result code"
	      },
	      "statusText": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The response string returned by the HTTP server. Unlike status, this includes the entire text of the response message (\"200 OK\", for example)."
	      },
	      "timeout": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest/Synchronous_and_Asynchronous_Requests",
	        "!doc": "The number of milliseconds a request can take before automatically being terminated. A value of 0 (which is the default) means there is no timeout."
	      },
	      "UNSENT": "number",
	      "OPENED": "number",
	      "HEADERS_RECEIVED": "number",
	      "LOADING": "number",
	      "DONE": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	    "!doc": "XMLHttpRequest is a JavaScript object that was designed by Microsoft and adopted by Mozilla, Apple, and Google. It's now being standardized in the W3C. It provides an easy way to retrieve data at a URL. Despite its name, XMLHttpRequest can be used to retrieve any type of data, not just XML, and it supports protocols other than HTTP (including file and ftp)."
	  },
	  "DOMParser": {
	    "!type": "fn()",
	    "prototype": {
	      "parseFromString": {
	        "!type": "fn(data: string, mime: string) -> +Document",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMParser",
	        "!doc": "DOMParser can parse XML or HTML source stored in a string into a DOM Document. DOMParser is specified in DOM Parsing and Serialization."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOMParser",
	    "!doc": "DOMParser can parse XML or HTML source stored in a string into a DOM Document. DOMParser is specified in DOM Parsing and Serialization."
	  },
	  "Selection": {
	    "!type": "fn()",
	    "prototype": {
	      "anchorNode": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/anchorNode",
	        "!doc": "Returns the node in which the selection begins."
	      },
	      "anchorOffset": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/anchorOffset",
	        "!doc": "Returns the number of characters that the selection's anchor is offset within the anchorNode."
	      },
	      "focusNode": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/focusNode",
	        "!doc": "Returns the node in which the selection ends."
	      },
	      "focusOffset": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/focusOffset",
	        "!doc": "Returns the number of characters that the selection's focus is offset within the focusNode. "
	      },
	      "isCollapsed": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/isCollapsed",
	        "!doc": "Returns a boolean indicating whether the selection's start and end points are at the same position."
	      },
	      "rangeCount": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/rangeCount",
	        "!doc": "Returns the number of ranges in the selection."
	      },
	      "getRangeAt": {
	        "!type": "fn(i: number) -> +Range",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/getRangeAt",
	        "!doc": "Returns a range object representing one of the ranges currently selected."
	      },
	      "collapse": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/collapse",
	        "!doc": "Collapses the current selection to a single point. The document is not modified. If the content is focused and editable, the caret will blink there."
	      },
	      "extend": {
	        "!type": "fn(node: +Element, offset: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/extend",
	        "!doc": "Moves the focus of the selection to a specified point. The anchor of the selection does not move. The selection will be from the anchor to the new focus regardless of direction."
	      },
	      "collapseToStart": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/collapseToStart",
	        "!doc": "Collapses the selection to the start of the first range in the selection.  If the content of the selection is focused and editable, the caret will blink there."
	      },
	      "collapseToEnd": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/collapseToEnd",
	        "!doc": "Collapses the selection to the end of the last range in the selection.  If the content the selection is in is focused and editable, the caret will blink there."
	      },
	      "selectAllChildren": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/selectAllChildren",
	        "!doc": "Adds all the children of the specified node to the selection. Previous selection is lost."
	      },
	      "addRange": {
	        "!type": "fn(range: +Range)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/addRange",
	        "!doc": "Adds a Range to a Selection."
	      },
	      "removeRange": {
	        "!type": "fn(range: +Range)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/removeRange",
	        "!doc": "Removes a range from the selection."
	      },
	      "removeAllRanges": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/removeAllRanges",
	        "!doc": "Removes all ranges from the selection, leaving the anchorNode and focusNode properties equal to null and leaving nothing selected. "
	      },
	      "deleteFromDocument": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/deleteFromDocument",
	        "!doc": "Deletes the actual text being represented by a selection object from the document's DOM."
	      },
	      "containsNode": {
	        "!type": "fn(node: +Element) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/containsNode",
	        "!doc": "Indicates if the node is part of the selection."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Selection",
	    "!doc": "Selection is the class of the object returned by window.getSelection() and other methods. It represents the text selection in the greater page, possibly spanning multiple elements, when the user drags over static text and other parts of the page. For information about text selection in an individual text editing element."
	  },
	  "console": {
	    "error": {
	      "!type": "fn(text: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/console.error",
	      "!doc": "Outputs an error message to the Web Console."
	    },
	    "info": {
	      "!type": "fn(text: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/console.info",
	      "!doc": "Outputs an informational message to the Web Console."
	    },
	    "log": {
	      "!type": "fn(text: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/console.log",
	      "!doc": "Outputs a message to the Web Console."
	    },
	    "warn": {
	      "!type": "fn(text: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/console.warn",
	      "!doc": "Outputs a warning message to the Web Console."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/console",
	    "!doc": "The console object provides access to the browser's debugging console. The specifics of how it works vary from browser to browser, but there is a de facto set of features that are typically provided."
	  },
	  "top": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.top",
	    "!doc": "Returns a reference to the topmost window in the window hierarchy."
	  },
	  "parent": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.parent",
	    "!doc": "A reference to the parent of the current window or subframe."
	  },
	  "window": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window",
	    "!doc": "This section provides a brief reference for all of the methods, properties, and events available through the DOM window object. The window object implements the Window interface, which in turn inherits from the AbstractView interface. Some additional global functions, namespaces objects, and constructors, not typically associated with the window, but available on it, are listed in the JavaScript Reference."
	  },
	  "opener": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.opener",
	    "!doc": "Returns a reference to the window that opened this current window."
	  },
	  "self": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.self",
	    "!doc": "Returns an object reference to the window object. "
	  },
	  "devicePixelRatio": "number",
	  "name": {
	    "!type": "string",
	    "!url": "https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/Function/name",
	    "!doc": "The name of the function."
	  },
	  "closed": {
	    "!type": "bool",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.closed",
	    "!doc": "This property indicates whether the referenced window is closed or not."
	  },
	  "pageYOffset": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollY",
	    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
	  },
	  "pageXOffset": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollX",
	    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
	  },
	  "scrollY": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollY",
	    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
	  },
	  "scrollX": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollX",
	    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
	  },
	  "screenTop": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.top",
	    "!doc": "Returns the distance in pixels from the top side of the current screen."
	  },
	  "screenLeft": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.left",
	    "!doc": "Returns the distance in pixels from the left side of the main screen to the left side of the current screen."
	  },
	  "screenY": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/event.screenY",
	    "!doc": "Returns the vertical coordinate of the event within the screen as a whole."
	  },
	  "screenX": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/event.screenX",
	    "!doc": "Returns the horizontal coordinate of the event within the screen as a whole."
	  },
	  "innerWidth": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.innerWidth",
	    "!doc": "Width (in pixels) of the browser window viewport including, if rendered, the vertical scrollbar."
	  },
	  "innerHeight": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.innerHeight",
	    "!doc": "Height (in pixels) of the browser window viewport including, if rendered, the horizontal scrollbar."
	  },
	  "outerWidth": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.outerWidth",
	    "!doc": "window.outerWidth gets the width of the outside of the browser window. It represents the width of the whole browser window including sidebar (if expanded), window chrome and window resizing borders/handles."
	  },
	  "outerHeight": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.outerHeight",
	    "!doc": "window.outerHeight gets the height in pixels of the whole browser window."
	  },
	  "frameElement": {
	    "!type": "+Element",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.frameElement",
	    "!doc": "Returns the element (such as <iframe> or <object>) in which the window is embedded, or null if the window is top-level."
	  },
	  "crypto": {
	    "getRandomValues": {
	      "!type": "fn([number])",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.crypto.getRandomValues",
	      "!doc": "This methods lets you get cryptographically random values."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.crypto.getRandomValues",
	    "!doc": "This methods lets you get cryptographically random values."
	  },
	  "navigator": {
	    "appName": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.appName",
	      "!doc": "Returns the name of the browser. The HTML5 specification also allows any browser to return \"Netscape\" here, for compatibility reasons."
	    },
	    "appVersion": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.appVersion",
	      "!doc": "Returns the version of the browser as a string. It may be either a plain version number, like \"5.0\", or a version number followed by more detailed information. The HTML5 specification also allows any browser to return \"4.0\" here, for compatibility reasons."
	    },
	    "language": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.language",
	      "!doc": "Returns a string representing the language version of the browser."
	    },
	    "platform": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.platform",
	      "!doc": "Returns a string representing the platform of the browser."
	    },
	    "plugins": {
	      "!type": "[?]",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.plugins",
	      "!doc": "Returns a PluginArray object, listing the plugins installed in the application."
	    },
	    "userAgent": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.userAgent",
	      "!doc": "Returns the user agent string for the current browser."
	    },
	    "vendor": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.vendor",
	      "!doc": "Returns the name of the browser vendor for the current browser."
	    },
	    "javaEnabled": {
	      "!type": "bool",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.javaEnabled",
	      "!doc": "This method indicates whether the current browser is Java-enabled or not."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator",
	    "!doc": "Returns a reference to the navigator object, which can be queried for information about the application running the script."
	  },
	  "history": {
	    "state": {
	      "!type": "?",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "length": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "go": {
	      "!type": "fn(delta: number)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.history",
	      "!doc": "Returns a reference to the History object, which provides an interface for manipulating the browser session history (pages visited in the tab or frame that the current page is loaded in)."
	    },
	    "forward": {
	      "!type": "fn()",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "back": {
	      "!type": "fn()",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "pushState": {
	      "!type": "fn(data: ?, title: string, url?: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "replaceState": {
	      "!type": "fn(data: ?, title: string, url?: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	    "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	  },
	  "screen": {
	    "availWidth": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availWidth",
	      "!doc": "Returns the amount of horizontal space in pixels available to the window."
	    },
	    "availHeight": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availHeight",
	      "!doc": "Returns the amount of vertical space available to the window on the screen."
	    },
	    "availTop": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availTop",
	      "!doc": "Specifies the y-coordinate of the first pixel that is not allocated to permanent or semipermanent user interface features."
	    },
	    "availLeft": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availLeft",
	      "!doc": "Returns the first available pixel available from the left side of the screen."
	    },
	    "pixelDepth": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.pixelDepth",
	      "!doc": "Returns the bit depth of the screen."
	    },
	    "colorDepth": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.colorDepth",
	      "!doc": "Returns the color depth of the screen."
	    },
	    "width": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.width",
	      "!doc": "Returns the width of the screen."
	    },
	    "height": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.height",
	      "!doc": "Returns the height of the screen in pixels."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen",
	    "!doc": "Returns a reference to the screen object associated with the window."
	  },
	  "postMessage": {
	    "!type": "fn(message: string, targetOrigin: string)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.postMessage",
	    "!doc": "window.postMessage, when called, causes a MessageEvent to be dispatched at the target window when any pending script that must be executed completes (e.g. remaining event handlers if window.postMessage is called from an event handler, previously-set pending timeouts, etc.). The MessageEvent has the type message, a data property which is set to the value of the first argument provided to window.postMessage, an origin property corresponding to the origin of the main document in the window calling window.postMessage at the time window.postMessage was called, and a source property which is the window from which window.postMessage is called. (Other standard properties of events are present with their expected values.)"
	  },
	  "close": {
	    "!type": "fn()",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.close",
	    "!doc": "Closes the current window, or a referenced window."
	  },
	  "blur": {
	    "!type": "fn()",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.blur",
	    "!doc": "The blur method removes keyboard focus from the current element."
	  },
	  "focus": {
	    "!type": "fn()",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.focus",
	    "!doc": "Sets focus on the specified element, if it can be focused."
	  },
	  "onload": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onload",
	    "!doc": "An event handler for the load event of a window."
	  },
	  "onunload": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onunload",
	    "!doc": "The unload event is raised when the window is unloading its content and resources. The resources removal is processed after the unload event occurs."
	  },
	  "onscroll": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onscroll",
	    "!doc": "Specifies the function to be called when the window is scrolled."
	  },
	  "onresize": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onresize",
	    "!doc": "An event handler for the resize event on the window."
	  },
	  "ononline": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/document.ononline",
	    "!doc": ",fgh s dgkljgsdfl dfjg sdlgj sdlg sdlfj dlg jkdfkj dfjgdfkglsdfjsdlfkgj hdflkg hdlkfjgh dfkjgh"
	  },
	  "onoffline": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/Online_and_offline_events",
	    "!doc": "Some browsers implement Online/Offline events from the WHATWG Web Applications 1.0 specification."
	  },
	  "onmousewheel": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/mousewheel",
	    "!doc": "The DOM mousewheel event is fired asynchronously when mouse wheel or similar device is operated. It's represented by the MouseWheelEvent interface."
	  },
	  "onmouseup": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onmouseup",
	    "!doc": "An event handler for the mouseup event on the window."
	  },
	  "onmouseover": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseover",
	    "!doc": "The onmouseover property returns the onMouseOver event handler code on the current element."
	  },
	  "onmouseout": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseout",
	    "!doc": "The onmouseout property returns the onMouseOut event handler code on the current element."
	  },
	  "onmousemove": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmousemove",
	    "!doc": "The onmousemove property returns the mousemove event handler code on the current element."
	  },
	  "onmousedown": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onmousedown",
	    "!doc": "An event handler for the mousedown event on the window."
	  },
	  "onclick": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onclick",
	    "!doc": "The onclick property returns the onClick event handler code on the current element."
	  },
	  "ondblclick": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.ondblclick",
	    "!doc": "The ondblclick property returns the onDblClick event handler code on the current element."
	  },
	  "onmessage": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	    "!doc": "Dedicated Web Workers provide a simple means for web content to run scripts in background threads.  Once created, a worker can send messages to the spawning task by posting messages to an event handler specified by the creator."
	  },
	  "onkeyup": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeyup",
	    "!doc": "The onkeyup property returns the onKeyUp event handler code for the current element."
	  },
	  "onkeypress": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeypress",
	    "!doc": "The onkeypress property sets and returns the onKeyPress event handler code for the current element."
	  },
	  "onkeydown": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onkeydown",
	    "!doc": "An event handler for the keydown event on the window."
	  },
	  "oninput": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/input",
	    "!doc": "The DOM input event is fired synchronously when the value of an <input> or <textarea> element is changed. Additionally, it's also fired on contenteditable editors when its contents are changed. In this case, the event target is the editing host element. If there are two or more elements which have contenteditable as true, \"editing host\" is the nearest ancestor element whose parent isn't editable. Similarly, it's also fired on root element of designMode editors."
	  },
	  "onpopstate": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onpopstate",
	    "!doc": "An event handler for the popstate event on the window."
	  },
	  "onhashchange": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onhashchange",
	    "!doc": "The hashchange event fires when a window's hash changes."
	  },
	  "onfocus": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onfocus",
	    "!doc": "The onfocus property returns the onFocus event handler code on the current element."
	  },
	  "onblur": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onblur",
	    "!doc": "The onblur property returns the onBlur event handler code, if any, that exists on the current element."
	  },
	  "onerror": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onerror",
	    "!doc": "An event handler for runtime script errors."
	  },
	  "ondrop": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/drop",
	    "!doc": "The drop event is fired when an element or text selection is dropped on a valid drop target."
	  },
	  "ondragstart": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragstart",
	    "!doc": "The dragstart event is fired when the user starts dragging an element or text selection."
	  },
	  "ondragover": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragover",
	    "!doc": "The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds)."
	  },
	  "ondragleave": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragleave",
	    "!doc": "The dragleave event is fired when a dragged element or text selection leaves a valid drop target."
	  },
	  "ondragenter": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragenter",
	    "!doc": "The dragenter event is fired when a dragged element or text selection enters a valid drop target."
	  },
	  "ondragend": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragend",
	    "!doc": "The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key)."
	  },
	  "ondrag": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/drag",
	    "!doc": "The drag event is fired when an element or text selection is being dragged (every few hundred milliseconds)."
	  },
	  "oncontextmenu": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.oncontextmenu",
	    "!doc": "An event handler property for right-click events on the window. Unless the default behavior is prevented, the browser context menu will activate (though IE8 has a bug with this and will not activate the context menu if a contextmenu event handler is defined). Note that this event will occur with any non-disabled right-click event and does not depend on an element possessing the \"contextmenu\" attribute."
	  },
	  "onchange": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onchange",
	    "!doc": "The onchange property sets and returns the onChange event handler code for the current element."
	  },
	  "onbeforeunload": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onbeforeunload",
	    "!doc": "An event that fires when a window is about to unload its resources. The document is still visible and the event is still cancelable."
	  },
	  "onabort": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onabort",
	    "!doc": "An event handler for abort events sent to the window."
	  },
	  "getSelection": {
	    "!type": "fn() -> +Selection",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.getSelection",
	    "!doc": "Returns a selection object representing the range of text selected by the user. "
	  },
	  "alert": {
	    "!type": "fn(message: string)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.alert",
	    "!doc": "Display an alert dialog with the specified content and an OK button."
	  },
	  "confirm": {
	    "!type": "fn(message: string) -> bool",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.confirm",
	    "!doc": "Displays a modal dialog with a message and two buttons, OK and Cancel."
	  },
	  "prompt": {
	    "!type": "fn(message: string, value: string) -> string",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.prompt",
	    "!doc": "Displays a dialog with a message prompting the user to input some text."
	  },
	  "scrollBy": {
	    "!type": "fn(x: number, y: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollBy",
	    "!doc": "Scrolls the document in the window by the given amount."
	  },
	  "scrollTo": {
	    "!type": "fn(x: number, y: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollTo",
	    "!doc": "Scrolls to a particular set of coordinates in the document."
	  },
	  "scroll": {
	    "!type": "fn(x: number, y: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scroll",
	    "!doc": "Scrolls the window to a particular place in the document."
	  },
	  "setTimeout": {
	    "!type": "fn(f: fn(), ms: number) -> number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.setTimeout",
	    "!doc": "Calls a function or executes a code snippet after specified delay."
	  },
	  "clearTimeout": {
	    "!type": "fn(timeout: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.clearTimeout",
	    "!doc": "Clears the delay set by window.setTimeout()."
	  },
	  "setInterval": {
	    "!type": "fn(f: fn(), ms: number) -> number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.setInterval",
	    "!doc": "Calls a function or executes a code snippet repeatedly, with a fixed time delay between each call to that function."
	  },
	  "clearInterval": {
	    "!type": "fn(interval: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.clearInterval",
	    "!doc": "Cancels repeated action which was set up using setInterval."
	  },
	  "atob": {
	    "!type": "fn(encoded: string) -> string",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.atob",
	    "!doc": "Decodes a string of data which has been encoded using base-64 encoding."
	  },
	  "btoa": {
	    "!type": "fn(data: string) -> string",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.btoa",
	    "!doc": "Creates a base-64 encoded ASCII string from a string of binary data."
	  },
	  "addEventListener": {
	    "!type": "fn(type: string, listener: fn(e: +Event), capture: bool)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.addEventListener",
	    "!doc": "Registers a single event listener on a single target. The event target may be a single element in a document, the document itself, a window, or an XMLHttpRequest."
	  },
	  "removeEventListener": {
	    "!type": "fn(type: string, listener: fn(), capture: bool)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.removeEventListener",
	    "!doc": "Allows the removal of event listeners from the event target."
	  },
	  "dispatchEvent": {
	    "!type": "fn(event: +Event) -> bool",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.dispatchEvent",
	    "!doc": "Dispatches an event into the event system. The event is subject to the same capturing and bubbling behavior as directly dispatched events."
	  },
	  "getComputedStyle": {
	    "!type": "fn(node: +Element, pseudo?: string) -> Element.prototype.style",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.getComputedStyle",
	    "!doc": "Gives the final used values of all the CSS properties of an element."
	  },
	  "CanvasRenderingContext2D": {
	    "canvas": "+Element",
	    "width": "number",
	    "height": "number",
	    "commit": "fn()",
	    "save": "fn()",
	    "restore": "fn()",
	    "currentTransform": "?",
	    "scale": "fn(x: number, y: number)",
	    "rotate": "fn(angle: number)",
	    "translate": "fn(x: number, y: number)",
	    "transform": "fn(a: number, b: number, c: number, d: number, e: number, f: number)",
	    "setTransform": "fn(a: number, b: number, c: number, d: number, e: number, f: number)",
	    "resetTransform": "fn()",
	    "globalAlpha": "number",
	    "globalCompositeOperation": "string",
	    "imageSmoothingEnabled": "bool",
	    "strokeStyle": "string",
	    "fillStyle": "string",
	    "createLinearGradient": "fn(x0: number, y0: number, x1: number, y1: number) -> ?",
	    "createPattern": "fn(image: ?, repetition: string) -> ?",
	    "shadowOffsetX": "number",
	    "shadowOffsetY": "number",
	    "shadowBlur": "number",
	    "shadowColor": "string",
	    "clearRect": "fn(x: number, y: number, w: number, h: number)",
	    "fillRect": "fn(x: number, y: number, w: number, h: number)",
	    "strokeRect": "fn(x: number, y: number, w: number, h: number)",
	    "fillRule": "string",
	    "fill": "fn()",
	    "beginPath": "fn()",
	    "stroke": "fn()",
	    "clip": "fn()",
	    "resetClip": "fn()",
	    "measureText": "fn(text: string) -> ?",
	    "drawImage": "fn(image: ?, dx: number, dy: number)",
	    "createImageData": "fn(sw: number, sh: number) -> ?",
	    "getImageData": "fn(sx: number, sy: number, sw: number, sh: number) -> ?",
	    "putImageData": "fn(imagedata: ?, dx: number, dy: number)",
	    "lineWidth": "number",
	    "lineCap": "string",
	    "lineJoin": "string",
	    "miterLimit": "number",
	    "setLineDash": "fn(segments: [number])",
	    "getLineDash": "fn() -> [number]",
	    "lineDashOffset": "number",
	    "font": "string",
	    "textAlign": "string",
	    "textBaseline": "string",
	    "direction": "string",
	    "closePath": "fn()",
	    "moveTo": "fn(x: number, y: number)",
	    "lineTo": "fn(x: number, y: number)",
	    "quadraticCurveTo": "fn(cpx: number, cpy: number, x: number, y: number)",
	    "bezierCurveTo": "fn(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number)",
	    "arcTo": "fn(x1: number, y1: number, x2: number, y2: number, radius: number)",
	    "rect": "fn(x: number, y: number, w: number, h: number)",
	    "arc": "fn(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: bool)",
	    "ellipse": "fn(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise: bool)"
	  }
	}


/***/ },
/* 175 */
/***/ function(module, exports) {

	module.exports = {
	  "!name": "ecma5",
	  "!define": {"Error.prototype": "Error.prototype"},
	  "Infinity": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Infinity",
	    "!doc": "A numeric value representing infinity."
	  },
	  "undefined": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/undefined",
	    "!doc": "The value undefined."
	  },
	  "NaN": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/NaN",
	    "!doc": "A value representing Not-A-Number."
	  },
	  "Object": {
	    "!type": "fn()",
	    "getPrototypeOf": {
	      "!type": "fn(obj: ?) -> ?",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getPrototypeOf",
	      "!doc": "Returns the prototype (i.e. the internal prototype) of the specified object."
	    },
	    "create": {
	      "!type": "fn(proto: ?) -> !custom:Object_create",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create",
	      "!doc": "Creates a new object with the specified prototype object and properties."
	    },
	    "defineProperty": {
	      "!type": "fn(obj: ?, prop: string, desc: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
	      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
	    },
	    "defineProperties": {
	      "!type": "fn(obj: ?, props: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
	      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
	    },
	    "getOwnPropertyDescriptor": {
	      "!type": "fn(obj: ?, prop: string) -> ?",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor",
	      "!doc": "Returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object."
	    },
	    "keys": {
	      "!type": "fn(obj: ?) -> [string]",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys",
	      "!doc": "Returns an array of a given object's own enumerable properties, in the same order as that provided by a for-in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."
	    },
	    "getOwnPropertyNames": {
	      "!type": "fn(obj: ?) -> [string]",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames",
	      "!doc": "Returns an array of all properties (enumerable or not) found directly upon a given object."
	    },
	    "seal": {
	      "!type": "fn(obj: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/seal",
	      "!doc": "Seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable."
	    },
	    "isSealed": {
	      "!type": "fn(obj: ?) -> bool",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isSealed",
	      "!doc": "Determine if an object is sealed."
	    },
	    "freeze": {
	      "!type": "fn(obj: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/freeze",
	      "!doc": "Freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen."
	    },
	    "isFrozen": {
	      "!type": "fn(obj: ?) -> bool",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isFrozen",
	      "!doc": "Determine if an object is frozen."
	    },
	    "prototype": {
	      "!stdProto": "Object",
	      "toString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toString",
	        "!doc": "Returns a string representing the object."
	      },
	      "toLocaleString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toLocaleString",
	        "!doc": "Returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes."
	      },
	      "valueOf": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/valueOf",
	        "!doc": "Returns the primitive value of the specified object"
	      },
	      "hasOwnProperty": {
	        "!type": "fn(prop: string) -> bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty",
	        "!doc": "Returns a boolean indicating whether the object has the specified property."
	      },
	      "propertyIsEnumerable": {
	        "!type": "fn(prop: string) -> bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable",
	        "!doc": "Returns a Boolean indicating whether the specified property is enumerable."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object",
	    "!doc": "Creates an object wrapper."
	  },
	  "Function": {
	    "!type": "fn(body: string) -> fn()",
	    "prototype": {
	      "!stdProto": "Function",
	      "apply": {
	        "!type": "fn(this: ?, args: [?])",
	        "!effects": [
	          "call and return !this this=!0 !1.<i> !1.<i> !1.<i>"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply",
	        "!doc": "Calls a function with a given this value and arguments provided as an array (or an array like object)."
	      },
	      "call": {
	        "!type": "fn(this: ?, args?: ?) -> !this.!ret",
	        "!effects": [
	          "call and return !this this=!0 !1 !2 !3 !4"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call",
	        "!doc": "Calls a function with a given this value and arguments provided individually."
	      },
	      "bind": {
	        "!type": "fn(this: ?, args?: ?) -> !custom:Function_bind",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind",
	        "!doc": "Creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function was called."
	      },
	      "prototype": "?"
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function",
	    "!doc": "Every function in JavaScript is actually a Function object."
	  },
	  "Array": {
	    "!type": "fn(size: number) -> !custom:Array_ctor",
	    "isArray": {
	      "!type": "fn(value: ?) -> bool",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray",
	      "!doc": "Returns true if an object is an array, false if it is not."
	    },
	    "prototype": {
	      "!stdProto": "Array",
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/length",
	        "!doc": "An unsigned, 32-bit integer that specifies the number of elements in an array."
	      },
	      "concat": {
	        "!type": "fn(other: [?]) -> !this",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/concat",
	        "!doc": "Returns a new array comprised of this array joined with other array(s) and/or value(s)."
	      },
	      "join": {
	        "!type": "fn(separator?: string) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/join",
	        "!doc": "Joins all elements of an array into a string."
	      },
	      "splice": {
	        "!type": "fn(pos: number, amount: number)",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/splice",
	        "!doc": "Changes the content of an array, adding new elements while removing old elements."
	      },
	      "pop": {
	        "!type": "fn() -> !this.<i>",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/pop",
	        "!doc": "Removes the last element from an array and returns that element."
	      },
	      "push": {
	        "!type": "fn(newelt: ?) -> number",
	        "!effects": [
	          "propagate !0 !this.<i>"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/push",
	        "!doc": "Mutates an array by appending the given elements and returning the new length of the array."
	      },
	      "shift": {
	        "!type": "fn() -> !this.<i>",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/shift",
	        "!doc": "Removes the first element from an array and returns that element. This method changes the length of the array."
	      },
	      "unshift": {
	        "!type": "fn(newelt: ?) -> number",
	        "!effects": [
	          "propagate !0 !this.<i>"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/unshift",
	        "!doc": "Adds one or more elements to the beginning of an array and returns the new length of the array."
	      },
	      "slice": {
	        "!type": "fn(from: number, to?: number) -> !this",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/slice",
	        "!doc": "Returns a shallow copy of a portion of an array."
	      },
	      "reverse": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/reverse",
	        "!doc": "Reverses an array in place.  The first array element becomes the last and the last becomes the first."
	      },
	      "sort": {
	        "!type": "fn(compare?: fn(a: ?, b: ?) -> number)",
	        "!effects": [
	          "call !0 !this.<i> !this.<i>"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort",
	        "!doc": "Sorts the elements of an array in place and returns the array."
	      },
	      "indexOf": {
	        "!type": "fn(elt: ?, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf",
	        "!doc": "Returns the first index at which a given element can be found in the array, or -1 if it is not present."
	      },
	      "lastIndexOf": {
	        "!type": "fn(elt: ?, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/lastIndexOf",
	        "!doc": "Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting at fromIndex."
	      },
	      "every": {
	        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> bool",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/every",
	        "!doc": "Tests whether all elements in the array pass the test implemented by the provided function."
	      },
	      "some": {
	        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> bool",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/some",
	        "!doc": "Tests whether some element in the array passes the test implemented by the provided function."
	      },
	      "filter": {
	        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> !this",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/filter",
	        "!doc": "Creates a new array with all elements that pass the test implemented by the provided function."
	      },
	      "forEach": {
	        "!type": "fn(f: fn(elt: ?, i: number), context?: ?)",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach",
	        "!doc": "Executes a provided function once per array element."
	      },
	      "map": {
	        "!type": "fn(f: fn(elt: ?, i: number) -> ?, context?: ?) -> [!0.!ret]",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map",
	        "!doc": "Creates a new array with the results of calling a provided function on every element in this array."
	      },
	      "reduce": {
	        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number) -> ?, init?: ?) -> !0.!ret",
	        "!effects": [
	          "call !0 !1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/Reduce",
	        "!doc": "Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value."
	      },
	      "reduceRight": {
	        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number) -> ?, init?: ?) -> !0.!ret",
	        "!effects": [
	          "call !0 !1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/ReduceRight",
	        "!doc": "Apply a function simultaneously against two values of the array (from right-to-left) as to reduce it to a single value."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array",
	    "!doc": "The JavaScript Array global object is a constructor for arrays, which are high-level, list-like objects."
	  },
	  "String": {
	    "!type": "fn(value: ?) -> string",
	    "fromCharCode": {
	      "!type": "fn(code: number) -> string",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode",
	      "!doc": "Returns a string created by using the specified sequence of Unicode values."
	    },
	    "prototype": {
	      "!stdProto": "String",
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/String/length",
	        "!doc": "Represents the length of a string."
	      },
	      "<i>": "string",
	      "charAt": {
	        "!type": "fn(i: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charAt",
	        "!doc": "Returns the specified character from a string."
	      },
	      "charCodeAt": {
	        "!type": "fn(i: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charCodeAt",
	        "!doc": "Returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000)."
	      },
	      "indexOf": {
	        "!type": "fn(char: string, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/indexOf",
	        "!doc": "Returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex,\nreturns -1 if the value is not found."
	      },
	      "lastIndexOf": {
	        "!type": "fn(char: string, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/lastIndexOf",
	        "!doc": "Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found. The calling string is searched backward, starting at fromIndex."
	      },
	      "substring": {
	        "!type": "fn(from: number, to?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substring",
	        "!doc": "Returns a subset of a string between one index and another, or through the end of the string."
	      },
	      "substr": {
	        "!type": "fn(from: number, length?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substr",
	        "!doc": "Returns the characters in a string beginning at the specified location through the specified number of characters."
	      },
	      "slice": {
	        "!type": "fn(from: number, to?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/slice",
	        "!doc": "Extracts a section of a string and returns a new string."
	      },
	      "trim": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim",
	        "!doc": "Removes whitespace from both ends of the string."
	      },
	      "trimLeft": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/TrimLeft",
	        "!doc": "Removes whitespace from the left end of the string."
	      },
	      "trimRight": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/TrimRight",
	        "!doc": "Removes whitespace from the right end of the string."
	      },
	      "toUpperCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toUpperCase",
	        "!doc": "Returns the calling string value converted to uppercase."
	      },
	      "toLowerCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLowerCase",
	        "!doc": "Returns the calling string value converted to lowercase."
	      },
	      "toLocaleUpperCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase",
	        "!doc": "Returns the calling string value converted to upper case, according to any locale-specific case mappings."
	      },
	      "toLocaleLowerCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase",
	        "!doc": "Returns the calling string value converted to lower case, according to any locale-specific case mappings."
	      },
	      "split": {
	        "!type": "fn(pattern: string) -> [string]",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/split",
	        "!doc": "Splits a String object into an array of strings by separating the string into substrings."
	      },
	      "concat": {
	        "!type": "fn(other: string) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/concat",
	        "!doc": "Combines the text of two or more strings and returns a new string."
	      },
	      "localeCompare": {
	        "!type": "fn(other: string) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/localeCompare",
	        "!doc": "Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order."
	      },
	      "match": {
	        "!type": "fn(pattern: +RegExp) -> [string]",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/match",
	        "!doc": "Used to retrieve the matches when matching a string against a regular expression."
	      },
	      "replace": {
	        "!type": "fn(pattern: +RegExp, replacement: string) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/replace",
	        "!doc": "Returns a new string with some or all matches of a pattern replaced by a replacement.  The pattern can be a string or a RegExp, and the replacement can be a string or a function to be called for each match."
	      },
	      "search": {
	        "!type": "fn(pattern: +RegExp) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/search",
	        "!doc": "Executes the search for a match between a regular expression and this String object."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String",
	    "!doc": "The String global object is a constructor for strings, or a sequence of characters."
	  },
	  "Number": {
	    "!type": "fn(value: ?) -> number",
	    "MAX_VALUE": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MAX_VALUE",
	      "!doc": "The maximum numeric value representable in JavaScript."
	    },
	    "MIN_VALUE": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MIN_VALUE",
	      "!doc": "The smallest positive numeric value representable in JavaScript."
	    },
	    "POSITIVE_INFINITY": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY",
	      "!doc": "A value representing the positive Infinity value."
	    },
	    "NEGATIVE_INFINITY": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY",
	      "!doc": "A value representing the negative Infinity value."
	    },
	    "prototype": {
	      "!stdProto": "Number",
	      "toString": {
	        "!type": "fn(radix?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toString",
	        "!doc": "Returns a string representing the specified Number object"
	      },
	      "toFixed": {
	        "!type": "fn(digits: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed",
	        "!doc": "Formats a number using fixed-point notation"
	      },
	      "toExponential": {
	        "!type": "fn(digits: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toExponential",
	        "!doc": "Returns a string representing the Number object in exponential notation"
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number",
	    "!doc": "The Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor."
	  },
	  "Boolean": {
	    "!type": "fn(value: ?) -> bool",
	    "prototype": {
	      "!stdProto": "Boolean"
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Boolean",
	    "!doc": "The Boolean object is an object wrapper for a boolean value."
	  },
	  "RegExp": {
	    "!type": "fn(source: string, flags?: string)",
	    "prototype": {
	      "!stdProto": "RegExp",
	      "exec": {
	        "!type": "fn(input: string) -> [string]",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/exec",
	        "!doc": "Executes a search for a match in a specified string. Returns a result array, or null."
	      },
	      "compile": {
	        "!type": "fn(source: string, flags?: string)",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	        "!doc": "Creates a regular expression object for matching text with a pattern."
	      },
	      "test": {
	        "!type": "fn(input: string) -> bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/test",
	        "!doc": "Executes the search for a match between a regular expression and a specified string. Returns true or false."
	      },
	      "global": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	        "!doc": "Creates a regular expression object for matching text with a pattern."
	      },
	      "ignoreCase": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	        "!doc": "Creates a regular expression object for matching text with a pattern."
	      },
	      "multiline": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/multiline",
	        "!doc": "Reflects whether or not to search in strings across multiple lines.\n"
	      },
	      "source": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/source",
	        "!doc": "A read-only property that contains the text of the pattern, excluding the forward slashes.\n"
	      },
	      "lastIndex": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/lastIndex",
	        "!doc": "A read/write integer property that specifies the index at which to start the next match."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	    "!doc": "Creates a regular expression object for matching text with a pattern."
	  },
	  "Date": {
	    "!type": "fn(ms: number)",
	    "parse": {
	      "!type": "fn(source: string) -> +Date",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/parse",
	      "!doc": "Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC."
	    },
	    "UTC": {
	      "!type": "fn(year: number, month: number, date: number, hour?: number, min?: number, sec?: number, ms?: number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/UTC",
	      "!doc": "Accepts the same parameters as the longest form of the constructor, and returns the number of milliseconds in a Date object since January 1, 1970, 00:00:00, universal time."
	    },
	    "now": {
	      "!type": "fn() -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now",
	      "!doc": "Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
	    },
	    "prototype": {
	      "toUTCString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toUTCString",
	        "!doc": "Converts a date to a string, using the universal time convention."
	      },
	      "toISOString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toISOString",
	        "!doc": "JavaScript provides a direct way to convert a date object into a string in ISO format, the ISO 8601 Extended Format."
	      },
	      "toDateString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toDateString",
	        "!doc": "Returns the date portion of a Date object in human readable form in American English."
	      },
	      "toTimeString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toTimeString",
	        "!doc": "Returns the time portion of a Date object in human readable form in American English."
	      },
	      "toLocaleDateString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleDateString",
	        "!doc": "Converts a date to a string, returning the \"date\" portion using the operating system's locale's conventions.\n"
	      },
	      "toLocaleTimeString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString",
	        "!doc": "Converts a date to a string, returning the \"time\" portion using the current locale's conventions."
	      },
	      "getTime": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTime",
	        "!doc": "Returns the numeric value corresponding to the time for the specified date according to universal time."
	      },
	      "getFullYear": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getFullYear",
	        "!doc": "Returns the year of the specified date according to local time."
	      },
	      "getYear": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getYear",
	        "!doc": "Returns the year in the specified date according to local time."
	      },
	      "getMonth": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMonth",
	        "!doc": "Returns the month in the specified date according to local time."
	      },
	      "getUTCMonth": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMonth",
	        "!doc": "Returns the month of the specified date according to universal time.\n"
	      },
	      "getDate": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDate",
	        "!doc": "Returns the day of the month for the specified date according to local time."
	      },
	      "getUTCDate": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDate",
	        "!doc": "Returns the day (date) of the month in the specified date according to universal time.\n"
	      },
	      "getDay": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDay",
	        "!doc": "Returns the day of the week for the specified date according to local time."
	      },
	      "getUTCDay": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDay",
	        "!doc": "Returns the day of the week in the specified date according to universal time.\n"
	      },
	      "getHours": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getHours",
	        "!doc": "Returns the hour for the specified date according to local time."
	      },
	      "getUTCHours": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCHours",
	        "!doc": "Returns the hours in the specified date according to universal time.\n"
	      },
	      "getMinutes": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMinutes",
	        "!doc": "Returns the minutes in the specified date according to local time."
	      },
	      "getUTCMinutes": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
	        "!doc": "Creates JavaScript Date instances which let you work with dates and times."
	      },
	      "getSeconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getSeconds",
	        "!doc": "Returns the seconds in the specified date according to local time."
	      },
	      "getUTCSeconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCSeconds",
	        "!doc": "Returns the seconds in the specified date according to universal time.\n"
	      },
	      "getMilliseconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMilliseconds",
	        "!doc": "Returns the milliseconds in the specified date according to local time."
	      },
	      "getUTCMilliseconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMilliseconds",
	        "!doc": "Returns the milliseconds in the specified date according to universal time.\n"
	      },
	      "getTimezoneOffset": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset",
	        "!doc": "Returns the time-zone offset from UTC, in minutes, for the current locale."
	      },
	      "setTime": {
	        "!type": "fn(date: +Date) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setTime",
	        "!doc": "Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC.\n"
	      },
	      "setFullYear": {
	        "!type": "fn(year: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setFullYear",
	        "!doc": "Sets the full year for a specified date according to local time.\n"
	      },
	      "setUTCFullYear": {
	        "!type": "fn(year: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCFullYear",
	        "!doc": "Sets the full year for a specified date according to universal time.\n"
	      },
	      "setMonth": {
	        "!type": "fn(month: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMonth",
	        "!doc": "Set the month for a specified date according to local time."
	      },
	      "setUTCMonth": {
	        "!type": "fn(month: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMonth",
	        "!doc": "Sets the month for a specified date according to universal time.\n"
	      },
	      "setDate": {
	        "!type": "fn(day: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setDate",
	        "!doc": "Sets the day of the month for a specified date according to local time."
	      },
	      "setUTCDate": {
	        "!type": "fn(day: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCDate",
	        "!doc": "Sets the day of the month for a specified date according to universal time.\n"
	      },
	      "setHours": {
	        "!type": "fn(hour: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setHours",
	        "!doc": "Sets the hours for a specified date according to local time, and returns the number of milliseconds since 1 January 1970 00:00:00 UTC until the time represented by the updated Date instance."
	      },
	      "setUTCHours": {
	        "!type": "fn(hour: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCHours",
	        "!doc": "Sets the hour for a specified date according to universal time.\n"
	      },
	      "setMinutes": {
	        "!type": "fn(min: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMinutes",
	        "!doc": "Sets the minutes for a specified date according to local time."
	      },
	      "setUTCMinutes": {
	        "!type": "fn(min: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMinutes",
	        "!doc": "Sets the minutes for a specified date according to universal time.\n"
	      },
	      "setSeconds": {
	        "!type": "fn(sec: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setSeconds",
	        "!doc": "Sets the seconds for a specified date according to local time."
	      },
	      "setUTCSeconds": {
	        "!type": "fn(sec: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCSeconds",
	        "!doc": "Sets the seconds for a specified date according to universal time.\n"
	      },
	      "setMilliseconds": {
	        "!type": "fn(ms: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMilliseconds",
	        "!doc": "Sets the milliseconds for a specified date according to local time.\n"
	      },
	      "setUTCMilliseconds": {
	        "!type": "fn(ms: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMilliseconds",
	        "!doc": "Sets the milliseconds for a specified date according to universal time.\n"
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
	    "!doc": "Creates JavaScript Date instances which let you work with dates and times."
	  },
	  "Error": {
	    "!type": "fn(message: string)",
	    "prototype": {
	      "name": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/name",
	        "!doc": "A name for the type of error."
	      },
	      "message": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/message",
	        "!doc": "A human-readable description of the error."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error",
	    "!doc": "Creates an error object."
	  },
	  "SyntaxError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/SyntaxError",
	    "!doc": "Represents an error when trying to interpret syntactically invalid code."
	  },
	  "ReferenceError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/ReferenceError",
	    "!doc": "Represents an error when a non-existent variable is referenced."
	  },
	  "URIError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/URIError",
	    "!doc": "Represents an error when a malformed URI is encountered."
	  },
	  "EvalError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/EvalError",
	    "!doc": "Represents an error regarding the eval function."
	  },
	  "RangeError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RangeError",
	    "!doc": "Represents an error when a number is not within the correct range allowed."
	  },
	  "parseInt": {
	    "!type": "fn(string: string, radix?: number) -> number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseInt",
	    "!doc": "Parses a string argument and returns an integer of the specified radix or base."
	  },
	  "parseFloat": {
	    "!type": "fn(string: string) -> number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseFloat",
	    "!doc": "Parses a string argument and returns a floating point number."
	  },
	  "isNaN": {
	    "!type": "fn(value: number) -> bool",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/isNaN",
	    "!doc": "Determines whether a value is NaN or not. Be careful, this function is broken. You may be interested in ECMAScript 6 Number.isNaN."
	  },
	  "eval": {
	    "!type": "fn(code: string) -> ?",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/eval",
	    "!doc": "Evaluates JavaScript code represented as a string."
	  },
	  "encodeURI": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURI",
	    "!doc": "Encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \"surrogate\" characters)."
	  },
	  "encodeURIComponent": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent",
	    "!doc": "Encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \"surrogate\" characters)."
	  },
	  "decodeURI": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURI",
	    "!doc": "Decodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine."
	  },
	  "decodeURIComponent": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURIComponent",
	    "!doc": "Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine."
	  },
	  "Math": {
	    "E": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/E",
	      "!doc": "The base of natural logarithms, e, approximately 2.718."
	    },
	    "LN2": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN2",
	      "!doc": "The natural logarithm of 2, approximately 0.693."
	    },
	    "LN10": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN10",
	      "!doc": "The natural logarithm of 10, approximately 2.302."
	    },
	    "LOG2E": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG2E",
	      "!doc": "The base 2 logarithm of E (approximately 1.442)."
	    },
	    "LOG10E": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG10E",
	      "!doc": "The base 10 logarithm of E (approximately 0.434)."
	    },
	    "SQRT1_2": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT1_2",
	      "!doc": "The square root of 1/2; equivalently, 1 over the square root of 2, approximately 0.707."
	    },
	    "SQRT2": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT2",
	      "!doc": "The square root of 2, approximately 1.414."
	    },
	    "PI": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/PI",
	      "!doc": "The ratio of the circumference of a circle to its diameter, approximately 3.14159."
	    },
	    "abs": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/abs",
	      "!doc": "Returns the absolute value of a number."
	    },
	    "cos": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/cos",
	      "!doc": "Returns the cosine of a number."
	    },
	    "sin": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sin",
	      "!doc": "Returns the sine of a number."
	    },
	    "tan": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/tan",
	      "!doc": "Returns the tangent of a number."
	    },
	    "acos": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/acos",
	      "!doc": "Returns the arccosine (in radians) of a number."
	    },
	    "asin": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/asin",
	      "!doc": "Returns the arcsine (in radians) of a number."
	    },
	    "atan": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan",
	      "!doc": "Returns the arctangent (in radians) of a number."
	    },
	    "atan2": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan2",
	      "!doc": "Returns the arctangent of the quotient of its arguments."
	    },
	    "ceil": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/ceil",
	      "!doc": "Returns the smallest integer greater than or equal to a number."
	    },
	    "floor": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/floor",
	      "!doc": "Returns the largest integer less than or equal to a number."
	    },
	    "round": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/round",
	      "!doc": "Returns the value of a number rounded to the nearest integer."
	    },
	    "exp": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/exp",
	      "!doc": "Returns Ex, where x is the argument, and E is Euler's constant, the base of the natural logarithms."
	    },
	    "log": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/log",
	      "!doc": "Returns the natural logarithm (base E) of a number."
	    },
	    "sqrt": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sqrt",
	      "!doc": "Returns the square root of a number."
	    },
	    "pow": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/pow",
	      "!doc": "Returns base to the exponent power, that is, baseexponent."
	    },
	    "max": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/max",
	      "!doc": "Returns the largest of zero or more numbers."
	    },
	    "min": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/min",
	      "!doc": "Returns the smallest of zero or more numbers."
	    },
	    "random": {
	      "!type": "fn() -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random",
	      "!doc": "Returns a floating-point, pseudo-random number in the range [0, 1) that is, from 0 (inclusive) up to but not including 1 (exclusive), which you can then scale to your desired range."
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math",
	    "!doc": "A built-in object that has properties and methods for mathematical constants and functions."
	  },
	  "JSON": {
	    "parse": {
	      "!type": "fn(json: string) -> ?",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse",
	      "!doc": "Parse a string as JSON, optionally transforming the value produced by parsing."
	    },
	    "stringify": {
	      "!type": "fn(value: ?) -> string",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify",
	      "!doc": "Convert a value to JSON, optionally replacing values if a replacer function is specified, or optionally including only the specified properties if a replacer array is specified."
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JSON",
	    "!doc": "JSON (JavaScript Object Notation) is a data-interchange format.  It closely resembles a subset of JavaScript syntax, although it is not a strict subset. (See JSON in the JavaScript Reference for full details.)  It is useful when writing any kind of JavaScript-based application, including websites and browser extensions.  For example, you might store user information in JSON format in a cookie, or you might store extension preferences in JSON in a string-valued browser preference."
	  }
	}


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// The Tern server object

	// A server is a stateful object that manages the analysis for a
	// project, and defines an interface for querying the code in the
	// project.

	(function(root, mod) {
	  if (true) // CommonJS
	    return mod(exports, __webpack_require__(177), __webpack_require__(183),
	               __webpack_require__(178), __webpack_require__(181));
	  if (true) // AMD
	    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(177), __webpack_require__(183), __webpack_require__(178), __webpack_require__(181)], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env
	})(this, function(exports, infer, signal, acorn, walk) {
	  "use strict";

	  var plugins = Object.create(null);
	  exports.registerPlugin = function(name, init) { plugins[name] = init; };

	  var defaultOptions = exports.defaultOptions = {
	    debug: false,
	    async: false,
	    getFile: function(_f, c) { if (this.async) c(null, null); },
	    normalizeFilename: function(name) { return name },
	    defs: [],
	    plugins: {},
	    fetchTimeout: 1000,
	    dependencyBudget: 20000,
	    reuseInstances: true,
	    stripCRs: false,
	    ecmaVersion: 6,
	    projectDir: "/"
	  };

	  var queryTypes = {
	    completions: {
	      takesFile: true,
	      run: findCompletions
	    },
	    properties: {
	      run: findProperties
	    },
	    type: {
	      takesFile: true,
	      run: findTypeAt
	    },
	    documentation: {
	      takesFile: true,
	      run: findDocs
	    },
	    definition: {
	      takesFile: true,
	      run: findDef
	    },
	    refs: {
	      takesFile: true,
	      fullFile: true,
	      run: findRefs
	    },
	    rename: {
	      takesFile: true,
	      fullFile: true,
	      run: buildRename
	    },
	    files: {
	      run: listFiles
	    }
	  };

	  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };

	  function File(name, parent) {
	    this.name = name;
	    this.parent = parent;
	    this.scope = this.text = this.ast = this.lineOffsets = null;
	  }
	  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };

	  function parseFile(srv, file) {
	    var options = {
	      directSourceFile: file,
	      allowReturnOutsideFunction: true,
	      allowImportExportEverywhere: true,
	      ecmaVersion: srv.options.ecmaVersion
	    }
	    var text = srv.signalReturnFirst("preParse", file.text, options) || file.text
	    var ast = infer.parse(text, options)
	    srv.signal("postParse", ast, text)
	    return ast
	  }

	  function updateText(file, text, srv) {
	    file.text = srv.options.stripCRs ? text.replace(/\r\n/g, "\n") : text;
	    infer.withContext(srv.cx, function() {
	      file.ast = parseFile(srv, file)
	    });
	    file.lineOffsets = null;
	  }

	  var Server = exports.Server = function(options) {
	    this.cx = null;
	    this.options = options || {};
	    for (var o in defaultOptions) if (!options.hasOwnProperty(o))
	      options[o] = defaultOptions[o];

	    this.projectDir = options.projectDir.replace(/\\/g, "/")
	    if (!/\/$/.test(this.projectDir)) this.projectDir += "/"

	    this.handlers = Object.create(null);
	    this.files = [];
	    this.fileMap = Object.create(null);
	    this.needsPurge = [];
	    this.budgets = Object.create(null);
	    this.uses = 0;
	    this.pending = 0;
	    this.asyncError = null;
	    this.mod = {}

	    this.defs = options.defs.slice(0)
	    this.plugins = Object.create(null)
	    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))
	      this.loadPlugin(plugin, options.plugins[plugin])

	    this.reset();
	  };
	  Server.prototype = signal.mixin({
	    addFile: function(name, /*optional*/ text, parent) {
	      // Don't crash when sloppy plugins pass non-existent parent ids
	      if (parent && !(parent in this.fileMap)) parent = null;
	      if (!(name in this.fileMap))
	        name = this.normalizeFilename(name)
	      ensureFile(this, name, parent, text);
	    },
	    delFile: function(name) {
	      var file = this.findFile(name);
	      if (file) {
	        this.needsPurge.push(file.name);
	        this.files.splice(this.files.indexOf(file), 1);
	        delete this.fileMap[name];
	      }
	    },
	    reset: function() {
	      this.signal("reset");
	      this.cx = new infer.Context(this.defs, this);
	      this.uses = 0;
	      this.budgets = Object.create(null);
	      for (var i = 0; i < this.files.length; ++i) {
	        var file = this.files[i];
	        file.scope = null;
	      }
	      this.signal("postReset");
	    },

	    request: function(doc, c) {
	      var inv = invalidDoc(doc);
	      if (inv) return c(inv);

	      var self = this;
	      doRequest(this, doc, function(err, data) {
	        c(err, data);
	        if (self.uses > 40) {
	          self.reset();
	          analyzeAll(self, null, function(){});
	        }
	      });
	    },

	    findFile: function(name) {
	      return this.fileMap[name];
	    },

	    flush: function(c) {
	      var cx = this.cx;
	      analyzeAll(this, null, function(err) {
	        if (err) return c(err);
	        infer.withContext(cx, c);
	      });
	    },

	    startAsyncAction: function() {
	      ++this.pending;
	    },
	    finishAsyncAction: function(err) {
	      if (err) this.asyncError = err;
	      if (--this.pending === 0) this.signal("everythingFetched");
	    },

	    addDefs: function(defs, toFront) {
	      if (toFront) this.defs.unshift(defs)
	      else this.defs.push(defs)

	      if (this.cx) this.reset()
	    },

	    loadPlugin: function(name, options) {
	      if (arguments.length == 1) options = this.options.plugins[name] || true
	      if (name in this.plugins || !(name in plugins) || !options) return
	      this.plugins[name] = true
	      var init = plugins[name](this, options)

	      // This is for backwards-compatibilty. Don't rely on it -- use addDef and on directly
	      if (!init) return
	      if (init.defs) this.addDefs(init.defs, init.loadFirst)
	      if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
	        this.on(type, init.passes[type])
	    },

	    normalizeFilename: function(name) {
	      var norm = this.options.normalizeFilename(name).replace(/\\/g, "/")
	      if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length)
	      return norm
	    }
	  });

	  function doRequest(srv, doc, c) {
	    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))
	      return c("No query type '" + doc.query.type + "' defined");

	    var query = doc.query;
	    // Respond as soon as possible when this just uploads files
	    if (!query) c(null, {});

	    var files = doc.files || [];
	    if (files.length) ++srv.uses;
	    for (var i = 0; i < files.length; ++i) {
	      var file = files[i];
	      if (file.type == "delete")
	        srv.delFile(file.name);
	      else
	        ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
	    }

	    var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
	    if (!query) {
	      analyzeAll(srv, timeBudget, function(){});
	      return;
	    }

	    var queryType = queryTypes[query.type];
	    if (queryType.takesFile) {
	      if (typeof query.file != "string") return c(".query.file must be a string");
	      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);
	    }

	    analyzeAll(srv, timeBudget, function(err) {
	      if (err) return c(err);
	      var file = queryType.takesFile && resolveFile(srv, files, query.file);
	      if (queryType.fullFile && file.type == "part")
	        return c("Can't run a " + query.type + " query on a file fragment");

	      function run() {
	        var result;
	        try {
	          result = queryType.run(srv, query, file);
	        } catch (e) {
	          if (srv.options.debug && e.name != "TernError") console.error(e.stack);
	          return c(e);
	        }
	        c(null, result);
	      }
	      infer.resetGuessing()
	      infer.withContext(srv.cx, timeBudget ? function() { infer.withTimeout(timeBudget[0], run); } : run);
	    });
	  }

	  function analyzeFile(srv, file) {
	    infer.withContext(srv.cx, function() {
	      file.scope = srv.cx.topScope;
	      srv.signal("beforeLoad", file);
	      infer.analyze(file.ast, file.name, file.scope);
	      srv.signal("afterLoad", file);
	    });
	    return file;
	  }

	  function ensureFile(srv, name, parent, text) {
	    var known = srv.findFile(name);
	    if (known) {
	      if (text != null) {
	        if (known.scope) {
	          srv.needsPurge.push(name);
	          known.scope = null;
	        }
	        updateText(known, text, srv);
	      }
	      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {
	        known.parent = parent;
	        if (known.excluded) known.excluded = null;
	      }
	      return;
	    }

	    var file = new File(name, parent);
	    srv.files.push(file);
	    srv.fileMap[name] = file;
	    if (text != null) {
	      updateText(file, text, srv);
	    } else if (srv.options.async) {
	      srv.startAsyncAction();
	      srv.options.getFile(name, function(err, text) {
	        updateText(file, text || "", srv);
	        srv.finishAsyncAction(err);
	      });
	    } else {
	      updateText(file, srv.options.getFile(name) || "", srv);
	    }
	  }

	  function fetchAll(srv, c) {
	    var done = true, returned = false;
	    srv.files.forEach(function(file) {
	      if (file.text != null) return;
	      if (srv.options.async) {
	        done = false;
	        srv.options.getFile(file.name, function(err, text) {
	          if (err && !returned) { returned = true; return c(err); }
	          updateText(file, text || "", srv);
	          fetchAll(srv, c);
	        });
	      } else {
	        try {
	          updateText(file, srv.options.getFile(file.name) || "", srv);
	        } catch (e) { return c(e); }
	      }
	    });
	    if (done) c();
	  }

	  function waitOnFetch(srv, timeBudget, c) {
	    var done = function() {
	      srv.off("everythingFetched", done);
	      clearTimeout(timeout);
	      analyzeAll(srv, timeBudget, c);
	    };
	    srv.on("everythingFetched", done);
	    var timeout = setTimeout(done, srv.options.fetchTimeout);
	  }

	  function analyzeAll(srv, timeBudget, c) {
	    if (srv.pending) return waitOnFetch(srv, timeBudget, c);

	    var e = srv.fetchError;
	    if (e) { srv.fetchError = null; return c(e); }

	    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {
	      infer.purge(srv.needsPurge);
	      srv.needsPurge.length = 0;
	    });

	    var done = true;
	    // The second inner loop might add new files. The outer loop keeps
	    // repeating both inner loops until all files have been looked at.
	    for (var i = 0; i < srv.files.length;) {
	      var toAnalyze = [];
	      for (; i < srv.files.length; ++i) {
	        var file = srv.files[i];
	        if (file.text == null) done = false;
	        else if (file.scope == null && !file.excluded) toAnalyze.push(file);
	      }
	      toAnalyze.sort(function(a, b) {
	        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);
	      });
	      for (var j = 0; j < toAnalyze.length; j++) {
	        var file = toAnalyze[j];
	        if (file.parent && !chargeOnBudget(srv, file)) {
	          file.excluded = true;
	        } else if (timeBudget) {
	          var startTime = +new Date;
	          infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });
	          timeBudget[0] -= +new Date - startTime;
	        } else {
	          analyzeFile(srv, file);
	        }
	      }
	    }
	    if (done) c();
	    else waitOnFetch(srv, timeBudget, c);
	  }

	  function firstLine(str) {
	    var end = str.indexOf("\n");
	    if (end < 0) return str;
	    return str.slice(0, end);
	  }

	  function findMatchingPosition(line, file, near) {
	    var pos = Math.max(0, near - 500), closest = null;
	    if (!/^\s*$/.test(line)) for (;;) {
	      var found = file.indexOf(line, pos);
	      if (found < 0 || found > near + 500) break;
	      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))
	        closest = found;
	      pos = found + line.length;
	    }
	    return closest;
	  }

	  function scopeDepth(s) {
	    for (var i = 0; s; ++i, s = s.prev) {}
	    return i;
	  }

	  function ternError(msg) {
	    var err = new Error(msg);
	    err.name = "TernError";
	    return err;
	  }

	  function resolveFile(srv, localFiles, name) {
	    var isRef = name.match(/^#(\d+)$/);
	    if (!isRef) return srv.findFile(name);

	    var file = localFiles[isRef[1]];
	    if (!file || file.type == "delete") throw ternError("Reference to unknown file " + name);
	    if (file.type == "full") return srv.findFile(file.name);

	    // This is a partial file

	    var realFile = file.backing = srv.findFile(file.name);
	    var offset = file.offset;
	    if (file.offsetLines) offset = {line: file.offsetLines, ch: 0};
	    file.offset = offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);
	    var line = firstLine(file.text);
	    var foundPos = findMatchingPosition(line, realFile.text, offset);
	    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf("\n", offset)) : foundPos;
	    var inObject, atFunction;

	    infer.withContext(srv.cx, function() {
	      infer.purge(file.name, pos, pos + file.text.length);

	      var text = file.text, m;
	      if (m = text.match(/(?:"([^"]*)"|([\w$]+))\s*:\s*function\b/)) {
	        var objNode = walk.findNodeAround(file.backing.ast, pos, "ObjectExpression");
	        if (objNode && objNode.node.objType)
	          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};
	      }
	      if (foundPos && (m = line.match(/^(.*?)\bfunction\b/))) {
	        var cut = m[1].length, white = "";
	        for (var i = 0; i < cut; ++i) white += " ";
	        file.text = white + text.slice(cut);
	        atFunction = true;
	      }

	      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);
	      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);
	      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;
	      file.ast = parseFile(srv, file)
	      infer.analyze(file.ast, file.name, scope);

	      // This is a kludge to tie together the function types (if any)
	      // outside and inside of the fragment, so that arguments and
	      // return values have some information known about them.
	      tieTogether: if (inObject || atFunction) {
	        var newInner = infer.scopeAt(file.ast, line.length, scopeStart);
	        if (!newInner.fnType) break tieTogether;
	        if (inObject) {
	          var prop = inObject.type.getProp(inObject.prop);
	          prop.addType(newInner.fnType);
	        } else if (atFunction) {
	          var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);
	          if (inner == scopeStart || !inner.fnType) break tieTogether;
	          var fOld = inner.fnType, fNew = newInner.fnType;
	          if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;
	          for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)
	            fOld.args[i].propagate(fNew.args[i]);
	          fOld.self.propagate(fNew.self);
	          fNew.retval.propagate(fOld.retval);
	        }
	      }
	    });
	    return file;
	  }

	  // Budget management

	  function astSize(node) {
	    var size = 0;
	    walk.simple(node, {Expression: function() { ++size; }});
	    return size;
	  }

	  function parentDepth(srv, parent) {
	    var depth = 0;
	    while (parent) {
	      parent = srv.findFile(parent).parent;
	      ++depth;
	    }
	    return depth;
	  }

	  function budgetName(srv, file) {
	    for (;;) {
	      var parent = srv.findFile(file.parent);
	      if (!parent.parent) break;
	      file = parent;
	    }
	    return file.name;
	  }

	  function chargeOnBudget(srv, file) {
	    var bName = budgetName(srv, file);
	    var size = astSize(file.ast);
	    var known = srv.budgets[bName];
	    if (known == null)
	      known = srv.budgets[bName] = srv.options.dependencyBudget;
	    if (known < size) return false;
	    srv.budgets[bName] = known - size;
	    return true;
	  }

	  // Query helpers

	  function isPosition(val) {
	    return typeof val == "number" || typeof val == "object" &&
	      typeof val.line == "number" && typeof val.ch == "number";
	  }

	  // Baseline query document validation
	  function invalidDoc(doc) {
	    if (doc.query) {
	      if (typeof doc.query.type != "string") return ".query.type must be a string";
	      if (doc.query.start && !isPosition(doc.query.start)) return ".query.start must be a position";
	      if (doc.query.end && !isPosition(doc.query.end)) return ".query.end must be a position";
	    }
	    if (doc.files) {
	      if (!Array.isArray(doc.files)) return "Files property must be an array";
	      for (var i = 0; i < doc.files.length; ++i) {
	        var file = doc.files[i];
	        if (typeof file != "object") return ".files[n] must be objects";
	        else if (typeof file.name != "string") return ".files[n].name must be a string";
	        else if (file.type == "delete") continue;
	        else if (typeof file.text != "string") return ".files[n].text must be a string";
	        else if (file.type == "part") {
	          if (!isPosition(file.offset) && typeof file.offsetLines != "number")
	            return ".files[n].offset must be a position";
	        } else if (file.type != "full") return ".files[n].type must be \"full\" or \"part\"";
	      }
	    }
	  }

	  var offsetSkipLines = 25;

	  function findLineStart(file, line) {
	    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);
	    var pos = 0, curLine = 0;
	    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);
	    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;

	    while (curLine < line) {
	      ++curLine;
	      pos = text.indexOf("\n", pos) + 1;
	      if (pos === 0) return null;
	      if (curLine % offsetSkipLines === 0) offsets.push(pos);
	    }
	    return pos;
	  }

	  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {
	    if (typeof pos != "number") {
	      var lineStart = findLineStart(file, pos.line);
	      if (lineStart == null) {
	        if (tolerant) pos = file.text.length;
	        else throw ternError("File doesn't contain a line " + pos.line);
	      } else {
	        pos = lineStart + pos.ch;
	      }
	    }
	    if (pos > file.text.length) {
	      if (tolerant) pos = file.text.length;
	      else throw ternError("Position " + pos + " is outside of file.");
	    }
	    return pos;
	  };

	  function asLineChar(file, pos) {
	    if (!file) return {line: 0, ch: 0};
	    var offsets = file.lineOffsets || (file.lineOffsets = [0]);
	    var text = file.text, line, lineStart;
	    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {
	      line = i * offsetSkipLines;
	      lineStart = offsets[i];
	    }
	    for (;;) {
	      var eol = text.indexOf("\n", lineStart);
	      if (eol >= pos || eol < 0) break;
	      lineStart = eol + 1;
	      ++line;
	    }
	    return {line: line, ch: pos - lineStart};
	  }

	  var outputPos = exports.outputPos = function(query, file, pos) {
	    if (query.lineCharPositions) {
	      var out = asLineChar(file, pos);
	      if (file.type == "part")
	        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;
	      return out;
	    } else {
	      return pos + (file.type == "part" ? file.offset : 0);
	    }
	  };

	  // Delete empty fields from result objects
	  function clean(obj) {
	    for (var prop in obj) if (obj[prop] == null) delete obj[prop];
	    return obj;
	  }
	  function maybeSet(obj, prop, val) {
	    if (val != null) obj[prop] = val;
	  }

	  // Built-in query types

	  function compareCompletions(a, b) {
	    if (typeof a != "string") { a = a.name; b = b.name; }
	    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);
	    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;
	    else return aUp ? 1 : -1;
	  }

	  function isStringAround(node, start, end) {
	    return node.type == "Literal" && typeof node.value == "string" &&
	      node.start == start - 1 && node.end <= end + 1;
	  }

	  function pointInProp(objNode, point) {
	    for (var i = 0; i < objNode.properties.length; i++) {
	      var curProp = objNode.properties[i];
	      if (curProp.key.start <= point && curProp.key.end >= point)
	        return curProp;
	    }
	  }

	  var jsKeywords = ("break do instanceof typeof case else new var " +
	    "catch finally return void continue for switch while debugger " +
	    "function this with default if throw delete in try").split(" ");

	  var addCompletion = exports.addCompletion = function(query, completions, name, aval, depth) {
	    var typeInfo = query.types || query.docs || query.urls || query.origins;
	    var wrapAsObjs = typeInfo || query.depths;

	    for (var i = 0; i < completions.length; ++i) {
	      var c = completions[i];
	      if ((wrapAsObjs ? c.name : c) == name) return;
	    }
	    var rec = wrapAsObjs ? {name: name} : name;
	    completions.push(rec);

	    if (aval && typeInfo) {
	      infer.resetGuessing();
	      var type = aval.getType();
	      rec.guess = infer.didGuess();
	      if (query.types)
	        rec.type = infer.toString(aval);
	      if (query.docs)
	        maybeSet(rec, "doc", parseDoc(query, aval.doc || type && type.doc));
	      if (query.urls)
	        maybeSet(rec, "url", aval.url || type && type.url);
	      if (query.origins)
	        maybeSet(rec, "origin", aval.origin || type && type.origin);
	    }
	    if (query.depths) rec.depth = depth || 0;
	    return rec;
	  };

	  function findCompletions(srv, query, file) {
	    if (query.end == null) throw ternError("missing .query.end field");
	    var fromPlugin = srv.signalReturnFirst("completion", file, query)
	    if (fromPlugin) return fromPlugin

	    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;
	    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;
	    if (query.expandWordForward !== false)
	      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;
	    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;
	    if (query.caseInsensitive) word = word.toLowerCase();

	    function gather(prop, obj, depth, addInfo) {
	      // 'hasOwnProperty' and such are usually just noise, leave them
	      // out when no prefix is provided.
	      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;
	      if (query.filter !== false && word &&
	          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;
	      if (ignoreObj && ignoreObj.props[prop]) return;
	      var result = addCompletion(query, completions, prop, obj && obj.props[prop], depth);
	      if (addInfo && result && typeof result != "string") addInfo(result);
	    }

	    var hookname, prop, objType, isKey;

	    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);
	    var memberExpr, objLit;
	    // Decide whether this is an object property, either in a member
	    // expression or an object literal.
	    if (exprAt) {
	      var exprNode = exprAt.node;
	      if (exprNode.type == "MemberExpression" && exprNode.object.end < wordStart) {
	        memberExpr = exprAt;
	      } else if (isStringAround(exprNode, wordStart, wordEnd)) {
	        var parent = infer.parentNode(exprNode, file.ast);
	        if (parent.type == "MemberExpression" && parent.property == exprNode)
	          memberExpr = {node: parent, state: exprAt.state};
	      } else if (exprNode.type == "ObjectExpression") {
	        var objProp = pointInProp(exprNode, wordEnd);
	        if (objProp) {
	          objLit = exprAt;
	          prop = isKey = objProp.key.name;
	        } else if (!word && !/:\s*$/.test(file.text.slice(0, wordStart))) {
	          objLit = exprAt;
	          prop = isKey = true;
	        }
	      }
	    }

	    if (objLit) {
	      // Since we can't use the type of the literal itself to complete
	      // its properties (it doesn't contain the information we need),
	      // we have to try asking the surrounding expression for type info.
	      objType = infer.typeFromContext(file.ast, objLit);
	      ignoreObj = objLit.node.objType;
	    } else if (memberExpr) {
	      prop = memberExpr.node.property;
	      prop = prop.type == "Literal" ? prop.value.slice(1) : prop.name;
	      memberExpr.node = memberExpr.node.object;
	      objType = infer.expressionType(memberExpr);
	    } else if (text.charAt(wordStart - 1) == ".") {
	      var pathStart = wordStart - 1;
	      while (pathStart && (text.charAt(pathStart - 1) == "." || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;
	      var path = text.slice(pathStart, wordStart - 1);
	      if (path) {
	        objType = infer.def.parsePath(path, file.scope).getObjType();
	        prop = word;
	      }
	    }

	    if (prop != null) {
	      srv.cx.completingProperty = prop;

	      if (objType) infer.forAllPropertiesOf(objType, gather);

	      if (!completions.length && query.guess !== false && objType && objType.guessProperties)
	        objType.guessProperties(function(p, o, d) {if (p != prop && p != "✖") gather(p, o, d);});
	      if (!completions.length && word.length >= 2 && query.guess !== false)
	        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);
	      hookname = "memberCompletion";
	    } else {
	      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);
	      if (query.includeKeywords) jsKeywords.forEach(function(kw) {
	        gather(kw, null, 0, function(rec) { rec.isKeyword = true; });
	      });
	      hookname = "variableCompletion";
	    }
	    srv.signal(hookname, file, wordStart, wordEnd, gather)

	    if (query.sort !== false) completions.sort(compareCompletions);
	    srv.cx.completingProperty = null;

	    return {start: outputPos(query, file, wordStart),
	            end: outputPos(query, file, wordEnd),
	            isProperty: !!prop,
	            isObjectKey: !!isKey,
	            completions: completions};
	  }

	  function findProperties(srv, query) {
	    var prefix = query.prefix, found = [];
	    for (var prop in srv.cx.props)
	      if (prop != "<i>" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);
	    if (query.sort !== false) found.sort(compareCompletions);
	    return {completions: found};
	  }

	  var findExpr = exports.findQueryExpr = function(file, query, wide) {
	    if (query.end == null) throw ternError("missing .query.end field");

	    if (query.variable) {
	      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);
	      return {node: {type: "Identifier", name: query.variable, start: query.end, end: query.end + 1},
	              state: scope};
	    } else {
	      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);
	      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);
	      if (expr) return expr;
	      expr = infer.findExpressionAround(file.ast, start, end, file.scope);
	      if (expr && (expr.node.type == "ObjectExpression" || wide ||
	                   (start == null ? end : start) - expr.node.start < 20 || expr.node.end - end < 20))
	        return expr;
	      return null;
	    }
	  };

	  function findExprOrThrow(file, query, wide) {
	    var expr = findExpr(file, query, wide);
	    if (expr) return expr;
	    throw ternError("No expression at the given position.");
	  }

	  function ensureObj(tp) {
	    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;
	    return tp;
	  }

	  function findExprType(srv, query, file, expr) {
	    var type;
	    if (expr) {
	      infer.resetGuessing();
	      type = infer.expressionType(expr);
	    }
	    var typeHandlers = srv.hasHandler("typeAt")
	    if (typeHandlers) {
	      var pos = resolvePos(file, query.end)
	      for (var i = 0; i < typeHandlers.length; i++)
	        type = typeHandlers[i](file, pos, expr, type)
	    }
	    if (!type) throw ternError("No type found at the given position.");

	    var objProp;
	    if (expr.node.type == "ObjectExpression" && query.end != null &&
	        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {
	      var name = objProp.key.name;
	      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));
	      if (fromCx && fromCx.hasProp(name)) {
	        type = fromCx.hasProp(name);
	      } else {
	        var fromLocal = ensureObj(type);
	        if (fromLocal && fromLocal.hasProp(name))
	          type = fromLocal.hasProp(name);
	      }
	    }
	    return type;
	  };

	  function findTypeAt(srv, query, file) {
	    var expr = findExpr(file, query), exprName;
	    var type = findExprType(srv, query, file, expr), exprType = type;
	    if (query.preferFunction)
	      type = type.getFunctionType() || type.getType();
	    else
	      type = type.getType();

	    if (expr) {
	      if (expr.node.type == "Identifier")
	        exprName = expr.node.name;
	      else if (expr.node.type == "MemberExpression" && !expr.node.computed)
	        exprName = expr.node.property.name;
	    }

	    if (query.depth != null && typeof query.depth != "number")
	      throw ternError(".query.depth must be a number");

	    var result = {guess: infer.didGuess(),
	                  type: infer.toString(exprType, query.depth),
	                  name: type && type.name,
	                  exprName: exprName,
	                  doc: exprType.doc,
	                  url: exprType.url};
	    if (type) storeTypeDocs(query, type, result);

	    return clean(result);
	  }

	  function parseDoc(query, doc) {
	    if (!doc) return null;
	    if (query.docFormat == "full") return doc;
	    var parabreak = /.\n[\s@\n]/.exec(doc);
	    if (parabreak) doc = doc.slice(0, parabreak.index + 1);
	    doc = doc.replace(/\n\s*/g, " ");
	    if (doc.length < 100) return doc;
	    var sentenceEnd = /[\.!?] [A-Z]/g;
	    sentenceEnd.lastIndex = 80;
	    var found = sentenceEnd.exec(doc);
	    if (found) doc = doc.slice(0, found.index + 1);
	    return doc;
	  }

	  function findDocs(srv, query, file) {
	    var expr = findExpr(file, query);
	    var type = findExprType(srv, query, file, expr);
	    var result = {url: type.url, doc: parseDoc(query, type.doc), type: infer.toString(type)};
	    var inner = type.getType();
	    if (inner) storeTypeDocs(query, inner, result);
	    return clean(result);
	  }

	  function storeTypeDocs(query, type, out) {
	    if (!out.url) out.url = type.url;
	    if (!out.doc) out.doc = parseDoc(query, type.doc);
	    if (!out.origin) out.origin = type.origin;
	    var ctor, boring = infer.cx().protos;
	    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&
	        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {
	      out.url = ctor.url;
	      out.doc = parseDoc(query, ctor.doc);
	    }
	  }

	  var getSpan = exports.getSpan = function(obj) {
	    if (!obj.origin) return;
	    if (obj.originNode) {
	      var node = obj.originNode;
	      if (/^Function/.test(node.type) && node.id) node = node.id;
	      return {origin: obj.origin, node: node};
	    }
	    if (obj.span) return {origin: obj.origin, span: obj.span};
	  };

	  var storeSpan = exports.storeSpan = function(srv, query, span, target) {
	    target.origin = span.origin;
	    if (span.span) {
	      var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
	      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);
	      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);
	    } else {
	      var file = srv.findFile(span.origin);
	      target.start = outputPos(query, file, span.node.start);
	      target.end = outputPos(query, file, span.node.end);
	    }
	  };

	  function findDef(srv, query, file) {
	    var expr = findExpr(file, query);
	    var type = findExprType(srv, query, file, expr);
	    if (infer.didGuess()) return {};

	    var span = getSpan(type);
	    var result = {url: type.url, doc: parseDoc(query, type.doc), origin: type.origin};

	    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {
	      var tp = type.types[i];
	      storeTypeDocs(query, tp, result);
	      if (!span) span = getSpan(tp);
	    }

	    if (span && span.node) { // refers to a loaded file
	      var spanFile = span.node.sourceFile || srv.findFile(span.origin);
	      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);
	      result.start = start; result.end = end;
	      result.file = span.origin;
	      var cxStart = Math.max(0, span.node.start - 50);
	      result.contextOffset = span.node.start - cxStart;
	      result.context = spanFile.text.slice(cxStart, cxStart + 50);
	    } else if (span) { // external
	      result.file = span.origin;
	      storeSpan(srv, query, span, result);
	    }
	    return clean(result);
	  }

	  function findRefsToVariable(srv, query, file, expr, checkShadowing) {
	    var name = expr.node.name;

	    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}
	    if (!scope) throw ternError("Could not find a definition for " + name);

	    var type, refs = [];
	    function storeRef(file) {
	      return function(node, scopeHere) {
	        if (checkShadowing) for (var s = scopeHere; s != scope; s = s.prev) {
	          var exists = s.hasProp(checkShadowing);
	          if (exists)
	            throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would make a variable at line " +
	                            (asLineChar(file, node.start).line + 1) + " point to the definition at line " +
	                            (asLineChar(file, exists.name.start).line + 1));
	        }
	        refs.push({file: file.name,
	                   start: outputPos(query, file, node.start),
	                   end: outputPos(query, file, node.end)});
	      };
	    }

	    if (scope.originNode) {
	      type = "local";
	      if (checkShadowing) {
	        for (var prev = scope.prev; prev; prev = prev.prev)
	          if (checkShadowing in prev.props) break;
	        if (prev) infer.findRefs(scope.originNode, scope, checkShadowing, prev, function(node) {
	          throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would shadow the definition used at line " +
	                          (asLineChar(file, node.start).line + 1));
	        });
	      }
	      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));
	    } else {
	      type = "global";
	      for (var i = 0; i < srv.files.length; ++i) {
	        var cur = srv.files[i];
	        infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));
	      }
	    }

	    return {refs: refs, type: type, name: name};
	  }

	  function findRefsToProperty(srv, query, expr, prop) {
	    var objType = infer.expressionType(expr).getObjType();
	    if (!objType) throw ternError("Couldn't determine type of base object.");

	    var refs = [];
	    function storeRef(file) {
	      return function(node) {
	        refs.push({file: file.name,
	                   start: outputPos(query, file, node.start),
	                   end: outputPos(query, file, node.end)});
	      };
	    }
	    for (var i = 0; i < srv.files.length; ++i) {
	      var cur = srv.files[i];
	      infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));
	    }

	    return {refs: refs, name: prop.name};
	  }

	  function findRefs(srv, query, file) {
	    var expr = findExprOrThrow(file, query, true);
	    if (expr && expr.node.type == "Identifier") {
	      return findRefsToVariable(srv, query, file, expr);
	    } else if (expr && expr.node.type == "MemberExpression" && !expr.node.computed) {
	      var p = expr.node.property;
	      expr.node = expr.node.object;
	      return findRefsToProperty(srv, query, expr, p);
	    } else if (expr && expr.node.type == "ObjectExpression") {
	      var pos = resolvePos(file, query.end);
	      for (var i = 0; i < expr.node.properties.length; ++i) {
	        var k = expr.node.properties[i].key;
	        if (k.start <= pos && k.end >= pos)
	          return findRefsToProperty(srv, query, expr, k);
	      }
	    }
	    throw ternError("Not at a variable or property name.");
	  }

	  function buildRename(srv, query, file) {
	    if (typeof query.newName != "string") throw ternError(".query.newName should be a string");
	    var expr = findExprOrThrow(file, query);
	    if (!expr || expr.node.type != "Identifier") throw ternError("Not at a variable.");

	    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;
	    delete data.refs;
	    data.files = srv.files.map(function(f){return f.name;});

	    var changes = data.changes = [];
	    for (var i = 0; i < refs.length; ++i) {
	      var use = refs[i];
	      use.text = query.newName;
	      changes.push(use);
	    }

	    return data;
	  }

	  function listFiles(srv) {
	    return {files: srv.files.map(function(f){return f.name;})};
	  }

	  exports.version = "0.16.0";
	});


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Main type inference engine

	// Walks an AST, building up a graph of abstract values and constraints
	// that cause types to flow from one node to another. Also defines a
	// number of utilities for accessing ASTs and scopes.

	// Analysis is done in a context, which is tracked by the dynamically
	// bound cx variable. Use withContext to set the current context.

	// For memory-saving reasons, individual types export an interface
	// similar to abstract values (which can hold multiple types), and can
	// thus be used in place abstract values that only ever contain a
	// single type.

	(function(root, mod) {
	  if (true) // CommonJS
	    return mod(exports, __webpack_require__(178), __webpack_require__(180), __webpack_require__(181),
	               __webpack_require__(182), __webpack_require__(183));
	  if (true) // AMD
	    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(178), __webpack_require__(180), __webpack_require__(181), __webpack_require__(182), __webpack_require__(183)], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  mod(root.tern || (root.tern = {}), acorn, acorn, acorn.walk, tern.def, tern.signal); // Plain browser env
	})(this, function(exports, acorn, acorn_loose, walk, def, signal) {
	  "use strict";

	  var toString = exports.toString = function(type, maxDepth, parent) {
	    if (!type || type == parent || maxDepth && maxDepth < -3) return "?";
	    return type.toString(maxDepth, parent);
	  };

	  // A variant of AVal used for unknown, dead-end values. Also serves
	  // as prototype for AVals, Types, and Constraints because it
	  // implements 'empty' versions of all the methods that the code
	  // expects.
	  var ANull = exports.ANull = signal.mixin({
	    addType: function() {},
	    propagate: function() {},
	    getProp: function() { return ANull; },
	    forAllProps: function() {},
	    hasType: function() { return false; },
	    isEmpty: function() { return true; },
	    getFunctionType: function() {},
	    getObjType: function() {},
	    getSymbolType: function() {},
	    getType: function() {},
	    gatherProperties: function() {},
	    propagatesTo: function() {},
	    typeHint: function() {},
	    propHint: function() {},
	    toString: function() { return "?"; }
	  });

	  function extend(proto, props) {
	    var obj = Object.create(proto);
	    if (props) for (var prop in props) obj[prop] = props[prop];
	    return obj;
	  }

	  // ABSTRACT VALUES

	  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10,
	      WG_MULTI_MEMBER = 6, WG_CATCH_ERROR = 6,
	      WG_PHANTOM_OBJ = 1,
	      WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2, WG_SPECULATIVE_PROTO_THIS = 4;

	  var AVal = exports.AVal = function() {
	    this.types = [];
	    this.forward = null;
	    this.maxWeight = 0;
	  };
	  AVal.prototype = extend(ANull, {
	    addType: function(type, weight) {
	      weight = weight || WG_DEFAULT;
	      if (this.maxWeight < weight) {
	        this.maxWeight = weight;
	        if (this.types.length == 1 && this.types[0] == type) return;
	        this.types.length = 0;
	      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {
	        return;
	      }

	      this.signal("addType", type);
	      this.types.push(type);
	      var forward = this.forward;
	      if (forward) withWorklist(function(add) {
	        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);
	      });
	    },

	    propagate: function(target, weight) {
	      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;
	      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);
	      (this.forward || (this.forward = [])).push(target);
	      var types = this.types;
	      if (types.length) withWorklist(function(add) {
	        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);
	      });
	    },

	    getProp: function(prop) {
	      if (prop == "__proto__" || prop == "✖") return ANull;
	      var found = (this.props || (this.props = Object.create(null)))[prop];
	      if (!found) {
	        found = this.props[prop] = new AVal;
	        this.propagate(new GetProp(prop, found));
	      }
	      return found;
	    },

	    forAllProps: function(c) {
	      this.propagate(new ForAllProps(c));
	    },

	    hasType: function(type) {
	      return this.types.indexOf(type) > -1;
	    },
	    isEmpty: function() { return this.types.length === 0; },
	    getFunctionType: function() {
	      for (var i = this.types.length - 1; i >= 0; --i)
	        if (this.types[i] instanceof Fn) return this.types[i];
	    },
	    getObjType: function() {
	      var seen = null;
	      for (var i = this.types.length - 1; i >= 0; --i) {
	        var type = this.types[i];
	        if (!(type instanceof Obj)) continue;
	        if (type.name) return type;
	        if (!seen) seen = type;
	      }
	      return seen;
	    },

	    getSymbolType: function() {
	      for (var i = this.types.length - 1; i >= 0; --i)
	        if (this.types[i] instanceof Sym) return this.types[i]
	    },

	    getType: function(guess) {
	      if (this.types.length === 0 && guess !== false) return this.makeupType();
	      if (this.types.length === 1) return this.types[0];
	      return canonicalType(this.types);
	    },

	    toString: function(maxDepth, parent) {
	      if (this.types.length == 0) return toString(this.makeupType(), maxDepth, parent);
	      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);
	      var simplified = simplifyTypes(this.types);
	      if (simplified.length > 2) return "?";
	      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join("|");
	    },

	    makeupPropType: function(obj) {
	      var propName = this.propertyName;

	      var protoProp = obj.proto && obj.proto.hasProp(propName);
	      if (protoProp) {
	        var fromProto = protoProp.getType();
	        if (fromProto) return fromProto;
	      }

	      if (propName != "<i>") {
	        var computedProp = obj.hasProp("<i>");
	        if (computedProp) return computedProp.getType();
	      } else if (obj.props["<i>"] != this) {
	        for (var prop in obj.props) {
	          var val = obj.props[prop];
	          if (!val.isEmpty()) return val.getType();
	        }
	      }
	    },

	    makeupType: function() {
	      var computed = this.propertyOf && this.makeupPropType(this.propertyOf);
	      if (computed) return computed;

	      if (!this.forward) return null;
	      for (var i = this.forward.length - 1; i >= 0; --i) {
	        var hint = this.forward[i].typeHint();
	        if (hint && !hint.isEmpty()) {guessing = true; return hint;}
	      }

	      var props = Object.create(null), foundProp = null;
	      for (var i = 0; i < this.forward.length; ++i) {
	        var prop = this.forward[i].propHint();
	        if (prop && prop != "length" && prop != "<i>" && prop != "✖" && prop != cx.completingProperty) {
	          props[prop] = true;
	          foundProp = prop;
	        }
	      }
	      if (!foundProp) return null;

	      var objs = objsWithProp(foundProp);
	      if (objs) {
	        var matches = [];
	        search: for (var i = 0; i < objs.length; ++i) {
	          var obj = objs[i];
	          for (var prop in props) if (!obj.hasProp(prop)) continue search;
	          if (obj.hasCtor) obj = getInstance(obj);
	          matches.push(obj);
	        }
	        var canon = canonicalType(matches);
	        if (canon) {guessing = true; return canon;}
	      }
	    },

	    typeHint: function() { return this.types.length ? this.getType() : null; },
	    propagatesTo: function() { return this; },

	    gatherProperties: function(f, depth) {
	      for (var i = 0; i < this.types.length; ++i)
	        this.types[i].gatherProperties(f, depth);
	    },

	    guessProperties: function(f) {
	      if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
	        var prop = this.forward[i].propHint();
	        if (prop) f(prop, null, 0);
	      }
	      var guessed = this.makeupType();
	      if (guessed) guessed.gatherProperties(f);
	    }
	  });

	  function similarAVal(a, b, depth) {
	    var typeA = a.getType(false), typeB = b.getType(false);
	    if (!typeA || !typeB) return true;
	    return similarType(typeA, typeB, depth);
	  }

	  function similarType(a, b, depth) {
	    if (!a || depth >= 5) return b;
	    if (!a || a == b) return a;
	    if (!b) return a;
	    if (a.constructor != b.constructor) return false;
	    if (a.constructor == Arr) {
	      var innerA = a.getProp("<i>").getType(false);
	      if (!innerA) return b;
	      var innerB = b.getProp("<i>").getType(false);
	      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;
	    } else if (a.constructor == Obj) {
	      var propsA = 0, propsB = 0, same = 0;
	      for (var prop in a.props) {
	        propsA++;
	        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))
	          same++;
	      }
	      for (var prop in b.props) propsB++;
	      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;
	      return propsA > propsB ? a : b;
	    } else if (a.constructor == Fn) {
	      if (a.args.length != b.args.length ||
	          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||
	          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))
	        return false;
	      return a;
	    } else {
	      return false;
	    }
	  }

	  var simplifyTypes = exports.simplifyTypes = function(types) {
	    var found = [];
	    outer: for (var i = 0; i < types.length; ++i) {
	      var tp = types[i];
	      for (var j = 0; j < found.length; j++) {
	        var similar = similarType(tp, found[j], 0);
	        if (similar) {
	          found[j] = similar;
	          continue outer;
	        }
	      }
	      found.push(tp);
	    }
	    return found;
	  };

	  function canonicalType(types) {
	    var arrays = 0, fns = 0, objs = 0, prim = null;
	    for (var i = 0; i < types.length; ++i) {
	      var tp = types[i];
	      if (tp instanceof Arr) ++arrays;
	      else if (tp instanceof Fn) ++fns;
	      else if (tp instanceof Obj) ++objs;
	      else if (tp instanceof Prim) {
	        if (prim && tp.name != prim.name) return null;
	        prim = tp;
	      }
	    }
	    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);
	    if (kinds > 1) return null;
	    if (prim) return prim;

	    var maxScore = 0, maxTp = null;
	    for (var i = 0; i < types.length; ++i) {
	      var tp = types[i], score = 0;
	      if (arrays) {
	        score = tp.getProp("<i>").isEmpty() ? 1 : 2;
	      } else if (fns) {
	        score = 1;
	        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;
	        if (!tp.retval.isEmpty()) ++score;
	      } else if (objs) {
	        score = tp.name ? 100 : 2;
	      }
	      if (score >= maxScore) { maxScore = score; maxTp = tp; }
	    }
	    return maxTp;
	  }

	  // PROPAGATION STRATEGIES

	  var constraint = exports.constraint = function(methods) {
	    var ctor = function() {
	      this.origin = cx.curOrigin;
	      this.construct.apply(this, arguments);
	    };
	    ctor.prototype = Object.create(ANull);
	    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];
	    return ctor;
	  };

	  var GetProp = constraint({
	    construct: function(prop, target) {
	      this.prop = prop; this.target = target;
	    },
	    addType: function(type, weight) {
	      if (type.getProp)
	        type.getProp(this.prop).propagate(this.target, weight);
	    },
	    propHint: function() { return this.prop; },
	    propagatesTo: function() {
	      if (this.prop == "<i>" || !/[^\w_]/.test(this.prop))
	        return {target: this.target, pathExt: "." + this.prop};
	    }
	  });

	  var DefProp = exports.PropHasSubset = exports.DefProp = constraint({
	    construct: function(prop, type, originNode) {
	      this.prop = prop; this.type = type; this.originNode = originNode;
	    },
	    addType: function(type, weight) {
	      if (!(type instanceof Obj)) return;
	      var prop = type.defProp(this.prop, this.originNode);
	      if (!prop.origin) prop.origin = this.origin;
	      this.type.propagate(prop, weight);
	    },
	    propHint: function() { return this.prop; }
	  });

	  var ForAllProps = constraint({
	    construct: function(c) { this.c = c; },
	    addType: function(type) {
	      if (!(type instanceof Obj)) return;
	      type.forAllProps(this.c);
	    }
	  });

	  function withDisabledComputing(fn, body) {
	    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};
	    var result = body();
	    cx.disabledComputing = cx.disabledComputing.prev;
	    return result;
	  }
	  var IsCallee = exports.IsCallee = constraint({
	    construct: function(self, args, argNodes, retval) {
	      this.self = self; this.args = args; this.argNodes = argNodes; this.retval = retval;
	      this.disabled = cx.disabledComputing;
	    },
	    addType: function(fn, weight) {
	      if (!(fn instanceof Fn)) return;
	      for (var i = 0; i < this.args.length; ++i) {
	        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);
	        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);
	      }
	      this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);
	      var compute = fn.computeRet, result = fn.retval
	      if (compute) for (var d = this.disabled; d; d = d.prev)
	        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;
	      if (compute) {
	        var old = cx.disabledComputing;
	        cx.disabledComputing = this.disabled;
	        result = compute(this.self, this.args, this.argNodes)
	        cx.disabledComputing = old;
	      }
	      maybeIterator(fn, result).propagate(this.retval, weight)
	    },
	    typeHint: function() {
	      var names = [];
	      for (var i = 0; i < this.args.length; ++i) names.push("?");
	      return new Fn(null, this.self, this.args, names, ANull);
	    },
	    propagatesTo: function() {
	      return {target: this.retval, pathExt: ".!ret"};
	    }
	  });

	  var HasMethodCall = constraint({
	    construct: function(propName, args, argNodes, retval) {
	      this.propName = propName; this.args = args; this.argNodes = argNodes; this.retval = retval;
	      this.disabled = cx.disabledComputing;
	    },
	    addType: function(obj, weight) {
	      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);
	      callee.disabled = this.disabled;
	      obj.getProp(this.propName).propagate(callee, weight);
	    },
	    propHint: function() { return this.propName; }
	  });

	  var IsCtor = exports.IsCtor = constraint({
	    construct: function(target, noReuse) {
	      this.target = target; this.noReuse = noReuse;
	    },
	    addType: function(f, weight) {
	      if (!(f instanceof Fn)) return;
	      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;
	      f.getProp("prototype").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);
	    }
	  });

	  var getInstance = exports.getInstance = function(obj, ctor) {
	    if (ctor === false) return new Obj(obj);

	    if (!ctor) ctor = obj.hasCtor;
	    if (!obj.instances) obj.instances = [];
	    for (var i = 0; i < obj.instances.length; ++i) {
	      var cur = obj.instances[i];
	      if (cur.ctor == ctor) return cur.instance;
	    }
	    var instance = new Obj(obj, ctor && ctor.name);
	    instance.origin = obj.origin;
	    obj.instances.push({ctor: ctor, instance: instance});
	    return instance;
	  };

	  var IsProto = exports.IsProto = constraint({
	    construct: function(ctor, target) {
	      this.ctor = ctor; this.target = target;
	    },
	    addType: function(o, _weight) {
	      if (!(o instanceof Obj)) return;
	      if ((this.count = (this.count || 0) + 1) > 8) return;
	      if (o == cx.protos.Array)
	        this.target.addType(new Arr);
	      else
	        this.target.addType(getInstance(o, this.ctor));
	    }
	  });

	  var FnPrototype = constraint({
	    construct: function(fn) { this.fn = fn; },
	    addType: function(o, _weight) {
	      if (o instanceof Obj && !o.hasCtor) {
	        o.hasCtor = this.fn;
	        var adder = new SpeculativeThis(o, this.fn);
	        adder.addType(this.fn);
	        o.forAllProps(function(_prop, val, local) {
	          if (local) val.propagate(adder);
	        });
	      }
	    }
	  });

	  var IsAdded = constraint({
	    construct: function(other, target) {
	      this.other = other; this.target = target;
	    },
	    addType: function(type, weight) {
	      if (type == cx.str)
	        this.target.addType(cx.str, weight);
	      else if (type == cx.num && this.other.hasType(cx.num))
	        this.target.addType(cx.num, weight);
	    },
	    typeHint: function() { return this.other; }
	  });

	  var IfObj = exports.IfObj = constraint({
	    construct: function(target) { this.target = target; },
	    addType: function(t, weight) {
	      if (t instanceof Obj) this.target.addType(t, weight);
	    },
	    propagatesTo: function() { return this.target; }
	  });

	  var SpeculativeThis = constraint({
	    construct: function(obj, ctor) { this.obj = obj; this.ctor = ctor; },
	    addType: function(tp) {
	      if (tp instanceof Fn && tp.self)
	        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_PROTO_THIS);
	    }
	  });

	  var HasProto = constraint({
	    construct: function(obj) { this.obj = obj },
	    addType: function(tp) {
	      if (tp instanceof Obj && this.obj.proto == cx.protos.Object)
	        this.obj.replaceProto(tp)
	    }
	  });

	  var Muffle = constraint({
	    construct: function(inner, weight) {
	      this.inner = inner; this.weight = weight;
	    },
	    addType: function(tp, weight) {
	      this.inner.addType(tp, Math.min(weight, this.weight));
	    },
	    propagatesTo: function() { return this.inner.propagatesTo(); },
	    typeHint: function() { return this.inner.typeHint(); },
	    propHint: function() { return this.inner.propHint(); }
	  });

	  // TYPE OBJECTS

	  var Type = exports.Type = function() {};
	  Type.prototype = extend(ANull, {
	    constructor: Type,
	    propagate: function(c, w) { c.addType(this, w); },
	    hasType: function(other) { return other == this; },
	    isEmpty: function() { return false; },
	    typeHint: function() { return this; },
	    getType: function() { return this; }
	  });

	  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };
	  Prim.prototype = extend(Type.prototype, {
	    constructor: Prim,
	    toString: function() { return this.name; },
	    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},
	    gatherProperties: function(f, depth) {
	      if (this.proto) this.proto.gatherProperties(f, depth);
	    }
	  });

	  function isInteger(str) {
	    var c0 = str.charCodeAt(0)
	    if (c0 >= 48 && c0 <= 57) return !/\D/.test(str)
	    else return false
	  }

	  var Obj = exports.Obj = function(proto, name) {
	    if (!this.props) this.props = Object.create(null);
	    this.proto = proto === true ? cx.protos.Object : proto;
	    if (proto && !name && proto.name && !(this instanceof Fn)) {
	      var match = /^(.*)\.prototype$/.exec(this.proto.name);
	      if (match) name = match[1];
	    }
	    this.name = name;
	    this.maybeProps = null;
	    this.origin = cx.curOrigin;
	  };
	  Obj.prototype = extend(Type.prototype, {
	    constructor: Obj,
	    toString: function(maxDepth) {
	      if (maxDepth == null) maxDepth = 0;
	      if (maxDepth <= 0 && this.name) return this.name;
	      var props = [], etc = false;
	      for (var prop in this.props) if (prop != "<i>") {
	        if (props.length > 5) { etc = true; break; }
	        if (maxDepth)
	          props.push(prop + ": " + toString(this.props[prop], maxDepth - 1, this));
	        else
	          props.push(prop);
	      }
	      props.sort();
	      if (etc) props.push("...");
	      return "{" + props.join(", ") + "}";
	    },
	    hasProp: function(prop, searchProto) {
	      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
	      var found = this.props[prop];
	      if (searchProto !== false)
	        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];
	      return found;
	    },
	    defProp: function(prop, originNode) {
	      var found = this.hasProp(prop, false);
	      if (found) {
	        if (originNode && !found.originNode) found.originNode = originNode;
	        return found;
	      }
	      if (prop == "__proto__" || prop == "✖") return ANull;
	      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)

	      var av = this.maybeProps && this.maybeProps[prop];
	      if (av) {
	        delete this.maybeProps[prop];
	        this.maybeUnregProtoPropHandler();
	      } else {
	        av = new AVal;
	        av.propertyOf = this;
	        av.propertyName = prop;
	      }

	      this.props[prop] = av;
	      av.originNode = originNode;
	      av.origin = cx.curOrigin;
	      this.broadcastProp(prop, av, true);
	      return av;
	    },
	    getProp: function(prop) {
	      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);
	      if (found) return found;
	      if (prop == "__proto__" || prop == "✖") return ANull;
	      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
	      var av = this.ensureMaybeProps()[prop] = new AVal;
	      av.propertyOf = this;
	      av.propertyName = prop;
	      return av;
	    },
	    normalizeIntegerProp: function(_) { return "<i>" },
	    broadcastProp: function(prop, val, local) {
	      if (local) {
	        this.signal("addProp", prop, val);
	        // If this is a scope, it shouldn't be registered
	        if (!(this instanceof Scope)) registerProp(prop, this);
	      }

	      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {
	        var h = this.onNewProp[i];
	        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);
	      }
	    },
	    onProtoProp: function(prop, val, _local) {
	      var maybe = this.maybeProps && this.maybeProps[prop];
	      if (maybe) {
	        delete this.maybeProps[prop];
	        this.maybeUnregProtoPropHandler();
	        this.proto.getProp(prop).propagate(maybe);
	      }
	      this.broadcastProp(prop, val, false);
	    },
	    replaceProto: function(proto) {
	      if (this.proto && this.maybeProps)
	        this.proto.unregPropHandler(this)
	      this.proto = proto
	      if (this.maybeProps)
	        this.proto.forAllProps(this)
	    },
	    ensureMaybeProps: function() {
	      if (!this.maybeProps) {
	        if (this.proto) this.proto.forAllProps(this);
	        this.maybeProps = Object.create(null);
	      }
	      return this.maybeProps;
	    },
	    removeProp: function(prop) {
	      var av = this.props[prop];
	      delete this.props[prop];
	      this.ensureMaybeProps()[prop] = av;
	      av.types.length = 0;
	    },
	    forAllProps: function(c) {
	      if (!this.onNewProp) {
	        this.onNewProp = [];
	        if (this.proto) this.proto.forAllProps(this);
	      }
	      this.onNewProp.push(c);
	      for (var o = this; o; o = o.proto) for (var prop in o.props) {
	        if (c.onProtoProp)
	          c.onProtoProp(prop, o.props[prop], o == this);
	        else
	          c(prop, o.props[prop], o == this);
	      }
	    },
	    maybeUnregProtoPropHandler: function() {
	      if (this.maybeProps) {
	        for (var _n in this.maybeProps) return;
	        this.maybeProps = null;
	      }
	      if (!this.proto || this.onNewProp && this.onNewProp.length) return;
	      this.proto.unregPropHandler(this);
	    },
	    unregPropHandler: function(handler) {
	      for (var i = 0; i < this.onNewProp.length; ++i)
	        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }
	      this.maybeUnregProtoPropHandler();
	    },
	    gatherProperties: function(f, depth) {
	      for (var prop in this.props) if (prop != "<i>" && prop.charAt(0) != ":")
	        f(prop, this, depth);
	      if (this.proto) this.proto.gatherProperties(f, depth + 1);
	    },
	    getObjType: function() { return this; }
	  });

	  var Fn = exports.Fn = function(name, self, args, argNames, retval, generator) {
	    Obj.call(this, cx.protos.Function, name);
	    this.self = self;
	    this.args = args;
	    this.argNames = argNames;
	    this.retval = retval;
	    this.generator = generator
	  };
	  Fn.prototype = extend(Obj.prototype, {
	    constructor: Fn,
	    toString: function(maxDepth) {
	      if (maxDepth == null) maxDepth = 0;
	      var str = this.generator ? "fn*(" : "fn(";
	      for (var i = 0; i < this.args.length; ++i) {
	        if (i) str += ", ";
	        var name = this.argNames[i];
	        if (name && name != "?") str += name + ": ";
	        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : "?";
	      }
	      str += ")";
	      if (!this.retval.isEmpty())
	        str += " -> " + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : "?");
	      return str;
	    },
	    getProp: function(prop) {
	      if (prop == "prototype") {
	        var known = this.hasProp(prop, false);
	        if (!known) {
	          known = this.defProp(prop);
	          var proto = new Obj(true, this.name && this.name + ".prototype");
	          proto.origin = this.origin;
	          known.addType(proto, WG_MADEUP_PROTO);
	        }
	        return known;
	      }
	      return Obj.prototype.getProp.call(this, prop);
	    },
	    defProp: function(prop, originNode) {
	      if (prop == "prototype") {
	        var found = this.hasProp(prop, false);
	        if (found) return found;
	        found = Obj.prototype.defProp.call(this, prop, originNode);
	        found.origin = this.origin;
	        found.propagate(new FnPrototype(this));
	        return found;
	      }
	      return Obj.prototype.defProp.call(this, prop, originNode);
	    },
	    getFunctionType: function() { return this; }
	  });

	  var Arr = exports.Arr = function(contentType) {
	    Obj.call(this, cx.protos.Array)
	    var content = this.defProp("<i>")
	    if (Array.isArray(contentType)) {
	      this.tuple = contentType.length
	      for (var i = 0; i < contentType.length; i++) {
	        var prop = this.defProp(String(i))
	        contentType[i].propagate(prop)
	        prop.propagate(content)
	      }
	    } else if (contentType) {
	      this.tuple = 0
	      contentType.propagate(content)
	    }
	  };
	  Arr.prototype = extend(Obj.prototype, {
	    constructor: Arr,
	    toString: function(maxDepth) {
	      if (maxDepth == null) maxDepth = 0
	      if (maxDepth <= -3) return "[?]"
	      var content = ""
	      if (this.tuple) {
	        var similar
	        for (var i = 0; i in this.props; i++) {
	          var type = toString(this.getProp(String(i)), maxDepth - 1, this)
	          if (similar == null)
	            similar = type
	          else if (similar != type)
	            similar = false
	          else
	            similar = type
	          content += (content ? ", " : "") + type
	        }
	        if (similar) content = similar
	      } else {
	        content = toString(this.getProp("<i>"), maxDepth - 1, this)
	      }
	      return "[" + content + "]"
	    },
	    normalizeIntegerProp: function(prop) {
	      if (+prop < this.tuple) return prop
	      else return "<i>"
	    }
	  });

	  var Sym = exports.Sym = function(name, originNode) {
	    Prim.call(this, cx.protos.Symbol, "Symbol")
	    this.symName = name
	    this.originNode = originNode
	  }
	  Sym.prototype = extend(Prim.prototype, {
	    constructor: Sym,
	    asPropName: function() { return ":" + this.symName },
	    getSymbolType: function() { return this }
	  })

	  exports.getSymbol = function(name, originNode) {
	    var cleanName = name.replace(/[^\w$\.]/g, "_")
	    var known = cx.symbols[cleanName]
	    if (known) {
	      if (originNode && !known.originNode) known.originNode = originNode
	      return known
	    }
	    return cx.symbols[cleanName] = new Sym(cleanName, originNode)
	  }

	  // THE PROPERTY REGISTRY

	  function registerProp(prop, obj) {
	    var data = cx.props[prop] || (cx.props[prop] = []);
	    data.push(obj);
	  }

	  function objsWithProp(prop) {
	    return cx.props[prop];
	  }

	  // INFERENCE CONTEXT

	  exports.Context = function(defs, parent) {
	    this.parent = parent;
	    this.props = Object.create(null);
	    this.protos = Object.create(null);
	    this.origins = [];
	    this.curOrigin = "ecma5";
	    this.paths = Object.create(null);
	    this.definitions = Object.create(null);
	    this.purgeGen = 0;
	    this.workList = null;
	    this.disabledComputing = null;
	    this.curSuperCtor = this.curSuper = null;
	    this.symbols = Object.create(null)

	    exports.withContext(this, function() {
	      cx.protos.Object = new Obj(null, "Object.prototype");
	      cx.topScope = new Scope();
	      cx.topScope.name = "<top>";
	      cx.protos.Array = new Obj(true, "Array.prototype");
	      cx.protos.Function = new Fn("Function.prototype", ANull, [], [], ANull);
	      cx.protos.Function.proto = cx.protos.Object;
	      cx.protos.RegExp = new Obj(true, "RegExp.prototype");
	      cx.protos.String = new Obj(true, "String.prototype");
	      cx.protos.Number = new Obj(true, "Number.prototype");
	      cx.protos.Boolean = new Obj(true, "Boolean.prototype");
	      cx.protos.Symbol = new Obj(true, "Symbol.prototype");
	      cx.str = new Prim(cx.protos.String, "string");
	      cx.bool = new Prim(cx.protos.Boolean, "bool");
	      cx.num = new Prim(cx.protos.Number, "number");
	      cx.curOrigin = null;

	      if (defs) for (var i = 0; i < defs.length; ++i)
	        def.load(defs[i]);
	    });
	  };

	  exports.Context.prototype.startAnalysis = function() {
	    this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;
	  };

	  var cx = null;
	  exports.cx = function() { return cx; };

	  exports.withContext = function(context, f) {
	    var old = cx;
	    cx = context;
	    try { return f(); }
	    finally { cx = old; }
	  };

	  exports.TimedOut = function() {
	    this.message = "Timed out";
	    this.stack = (new Error()).stack;
	  };
	  exports.TimedOut.prototype = Object.create(Error.prototype);
	  exports.TimedOut.prototype.name = "infer.TimedOut";

	  var timeout;
	  exports.withTimeout = function(ms, f) {
	    var end = +new Date + ms;
	    var oldEnd = timeout;
	    if (oldEnd && oldEnd < end) return f();
	    timeout = end;
	    try { return f(); }
	    finally { timeout = oldEnd; }
	  };

	  exports.addOrigin = function(origin) {
	    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);
	  };

	  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;
	  function withWorklist(f) {
	    if (cx.workList) return f(cx.workList);

	    var list = [], depth = 0;
	    var add = cx.workList = function(type, target, weight) {
	      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)
	        list.push(type, target, weight, depth);
	    };
	    var ret = f(add);
	    for (var i = 0; i < list.length; i += 4) {
	      if (timeout && +new Date >= timeout)
	        throw new exports.TimedOut();
	      depth = list[i + 3] + 1;
	      list[i + 1].addType(list[i], list[i + 2]);
	    }
	    cx.workList = null;
	    return ret;
	  }

	  function withSuper(ctor, obj, f) {
	    var oldCtor = cx.curSuperCtor, oldObj = cx.curSuper
	    cx.curSuperCtor = ctor; cx.curSuper = obj
	    var result = f()
	    cx.curSuperCtor = oldCtor; cx.curSuper = oldObj
	    return result
	  }

	  // SCOPES

	  var Scope = exports.Scope = function(prev, originNode, isBlock) {
	    Obj.call(this, prev || true);
	    this.prev = prev;
	    this.originNode = originNode
	    this.isBlock = !!isBlock
	  };
	  Scope.prototype = extend(Obj.prototype, {
	    constructor: Scope,
	    defVar: function(name, originNode) {
	      for (var s = this; ; s = s.proto) {
	        var found = s.props[name];
	        if (found) return found;
	        if (!s.prev) return s.defProp(name, originNode);
	      }
	    }
	  });

	  function functionScope(scope) {
	    while (scope.isBlock) scope = scope.prev
	    return scope
	  }


	  // RETVAL COMPUTATION HEURISTICS

	  function maybeInstantiate(scope, score) {
	    var fn = functionScope(scope).fnType
	    if (fn) fn.instantiateScore = (fn.instantiateScore || 0) + score;
	  }

	  var NotSmaller = {};
	  function nodeSmallerThan(node, n) {
	    try {
	      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});
	      return true;
	    } catch(e) {
	      if (e == NotSmaller) return false;
	      throw e;
	    }
	  }

	  function maybeTagAsInstantiated(node, fn) {
	    var score = fn.instantiateScore;
	    if (!cx.disabledComputing && score && fn.args.length && nodeSmallerThan(node, score * 5)) {
	      maybeInstantiate(functionScope(fn.originNode.scope.prev), score / 2);
	      setFunctionInstantiated(node, fn);
	      return true;
	    } else {
	      fn.instantiateScore = null;
	    }
	  }

	  function setFunctionInstantiated(node, fn) {
	    // Disconnect the arg avals, so that we can add info to them without side effects
	    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;
	    fn.self = new AVal;
	    fn.computeRet = function(self, args) {
	      // Prevent recursion
	      return withDisabledComputing(fn, function() {
	        var oldOrigin = cx.curOrigin;
	        cx.curOrigin = fn.origin;
	        var scope = node.scope
	        var scopeCopy = new Scope(scope.prev, scope.originNode);
	        for (var v in scope.props) {
	          var local = scopeCopy.defProp(v, scope.props[v].originNode);
	          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)
	            args[i].propagate(local);
	        }
	        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;
	        while (argNames.length < args.length) argNames.push("?");
	        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull, fn.generator);
	        scopeCopy.fnType.originNode = fn.originNode;
	        if (fn.arguments) {
	          var argset = scopeCopy.fnType.arguments = new AVal;
	          scopeCopy.defProp("arguments").addType(new Arr(argset));
	          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);
	        }
	        node.scope = scopeCopy;
	        walk.recursive(node.body, scopeCopy, null, scopeGatherer);
	        walk.recursive(node.body, scopeCopy, null, inferWrapper);
	        cx.curOrigin = oldOrigin;
	        return scopeCopy.fnType.retval;
	      });
	    };
	  }

	  function maybeTagAsGeneric(fn) {
	    var target = fn.retval;
	    if (target == ANull) return;
	    var targetInner, asArray;
	    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)
	      target = asArray = targetInner.getProp("<i>");

	    function explore(aval, path, depth) {
	      if (depth > 3 || !aval.forward) return;
	      for (var i = 0; i < aval.forward.length; ++i) {
	        var prop = aval.forward[i].propagatesTo();
	        if (!prop) continue;
	        var newPath = path, dest;
	        if (prop instanceof AVal) {
	          dest = prop;
	        } else if (prop.target instanceof AVal) {
	          newPath += prop.pathExt;
	          dest = prop.target;
	        } else continue;
	        if (dest == target) return newPath;
	        var found = explore(dest, newPath, depth + 1);
	        if (found) return found;
	      }
	    }

	    var foundPath = explore(fn.self, "!this", 0);
	    for (var i = 0; !foundPath && i < fn.args.length; ++i)
	      foundPath = explore(fn.args[i], "!" + i, 0);

	    if (foundPath) {
	      if (asArray) foundPath = "[" + foundPath + "]";
	      var p = new def.TypeParser(foundPath);
	      var parsed = p.parseType(true);
	      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };
	      fn.computeRetSource = foundPath;
	      return true;
	    }
	  }

	  // SCOPE GATHERING PASS

	  function addVar(scope, nameNode) {
	    return scope.defProp(nameNode.name, nameNode);
	  }
	  function patternName(node) {
	    if (node.type == "Identifier") return node.name
	    if (node.type == "AssignmentPattern") return patternName(node.left)
	    if (node.type == "ObjectPattern") return "{" + node.properties.map(function(e) { return patternName(e.value) }).join(", ") + "}"
	    if (node.type == "ArrayPattern") return "[" + node.elements.map(patternName).join(", ") + "]"
	    if (node.type == "RestElement") return "..." + patternName(node.argument)
	    return "_"
	  }

	  function isBlockScopedDecl(node) {
	    return node.type == "VariableDeclaration" && node.kind != "var" ||
	      node.type == "FunctionDeclaration" ||
	      node.type == "ClassDeclaration";
	  }

	  function patternScopes(inner, outer) {
	    return {inner: inner, outer: outer || inner}
	  }

	  var scopeGatherer = exports.scopeGatherer = walk.make({
	    VariablePattern: function(node, scopes) {
	      if (scopes.inner) addVar(scopes.inner, node)
	    },
	    AssignmentPattern: function(node, scopes, c) {
	      c(node.left, scopes, "Pattern")
	      c(node.right, scopes.outer, "Expression")
	    },
	    AssignmentExpression: function(node, scope, c) {
	      if (node.left.type == "MemberExpression")
	        c(node.left, scope, "Expression")
	      else
	        c(node.left, patternScopes(false, scope), "Pattern")
	      c(node.right, scope, "Expression")
	    },
	    Function: function(node, scope, c) {
	      var inner = node.scope = new Scope(scope, node)
	      var argVals = [], argNames = []
	      for (var i = 0; i < node.params.length; ++i) {
	        var param = node.params[i]
	        argNames.push(patternName(param))
	        if (param.type == "Identifier") {
	          argVals.push(addVar(inner, param))
	        } else {
	          var arg = new AVal
	          argVals.push(arg)
	          arg.originNode = param
	          c(param, patternScopes(inner), "Pattern")
	        }
	      }
	      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull, node.generator)
	      inner.fnType.originNode = node;
	      if (node.id) {
	        var decl = node.type == "FunctionDeclaration";
	        addVar(decl ? scope : inner, node.id);
	      }
	      c(node.body, inner, node.expression ? "Expression" : "Statement");
	    },
	    BlockStatement: function(node, scope, c) {
	      if (!node.scope && node.body.some(isBlockScopedDecl))
	        scope = node.scope = new Scope(scope, node, true)
	      walk.base.BlockStatement(node, scope, c)
	    },
	    TryStatement: function(node, scope, c) {
	      c(node.block, scope, "Statement");
	      if (node.handler) {
	        if (node.handler.param.type == "Identifier") {
	          var v = addVar(scope, node.handler.param);
	          c(node.handler.body, scope, "Statement");
	          var e5 = cx.definitions.ecma5;
	          if (e5 && v.isEmpty()) getInstance(e5["Error.prototype"]).propagate(v, WG_CATCH_ERROR);
	        } else {
	          c(node.handler.param, patternScopes(scope), "Pattern")
	        }
	      }
	      if (node.finalizer) c(node.finalizer, scope, "Statement");
	    },
	    VariableDeclaration: function(node, scope, c) {
	      var targetScope = node.kind == "var" ? functionScope(scope) : scope
	      for (var i = 0; i < node.declarations.length; ++i) {
	        var decl = node.declarations[i];
	        c(decl.id, patternScopes(targetScope, scope), "Pattern")
	        if (decl.init) c(decl.init, scope, "Expression");
	      }
	    },
	    ClassDeclaration: function(node, scope, c) {
	      addVar(scope, node.id)
	      if (node.superClass) c(node.superClass, scope, "Expression")
	      for (var i = 0; i < node.body.body.length; i++)
	        c(node.body.body[i], scope)
	    },
	    ForInStatement: function(node, scope, c) {
	      if (!node.scope && isBlockScopedDecl(node.left))
	        scope = node.scope = new Scope(scope, node, true)
	      walk.base.ForInStatement(node, scope, c)
	    },
	    ForStatement: function(node, scope, c) {
	      if (!node.scope && node.init && isBlockScopedDecl(node.init))
	        scope = node.scope = new Scope(scope, node, true)
	      walk.base.ForStatement(node, scope, c)
	    },
	    ImportDeclaration: function(node, scope) {
	      for (var i = 0; i < node.specifiers.length; i++)
	        addVar(scope, node.specifiers[i].local)
	    }
	  });
	  scopeGatherer.ForOfStatement = scopeGatherer.ForInStatement

	  // CONSTRAINT GATHERING PASS

	  var propName = exports.propName = function(node, inferInScope) {
	    var key = node.property || node.key;
	    if (!node.computed && key.type == "Identifier") return key.name;
	    if (key.type == "Literal") {
	      if (typeof key.value == "string") return key.value
	      if (typeof key.value == "number") return String(key.value)
	    }
	    if (inferInScope) {
	      var symName = symbolName(infer(key, inferInScope))
	      if (symName) return node.propName = symName
	    } else if (node.propName) {
	      return node.propName
	    }
	    return "<i>";
	  }
	  function symbolName(val) {
	    var sym = val.getSymbolType()
	    if (sym) return sym.asPropName()
	  }

	  function unopResultType(op) {
	    switch (op) {
	    case "+": case "-": case "~": return cx.num;
	    case "!": return cx.bool;
	    case "typeof": return cx.str;
	    case "void": case "delete": return ANull;
	    }
	  }
	  function binopIsBoolean(op) {
	    switch (op) {
	    case "==": case "!=": case "===": case "!==": case "<": case ">": case ">=": case "<=":
	    case "in": case "instanceof": return true;
	    }
	  }
	  function literalType(node) {
	    if (node.regex) return getInstance(cx.protos.RegExp);
	    switch (typeof node.value) {
	    case "boolean": return cx.bool;
	    case "number": return cx.num;
	    case "string": return cx.str;
	    case "object":
	    case "function":
	      if (!node.value) return ANull;
	      return getInstance(cx.protos.RegExp);
	    }
	  }

	  function join(a, b) {
	    if (a == b || b == ANull) return a
	    if (a == ANull) return b
	    var joined = new AVal
	    a.propagate(joined)
	    b.propagate(joined)
	    return joined
	  }

	  function connectParams(node, scope) {
	    for (var i = 0; i < node.params.length; i++) {
	      var param = node.params[i]
	      if (param.type == "Identifier") continue
	      connectPattern(param, scope, node.scope.fnType.args[i])
	    }
	  }

	  function ensureVar(node, scope) {
	    return scope.hasProp(node.name) || cx.topScope.defProp(node.name, node)
	  }

	  var inferPatternVisitor = exports.inferPatternVisitor = {
	    Identifier: function(node, scope, source) {
	      source.propagate(ensureVar(node, scope))
	    },
	    MemberExpression: function(node, scope, source) {
	      var obj = infer(node.object, scope)
	      var pName = propName(node, scope)
	      obj.propagate(new DefProp(pName, source, node.property))
	    },
	    RestElement: function(node, scope, source) {
	      connectPattern(node.argument, scope, new Arr(source))
	    },
	    ObjectPattern: function(node, scope, source) {
	      for (var i = 0; i < node.properties.length; ++i) {
	        var prop = node.properties[i]
	        connectPattern(prop.value, scope, source.getProp(prop.key.name))
	      }
	    },
	    ArrayPattern: function(node, scope, source) {
	      for (var i = 0; i < node.elements.length; i++)
	        if (node.elements[i])
	          connectPattern(node.elements[i], scope, source.getProp(String(i)))
	    },
	    AssignmentPattern: function(node, scope, source) {
	      connectPattern(node.left, scope, join(source, infer(node.right, scope)))
	    }
	  }

	  function connectPattern(node, scope, source) {
	    var connecter = inferPatternVisitor[node.type]
	    if (connecter) connecter(node, scope, source)
	  }

	  function getThis(scope) {
	    var fnScope = functionScope(scope)
	    return fnScope.fnType ? fnScope.fnType.self : fnScope
	  }

	  function maybeAddPhantomObj(obj) {
	    if (!obj.isEmpty() || !obj.propertyOf) return
	    obj.propertyOf.getProp(obj.propertyName).addType(new Obj, WG_PHANTOM_OBJ)
	    maybeAddPhantomObj(obj.propertyOf)
	  }

	  function inferClass(node, scope, name) {
	    if (!name && node.id) name = node.id.name

	    var sup = cx.protos.Object, supCtor, delayed
	    if (node.superClass) {
	      if (node.superClass.type == "Literal" && node.superClass.value == null) {
	        sup = null
	      } else {
	        var supVal = infer(node.superClass, scope), supProto
	        supCtor = supVal.getFunctionType()
	        if (supCtor && (supProto = supCtor.getProp("prototype").getObjType())) {
	          sup = supProto
	        } else {
	          supCtor = supVal
	          delayed = supVal.getProp("prototype")
	        }
	      }
	    }
	    var proto = new Obj(sup, name && name + ".prototype")
	    if (delayed) delayed.propagate(new HasProto(proto))

	    return withSuper(supCtor, delayed || sup, function() {
	      var ctor, body = node.body.body
	      for (var i = 0; i < body.length; i++)
	        if (body[i].kind == "constructor") ctor = body[i].value
	      var fn = node.objType = ctor ? infer(ctor, scope) : new Fn(name, ANull, [], null, ANull)
	      fn.originNode = node.id || ctor || node

	      var inst = getInstance(proto, fn)
	      fn.self.addType(inst)
	      fn.defProp("prototype", node).addType(proto)
	      for (var i = 0; i < body.length; i++) {
	        var method = body[i], target
	        if (method.kind == "constructor") continue
	        var pName = propName(method, scope)
	        if (pName == "<i>" || method.kind == "set") {
	          target = ANull
	        } else {
	          target = (method.static ? fn : proto).defProp(pName, method.key)
	          target.initializer = true
	          if (method.kind == "get") target = new IsCallee(inst, [], null, target)
	        }
	        infer(method.value, scope, target)
	        var methodFn = target.getFunctionType()
	        if (methodFn) methodFn.self.addType(inst)
	      }
	      return fn
	    })
	  }

	  function arrayLiteralType(elements, scope, inner) {
	    var tuple = elements.length > 1 && elements.length < 6
	    if (tuple) {
	      var homogenous = true, litType
	      for (var i = 0; i < elements.length; i++) {
	        var elt = elements[i]
	        if (!elt)
	          tuple = false
	        else if (elt.type != "Literal" || (litType && litType != typeof elt.value))
	          homogenous = false
	        else
	          litType = typeof elt.value
	      }
	      if (homogenous) tuple = false
	    }

	    if (tuple) {
	      var types = []
	      for (var i = 0; i < elements.length; ++i)
	        types.push(inner(elements[i], scope))
	      return new Arr(types)
	    } else if (elements.length < 2) {
	      return new Arr(elements[0] && inner(elements[0], scope))
	    } else {
	      var eltVal = new AVal
	      for (var i = 0; i < elements.length; i++)
	        if (elements[i]) inner(elements[i], scope).propagate(eltVal)
	      return new Arr(eltVal)
	    }
	  }

	  function ret(f) {
	    return function(node, scope, out, name) {
	      var r = f(node, scope, name);
	      if (out) r.propagate(out);
	      return r;
	    };
	  }
	  function fill(f) {
	    return function(node, scope, out, name) {
	      if (!out) out = new AVal;
	      f(node, scope, out, name);
	      return out;
	    };
	  }

	  var inferExprVisitor = exports.inferExprVisitor = {
	    ArrayExpression: ret(function(node, scope) {
	      return arrayLiteralType(node.elements, scope, infer)
	    }),
	    ObjectExpression: ret(function(node, scope, name) {
	      var proto = true, waitForProto
	      for (var i = 0; i < node.properties.length; ++i) {
	        var prop = node.properties[i]
	        if (prop.key.name == "__proto__") {
	          if (prop.value.type == "Literal" && prop.value.value == null) {
	            proto = null
	          } else {
	            var protoVal = infer(prop.value, scope), known = protoVal.getObjType()
	            if (known) proto = known
	            else waitForProto = protoVal
	          }
	        }
	      }

	      var obj = node.objType = new Obj(proto, name);
	      if (waitForProto) waitForProto.propagate(new HasProto(obj))
	      obj.originNode = node;

	      withSuper(null, waitForProto || proto, function() {
	        for (var i = 0; i < node.properties.length; ++i) {
	          var prop = node.properties[i], key = prop.key;
	          if (prop.value.name == "✖" || prop.key.name == "__proto__") continue;

	          var name = propName(prop, scope), target
	          if (name == "<i>" || prop.kind == "set") {
	            target = ANull;
	          } else {
	            var val = target = obj.defProp(name, key);
	            val.initializer = true;
	            if (prop.kind == "get")
	              target = new IsCallee(obj, [], null, val);
	          }
	          infer(prop.value, scope, target, name);
	          if (prop.value.type == "FunctionExpression")
	            prop.value.scope.fnType.self.addType(obj, WG_SPECULATIVE_THIS);
	        }
	      })
	      return obj;
	    }),
	    FunctionExpression: ret(function(node, scope, name) {
	      var inner = node.scope, fn = inner.fnType;
	      if (name && !fn.name) fn.name = name;
	      connectParams(node, inner)
	      if (node.expression)
	        infer(node.body, inner, inner.fnType.retval = new AVal)
	      else
	        walk.recursive(node.body, inner, null, inferWrapper, "Statement")
	      if (node.type == "ArrowFunctionExpression") {
	        getThis(scope).propagate(fn.self)
	        fn.self = ANull
	      }
	      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
	      if (node.id) inner.getProp(node.id.name).addType(fn);
	      return fn;
	    }),
	    ClassExpression: ret(inferClass),
	    SequenceExpression: ret(function(node, scope) {
	      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)
	        infer(node.expressions[i], scope, ANull);
	      return infer(node.expressions[l], scope);
	    }),
	    UnaryExpression: ret(function(node, scope) {
	      infer(node.argument, scope, ANull);
	      return unopResultType(node.operator);
	    }),
	    UpdateExpression: ret(function(node, scope) {
	      infer(node.argument, scope, ANull);
	      return cx.num;
	    }),
	    BinaryExpression: ret(function(node, scope) {
	      if (node.operator == "+") {
	        var lhs = infer(node.left, scope);
	        var rhs = infer(node.right, scope);
	        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
	        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;
	        var result = new AVal;
	        lhs.propagate(new IsAdded(rhs, result));
	        rhs.propagate(new IsAdded(lhs, result));
	        return result;
	      } else {
	        infer(node.left, scope, ANull);
	        infer(node.right, scope, ANull);
	        return binopIsBoolean(node.operator) ? cx.bool : cx.num;
	      }
	    }),
	    AssignmentExpression: ret(function(node, scope, name) {
	      var rhs, pName;
	      if (node.left.type == "MemberExpression") {
	        pName = propName(node.left, scope)
	        if (!name)
	          name = node.left.object.type == "Identifier" ? node.left.object.name + "." + pName : pName
	      } else if (!name && node.left.type == "Identifier") {
	        name = node.left.name
	      }

	      if (node.operator && node.operator != "=" && node.operator != "+=") {
	        infer(node.right, scope, ANull);
	        rhs = cx.num;
	      } else {
	        rhs = infer(node.right, scope, null, name);
	      }

	      if (node.left.type == "MemberExpression") {
	        var obj = infer(node.left.object, scope);
	        if (pName == "prototype") maybeInstantiate(scope, 20);
	        if (pName == "<i>") {
	          // This is a hack to recognize for/in loops that copy
	          // properties, and do the copying ourselves, insofar as we
	          // manage, because such loops tend to be relevant for type
	          // information.
	          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;
	          if (over) {
	            maybeInstantiate(scope, 20);
	            var fromRight = node.right.type == "MemberExpression" && node.right.computed && node.right.property.name == v;
	            over.forAllProps(function(prop, val, local) {
	              if (local && prop != "prototype" && prop != "<i>")
	                obj.propagate(new DefProp(prop, fromRight ? val : ANull));
	            });
	            return rhs;
	          }
	        }

	        obj.propagate(new DefProp(pName, rhs, node.left.property));
	        maybeAddPhantomObj(obj)
	        if (node.right.type == "FunctionExpression")
	          obj.propagate(node.right.scope.fnType.self, WG_SPECULATIVE_THIS);
	      } else {
	        connectPattern(node.left, scope, rhs)
	      }
	      return rhs;
	    }),
	    LogicalExpression: fill(function(node, scope, out) {
	      infer(node.left, scope, out);
	      infer(node.right, scope, out);
	    }),
	    ConditionalExpression: fill(function(node, scope, out) {
	      infer(node.test, scope, ANull);
	      infer(node.consequent, scope, out);
	      infer(node.alternate, scope, out);
	    }),
	    NewExpression: fill(function(node, scope, out, name) {
	      if (node.callee.type == "Identifier" && node.callee.name in scope.props)
	        maybeInstantiate(scope, 20);

	      for (var i = 0, args = []; i < node.arguments.length; ++i)
	        args.push(infer(node.arguments[i], scope));
	      var callee = infer(node.callee, scope);
	      var self = new AVal;
	      callee.propagate(new IsCtor(self, name && /\.prototype$/.test(name)));
	      self.propagate(out, WG_NEW_INSTANCE);
	      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));
	    }),
	    CallExpression: fill(function(node, scope, out) {
	      for (var i = 0, args = []; i < node.arguments.length; ++i)
	        args.push(infer(node.arguments[i], scope));
	      var outerFn = functionScope(scope).fnType
	      if (node.callee.type == "MemberExpression") {
	        var self = infer(node.callee.object, scope);
	        var pName = propName(node.callee, scope)
	        if (outerFn && (pName == "call" || pName == "apply") &&
	            outerFn.args.indexOf(self) > -1)
	          maybeInstantiate(scope, 30);
	        self.propagate(new HasMethodCall(pName, args, node.arguments, out));
	      } else if (node.callee.type == "Super" && cx.curSuperCtor) {
	        cx.curSuperCtor.propagate(new IsCallee(getThis(scope), args, node.arguments, out))
	      } else {
	        var callee = infer(node.callee, scope);
	        if (outerFn && outerFn.args.indexOf(callee) > -1)
	          maybeInstantiate(scope, 30);
	        var knownFn = callee.getFunctionType();
	        if (knownFn && knownFn.instantiateScore && outerFn)
	          maybeInstantiate(scope, knownFn.instantiateScore / 5);
	        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));
	      }
	    }),
	    MemberExpression: fill(function(node, scope, out) {
	      var name = propName(node), wg;
	      if (name == "<i>") {
	        var propType = infer(node.property, scope)
	        var symName = symbolName(propType)
	        if (symName)
	          name = node.propName = symName
	        else if (!propType.hasType(cx.num))
	          wg = WG_MULTI_MEMBER
	      }
	      infer(node.object, scope).getProp(name).propagate(out, wg)
	    }),
	    Identifier: ret(function(node, scope) {
	      if (node.name == "arguments") {
	        var fnScope = functionScope(scope)
	        if (fnScope.fnType && !(node.name in fnScope.props))
	          scope.defProp(node.name, fnScope.fnType.originNode)
	            .addType(new Arr(fnScope.fnType.arguments = new AVal));
	      }
	      return scope.getProp(node.name);
	    }),
	    ThisExpression: ret(function(_node, scope) {
	      return getThis(scope)
	    }),
	    Super: ret(function(node) {
	      return node.superType = cx.curSuper || ANull
	    }),
	    Literal: ret(function(node) {
	      return literalType(node);
	    }),
	    TemplateLiteral: ret(function(node, scope) {
	      for (var i = 0; i < node.expressions.length; ++i)
	        infer(node.expressions[i], scope, ANull)
	      return cx.str
	    }),
	    TaggedTemplateExpression: fill(function(node, scope, out) {
	      var args = [new Arr(cx.str)]
	      for (var i = 0; i < node.quasi.expressions.length; ++i)
	        args.push(infer(node.quasi.expressions[i], scope))
	      infer(node.tag, scope, new IsCallee(cx.topScope, args, node.quasi.expressions, out))
	    }),
	    YieldExpression: ret(function(node, scope) {
	      var output = ANull, fn = functionScope(scope).fnType
	      if (fn) {
	        if (fn.retval == ANull) fn.retval = new AVal
	        if (!fn.yieldval) fn.yieldval = new AVal
	        output = fn.retval
	      }
	      if (node.argument) {
	        if (node.delegate) {
	          infer(node.argument, scope, new HasMethodCall("next", [], null,
	                                                        new GetProp("value", output)))
	        } else {
	          infer(node.argument, scope, output)
	        }
	      }
	      return fn ? fn.yieldval : ANull
	    })
	  };
	  inferExprVisitor.ArrowFunctionExpression = inferExprVisitor.FunctionExpression

	  function infer(node, scope, out, name) {
	    var handler = inferExprVisitor[node.type];
	    return handler ? handler(node, scope, out, name) : ANull;
	  }

	  function loopPattern(init) {
	    return init.type == "VariableDeclaration" ? init.declarations[0].id : init
	  }

	  var inferWrapper = exports.inferWrapper = walk.make({
	    Expression: function(node, scope) {
	      infer(node, node.scope || scope, ANull);
	    },

	    FunctionDeclaration: function(node, scope, c) {
	      var inner = node.scope, fn = inner.fnType;
	      connectParams(node, inner)
	      c(node.body, inner, "Statement");
	      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
	      scope.getProp(node.id.name).addType(fn)
	    },

	    Statement: function(node, scope, c) {
	      c(node, node.scope || scope)
	    },

	    VariableDeclaration: function(node, scope) {
	      for (var i = 0; i < node.declarations.length; ++i) {
	        var decl = node.declarations[i];
	        if (decl.id.type == "Identifier") {
	          var prop = scope.getProp(decl.id.name);
	          if (decl.init)
	            infer(decl.init, scope, prop, decl.id.name);
	        } else if (decl.init) {
	          connectPattern(decl.id, scope, infer(decl.init, scope))
	        }
	      }
	    },

	    ClassDeclaration: function(node, scope) {
	      scope.getProp(node.id.name).addType(inferClass(node, scope, node.id.name))
	    },

	    ReturnStatement: function(node, scope) {
	      if (!node.argument) return;
	      var output = ANull, fn = functionScope(scope).fnType
	      if (fn) {
	        if (fn.retval == ANull) fn.retval = new AVal;
	        output = fn.retval;
	      }
	      infer(node.argument, scope, output);
	    },

	    ForInStatement: function(node, scope, c) {
	      var source = infer(node.right, scope);
	      if ((node.right.type == "Identifier" && node.right.name in scope.props) ||
	          (node.right.type == "MemberExpression" && node.right.property.name == "prototype")) {
	        maybeInstantiate(scope, 5);
	        var pattern = loopPattern(node.left)
	        if (pattern.type == "Identifier") {
	          if (pattern.name in scope.props)
	            scope.getProp(pattern.name).iteratesOver = source
	          source.getProp("<i>").propagate(ensureVar(pattern, scope))
	        } else {
	          connectPattern(pattern, scope, source.getProp("<i>"))
	        }
	      }
	      c(node.body, scope, "Statement");
	    },

	    ForOfStatement: function(node, scope, c) {
	      var pattern = loopPattern(node.left), target
	      if (pattern.type == "Identifier")
	        target = ensureVar(pattern, scope)
	      else
	        connectPattern(pattern, scope, target = new AVal)
	      infer(node.right, scope, new HasMethodCall(":Symbol.iterator", [], null,
	                                                 new HasMethodCall("next", [], null,
	                                                                   new GetProp("value", target))))
	      c(node.body, scope, "Statement")
	    }
	  });

	  // PARSING

	  var parse = exports.parse = function(text, options, thirdArg) {
	    if (!options || Array.isArray(options)) options = thirdArg
	    var ast;
	    try { ast = acorn.parse(text, options); }
	    catch(e) { ast = acorn_loose.parse_dammit(text, options); }
	    return ast;
	  };

	  // ANALYSIS INTERFACE

	  exports.analyze = function(ast, name, scope) {
	    if (typeof ast == "string") ast = parse(ast);

	    if (!name) name = "file#" + cx.origins.length;
	    exports.addOrigin(cx.curOrigin = name);

	    if (!scope) scope = cx.topScope;
	    cx.startAnalysis();

	    walk.recursive(ast, scope, null, scopeGatherer);
	    if (cx.parent) cx.parent.signal("preInfer", ast, scope)
	    walk.recursive(ast, scope, null, inferWrapper);
	    if (cx.parent) cx.parent.signal("postInfer", ast, scope)

	    cx.curOrigin = null;
	  };

	  // PURGING

	  exports.purge = function(origins, start, end) {
	    var test = makePredicate(origins, start, end);
	    ++cx.purgeGen;
	    cx.topScope.purge(test);
	    for (var prop in cx.props) {
	      var list = cx.props[prop];
	      for (var i = 0; i < list.length; ++i) {
	        var obj = list[i], av = obj.props[prop];
	        if (!av || test(av, av.originNode)) list.splice(i--, 1);
	      }
	      if (!list.length) delete cx.props[prop];
	    }
	  };

	  function makePredicate(origins, start, end) {
	    var arr = Array.isArray(origins);
	    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }
	    if (arr) {
	      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };
	      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };
	    } else {
	      if (end == null) return function(n) { return n.origin == origins; };
	      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };
	    }
	  }

	  AVal.prototype.purge = function(test) {
	    if (this.purgeGen == cx.purgeGen) return;
	    this.purgeGen = cx.purgeGen;
	    for (var i = 0; i < this.types.length; ++i) {
	      var type = this.types[i];
	      if (test(type, type.originNode))
	        this.types.splice(i--, 1);
	      else
	        type.purge(test);
	    }
	    if (!this.types.length) this.maxWeight = 0;

	    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
	      var f = this.forward[i];
	      if (test(f)) {
	        this.forward.splice(i--, 1);
	        if (this.props) this.props = null;
	      } else if (f.purge) {
	        f.purge(test);
	      }
	    }
	  };
	  ANull.purge = function() {};
	  Obj.prototype.purge = function(test) {
	    if (this.purgeGen == cx.purgeGen) return true;
	    this.purgeGen = cx.purgeGen;
	    for (var p in this.props) {
	      var av = this.props[p];
	      if (test(av, av.originNode))
	        this.removeProp(p);
	      av.purge(test);
	    }
	  };
	  Fn.prototype.purge = function(test) {
	    if (Obj.prototype.purge.call(this, test)) return;
	    this.self.purge(test);
	    this.retval.purge(test);
	    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);
	  };

	  // EXPRESSION TYPE DETERMINATION

	  function findByPropertyName(name) {
	    guessing = true;
	    var found = objsWithProp(name);
	    if (found) for (var i = 0; i < found.length; ++i) {
	      var val = found[i].getProp(name);
	      if (!val.isEmpty()) return val;
	    }
	    return ANull;
	  }

	  function generatorResult(input, output) {
	    var retObj = new Obj(true)
	    retObj.defProp("done").addType(cx.bool)
	    output.propagate(retObj.defProp("value"))
	    var method = new Fn(null, ANull, input ? [input] : [], input ? ["?"] : [], retObj)
	    var result = new Obj(cx.definitions.ecma6 && cx.definitions.ecma6.generator_prototype || true)
	    result.defProp("next").addType(method)
	    return result
	  }

	  function maybeIterator(fn, output) {
	    if (!fn.generator) return output
	    if (!fn.computeRet) { // Reuse iterator objects for non-computed return types
	      if (fn.generator === true) fn.generator = generatorResult(fn.yieldval, output)
	      return fn.generator
	    }
	    return generatorResult(fn.yieldval, output)
	  }

	  function computeReturnType(funcNode, argNodes, scope) {
	    var fn = findType(funcNode, scope).getFunctionType()
	    if (!fn) return ANull
	    var result = fn.retval
	    if (fn.computeRet) {
	      for (var i = 0, args = []; i < argNodes.length; ++i)
	        args.push(findType(argNodes[i], scope))
	      var self = ANull
	      if (funcNode.type == "MemberExpression")
	        self = findType(funcNode.object, scope)
	      result = fn.computeRet(self, args, argNodes);
	    }
	    return maybeIterator(fn, result)
	  }

	  var typeFinder = exports.typeFinder = {
	    ArrayExpression: function(node, scope) {
	      return arrayLiteralType(node.elements, scope, findType)
	    },
	    ObjectExpression: function(node) {
	      return node.objType;
	    },
	    ClassExpression: function(node) {
	      return node.objType;
	    },
	    FunctionExpression: function(node) {
	      return node.scope.fnType;
	    },
	    ArrowFunctionExpression: function(node) {
	      return node.scope.fnType;
	    },
	    SequenceExpression: function(node, scope) {
	      return findType(node.expressions[node.expressions.length-1], scope);
	    },
	    UnaryExpression: function(node) {
	      return unopResultType(node.operator);
	    },
	    UpdateExpression: function() {
	      return cx.num;
	    },
	    BinaryExpression: function(node, scope) {
	      if (binopIsBoolean(node.operator)) return cx.bool;
	      if (node.operator == "+") {
	        var lhs = findType(node.left, scope);
	        var rhs = findType(node.right, scope);
	        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
	      }
	      return cx.num;
	    },
	    AssignmentExpression: function(node, scope) {
	      return findType(node.right, scope);
	    },
	    LogicalExpression: function(node, scope) {
	      var lhs = findType(node.left, scope);
	      return lhs.isEmpty() ? findType(node.right, scope) : lhs;
	    },
	    ConditionalExpression: function(node, scope) {
	      var lhs = findType(node.consequent, scope);
	      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;
	    },
	    NewExpression: function(node, scope) {
	      var f = findType(node.callee, scope).getFunctionType();
	      var proto = f && f.getProp("prototype").getObjType();
	      if (!proto) return ANull;
	      return getInstance(proto, f);
	    },
	    CallExpression: function(node, scope) {
	      return computeReturnType(node.callee, node.arguments, scope)
	    },
	    MemberExpression: function(node, scope) {
	      var propN = propName(node), obj = findType(node.object, scope).getType();
	      if (obj) return obj.getProp(propN);
	      if (propN == "<i>") return ANull;
	      return findByPropertyName(propN);
	    },
	    Identifier: function(node, scope) {
	      return scope.hasProp(node.name) || ANull;
	    },
	    ThisExpression: function(_node, scope) {
	      return getThis(scope)
	    },
	    Literal: function(node) {
	      return literalType(node);
	    },
	    Super: ret(function(node) {
	      return node.superType
	    }),
	    TemplateLiteral: function() {
	      return cx.str
	    },
	    TaggedTemplateExpression: function(node, scope) {
	      return computeReturnType(node.tag, node.quasi.expressions, scope)
	    },
	    YieldExpression: function(_node, scope) {
	      var fn = functionScope(scope).fnType
	      return fn ? fn.yieldval : ANull
	    }
	  };

	  function findType(node, scope) {
	    var finder = typeFinder[node.type];
	    return finder ? finder(node, scope) : ANull;
	  }

	  var searchVisitor = exports.searchVisitor = walk.make({
	    Function: function(node, _st, c) {
	      walk.base.Function(node, node.scope, c)
	    },
	    Property: function(node, st, c) {
	      if (node.computed) c(node.key, st, "Expression");
	      if (node.key != node.value) c(node.value, st, "Expression");
	    },
	    Statement: function(node, st, c) {
	      c(node, node.scope || st)
	    },
	    ImportSpecifier: function(node, st, c) {
	      c(node.local, st)
	    },
	    ImportDefaultSpecifier: function(node, st, c) {
	      c(node.local, st)
	    },
	    ImportNamespaceSpecifier: function(node, st, c) {
	      c(node.local, st)
	    }
	  });
	  exports.fullVisitor = walk.make({
	    MemberExpression: function(node, st, c) {
	      c(node.object, st, "Expression");
	      c(node.property, st, node.computed ? "Expression" : null);
	    },
	    ObjectExpression: function(node, st, c) {
	      for (var i = 0; i < node.properties.length; ++i) {
	        c(node.properties[i].value, st, "Expression");
	        c(node.properties[i].key, st);
	      }
	    }
	  }, searchVisitor);

	  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {
	    var test = filter || function(_t, node) {
	      if (node.type == "Identifier" && node.name == "✖") return false;
	      return typeFinder.hasOwnProperty(node.type);
	    };
	    return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);
	  };

	  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {
	    var test = filter || function(_t, node) {
	      if (start != null && node.start > start) return false;
	      if (node.type == "Identifier" && node.name == "✖") return false;
	      return typeFinder.hasOwnProperty(node.type);
	    };
	    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);
	  };

	  exports.expressionType = function(found) {
	    return findType(found.node, found.state);
	  };

	  // Finding the expected type of something, from context

	  exports.parentNode = function(child, ast) {
	    var stack = [];
	    function c(node, st, override) {
	      if (node.start <= child.start && node.end >= child.end) {
	        var top = stack[stack.length - 1];
	        if (node == child) throw {found: top};
	        if (top != node) stack.push(node);
	        walk.base[override || node.type](node, st, c);
	        if (top != node) stack.pop();
	      }
	    }
	    try {
	      c(ast, null);
	    } catch (e) {
	      if (e.found) return e.found;
	      throw e;
	    }
	  };

	  var findTypeFromContext = exports.findTypeFromContext = {
	    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp("<i>"); },
	    ObjectExpression: function(parent, node, get) {
	      for (var i = 0; i < parent.properties.length; ++i) {
	        var prop = node.properties[i];
	        if (prop.value == node)
	          return get(parent, true).getProp(prop.key.name);
	      }
	    },
	    UnaryExpression: function(parent) { return unopResultType(parent.operator); },
	    UpdateExpression: function() { return cx.num; },
	    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },
	    AssignmentExpression: function(parent, _, get) { return get(parent.left); },
	    LogicalExpression: function(parent, _, get) { return get(parent, true); },
	    ConditionalExpression: function(parent, node, get) {
	      if (parent.consequent == node || parent.alternate == node) return get(parent, true);
	    },
	    CallExpression: function(parent, node, get) {
	      for (var i = 0; i < parent.arguments.length; i++) {
	        var arg = parent.arguments[i];
	        if (arg == node) {
	          var calleeType = get(parent.callee).getFunctionType();
	          if (calleeType instanceof Fn)
	            return calleeType.args[i];
	          break;
	        }
	      }
	    },
	    ReturnStatement: function(_parent, node, get) {
	      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start, "Function");
	      if (fnNode) {
	        var fnType = fnNode.node.type != "FunctionDeclaration"
	          ? get(fnNode.node, true).getFunctionType()
	          : fnNode.node.scope.fnType;
	        if (fnType) return fnType.retval.getType();
	      }
	    },
	    VariableDeclarator: function(parent, node, get) {
	      if (parent.init == node) return get(parent.id)
	    }
	  };
	  findTypeFromContext.NewExpression = findTypeFromContext.CallExpression

	  exports.typeFromContext = function(ast, found) {
	    var parent = exports.parentNode(found.node, ast);
	    var type = null;
	    if (findTypeFromContext.hasOwnProperty(parent.type)) {
	      var finder = findTypeFromContext[parent.type];
	      type = finder && finder(parent, found.node, function(node, fromContext) {
	        var obj = {node: node, state: found.state};
	        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);
	        return tp || ANull;
	      });
	    }
	    return type || exports.expressionType(found);
	  };

	  // Flag used to indicate that some wild guessing was used to produce
	  // a type or set of completions.
	  var guessing = false;

	  exports.resetGuessing = function(val) { guessing = val; };
	  exports.didGuess = function() { return guessing; };

	  exports.forAllPropertiesOf = function(type, f) {
	    type.gatherProperties(f, 0);
	  };

	  var refFindWalker = walk.make({}, searchVisitor);

	  exports.findRefs = function(ast, baseScope, name, refScope, f) {
	    refFindWalker.Identifier = refFindWalker.VariablePattern = function(node, scope) {
	      if (node.name != name) return;
	      for (var s = scope; s; s = s.prev) {
	        if (s == refScope) f(node, scope);
	        if (name in s.props) return;
	      }
	    };
	    walk.recursive(ast, baseScope, null, refFindWalker);
	  };

	  var simpleWalker = walk.make({
	    Function: function(node, _scope, c) {
	      c(node.body, node.scope, node.expression ? "Expression" : "Statement")
	    },
	    Statement: function(node, scope, c) {
	      c(node, node.scope || scope)
	    }
	  });

	  exports.findPropRefs = function(ast, scope, objType, propName, f) {
	    walk.simple(ast, {
	      MemberExpression: function(node, scope) {
	        if (node.computed || node.property.name != propName) return;
	        if (findType(node.object, scope).getType() == objType) f(node.property);
	      },
	      ObjectExpression: function(node, scope) {
	        if (findType(node, scope).getType() != objType) return;
	        for (var i = 0; i < node.properties.length; ++i)
	          if (node.properties[i].key.name == propName) f(node.properties[i].key);
	      }
	    }, simpleWalker, scope);
	  };

	  // LOCAL-VARIABLE QUERIES

	  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {
	    var found = walk.findNodeAround(ast, pos, function(_, node) {
	      return node.scope;
	    });
	    if (found) return found.node.scope;
	    else return defaultScope || cx.topScope;
	  };

	  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {
	    var scope = scopeAt(ast, pos, defaultScope);
	    scope.gatherProperties(f, 0);
	  };

	  // INIT DEF MODULE

	  // Delayed initialization because of cyclic dependencies.
	  def = exports.def = def.init({}, exports);
	});


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	// A recursive descent parser operates by defining functions for all
	// syntactic elements, and recursively calling those, each function
	// advancing the input stream and returning an AST node. Precedence
	// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
	// instead of `(!x)[1]` is handled by the fact that the parser
	// function that parses unary prefix operators is called first, and
	// in turn calls the function that parses `[]` subscripts — that
	// way, it'll receive the node for `x[1]` already parsed, and wraps
	// *that* in the unary operator node.
	//
	// Acorn uses an [operator precedence parser][opp] to handle binary
	// operator precedence, because it is much more compact than using
	// the technique outlined above, which uses different, nesting
	// functions to specify precedence, for all of the ten binary
	// precedence levels that JavaScript defines.
	//
	// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var pp = _state.Parser.prototype;

	// Check if property name clashes with already added.
	// Object/class getters and setters are not allowed to clash —
	// either with each other or with an init property — and in
	// strict mode, init properties are also not allowed to be repeated.

	pp.checkPropClash = function (prop, propHash) {
	  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
	  var key = prop.key;var name = undefined;
	  switch (key.type) {
	    case "Identifier":
	      name = key.name;break;
	    case "Literal":
	      name = String(key.value);break;
	    default:
	      return;
	  }
	  var kind = prop.kind;

	  if (this.options.ecmaVersion >= 6) {
	    if (name === "__proto__" && kind === "init") {
	      if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
	      propHash.proto = true;
	    }
	    return;
	  }
	  name = "$" + name;
	  var other = propHash[name];
	  if (other) {
	    var isGetSet = kind !== "init";
	    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
	  } else {
	    other = propHash[name] = {
	      init: false,
	      get: false,
	      set: false
	    };
	  }
	  other[kind] = true;
	};

	// ### Expression parsing

	// These nest, from the most general expression type at the top to
	// 'atomic', nondivisible expression types at the bottom. Most of
	// the functions will simply let the function(s) below them parse,
	// and, *if* the syntactic construct they handle is present, wrap
	// the AST node that the inner parser gave them in another node.

	// Parse a full expression. The optional arguments are used to
	// forbid the `in` operator (in for loops initalization expressions)
	// and provide reference for storing '=' operator inside shorthand
	// property assignment in contexts where both object expression
	// and object pattern might appear (so it's possible to raise
	// delayed syntax error at correct position).

	pp.parseExpression = function (noIn, refDestructuringErrors) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
	  if (this.type === _tokentype.types.comma) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.expressions = [expr];
	    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
	    return this.finishNode(node, "SequenceExpression");
	  }
	  return expr;
	};

	// Parse an assignment expression. This includes applications of
	// operators like `+=`.

	pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
	  if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield();

	  var validateDestructuring = false;
	  if (!refDestructuringErrors) {
	    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
	    validateDestructuring = true;
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
	  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
	  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
	  if (this.type.isAssign) {
	    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
	    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
	    this.checkLVal(left);
	    this.next();
	    node.right = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "AssignmentExpression");
	  } else {
	    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
	  }
	  return left;
	};

	// Parse a ternary conditional (`?:`) operator.

	pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprOps(noIn, refDestructuringErrors);
	  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	  if (this.eat(_tokentype.types.question)) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.test = expr;
	    node.consequent = this.parseMaybeAssign();
	    this.expect(_tokentype.types.colon);
	    node.alternate = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "ConditionalExpression");
	  }
	  return expr;
	};

	// Start the precedence parser.

	pp.parseExprOps = function (noIn, refDestructuringErrors) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseMaybeUnary(refDestructuringErrors);
	  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
	};

	// Parse binary operators with the operator precedence parsing
	// algorithm. `left` is the left-hand side of the operator.
	// `minPrec` provides context that allows the function to stop and
	// defer further parser to one of its callers when it encounters an
	// operator that has a lower precedence than the set it is parsing.

	pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
	  var prec = this.type.binop;
	  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
	    if (prec > minPrec) {
	      var node = this.startNodeAt(leftStartPos, leftStartLoc);
	      node.left = left;
	      node.operator = this.value;
	      var op = this.type;
	      this.next();
	      var startPos = this.start,
	          startLoc = this.startLoc;
	      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
	      this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
	      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
	    }
	  }
	  return left;
	};

	// Parse unary operators, both prefix and postfix.

	pp.parseMaybeUnary = function (refDestructuringErrors) {
	  if (this.type.prefix) {
	    var node = this.startNode(),
	        update = this.type === _tokentype.types.incDec;
	    node.operator = this.value;
	    node.prefix = true;
	    this.next();
	    node.argument = this.parseMaybeUnary();
	    this.checkExpressionErrors(refDestructuringErrors, true);
	    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
	    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprSubscripts(refDestructuringErrors);
	  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	  while (this.type.postfix && !this.canInsertSemicolon()) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    node.prefix = false;
	    node.argument = expr;
	    this.checkLVal(expr);
	    this.next();
	    expr = this.finishNode(node, "UpdateExpression");
	  }
	  return expr;
	};

	// Parse call, dot, and `[]`-subscript expressions.

	pp.parseExprSubscripts = function (refDestructuringErrors) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprAtom(refDestructuringErrors);
	  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
	  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
	  return this.parseSubscripts(expr, startPos, startLoc);
	};

	pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
	  for (;;) {
	    if (this.eat(_tokentype.types.dot)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.object = base;
	      node.property = this.parseIdent(true);
	      node.computed = false;
	      base = this.finishNode(node, "MemberExpression");
	    } else if (this.eat(_tokentype.types.bracketL)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.object = base;
	      node.property = this.parseExpression();
	      node.computed = true;
	      this.expect(_tokentype.types.bracketR);
	      base = this.finishNode(node, "MemberExpression");
	    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.callee = base;
	      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
	      base = this.finishNode(node, "CallExpression");
	    } else if (this.type === _tokentype.types.backQuote) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.tag = base;
	      node.quasi = this.parseTemplate();
	      base = this.finishNode(node, "TaggedTemplateExpression");
	    } else {
	      return base;
	    }
	  }
	};

	// Parse an atomic expression — either a single token that is an
	// expression, an expression started by a keyword like `function` or
	// `new`, or an expression wrapped in punctuation like `()`, `[]`,
	// or `{}`.

	pp.parseExprAtom = function (refDestructuringErrors) {
	  var node = undefined,
	      canBeArrow = this.potentialArrowAt == this.start;
	  switch (this.type) {
	    case _tokentype.types._super:
	      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");
	    case _tokentype.types._this:
	      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
	      node = this.startNode();
	      this.next();
	      return this.finishNode(node, type);

	    case _tokentype.types._yield:
	      if (this.inGenerator) this.unexpected();

	    case _tokentype.types.name:
	      var startPos = this.start,
	          startLoc = this.startLoc;
	      var id = this.parseIdent(this.type !== _tokentype.types.name);
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
	      return id;

	    case _tokentype.types.regexp:
	      var value = this.value;
	      node = this.parseLiteral(value.value);
	      node.regex = { pattern: value.pattern, flags: value.flags };
	      return node;

	    case _tokentype.types.num:case _tokentype.types.string:
	      return this.parseLiteral(this.value);

	    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
	      node = this.startNode();
	      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
	      node.raw = this.type.keyword;
	      this.next();
	      return this.finishNode(node, "Literal");

	    case _tokentype.types.parenL:
	      return this.parseParenAndDistinguishExpression(canBeArrow);

	    case _tokentype.types.bracketL:
	      node = this.startNode();
	      this.next();
	      // check whether this is array comprehension or regular array
	      if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
	        return this.parseComprehension(node, false);
	      }
	      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
	      return this.finishNode(node, "ArrayExpression");

	    case _tokentype.types.braceL:
	      return this.parseObj(false, refDestructuringErrors);

	    case _tokentype.types._function:
	      node = this.startNode();
	      this.next();
	      return this.parseFunction(node, false);

	    case _tokentype.types._class:
	      return this.parseClass(this.startNode(), false);

	    case _tokentype.types._new:
	      return this.parseNew();

	    case _tokentype.types.backQuote:
	      return this.parseTemplate();

	    default:
	      this.unexpected();
	  }
	};

	pp.parseLiteral = function (value) {
	  var node = this.startNode();
	  node.value = value;
	  node.raw = this.input.slice(this.start, this.end);
	  this.next();
	  return this.finishNode(node, "Literal");
	};

	pp.parseParenExpression = function () {
	  this.expect(_tokentype.types.parenL);
	  var val = this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  return val;
	};

	pp.parseParenAndDistinguishExpression = function (canBeArrow) {
	  var startPos = this.start,
	      startLoc = this.startLoc,
	      val = undefined;
	  if (this.options.ecmaVersion >= 6) {
	    this.next();

	    if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
	      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);
	    }

	    var innerStartPos = this.start,
	        innerStartLoc = this.startLoc;
	    var exprList = [],
	        first = true;
	    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
	        spreadStart = undefined,
	        innerParenStart = undefined;
	    while (this.type !== _tokentype.types.parenR) {
	      first ? first = false : this.expect(_tokentype.types.comma);
	      if (this.type === _tokentype.types.ellipsis) {
	        spreadStart = this.start;
	        exprList.push(this.parseParenItem(this.parseRest()));
	        break;
	      } else {
	        if (this.type === _tokentype.types.parenL && !innerParenStart) {
	          innerParenStart = this.start;
	        }
	        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
	      }
	    }
	    var innerEndPos = this.start,
	        innerEndLoc = this.startLoc;
	    this.expect(_tokentype.types.parenR);

	    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
	      this.checkPatternErrors(refDestructuringErrors, true);
	      if (innerParenStart) this.unexpected(innerParenStart);
	      return this.parseParenArrowList(startPos, startLoc, exprList);
	    }

	    if (!exprList.length) this.unexpected(this.lastTokStart);
	    if (spreadStart) this.unexpected(spreadStart);
	    this.checkExpressionErrors(refDestructuringErrors, true);

	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartPos, innerStartLoc);
	      val.expressions = exprList;
	      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }
	  } else {
	    val = this.parseParenExpression();
	  }

	  if (this.options.preserveParens) {
	    var par = this.startNodeAt(startPos, startLoc);
	    par.expression = val;
	    return this.finishNode(par, "ParenthesizedExpression");
	  } else {
	    return val;
	  }
	};

	pp.parseParenItem = function (item) {
	  return item;
	};

	pp.parseParenArrowList = function (startPos, startLoc, exprList) {
	  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
	};

	// New's precedence is slightly tricky. It must allow its argument
	// to be a `[]` or dot subscript expression, but not a call — at
	// least, not without wrapping it in parentheses. Thus, it uses the

	var empty = [];

	pp.parseNew = function () {
	  var node = this.startNode();
	  var meta = this.parseIdent(true);
	  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
	    node.meta = meta;
	    node.property = this.parseIdent(true);
	    if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
	    if (!this.inFunction) this.raise(node.start, "new.target can only be used in functions");
	    return this.finishNode(node, "MetaProperty");
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
	  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
	  return this.finishNode(node, "NewExpression");
	};

	// Parse template expression.

	pp.parseTemplateElement = function () {
	  var elem = this.startNode();
	  elem.value = {
	    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
	    cooked: this.value
	  };
	  this.next();
	  elem.tail = this.type === _tokentype.types.backQuote;
	  return this.finishNode(elem, "TemplateElement");
	};

	pp.parseTemplate = function () {
	  var node = this.startNode();
	  this.next();
	  node.expressions = [];
	  var curElt = this.parseTemplateElement();
	  node.quasis = [curElt];
	  while (!curElt.tail) {
	    this.expect(_tokentype.types.dollarBraceL);
	    node.expressions.push(this.parseExpression());
	    this.expect(_tokentype.types.braceR);
	    node.quasis.push(curElt = this.parseTemplateElement());
	  }
	  this.next();
	  return this.finishNode(node, "TemplateLiteral");
	};

	// Parse an object literal or binding pattern.

	pp.parseObj = function (isPattern, refDestructuringErrors) {
	  var node = this.startNode(),
	      first = true,
	      propHash = {};
	  node.properties = [];
	  this.next();
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;

	    var prop = this.startNode(),
	        isGenerator = undefined,
	        startPos = undefined,
	        startLoc = undefined;
	    if (this.options.ecmaVersion >= 6) {
	      prop.method = false;
	      prop.shorthand = false;
	      if (isPattern || refDestructuringErrors) {
	        startPos = this.start;
	        startLoc = this.startLoc;
	      }
	      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
	    }
	    this.parsePropertyName(prop);
	    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
	    this.checkPropClash(prop, propHash);
	    node.properties.push(this.finishNode(prop, "Property"));
	  }
	  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
	};

	pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
	  if (this.eat(_tokentype.types.colon)) {
	    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
	    prop.kind = "init";
	  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
	    if (isPattern) this.unexpected();
	    prop.kind = "init";
	    prop.method = true;
	    prop.value = this.parseMethod(isGenerator);
	  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
	    if (isGenerator || isPattern) this.unexpected();
	    prop.kind = prop.key.name;
	    this.parsePropertyName(prop);
	    prop.value = this.parseMethod(false);
	    var paramCount = prop.kind === "get" ? 0 : 1;
	    if (prop.value.params.length !== paramCount) {
	      var start = prop.value.start;
	      if (prop.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
	    }
	  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	    prop.kind = "init";
	    if (isPattern) {
	      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
	      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else {
	      prop.value = prop.key;
	    }
	    prop.shorthand = true;
	  } else this.unexpected();
	};

	pp.parsePropertyName = function (prop) {
	  if (this.options.ecmaVersion >= 6) {
	    if (this.eat(_tokentype.types.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssign();
	      this.expect(_tokentype.types.bracketR);
	      return prop.key;
	    } else {
	      prop.computed = false;
	    }
	  }
	  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
	};

	// Initialize empty function node.

	pp.initFunction = function (node) {
	  node.id = null;
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = false;
	    node.expression = false;
	  }
	};

	// Parse object or class method.

	pp.parseMethod = function (isGenerator) {
	  var node = this.startNode();
	  this.initFunction(node);
	  this.expect(_tokentype.types.parenL);
	  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
	  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
	  this.parseFunctionBody(node, false);
	  return this.finishNode(node, "FunctionExpression");
	};

	// Parse arrow function expression with given parameters.

	pp.parseArrowExpression = function (node, params) {
	  this.initFunction(node);
	  node.params = this.toAssignableList(params, true);
	  this.parseFunctionBody(node, true);
	  return this.finishNode(node, "ArrowFunctionExpression");
	};

	// Parse function body and check parameters.

	pp.parseFunctionBody = function (node, isArrowFunction) {
	  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

	  if (isExpression) {
	    node.body = this.parseMaybeAssign();
	    node.expression = true;
	  } else {
	    // Start a new scope with regard to labels and the `inFunction`
	    // flag (restore them to their old value afterwards).
	    var oldInFunc = this.inFunction,
	        oldInGen = this.inGenerator,
	        oldLabels = this.labels;
	    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
	    node.body = this.parseBlock(true);
	    node.expression = false;
	    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
	  }

	  // If this is a strict mode function, verify that argument names
	  // are not repeated, and it does not try to bind the words `eval`
	  // or `arguments`.
	  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
	    var oldStrict = this.strict;
	    this.strict = true;
	    if (node.id) this.checkLVal(node.id, true);
	    this.checkParams(node);
	    this.strict = oldStrict;
	  } else if (isArrowFunction) {
	    this.checkParams(node);
	  }
	};

	// Checks function params for various disallowed patterns such as using "eval"
	// or "arguments" and duplicate parameters.

	pp.checkParams = function (node) {
	  var nameHash = {};
	  for (var i = 0; i < node.params.length; i++) {
	    this.checkLVal(node.params[i], true, nameHash);
	  }
	};

	// Parses a comma-separated list of expressions, and returns them as
	// an array. `close` is the token type that ends the list, and
	// `allowEmpty` can be turned on to allow subsequent commas with
	// nothing in between them to be parsed as `null` (which is needed
	// for array literals).

	pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
	        refDestructuringErrors.trailingComma = this.lastTokStart;
	      }
	      if (allowTrailingComma && this.afterTrailingComma(close)) break;
	    } else first = false;

	    var elt = undefined;
	    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
	    elts.push(elt);
	  }
	  return elts;
	};

	// Parse the next token as an identifier. If `liberal` is true (used
	// when parsing properties), it will also convert keywords into
	// identifiers.

	pp.parseIdent = function (liberal) {
	  var node = this.startNode();
	  if (liberal && this.options.allowReserved == "never") liberal = false;
	  if (this.type === _tokentype.types.name) {
	    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
	    node.name = this.value;
	  } else if (liberal && this.type.keyword) {
	    node.name = this.type.keyword;
	  } else {
	    this.unexpected();
	  }
	  this.next();
	  return this.finishNode(node, "Identifier");
	};

	// Parses yield expression inside generator.

	pp.parseYield = function () {
	  var node = this.startNode();
	  this.next();
	  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
	    node.delegate = false;
	    node.argument = null;
	  } else {
	    node.delegate = this.eat(_tokentype.types.star);
	    node.argument = this.parseMaybeAssign();
	  }
	  return this.finishNode(node, "YieldExpression");
	};

	// Parses array and generator comprehensions.

	pp.parseComprehension = function (node, isGenerator) {
	  node.blocks = [];
	  while (this.type === _tokentype.types._for) {
	    var block = this.startNode();
	    this.next();
	    this.expect(_tokentype.types.parenL);
	    block.left = this.parseBindingAtom();
	    this.checkLVal(block.left, true);
	    this.expectContextual("of");
	    block.right = this.parseExpression();
	    this.expect(_tokentype.types.parenR);
	    node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
	  }
	  node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null;
	  node.body = this.parseExpression();
	  this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR);
	  node.generator = isGenerator;
	  return this.finishNode(node, "ComprehensionExpression");
	};

	},{"./state":10,"./tokentype":14}],2:[function(_dereq_,module,exports){
	// This is a trick taken from Esprima. It turns out that, on
	// non-Chrome browsers, to check whether a string is in a set, a
	// predicate containing a big ugly `switch` statement is faster than
	// a regular expression, and on Chrome the two are about on par.
	// This function uses `eval` (non-lexical) to produce such a
	// predicate from a space-separated string of words.
	//
	// It starts by sorting the words by length.

	// Reserved word lists for various dialects of the language

	"use strict";

	exports.__esModule = true;
	exports.isIdentifierStart = isIdentifierStart;
	exports.isIdentifierChar = isIdentifierChar;
	var reservedWords = {
	  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	  5: "class enum extends super const export import",
	  6: "enum",
	  strict: "implements interface let package private protected public static yield",
	  strictBind: "eval arguments"
	};

	exports.reservedWords = reservedWords;
	// And the keywords

	var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

	var keywords = {
	  5: ecma5AndLessKeywords,
	  6: ecma5AndLessKeywords + " let const class extends export import yield super"
	};

	exports.keywords = keywords;
	// ## Character categories

	// Big ugly regular expressions that match characters in the
	// whitespace, identifier, and identifier-start categories. These
	// are only applied when a character is found to actually have a
	// code point above 128.
	// Generated by `bin/generate-identifier-regex.js`.

	var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
	var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏ᦰ-ᧀᧈᧉ᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︭︳︴﹍-﹏０-９＿";

	var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

	// These are a run-length and offset encoded representation of the
	// >0xffff code points that are a valid part of identifiers. The
	// offset starts at 0x10000, and each pair of numbers represents an
	// offset to the next range, and then a size of the range. They were
	// generated by tools/generate-identifier-regex.js
	var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
	var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];

	// This has a complexity linear to the value of the code. The
	// assumption is that looking up astral identifier characters is
	// rare.
	function isInAstralSet(code, set) {
	  var pos = 0x10000;
	  for (var i = 0; i < set.length; i += 2) {
	    pos += set[i];
	    if (pos > code) return false;
	    pos += set[i + 1];
	    if (pos >= code) return true;
	  }
	}

	// Test whether a given character code starts an identifier.

	function isIdentifierStart(code, astral) {
	  if (code < 65) return code === 36;
	  if (code < 91) return true;
	  if (code < 97) return code === 95;
	  if (code < 123) return true;
	  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  if (astral === false) return false;
	  return isInAstralSet(code, astralIdentifierStartCodes);
	}

	// Test whether a given character is part of an identifier.

	function isIdentifierChar(code, astral) {
	  if (code < 48) return code === 36;
	  if (code < 58) return true;
	  if (code < 65) return false;
	  if (code < 91) return true;
	  if (code < 97) return code === 95;
	  if (code < 123) return true;
	  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	  if (astral === false) return false;
	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}

	},{}],3:[function(_dereq_,module,exports){
	// Acorn is a tiny, fast JavaScript parser written in JavaScript.
	//
	// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
	// various contributors and released under an MIT license.
	//
	// Git repositories for Acorn are available at
	//
	//     http://marijnhaverbeke.nl/git/acorn
	//     https://github.com/ternjs/acorn.git
	//
	// Please use the [github bug tracker][ghbt] to report issues.
	//
	// [ghbt]: https://github.com/ternjs/acorn/issues
	//
	// This file defines the main parser interface. The library also comes
	// with a [error-tolerant parser][dammit] and an
	// [abstract syntax tree walker][walk], defined in other files.
	//
	// [dammit]: acorn_loose.js
	// [walk]: util/walk.js

	"use strict";

	exports.__esModule = true;
	exports.parse = parse;
	exports.parseExpressionAt = parseExpressionAt;
	exports.tokenizer = tokenizer;

	var _state = _dereq_("./state");

	_dereq_("./parseutil");

	_dereq_("./statement");

	_dereq_("./lval");

	_dereq_("./expression");

	_dereq_("./location");

	exports.Parser = _state.Parser;
	exports.plugins = _state.plugins;

	var _options = _dereq_("./options");

	exports.defaultOptions = _options.defaultOptions;

	var _locutil = _dereq_("./locutil");

	exports.Position = _locutil.Position;
	exports.SourceLocation = _locutil.SourceLocation;
	exports.getLineInfo = _locutil.getLineInfo;

	var _node = _dereq_("./node");

	exports.Node = _node.Node;

	var _tokentype = _dereq_("./tokentype");

	exports.TokenType = _tokentype.TokenType;
	exports.tokTypes = _tokentype.types;

	var _tokencontext = _dereq_("./tokencontext");

	exports.TokContext = _tokencontext.TokContext;
	exports.tokContexts = _tokencontext.types;

	var _identifier = _dereq_("./identifier");

	exports.isIdentifierChar = _identifier.isIdentifierChar;
	exports.isIdentifierStart = _identifier.isIdentifierStart;

	var _tokenize = _dereq_("./tokenize");

	exports.Token = _tokenize.Token;

	var _whitespace = _dereq_("./whitespace");

	exports.isNewLine = _whitespace.isNewLine;
	exports.lineBreak = _whitespace.lineBreak;
	exports.lineBreakG = _whitespace.lineBreakG;
	var version = "2.6.4";

	exports.version = version;
	// The main exported interface (under `self.acorn` when in the
	// browser) is a `parse` function that takes a code string and
	// returns an abstract syntax tree as specified by [Mozilla parser
	// API][api].
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

	function parse(input, options) {
	  return new _state.Parser(options, input).parse();
	}

	// This function tries to parse a single expression at a given
	// offset in a string. Useful for parsing mixed-language formats
	// that embed JavaScript expressions.

	function parseExpressionAt(input, pos, options) {
	  var p = new _state.Parser(options, input, pos);
	  p.nextToken();
	  return p.parseExpression();
	}

	// Acorn is organized as a tokenizer and a recursive-descent parser.
	// The `tokenizer` export provides an interface to the tokenizer.

	function tokenizer(input, options) {
	  return new _state.Parser(options, input);
	}

	},{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(_dereq_,module,exports){
	"use strict";

	var _state = _dereq_("./state");

	var _locutil = _dereq_("./locutil");

	var pp = _state.Parser.prototype;

	// This function is used to raise exceptions on parse errors. It
	// takes an offset integer (into the current `input`) to indicate
	// the location of the error, attaches the position to the end
	// of the error message, and then raises a `SyntaxError` with that
	// message.

	pp.raise = function (pos, message) {
	  var loc = _locutil.getLineInfo(this.input, pos);
	  message += " (" + loc.line + ":" + loc.column + ")";
	  var err = new SyntaxError(message);
	  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
	  throw err;
	};

	pp.curPosition = function () {
	  if (this.options.locations) {
	    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
	  }
	};

	},{"./locutil":5,"./state":10}],5:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.getLineInfo = getLineInfo;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _whitespace = _dereq_("./whitespace");

	// These are used when `options.locations` is on, for the
	// `startLoc` and `endLoc` properties.

	var Position = (function () {
	  function Position(line, col) {
	    _classCallCheck(this, Position);

	    this.line = line;
	    this.column = col;
	  }

	  Position.prototype.offset = function offset(n) {
	    return new Position(this.line, this.column + n);
	  };

	  return Position;
	})();

	exports.Position = Position;

	var SourceLocation = function SourceLocation(p, start, end) {
	  _classCallCheck(this, SourceLocation);

	  this.start = start;
	  this.end = end;
	  if (p.sourceFile !== null) this.source = p.sourceFile;
	}

	// The `getLineInfo` function is mostly useful when the
	// `locations` option is off (for performance reasons) and you
	// want to find the line/column position for a given character
	// offset. `input` should be the code string that the offset refers
	// into.

	;

	exports.SourceLocation = SourceLocation;

	function getLineInfo(input, offset) {
	  for (var line = 1, cur = 0;;) {
	    _whitespace.lineBreakG.lastIndex = cur;
	    var match = _whitespace.lineBreakG.exec(input);
	    if (match && match.index < offset) {
	      ++line;
	      cur = match.index + match[0].length;
	    } else {
	      return new Position(line, offset - cur);
	    }
	  }
	}

	},{"./whitespace":16}],6:[function(_dereq_,module,exports){
	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _util = _dereq_("./util");

	var pp = _state.Parser.prototype;

	// Convert existing expression atom to assignable pattern
	// if possible.

	pp.toAssignable = function (node, isBinding) {
	  if (this.options.ecmaVersion >= 6 && node) {
	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	        break;

	      case "ObjectExpression":
	        node.type = "ObjectPattern";
	        for (var i = 0; i < node.properties.length; i++) {
	          var prop = node.properties[i];
	          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
	          this.toAssignable(prop.value, isBinding);
	        }
	        break;

	      case "ArrayExpression":
	        node.type = "ArrayPattern";
	        this.toAssignableList(node.elements, isBinding);
	        break;

	      case "AssignmentExpression":
	        if (node.operator === "=") {
	          node.type = "AssignmentPattern";
	          delete node.operator;
	          // falls through to AssignmentPattern
	        } else {
	            this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
	            break;
	          }

	      case "AssignmentPattern":
	        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
	        break;

	      case "ParenthesizedExpression":
	        node.expression = this.toAssignable(node.expression, isBinding);
	        break;

	      case "MemberExpression":
	        if (!isBinding) break;

	      default:
	        this.raise(node.start, "Assigning to rvalue");
	    }
	  }
	  return node;
	};

	// Convert list of expression atoms to binding list.

	pp.toAssignableList = function (exprList, isBinding) {
	  var end = exprList.length;
	  if (end) {
	    var last = exprList[end - 1];
	    if (last && last.type == "RestElement") {
	      --end;
	    } else if (last && last.type == "SpreadElement") {
	      last.type = "RestElement";
	      var arg = last.argument;
	      this.toAssignable(arg, isBinding);
	      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
	      --end;
	    }

	    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
	  }
	  for (var i = 0; i < end; i++) {
	    var elt = exprList[i];
	    if (elt) this.toAssignable(elt, isBinding);
	  }
	  return exprList;
	};

	// Parses spread element.

	pp.parseSpread = function (refDestructuringErrors) {
	  var node = this.startNode();
	  this.next();
	  node.argument = this.parseMaybeAssign(refDestructuringErrors);
	  return this.finishNode(node, "SpreadElement");
	};

	pp.parseRest = function (allowNonIdent) {
	  var node = this.startNode();
	  this.next();

	  // RestElement inside of a function parameter must be an identifier
	  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

	  return this.finishNode(node, "RestElement");
	};

	// Parses lvalue (assignable) atom.

	pp.parseBindingAtom = function () {
	  if (this.options.ecmaVersion < 6) return this.parseIdent();
	  switch (this.type) {
	    case _tokentype.types.name:
	      return this.parseIdent();

	    case _tokentype.types.bracketL:
	      var node = this.startNode();
	      this.next();
	      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
	      return this.finishNode(node, "ArrayPattern");

	    case _tokentype.types.braceL:
	      return this.parseObj(true);

	    default:
	      this.unexpected();
	  }
	};

	pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (first) first = false;else this.expect(_tokentype.types.comma);
	    if (allowEmpty && this.type === _tokentype.types.comma) {
	      elts.push(null);
	    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
	      break;
	    } else if (this.type === _tokentype.types.ellipsis) {
	      var rest = this.parseRest(allowNonIdent);
	      this.parseBindingListItem(rest);
	      elts.push(rest);
	      this.expect(close);
	      break;
	    } else {
	      var elem = this.parseMaybeDefault(this.start, this.startLoc);
	      this.parseBindingListItem(elem);
	      elts.push(elem);
	    }
	  }
	  return elts;
	};

	pp.parseBindingListItem = function (param) {
	  return param;
	};

	// Parses assignment pattern around given atom if possible.

	pp.parseMaybeDefault = function (startPos, startLoc, left) {
	  left = left || this.parseBindingAtom();
	  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
	  var node = this.startNodeAt(startPos, startLoc);
	  node.left = left;
	  node.right = this.parseMaybeAssign();
	  return this.finishNode(node, "AssignmentPattern");
	};

	// Verify that a node is an lval — something that can be assigned
	// to.

	pp.checkLVal = function (expr, isBinding, checkClashes) {
	  switch (expr.type) {
	    case "Identifier":
	      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
	      if (checkClashes) {
	        if (_util.has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash");
	        checkClashes[expr.name] = true;
	      }
	      break;

	    case "MemberExpression":
	      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
	      break;

	    case "ObjectPattern":
	      for (var i = 0; i < expr.properties.length; i++) {
	        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
	      }break;

	    case "ArrayPattern":
	      for (var i = 0; i < expr.elements.length; i++) {
	        var elem = expr.elements[i];
	        if (elem) this.checkLVal(elem, isBinding, checkClashes);
	      }
	      break;

	    case "AssignmentPattern":
	      this.checkLVal(expr.left, isBinding, checkClashes);
	      break;

	    case "RestElement":
	      this.checkLVal(expr.argument, isBinding, checkClashes);
	      break;

	    case "ParenthesizedExpression":
	      this.checkLVal(expr.expression, isBinding, checkClashes);
	      break;

	    default:
	      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
	  }
	};

	},{"./state":10,"./tokentype":14,"./util":15}],7:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _state = _dereq_("./state");

	var _locutil = _dereq_("./locutil");

	var Node = function Node(parser, pos, loc) {
	  _classCallCheck(this, Node);

	  this.type = "";
	  this.start = pos;
	  this.end = 0;
	  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
	  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
	  if (parser.options.ranges) this.range = [pos, 0];
	}

	// Start an AST node, attaching a start offset.

	;

	exports.Node = Node;
	var pp = _state.Parser.prototype;

	pp.startNode = function () {
	  return new Node(this, this.start, this.startLoc);
	};

	pp.startNodeAt = function (pos, loc) {
	  return new Node(this, pos, loc);
	};

	// Finish an AST node, adding `type` and `end` properties.

	function finishNodeAt(node, type, pos, loc) {
	  node.type = type;
	  node.end = pos;
	  if (this.options.locations) node.loc.end = loc;
	  if (this.options.ranges) node.range[1] = pos;
	  return node;
	}

	pp.finishNode = function (node, type) {
	  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
	};

	// Finish node at given position

	pp.finishNodeAt = function (node, type, pos, loc) {
	  return finishNodeAt.call(this, node, type, pos, loc);
	};

	},{"./locutil":5,"./state":10}],8:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.getOptions = getOptions;

	var _util = _dereq_("./util");

	var _locutil = _dereq_("./locutil");

	// A second optional argument can be given to further configure
	// the parser process. These options are recognized:

	var defaultOptions = {
	  // `ecmaVersion` indicates the ECMAScript version to parse. Must
	  // be either 3, or 5, or 6. This influences support for strict
	  // mode, the set of reserved words, support for getters and
	  // setters and other features.
	  ecmaVersion: 5,
	  // Source type ("script" or "module") for different semantics
	  sourceType: "script",
	  // `onInsertedSemicolon` can be a callback that will be called
	  // when a semicolon is automatically inserted. It will be passed
	  // th position of the comma as an offset, and if `locations` is
	  // enabled, it is given the location as a `{line, column}` object
	  // as second argument.
	  onInsertedSemicolon: null,
	  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	  // trailing commas.
	  onTrailingComma: null,
	  // By default, reserved words are only enforced if ecmaVersion >= 5.
	  // Set `allowReserved` to a boolean value to explicitly turn this on
	  // an off. When this option has the value "never", reserved words
	  // and keywords can also not be used as property names.
	  allowReserved: null,
	  // When enabled, a return at the top level is not considered an
	  // error.
	  allowReturnOutsideFunction: false,
	  // When enabled, import/export statements are not constrained to
	  // appearing at the top of the program.
	  allowImportExportEverywhere: false,
	  // When enabled, hashbang directive in the beginning of file
	  // is allowed and treated as a line comment.
	  allowHashBang: false,
	  // When `locations` is on, `loc` properties holding objects with
	  // `start` and `end` properties in `{line, column}` form (with
	  // line being 1-based and column 0-based) will be attached to the
	  // nodes.
	  locations: false,
	  // A function can be passed as `onToken` option, which will
	  // cause Acorn to call that function with object in the same
	  // format as tokens returned from `tokenizer().getToken()`. Note
	  // that you are not allowed to call the parser from the
	  // callback—that will corrupt its internal state.
	  onToken: null,
	  // A function can be passed as `onComment` option, which will
	  // cause Acorn to call that function with `(block, text, start,
	  // end)` parameters whenever a comment is skipped. `block` is a
	  // boolean indicating whether this is a block (`/* */`) comment,
	  // `text` is the content of the comment, and `start` and `end` are
	  // character offsets that denote the start and end of the comment.
	  // When the `locations` option is on, two more parameters are
	  // passed, the full `{line, column}` locations of the start and
	  // end of the comments. Note that you are not allowed to call the
	  // parser from the callback—that will corrupt its internal state.
	  onComment: null,
	  // Nodes have their start and end characters offsets recorded in
	  // `start` and `end` properties (directly on the node, rather than
	  // the `loc` object, which holds line/column data. To also add a
	  // [semi-standardized][range] `range` property holding a `[start,
	  // end]` array with the same numbers, set the `ranges` option to
	  // `true`.
	  //
	  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	  ranges: false,
	  // It is possible to parse multiple files into a single AST by
	  // passing the tree produced by parsing the first file as
	  // `program` option in subsequent parses. This will add the
	  // toplevel forms of the parsed file to the `Program` (top) node
	  // of an existing parse tree.
	  program: null,
	  // When `locations` is on, you can pass this to record the source
	  // file in every node's `loc` object.
	  sourceFile: null,
	  // This value, if given, is stored in every node, whether
	  // `locations` is on or off.
	  directSourceFile: null,
	  // When enabled, parenthesized expressions are represented by
	  // (non-standard) ParenthesizedExpression nodes
	  preserveParens: false,
	  plugins: {}
	};

	exports.defaultOptions = defaultOptions;
	// Interpret and default an options object

	function getOptions(opts) {
	  var options = {};
	  for (var opt in defaultOptions) {
	    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
	  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

	  if (_util.isArray(options.onToken)) {
	    (function () {
	      var tokens = options.onToken;
	      options.onToken = function (token) {
	        return tokens.push(token);
	      };
	    })();
	  }
	  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

	  return options;
	}

	function pushComment(options, array) {
	  return function (block, text, start, end, startLoc, endLoc) {
	    var comment = {
	      type: block ? 'Block' : 'Line',
	      value: text,
	      start: start,
	      end: end
	    };
	    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
	    if (options.ranges) comment.range = [start, end];
	    array.push(comment);
	  };
	}

	},{"./locutil":5,"./util":15}],9:[function(_dereq_,module,exports){
	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _whitespace = _dereq_("./whitespace");

	var pp = _state.Parser.prototype;

	// ## Parser utilities

	// Test whether a statement node is the string literal `"use strict"`.

	pp.isUseStrict = function (stmt) {
	  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
	};

	// Predicate that tests whether the next token is of the given
	// type, and if yes, consumes it as a side effect.

	pp.eat = function (type) {
	  if (this.type === type) {
	    this.next();
	    return true;
	  } else {
	    return false;
	  }
	};

	// Tests whether parsed token is a contextual keyword.

	pp.isContextual = function (name) {
	  return this.type === _tokentype.types.name && this.value === name;
	};

	// Consumes contextual keyword if possible.

	pp.eatContextual = function (name) {
	  return this.value === name && this.eat(_tokentype.types.name);
	};

	// Asserts that following token is given contextual keyword.

	pp.expectContextual = function (name) {
	  if (!this.eatContextual(name)) this.unexpected();
	};

	// Test whether a semicolon can be inserted at the current position.

	pp.canInsertSemicolon = function () {
	  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	};

	pp.insertSemicolon = function () {
	  if (this.canInsertSemicolon()) {
	    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
	    return true;
	  }
	};

	// Consume a semicolon, or, failing that, see if we are allowed to
	// pretend that there is a semicolon at this position.

	pp.semicolon = function () {
	  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
	};

	pp.afterTrailingComma = function (tokType) {
	  if (this.type == tokType) {
	    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
	    this.next();
	    return true;
	  }
	};

	// Expect a token of a given type. If found, consume it, otherwise,
	// raise an unexpected token error.

	pp.expect = function (type) {
	  this.eat(type) || this.unexpected();
	};

	// Raise an unexpected token error.

	pp.unexpected = function (pos) {
	  this.raise(pos != null ? pos : this.start, "Unexpected token");
	};

	pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
	  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
	  if (!andThrow) return !!pos;
	  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
	};

	pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
	  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
	  if (!andThrow) return !!pos;
	  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
	};

	},{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _identifier = _dereq_("./identifier");

	var _tokentype = _dereq_("./tokentype");

	var _whitespace = _dereq_("./whitespace");

	var _options = _dereq_("./options");

	// Registered plugins
	var plugins = {};

	exports.plugins = plugins;
	function keywordRegexp(words) {
	  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
	}

	var Parser = (function () {
	  function Parser(options, input, startPos) {
	    _classCallCheck(this, Parser);

	    this.options = options = _options.getOptions(options);
	    this.sourceFile = options.sourceFile;
	    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
	    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
	    this.reservedWords = keywordRegexp(reserved);
	    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
	    this.reservedWordsStrict = keywordRegexp(reservedStrict);
	    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
	    this.input = String(input);

	    // Used to signal to callers of `readWord1` whether the word
	    // contained any escape sequences. This is needed because words with
	    // escape sequences must not be interpreted as keywords.
	    this.containsEsc = false;

	    // Load plugins
	    this.loadPlugins(options.plugins);

	    // Set up token state

	    // The current position of the tokenizer in the input.
	    if (startPos) {
	      this.pos = startPos;
	      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
	      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
	    } else {
	      this.pos = this.lineStart = 0;
	      this.curLine = 1;
	    }

	    // Properties of the current token:
	    // Its type
	    this.type = _tokentype.types.eof;
	    // For tokens that include more information than their type, the value
	    this.value = null;
	    // Its start and end offset
	    this.start = this.end = this.pos;
	    // And, if locations are used, the {line, column} object
	    // corresponding to those offsets
	    this.startLoc = this.endLoc = this.curPosition();

	    // Position information for the previous token
	    this.lastTokEndLoc = this.lastTokStartLoc = null;
	    this.lastTokStart = this.lastTokEnd = this.pos;

	    // The context stack is used to superficially track syntactic
	    // context to predict whether a regular expression is allowed in a
	    // given position.
	    this.context = this.initialContext();
	    this.exprAllowed = true;

	    // Figure out if it's a module code.
	    this.strict = this.inModule = options.sourceType === "module";

	    // Used to signify the start of a potential arrow function
	    this.potentialArrowAt = -1;

	    // Flags to track whether we are in a function, a generator.
	    this.inFunction = this.inGenerator = false;
	    // Labels in scope.
	    this.labels = [];

	    // If enabled, skip leading hashbang line.
	    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);
	  }

	  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them

	  Parser.prototype.isKeyword = function isKeyword(word) {
	    return this.keywords.test(word);
	  };

	  Parser.prototype.isReservedWord = function isReservedWord(word) {
	    return this.reservedWords.test(word);
	  };

	  Parser.prototype.extend = function extend(name, f) {
	    this[name] = f(this[name]);
	  };

	  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
	    for (var _name in pluginConfigs) {
	      var plugin = plugins[_name];
	      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
	      plugin(this, pluginConfigs[_name]);
	    }
	  };

	  Parser.prototype.parse = function parse() {
	    var node = this.options.program || this.startNode();
	    this.nextToken();
	    return this.parseTopLevel(node);
	  };

	  return Parser;
	})();

	exports.Parser = Parser;

	},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){
	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _whitespace = _dereq_("./whitespace");

	var pp = _state.Parser.prototype;

	// ### Statement parsing

	// Parse a program. Initializes the parser, reads any number of
	// statements, and wraps them in a Program node.  Optionally takes a
	// `program` argument.  If present, the statements will be appended
	// to its body instead of creating a new node.

	pp.parseTopLevel = function (node) {
	  var first = true;
	  if (!node.body) node.body = [];
	  while (this.type !== _tokentype.types.eof) {
	    var stmt = this.parseStatement(true, true);
	    node.body.push(stmt);
	    if (first) {
	      if (this.isUseStrict(stmt)) this.setStrict(true);
	      first = false;
	    }
	  }
	  this.next();
	  if (this.options.ecmaVersion >= 6) {
	    node.sourceType = this.options.sourceType;
	  }
	  return this.finishNode(node, "Program");
	};

	var loopLabel = { kind: "loop" },
	    switchLabel = { kind: "switch" };

	// Parse a single statement.
	//
	// If expecting a statement and finding a slash operator, parse a
	// regular expression literal. This is to handle cases like
	// `if (foo) /blah/.exec(foo)`, where looking at the previous token
	// does not help.

	pp.parseStatement = function (declaration, topLevel) {
	  var starttype = this.type,
	      node = this.startNode();

	  // Most types of statements are recognized by the keyword they
	  // start with. Many are trivial to parse, some require a bit of
	  // complexity.

	  switch (starttype) {
	    case _tokentype.types._break:case _tokentype.types._continue:
	      return this.parseBreakContinueStatement(node, starttype.keyword);
	    case _tokentype.types._debugger:
	      return this.parseDebuggerStatement(node);
	    case _tokentype.types._do:
	      return this.parseDoStatement(node);
	    case _tokentype.types._for:
	      return this.parseForStatement(node);
	    case _tokentype.types._function:
	      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
	      return this.parseFunctionStatement(node);
	    case _tokentype.types._class:
	      if (!declaration) this.unexpected();
	      return this.parseClass(node, true);
	    case _tokentype.types._if:
	      return this.parseIfStatement(node);
	    case _tokentype.types._return:
	      return this.parseReturnStatement(node);
	    case _tokentype.types._switch:
	      return this.parseSwitchStatement(node);
	    case _tokentype.types._throw:
	      return this.parseThrowStatement(node);
	    case _tokentype.types._try:
	      return this.parseTryStatement(node);
	    case _tokentype.types._let:case _tokentype.types._const:
	      if (!declaration) this.unexpected(); // NOTE: falls through to _var
	    case _tokentype.types._var:
	      return this.parseVarStatement(node, starttype);
	    case _tokentype.types._while:
	      return this.parseWhileStatement(node);
	    case _tokentype.types._with:
	      return this.parseWithStatement(node);
	    case _tokentype.types.braceL:
	      return this.parseBlock();
	    case _tokentype.types.semi:
	      return this.parseEmptyStatement(node);
	    case _tokentype.types._export:
	    case _tokentype.types._import:
	      if (!this.options.allowImportExportEverywhere) {
	        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
	        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
	      }
	      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);

	    // If the statement does not start with a statement keyword or a
	    // brace, it's an ExpressionStatement or LabeledStatement. We
	    // simply start parsing an expression, and afterwards, if the
	    // next token is a colon and the expression was a simple
	    // Identifier node, we switch to interpreting it as a label.
	    default:
	      var maybeName = this.value,
	          expr = this.parseExpression();
	      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
	  }
	};

	pp.parseBreakContinueStatement = function (node, keyword) {
	  var isBreak = keyword == "break";
	  this.next();
	  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
	    node.label = this.parseIdent();
	    this.semicolon();
	  }

	  // Verify that there is an actual destination to break or
	  // continue to.
	  for (var i = 0; i < this.labels.length; ++i) {
	    var lab = this.labels[i];
	    if (node.label == null || lab.name === node.label.name) {
	      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
	      if (node.label && isBreak) break;
	    }
	  }
	  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	};

	pp.parseDebuggerStatement = function (node) {
	  this.next();
	  this.semicolon();
	  return this.finishNode(node, "DebuggerStatement");
	};

	pp.parseDoStatement = function (node) {
	  this.next();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  this.expect(_tokentype.types._while);
	  node.test = this.parseParenExpression();
	  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
	  return this.finishNode(node, "DoWhileStatement");
	};

	// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	// loop is non-trivial. Basically, we have to parse the init `var`
	// statement or expression, disallowing the `in` operator (see
	// the second parameter to `parseExpression`), and then check
	// whether the next token is `in` or `of`. When there is no init
	// part (semicolon immediately after the opening parenthesis), it
	// is a regular `for` loop.

	pp.parseForStatement = function (node) {
	  this.next();
	  this.labels.push(loopLabel);
	  this.expect(_tokentype.types.parenL);
	  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
	  if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) {
	    var _init = this.startNode(),
	        varKind = this.type;
	    this.next();
	    this.parseVar(_init, true, varKind);
	    this.finishNode(_init, "VariableDeclaration");
	    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
	    return this.parseFor(node, _init);
	  }
	  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
	  var init = this.parseExpression(true, refDestructuringErrors);
	  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
	    this.checkPatternErrors(refDestructuringErrors, true);
	    this.toAssignable(init);
	    this.checkLVal(init);
	    return this.parseForIn(node, init);
	  } else {
	    this.checkExpressionErrors(refDestructuringErrors, true);
	  }
	  return this.parseFor(node, init);
	};

	pp.parseFunctionStatement = function (node) {
	  this.next();
	  return this.parseFunction(node, true);
	};

	pp.parseIfStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  node.consequent = this.parseStatement(false);
	  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
	  return this.finishNode(node, "IfStatement");
	};

	pp.parseReturnStatement = function (node) {
	  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	  this.next();

	  // In `return` (and `break`/`continue`), the keywords with
	  // optional arguments, we eagerly look for a semicolon or the
	  // possibility to insert one.

	  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
	    node.argument = this.parseExpression();this.semicolon();
	  }
	  return this.finishNode(node, "ReturnStatement");
	};

	pp.parseSwitchStatement = function (node) {
	  this.next();
	  node.discriminant = this.parseParenExpression();
	  node.cases = [];
	  this.expect(_tokentype.types.braceL);
	  this.labels.push(switchLabel);

	  // Statements under must be grouped (by label) in SwitchCase
	  // nodes. `cur` is used to keep the node that we are currently
	  // adding statements to.

	  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
	    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
	      var isCase = this.type === _tokentype.types._case;
	      if (cur) this.finishNode(cur, "SwitchCase");
	      node.cases.push(cur = this.startNode());
	      cur.consequent = [];
	      this.next();
	      if (isCase) {
	        cur.test = this.parseExpression();
	      } else {
	        if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
	        sawDefault = true;
	        cur.test = null;
	      }
	      this.expect(_tokentype.types.colon);
	    } else {
	      if (!cur) this.unexpected();
	      cur.consequent.push(this.parseStatement(true));
	    }
	  }
	  if (cur) this.finishNode(cur, "SwitchCase");
	  this.next(); // Closing brace
	  this.labels.pop();
	  return this.finishNode(node, "SwitchStatement");
	};

	pp.parseThrowStatement = function (node) {
	  this.next();
	  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	  node.argument = this.parseExpression();
	  this.semicolon();
	  return this.finishNode(node, "ThrowStatement");
	};

	// Reused empty array added for node fields that are always empty.

	var empty = [];

	pp.parseTryStatement = function (node) {
	  this.next();
	  node.block = this.parseBlock();
	  node.handler = null;
	  if (this.type === _tokentype.types._catch) {
	    var clause = this.startNode();
	    this.next();
	    this.expect(_tokentype.types.parenL);
	    clause.param = this.parseBindingAtom();
	    this.checkLVal(clause.param, true);
	    this.expect(_tokentype.types.parenR);
	    clause.body = this.parseBlock();
	    node.handler = this.finishNode(clause, "CatchClause");
	  }
	  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
	  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	  return this.finishNode(node, "TryStatement");
	};

	pp.parseVarStatement = function (node, kind) {
	  this.next();
	  this.parseVar(node, false, kind);
	  this.semicolon();
	  return this.finishNode(node, "VariableDeclaration");
	};

	pp.parseWhileStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "WhileStatement");
	};

	pp.parseWithStatement = function (node) {
	  if (this.strict) this.raise(this.start, "'with' in strict mode");
	  this.next();
	  node.object = this.parseParenExpression();
	  node.body = this.parseStatement(false);
	  return this.finishNode(node, "WithStatement");
	};

	pp.parseEmptyStatement = function (node) {
	  this.next();
	  return this.finishNode(node, "EmptyStatement");
	};

	pp.parseLabeledStatement = function (node, maybeName, expr) {
	  for (var i = 0; i < this.labels.length; ++i) {
	    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
	  for (var i = this.labels.length - 1; i >= 0; i--) {
	    var label = this.labels[i];
	    if (label.statementStart == node.start) {
	      label.statementStart = this.start;
	      label.kind = kind;
	    } else break;
	  }
	  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
	  node.body = this.parseStatement(true);
	  this.labels.pop();
	  node.label = expr;
	  return this.finishNode(node, "LabeledStatement");
	};

	pp.parseExpressionStatement = function (node, expr) {
	  node.expression = expr;
	  this.semicolon();
	  return this.finishNode(node, "ExpressionStatement");
	};

	// Parse a semicolon-enclosed block of statements, handling `"use
	// strict"` declarations when `allowStrict` is true (used for
	// function bodies).

	pp.parseBlock = function (allowStrict) {
	  var node = this.startNode(),
	      first = true,
	      oldStrict = undefined;
	  node.body = [];
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    var stmt = this.parseStatement(true);
	    node.body.push(stmt);
	    if (first && allowStrict && this.isUseStrict(stmt)) {
	      oldStrict = this.strict;
	      this.setStrict(this.strict = true);
	    }
	    first = false;
	  }
	  if (oldStrict === false) this.setStrict(false);
	  return this.finishNode(node, "BlockStatement");
	};

	// Parse a regular `for` loop. The disambiguation code in
	// `parseStatement` will already have parsed the init statement or
	// expression.

	pp.parseFor = function (node, init) {
	  node.init = init;
	  this.expect(_tokentype.types.semi);
	  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
	  this.expect(_tokentype.types.semi);
	  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "ForStatement");
	};

	// Parse a `for`/`in` and `for`/`of` loop, which are almost
	// same from parser's perspective.

	pp.parseForIn = function (node, init) {
	  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
	  this.next();
	  node.left = init;
	  node.right = this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, type);
	};

	// Parse a list of variable declarations.

	pp.parseVar = function (node, isFor, kind) {
	  node.declarations = [];
	  node.kind = kind.keyword;
	  for (;;) {
	    var decl = this.startNode();
	    this.parseVarId(decl);
	    if (this.eat(_tokentype.types.eq)) {
	      decl.init = this.parseMaybeAssign(isFor);
	    } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	      this.unexpected();
	    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
	      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
	    } else {
	      decl.init = null;
	    }
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	    if (!this.eat(_tokentype.types.comma)) break;
	  }
	  return node;
	};

	pp.parseVarId = function (decl) {
	  decl.id = this.parseBindingAtom();
	  this.checkLVal(decl.id, true);
	};

	// Parse a function declaration or literal (depending on the
	// `isStatement` parameter).

	pp.parseFunction = function (node, isStatement, allowExpressionBody) {
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
	  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
	  this.parseFunctionParams(node);
	  this.parseFunctionBody(node, allowExpressionBody);
	  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	};

	pp.parseFunctionParams = function (node) {
	  this.expect(_tokentype.types.parenL);
	  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
	};

	// Parse a class declaration or literal (depending on the
	// `isStatement` parameter).

	pp.parseClass = function (node, isStatement) {
	  this.next();
	  this.parseClassId(node, isStatement);
	  this.parseClassSuper(node);
	  var classBody = this.startNode();
	  var hadConstructor = false;
	  classBody.body = [];
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (this.eat(_tokentype.types.semi)) continue;
	    var method = this.startNode();
	    var isGenerator = this.eat(_tokentype.types.star);
	    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
	    this.parsePropertyName(method);
	    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
	    if (method["static"]) {
	      if (isGenerator) this.unexpected();
	      isGenerator = this.eat(_tokentype.types.star);
	      this.parsePropertyName(method);
	    }
	    method.kind = "method";
	    var isGetSet = false;
	    if (!method.computed) {
	      var key = method.key;

	      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
	        isGetSet = true;
	        method.kind = key.name;
	        key = this.parsePropertyName(method);
	      }
	      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
	        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
	        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
	        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
	        method.kind = "constructor";
	        hadConstructor = true;
	      }
	    }
	    this.parseClassMethod(classBody, method, isGenerator);
	    if (isGetSet) {
	      var paramCount = method.kind === "get" ? 0 : 1;
	      if (method.value.params.length !== paramCount) {
	        var start = method.value.start;
	        if (method.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
	      }
	    }
	  }
	  node.body = this.finishNode(classBody, "ClassBody");
	  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	};

	pp.parseClassMethod = function (classBody, method, isGenerator) {
	  method.value = this.parseMethod(isGenerator);
	  classBody.body.push(this.finishNode(method, "MethodDefinition"));
	};

	pp.parseClassId = function (node, isStatement) {
	  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
	};

	pp.parseClassSuper = function (node) {
	  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
	};

	// Parses module export declaration.

	pp.parseExport = function (node) {
	  this.next();
	  // export * from '...'
	  if (this.eat(_tokentype.types.star)) {
	    this.expectContextual("from");
	    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	    this.semicolon();
	    return this.finishNode(node, "ExportAllDeclaration");
	  }
	  if (this.eat(_tokentype.types._default)) {
	    // export default ...
	    var expr = this.parseMaybeAssign();
	    var needsSemi = true;
	    if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
	      needsSemi = false;
	      if (expr.id) {
	        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
	      }
	    }
	    node.declaration = expr;
	    if (needsSemi) this.semicolon();
	    return this.finishNode(node, "ExportDefaultDeclaration");
	  }
	  // export var|const|let|function|class ...
	  if (this.shouldParseExportStatement()) {
	    node.declaration = this.parseStatement(true);
	    node.specifiers = [];
	    node.source = null;
	  } else {
	    // export { x, y as z } [from '...']
	    node.declaration = null;
	    node.specifiers = this.parseExportSpecifiers();
	    if (this.eatContextual("from")) {
	      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	    } else {
	      // check for keywords used as local names
	      for (var i = 0; i < node.specifiers.length; i++) {
	        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
	          this.unexpected(node.specifiers[i].local.start);
	        }
	      }

	      node.source = null;
	    }
	    this.semicolon();
	  }
	  return this.finishNode(node, "ExportNamedDeclaration");
	};

	pp.shouldParseExportStatement = function () {
	  return this.type.keyword;
	};

	// Parses a comma-separated list of module exports.

	pp.parseExportSpecifiers = function () {
	  var nodes = [],
	      first = true;
	  // export { x, y as z } [from '...']
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;

	    var node = this.startNode();
	    node.local = this.parseIdent(this.type === _tokentype.types._default);
	    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
	    nodes.push(this.finishNode(node, "ExportSpecifier"));
	  }
	  return nodes;
	};

	// Parses import declaration.

	pp.parseImport = function (node) {
	  this.next();
	  // import '...'
	  if (this.type === _tokentype.types.string) {
	    node.specifiers = empty;
	    node.source = this.parseExprAtom();
	  } else {
	    node.specifiers = this.parseImportSpecifiers();
	    this.expectContextual("from");
	    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	  }
	  this.semicolon();
	  return this.finishNode(node, "ImportDeclaration");
	};

	// Parses a comma-separated list of module imports.

	pp.parseImportSpecifiers = function () {
	  var nodes = [],
	      first = true;
	  if (this.type === _tokentype.types.name) {
	    // import defaultObj, { x, y as z } from '...'
	    var node = this.startNode();
	    node.local = this.parseIdent();
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
	    if (!this.eat(_tokentype.types.comma)) return nodes;
	  }
	  if (this.type === _tokentype.types.star) {
	    var node = this.startNode();
	    this.next();
	    this.expectContextual("as");
	    node.local = this.parseIdent();
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
	    return nodes;
	  }
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;

	    var node = this.startNode();
	    node.imported = this.parseIdent(true);
	    node.local = this.eatContextual("as") ? this.parseIdent() : node.imported;
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportSpecifier"));
	  }
	  return nodes;
	};

	},{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(_dereq_,module,exports){
	// The algorithm used to determine whether a regexp can appear at a
	// given point in the program is loosely based on sweet.js' approach.
	// See https://github.com/mozilla/sweet.js/wiki/design

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _state = _dereq_("./state");

	var _tokentype = _dereq_("./tokentype");

	var _whitespace = _dereq_("./whitespace");

	var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
	  _classCallCheck(this, TokContext);

	  this.token = token;
	  this.isExpr = !!isExpr;
	  this.preserveSpace = !!preserveSpace;
	  this.override = override;
	};

	exports.TokContext = TokContext;
	var types = {
	  b_stat: new TokContext("{", false),
	  b_expr: new TokContext("{", true),
	  b_tmpl: new TokContext("${", true),
	  p_stat: new TokContext("(", false),
	  p_expr: new TokContext("(", true),
	  q_tmpl: new TokContext("`", true, true, function (p) {
	    return p.readTmplToken();
	  }),
	  f_expr: new TokContext("function", true)
	};

	exports.types = types;
	var pp = _state.Parser.prototype;

	pp.initialContext = function () {
	  return [types.b_stat];
	};

	pp.braceIsBlock = function (prevType) {
	  if (prevType === _tokentype.types.colon) {
	    var _parent = this.curContext();
	    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
	  }
	  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
	  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
	  return !this.exprAllowed;
	};

	pp.updateContext = function (prevType) {
	  var update = undefined,
	      type = this.type;
	  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
	};

	// Token-specific context update code

	_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
	  if (this.context.length == 1) {
	    this.exprAllowed = true;
	    return;
	  }
	  var out = this.context.pop();
	  if (out === types.b_stat && this.curContext() === types.f_expr) {
	    this.context.pop();
	    this.exprAllowed = false;
	  } else if (out === types.b_tmpl) {
	    this.exprAllowed = true;
	  } else {
	    this.exprAllowed = !out.isExpr;
	  }
	};

	_tokentype.types.braceL.updateContext = function (prevType) {
	  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
	  this.exprAllowed = true;
	};

	_tokentype.types.dollarBraceL.updateContext = function () {
	  this.context.push(types.b_tmpl);
	  this.exprAllowed = true;
	};

	_tokentype.types.parenL.updateContext = function (prevType) {
	  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
	  this.context.push(statementParens ? types.p_stat : types.p_expr);
	  this.exprAllowed = true;
	};

	_tokentype.types.incDec.updateContext = function () {
	  // tokExprAllowed stays unchanged
	};

	_tokentype.types._function.updateContext = function () {
	  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
	  this.exprAllowed = false;
	};

	_tokentype.types.backQuote.updateContext = function () {
	  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
	  this.exprAllowed = false;
	};

	},{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _identifier = _dereq_("./identifier");

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _locutil = _dereq_("./locutil");

	var _whitespace = _dereq_("./whitespace");

	// Object type used to represent tokens. Note that normally, tokens
	// simply exist as properties on the parser object. This is only
	// used for the onToken callback and the external tokenizer.

	var Token = function Token(p) {
	  _classCallCheck(this, Token);

	  this.type = p.type;
	  this.value = p.value;
	  this.start = p.start;
	  this.end = p.end;
	  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
	  if (p.options.ranges) this.range = [p.start, p.end];
	}

	// ## Tokenizer

	;

	exports.Token = Token;
	var pp = _state.Parser.prototype;

	// Are we running under Rhino?
	var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

	// Move to the next token

	pp.next = function () {
	  if (this.options.onToken) this.options.onToken(new Token(this));

	  this.lastTokEnd = this.end;
	  this.lastTokStart = this.start;
	  this.lastTokEndLoc = this.endLoc;
	  this.lastTokStartLoc = this.startLoc;
	  this.nextToken();
	};

	pp.getToken = function () {
	  this.next();
	  return new Token(this);
	};

	// If we're in an ES6 environment, make parsers iterable
	if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
	  var self = this;
	  return { next: function next() {
	      var token = self.getToken();
	      return {
	        done: token.type === _tokentype.types.eof,
	        value: token
	      };
	    } };
	};

	// Toggle strict mode. Re-reads the next number or string to please
	// pedantic tests (`"use strict"; 010;` should fail).

	pp.setStrict = function (strict) {
	  this.strict = strict;
	  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
	  this.pos = this.start;
	  if (this.options.locations) {
	    while (this.pos < this.lineStart) {
	      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
	      --this.curLine;
	    }
	  }
	  this.nextToken();
	};

	pp.curContext = function () {
	  return this.context[this.context.length - 1];
	};

	// Read a single token, updating the parser object's token-related
	// properties.

	pp.nextToken = function () {
	  var curContext = this.curContext();
	  if (!curContext || !curContext.preserveSpace) this.skipSpace();

	  this.start = this.pos;
	  if (this.options.locations) this.startLoc = this.curPosition();
	  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

	  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
	};

	pp.readToken = function (code) {
	  // Identifier or keyword. '\uXXXX' sequences are allowed in
	  // identifiers, so '\' also dispatches to that.
	  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

	  return this.getTokenFromCode(code);
	};

	pp.fullCharCodeAtPos = function () {
	  var code = this.input.charCodeAt(this.pos);
	  if (code <= 0xd7ff || code >= 0xe000) return code;
	  var next = this.input.charCodeAt(this.pos + 1);
	  return (code << 10) + next - 0x35fdc00;
	};

	pp.skipBlockComment = function () {
	  var startLoc = this.options.onComment && this.curPosition();
	  var start = this.pos,
	      end = this.input.indexOf("*/", this.pos += 2);
	  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	  this.pos = end + 2;
	  if (this.options.locations) {
	    _whitespace.lineBreakG.lastIndex = start;
	    var match = undefined;
	    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
	      ++this.curLine;
	      this.lineStart = match.index + match[0].length;
	    }
	  }
	  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
	};

	pp.skipLineComment = function (startSkip) {
	  var start = this.pos;
	  var startLoc = this.options.onComment && this.curPosition();
	  var ch = this.input.charCodeAt(this.pos += startSkip);
	  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	    ++this.pos;
	    ch = this.input.charCodeAt(this.pos);
	  }
	  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
	};

	// Called at the start of the parse and after every token. Skips
	// whitespace and comments, and.

	pp.skipSpace = function () {
	  loop: while (this.pos < this.input.length) {
	    var ch = this.input.charCodeAt(this.pos);
	    switch (ch) {
	      case 32:case 160:
	        // ' '
	        ++this.pos;
	        break;
	      case 13:
	        if (this.input.charCodeAt(this.pos + 1) === 10) {
	          ++this.pos;
	        }
	      case 10:case 8232:case 8233:
	        ++this.pos;
	        if (this.options.locations) {
	          ++this.curLine;
	          this.lineStart = this.pos;
	        }
	        break;
	      case 47:
	        // '/'
	        switch (this.input.charCodeAt(this.pos + 1)) {
	          case 42:
	            // '*'
	            this.skipBlockComment();
	            break;
	          case 47:
	            this.skipLineComment(2);
	            break;
	          default:
	            break loop;
	        }
	        break;
	      default:
	        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	          ++this.pos;
	        } else {
	          break loop;
	        }
	    }
	  }
	};

	// Called at the end of every token. Sets `end`, `val`, and
	// maintains `context` and `exprAllowed`, and skips the space after
	// the token, so that the next one's `start` will point at the
	// right position.

	pp.finishToken = function (type, val) {
	  this.end = this.pos;
	  if (this.options.locations) this.endLoc = this.curPosition();
	  var prevType = this.type;
	  this.type = type;
	  this.value = val;

	  this.updateContext(prevType);
	};

	// ### Token reading

	// This is the function that is called to fetch the next token. It
	// is somewhat obscure, because it works in character codes rather
	// than characters, and because operator parsing has been inlined
	// into it.
	//
	// All in the name of speed.
	//
	pp.readToken_dot = function () {
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next >= 48 && next <= 57) return this.readNumber(true);
	  var next2 = this.input.charCodeAt(this.pos + 2);
	  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
	    // 46 = dot '.'
	    this.pos += 3;
	    return this.finishToken(_tokentype.types.ellipsis);
	  } else {
	    ++this.pos;
	    return this.finishToken(_tokentype.types.dot);
	  }
	};

	pp.readToken_slash = function () {
	  // '/'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (this.exprAllowed) {
	    ++this.pos;return this.readRegexp();
	  }
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.slash, 1);
	};

	pp.readToken_mult_modulo = function (code) {
	  // '%*'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(code === 42 ? _tokentype.types.star : _tokentype.types.modulo, 1);
	};

	pp.readToken_pipe_amp = function (code) {
	  // '|&'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
	};

	pp.readToken_caret = function () {
	  // '^'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
	};

	pp.readToken_plus_min = function (code) {
	  // '+-'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) {
	    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
	      // A `-->` line comment
	      this.skipLineComment(3);
	      this.skipSpace();
	      return this.nextToken();
	    }
	    return this.finishOp(_tokentype.types.incDec, 2);
	  }
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.plusMin, 1);
	};

	pp.readToken_lt_gt = function (code) {
	  // '<>'
	  var next = this.input.charCodeAt(this.pos + 1);
	  var size = 1;
	  if (next === code) {
	    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
	    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
	    return this.finishOp(_tokentype.types.bitShift, size);
	  }
	  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
	    if (this.inModule) this.unexpected();
	    // `<!--`, an XML-style comment that should be interpreted as a line comment
	    this.skipLineComment(4);
	    this.skipSpace();
	    return this.nextToken();
	  }
	  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
	  return this.finishOp(_tokentype.types.relational, size);
	};

	pp.readToken_eq_excl = function (code) {
	  // '=!'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
	    // '=>'
	    this.pos += 2;
	    return this.finishToken(_tokentype.types.arrow);
	  }
	  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
	};

	pp.getTokenFromCode = function (code) {
	  switch (code) {
	    // The interpretation of a dot depends on whether it is followed
	    // by a digit or another two dots.
	    case 46:
	      // '.'
	      return this.readToken_dot();

	    // Punctuation tokens.
	    case 40:
	      ++this.pos;return this.finishToken(_tokentype.types.parenL);
	    case 41:
	      ++this.pos;return this.finishToken(_tokentype.types.parenR);
	    case 59:
	      ++this.pos;return this.finishToken(_tokentype.types.semi);
	    case 44:
	      ++this.pos;return this.finishToken(_tokentype.types.comma);
	    case 91:
	      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
	    case 93:
	      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
	    case 123:
	      ++this.pos;return this.finishToken(_tokentype.types.braceL);
	    case 125:
	      ++this.pos;return this.finishToken(_tokentype.types.braceR);
	    case 58:
	      ++this.pos;return this.finishToken(_tokentype.types.colon);
	    case 63:
	      ++this.pos;return this.finishToken(_tokentype.types.question);

	    case 96:
	      // '`'
	      if (this.options.ecmaVersion < 6) break;
	      ++this.pos;
	      return this.finishToken(_tokentype.types.backQuote);

	    case 48:
	      // '0'
	      var next = this.input.charCodeAt(this.pos + 1);
	      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
	      if (this.options.ecmaVersion >= 6) {
	        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
	        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
	      }
	    // Anything else beginning with a digit is an integer, octal
	    // number, or float.
	    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
	      // 1-9
	      return this.readNumber(false);

	    // Quotes produce strings.
	    case 34:case 39:
	      // '"', "'"
	      return this.readString(code);

	    // Operators are parsed inline in tiny state machines. '=' (61) is
	    // often referred to. `finishOp` simply skips the amount of
	    // characters it is given as second argument, and returns a token
	    // of the type given by its first argument.

	    case 47:
	      // '/'
	      return this.readToken_slash();

	    case 37:case 42:
	      // '%*'
	      return this.readToken_mult_modulo(code);

	    case 124:case 38:
	      // '|&'
	      return this.readToken_pipe_amp(code);

	    case 94:
	      // '^'
	      return this.readToken_caret();

	    case 43:case 45:
	      // '+-'
	      return this.readToken_plus_min(code);

	    case 60:case 62:
	      // '<>'
	      return this.readToken_lt_gt(code);

	    case 61:case 33:
	      // '=!'
	      return this.readToken_eq_excl(code);

	    case 126:
	      // '~'
	      return this.finishOp(_tokentype.types.prefix, 1);
	  }

	  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};

	pp.finishOp = function (type, size) {
	  var str = this.input.slice(this.pos, this.pos + size);
	  this.pos += size;
	  return this.finishToken(type, str);
	};

	// Parse a regular expression. Some context-awareness is necessary,
	// since a '/' inside a '[]' set does not end the expression.

	function tryCreateRegexp(src, flags, throwErrorAt, parser) {
	  try {
	    return new RegExp(src, flags);
	  } catch (e) {
	    if (throwErrorAt !== undefined) {
	      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
	      throw e;
	    }
	  }
	}

	var regexpUnicodeSupport = !!tryCreateRegexp("￿", "u");

	pp.readRegexp = function () {
	  var _this = this;

	  var escaped = undefined,
	      inClass = undefined,
	      start = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
	    var ch = this.input.charAt(this.pos);
	    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
	    if (!escaped) {
	      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
	      escaped = ch === "\\";
	    } else escaped = false;
	    ++this.pos;
	  }
	  var content = this.input.slice(start, this.pos);
	  ++this.pos;
	  // Need to use `readWord1` because '\uXXXX' sequences are allowed
	  // here (don't ask).
	  var mods = this.readWord1();
	  var tmp = content;
	  if (mods) {
	    var validFlags = /^[gmsiy]*$/;
	    if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
	    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
	    if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {
	      // Replace each astral symbol and every Unicode escape sequence that
	      // possibly represents an astral symbol or a paired surrogate with a
	      // single ASCII symbol to avoid throwing on regular expressions that
	      // are only valid in combination with the `/u` flag.
	      // Note: replacing with the ASCII symbol `x` might cause false
	      // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	      // perfectly valid pattern that is equivalent to `[a-b]`, but it would
	      // be replaced by `[x-b]` which throws an error.
	      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
	        code = Number("0x" + code);
	        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
	        return "x";
	      });
	      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
	    }
	  }
	  // Detect invalid regular expressions.
	  var value = null;
	  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
	  // so don't do detection if we are running under Rhino
	  if (!isRhino) {
	    tryCreateRegexp(tmp, undefined, start, this);
	    // Get a regular expression object for this pattern-flag pair, or `null` in
	    // case the current environment doesn't support the flags it uses.
	    value = tryCreateRegexp(content, mods);
	  }
	  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
	};

	// Read an integer in the given radix. Return null if zero digits
	// were read, the integer value otherwise. When `len` is given, this
	// will return `null` unless the integer has exactly `len` digits.

	pp.readInt = function (radix, len) {
	  var start = this.pos,
	      total = 0;
	  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	    var code = this.input.charCodeAt(this.pos),
	        val = undefined;
	    if (code >= 97) val = code - 97 + 10; // a
	    else if (code >= 65) val = code - 65 + 10; // A
	      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
	        else val = Infinity;
	    if (val >= radix) break;
	    ++this.pos;
	    total = total * radix + val;
	  }
	  if (this.pos === start || len != null && this.pos - start !== len) return null;

	  return total;
	};

	pp.readRadixNumber = function (radix) {
	  this.pos += 2; // 0x
	  var val = this.readInt(radix);
	  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	  return this.finishToken(_tokentype.types.num, val);
	};

	// Read an integer, octal integer, or floating-point number.

	pp.readNumber = function (startsWithDot) {
	  var start = this.pos,
	      isFloat = false,
	      octal = this.input.charCodeAt(this.pos) === 48;
	  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
	  var next = this.input.charCodeAt(this.pos);
	  if (next === 46) {
	    // '.'
	    ++this.pos;
	    this.readInt(10);
	    isFloat = true;
	    next = this.input.charCodeAt(this.pos);
	  }
	  if (next === 69 || next === 101) {
	    // 'eE'
	    next = this.input.charCodeAt(++this.pos);
	    if (next === 43 || next === 45) ++this.pos; // '+-'
	    if (this.readInt(10) === null) this.raise(start, "Invalid number");
	    isFloat = true;
	  }
	  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

	  var str = this.input.slice(start, this.pos),
	      val = undefined;
	  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
	  return this.finishToken(_tokentype.types.num, val);
	};

	// Read a string value, interpreting backslash-escapes.

	pp.readCodePoint = function () {
	  var ch = this.input.charCodeAt(this.pos),
	      code = undefined;

	  if (ch === 123) {
	    if (this.options.ecmaVersion < 6) this.unexpected();
	    var codePos = ++this.pos;
	    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);
	    ++this.pos;
	    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
	  } else {
	    code = this.readHexChar(4);
	  }
	  return code;
	};

	function codePointToString(code) {
	  // UTF-16 Decoding
	  if (code <= 0xFFFF) return String.fromCharCode(code);
	  code -= 0x10000;
	  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
	}

	pp.readString = function (quote) {
	  var out = "",
	      chunkStart = ++this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === quote) break;
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar(false);
	      chunkStart = this.pos;
	    } else {
	      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
	      ++this.pos;
	    }
	  }
	  out += this.input.slice(chunkStart, this.pos++);
	  return this.finishToken(_tokentype.types.string, out);
	};

	// Reads template string tokens.

	pp.readTmplToken = function () {
	  var out = "",
	      chunkStart = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
	      // '`', '${'
	      if (this.pos === this.start && this.type === _tokentype.types.template) {
	        if (ch === 36) {
	          this.pos += 2;
	          return this.finishToken(_tokentype.types.dollarBraceL);
	        } else {
	          ++this.pos;
	          return this.finishToken(_tokentype.types.backQuote);
	        }
	      }
	      out += this.input.slice(chunkStart, this.pos);
	      return this.finishToken(_tokentype.types.template, out);
	    }
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar(true);
	      chunkStart = this.pos;
	    } else if (_whitespace.isNewLine(ch)) {
	      out += this.input.slice(chunkStart, this.pos);
	      ++this.pos;
	      switch (ch) {
	        case 13:
	          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
	        case 10:
	          out += "\n";
	          break;
	        default:
	          out += String.fromCharCode(ch);
	          break;
	      }
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	      chunkStart = this.pos;
	    } else {
	      ++this.pos;
	    }
	  }
	};

	// Used to read escaped characters

	pp.readEscapedChar = function (inTemplate) {
	  var ch = this.input.charCodeAt(++this.pos);
	  ++this.pos;
	  switch (ch) {
	    case 110:
	      return "\n"; // 'n' -> '\n'
	    case 114:
	      return "\r"; // 'r' -> '\r'
	    case 120:
	      return String.fromCharCode(this.readHexChar(2)); // 'x'
	    case 117:
	      return codePointToString(this.readCodePoint()); // 'u'
	    case 116:
	      return "\t"; // 't' -> '\t'
	    case 98:
	      return "\b"; // 'b' -> '\b'
	    case 118:
	      return "\u000b"; // 'v' -> '\u000b'
	    case 102:
	      return "\f"; // 'f' -> '\f'
	    case 13:
	      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
	    case 10:
	      // ' \n'
	      if (this.options.locations) {
	        this.lineStart = this.pos;++this.curLine;
	      }
	      return "";
	    default:
	      if (ch >= 48 && ch <= 55) {
	        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
	        var octal = parseInt(octalStr, 8);
	        if (octal > 255) {
	          octalStr = octalStr.slice(0, -1);
	          octal = parseInt(octalStr, 8);
	        }
	        if (octal > 0 && (this.strict || inTemplate)) {
	          this.raise(this.pos - 2, "Octal literal in strict mode");
	        }
	        this.pos += octalStr.length - 1;
	        return String.fromCharCode(octal);
	      }
	      return String.fromCharCode(ch);
	  }
	};

	// Used to read character escape sequences ('\x', '\u', '\U').

	pp.readHexChar = function (len) {
	  var codePos = this.pos;
	  var n = this.readInt(16, len);
	  if (n === null) this.raise(codePos, "Bad character escape sequence");
	  return n;
	};

	// Read an identifier, and return it as a string. Sets `this.containsEsc`
	// to whether the word contained a '\u' escape.
	//
	// Incrementally adds only escaped chars, adding other chunks as-is
	// as a micro-optimization.

	pp.readWord1 = function () {
	  this.containsEsc = false;
	  var word = "",
	      first = true,
	      chunkStart = this.pos;
	  var astral = this.options.ecmaVersion >= 6;
	  while (this.pos < this.input.length) {
	    var ch = this.fullCharCodeAtPos();
	    if (_identifier.isIdentifierChar(ch, astral)) {
	      this.pos += ch <= 0xffff ? 1 : 2;
	    } else if (ch === 92) {
	      // "\"
	      this.containsEsc = true;
	      word += this.input.slice(chunkStart, this.pos);
	      var escStart = this.pos;
	      if (this.input.charCodeAt(++this.pos) != 117) // "u"
	        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
	      ++this.pos;
	      var esc = this.readCodePoint();
	      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
	      word += codePointToString(esc);
	      chunkStart = this.pos;
	    } else {
	      break;
	    }
	    first = false;
	  }
	  return word + this.input.slice(chunkStart, this.pos);
	};

	// Read an identifier or keyword token. Will check for reserved
	// words when necessary.

	pp.readWord = function () {
	  var word = this.readWord1();
	  var type = _tokentype.types.name;
	  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
	  return this.finishToken(type, word);
	};

	},{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(_dereq_,module,exports){
	// ## Token types

	// The assignment of fine-grained, information-carrying type objects
	// allows the tokenizer to store the information it has about a
	// token in a way that is very cheap for the parser to look up.

	// All token type variables start with an underscore, to make them
	// easy to recognize.

	// The `beforeExpr` property is used to disambiguate between regular
	// expressions and divisions. It is set on all token types that can
	// be followed by an expression (thus, a slash after them would be a
	// regular expression).
	//
	// The `startsExpr` property is used to check if the token ends a
	// `yield` expression. It is set on all token types that either can
	// directly start an expression (like a quotation mark) or can
	// continue an expression (like the body of a string).
	//
	// `isLoop` marks a keyword as starting a loop, which is important
	// to know when parsing a label, in order to allow or disallow
	// continue jumps to that label.

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TokenType = function TokenType(label) {
	  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  _classCallCheck(this, TokenType);

	  this.label = label;
	  this.keyword = conf.keyword;
	  this.beforeExpr = !!conf.beforeExpr;
	  this.startsExpr = !!conf.startsExpr;
	  this.isLoop = !!conf.isLoop;
	  this.isAssign = !!conf.isAssign;
	  this.prefix = !!conf.prefix;
	  this.postfix = !!conf.postfix;
	  this.binop = conf.binop || null;
	  this.updateContext = null;
	};

	exports.TokenType = TokenType;

	function binop(name, prec) {
	  return new TokenType(name, { beforeExpr: true, binop: prec });
	}
	var beforeExpr = { beforeExpr: true },
	    startsExpr = { startsExpr: true };

	var types = {
	  num: new TokenType("num", startsExpr),
	  regexp: new TokenType("regexp", startsExpr),
	  string: new TokenType("string", startsExpr),
	  name: new TokenType("name", startsExpr),
	  eof: new TokenType("eof"),

	  // Punctuation token types.
	  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
	  bracketR: new TokenType("]"),
	  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
	  braceR: new TokenType("}"),
	  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
	  parenR: new TokenType(")"),
	  comma: new TokenType(",", beforeExpr),
	  semi: new TokenType(";", beforeExpr),
	  colon: new TokenType(":", beforeExpr),
	  dot: new TokenType("."),
	  question: new TokenType("?", beforeExpr),
	  arrow: new TokenType("=>", beforeExpr),
	  template: new TokenType("template"),
	  ellipsis: new TokenType("...", beforeExpr),
	  backQuote: new TokenType("`", startsExpr),
	  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

	  // Operators. These carry several kinds of properties to help the
	  // parser use them properly (the presence of these properties is
	  // what categorizes them as operators).
	  //
	  // `binop`, when present, specifies that this operator is a binary
	  // operator, and will refer to its precedence.
	  //
	  // `prefix` and `postfix` mark the operator as a prefix or postfix
	  // unary operator.
	  //
	  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	  // binary operators with a very low precedence, that should result
	  // in AssignmentExpression nodes.

	  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
	  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
	  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
	  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
	  logicalOR: binop("||", 1),
	  logicalAND: binop("&&", 2),
	  bitwiseOR: binop("|", 3),
	  bitwiseXOR: binop("^", 4),
	  bitwiseAND: binop("&", 5),
	  equality: binop("==/!=", 6),
	  relational: binop("</>", 7),
	  bitShift: binop("<</>>", 8),
	  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
	  modulo: binop("%", 10),
	  star: binop("*", 10),
	  slash: binop("/", 10)
	};

	exports.types = types;
	// Map keyword names to token types.

	var keywords = {};

	exports.keywords = keywords;
	// Succinct definitions of keyword token types
	function kw(name) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  options.keyword = name;
	  keywords[name] = types["_" + name] = new TokenType(name, options);
	}

	kw("break");
	kw("case", beforeExpr);
	kw("catch");
	kw("continue");
	kw("debugger");
	kw("default", beforeExpr);
	kw("do", { isLoop: true, beforeExpr: true });
	kw("else", beforeExpr);
	kw("finally");
	kw("for", { isLoop: true });
	kw("function", startsExpr);
	kw("if");
	kw("return", beforeExpr);
	kw("switch");
	kw("throw", beforeExpr);
	kw("try");
	kw("var");
	kw("let");
	kw("const");
	kw("while", { isLoop: true });
	kw("with");
	kw("new", { beforeExpr: true, startsExpr: true });
	kw("this", startsExpr);
	kw("super", startsExpr);
	kw("class");
	kw("extends", beforeExpr);
	kw("export");
	kw("import");
	kw("yield", { beforeExpr: true, startsExpr: true });
	kw("null", startsExpr);
	kw("true", startsExpr);
	kw("false", startsExpr);
	kw("in", { beforeExpr: true, binop: 7 });
	kw("instanceof", { beforeExpr: true, binop: 7 });
	kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

	},{}],15:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.isArray = isArray;
	exports.has = has;

	function isArray(obj) {
	  return Object.prototype.toString.call(obj) === "[object Array]";
	}

	// Checks if an object has a property.

	function has(obj, propName) {
	  return Object.prototype.hasOwnProperty.call(obj, propName);
	}

	},{}],16:[function(_dereq_,module,exports){
	// Matches a whole line break (where CRLF is considered a single
	// line break). Used to count lines.

	"use strict";

	exports.__esModule = true;
	exports.isNewLine = isNewLine;
	var lineBreak = /\r\n?|\n|\u2028|\u2029/;
	exports.lineBreak = lineBreak;
	var lineBreakG = new RegExp(lineBreak.source, "g");

	exports.lineBreakG = lineBreakG;

	function isNewLine(code) {
	  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
	}

	var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
	exports.nonASCIIwhitespace = nonASCIIwhitespace;

	},{}]},{},[3])(3)
	});

/***/ },
/* 179 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 179;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).loose = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";

	module.exports = typeof acorn != 'undefined' ? acorn : __webpack_require__(178);

	},{}],2:[function(_dereq_,module,exports){
	"use strict";

	var _state = _dereq_("./state");

	var _parseutil = _dereq_("./parseutil");

	var _ = _dereq_("..");

	var lp = _state.LooseParser.prototype;

	lp.checkLVal = function (expr) {
	  if (!expr) return expr;
	  switch (expr.type) {
	    case "Identifier":
	    case "MemberExpression":
	      return expr;

	    case "ParenthesizedExpression":
	      expr.expression = this.checkLVal(expr.expression);
	      return expr;

	    default:
	      return this.dummyIdent();
	  }
	};

	lp.parseExpression = function (noIn) {
	  var start = this.storeCurrentPos();
	  var expr = this.parseMaybeAssign(noIn);
	  if (this.tok.type === _.tokTypes.comma) {
	    var node = this.startNodeAt(start);
	    node.expressions = [expr];
	    while (this.eat(_.tokTypes.comma)) node.expressions.push(this.parseMaybeAssign(noIn));
	    return this.finishNode(node, "SequenceExpression");
	  }
	  return expr;
	};

	lp.parseParenExpression = function () {
	  this.pushCx();
	  this.expect(_.tokTypes.parenL);
	  var val = this.parseExpression();
	  this.popCx();
	  this.expect(_.tokTypes.parenR);
	  return val;
	};

	lp.parseMaybeAssign = function (noIn) {
	  var start = this.storeCurrentPos();
	  var left = this.parseMaybeConditional(noIn);
	  if (this.tok.type.isAssign) {
	    var node = this.startNodeAt(start);
	    node.operator = this.tok.value;
	    node.left = this.tok.type === _.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);
	    this.next();
	    node.right = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "AssignmentExpression");
	  }
	  return left;
	};

	lp.parseMaybeConditional = function (noIn) {
	  var start = this.storeCurrentPos();
	  var expr = this.parseExprOps(noIn);
	  if (this.eat(_.tokTypes.question)) {
	    var node = this.startNodeAt(start);
	    node.test = expr;
	    node.consequent = this.parseMaybeAssign();
	    node.alternate = this.expect(_.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
	    return this.finishNode(node, "ConditionalExpression");
	  }
	  return expr;
	};

	lp.parseExprOps = function (noIn) {
	  var start = this.storeCurrentPos();
	  var indent = this.curIndent,
	      line = this.curLineStart;
	  return this.parseExprOp(this.parseMaybeUnary(noIn), start, -1, noIn, indent, line);
	};

	lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
	  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left;
	  var prec = this.tok.type.binop;
	  if (prec != null && (!noIn || this.tok.type !== _.tokTypes._in)) {
	    if (prec > minPrec) {
	      var node = this.startNodeAt(start);
	      node.left = left;
	      node.operator = this.tok.value;
	      this.next();
	      if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
	        node.right = this.dummyIdent();
	      } else {
	        var rightStart = this.storeCurrentPos();
	        node.right = this.parseExprOp(this.parseMaybeUnary(noIn), rightStart, prec, noIn, indent, line);
	      }
	      this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
	      return this.parseExprOp(node, start, minPrec, noIn, indent, line);
	    }
	  }
	  return left;
	};

	lp.parseMaybeUnary = function (noIn) {
	  if (this.tok.type.prefix) {
	    var node = this.startNode(),
	        update = this.tok.type === _.tokTypes.incDec;
	    node.operator = this.tok.value;
	    node.prefix = true;
	    this.next();
	    node.argument = this.parseMaybeUnary(noIn);
	    if (update) node.argument = this.checkLVal(node.argument);
	    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	  } else if (this.tok.type === _.tokTypes.ellipsis) {
	    var node = this.startNode();
	    this.next();
	    node.argument = this.parseMaybeUnary(noIn);
	    return this.finishNode(node, "SpreadElement");
	  }
	  var start = this.storeCurrentPos();
	  var expr = this.parseExprSubscripts();
	  while (this.tok.type.postfix && !this.canInsertSemicolon()) {
	    var node = this.startNodeAt(start);
	    node.operator = this.tok.value;
	    node.prefix = false;
	    node.argument = this.checkLVal(expr);
	    this.next();
	    expr = this.finishNode(node, "UpdateExpression");
	  }
	  return expr;
	};

	lp.parseExprSubscripts = function () {
	  var start = this.storeCurrentPos();
	  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
	};

	lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
	  for (;;) {
	    if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
	      if (this.tok.type == _.tokTypes.dot && this.curIndent == startIndent) --startIndent;else return base;
	    }

	    if (this.eat(_.tokTypes.dot)) {
	      var node = this.startNodeAt(start);
	      node.object = base;
	      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) node.property = this.dummyIdent();else node.property = this.parsePropertyAccessor() || this.dummyIdent();
	      node.computed = false;
	      base = this.finishNode(node, "MemberExpression");
	    } else if (this.tok.type == _.tokTypes.bracketL) {
	      this.pushCx();
	      this.next();
	      var node = this.startNodeAt(start);
	      node.object = base;
	      node.property = this.parseExpression();
	      node.computed = true;
	      this.popCx();
	      this.expect(_.tokTypes.bracketR);
	      base = this.finishNode(node, "MemberExpression");
	    } else if (!noCalls && this.tok.type == _.tokTypes.parenL) {
	      var node = this.startNodeAt(start);
	      node.callee = base;
	      node.arguments = this.parseExprList(_.tokTypes.parenR);
	      base = this.finishNode(node, "CallExpression");
	    } else if (this.tok.type == _.tokTypes.backQuote) {
	      var node = this.startNodeAt(start);
	      node.tag = base;
	      node.quasi = this.parseTemplate();
	      base = this.finishNode(node, "TaggedTemplateExpression");
	    } else {
	      return base;
	    }
	  }
	};

	lp.parseExprAtom = function () {
	  var node = undefined;
	  switch (this.tok.type) {
	    case _.tokTypes._this:
	    case _.tokTypes._super:
	      var type = this.tok.type === _.tokTypes._this ? "ThisExpression" : "Super";
	      node = this.startNode();
	      this.next();
	      return this.finishNode(node, type);

	    case _.tokTypes.name:
	      var start = this.storeCurrentPos();
	      var id = this.parseIdent();
	      return this.eat(_.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id;

	    case _.tokTypes.regexp:
	      node = this.startNode();
	      var val = this.tok.value;
	      node.regex = { pattern: val.pattern, flags: val.flags };
	      node.value = val.value;
	      node.raw = this.input.slice(this.tok.start, this.tok.end);
	      this.next();
	      return this.finishNode(node, "Literal");

	    case _.tokTypes.num:case _.tokTypes.string:
	      node = this.startNode();
	      node.value = this.tok.value;
	      node.raw = this.input.slice(this.tok.start, this.tok.end);
	      this.next();
	      return this.finishNode(node, "Literal");

	    case _.tokTypes._null:case _.tokTypes._true:case _.tokTypes._false:
	      node = this.startNode();
	      node.value = this.tok.type === _.tokTypes._null ? null : this.tok.type === _.tokTypes._true;
	      node.raw = this.tok.type.keyword;
	      this.next();
	      return this.finishNode(node, "Literal");

	    case _.tokTypes.parenL:
	      var parenStart = this.storeCurrentPos();
	      this.next();
	      var inner = this.parseExpression();
	      this.expect(_.tokTypes.parenR);
	      if (this.eat(_.tokTypes.arrow)) {
	        return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (_parseutil.isDummy(inner) ? [] : [inner]));
	      }
	      if (this.options.preserveParens) {
	        var par = this.startNodeAt(parenStart);
	        par.expression = inner;
	        inner = this.finishNode(par, "ParenthesizedExpression");
	      }
	      return inner;

	    case _.tokTypes.bracketL:
	      node = this.startNode();
	      node.elements = this.parseExprList(_.tokTypes.bracketR, true);
	      return this.finishNode(node, "ArrayExpression");

	    case _.tokTypes.braceL:
	      return this.parseObj();

	    case _.tokTypes._class:
	      return this.parseClass();

	    case _.tokTypes._function:
	      node = this.startNode();
	      this.next();
	      return this.parseFunction(node, false);

	    case _.tokTypes._new:
	      return this.parseNew();

	    case _.tokTypes._yield:
	      node = this.startNode();
	      this.next();
	      if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != _.tokTypes.star && !this.tok.type.startsExpr) {
	        node.delegate = false;
	        node.argument = null;
	      } else {
	        node.delegate = this.eat(_.tokTypes.star);
	        node.argument = this.parseMaybeAssign();
	      }
	      return this.finishNode(node, "YieldExpression");

	    case _.tokTypes.backQuote:
	      return this.parseTemplate();

	    default:
	      return this.dummyIdent();
	  }
	};

	lp.parseNew = function () {
	  var node = this.startNode(),
	      startIndent = this.curIndent,
	      line = this.curLineStart;
	  var meta = this.parseIdent(true);
	  if (this.options.ecmaVersion >= 6 && this.eat(_.tokTypes.dot)) {
	    node.meta = meta;
	    node.property = this.parseIdent(true);
	    return this.finishNode(node, "MetaProperty");
	  }
	  var start = this.storeCurrentPos();
	  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
	  if (this.tok.type == _.tokTypes.parenL) {
	    node.arguments = this.parseExprList(_.tokTypes.parenR);
	  } else {
	    node.arguments = [];
	  }
	  return this.finishNode(node, "NewExpression");
	};

	lp.parseTemplateElement = function () {
	  var elem = this.startNode();
	  elem.value = {
	    raw: this.input.slice(this.tok.start, this.tok.end).replace(/\r\n?/g, '\n'),
	    cooked: this.tok.value
	  };
	  this.next();
	  elem.tail = this.tok.type === _.tokTypes.backQuote;
	  return this.finishNode(elem, "TemplateElement");
	};

	lp.parseTemplate = function () {
	  var node = this.startNode();
	  this.next();
	  node.expressions = [];
	  var curElt = this.parseTemplateElement();
	  node.quasis = [curElt];
	  while (!curElt.tail) {
	    this.next();
	    node.expressions.push(this.parseExpression());
	    if (this.expect(_.tokTypes.braceR)) {
	      curElt = this.parseTemplateElement();
	    } else {
	      curElt = this.startNode();
	      curElt.value = { cooked: '', raw: '' };
	      curElt.tail = true;
	    }
	    node.quasis.push(curElt);
	  }
	  this.expect(_.tokTypes.backQuote);
	  return this.finishNode(node, "TemplateLiteral");
	};

	lp.parseObj = function () {
	  var node = this.startNode();
	  node.properties = [];
	  this.pushCx();
	  var indent = this.curIndent + 1,
	      line = this.curLineStart;
	  this.eat(_.tokTypes.braceL);
	  if (this.curIndent + 1 < indent) {
	    indent = this.curIndent;line = this.curLineStart;
	  }
	  while (!this.closes(_.tokTypes.braceR, indent, line)) {
	    var prop = this.startNode(),
	        isGenerator = undefined,
	        start = undefined;
	    if (this.options.ecmaVersion >= 6) {
	      start = this.storeCurrentPos();
	      prop.method = false;
	      prop.shorthand = false;
	      isGenerator = this.eat(_.tokTypes.star);
	    }
	    this.parsePropertyName(prop);
	    if (_parseutil.isDummy(prop.key)) {
	      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
	    }
	    if (this.eat(_.tokTypes.colon)) {
	      prop.kind = "init";
	      prop.value = this.parseMaybeAssign();
	    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === _.tokTypes.parenL || this.tok.type === _.tokTypes.braceL)) {
	      prop.kind = "init";
	      prop.method = true;
	      prop.value = this.parseMethod(isGenerator);
	    } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && (this.tok.type != _.tokTypes.comma && this.tok.type != _.tokTypes.braceR)) {
	      prop.kind = prop.key.name;
	      this.parsePropertyName(prop);
	      prop.value = this.parseMethod(false);
	    } else {
	      prop.kind = "init";
	      if (this.options.ecmaVersion >= 6) {
	        if (this.eat(_.tokTypes.eq)) {
	          var assign = this.startNodeAt(start);
	          assign.operator = "=";
	          assign.left = prop.key;
	          assign.right = this.parseMaybeAssign();
	          prop.value = this.finishNode(assign, "AssignmentExpression");
	        } else {
	          prop.value = prop.key;
	        }
	      } else {
	        prop.value = this.dummyIdent();
	      }
	      prop.shorthand = true;
	    }
	    node.properties.push(this.finishNode(prop, "Property"));
	    this.eat(_.tokTypes.comma);
	  }
	  this.popCx();
	  if (!this.eat(_.tokTypes.braceR)) {
	    // If there is no closing brace, make the node span to the start
	    // of the next token (this is useful for Tern)
	    this.last.end = this.tok.start;
	    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
	  }
	  return this.finishNode(node, "ObjectExpression");
	};

	lp.parsePropertyName = function (prop) {
	  if (this.options.ecmaVersion >= 6) {
	    if (this.eat(_.tokTypes.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseExpression();
	      this.expect(_.tokTypes.bracketR);
	      return;
	    } else {
	      prop.computed = false;
	    }
	  }
	  var key = this.tok.type === _.tokTypes.num || this.tok.type === _.tokTypes.string ? this.parseExprAtom() : this.parseIdent();
	  prop.key = key || this.dummyIdent();
	};

	lp.parsePropertyAccessor = function () {
	  if (this.tok.type === _.tokTypes.name || this.tok.type.keyword) return this.parseIdent();
	};

	lp.parseIdent = function () {
	  var name = this.tok.type === _.tokTypes.name ? this.tok.value : this.tok.type.keyword;
	  if (!name) return this.dummyIdent();
	  var node = this.startNode();
	  this.next();
	  node.name = name;
	  return this.finishNode(node, "Identifier");
	};

	lp.initFunction = function (node) {
	  node.id = null;
	  node.params = [];
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = false;
	    node.expression = false;
	  }
	};

	// Convert existing expression atom to assignable pattern
	// if possible.

	lp.toAssignable = function (node, binding) {
	  if (!node || node.type == "Identifier" || node.type == "MemberExpression" && !binding) {
	    // Okay
	  } else if (node.type == "ParenthesizedExpression") {
	      node.expression = this.toAssignable(node.expression, binding);
	    } else if (this.options.ecmaVersion < 6) {
	      return this.dummyIdent();
	    } else if (node.type == "ObjectExpression") {
	      node.type = "ObjectPattern";
	      var props = node.properties;
	      for (var i = 0; i < props.length; i++) {
	        props[i].value = this.toAssignable(props[i].value, binding);
	      }
	    } else if (node.type == "ArrayExpression") {
	      node.type = "ArrayPattern";
	      this.toAssignableList(node.elements, binding);
	    } else if (node.type == "SpreadElement") {
	      node.type = "RestElement";
	      node.argument = this.toAssignable(node.argument, binding);
	    } else if (node.type == "AssignmentExpression") {
	      node.type = "AssignmentPattern";
	      delete node.operator;
	    } else {
	      return this.dummyIdent();
	    }
	  return node;
	};

	lp.toAssignableList = function (exprList, binding) {
	  for (var i = 0; i < exprList.length; i++) {
	    exprList[i] = this.toAssignable(exprList[i], binding);
	  }return exprList;
	};

	lp.parseFunctionParams = function (params) {
	  params = this.parseExprList(_.tokTypes.parenR);
	  return this.toAssignableList(params, true);
	};

	lp.parseMethod = function (isGenerator) {
	  var node = this.startNode();
	  this.initFunction(node);
	  node.params = this.parseFunctionParams();
	  node.generator = isGenerator || false;
	  node.expression = this.options.ecmaVersion >= 6 && this.tok.type !== _.tokTypes.braceL;
	  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
	  return this.finishNode(node, "FunctionExpression");
	};

	lp.parseArrowExpression = function (node, params) {
	  this.initFunction(node);
	  node.params = this.toAssignableList(params, true);
	  node.expression = this.tok.type !== _.tokTypes.braceL;
	  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
	  return this.finishNode(node, "ArrowFunctionExpression");
	};

	lp.parseExprList = function (close, allowEmpty) {
	  this.pushCx();
	  var indent = this.curIndent,
	      line = this.curLineStart,
	      elts = [];
	  this.next(); // Opening bracket
	  while (!this.closes(close, indent + 1, line)) {
	    if (this.eat(_.tokTypes.comma)) {
	      elts.push(allowEmpty ? null : this.dummyIdent());
	      continue;
	    }
	    var elt = this.parseMaybeAssign();
	    if (_parseutil.isDummy(elt)) {
	      if (this.closes(close, indent, line)) break;
	      this.next();
	    } else {
	      elts.push(elt);
	    }
	    this.eat(_.tokTypes.comma);
	  }
	  this.popCx();
	  if (!this.eat(close)) {
	    // If there is no closing brace, make the node span to the start
	    // of the next token (this is useful for Tern)
	    this.last.end = this.tok.start;
	    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
	  }
	  return elts;
	};

	},{"..":1,"./parseutil":4,"./state":5}],3:[function(_dereq_,module,exports){
	// Acorn: Loose parser
	//
	// This module provides an alternative parser (`parse_dammit`) that
	// exposes that same interface as `parse`, but will try to parse
	// anything as JavaScript, repairing syntax error the best it can.
	// There are circumstances in which it will raise an error and give
	// up, but they are very rare. The resulting AST will be a mostly
	// valid JavaScript AST (as per the [Mozilla parser API][api], except
	// that:
	//
	// - Return outside functions is allowed
	//
	// - Label consistency (no conflicts, break only to existing labels)
	//   is not enforced.
	//
	// - Bogus Identifier nodes with a name of `"✖"` are inserted whenever
	//   the parser got too confused to return anything meaningful.
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
	//
	// The expected use for this is to *first* try `acorn.parse`, and only
	// if that fails switch to `parse_dammit`. The loose parser might
	// parse badly indented code incorrectly, so **don't** use it as
	// your default parser.
	//
	// Quite a lot of acorn.js is duplicated here. The alternative was to
	// add a *lot* of extra cruft to that file, making it less readable
	// and slower. Copying and editing the code allowed me to make
	// invasive changes and simplifications without creating a complicated
	// tangle.

	"use strict";

	exports.__esModule = true;
	exports.parse_dammit = parse_dammit;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

	var _ = _dereq_("..");

	var acorn = _interopRequireWildcard(_);

	var _state = _dereq_("./state");

	_dereq_("./tokenize");

	_dereq_("./statement");

	_dereq_("./expression");

	exports.LooseParser = _state.LooseParser;
	exports.pluginsLoose = _state.pluginsLoose;

	acorn.defaultOptions.tabSize = 4;

	function parse_dammit(input, options) {
	  var p = new _state.LooseParser(input, options);
	  p.next();
	  return p.parseTopLevel();
	}

	// Don't define new properties on acorn because of:
	// TypeError: can't define property "parse_dammit": Object is not extensible
	// acorn.parse_dammit = parse_dammit;
	// acorn.LooseParser = _state.LooseParser;
	// acorn.pluginsLoose = _state.pluginsLoose;

	},{"..":1,"./expression":2,"./state":5,"./statement":6,"./tokenize":7}],4:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.isDummy = isDummy;

	function isDummy(node) {
	  return node.name == "✖";
	}

	},{}],5:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _ = _dereq_("..");

	// Registered plugins
	var pluginsLoose = {};

	exports.pluginsLoose = pluginsLoose;

	var LooseParser = (function () {
	  function LooseParser(input, options) {
	    _classCallCheck(this, LooseParser);

	    this.toks = _.tokenizer(input, options);
	    this.options = this.toks.options;
	    this.input = this.toks.input;
	    this.tok = this.last = { type: _.tokTypes.eof, start: 0, end: 0 };
	    if (this.options.locations) {
	      var here = this.toks.curPosition();
	      this.tok.loc = new _.SourceLocation(this.toks, here, here);
	    }
	    this.ahead = []; // Tokens ahead
	    this.context = []; // Indentation contexted
	    this.curIndent = 0;
	    this.curLineStart = 0;
	    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
	    // Load plugins
	    this.options.pluginsLoose = options.pluginsLoose || {};
	    this.loadPlugins(this.options.pluginsLoose);
	  }

	  LooseParser.prototype.startNode = function startNode() {
	    return new _.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
	  };

	  LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {
	    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
	  };

	  LooseParser.prototype.startNodeAt = function startNodeAt(pos) {
	    if (this.options.locations) {
	      return new _.Node(this.toks, pos[0], pos[1]);
	    } else {
	      return new _.Node(this.toks, pos);
	    }
	  };

	  LooseParser.prototype.finishNode = function finishNode(node, type) {
	    node.type = type;
	    node.end = this.last.end;
	    if (this.options.locations) node.loc.end = this.last.loc.end;
	    if (this.options.ranges) node.range[1] = this.last.end;
	    return node;
	  };

	  LooseParser.prototype.dummyNode = function dummyNode(type) {
	    var dummy = this.startNode();
	    dummy.type = type;
	    dummy.end = dummy.start;
	    if (this.options.locations) dummy.loc.end = dummy.loc.start;
	    if (this.options.ranges) dummy.range[1] = dummy.start;
	    this.last = { type: _.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc };
	    return dummy;
	  };

	  LooseParser.prototype.dummyIdent = function dummyIdent() {
	    var dummy = this.dummyNode("Identifier");
	    dummy.name = "✖";
	    return dummy;
	  };

	  LooseParser.prototype.dummyString = function dummyString() {
	    var dummy = this.dummyNode("Literal");
	    dummy.value = dummy.raw = "✖";
	    return dummy;
	  };

	  LooseParser.prototype.eat = function eat(type) {
	    if (this.tok.type === type) {
	      this.next();
	      return true;
	    } else {
	      return false;
	    }
	  };

	  LooseParser.prototype.isContextual = function isContextual(name) {
	    return this.tok.type === _.tokTypes.name && this.tok.value === name;
	  };

	  LooseParser.prototype.eatContextual = function eatContextual(name) {
	    return this.tok.value === name && this.eat(_.tokTypes.name);
	  };

	  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {
	    return this.tok.type === _.tokTypes.eof || this.tok.type === _.tokTypes.braceR || _.lineBreak.test(this.input.slice(this.last.end, this.tok.start));
	  };

	  LooseParser.prototype.semicolon = function semicolon() {
	    return this.eat(_.tokTypes.semi);
	  };

	  LooseParser.prototype.expect = function expect(type) {
	    if (this.eat(type)) return true;
	    for (var i = 1; i <= 2; i++) {
	      if (this.lookAhead(i).type == type) {
	        for (var j = 0; j < i; j++) {
	          this.next();
	        }return true;
	      }
	    }
	  };

	  LooseParser.prototype.pushCx = function pushCx() {
	    this.context.push(this.curIndent);
	  };

	  LooseParser.prototype.popCx = function popCx() {
	    this.curIndent = this.context.pop();
	  };

	  LooseParser.prototype.lineEnd = function lineEnd(pos) {
	    while (pos < this.input.length && !_.isNewLine(this.input.charCodeAt(pos))) ++pos;
	    return pos;
	  };

	  LooseParser.prototype.indentationAfter = function indentationAfter(pos) {
	    for (var count = 0;; ++pos) {
	      var ch = this.input.charCodeAt(pos);
	      if (ch === 32) ++count;else if (ch === 9) count += this.options.tabSize;else return count;
	    }
	  };

	  LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {
	    if (this.tok.type === closeTok || this.tok.type === _.tokTypes.eof) return true;
	    return line != this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);
	  };

	  LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {
	    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
	      var ch = this.input.charCodeAt(p);
	      if (ch !== 9 && ch !== 32) return false;
	    }
	    return true;
	  };

	  LooseParser.prototype.extend = function extend(name, f) {
	    this[name] = f(this[name]);
	  };

	  LooseParser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
	    for (var _name in pluginConfigs) {
	      var plugin = pluginsLoose[_name];
	      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
	      plugin(this, pluginConfigs[_name]);
	    }
	  };

	  return LooseParser;
	})();

	exports.LooseParser = LooseParser;

	},{"..":1}],6:[function(_dereq_,module,exports){
	"use strict";

	var _state = _dereq_("./state");

	var _parseutil = _dereq_("./parseutil");

	var _ = _dereq_("..");

	var lp = _state.LooseParser.prototype;

	lp.parseTopLevel = function () {
	  var node = this.startNodeAt(this.options.locations ? [0, _.getLineInfo(this.input, 0)] : 0);
	  node.body = [];
	  while (this.tok.type !== _.tokTypes.eof) node.body.push(this.parseStatement());
	  this.last = this.tok;
	  if (this.options.ecmaVersion >= 6) {
	    node.sourceType = this.options.sourceType;
	  }
	  return this.finishNode(node, "Program");
	};

	lp.parseStatement = function () {
	  var starttype = this.tok.type,
	      node = this.startNode();

	  switch (starttype) {
	    case _.tokTypes._break:case _.tokTypes._continue:
	      this.next();
	      var isBreak = starttype === _.tokTypes._break;
	      if (this.semicolon() || this.canInsertSemicolon()) {
	        node.label = null;
	      } else {
	        node.label = this.tok.type === _.tokTypes.name ? this.parseIdent() : null;
	        this.semicolon();
	      }
	      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

	    case _.tokTypes._debugger:
	      this.next();
	      this.semicolon();
	      return this.finishNode(node, "DebuggerStatement");

	    case _.tokTypes._do:
	      this.next();
	      node.body = this.parseStatement();
	      node.test = this.eat(_.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();
	      this.semicolon();
	      return this.finishNode(node, "DoWhileStatement");

	    case _.tokTypes._for:
	      this.next();
	      this.pushCx();
	      this.expect(_.tokTypes.parenL);
	      if (this.tok.type === _.tokTypes.semi) return this.parseFor(node, null);
	      if (this.tok.type === _.tokTypes._var || this.tok.type === _.tokTypes._let || this.tok.type === _.tokTypes._const) {
	        var _init = this.parseVar(true);
	        if (_init.declarations.length === 1 && (this.tok.type === _.tokTypes._in || this.isContextual("of"))) {
	          return this.parseForIn(node, _init);
	        }
	        return this.parseFor(node, _init);
	      }
	      var init = this.parseExpression(true);
	      if (this.tok.type === _.tokTypes._in || this.isContextual("of")) return this.parseForIn(node, this.toAssignable(init));
	      return this.parseFor(node, init);

	    case _.tokTypes._function:
	      this.next();
	      return this.parseFunction(node, true);

	    case _.tokTypes._if:
	      this.next();
	      node.test = this.parseParenExpression();
	      node.consequent = this.parseStatement();
	      node.alternate = this.eat(_.tokTypes._else) ? this.parseStatement() : null;
	      return this.finishNode(node, "IfStatement");

	    case _.tokTypes._return:
	      this.next();
	      if (this.eat(_.tokTypes.semi) || this.canInsertSemicolon()) node.argument = null;else {
	        node.argument = this.parseExpression();this.semicolon();
	      }
	      return this.finishNode(node, "ReturnStatement");

	    case _.tokTypes._switch:
	      var blockIndent = this.curIndent,
	          line = this.curLineStart;
	      this.next();
	      node.discriminant = this.parseParenExpression();
	      node.cases = [];
	      this.pushCx();
	      this.expect(_.tokTypes.braceL);

	      var cur = undefined;
	      while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) {
	        if (this.tok.type === _.tokTypes._case || this.tok.type === _.tokTypes._default) {
	          var isCase = this.tok.type === _.tokTypes._case;
	          if (cur) this.finishNode(cur, "SwitchCase");
	          node.cases.push(cur = this.startNode());
	          cur.consequent = [];
	          this.next();
	          if (isCase) cur.test = this.parseExpression();else cur.test = null;
	          this.expect(_.tokTypes.colon);
	        } else {
	          if (!cur) {
	            node.cases.push(cur = this.startNode());
	            cur.consequent = [];
	            cur.test = null;
	          }
	          cur.consequent.push(this.parseStatement());
	        }
	      }
	      if (cur) this.finishNode(cur, "SwitchCase");
	      this.popCx();
	      this.eat(_.tokTypes.braceR);
	      return this.finishNode(node, "SwitchStatement");

	    case _.tokTypes._throw:
	      this.next();
	      node.argument = this.parseExpression();
	      this.semicolon();
	      return this.finishNode(node, "ThrowStatement");

	    case _.tokTypes._try:
	      this.next();
	      node.block = this.parseBlock();
	      node.handler = null;
	      if (this.tok.type === _.tokTypes._catch) {
	        var clause = this.startNode();
	        this.next();
	        this.expect(_.tokTypes.parenL);
	        clause.param = this.toAssignable(this.parseExprAtom(), true);
	        this.expect(_.tokTypes.parenR);
	        clause.body = this.parseBlock();
	        node.handler = this.finishNode(clause, "CatchClause");
	      }
	      node.finalizer = this.eat(_.tokTypes._finally) ? this.parseBlock() : null;
	      if (!node.handler && !node.finalizer) return node.block;
	      return this.finishNode(node, "TryStatement");

	    case _.tokTypes._var:
	    case _.tokTypes._let:
	    case _.tokTypes._const:
	      return this.parseVar();

	    case _.tokTypes._while:
	      this.next();
	      node.test = this.parseParenExpression();
	      node.body = this.parseStatement();
	      return this.finishNode(node, "WhileStatement");

	    case _.tokTypes._with:
	      this.next();
	      node.object = this.parseParenExpression();
	      node.body = this.parseStatement();
	      return this.finishNode(node, "WithStatement");

	    case _.tokTypes.braceL:
	      return this.parseBlock();

	    case _.tokTypes.semi:
	      this.next();
	      return this.finishNode(node, "EmptyStatement");

	    case _.tokTypes._class:
	      return this.parseClass(true);

	    case _.tokTypes._import:
	      return this.parseImport();

	    case _.tokTypes._export:
	      return this.parseExport();

	    default:
	      var expr = this.parseExpression();
	      if (_parseutil.isDummy(expr)) {
	        this.next();
	        if (this.tok.type === _.tokTypes.eof) return this.finishNode(node, "EmptyStatement");
	        return this.parseStatement();
	      } else if (starttype === _.tokTypes.name && expr.type === "Identifier" && this.eat(_.tokTypes.colon)) {
	        node.body = this.parseStatement();
	        node.label = expr;
	        return this.finishNode(node, "LabeledStatement");
	      } else {
	        node.expression = expr;
	        this.semicolon();
	        return this.finishNode(node, "ExpressionStatement");
	      }
	  }
	};

	lp.parseBlock = function () {
	  var node = this.startNode();
	  this.pushCx();
	  this.expect(_.tokTypes.braceL);
	  var blockIndent = this.curIndent,
	      line = this.curLineStart;
	  node.body = [];
	  while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) node.body.push(this.parseStatement());
	  this.popCx();
	  this.eat(_.tokTypes.braceR);
	  return this.finishNode(node, "BlockStatement");
	};

	lp.parseFor = function (node, init) {
	  node.init = init;
	  node.test = node.update = null;
	  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.semi) node.test = this.parseExpression();
	  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.parenR) node.update = this.parseExpression();
	  this.popCx();
	  this.expect(_.tokTypes.parenR);
	  node.body = this.parseStatement();
	  return this.finishNode(node, "ForStatement");
	};

	lp.parseForIn = function (node, init) {
	  var type = this.tok.type === _.tokTypes._in ? "ForInStatement" : "ForOfStatement";
	  this.next();
	  node.left = init;
	  node.right = this.parseExpression();
	  this.popCx();
	  this.expect(_.tokTypes.parenR);
	  node.body = this.parseStatement();
	  return this.finishNode(node, type);
	};

	lp.parseVar = function (noIn) {
	  var node = this.startNode();
	  node.kind = this.tok.type.keyword;
	  this.next();
	  node.declarations = [];
	  do {
	    var decl = this.startNode();
	    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();
	    decl.init = this.eat(_.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	  } while (this.eat(_.tokTypes.comma));
	  if (!node.declarations.length) {
	    var decl = this.startNode();
	    decl.id = this.dummyIdent();
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	  }
	  if (!noIn) this.semicolon();
	  return this.finishNode(node, "VariableDeclaration");
	};

	lp.parseClass = function (isStatement) {
	  var node = this.startNode();
	  this.next();
	  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();else node.id = null;
	  node.superClass = this.eat(_.tokTypes._extends) ? this.parseExpression() : null;
	  node.body = this.startNode();
	  node.body.body = [];
	  this.pushCx();
	  var indent = this.curIndent + 1,
	      line = this.curLineStart;
	  this.eat(_.tokTypes.braceL);
	  if (this.curIndent + 1 < indent) {
	    indent = this.curIndent;line = this.curLineStart;
	  }
	  while (!this.closes(_.tokTypes.braceR, indent, line)) {
	    if (this.semicolon()) continue;
	    var method = this.startNode(),
	        isGenerator = undefined;
	    if (this.options.ecmaVersion >= 6) {
	      method["static"] = false;
	      isGenerator = this.eat(_.tokTypes.star);
	    }
	    this.parsePropertyName(method);
	    if (_parseutil.isDummy(method.key)) {
	      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
	    }
	    if (method.key.type === "Identifier" && !method.computed && method.key.name === "static" && (this.tok.type != _.tokTypes.parenL && this.tok.type != _.tokTypes.braceL)) {
	      method["static"] = true;
	      isGenerator = this.eat(_.tokTypes.star);
	      this.parsePropertyName(method);
	    } else {
	      method["static"] = false;
	    }
	    if (this.options.ecmaVersion >= 5 && method.key.type === "Identifier" && !method.computed && (method.key.name === "get" || method.key.name === "set") && this.tok.type !== _.tokTypes.parenL && this.tok.type !== _.tokTypes.braceL) {
	      method.kind = method.key.name;
	      this.parsePropertyName(method);
	      method.value = this.parseMethod(false);
	    } else {
	      if (!method.computed && !method["static"] && !isGenerator && (method.key.type === "Identifier" && method.key.name === "constructor" || method.key.type === "Literal" && method.key.value === "constructor")) {
	        method.kind = "constructor";
	      } else {
	        method.kind = "method";
	      }
	      method.value = this.parseMethod(isGenerator);
	    }
	    node.body.body.push(this.finishNode(method, "MethodDefinition"));
	  }
	  this.popCx();
	  if (!this.eat(_.tokTypes.braceR)) {
	    // If there is no closing brace, make the node span to the start
	    // of the next token (this is useful for Tern)
	    this.last.end = this.tok.start;
	    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
	  }
	  this.semicolon();
	  this.finishNode(node.body, "ClassBody");
	  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	};

	lp.parseFunction = function (node, isStatement) {
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = this.eat(_.tokTypes.star);
	  }
	  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();
	  node.params = this.parseFunctionParams();
	  node.body = this.parseBlock();
	  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	};

	lp.parseExport = function () {
	  var node = this.startNode();
	  this.next();
	  if (this.eat(_.tokTypes.star)) {
	    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
	    return this.finishNode(node, "ExportAllDeclaration");
	  }
	  if (this.eat(_.tokTypes._default)) {
	    var expr = this.parseMaybeAssign();
	    if (expr.id) {
	      switch (expr.type) {
	        case "FunctionExpression":
	          expr.type = "FunctionDeclaration";break;
	        case "ClassExpression":
	          expr.type = "ClassDeclaration";break;
	      }
	    }
	    node.declaration = expr;
	    this.semicolon();
	    return this.finishNode(node, "ExportDefaultDeclaration");
	  }
	  if (this.tok.type.keyword) {
	    node.declaration = this.parseStatement();
	    node.specifiers = [];
	    node.source = null;
	  } else {
	    node.declaration = null;
	    node.specifiers = this.parseExportSpecifierList();
	    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
	    this.semicolon();
	  }
	  return this.finishNode(node, "ExportNamedDeclaration");
	};

	lp.parseImport = function () {
	  var node = this.startNode();
	  this.next();
	  if (this.tok.type === _.tokTypes.string) {
	    node.specifiers = [];
	    node.source = this.parseExprAtom();
	    node.kind = '';
	  } else {
	    var elt = undefined;
	    if (this.tok.type === _.tokTypes.name && this.tok.value !== "from") {
	      elt = this.startNode();
	      elt.local = this.parseIdent();
	      this.finishNode(elt, "ImportDefaultSpecifier");
	      this.eat(_.tokTypes.comma);
	    }
	    node.specifiers = this.parseImportSpecifierList();
	    node.source = this.eatContextual("from") && this.tok.type == _.tokTypes.string ? this.parseExprAtom() : this.dummyString();
	    if (elt) node.specifiers.unshift(elt);
	  }
	  this.semicolon();
	  return this.finishNode(node, "ImportDeclaration");
	};

	lp.parseImportSpecifierList = function () {
	  var elts = [];
	  if (this.tok.type === _.tokTypes.star) {
	    var elt = this.startNode();
	    this.next();
	    if (this.eatContextual("as")) elt.local = this.parseIdent();
	    elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
	  } else {
	    var indent = this.curIndent,
	        line = this.curLineStart,
	        continuedLine = this.nextLineStart;
	    this.pushCx();
	    this.eat(_.tokTypes.braceL);
	    if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
	    while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
	      var elt = this.startNode();
	      if (this.eat(_.tokTypes.star)) {
	        if (this.eatContextual("as")) elt.local = this.parseIdent();
	        this.finishNode(elt, "ImportNamespaceSpecifier");
	      } else {
	        if (this.isContextual("from")) break;
	        elt.imported = this.parseIdent();
	        if (_parseutil.isDummy(elt.imported)) break;
	        elt.local = this.eatContextual("as") ? this.parseIdent() : elt.imported;
	        this.finishNode(elt, "ImportSpecifier");
	      }
	      elts.push(elt);
	      this.eat(_.tokTypes.comma);
	    }
	    this.eat(_.tokTypes.braceR);
	    this.popCx();
	  }
	  return elts;
	};

	lp.parseExportSpecifierList = function () {
	  var elts = [];
	  var indent = this.curIndent,
	      line = this.curLineStart,
	      continuedLine = this.nextLineStart;
	  this.pushCx();
	  this.eat(_.tokTypes.braceL);
	  if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
	  while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
	    if (this.isContextual("from")) break;
	    var elt = this.startNode();
	    elt.local = this.parseIdent();
	    if (_parseutil.isDummy(elt.local)) break;
	    elt.exported = this.eatContextual("as") ? this.parseIdent() : elt.local;
	    this.finishNode(elt, "ExportSpecifier");
	    elts.push(elt);
	    this.eat(_.tokTypes.comma);
	  }
	  this.eat(_.tokTypes.braceR);
	  this.popCx();
	  return elts;
	};

	},{"..":1,"./parseutil":4,"./state":5}],7:[function(_dereq_,module,exports){
	"use strict";

	var _ = _dereq_("..");

	var _state = _dereq_("./state");

	var lp = _state.LooseParser.prototype;

	function isSpace(ch) {
	  return ch < 14 && ch > 8 || ch === 32 || ch === 160 || _.isNewLine(ch);
	}

	lp.next = function () {
	  this.last = this.tok;
	  if (this.ahead.length) this.tok = this.ahead.shift();else this.tok = this.readToken();

	  if (this.tok.start >= this.nextLineStart) {
	    while (this.tok.start >= this.nextLineStart) {
	      this.curLineStart = this.nextLineStart;
	      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
	    }
	    this.curIndent = this.indentationAfter(this.curLineStart);
	  }
	};

	lp.readToken = function () {
	  for (;;) {
	    try {
	      this.toks.next();
	      if (this.toks.type === _.tokTypes.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6) {
	        this.toks.end++;
	        this.toks.type = _.tokTypes.ellipsis;
	      }
	      return new _.Token(this.toks);
	    } catch (e) {
	      if (!(e instanceof SyntaxError)) throw e;

	      // Try to skip some text, based on the error message, and then continue
	      var msg = e.message,
	          pos = e.raisedAt,
	          replace = true;
	      if (/unterminated/i.test(msg)) {
	        pos = this.lineEnd(e.pos + 1);
	        if (/string/.test(msg)) {
	          replace = { start: e.pos, end: pos, type: _.tokTypes.string, value: this.input.slice(e.pos + 1, pos) };
	        } else if (/regular expr/i.test(msg)) {
	          var re = this.input.slice(e.pos, pos);
	          try {
	            re = new RegExp(re);
	          } catch (e) {}
	          replace = { start: e.pos, end: pos, type: _.tokTypes.regexp, value: re };
	        } else if (/template/.test(msg)) {
	          replace = { start: e.pos, end: pos,
	            type: _.tokTypes.template,
	            value: this.input.slice(e.pos, pos) };
	        } else {
	          replace = false;
	        }
	      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {
	        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos;
	      } else if (/character escape|expected hexadecimal/i.test(msg)) {
	        while (pos < this.input.length) {
	          var ch = this.input.charCodeAt(pos++);
	          if (ch === 34 || ch === 39 || _.isNewLine(ch)) break;
	        }
	      } else if (/unexpected character/i.test(msg)) {
	        pos++;
	        replace = false;
	      } else if (/regular expression/i.test(msg)) {
	        replace = true;
	      } else {
	        throw e;
	      }
	      this.resetTo(pos);
	      if (replace === true) replace = { start: pos, end: pos, type: _.tokTypes.name, value: "✖" };
	      if (replace) {
	        if (this.options.locations) replace.loc = new _.SourceLocation(this.toks, _.getLineInfo(this.input, replace.start), _.getLineInfo(this.input, replace.end));
	        return replace;
	      }
	    }
	  }
	};

	lp.resetTo = function (pos) {
	  this.toks.pos = pos;
	  var ch = this.input.charAt(pos - 1);
	  this.toks.exprAllowed = !ch || /[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos));

	  if (this.options.locations) {
	    this.toks.curLine = 1;
	    this.toks.lineStart = _.lineBreakG.lastIndex = 0;
	    var match = undefined;
	    while ((match = _.lineBreakG.exec(this.input)) && match.index < pos) {
	      ++this.toks.curLine;
	      this.toks.lineStart = match.index + match[0].length;
	    }
	  }
	};

	lp.lookAhead = function (n) {
	  while (n > this.ahead.length) this.ahead.push(this.readToken());
	  return this.ahead[n - 1];
	};

	},{"..":1,"./state":5}]},{},[3])(3)
	});

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).walk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	// AST walker module for Mozilla Parser API compatible trees

	// A simple walk is one where you simply specify callbacks to be
	// called on specific nodes. The last two arguments are optional. A
	// simple use would be
	//
	//     walk.simple(myTree, {
	//         Expression: function(node) { ... }
	//     });
	//
	// to do something with all expressions. All Parser API node types
	// can be used to identify node types, as well as Expression,
	// Statement, and ScopeBody, which denote categories of nodes.
	//
	// The base argument can be used to pass a custom (recursive)
	// walker, and state can be used to give this walked an initial
	// state.

	"use strict";

	exports.__esModule = true;
	exports.simple = simple;
	exports.ancestor = ancestor;
	exports.recursive = recursive;
	exports.findNodeAt = findNodeAt;
	exports.findNodeAround = findNodeAround;
	exports.findNodeAfter = findNodeAfter;
	exports.findNodeBefore = findNodeBefore;
	exports.make = make;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function simple(node, visitors, base, state, override) {
	  if (!base) base = exports.base;(function c(node, st, override) {
	    var type = override || node.type,
	        found = visitors[type];
	    base[type](node, st, c);
	    if (found) found(node, st);
	  })(node, state, override);
	}

	// An ancestor walk builds up an array of ancestor nodes (including
	// the current node) and passes them to the callback as the state parameter.

	function ancestor(node, visitors, base, state) {
	  if (!base) base = exports.base;
	  if (!state) state = [];(function c(node, st, override) {
	    var type = override || node.type,
	        found = visitors[type];
	    if (node != st[st.length - 1]) {
	      st = st.slice();
	      st.push(node);
	    }
	    base[type](node, st, c);
	    if (found) found(node, st);
	  })(node, state);
	}

	// A recursive walk is one where your functions override the default
	// walkers. They can modify and replace the state parameter that's
	// threaded through the walk, and can opt how and whether to walk
	// their child nodes (by calling their third argument on these
	// nodes).

	function recursive(node, state, funcs, base, override) {
	  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) {
	    visitor[override || node.type](node, st, c);
	  })(node, state, override);
	}

	function makeTest(test) {
	  if (typeof test == "string") return function (type) {
	    return type == test;
	  };else if (!test) return function () {
	    return true;
	  };else return test;
	}

	var Found = function Found(node, state) {
	  _classCallCheck(this, Found);

	  this.node = node;this.state = state;
	}

	// Find a node with a given start, end, and type (all are optional,
	// null can be used as wildcard). Returns a {node, state} object, or
	// undefined when it doesn't find a matching node.
	;

	function findNodeAt(node, start, end, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      var type = override || node.type;
	      if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
	      if ((start == null || node.start == start) && (end == null || node.end == end) && test(type, node)) throw new Found(node, st);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) return e;
	    throw e;
	  }
	}

	// Find the innermost node of a given type that contains the given
	// position. Interface similar to findNodeAt.

	function findNodeAround(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      var type = override || node.type;
	      if (node.start > pos || node.end < pos) return;
	      base[type](node, st, c);
	      if (test(type, node)) throw new Found(node, st);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) return e;
	    throw e;
	  }
	}

	// Find the outermost matching node after a given position.

	function findNodeAfter(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      if (node.end < pos) return;
	      var type = override || node.type;
	      if (node.start >= pos && test(type, node)) throw new Found(node, st);
	      base[type](node, st, c);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) return e;
	    throw e;
	  }
	}

	// Find the outermost matching node before a given position.

	function findNodeBefore(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  var max = undefined;(function c(node, st, override) {
	    if (node.start > pos) return;
	    var type = override || node.type;
	    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
	    base[type](node, st, c);
	  })(node, state);
	  return max;
	}

	// Used to create a custom walker. Will fill in all missing node
	// type properties with the defaults.

	function make(funcs, base) {
	  if (!base) base = exports.base;
	  var visitor = {};
	  for (var type in base) visitor[type] = base[type];
	  for (var type in funcs) visitor[type] = funcs[type];
	  return visitor;
	}

	function skipThrough(node, st, c) {
	  c(node, st);
	}
	function ignore(_node, _st, _c) {}

	// Node walkers.

	var base = {};

	exports.base = base;
	base.Program = base.BlockStatement = function (node, st, c) {
	  for (var i = 0; i < node.body.length; ++i) {
	    c(node.body[i], st, "Statement");
	  }
	};
	base.Statement = skipThrough;
	base.EmptyStatement = ignore;
	base.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {
	  return c(node.expression, st, "Expression");
	};
	base.IfStatement = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.consequent, st, "Statement");
	  if (node.alternate) c(node.alternate, st, "Statement");
	};
	base.LabeledStatement = function (node, st, c) {
	  return c(node.body, st, "Statement");
	};
	base.BreakStatement = base.ContinueStatement = ignore;
	base.WithStatement = function (node, st, c) {
	  c(node.object, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.SwitchStatement = function (node, st, c) {
	  c(node.discriminant, st, "Expression");
	  for (var i = 0; i < node.cases.length; ++i) {
	    var cs = node.cases[i];
	    if (cs.test) c(cs.test, st, "Expression");
	    for (var j = 0; j < cs.consequent.length; ++j) {
	      c(cs.consequent[j], st, "Statement");
	    }
	  }
	};
	base.ReturnStatement = base.YieldExpression = function (node, st, c) {
	  if (node.argument) c(node.argument, st, "Expression");
	};
	base.ThrowStatement = base.SpreadElement = function (node, st, c) {
	  return c(node.argument, st, "Expression");
	};
	base.TryStatement = function (node, st, c) {
	  c(node.block, st, "Statement");
	  if (node.handler) {
	    c(node.handler.param, st, "Pattern");
	    c(node.handler.body, st, "ScopeBody");
	  }
	  if (node.finalizer) c(node.finalizer, st, "Statement");
	};
	base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForStatement = function (node, st, c) {
	  if (node.init) c(node.init, st, "ForInit");
	  if (node.test) c(node.test, st, "Expression");
	  if (node.update) c(node.update, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForInStatement = base.ForOfStatement = function (node, st, c) {
	  c(node.left, st, "ForInit");
	  c(node.right, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForInit = function (node, st, c) {
	  if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
	};
	base.DebuggerStatement = ignore;

	base.FunctionDeclaration = function (node, st, c) {
	  return c(node, st, "Function");
	};
	base.VariableDeclaration = function (node, st, c) {
	  for (var i = 0; i < node.declarations.length; ++i) {
	    c(node.declarations[i], st);
	  }
	};
	base.VariableDeclarator = function (node, st, c) {
	  c(node.id, st, "Pattern");
	  if (node.init) c(node.init, st, "Expression");
	};

	base.Function = function (node, st, c) {
	  if (node.id) c(node.id, st, "Pattern");
	  for (var i = 0; i < node.params.length; i++) {
	    c(node.params[i], st, "Pattern");
	  }c(node.body, st, node.expression ? "ScopeExpression" : "ScopeBody");
	};
	// FIXME drop these node types in next major version
	// (They are awkward, and in ES6 every block can be a scope.)
	base.ScopeBody = function (node, st, c) {
	  return c(node, st, "Statement");
	};
	base.ScopeExpression = function (node, st, c) {
	  return c(node, st, "Expression");
	};

	base.Pattern = function (node, st, c) {
	  if (node.type == "Identifier") c(node, st, "VariablePattern");else if (node.type == "MemberExpression") c(node, st, "MemberPattern");else c(node, st);
	};
	base.VariablePattern = ignore;
	base.MemberPattern = skipThrough;
	base.RestElement = function (node, st, c) {
	  return c(node.argument, st, "Pattern");
	};
	base.ArrayPattern = function (node, st, c) {
	  for (var i = 0; i < node.elements.length; ++i) {
	    var elt = node.elements[i];
	    if (elt) c(elt, st, "Pattern");
	  }
	};
	base.ObjectPattern = function (node, st, c) {
	  for (var i = 0; i < node.properties.length; ++i) {
	    c(node.properties[i].value, st, "Pattern");
	  }
	};

	base.Expression = skipThrough;
	base.ThisExpression = base.Super = base.MetaProperty = ignore;
	base.ArrayExpression = function (node, st, c) {
	  for (var i = 0; i < node.elements.length; ++i) {
	    var elt = node.elements[i];
	    if (elt) c(elt, st, "Expression");
	  }
	};
	base.ObjectExpression = function (node, st, c) {
	  for (var i = 0; i < node.properties.length; ++i) {
	    c(node.properties[i], st);
	  }
	};
	base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
	base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
	  for (var i = 0; i < node.expressions.length; ++i) {
	    c(node.expressions[i], st, "Expression");
	  }
	};
	base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
	  c(node.argument, st, "Expression");
	};
	base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
	  c(node.left, st, "Expression");
	  c(node.right, st, "Expression");
	};
	base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
	  c(node.left, st, "Pattern");
	  c(node.right, st, "Expression");
	};
	base.ConditionalExpression = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.consequent, st, "Expression");
	  c(node.alternate, st, "Expression");
	};
	base.NewExpression = base.CallExpression = function (node, st, c) {
	  c(node.callee, st, "Expression");
	  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
	    c(node.arguments[i], st, "Expression");
	  }
	};
	base.MemberExpression = function (node, st, c) {
	  c(node.object, st, "Expression");
	  if (node.computed) c(node.property, st, "Expression");
	};
	base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
	  if (node.declaration) c(node.declaration, st, node.type == "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
	  if (node.source) c(node.source, st, "Expression");
	};
	base.ExportAllDeclaration = function (node, st, c) {
	  c(node.source, st, "Expression");
	};
	base.ImportDeclaration = function (node, st, c) {
	  for (var i = 0; i < node.specifiers.length; i++) {
	    c(node.specifiers[i], st);
	  }c(node.source, st, "Expression");
	};
	base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

	base.TaggedTemplateExpression = function (node, st, c) {
	  c(node.tag, st, "Expression");
	  c(node.quasi, st);
	};
	base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
	  return c(node, st, "Class");
	};
	base.Class = function (node, st, c) {
	  if (node.id) c(node.id, st, "Pattern");
	  if (node.superClass) c(node.superClass, st, "Expression");
	  for (var i = 0; i < node.body.body.length; i++) {
	    c(node.body.body[i], st);
	  }
	};
	base.MethodDefinition = base.Property = function (node, st, c) {
	  if (node.computed) c(node.key, st, "Expression");
	  c(node.value, st, "Expression");
	};
	base.ComprehensionExpression = function (node, st, c) {
	  for (var i = 0; i < node.blocks.length; i++) {
	    c(node.blocks[i].right, st, "Expression");
	  }c(node.body, st, "Expression");
	};

	},{}]},{},[1])(1)
	});

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	// Type description parser
	//
	// Type description JSON files (such as ecma5.json and browser.json)
	// are used to
	//
	// A) describe types that come from native code
	//
	// B) to cheaply load the types for big libraries, or libraries that
	//    can't be inferred well

	(function(mod) {
	  if (true) // CommonJS
	    return exports.init = mod;
	  if (true) // AMD
	    return !(module.exports = {init: mod});
	  tern.def = {init: mod};
	})(function(exports, infer) {
	  "use strict";

	  function hop(obj, prop) {
	    return Object.prototype.hasOwnProperty.call(obj, prop);
	  }

	  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {
	    this.pos = start || 0;
	    this.spec = spec;
	    this.base = base;
	    this.forceNew = forceNew;
	  };

	  function unwrapType(type, self, args) {
	    return type.call ? type(self, args) : type;
	  }

	  function extractProp(type, prop) {
	    if (prop == "!ret") {
	      if (type.retval) return type.retval;
	      var rv = new infer.AVal;
	      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));
	      return rv;
	    } else {
	      return type.getProp(prop);
	    }
	  }

	  function computedFunc(name, args, retType, generator) {
	    return function(self, cArgs) {
	      var realArgs = [];
	      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));
	      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);
	    };
	  }
	  function computedUnion(types) {
	    return function(self, args) {
	      var union = new infer.AVal;
	      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);
	      union.maxWeight = 1e5;
	      return union;
	    };
	  }
	  function computedArray(inner) {
	    return function(self, args) {
	      return new infer.Arr(inner(self, args));
	    };
	  }
	  function computedTuple(types) {
	    return function(self, args) {
	      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }))
	    }
	  }

	  TypeParser.prototype = {
	    eat: function(str) {
	      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {
	        this.pos += str.length;
	        return true;
	      }
	    },
	    word: function(re) {
	      var word = "", ch, re = re || /[\w$]/;
	      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }
	      return word;
	    },
	    error: function() {
	      throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
	    },
	    parseFnType: function(comp, name, top, generator) {
	      var args = [], names = [], computed = false;
	      if (!this.eat(")")) for (var i = 0; ; ++i) {
	        var colon = this.spec.indexOf(": ", this.pos), argname;
	        if (colon != -1) {
	          argname = this.spec.slice(this.pos, colon);
	          if (/^[$\w?]+$/.test(argname))
	            this.pos = colon + 2;
	          else
	            argname = null;
	        }
	        names.push(argname);
	        var argType = this.parseType(comp);
	        if (argType.call) computed = true;
	        args.push(argType);
	        if (!this.eat(", ")) {
	          this.eat(")") || this.error();
	          break;
	        }
	      }
	      var retType, computeRet, computeRetStart, fn;
	      if (this.eat(" -> ")) {
	        var retStart = this.pos;
	        retType = this.parseType(true);
	        if (retType.call && !computed) {
	          computeRet = retType;
	          retType = infer.ANull;
	          computeRetStart = retStart;
	        }
	      } else {
	        retType = infer.ANull;
	      }
	      if (computed) return computedFunc(name, args, retType, generator);

	      if (top && (fn = this.base))
	        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);
	      else
	        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);
	      if (computeRet) fn.computeRet = computeRet;
	      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
	      return fn;
	    },
	    parseType: function(comp, name, top) {
	      var main = this.parseTypeMaybeProp(comp, name, top);
	      if (!this.eat("|")) return main;
	      var types = [main], computed = main.call;
	      for (;;) {
	        var next = this.parseTypeMaybeProp(comp, name, top);
	        types.push(next);
	        if (next.call) computed = true;
	        if (!this.eat("|")) break;
	      }
	      if (computed) return computedUnion(types);
	      var union = new infer.AVal;
	      for (var i = 0; i < types.length; i++) types[i].propagate(union);
	      union.maxWeight = 1e5;
	      return union;
	    },
	    parseTypeMaybeProp: function(comp, name, top) {
	      var result = this.parseTypeInner(comp, name, top);
	      while (comp && this.eat(".")) result = this.extendWithProp(result);
	      return result;
	    },
	    extendWithProp: function(base) {
	      var propName = this.word(/[\w<>$!:]/) || this.error();
	      if (base.apply) return function(self, args) {
	        return extractProp(base(self, args), propName);
	      };
	      return extractProp(base, propName);
	    },
	    parseTypeInner: function(comp, name, top) {
	      var gen
	      if (this.eat("fn(") || (gen = this.eat("fn*("))) {
	        return this.parseFnType(comp, name, top, gen);
	      } else if (this.eat("[")) {
	        var inner = this.parseType(comp), types, computed = inner.call
	        while (this.eat(", ")) {
	          if (!types) types = [inner]
	          var next = this.parseType(comp)
	          types.push(next)
	          computed = computed || next.call
	        }
	        this.eat("]") || this.error()
	        if (computed) return types ? computedTuple(types) : computedArray(inner)
	        if (top && this.base) {
	          infer.Arr.call(this.base, types || inner)
	          return this.base
	        }
	        return new infer.Arr(types || inner)
	      } else if (this.eat("+")) {
	        var path = this.word(/[\w$<>\.:!]/)
	        var base = infer.cx().localDefs[path + ".prototype"]
	        if (!base) {
	          var base = parsePath(path);
	          if (!(base instanceof infer.Obj)) return base;
	          var proto = descendProps(base, ["prototype"])
	          if (proto && (proto = proto.getObjType()))
	            base = proto
	        }
	        if (comp && this.eat("[")) return this.parsePoly(base);
	        if (top && this.forceNew) return new infer.Obj(base);
	        return infer.getInstance(base);
	      } else if (this.eat(":")) {
	        var name = this.word(/[\w$\.]/)
	        return infer.getSymbol(name)
	      } else if (comp && this.eat("!")) {
	        var arg = this.word(/\d/);
	        if (arg) {
	          arg = Number(arg);
	          return function(_self, args) {return args[arg] || infer.ANull;};
	        } else if (this.eat("this")) {
	          return function(self) {return self;};
	        } else if (this.eat("custom:")) {
	          var fname = this.word(/[\w$]/);
	          return customFunctions[fname] || function() { return infer.ANull; };
	        } else {
	          return this.fromWord("!" + this.word(/[\w$<>\.!:]/));
	        }
	      } else if (this.eat("?")) {
	        return infer.ANull;
	      } else {
	        return this.fromWord(this.word(/[\w$<>\.!:`]/));
	      }
	    },
	    fromWord: function(spec) {
	      var cx = infer.cx();
	      switch (spec) {
	      case "number": return cx.num;
	      case "string": return cx.str;
	      case "bool": return cx.bool;
	      case "<top>": return cx.topScope;
	      }
	      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];
	      return parsePath(spec);
	    },
	    parsePoly: function(base) {
	      var propName = "<i>", match;
	      if (match = this.spec.slice(this.pos).match(/^\s*([\w$:]+)\s*=\s*/)) {
	        propName = match[1];
	        this.pos += match[0].length;
	      }
	      var value = this.parseType(true);
	      if (!this.eat("]")) this.error();
	      if (value.call) return function(self, args) {
	        var instance = new infer.Obj(base);
	        value(self, args).propagate(instance.defProp(propName));
	        return instance;
	      };
	      var instance = new infer.Obj(base);
	      value.propagate(instance.defProp(propName));
	      return instance;
	    }
	  };

	  function parseType(spec, name, base, forceNew) {
	    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);
	    if (/^fn\(/.test(spec)) for (var i = 0; i < type.args.length; ++i) (function(i) {
	      var arg = type.args[i];
	      if (arg instanceof infer.Fn && arg.args && arg.args.length) addEffect(type, function(_self, fArgs) {
	        var fArg = fArgs[i];
	        if (fArg) fArg.propagate(new infer.IsCallee(infer.cx().topScope, arg.args, null, infer.ANull));
	      });
	    })(i);
	    return type;
	  }

	  function addEffect(fn, handler, replaceRet) {
	    var oldCmp = fn.computeRet, rv = fn.retval;
	    fn.computeRet = function(self, args, argNodes) {
	      var handled = handler(self, args, argNodes);
	      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;
	      return replaceRet ? handled : old;
	    };
	  }

	  var parseEffect = exports.parseEffect = function(effect, fn) {
	    var m;
	    if (effect.indexOf("propagate ") == 0) {
	      var p = new TypeParser(effect, 10);
	      var origin = p.parseType(true);
	      if (!p.eat(" ")) p.error();
	      var target = p.parseType(true);
	      addEffect(fn, function(self, args) {
	        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));
	      });
	    } else if (effect.indexOf("call ") == 0) {
	      var andRet = effect.indexOf("and return ", 5) == 5;
	      var p = new TypeParser(effect, andRet ? 16 : 5);
	      var getCallee = p.parseType(true), getSelf = null, getArgs = [];
	      if (p.eat(" this=")) getSelf = p.parseType(true);
	      while (p.eat(" ")) getArgs.push(p.parseType(true));
	      addEffect(fn, function(self, args) {
	        var callee = unwrapType(getCallee, self, args);
	        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];
	        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));
	        var result = andRet ? new infer.AVal : infer.ANull;
	        callee.propagate(new infer.IsCallee(slf, as, null, result));
	        return result;
	      }, andRet);
	    } else if (m = effect.match(/^custom (\S+)\s*(.*)/)) {
	      var customFunc = customFunctions[m[1]];
	      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);
	    } else if (effect.indexOf("copy ") == 0) {
	      var p = new TypeParser(effect, 5);
	      var getFrom = p.parseType(true);
	      p.eat(" ");
	      var getTo = p.parseType(true);
	      addEffect(fn, function(self, args) {
	        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);
	        from.forAllProps(function(prop, val, local) {
	          if (local && prop != "<i>")
	            to.propagate(new infer.DefProp(prop, val));
	        });
	      });
	    } else {
	      throw new Error("Unknown effect type: " + effect);
	    }
	  };

	  var currentTopScope;

	  var parsePath = exports.parsePath = function(path, scope) {
	    var cx = infer.cx(), cached = cx.paths[path], origPath = path;
	    if (cached != null) return cached;
	    cx.paths[path] = infer.ANull;

	    var base = scope || currentTopScope || cx.topScope;

	    if (cx.localDefs) for (var name in cx.localDefs) {
	      if (path.indexOf(name) == 0) {
	        if (path == name) return cx.paths[path] = cx.localDefs[path];
	        if (path.charAt(name.length) == ".") {
	          base = cx.localDefs[name];
	          path = path.slice(name.length + 1);
	          break;
	        }
	      }
	    }

	    var result = descendProps(base, path.split("."))
	    // Uncomment this to get feedback on your poorly written .json files
	    // if (result == infer.ANull) console.error("bad path: " + origPath + " (" + cx.curOrigin + ")")
	    cx.paths[origPath] = result == infer.ANull ? null : result
	    return result
	  }

	  function descendProps(base, parts) {
	    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {
	      var prop = parts[i];
	      if (prop.charAt(0) == "!") {
	        if (prop == "!proto") {
	          base = (base instanceof infer.Obj && base.proto) || infer.ANull;
	        } else {
	          var fn = base.getFunctionType();
	          if (!fn) {
	            base = infer.ANull;
	          } else if (prop == "!ret") {
	            base = fn.retval && fn.retval.getType(false) || infer.ANull;
	          } else {
	            var arg = fn.args && fn.args[Number(prop.slice(1))];
	            base = (arg && arg.getType(false)) || infer.ANull;
	          }
	        }
	      } else if (base instanceof infer.Obj) {
	        var propVal = (prop == "prototype" && base instanceof infer.Fn) ? base.getProp(prop) : base.props[prop];
	        if (!propVal || propVal.isEmpty())
	          base = infer.ANull;
	        else
	          base = propVal.types[0];
	      }
	    }
	    return base;
	  }

	  function emptyObj(ctor) {
	    var empty = Object.create(ctor.prototype);
	    empty.props = Object.create(null);
	    empty.isShell = true;
	    return empty;
	  }

	  function isSimpleAnnotation(spec) {
	    if (!spec["!type"] || /^(fn\(|\[)/.test(spec["!type"])) return false;
	    for (var prop in spec)
	      if (prop != "!type" && prop != "!doc" && prop != "!url" && prop != "!span" && prop != "!data")
	        return false;
	    return true;
	  }

	  function passOne(base, spec, path) {
	    if (!base) {
	      var tp = spec["!type"];
	      if (tp) {
	        if (/^fn\(/.test(tp)) base = emptyObj(infer.Fn);
	        else if (tp.charAt(0) == "[") base = emptyObj(infer.Arr);
	        else throw new Error("Invalid !type spec: " + tp);
	      } else if (spec["!stdProto"]) {
	        base = infer.cx().protos[spec["!stdProto"]];
	      } else {
	        base = emptyObj(infer.Obj);
	      }
	      base.name = path;
	    }

	    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
	      var inner = spec[name];
	      if (typeof inner == "string" || isSimpleAnnotation(inner)) continue;
	      var prop = base.defProp(name);
	      passOne(prop.getObjType(), inner, path ? path + "." + name : name).propagate(prop);
	    }
	    return base;
	  }

	  function passTwo(base, spec, path) {
	    if (base.isShell) {
	      delete base.isShell;
	      var tp = spec["!type"];
	      if (tp) {
	        parseType(tp, path, base);
	      } else {
	        var proto = spec["!proto"] && parseType(spec["!proto"]);
	        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);
	      }
	    }

	    var effects = spec["!effects"];
	    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)
	      parseEffect(effects[i], base);
	    copyInfo(spec, base);

	    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
	      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + "." + name : name;
	      if (typeof inner == "string") {
	        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);
	      } else {
	        if (!isSimpleAnnotation(inner))
	          passTwo(known.getObjType(), inner, innerPath);
	        else if (known.isEmpty())
	          parseType(inner["!type"], innerPath, null, true).propagate(known);
	        else
	          continue;
	        if (inner["!doc"]) known.doc = inner["!doc"];
	        if (inner["!url"]) known.url = inner["!url"];
	        if (inner["!span"]) known.span = inner["!span"];
	      }
	    }
	    return base;
	  }

	  function copyInfo(spec, type) {
	    if (spec["!doc"]) type.doc = spec["!doc"];
	    if (spec["!url"]) type.url = spec["!url"];
	    if (spec["!span"]) type.span = spec["!span"];
	    if (spec["!data"]) type.metaData = spec["!data"];
	  }

	  function doLoadEnvironment(data, scope) {
	    var cx = infer.cx(), server = cx.parent

	    infer.addOrigin(cx.curOrigin = data["!name"] || "env#" + cx.origins.length);
	    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);

	    if (server) server.signal("preLoadDef", data)

	    passOne(scope, data);

	    var def = data["!define"];
	    if (def) {
	      for (var name in def) {
	        var spec = def[name];
	        cx.localDefs[name] = typeof spec == "string" ? parsePath(spec) : passOne(null, spec, name);
	      }
	      for (var name in def) {
	        var spec = def[name];
	        if (typeof spec != "string") passTwo(cx.localDefs[name], def[name], name);
	      }
	    }

	    passTwo(scope, data);

	    if (server) server.signal("postLoadDef", data)

	    cx.curOrigin = cx.localDefs = null;
	  }

	  exports.load = function(data, scope) {
	    if (!scope) scope = infer.cx().topScope;
	    var oldScope = currentTopScope;
	    currentTopScope = scope;
	    try {
	      doLoadEnvironment(data, scope);
	    } finally {
	      currentTopScope = oldScope;
	    }
	  };

	  exports.parse = function(data, origin, path) {
	    var cx = infer.cx();
	    if (origin) {
	      cx.origin = origin;
	      cx.localDefs = cx.definitions[origin];
	    }

	    try {
	      if (typeof data == "string")
	        return parseType(data, path);
	      else
	        return passTwo(passOne(null, data, path), data, path);
	    } finally {
	      if (origin) cx.origin = cx.localDefs = null;
	    }
	  };

	  // Used to register custom logic for more involved effect or type
	  // computation.
	  var customFunctions = Object.create(null);
	  infer.registerFunction = function(name, f) { customFunctions[name] = f; };

	  var IsCreated = infer.constraint({
	    construct: function(created, target, spec) {
	      this.created = created;
	      this.target = target;
	      this.spec = spec;
	    },
	    addType: function(tp) {
	      if (tp instanceof infer.Obj && this.created++ < 5) {
	        var derived = new infer.Obj(tp), spec = this.spec;
	        if (spec instanceof infer.AVal) spec = spec.getObjType(false);
	        if (spec instanceof infer.Obj) for (var prop in spec.props) {
	          var cur = spec.props[prop].types[0];
	          var p = derived.defProp(prop);
	          if (cur && cur instanceof infer.Obj && cur.props.value) {
	            var vtp = cur.props.value.getType(false);
	            if (vtp) p.addType(vtp);
	          }
	        }
	        this.target.addType(derived);
	      }
	    }
	  });

	  infer.registerFunction("Object_create", function(_self, args, argNodes) {
	    if (argNodes && argNodes.length && argNodes[0].type == "Literal" && argNodes[0].value == null)
	      return new infer.Obj();

	    var result = new infer.AVal;
	    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));
	    return result;
	  });

	  var PropSpec = infer.constraint({
	    construct: function(target) { this.target = target; },
	    addType: function(tp) {
	      if (!(tp instanceof infer.Obj)) return;
	      if (tp.hasProp("value"))
	        tp.getProp("value").propagate(this.target);
	      else if (tp.hasProp("get"))
	        tp.getProp("get").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));
	    }
	  });

	  infer.registerFunction("Object_defineProperty", function(_self, args, argNodes) {
	    if (argNodes && argNodes.length >= 3 && argNodes[1].type == "Literal" &&
	        typeof argNodes[1].value == "string") {
	      var obj = args[0], connect = new infer.AVal;
	      obj.propagate(new infer.DefProp(argNodes[1].value, connect, argNodes[1]));
	      args[2].propagate(new PropSpec(connect));
	    }
	    return infer.ANull;
	  });

	  infer.registerFunction("Object_defineProperties", function(_self, args, argNodes) {
	    if (args.length >= 2) {
	      var obj = args[0];
	      args[1].forAllProps(function(prop, val, local) {
	        if (!local) return;
	        var connect = new infer.AVal;
	        obj.propagate(new infer.DefProp(prop, connect, argNodes && argNodes[1]));
	        val.propagate(new PropSpec(connect));
	      });
	    }
	    return infer.ANull;
	  });

	  var IsBound = infer.constraint({
	    construct: function(self, args, target) {
	      this.self = self; this.args = args; this.target = target;
	    },
	    addType: function(tp) {
	      if (!(tp instanceof infer.Fn)) return;
	      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),
	                                       tp.argNames.slice(this.args.length), tp.retval, tp.generator));
	      this.self.propagate(tp.self);
	      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)
	        this.args[i].propagate(tp.args[i]);
	    }
	  });

	  infer.registerFunction("Function_bind", function(self, args) {
	    if (!args.length) return infer.ANull;
	    var result = new infer.AVal;
	    self.propagate(new IsBound(args[0], args.slice(1), result));
	    return result;
	  });

	  infer.registerFunction("Array_ctor", function(_self, args) {
	    var arr = new infer.Arr;
	    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {
	      var content = arr.getProp("<i>");
	      for (var i = 0; i < args.length; ++i) args[i].propagate(content);
	    }
	    return arr;
	  });

	  infer.registerFunction("Promise_ctor", function(_self, args, argNodes) {
	    var defs6 = infer.cx().definitions.ecma6
	    if (!defs6 || args.length < 1) return infer.ANull;
	    var self = new infer.Obj(defs6["Promise.prototype"]);
	    var valProp = self.defProp(":t", argNodes && argNodes[0]);
	    var valArg = new infer.AVal;
	    valArg.propagate(valProp);
	    var exec = new infer.Fn("execute", infer.ANull, [valArg], ["value"], infer.ANull);
	    var reject = defs6.Promise_reject;
	    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));
	    return self;
	  });

	  var PromiseResolvesTo = infer.constraint({
	    construct: function(output) { this.output = output; },
	    addType: function(tp) {
	      if (tp.constructor == infer.Obj && tp.name == "Promise" && tp.hasProp(":t"))
	        tp.getProp(":t").propagate(this.output);
	      else
	        tp.propagate(this.output);
	    }
	  });

	  var WG_PROMISE_KEEP_VALUE = 50;

	  infer.registerFunction("Promise_then", function(self, args, argNodes) {
	    var fn = args.length && args[0].getFunctionType();
	    var defs6 = infer.cx().definitions.ecma6
	    if (!fn || !defs6) return self;

	    var result = new infer.Obj(defs6["Promise.prototype"]);
	    var value = result.defProp(":t", argNodes && argNodes[0]), ty;
	    if (fn.retval.isEmpty() && (ty = self.getType()) instanceof infer.Obj && ty.hasProp(":t"))
	      ty.getProp(":t").propagate(value, WG_PROMISE_KEEP_VALUE);
	    fn.retval.propagate(new PromiseResolvesTo(value));
	    return result;
	  });

	  infer.registerFunction("getOwnPropertySymbols", function(_self, args) {
	    if (!args.length) return infer.ANull
	    var result = new infer.AVal
	    args[0].forAllProps(function(prop, _val, local) {
	      if (local && prop.charAt(0) == ":") result.addType(infer.getSymbol(prop.slice(1)))
	    })
	    return result
	  })

	  infer.registerFunction("getSymbol", function(_self, _args, argNodes) {
	    if (argNodes.length && argNodes[0].type == "Literal" && typeof argNodes[0].value == "string")
	      return infer.getSymbol(argNodes[0].value)
	    else
	      return infer.ANull
	  })

	  return exports;
	});


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, mod) {
	  if (true) // CommonJS
	    return mod(exports);
	  if (true) // AMD
	    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env
	})(this, function(exports) {

	  function on(type, f) {
	    var handlers = this._handlers || (this._handlers = Object.create(null));
	    (handlers[type] || (handlers[type] = [])).push(f);
	  }

	  function off(type, f) {
	    var arr = this._handlers && this._handlers[type];
	    if (arr) for (var i = 0; i < arr.length; ++i)
	      if (arr[i] == f) { arr.splice(i, 1); break; }
	  }

	  var noHandlers = []
	  function getHandlers(emitter, type) {
	    var arr = emitter._handlers && emitter._handlers[type];
	    return arr && arr.length ? arr.slice() : noHandlers
	  }

	  function signal(type, a1, a2, a3, a4) {
	    var arr = getHandlers(this, type)
	    for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4)
	  }

	  function signalReturnFirst(type, a1, a2, a3, a4) {
	    var arr = getHandlers(this, type)
	    for (var i = 0; i < arr.length; ++i) {
	      var result = arr[i].call(this, a1, a2, a3, a4)
	      if (result) return result
	    }
	  }

	  function hasHandler(type) {
	    var arr = this._handlers && this._handlers[type]
	    return arr && arr.length > 0 && arr
	  }

	  exports.mixin = function(obj) {
	    obj.on = on; obj.off = off;
	    obj.signal = signal;
	    obj.signalReturnFirst = signalReturnFirst;
	    obj.hasHandler = hasHandler;
	    return obj;
	  };
	});


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {LocalizationHelper} = __webpack_require__(39);
	const L10N = new LocalizationHelper("devtools/locale/inspector.properties");

	const Editor = __webpack_require__(170);
	const beautify = __webpack_require__(185);

	const XHTML_NS = "http://www.w3.org/1999/xhtml";
	const CONTAINER_WIDTH = 500;

	/**
	 * Set the content of a provided HTMLTooltip instance to display a list of event
	 * listeners, with their event type, capturing argument and a link to the code
	 * of the event handler.
	 *
	 * @param {HTMLTooltip} tooltip
	 *        The tooltip instance on which the event details content should be set
	 * @param {Array} eventListenerInfos
	 *        A list of event listeners
	 * @param {Toolbox} toolbox
	 *        Toolbox used to select debugger panel
	 */
	function setEventTooltip(tooltip, eventListenerInfos, toolbox) {
	  let eventTooltip = new EventTooltip(tooltip, eventListenerInfos, toolbox);
	  eventTooltip.init();
	}

	function EventTooltip(tooltip, eventListenerInfos, toolbox) {
	  this._tooltip = tooltip;
	  this._eventListenerInfos = eventListenerInfos;
	  this._toolbox = toolbox;
	  this._eventEditors = new WeakMap();

	  // Used in tests: add a reference to the EventTooltip instance on the HTMLTooltip.
	  this._tooltip.eventTooltip = this;

	  this._headerClicked = this._headerClicked.bind(this);
	  this._debugClicked = this._debugClicked.bind(this);
	  this.destroy = this.destroy.bind(this);
	}

	EventTooltip.prototype = {
	  init: function () {
	    let config = {
	      mode: Editor.modes.js,
	      lineNumbers: false,
	      lineWrapping: true,
	      readOnly: true,
	      styleActiveLine: true,
	      extraKeys: {},
	      theme: "mozilla markup-view"
	    };

	    let doc = this._tooltip.doc;
	    this.container = doc.createElementNS(XHTML_NS, "div");
	    this.container.className = "devtools-tooltip-events-container";

	    for (let listener of this._eventListenerInfos) {
	      let phase = listener.capturing ? "Capturing" : "Bubbling";
	      let level = listener.DOM0 ? "DOM0" : "DOM2";

	      // Header
	      let header = doc.createElementNS(XHTML_NS, "div");
	      header.className = "event-header devtools-toolbar";
	      this.container.appendChild(header);

	      if (!listener.hide.debugger) {
	        let debuggerIcon = doc.createElementNS(XHTML_NS, "img");
	        debuggerIcon.className = "event-tooltip-debugger-icon";
	        debuggerIcon.setAttribute("src",
	          "chrome://devtools/skin/images/tool-debugger.svg");
	        let openInDebugger = L10N.getStr("eventsTooltip.openInDebugger");
	        debuggerIcon.setAttribute("title", openInDebugger);
	        header.appendChild(debuggerIcon);
	      }

	      if (!listener.hide.type) {
	        let eventTypeLabel = doc.createElementNS(XHTML_NS, "span");
	        eventTypeLabel.className = "event-tooltip-event-type";
	        eventTypeLabel.textContent = listener.type;
	        eventTypeLabel.setAttribute("title", listener.type);
	        header.appendChild(eventTypeLabel);
	      }

	      if (!listener.hide.filename) {
	        let filename = doc.createElementNS(XHTML_NS, "span");
	        filename.className = "event-tooltip-filename devtools-monospace";
	        filename.textContent = listener.origin;
	        filename.setAttribute("title", listener.origin);
	        header.appendChild(filename);
	      }

	      let attributesContainer = doc.createElementNS(XHTML_NS, "div");
	      attributesContainer.className = "event-tooltip-attributes-container";
	      header.appendChild(attributesContainer);

	      if (!listener.hide.capturing) {
	        let attributesBox = doc.createElementNS(XHTML_NS, "div");
	        attributesBox.className = "event-tooltip-attributes-box";
	        attributesContainer.appendChild(attributesBox);

	        let capturing = doc.createElementNS(XHTML_NS, "span");
	        capturing.className = "event-tooltip-attributes";
	        capturing.textContent = phase;
	        capturing.setAttribute("title", phase);
	        attributesBox.appendChild(capturing);
	      }

	      if (listener.tags) {
	        for (let tag of listener.tags.split(",")) {
	          let attributesBox = doc.createElementNS(XHTML_NS, "div");
	          attributesBox.className = "event-tooltip-attributes-box";
	          attributesContainer.appendChild(attributesBox);

	          let tagBox = doc.createElementNS(XHTML_NS, "span");
	          tagBox.className = "event-tooltip-attributes";
	          tagBox.textContent = tag;
	          tagBox.setAttribute("title", tag);
	          attributesBox.appendChild(tagBox);
	        }
	      }

	      if (!listener.hide.dom0) {
	        let attributesBox = doc.createElementNS(XHTML_NS, "div");
	        attributesBox.className = "event-tooltip-attributes-box";
	        attributesContainer.appendChild(attributesBox);

	        let dom0 = doc.createElementNS(XHTML_NS, "span");
	        dom0.className = "event-tooltip-attributes";
	        dom0.textContent = level;
	        dom0.setAttribute("title", level);
	        attributesBox.appendChild(dom0);
	      }

	      // Content
	      let content = doc.createElementNS(XHTML_NS, "div");
	      let editor = new Editor(config);
	      this._eventEditors.set(content, {
	        editor: editor,
	        handler: listener.handler,
	        searchString: listener.searchString,
	        uri: listener.origin,
	        dom0: listener.DOM0,
	        appended: false
	      });

	      content.className = "event-tooltip-content-box";
	      this.container.appendChild(content);

	      this._addContentListeners(header);
	    }

	    this._tooltip.setContent(this.container, {width: CONTAINER_WIDTH});
	    this._tooltip.on("hidden", this.destroy);
	  },

	  _addContentListeners: function (header) {
	    header.addEventListener("click", this._headerClicked);
	  },

	  _headerClicked: function (event) {
	    if (event.target.classList.contains("event-tooltip-debugger-icon")) {
	      this._debugClicked(event);
	      event.stopPropagation();
	      return;
	    }

	    let doc = this._tooltip.doc;
	    let header = event.currentTarget;
	    let content = header.nextElementSibling;

	    if (content.hasAttribute("open")) {
	      content.removeAttribute("open");
	    } else {
	      let contentNodes = doc.querySelectorAll(".event-tooltip-content-box");

	      for (let node of contentNodes) {
	        if (node !== content) {
	          node.removeAttribute("open");
	        }
	      }

	      content.setAttribute("open", "");

	      let eventEditor = this._eventEditors.get(content);

	      if (eventEditor.appended) {
	        return;
	      }

	      let {editor, handler} = eventEditor;

	      let iframe = doc.createElementNS(XHTML_NS, "iframe");
	      iframe.setAttribute("style", "width: 100%; height: 100%; border-style: none;");

	      editor.appendTo(content, iframe).then(() => {
	        let tidied = beautify.js(handler, { "indent_size": 2 });
	        editor.setText(tidied);

	        eventEditor.appended = true;

	        let container = header.parentElement.getBoundingClientRect();
	        if (header.getBoundingClientRect().top < container.top) {
	          header.scrollIntoView(true);
	        } else if (content.getBoundingClientRect().bottom > container.bottom) {
	          content.scrollIntoView(false);
	        }

	        this._tooltip.emit("event-tooltip-ready");
	      });
	    }
	  },

	  _debugClicked: function (event) {
	    let header = event.currentTarget;
	    let content = header.nextElementSibling;

	    let {uri, searchString, dom0} = this._eventEditors.get(content);

	    if (uri && uri !== "?") {
	      // Save a copy of toolbox as it will be set to null when we hide the tooltip.
	      let toolbox = this._toolbox;

	      this._tooltip.hide();

	      uri = uri.replace(/"/g, "");

	      let showSource = ({ DebuggerView }) => {
	        let matches = uri.match(/(.*):(\d+$)/);
	        let line = 1;

	        if (matches) {
	          uri = matches[1];
	          line = matches[2];
	        }

	        let item = DebuggerView.Sources.getItemForAttachment(a => a.source.url === uri);
	        if (item) {
	          let actor = item.attachment.source.actor;
	          DebuggerView.setEditorLocation(
	            actor, line, {noDebug: true}
	          ).then(() => {
	            if (dom0) {
	              let text = DebuggerView.editor.getText();
	              let index = text.indexOf(searchString);
	              let lastIndex = text.lastIndexOf(searchString);

	              // To avoid confusion we only search for DOM0 event handlers when
	              // there is only one possible match in the file.
	              if (index !== -1 && index === lastIndex) {
	                text = text.substr(0, index);
	                let newlineMatches = text.match(/\n/g);

	                if (newlineMatches) {
	                  DebuggerView.editor.setCursor({
	                    line: newlineMatches.length
	                  });
	                }
	              }
	            }
	          });
	        }
	      };

	      let debuggerAlreadyOpen = toolbox.getPanel("jsdebugger");
	      toolbox.selectTool("jsdebugger").then(({ panelWin: dbg }) => {
	        if (debuggerAlreadyOpen) {
	          showSource(dbg);
	        } else {
	          dbg.once(dbg.EVENTS.SOURCES_ADDED, () => showSource(dbg));
	        }
	      });
	    }
	  },

	  destroy: function () {
	    if (this._tooltip) {
	      this._tooltip.off("hidden", this.destroy);

	      let boxes = this.container.querySelectorAll(".event-tooltip-content-box");

	      for (let box of boxes) {
	        let {editor} = this._eventEditors.get(box);
	        editor.destroy();
	      }

	      this._eventEditors = null;
	      this._tooltip.eventTooltip = null;
	    }

	    let headerNodes = this.container.querySelectorAll(".event-header");

	    for (let node of headerNodes) {
	      node.removeEventListener("click", this._headerClicked);
	    }

	    let sourceNodes = this.container.querySelectorAll(".event-tooltip-debugger-icon");
	    for (let node of sourceNodes) {
	      node.removeEventListener("click", this._debugClicked);
	    }

	    this._eventListenerInfos = this._toolbox = this._tooltip = null;
	  }
	};

	module.exports.setEventTooltip = setEventTooltip;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var { cssBeautify } = __webpack_require__(186);
	var { htmlBeautify } = __webpack_require__(187);
	var { jsBeautify } = __webpack_require__(188);

	exports.css = cssBeautify;
	exports.html = htmlBeautify;
	exports.js = jsBeautify;


/***/ },
/* 186 */
/***/ function(module, exports) {

	/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 CSS Beautifier
	---------------

	    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

	    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	        http://jsbeautifier.org/

	    Usage:
	        css_beautify(source_text);
	        css_beautify(source_text, options);

	    The options are (default in brackets):
	        indent_size (4)                   — indentation size,
	        indent_char (space)               — character to indent with,
	        selector_separator_newline (true) - separate selectors with newline or
	                                            not (e.g. "a,\nbr" or "a, br")
	        end_with_newline (false)          - end with a newline

	    e.g

	    css_beautify(css_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t',
	      'selector_separator': ' ',
	      'end_with_newline': false,
	    });
	*/

	// http://www.w3.org/TR/CSS21/syndata.html#tokenization
	// http://www.w3.org/TR/css3-syntax/

	(function () {
	    function css_beautify(source_text, options) {
	        options = options || {};
	        var indentSize = options.indent_size || 4;
	        var indentCharacter = options.indent_char || ' ';
	        var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;
	        var endWithNewline = (options.end_with_newline === undefined) ? false : options.end_with_newline;

	        // compatibility
	        if (typeof indentSize === "string") {
	            indentSize = parseInt(indentSize, 10);
	        }


	        // tokenizer
	        var whiteRe = /^\s+$/;
	        var wordRe = /[\w$\-_]/;

	        var pos = -1,
	            ch;

	        function next() {
	            ch = source_text.charAt(++pos);
	            return ch;
	        }

	        function peek() {
	            return source_text.charAt(pos + 1);
	        }

	        function eatString(endChar) {
	            var start = pos;
	            while (next()) {
	                if (ch === "\\") {
	                    next();
	                    next();
	                } else if (ch === endChar) {
	                    break;
	                } else if (ch === "\n") {
	                    break;
	                }
	            }
	            return source_text.substring(start, pos + 1);
	        }

	        function eatWhitespace() {
	            var start = pos;
	            while (whiteRe.test(peek())) {
	                pos++;
	            }
	            return pos !== start;
	        }

	        function skipWhitespace() {
	            var start = pos;
	            do {} while (whiteRe.test(next()));
	            return pos !== start + 1;
	        }

	        function eatComment(singleLine) {
	            var start = pos;
	            next();
	            while (next()) {
	                if (ch === "*" && peek() === "/") {
	                    pos++;
	                    break;
	                } else if (singleLine && ch === "\n") {
	                    break;
	                }
	            }

	            return source_text.substring(start, pos + 1);
	        }


	        function lookBack(str) {
	            return source_text.substring(pos - str.length, pos).toLowerCase() ===
	                str;
	        }

	        function isCommentOnLine() {
	            var endOfLine = source_text.indexOf('\n', pos);
	            if (endOfLine === -1) {
	                return false;
	            }
	            var restOfLine = source_text.substring(pos, endOfLine);
	            return restOfLine.indexOf('//') !== -1;
	        }

	        // printer
	        var indentString = source_text.match(/^[\r\n]*[\t ]*/)[0];
	        var singleIndent = new Array(indentSize + 1).join(indentCharacter);
	        var indentLevel = 0;
	        var nestedLevel = 0;

	        function indent() {
	            indentLevel++;
	            indentString += singleIndent;
	        }

	        function outdent() {
	            indentLevel--;
	            indentString = indentString.slice(0, -indentSize);
	        }

	        var print = {};
	        print["{"] = function (ch) {
	            print.singleSpace();
	            output.push(ch);
	            print.newLine();
	        };
	        print["}"] = function (ch) {
	            print.newLine();
	            output.push(ch);
	            print.newLine();
	        };

	        print._lastCharWhitespace = function () {
	            return whiteRe.test(output[output.length - 1]);
	        };

	        print.newLine = function (keepWhitespace) {
	            if (!keepWhitespace) {
	                while (print._lastCharWhitespace()) {
	                    output.pop();
	                }
	            }

	            if (output.length) {
	                output.push('\n');
	            }
	            if (indentString) {
	                output.push(indentString);
	            }
	        };
	        print.singleSpace = function () {
	            if (output.length && !print._lastCharWhitespace()) {
	                output.push(' ');
	            }
	        };
	        var output = [];
	        if (indentString) {
	            output.push(indentString);
	        }
	        /*_____________________--------------------_____________________*/

	        var insideRule = false;
	        var enteringConditionalGroup = false;

	        while (true) {
	            var isAfterSpace = skipWhitespace();

	            if (!ch) {
	                break;
	            } else if (ch === '/' && peek() === '*') { /* css comment */
	                print.newLine();
	                output.push(eatComment(), "\n", indentString);
	                var header = lookBack("");
	                if (header) {
	                    print.newLine();
	                }
	            } else if (ch === '/' && peek() === '/') { // single line comment
	                output.push(eatComment(true), indentString);
	            } else if (ch === '@') {
	                // strip trailing space, if present, for hash property checks
	                var atRule = eatString(" ").replace(/ $/, '');

	                // pass along the space we found as a separate item
	                output.push(atRule, ch);

	                // might be a nesting at-rule
	                if (atRule in css_beautify.NESTED_AT_RULE) {
	                    nestedLevel += 1;
	                    if (atRule in css_beautify.CONDITIONAL_GROUP_RULE) {
	                        enteringConditionalGroup = true;
	                    }
	                }
	            } else if (ch === '{') {
	                eatWhitespace();
	                if (peek() === '}') {
	                    next();
	                    output.push(" {}");
	                } else {
	                    indent();
	                    print["{"](ch);
	                    // when entering conditional groups, only rulesets are allowed
	                    if (enteringConditionalGroup) {
	                        enteringConditionalGroup = false;
	                        insideRule = (indentLevel > nestedLevel);
	                    } else {
	                        // otherwise, declarations are also allowed
	                        insideRule = (indentLevel >= nestedLevel);
	                    }
	                }
	            } else if (ch === '}') {
	                outdent();
	                print["}"](ch);
	                insideRule = false;
	                if (nestedLevel) {
	                    nestedLevel--;
	                }
	            } else if (ch === ":") {
	                eatWhitespace();
	                if (insideRule || enteringConditionalGroup) {
	                    // 'property: value' delimiter
	                    // which could be in a conditional group query
	                    output.push(ch, " ");
	                } else {
	                    if (peek() === ":") {
	                        // pseudo-element
	                        next();
	                        output.push("::");
	                    } else {
	                        // pseudo-class
	                        output.push(ch);
	                    }
	                }
	            } else if (ch === '"' || ch === '\'') {
	                output.push(eatString(ch));
	            } else if (ch === ';') {
	                if (isCommentOnLine()) {
	                    var beforeComment = eatString('/');
	                    var comment = eatComment(true);
	                    output.push(beforeComment, comment.substring(1, comment.length - 1), '\n', indentString);
	                } else {
	                    output.push(ch, '\n', indentString);
	                }
	            } else if (ch === '(') { // may be a url
	                if (lookBack("url")) {
	                    output.push(ch);
	                    eatWhitespace();
	                    if (next()) {
	                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
	                            output.push(eatString(')'));
	                        } else {
	                            pos--;
	                        }
	                    }
	                } else {
	                    if (isAfterSpace) {
	                        print.singleSpace();
	                    }
	                    output.push(ch);
	                    eatWhitespace();
	                }
	            } else if (ch === ')') {
	                output.push(ch);
	            } else if (ch === ',') {
	                eatWhitespace();
	                output.push(ch);
	                if (!insideRule && selectorSeparatorNewline) {
	                    print.newLine();
	                } else {
	                    print.singleSpace();
	                }
	            } else if (ch === ']') {
	                output.push(ch);
	            } else if (ch === '[') {
	                if (isAfterSpace) {
	                    print.singleSpace();
	                }
	                output.push(ch);
	            } else if (ch === '=') { // no whitespace before or after
	                eatWhitespace();
	                output.push(ch);
	            } else {
	                if (isAfterSpace) {
	                    print.singleSpace();
	                }

	                output.push(ch);
	            }
	        }


	        var sweetCode = output.join('').replace(/[\n ]+$/, '');

	        // establish end_with_newline
	        var should = endWithNewline;
	        var actually = /\n$/.test(sweetCode);
	        if (should && !actually) {
	            sweetCode += "\n";
	        } else if (!should && actually) {
	            sweetCode = sweetCode.slice(0, -1);
	        }

	        return sweetCode;
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
	    css_beautify.NESTED_AT_RULE = {
	        "@page": true,
	        "@font-face": true,
	        "@keyframes": true,
	        // also in CONDITIONAL_GROUP_RULE below
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };
	    css_beautify.CONDITIONAL_GROUP_RULE = {
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };

	    exports.cssBeautify = css_beautify;
	}());


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 Style HTML
	---------------

	  Written by Nochum Sossonko, (nsossonko@hotmail.com)

	  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	    http://jsbeautifier.org/

	  Usage:
	    style_html(html_source);

	    style_html(html_source, options);

	  The options are:
	    indent_inner_html (default false)  — indent <head> and <body> sections,
	    indent_size (default 4)          — indentation size,
	    indent_char (default space)      — character to indent with,
	    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.
	    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
	    indent_scripts (default normal)  - "keep"|"separate"|"normal"
	    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
	                                        Only works before elements, not inside tags or for text.
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
	    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}

	    e.g.

	    style_html(html_source, {
	      'indent_inner_html': false,
	      'indent_size': 2,
	      'indent_char': ' ',
	      'wrap_line_length': 78,
	      'brace_style': 'expand',
	      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u'],
	      'preserve_newlines': true,
	      'max_preserve_newlines': 5,
	      'indent_handlebars': false
	    });
	*/

	(function() {

	    function trim(s) {
	        return s.replace(/^\s+|\s+$/g, '');
	    }

	    function ltrim(s) {
	        return s.replace(/^\s+/g, '');
	    }

	    function style_html(html_source, options, js_beautify, css_beautify) {
	        //Wrapper function to invoke all the necessary constructors and deal with the output.

	        var multi_parser,
	            indent_inner_html,
	            indent_size,
	            indent_character,
	            wrap_line_length,
	            brace_style,
	            unformatted,
	            preserve_newlines,
	            max_preserve_newlines,
	            indent_handlebars;

	        options = options || {};

	        // backwards compatibility to 1.3.4
	        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&
	                (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {
	            options.wrap_line_length = options.max_char;
	        }

	        indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;
	        indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);
	        indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;
	        brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;
	        wrap_line_length =  parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
	        unformatted = options.unformatted || ['a', 'span', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	        preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
	        max_preserve_newlines = preserve_newlines ?
	            (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10))
	            : 0;
	        indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;

	        function Parser() {

	            this.pos = 0; //Parser position
	            this.token = '';
	            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
	            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
	                parent: 'parent1',
	                parentcount: 1,
	                parent1: ''
	            };
	            this.tag_type = '';
	            this.token_text = this.last_token = this.last_text = this.token_type = '';
	            this.newlines = 0;
	            this.indent_content = indent_inner_html;

	            this.Utils = { //Uilities made available to the various functions
	                whitespace: "\n\r\t ".split(''),
	                single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML
	                extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them
	                in_array: function(what, arr) {
	                    for (var i = 0; i < arr.length; i++) {
	                        if (what === arr[i]) {
	                            return true;
	                        }
	                    }
	                    return false;
	                }
	            };

	            this.traverse_whitespace = function() {
	                var input_char = '';

	                input_char = this.input.charAt(this.pos);
	                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                    this.newlines = 0;
	                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
	                            this.newlines += 1;
	                        }

	                        this.pos++;
	                        input_char = this.input.charAt(this.pos);
	                    }
	                    return true;
	                }
	                return false;
	            };

	            this.get_content = function() { //function to capture regular content between tags

	                var input_char = '',
	                    content = [],
	                    space = false; //if a space is needed

	                while (this.input.charAt(this.pos) !== '<') {
	                    if (this.pos >= this.input.length) {
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    if (this.traverse_whitespace()) {
	                        if (content.length) {
	                            space = true;
	                        }
	                        continue; //don't want to insert unnecessary space
	                    }

	                    if (indent_handlebars) {
	                        // Handlebars parsing is complicated.
	                        // {{#foo}} and {{/foo}} are formatted tags.
	                        // {{something}} should get treated as content, except:
	                        // {{else}} specifically behaves like {{#if}} and {{/if}}
	                        var peek3 = this.input.substr(this.pos, 3);
	                        if (peek3 === '{{#' || peek3 === '{{/') {
	                            // These are tags and not content.
	                            break;
	                        } else if (this.input.substr(this.pos, 2) === '{{') {
	                            if (this.get_tag(true) === '{{else}}') {
	                                break;
	                            }
	                        }
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (space) {
	                        if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached
	                            this.print_newline(false, content);
	                            this.print_indentation(content);
	                        } else {
	                            this.line_char_count++;
	                            content.push(' ');
	                        }
	                        space = false;
	                    }
	                    this.line_char_count++;
	                    content.push(input_char); //letter at-a-time (or string) inserted to an array
	                }
	                return content.length ? content.join('') : '';
	            };

	            this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify
	                if (this.pos === this.input.length) {
	                    return ['', 'TK_EOF'];
	                }
	                var input_char = '';
	                var content = '';
	                var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
	                reg_match.lastIndex = this.pos;
	                var reg_array = reg_match.exec(this.input);
	                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
	                if (this.pos < end_script) { //get everything in between the script tags
	                    content = this.input.substring(this.pos, end_script);
	                    this.pos = end_script;
	                }
	                return content;
	            };

	            this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object
	                if (this.tags[tag + 'count']) { //check for the existence of this tag type
	                    this.tags[tag + 'count']++;
	                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                } else { //otherwise initialize this tag type
	                    this.tags[tag + 'count'] = 1;
	                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                }
	                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
	                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
	            };

	            this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer
	                if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
	                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.
	                    while (temp_parent) { //till we reach '' (the initial value);
	                        if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
	                            break;
	                        }
	                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
	                    }
	                    if (temp_parent) { //if we caught something
	                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
	                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
	                    }
	                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
	                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
	                    if (this.tags[tag + 'count'] === 1) {
	                        delete this.tags[tag + 'count'];
	                    } else {
	                        this.tags[tag + 'count']--;
	                    }
	                }
	            };

	            this.indent_to_tag = function(tag) {
	                // Match the indentation level to the last use of this tag, but don't remove it.
	                if (!this.tags[tag + 'count']) {
	                    return;
	                }
	                var temp_parent = this.tags.parent;
	                while (temp_parent) {
	                    if (tag + this.tags[tag + 'count'] === temp_parent) {
	                        break;
	                    }
	                    temp_parent = this.tags[temp_parent + 'parent'];
	                }
	                if (temp_parent) {
	                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];
	                }
	            };

	            this.get_tag = function(peek) { //function to get a full tag and parse its type
	                var input_char = '',
	                    content = [],
	                    comment = '',
	                    space = false,
	                    tag_start, tag_end,
	                    tag_start_char,
	                    orig_pos = this.pos,
	                    orig_line_char_count = this.line_char_count;

	                peek = peek !== undefined ? peek : false;

	                do {
	                    if (this.pos >= this.input.length) {
	                        if (peek) {
	                            this.pos = orig_pos;
	                            this.line_char_count = orig_line_char_count;
	                        }
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
	                        space = true;
	                        continue;
	                    }

	                    if (input_char === "'" || input_char === '"') {
	                        input_char += this.get_unformatted(input_char);
	                        space = true;

	                    }

	                    if (input_char === '=') { //no space before =
	                        space = false;
	                    }

	                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
	                        //no space after = or before >
	                        if (this.line_char_count >= this.wrap_line_length) {
	                            this.print_newline(false, content);
	                            this.print_indentation(content);
	                        } else {
	                            content.push(' ');
	                            this.line_char_count++;
	                        }
	                        space = false;
	                    }

	                    if (indent_handlebars && tag_start_char === '<') {
	                        // When inside an angle-bracket tag, put spaces around
	                        // handlebars not inside of strings.
	                        if ((input_char + this.input.charAt(this.pos)) === '{{') {
	                            input_char += this.get_unformatted('}}');
	                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
	                                input_char = ' ' + input_char;
	                            }
	                            space = true;
	                        }
	                    }

	                    if (input_char === '<' && !tag_start_char) {
	                        tag_start = this.pos - 1;
	                        tag_start_char = '<';
	                    }

	                    if (indent_handlebars && !tag_start_char) {
	                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] == '{') {
	                            if (input_char === '#' || input_char === '/') {
	                                tag_start = this.pos - 3;
	                            } else {
	                                tag_start = this.pos - 2;
	                            }
	                            tag_start_char = '{';
	                        }
	                    }

	                    this.line_char_count++;
	                    content.push(input_char); //inserts character at-a-time (or string)

	                    if (content[1] && content[1] === '!') { //if we're in a comment, do something special
	                        // We treat all comments as literals, even more than preformatted tags
	                        // we just look for the appropriate close tag
	                        content = [this.get_comment(tag_start)];
	                        break;
	                    }

	                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
	                        break;
	                    }
	                } while (input_char !== '>');

	                var tag_complete = content.join('');
	                var tag_index;
	                var tag_offset;

	                if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
	                    tag_index = tag_complete.indexOf(' ');
	                } else if (tag_complete[0] === '{') {
	                    tag_index = tag_complete.indexOf('}');
	                } else { //otherwise go with the tag ending
	                    tag_index = tag_complete.indexOf('>');
	                }
	                if (tag_complete[0] === '<' || !indent_handlebars) {
	                    tag_offset = 1;
	                } else {
	                    tag_offset = tag_complete[2] === '#' ? 3 : 2;
	                }
	                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
	                if (tag_complete.charAt(tag_complete.length - 2) === '/' ||
	                    this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                    }
	                } else if (indent_handlebars && tag_complete[0] === '{' && tag_check === 'else') {
	                    if (!peek) {
	                        this.indent_to_tag('if');
	                        this.tag_type = 'HANDLEBARS_ELSE';
	                        this.indent_content = true;
	                        this.traverse_whitespace();
	                    }
	                } else if (tag_check === 'script' &&
	                    (tag_complete.search('type') === -1 ||
	                    (tag_complete.search('type') > -1 &&
	                    tag_complete.search(/\b(text|application)\/(x-)?(javascript|ecmascript|jscript|livescript)/) > -1))) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'SCRIPT';
	                    }
	                } else if (tag_check === 'style' &&
	                    (tag_complete.search('type') === -1 ||
	                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'STYLE';
	                    }
	                } else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the "unformatted" tags
	                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
	                    content.push(comment);
	                    // Preserve collapsed whitespace either before or after this tag.
	                    if (tag_start > 0 && this.Utils.in_array(this.input.charAt(tag_start - 1), this.Utils.whitespace)) {
	                        content.splice(0, 0, this.input.charAt(tag_start - 1));
	                    }
	                    tag_end = this.pos - 1;
	                    if (this.Utils.in_array(this.input.charAt(tag_end + 1), this.Utils.whitespace)) {
	                        content.push(this.input.charAt(tag_end + 1));
	                    }
	                    this.tag_type = 'SINGLE';
	                } else if (tag_check.charAt(0) === '!') { //peek for <! comment
	                    // for comments content is already correct.
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                        this.traverse_whitespace();
	                    }
	                } else if (!peek) {
	                    if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
	                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
	                        this.tag_type = 'END';
	                        this.traverse_whitespace();
	                    } else { //otherwise it's a start-tag
	                        this.record_tag(tag_check); //push it on the tag stack
	                        if (tag_check.toLowerCase() !== 'html') {
	                            this.indent_content = true;
	                        }
	                        this.tag_type = 'START';

	                        // Allow preserving of newlines after a start tag
	                        this.traverse_whitespace();
	                    }
	                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
	                        this.print_newline(false, this.output);
	                        if (this.output.length && this.output[this.output.length - 2] !== '\n') {
	                            this.print_newline(true, this.output);
	                        }
	                    }
	                }

	                if (peek) {
	                    this.pos = orig_pos;
	                    this.line_char_count = orig_line_char_count;
	                }

	                return content.join(''); //returns fully formatted tag
	            };

	            this.get_comment = function(start_pos) { //function to return comment content in its entirety
	                // this is will have very poor perf, but will work for now.
	                var comment = '',
	                    delimiter = '>',
	                    matched = false;

	                this.pos = start_pos;
	                input_char = this.input.charAt(this.pos);
	                this.pos++;

	                while (this.pos <= this.input.length) {
	                    comment += input_char;

	                    // only need to check for the delimiter if the last chars match
	                    if (comment[comment.length - 1] === delimiter[delimiter.length - 1] &&
	                        comment.indexOf(delimiter) !== -1) {
	                        break;
	                    }

	                    // only need to search for custom delimiter for the first few characters
	                    if (!matched && comment.length < 10) {
	                        if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment
	                            delimiter = '<![endif]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...
	                            delimiter = ']]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...
	                            delimiter = ']>';
	                            matched = true;
	                        } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...
	                            delimiter = '-->';
	                            matched = true;
	                        }
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;
	                }

	                return comment;
	            };

	            this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety

	                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
	                    return '';
	                }
	                var input_char = '';
	                var content = '';
	                var min_index = 0;
	                var space = true;
	                do {

	                    if (this.pos >= this.input.length) {
	                        return content;
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (!space) {
	                            this.line_char_count--;
	                            continue;
	                        }
	                        if (input_char === '\n' || input_char === '\r') {
	                            content += '\n';
	                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
	                for (var i=0; i<this.indent_level; i++) {
	                  content += this.indent_string;
	                }
	                space = false; //...and make sure other indentation is erased
	                */
	                            this.line_char_count = 0;
	                            continue;
	                        }
	                    }
	                    content += input_char;
	                    this.line_char_count++;
	                    space = true;

	                    if (indent_handlebars && input_char === '{' && content.length && content[content.length - 2] === '{') {
	                        // Handlebars expressions in strings should also be unformatted.
	                        content += this.get_unformatted('}}');
	                        // These expressions are opaque.  Ignore delimiters found in them.
	                        min_index = content.length;
	                    }
	                } while (content.toLowerCase().indexOf(delimiter, min_index) === -1);
	                return content;
	            };

	            this.get_token = function() { //initial handler for token-retrieval
	                var token;

	                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
	                    var type = this.last_token.substr(7);
	                    token = this.get_contents_to(type);
	                    if (typeof token !== 'string') {
	                        return token;
	                    }
	                    return [token, 'TK_' + type];
	                }
	                if (this.current_mode === 'CONTENT') {
	                    token = this.get_content();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        return [token, 'TK_CONTENT'];
	                    }
	                }

	                if (this.current_mode === 'TAG') {
	                    token = this.get_tag();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        var tag_name_type = 'TK_TAG_' + this.tag_type;
	                        return [token, tag_name_type];
	                    }
	                }
	            };

	            this.get_full_indent = function(level) {
	                level = this.indent_level + level || 0;
	                if (level < 1) {
	                    return '';
	                }

	                return Array(level + 1).join(this.indent_string);
	            };

	            this.is_unformatted = function(tag_check, unformatted) {
	                //is this an HTML5 block-level link?
	                if (!this.Utils.in_array(tag_check, unformatted)) {
	                    return false;
	                }

	                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
	                    return true;
	                }

	                //at this point we have an  tag; is its first child something we want to remain
	                //unformatted?
	                var next_tag = this.get_tag(true /* peek. */ );

	                // test next_tag to see if it is just html tag (no external content)
	                var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

	                // if next_tag comes back but is not an isolated tag, then
	                // let's treat the 'a' tag as having content
	                // and respect the unformatted option
	                if (!tag || this.Utils.in_array(tag, unformatted)) {
	                    return true;
	                } else {
	                    return false;
	                }
	            };

	            this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions

	                this.input = js_source || ''; //gets the input for the Parser
	                this.output = [];
	                this.indent_character = indent_character;
	                this.indent_string = '';
	                this.indent_size = indent_size;
	                this.brace_style = brace_style;
	                this.indent_level = 0;
	                this.wrap_line_length = wrap_line_length;
	                this.line_char_count = 0; //count to see if wrap_line_length was exceeded

	                for (var i = 0; i < this.indent_size; i++) {
	                    this.indent_string += this.indent_character;
	                }

	                this.print_newline = function(force, arr) {
	                    this.line_char_count = 0;
	                    if (!arr || !arr.length) {
	                        return;
	                    }
	                    if (force || (arr[arr.length - 1] !== '\n')) { //we might want the extra line
	                        arr.push('\n');
	                    }
	                };

	                this.print_indentation = function(arr) {
	                    for (var i = 0; i < this.indent_level; i++) {
	                        arr.push(this.indent_string);
	                        this.line_char_count += this.indent_string.length;
	                    }
	                };

	                this.print_token = function(text) {
	                    if (text || text !== '') {
	                        if (this.output.length && this.output[this.output.length - 1] === '\n') {
	                            this.print_indentation(this.output);
	                            text = ltrim(text);
	                        }
	                    }
	                    this.print_token_raw(text);
	                };

	                this.print_token_raw = function(text) {
	                    if (text && text !== '') {
	                        if (text.length > 1 && text[text.length - 1] === '\n') {
	                            // unformatted tags can grab newlines as their last character
	                            this.output.push(text.slice(0, -1));
	                            this.print_newline(false, this.output);
	                        } else {
	                            this.output.push(text);
	                        }
	                    }

	                    for (var n = 0; n < this.newlines; n++) {
	                        this.print_newline(n > 0, this.output);
	                    }
	                    this.newlines = 0;
	                };

	                this.indent = function() {
	                    this.indent_level++;
	                };

	                this.unindent = function() {
	                    if (this.indent_level > 0) {
	                        this.indent_level--;
	                    }
	                };
	            };
	            return this;
	        }

	        /*_____________________--------------------_____________________*/

	        multi_parser = new Parser(); //wrapping functions Parser
	        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values

	        while (true) {
	            var t = multi_parser.get_token();
	            multi_parser.token_text = t[0];
	            multi_parser.token_type = t[1];

	            if (multi_parser.token_type === 'TK_EOF') {
	                break;
	            }

	            switch (multi_parser.token_type) {
	                case 'TK_TAG_START':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        multi_parser.indent();
	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_STYLE':
	                case 'TK_TAG_SCRIPT':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_END':
	                    //Print new line only if the tag has no content and has child
	                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
	                        var tag_name = multi_parser.token_text.match(/\w+/)[0];
	                        var tag_extracted_from_last_output = null;
	                        if (multi_parser.output.length) {
	                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
	                        }
	                        if (tag_extracted_from_last_output === null ||
	                            tag_extracted_from_last_output[1] !== tag_name) {
	                            multi_parser.print_newline(false, multi_parser.output);
	                        }
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_SINGLE':
	                    // Don't add a newline before elements that should remain unformatted.
	                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z]+)/i);
	                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
	                        multi_parser.print_newline(false, multi_parser.output);
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_HANDLEBARS_ELSE':
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        multi_parser.indent();
	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_CONTENT':
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'TAG';
	                    break;
	                case 'TK_STYLE':
	                case 'TK_SCRIPT':
	                    if (multi_parser.token_text !== '') {
	                        multi_parser.print_newline(false, multi_parser.output);
	                        var text = multi_parser.token_text,
	                            _beautifier,
	                            script_indent_level = 1;
	                        if (multi_parser.token_type === 'TK_SCRIPT') {
	                            _beautifier = typeof js_beautify === 'function' && js_beautify;
	                        } else if (multi_parser.token_type === 'TK_STYLE') {
	                            _beautifier = typeof css_beautify === 'function' && css_beautify;
	                        }

	                        if (options.indent_scripts === "keep") {
	                            script_indent_level = 0;
	                        } else if (options.indent_scripts === "separate") {
	                            script_indent_level = -multi_parser.indent_level;
	                        }

	                        var indentation = multi_parser.get_full_indent(script_indent_level);
	                        if (_beautifier) {
	                            // call the Beautifier if avaliable
	                            text = _beautifier(text.replace(/^\s*/, indentation), options);
	                        } else {
	                            // simply indent the string otherwise
	                            var white = text.match(/^\s*/)[0];
	                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
	                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
	                            text = text.replace(/^\s*/, indentation)
	                                .replace(/\r\n|\r|\n/g, '\n' + reindent)
	                                .replace(/\s+$/, '');
	                        }
	                        if (text) {
	                            multi_parser.print_token_raw(indentation + trim(text));
	                            multi_parser.print_newline(false, multi_parser.output);
	                        }
	                    }
	                    multi_parser.current_mode = 'TAG';
	                    break;
	            }
	            multi_parser.last_token = multi_parser.token_type;
	            multi_parser.last_text = multi_parser.token_text;
	        }
	        return multi_parser.output.join('');
	    }

	    var beautify = __webpack_require__(185);

	    exports.htmlBeautify = function(html_source, options) {
	        return style_html(html_source, options, beautify.js, beautify.css);
	    };
	}());


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */

	"use strict";

	const acorn = __webpack_require__(178);

	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.

	 JS Beautifier
	---------------


	  Written by Einar Lielmanis, <einar@jsbeautifier.org>
	      http://jsbeautifier.org/

	  Originally converted to javascript by Vital, <vital76@gmail.com>
	  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
	  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


	  Usage:
	    js_beautify(js_source_text);
	    js_beautify(js_source_text, options);

	  The options are:
	    indent_size (default 4)          - indentation size,
	    indent_char (default space)      - character to indent with,
	    preserve_newlines (default true) - whether existing line breaks should be preserved,
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

	    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

	            jslint_happy       !jslint_happy
	            ---------------------------------
	            function ()        function()

	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.

	    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

	    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

	    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
	          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
	                be preserved if it were present.

	    e.g

	    js_beautify(js_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t'
	    });

	*/

	var js_beautify = function js_beautify(js_source_text, options) {
	    var beautifier = new Beautifier(js_source_text, options);
	    return beautifier.beautify();
	};

	exports.jsBeautify = js_beautify;

	function Beautifier(js_source_text, options) {
	    var input, output_lines;
	    var token_text, token_type, last_type, last_last_text, indent_string;
	    var flags, previous_flags, flag_store;
	    var whitespace, wordchar, punct, parser_pos, line_starters, reserved_words, digits;
	    var prefix;
	    var input_wanted_newline;
	    var output_space_before_token;
	    var input_length, n_newlines, whitespace_before_token;
	    var handlers, MODE, opt;
	    var preindent_string = '';



	    whitespace = "\n\r\t ".split('');
	    wordchar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'.split('');
	    digits = '0123456789'.split('');

	    punct = '+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>';
	    punct += ' <%= <% %> <?= <? ?>'; // try to be a good boy and try not to break the markup language identifiers
	    punct = punct.split(' ');

	    // words which should always start on new line.
	    line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,yield'.split(',');
	    reserved_words = line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof']);


	    MODE = {
	        BlockStatement: 'BlockStatement', // 'BLOCK'
	        Statement: 'Statement', // 'STATEMENT'
	        ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
	        ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
	        ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
	        Conditional: 'Conditional', //'(COND-EXPRESSION)',
	        Expression: 'Expression' //'(EXPRESSION)'
	    };

	    handlers = {
	        'TK_START_EXPR': handle_start_expr,
	        'TK_END_EXPR': handle_end_expr,
	        'TK_START_BLOCK': handle_start_block,
	        'TK_END_BLOCK': handle_end_block,
	        'TK_WORD': handle_word,
	        'TK_RESERVED': handle_word,
	        'TK_SEMICOLON': handle_semicolon,
	        'TK_STRING': handle_string,
	        'TK_EQUALS': handle_equals,
	        'TK_OPERATOR': handle_operator,
	        'TK_COMMA': handle_comma,
	        'TK_BLOCK_COMMENT': handle_block_comment,
	        'TK_INLINE_COMMENT': handle_inline_comment,
	        'TK_COMMENT': handle_comment,
	        'TK_DOT': handle_dot,
	        'TK_UNKNOWN': handle_unknown
	    };

	    function create_flags(flags_base, mode) {
	        var next_indent_level = 0;
	        if (flags_base) {
	            next_indent_level = flags_base.indentation_level;
	            if (!just_added_newline() &&
	                flags_base.line_indent_level > next_indent_level) {
	                next_indent_level = flags_base.line_indent_level;
	            }
	        }

	        var next_flags = {
	            mode: mode,
	            parent: flags_base,
	            last_text: flags_base ? flags_base.last_text : '', // last token text
	            last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
	            declaration_statement: false,
	            declaration_assignment: false,
	            in_html_comment: false,
	            multiline_frame: false,
	            if_block: false,
	            else_block: false,
	            do_block: false,
	            do_while: false,
	            in_case_statement: false, // switch(..){ INSIDE HERE }
	            in_case: false, // we're on the exact line with "case 0:"
	            case_body: false, // the indented case-action block
	            indentation_level: next_indent_level,
	            line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
	            start_line_index: output_lines.length,
	            had_comment: false,
	            ternary_depth: 0
	        };
	        return next_flags;
	    }

	    // Using object instead of string to allow for later expansion of info about each line

	    function create_output_line() {
	        return {
	            text: []
	        };
	    }

	    // Some interpreters have unexpected results with foo = baz || bar;
	    options = options ? options : {};
	    opt = {};

	    // compatibility
	    if (options.space_after_anon_function !== undefined && options.jslint_happy === undefined) {
	        options.jslint_happy = options.space_after_anon_function;
	    }
	    if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
	        opt.brace_style = options.braces_on_own_line ? "expand" : "collapse";
	    }
	    opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : "collapse");

	    // graceful handling of deprecated option
	    if (opt.brace_style === "expand-strict") {
	        opt.brace_style = "expand";
	    }


	    opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
	    opt.indent_char = options.indent_char ? options.indent_char : ' ';
	    opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
	    opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
	    opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
	    opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
	    opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
	    opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
	    opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
	    opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
	    opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
	    opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
	    opt.e4x = (options.e4x === undefined) ? false : options.e4x;

	    if(options.indent_with_tabs){
	        opt.indent_char = '\t';
	        opt.indent_size = 1;
	    }

	    //----------------------------------
	    indent_string = '';
	    while (opt.indent_size > 0) {
	        indent_string += opt.indent_char;
	        opt.indent_size -= 1;
	    }

	    while (js_source_text && (js_source_text.charAt(0) === ' ' || js_source_text.charAt(0) === '\t')) {
	        preindent_string += js_source_text.charAt(0);
	        js_source_text = js_source_text.substring(1);
	    }
	    input = js_source_text;
	    // cache the source's length.
	    input_length = js_source_text.length;

	    last_type = 'TK_START_BLOCK'; // last token type
	    last_last_text = ''; // pre-last token text
	    output_lines = [create_output_line()];
	    output_space_before_token = false;
	    whitespace_before_token = [];

	    // Stack of parsing/formatting states, including MODE.
	    // We tokenize, parse, and output in an almost purely a forward-only stream of token input
	    // and formatted output.  This makes the beautifier less accurate than full parsers
	    // but also far more tolerant of syntax errors.
	    //
	    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
	    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
	    // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
	    // most full parsers would die, but the beautifier gracefully falls back to
	    // MODE.BlockStatement and continues on.
	    flag_store = [];
	    set_mode(MODE.BlockStatement);

	    parser_pos = 0;

	    this.beautify = function() {
	        /*jshint onevar:true */
	        var t, i, keep_whitespace, sweet_code;

	        while (true) {
	            t = get_next_token();
	            token_text = t[0];
	            token_type = t[1];

	            if (token_type === 'TK_EOF') {
	                // Unwind any open statements
	                while (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }
	                break;
	            }

	            keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);
	            input_wanted_newline = n_newlines > 0;

	            if (keep_whitespace) {
	                for (i = 0; i < n_newlines; i += 1) {
	                    print_newline(i > 0);
	                }
	            } else {
	                if (opt.max_preserve_newlines && n_newlines > opt.max_preserve_newlines) {
	                    n_newlines = opt.max_preserve_newlines;
	                }

	                if (opt.preserve_newlines) {
	                    if (n_newlines > 1) {
	                        print_newline();
	                        for (i = 1; i < n_newlines; i += 1) {
	                            print_newline(true);
	                        }
	                    }
	                }
	            }

	            handlers[token_type]();

	            // The cleanest handling of inline comments is to treat them as though they aren't there.
	            // Just continue formatting and the behavior should be logical.
	            // Also ignore unknown tokens.  Again, this should result in better behavior.
	            if (token_type !== 'TK_INLINE_COMMENT' && token_type !== 'TK_COMMENT' &&
	                token_type !== 'TK_BLOCK_COMMENT' && token_type !== 'TK_UNKNOWN') {
	                last_last_text = flags.last_text;
	                last_type = token_type;
	                flags.last_text = token_text;
	            }
	            flags.had_comment = (token_type === 'TK_INLINE_COMMENT' || token_type === 'TK_COMMENT'
	                || token_type === 'TK_BLOCK_COMMENT');
	        }


	        sweet_code = output_lines[0].text.join('');
	        for (var line_index = 1; line_index < output_lines.length; line_index++) {
	            sweet_code += '\n' + output_lines[line_index].text.join('');
	        }
	        sweet_code = sweet_code.replace(/[\r\n ]+$/, '');
	        return sweet_code;
	    };

	    function trim_output(eat_newlines) {
	        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

	        if (output_lines.length) {
	            trim_output_line(output_lines[output_lines.length - 1], eat_newlines);

	            while (eat_newlines && output_lines.length > 1 &&
	                output_lines[output_lines.length - 1].text.length === 0) {
	                output_lines.pop();
	                trim_output_line(output_lines[output_lines.length - 1], eat_newlines);
	            }
	        }
	    }

	    function trim_output_line(line) {
	        while (line.text.length &&
	            (line.text[line.text.length - 1] === ' ' ||
	                line.text[line.text.length - 1] === indent_string ||
	                line.text[line.text.length - 1] === preindent_string)) {
	            line.text.pop();
	        }
	    }

	    function trim(s) {
	        return s.replace(/^\s+|\s+$/g, '');
	    }

	    // we could use just string.split, but
	    // IE doesn't like returning empty strings

	    function split_newlines(s) {
	        //return s.split(/\x0d\x0a|\x0a/);

	        s = s.replace(/\x0d/g, '');
	        var out = [],
	            idx = s.indexOf("\n");
	        while (idx !== -1) {
	            out.push(s.substring(0, idx));
	            s = s.substring(idx + 1);
	            idx = s.indexOf("\n");
	        }
	        if (s.length) {
	            out.push(s);
	        }
	        return out;
	    }

	    function just_added_newline() {
	        var line = output_lines[output_lines.length - 1];
	        return line.text.length === 0;
	    }

	    function just_added_blankline() {
	        if (just_added_newline()) {
	            if (output_lines.length === 1) {
	                return true; // start of the file and newline = blank
	            }

	            var line = output_lines[output_lines.length - 2];
	            return line.text.length === 0;
	        }
	        return false;
	    }

	    function allow_wrap_or_preserved_newline(force_linewrap) {
	        force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;
	        if (opt.wrap_line_length && !force_linewrap) {
	            var line = output_lines[output_lines.length - 1];
	            var proposed_line_length = 0;
	            // never wrap the first token of a line.
	            if (line.text.length > 0) {
	                proposed_line_length = line.text.join('').length + token_text.length +
	                    (output_space_before_token ? 1 : 0);
	                if (proposed_line_length >= opt.wrap_line_length) {
	                    force_linewrap = true;
	                }
	            }
	        }
	        if (((opt.preserve_newlines && input_wanted_newline) || force_linewrap) && !just_added_newline()) {
	            print_newline(false, true);

	        }
	    }

	    function print_newline(force_newline, preserve_statement_flags) {
	        output_space_before_token = false;

	        if (!preserve_statement_flags) {
	            if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
	                while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
	                    restore_mode();
	                }
	            }
	        }

	        if (output_lines.length === 1 && just_added_newline()) {
	            return; // no newline on start of file
	        }

	        if (force_newline || !just_added_newline()) {
	            flags.multiline_frame = true;
	            output_lines.push(create_output_line());
	        }
	    }

	    function print_token_line_indentation() {
	        if (just_added_newline()) {
	            var line = output_lines[output_lines.length - 1];
	            if (opt.keep_array_indentation && is_array(flags.mode) && input_wanted_newline) {
	                // prevent removing of this whitespace as redundant
	                line.text.push('');
	                for (var i = 0; i < whitespace_before_token.length; i += 1) {
	                    line.text.push(whitespace_before_token[i]);
	                }
	            } else {
	                if (preindent_string) {
	                    line.text.push(preindent_string);
	                }

	                print_indent_string(flags.indentation_level);
	            }
	        }
	    }

	    function print_indent_string(level) {
	        // Never indent your first output indent at the start of the file
	        if (output_lines.length > 1) {
	            var line = output_lines[output_lines.length - 1];

	            flags.line_indent_level = level;
	            for (var i = 0; i < level; i += 1) {
	                line.text.push(indent_string);
	            }
	        }
	    }

	    function print_token_space_before() {
	        var line = output_lines[output_lines.length - 1];
	        if (output_space_before_token && line.text.length) {
	            var last_output = line.text[line.text.length - 1];
	            if (last_output !== ' ' && last_output !== indent_string) { // prevent occassional duplicate space
	                line.text.push(' ');
	            }
	        }
	    }

	    function print_token(printable_token) {
	        printable_token = printable_token || token_text;
	        print_token_line_indentation();
	        print_token_space_before();
	        output_space_before_token = false;
	        output_lines[output_lines.length - 1].text.push(printable_token);
	    }

	    function indent() {
	        flags.indentation_level += 1;
	    }

	    function deindent() {
	        if (flags.indentation_level > 0 &&
	            ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))
	            flags.indentation_level -= 1;
	    }

	    function remove_redundant_indentation(frame) {
	        // This implementation is effective but has some issues:
	        //     - less than great performance due to array splicing
	        //     - can cause line wrap to happen too soon due to indent removal
	        //           after wrap points are calculated
	        // These issues are minor compared to ugly indentation.

	        if (frame.multiline_frame) return;

	        // remove one indent from each line inside this section
	        var index = frame.start_line_index;
	        var splice_index = 0;
	        var line;

	        while (index < output_lines.length) {
	            line = output_lines[index];
	            index++;

	            // skip empty lines
	            if (line.text.length === 0) {
	                continue;
	            }

	            // skip the preindent string if present
	            if (preindent_string && line.text[0] === preindent_string) {
	                splice_index = 1;
	            } else {
	                splice_index = 0;
	            }

	            // remove one indent, if present
	            if (line.text[splice_index] === indent_string) {
	                line.text.splice(splice_index, 1);
	            }
	        }
	    }

	    function set_mode(mode) {
	        if (flags) {
	            flag_store.push(flags);
	            previous_flags = flags;
	        } else {
	            previous_flags = create_flags(null, mode);
	        }

	        flags = create_flags(previous_flags, mode);
	    }

	    function is_array(mode) {
	        return mode === MODE.ArrayLiteral;
	    }

	    function is_expression(mode) {
	        return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
	    }

	    function restore_mode() {
	        if (flag_store.length > 0) {
	            previous_flags = flags;
	            flags = flag_store.pop();
	            if (previous_flags.mode === MODE.Statement) {
	                remove_redundant_indentation(previous_flags);
	            }
	        }
	    }

	    function start_of_object_property() {
	        return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && flags.last_text === ':' &&
	            flags.ternary_depth === 0;
	    }

	    function start_of_statement() {
	        if (
	                (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && token_type === 'TK_WORD') ||
	                (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
	                (last_type === 'TK_RESERVED' && flags.last_text === 'return' && !input_wanted_newline) ||
	                (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(token_type === 'TK_RESERVED' && token_text === 'if')) ||
	                (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
	                (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement
	                    && !flags.in_case
	                    && !(token_text === '--' || token_text === '++')
	                    && token_type !== 'TK_WORD' && token_type !== 'TK_RESERVED') ||
	                (flags.mode === MODE.ObjectLiteral && flags.last_text === ':' && flags.ternary_depth === 0)

	            ) {

	            set_mode(MODE.Statement);
	            indent();

	            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && token_type === 'TK_WORD') {
	                flags.declaration_statement = true;
	            }

	            // Issue #276:
	            // If starting a new statement with [if, for, while, do], push to a new line.
	            // if (a) if (b) if(c) d(); else e(); else f();
	            if (!start_of_object_property()) {
	                allow_wrap_or_preserved_newline(
	                    token_type === 'TK_RESERVED' && in_array(token_text, ['do', 'for', 'if', 'while']));
	            }

	            return true;
	        }
	        return false;
	    }

	    function all_lines_start_with(lines, c) {
	        for (var i = 0; i < lines.length; i++) {
	            var line = trim(lines[i]);
	            if (line.charAt(0) !== c) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function each_line_matches_indent(lines, indent) {
	        var i = 0,
	            len = lines.length,
	            line;
	        for (; i < len; i++) {
	            line = lines[i];
	            // allow empty lines to pass through
	            if (line && line.indexOf(indent) !== 0) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function is_special_word(word) {
	        return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
	    }

	    function in_array(what, arr) {
	        for (var i = 0; i < arr.length; i += 1) {
	            if (arr[i] === what) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function unescape_string(s) {
	        var esc = false,
	            out = '',
	            pos = 0,
	            s_hex = '',
	            escaped = 0,
	            c;

	        while (esc || pos < s.length) {

	            c = s.charAt(pos);
	            pos++;

	            if (esc) {
	                esc = false;
	                if (c === 'x') {
	                    // simple hex-escape \x24
	                    s_hex = s.substr(pos, 2);
	                    pos += 2;
	                } else if (c === 'u') {
	                    // unicode-escape, \u2134
	                    s_hex = s.substr(pos, 4);
	                    pos += 4;
	                } else {
	                    // some common escape, e.g \n
	                    out += '\\' + c;
	                    continue;
	                }
	                if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {
	                    // some weird escaping, bail out,
	                    // leaving whole string intact
	                    return s;
	                }

	                escaped = parseInt(s_hex, 16);

	                if (escaped >= 0x00 && escaped < 0x20) {
	                    // leave 0x00...0x1f escaped
	                    if (c === 'x') {
	                        out += '\\x' + s_hex;
	                    } else {
	                        out += '\\u' + s_hex;
	                    }
	                    continue;
	                } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
	                    // single-quote, apostrophe, backslash - escape these
	                    out += '\\' + String.fromCharCode(escaped);
	                } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {
	                    // we bail out on \x7f..\xff,
	                    // leaving whole string escaped,
	                    // as it's probably completely binary
	                    return s;
	                } else {
	                    out += String.fromCharCode(escaped);
	                }
	            } else if (c === '\\') {
	                esc = true;
	            } else {
	                out += c;
	            }
	        }
	        return out;
	    }

	    function is_next(find) {
	        var local_pos = parser_pos;
	        var c = input.charAt(local_pos);
	        while (in_array(c, whitespace) && c !== find) {
	            local_pos++;
	            if (local_pos >= input_length) {
	                return false;
	            }
	            c = input.charAt(local_pos);
	        }
	        return c === find;
	    }

	    function get_next_token() {
	        var i, resulting_string;

	        n_newlines = 0;

	        if (parser_pos >= input_length) {
	            return ['', 'TK_EOF'];
	        }

	        input_wanted_newline = false;
	        whitespace_before_token = [];

	        var c = input.charAt(parser_pos);
	        parser_pos += 1;

	        while (in_array(c, whitespace)) {

	            if (c === '\n') {
	                n_newlines += 1;
	                whitespace_before_token = [];
	            } else if (n_newlines) {
	                if (c === indent_string) {
	                    whitespace_before_token.push(indent_string);
	                } else if (c !== '\r') {
	                    whitespace_before_token.push(' ');
	                }
	            }

	            if (parser_pos >= input_length) {
	                return ['', 'TK_EOF'];
	            }

	            c = input.charAt(parser_pos);
	            parser_pos += 1;
	        }

	        // NOTE: because beautifier doesn't fully parse, it doesn't use acorn.isIdentifierStart.
	        // It just treats all identifiers and numbers and such the same.
	        if (acorn.isIdentifierChar(input.charCodeAt(parser_pos-1))) {
	            if (parser_pos < input_length) {
	                while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {
	                    c += input.charAt(parser_pos);
	                    parser_pos += 1;
	                    if (parser_pos === input_length) {
	                        break;
	                    }
	                }
	            }

	            // small and surprisingly unugly hack for 1E-10 representation
	            if (parser_pos !== input_length && c.match(/^[0-9]+[Ee]$/) && (input.charAt(parser_pos) === '-' || input.charAt(parser_pos) === '+')) {

	                var sign = input.charAt(parser_pos);
	                parser_pos += 1;

	                var t = get_next_token();
	                c += sign + t[0];
	                return [c, 'TK_WORD'];
	            }

	            if (!(last_type === 'TK_DOT' ||
	                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['set', 'get'])))
	                && in_array(c, reserved_words)) {
	                if (c === 'in') { // hack for 'in' operator
	                    return [c, 'TK_OPERATOR'];
	                }
	                return [c, 'TK_RESERVED'];
	            }
	            return [c, 'TK_WORD'];
	        }

	        if (c === '(' || c === '[') {
	            return [c, 'TK_START_EXPR'];
	        }

	        if (c === ')' || c === ']') {
	            return [c, 'TK_END_EXPR'];
	        }

	        if (c === '{') {
	            return [c, 'TK_START_BLOCK'];
	        }

	        if (c === '}') {
	            return [c, 'TK_END_BLOCK'];
	        }

	        if (c === ';') {
	            return [c, 'TK_SEMICOLON'];
	        }

	        if (c === '/') {
	            var comment = '';
	            // peek for comment /* ... */
	            var inline_comment = true;
	            if (input.charAt(parser_pos) === '*') {
	                parser_pos += 1;
	                if (parser_pos < input_length) {
	                    while (parser_pos < input_length && !(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {
	                        c = input.charAt(parser_pos);
	                        comment += c;
	                        if (c === "\n" || c === "\r") {
	                            inline_comment = false;
	                        }
	                        parser_pos += 1;
	                        if (parser_pos >= input_length) {
	                            break;
	                        }
	                    }
	                }
	                parser_pos += 2;
	                if (inline_comment && n_newlines === 0) {
	                    return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];
	                } else {
	                    return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];
	                }
	            }
	            // peek for comment // ...
	            if (input.charAt(parser_pos) === '/') {
	                comment = c;
	                while (input.charAt(parser_pos) !== '\r' && input.charAt(parser_pos) !== '\n') {
	                    comment += input.charAt(parser_pos);
	                    parser_pos += 1;
	                    if (parser_pos >= input_length) {
	                        break;
	                    }
	                }
	                return [comment, 'TK_COMMENT'];
	            }

	        }


	        if (c === '`' || c === "'" || c === '"' || // string
	            (
	                (c === '/') || // regexp
	                (opt.e4x && c === "<" && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*\/?\s*>/)) // xml
	            ) && ( // regex and xml can only appear in specific locations during parsing
	                (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) ||
	                (last_type === 'TK_END_EXPR' && in_array(previous_flags.mode, [MODE.Conditional, MODE.ForInitializer])) ||
	                (in_array(last_type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
	                    'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
	                ]))
	            )) {

	            var sep = c,
	                esc = false,
	                has_char_escapes = false;

	            resulting_string = c;

	            if (parser_pos < input_length) {
	                if (sep === '/') {
	                    //
	                    // handle regexp
	                    //
	                    var in_char_class = false;
	                    while (esc || in_char_class || input.charAt(parser_pos) !== sep) {
	                        resulting_string += input.charAt(parser_pos);
	                        if (!esc) {
	                            esc = input.charAt(parser_pos) === '\\';
	                            if (input.charAt(parser_pos) === '[') {
	                                in_char_class = true;
	                            } else if (input.charAt(parser_pos) === ']') {
	                                in_char_class = false;
	                            }
	                        } else {
	                            esc = false;
	                        }
	                        parser_pos += 1;
	                        if (parser_pos >= input_length) {
	                            // incomplete string/rexp when end-of-file reached.
	                            // bail out with what had been received so far.
	                            return [resulting_string, 'TK_STRING'];
	                        }
	                    }
	                } else if (opt.e4x && sep === '<') {
	                    //
	                    // handle e4x xml literals
	                    //
	                    var xmlRegExp = /<(\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*(\/?)\s*>/g;
	                    var xmlStr = input.slice(parser_pos - 1);
	                    var match = xmlRegExp.exec(xmlStr);
	                    if (match && match.index === 0) {
	                        var rootTag = match[2];
	                        var depth = 0;
	                        while (match) {
	                            var isEndTag = !! match[1];
	                            var tagName = match[2];
	                            var isSingletonTag = ( !! match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
	                            if (tagName === rootTag && !isSingletonTag) {
	                                if (isEndTag) {
	                                    --depth;
	                                } else {
	                                    ++depth;
	                                }
	                            }
	                            if (depth <= 0) {
	                                break;
	                            }
	                            match = xmlRegExp.exec(xmlStr);
	                        }
	                        var xmlLength = match ? match.index + match[0].length : xmlStr.length;
	                        parser_pos += xmlLength - 1;
	                        return [xmlStr.slice(0, xmlLength), "TK_STRING"];
	                    }
	                } else {
	                    //
	                    // handle string
	                    //
	                    while (esc || input.charAt(parser_pos) !== sep) {
	                        resulting_string += input.charAt(parser_pos);
	                        if (esc) {
	                            if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {
	                                has_char_escapes = true;
	                            }
	                            esc = false;
	                        } else {
	                            esc = input.charAt(parser_pos) === '\\';
	                        }
	                        parser_pos += 1;
	                        if (parser_pos >= input_length) {
	                            // incomplete string/rexp when end-of-file reached.
	                            // bail out with what had been received so far.
	                            return [resulting_string, 'TK_STRING'];
	                        }
	                    }

	                }
	            }

	            parser_pos += 1;
	            resulting_string += sep;

	            if (has_char_escapes && opt.unescape_strings) {
	                resulting_string = unescape_string(resulting_string);
	            }

	            if (sep === '/') {
	                // regexps may have modifiers /regexp/MOD , so fetch those, too
	                while (parser_pos < input_length && in_array(input.charAt(parser_pos), wordchar)) {
	                    resulting_string += input.charAt(parser_pos);
	                    parser_pos += 1;
	                }
	            }
	            return [resulting_string, 'TK_STRING'];
	        }

	        if (c === '#') {


	            if (output_lines.length === 1 && output_lines[0].text.length === 0 &&
	                input.charAt(parser_pos) === '!') {
	                // shebang
	                resulting_string = c;
	                while (parser_pos < input_length && c !== '\n') {
	                    c = input.charAt(parser_pos);
	                    resulting_string += c;
	                    parser_pos += 1;
	                }
	                return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
	            }



	            // Spidermonkey-specific sharp variables for circular references
	            // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
	            // http://dxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
	            var sharp = '#';
	            if (parser_pos < input_length && in_array(input.charAt(parser_pos), digits)) {
	                do {
	                    c = input.charAt(parser_pos);
	                    sharp += c;
	                    parser_pos += 1;
	                } while (parser_pos < input_length && c !== '#' && c !== '=');
	                if (c === '#') {
	                    //
	                } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {
	                    sharp += '[]';
	                    parser_pos += 2;
	                } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {
	                    sharp += '{}';
	                    parser_pos += 2;
	                }
	                return [sharp, 'TK_WORD'];
	            }
	        }

	        if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {
	            parser_pos += 3;
	            c = '<!--';
	            while (input.charAt(parser_pos) !== '\n' && parser_pos < input_length) {
	                c += input.charAt(parser_pos);
	                parser_pos++;
	            }
	            flags.in_html_comment = true;
	            return [c, 'TK_COMMENT'];
	        }

	        if (c === '-' && flags.in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {
	            flags.in_html_comment = false;
	            parser_pos += 2;
	            return ['-->', 'TK_COMMENT'];
	        }

	        if (c === '.') {
	            return [c, 'TK_DOT'];
	        }

	        if (in_array(c, punct)) {
	            while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {
	                c += input.charAt(parser_pos);
	                parser_pos += 1;
	                if (parser_pos >= input_length) {
	                    break;
	                }
	            }

	            if (c === ',') {
	                return [c, 'TK_COMMA'];
	            } else if (c === '=') {
	                return [c, 'TK_EQUALS'];
	            } else {
	                return [c, 'TK_OPERATOR'];
	            }
	        }

	        return [c, 'TK_UNKNOWN'];
	    }

	    function handle_start_expr() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        var next_mode = MODE.Expression;
	        if (token_text === '[') {

	            if (last_type === 'TK_WORD' || flags.last_text === ')') {
	                // this is array index specifier, break immediately
	                // a[x], fn()[x]
	                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, line_starters)) {
	                    output_space_before_token = true;
	                }
	                set_mode(next_mode);
	                print_token();
	                indent();
	                if (opt.space_in_paren) {
	                    output_space_before_token = true;
	                }
	                return;
	            }

	            next_mode = MODE.ArrayLiteral;
	            if (is_array(flags.mode)) {
	                if (flags.last_text === '[' ||
	                    (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
	                    // ], [ goes to new line
	                    // }, [ goes to new line
	                    if (!opt.keep_array_indentation) {
	                        print_newline();
	                    }
	                }
	            }

	        } else {
	            if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
	                next_mode = MODE.ForInitializer;
	            } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
	                next_mode = MODE.Conditional;
	            } else {
	                // next_mode = MODE.Expression;
	            }
	        }

	        if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
	            print_newline();
	        } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
	            // TODO: Consider whether forcing this is required.  Review failing tests when removed.
	            allow_wrap_or_preserved_newline(input_wanted_newline);
	            // do nothing on (( and )( and ][ and ]( and .(
	        } else if (!(last_type === 'TK_RESERVED' && token_text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
	            output_space_before_token = true;
	        } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
	            (flags.last_text === '*' && last_last_text === 'function')) {
	            // function() vs function ()
	            if (opt.jslint_happy) {
	                output_space_before_token = true;
	            }
	        } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, line_starters) || flags.last_text === 'catch')) {
	            if (opt.space_before_conditional) {
	                output_space_before_token = true;
	            }
	        }

	        // Support of this kind of newline preservation.
	        // a = (b &&
	        //     (c || d));
	        if (token_text === '(') {
	            if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	                if (!start_of_object_property()) {
	                    allow_wrap_or_preserved_newline();
	                }
	            }
	        }

	        set_mode(next_mode);
	        print_token();
	        if (opt.space_in_paren) {
	            output_space_before_token = true;
	        }

	        // In all cases, if we newline while inside an expression it should be indented.
	        indent();
	    }

	    function handle_end_expr() {
	        // statements inside expressions are not valid syntax, but...
	        // statements must all be closed when their container closes
	        while (flags.mode === MODE.Statement) {
	            restore_mode();
	        }

	        if (flags.multiline_frame) {
	            allow_wrap_or_preserved_newline(token_text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
	        }

	        if (opt.space_in_paren) {
	            if (last_type === 'TK_START_EXPR' && ! opt.space_in_empty_paren) {
	                // () [] no inner space in empty parens like these, ever, ref #320
	                trim_output();
	                output_space_before_token = false;
	            } else {
	                output_space_before_token = true;
	            }
	        }
	        if (token_text === ']' && opt.keep_array_indentation) {
	            print_token();
	            restore_mode();
	        } else {
	            restore_mode();
	            print_token();
	        }
	        remove_redundant_indentation(previous_flags);

	        // do {} while () // no statement required after
	        if (flags.do_while && previous_flags.mode === MODE.Conditional) {
	            previous_flags.mode = MODE.Expression;
	            flags.do_block = false;
	            flags.do_while = false;

	        }
	    }

	    function handle_start_block() {
	        set_mode(MODE.BlockStatement);

	        var empty_braces = is_next('}');
	        var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
	            last_type === 'TK_END_EXPR';

	        if (opt.brace_style === "expand") {
	            if (last_type !== 'TK_OPERATOR' &&
	                (empty_anonymous_function ||
	                    last_type === 'TK_EQUALS' ||
	                    (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
	                output_space_before_token = true;
	            } else {
	                print_newline(false, true);
	            }
	        } else { // collapse
	            if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
	                if (last_type === 'TK_START_BLOCK') {
	                    print_newline();
	                } else {
	                    output_space_before_token = true;
	                }
	            } else {
	                // if TK_OPERATOR or TK_START_EXPR
	                if (is_array(previous_flags.mode) && flags.last_text === ',') {
	                    if (last_last_text === '}') {
	                        // }, { in array context
	                        output_space_before_token = true;
	                    } else {
	                        print_newline(); // [a, b, c, {
	                    }
	                }
	            }
	        }
	        print_token();
	        indent();
	    }

	    function handle_end_block() {
	        // statements must all be closed when their container closes
	        while (flags.mode === MODE.Statement) {
	            restore_mode();
	        }
	        var empty_braces = last_type === 'TK_START_BLOCK';

	        if (opt.brace_style === "expand") {
	            if (!empty_braces) {
	                print_newline();
	            }
	        } else {
	            // skip {}
	            if (!empty_braces) {
	                if (is_array(flags.mode) && opt.keep_array_indentation) {
	                    // we REALLY need a newline here, but newliner would skip that
	                    opt.keep_array_indentation = false;
	                    print_newline();
	                    opt.keep_array_indentation = true;

	                } else {
	                    print_newline();
	                }
	            }
	        }
	        restore_mode();
	        print_token();
	    }

	    function handle_word() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        } else if (input_wanted_newline && !is_expression(flags.mode) &&
	            (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
	            last_type !== 'TK_EQUALS' &&
	            (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {

	            print_newline();
	        }

	        if (flags.do_block && !flags.do_while) {
	            if (token_type === 'TK_RESERVED' && token_text === 'while') {
	                // do {} ## while ()
	                output_space_before_token = true;
	                print_token();
	                output_space_before_token = true;
	                flags.do_while = true;
	                return;
	            } else {
	                // do {} should always have while as the next word.
	                // if we don't see the expected while, recover
	                print_newline();
	                flags.do_block = false;
	            }
	        }

	        // if may be followed by else, or not
	        // Bare/inline ifs are tricky
	        // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
	        if (flags.if_block) {
	            if (!flags.else_block && (token_type === 'TK_RESERVED' && token_text === 'else')) {
	                flags.else_block = true;
	            } else {
	                while (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }
	                flags.if_block = false;
	                flags.else_block = false;
	            }
	        }

	        if (token_type === 'TK_RESERVED' && (token_text === 'case' || (token_text === 'default' && flags.in_case_statement))) {
	            print_newline();
	            if (flags.case_body || opt.jslint_happy) {
	                // switch cases following one another
	                deindent();
	                flags.case_body = false;
	            }
	            print_token();
	            flags.in_case = true;
	            flags.in_case_statement = true;
	            return;
	        }

	        if (token_type === 'TK_RESERVED' && token_text === 'function') {
	            if (in_array(flags.last_text, ['}', ';']) || (just_added_newline() && ! in_array(flags.last_text, ['{', ':', '=', ',']))) {
	                // make sure there is a nice clean space of at least one blank line
	                // before a new function definition
	                if ( ! just_added_blankline() && ! flags.had_comment) {
	                    print_newline();
	                    print_newline(true);
	                }
	            }
	            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
	                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return'])) {
	                    output_space_before_token = true;
	                } else {
	                    print_newline();
	                }
	            } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
	                // foo = function
	                output_space_before_token = true;
	            } else if (is_expression(flags.mode)) {
	                // (function
	            } else {
	                print_newline();
	            }
	        }

	        if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	            if (!start_of_object_property()) {
	                allow_wrap_or_preserved_newline();
	            }
	        }

	        if (token_type === 'TK_RESERVED' && token_text === 'function') {
	            print_token();
	            flags.last_word = token_text;
	            return;
	        }

	        prefix = 'NONE';

	        if (last_type === 'TK_END_BLOCK') {
	            if (!(token_type === 'TK_RESERVED' && in_array(token_text, ['else', 'catch', 'finally']))) {
	                prefix = 'NEWLINE';
	            } else {
	                if (opt.brace_style === "expand" || opt.brace_style === "end-expand") {
	                    prefix = 'NEWLINE';
	                } else {
	                    prefix = 'SPACE';
	                    output_space_before_token = true;
	                }
	            }
	        } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
	            // TODO: Should this be for STATEMENT as well?
	            prefix = 'NEWLINE';
	        } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
	            prefix = 'SPACE';
	        } else if (last_type === 'TK_STRING') {
	            prefix = 'NEWLINE';
	        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
	            (flags.last_text === '*' && last_last_text === 'function')) {
	            prefix = 'SPACE';
	        } else if (last_type === 'TK_START_BLOCK') {
	            prefix = 'NEWLINE';
	        } else if (last_type === 'TK_END_EXPR') {
	            output_space_before_token = true;
	            prefix = 'NEWLINE';
	        }

	        if (token_type === 'TK_RESERVED' && in_array(token_text, line_starters) && flags.last_text !== ')') {
	            if (flags.last_text === 'else') {
	                prefix = 'SPACE';
	            } else {
	                prefix = 'NEWLINE';
	            }

	        }

	        if (token_type === 'TK_RESERVED' && in_array(token_text, ['else', 'catch', 'finally'])) {
	            if (last_type !== 'TK_END_BLOCK' || opt.brace_style === "expand" || opt.brace_style === "end-expand") {
	                print_newline();
	            } else {
	                trim_output(true);
	                var line = output_lines[output_lines.length - 1];
	                // If we trimmed and there's something other than a close block before us
	                // put a newline back in.  Handles '} // comment' scenario.
	                if (line.text[line.text.length - 1] !== '}') {
	                    print_newline();
	                }
	                output_space_before_token = true;
	            }
	        } else if (prefix === 'NEWLINE') {
	            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	                // no newline between 'return nnn'
	                output_space_before_token = true;
	            } else if (last_type !== 'TK_END_EXPR') {
	                if ((last_type !== 'TK_START_EXPR' || !(token_type === 'TK_RESERVED' && in_array(token_text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
	                    // no need to force newline on 'var': for (var x = 0...)
	                    if (token_type === 'TK_RESERVED' && token_text === 'if' && flags.last_word === 'else' && flags.last_text !== '{') {
	                        // no newline for } else if {
	                        output_space_before_token = true;
	                    } else {
	                        print_newline();
	                    }
	                }
	            } else if (token_type === 'TK_RESERVED' && in_array(token_text, line_starters) && flags.last_text !== ')') {
	                print_newline();
	            }
	        } else if (is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
	            print_newline(); // }, in lists get a newline treatment
	        } else if (prefix === 'SPACE') {
	            output_space_before_token = true;
	        }
	        print_token();
	        flags.last_word = token_text;

	        if (token_type === 'TK_RESERVED' && token_text === 'do') {
	            flags.do_block = true;
	        }

	        if (token_type === 'TK_RESERVED' && token_text === 'if') {
	            flags.if_block = true;
	        }
	    }

	    function handle_semicolon() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	            // Semicolon can be the start (and end) of a statement
	            output_space_before_token = false;
	        }
	        while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
	            restore_mode();
	        }
	        print_token();
	        if (flags.mode === MODE.ObjectLiteral) {
	            // if we're in OBJECT mode and see a semicolon, its invalid syntax
	            // recover back to treating this as a BLOCK
	            flags.mode = MODE.BlockStatement;
	        }
	    }

	    function handle_string() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	            // One difference - strings want at least a space before
	            output_space_before_token = true;
	        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
	            output_space_before_token = true;
	        } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	            if (!start_of_object_property()) {
	                allow_wrap_or_preserved_newline();
	            }
	        } else {
	            print_newline();
	        }
	        print_token();
	    }

	    function handle_equals() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        if (flags.declaration_statement) {
	            // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
	            flags.declaration_assignment = true;
	        }
	        output_space_before_token = true;
	        print_token();
	        output_space_before_token = true;
	    }

	    function handle_comma() {
	        if (flags.declaration_statement) {
	            if (is_expression(flags.parent.mode)) {
	                // do not break on comma, for(var a = 1, b = 2)
	                flags.declaration_assignment = false;
	            }

	            print_token();

	            if (flags.declaration_assignment) {
	                flags.declaration_assignment = false;
	                print_newline(false, true);
	            } else {
	                output_space_before_token = true;
	            }
	            return;
	        }

	        print_token();
	        if (flags.mode === MODE.ObjectLiteral ||
	            (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
	            if (flags.mode === MODE.Statement) {
	                restore_mode();
	            }
	            print_newline();
	        } else {
	            // EXPR or DO_BLOCK
	            output_space_before_token = true;
	        }

	    }

	    function handle_operator() {
	        // Check if this is a BlockStatement that should be treated as a ObjectLiteral
	        if (token_text === ':' && flags.mode === MODE.BlockStatement &&
	                last_last_text === '{' &&
	                (last_type === 'TK_WORD' || last_type === 'TK_RESERVED')){
	            flags.mode = MODE.ObjectLiteral;
	        }

	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        var space_before = true;
	        var space_after = true;
	        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	            // "return" had a special handling in TK_WORD. Now we need to return the favor
	            output_space_before_token = true;
	            print_token();
	            return;
	        }

	        // hack for actionscript's import .*;
	        if (token_text === '*' && last_type === 'TK_DOT' && !last_last_text.match(/^\d+$/)) {
	            print_token();
	            return;
	        }

	        if (token_text === ':' && flags.in_case) {
	            flags.case_body = true;
	            indent();
	            print_token();
	            print_newline();
	            flags.in_case = false;
	            return;
	        }

	        if (token_text === '::') {
	            // no spaces around exotic namespacing syntax operator
	            print_token();
	            return;
	        }

	        // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
	        // if there is a newline between -- or ++ and anything else we should preserve it.
	        if (input_wanted_newline && (token_text === '--' || token_text === '++')) {
	            print_newline();
	        }

	        // Allow line wrapping between operators
	        if (last_type === 'TK_OPERATOR') {
	            allow_wrap_or_preserved_newline();
	        }

	        if (in_array(token_text, ['--', '++', '!', '~']) || (in_array(token_text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, line_starters) || flags.last_text === ','))) {
	            // unary operators (and binary +/- pretending to be unary) special cases

	            space_before = false;
	            space_after = false;

	            if (flags.last_text === ';' && is_expression(flags.mode)) {
	                // for (;; ++i)
	                //        ^^^
	                space_before = true;
	            }

	            if (last_type === 'TK_RESERVED') {
	                space_before = true;
	            }

	            if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ';')) {
	                // { foo; --i }
	                // foo(); --bar;
	                print_newline();
	            }
	        } else if (token_text === ':') {
	            if (flags.ternary_depth === 0) {
	                if (flags.mode === MODE.BlockStatement) {
	                    flags.mode = MODE.ObjectLiteral;
	                }
	                space_before = false;
	            } else {
	                flags.ternary_depth -= 1;
	            }
	        } else if (token_text === '?') {
	            flags.ternary_depth += 1;
	        } else if (token_text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {
	            space_before = false;
	            space_after = false;
	        }
	        output_space_before_token = output_space_before_token || space_before;
	        print_token();
	        output_space_before_token = space_after;
	    }

	    function handle_block_comment() {
	        var lines = split_newlines(token_text);
	        var j; // iterator for this case
	        var javadoc = false;
	        var starless = false;
	        var lastIndent = whitespace_before_token.join('');
	        var lastIndentLength = lastIndent.length;

	        // block comment starts with a new line
	        print_newline(false, true);
	        if (lines.length > 1) {
	            if (all_lines_start_with(lines.slice(1), '*')) {
	                javadoc = true;
	            }
	            else if (each_line_matches_indent(lines.slice(1), lastIndent)) {
	                starless = true;
	            }
	        }

	        // first line always indented
	        print_token(lines[0]);
	        for (j = 1; j < lines.length; j++) {
	            print_newline(false, true);
	            if (javadoc) {
	                // javadoc: reformat and re-indent
	                print_token(' ' + trim(lines[j]));
	            } else if (starless && lines[j].length > lastIndentLength) {
	                // starless: re-indent non-empty content, avoiding trim
	                print_token(lines[j].substring(lastIndentLength));
	            } else {
	                // normal comments output raw
	                output_lines[output_lines.length - 1].text.push(lines[j]);
	            }
	        }

	        // for comments of more than one line, make sure there's a new line after
	        print_newline(false, true);
	    }

	    function handle_inline_comment() {
	        output_space_before_token = true;
	        print_token();
	        output_space_before_token = true;
	    }

	    function handle_comment() {
	        if (input_wanted_newline) {
	            print_newline(false, true);
	        } else {
	            trim_output(true);
	        }

	        output_space_before_token = true;
	        print_token();
	        print_newline(false, true);
	    }

	    function handle_dot() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	            output_space_before_token = true;
	        } else {
	            // allow preserved newlines before dots in general
	            // force newlines on dots after close paren when break_chained - for bar().baz()
	            allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
	        }

	        print_token();
	    }

	    function handle_unknown() {
	        print_token();

	        if (token_text[token_text.length - 1] === '\n') {
	            print_newline();
	        }
	    }
	}


/***/ },
/* 189 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * This module contains a small element attribute value parser. It's primary
	 * goal is to extract link information from attribute values (like the href in
	 * <a href="/some/link.html"> for example).
	 *
	 * There are several types of linkable attribute values:
	 * - TYPE_URI: a URI (e.g. <a href="uri">).
	 * - TYPE_URI_LIST: a space separated list of URIs (e.g. <a ping="uri1 uri2">).
	 * - TYPE_IDREF: a reference to an other element in the same document via its id
	 *   (e.g. <label for="input-id"> or <key command="command-id">).
	 * - TYPE_IDREF_LIST: a space separated list of IDREFs (e.g.
	 *   <output for="id1 id2">).
	 * - TYPE_JS_RESOURCE_URI: a URI to a javascript resource that can be opened in
	 *   the devtools (e.g. <script src="uri">).
	 * - TYPE_CSS_RESOURCE_URI: a URI to a css resource that can be opened in the
	 *   devtools (e.g. <link href="uri">).
	 *
	 * parseAttribute is the parser entry function, exported on this module.
	 */

	const TYPE_STRING = "string";
	const TYPE_URI = "uri";
	const TYPE_URI_LIST = "uriList";
	const TYPE_IDREF = "idref";
	const TYPE_IDREF_LIST = "idrefList";
	const TYPE_JS_RESOURCE_URI = "jsresource";
	const TYPE_CSS_RESOURCE_URI = "cssresource";

	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	const HTML_NS = "http://www.w3.org/1999/xhtml";

	/* eslint-disable max-len */
	const ATTRIBUTE_TYPES = [
	  {namespaceURI: HTML_NS, attributeName: "action", tagName: "form", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "background", tagName: "body", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "blockquote", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "q", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "del", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "ins", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "classid", tagName: "object", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "codebase", tagName: "object", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "codebase", tagName: "applet", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "command", tagName: "menuitem", type: TYPE_IDREF},
	  {namespaceURI: "*", attributeName: "contextmenu", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "data", tagName: "object", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "for", tagName: "label", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "for", tagName: "output", type: TYPE_IDREF_LIST},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "button", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "fieldset", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "input", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "keygen", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "label", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "object", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "output", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "select", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "textarea", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "formaction", tagName: "button", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "formaction", tagName: "input", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "headers", tagName: "td", type: TYPE_IDREF_LIST},
	  {namespaceURI: HTML_NS, attributeName: "headers", tagName: "th", type: TYPE_IDREF_LIST},
	  {namespaceURI: HTML_NS, attributeName: "href", tagName: "a", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "href", tagName: "area", type: TYPE_URI},
	  {namespaceURI: "*", attributeName: "href", tagName: "link", type: TYPE_CSS_RESOURCE_URI,
	  /* eslint-enable */
	    isValid: (namespaceURI, tagName, attributes) => {
	      return getAttribute(attributes, "rel") === "stylesheet";
	    }},
	  /* eslint-disable max-len */
	  {namespaceURI: "*", attributeName: "href", tagName: "link", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "href", tagName: "base", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "icon", tagName: "menuitem", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "list", tagName: "input", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "img", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "frame", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "iframe", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "manifest", tagName: "html", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "menu", tagName: "button", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "ping", tagName: "a", type: TYPE_URI_LIST},
	  {namespaceURI: HTML_NS, attributeName: "ping", tagName: "area", type: TYPE_URI_LIST},
	  {namespaceURI: HTML_NS, attributeName: "poster", tagName: "video", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "profile", tagName: "head", type: TYPE_URI},
	  {namespaceURI: "*", attributeName: "src", tagName: "script", type: TYPE_JS_RESOURCE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "input", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "frame", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "iframe", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "img", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "audio", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "embed", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "source", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "track", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "video", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "usemap", tagName: "img", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "usemap", tagName: "input", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "usemap", tagName: "object", type: TYPE_URI},
	  {namespaceURI: "*", attributeName: "xmlns", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "command", tagName: "key", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "containment", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "context", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "datasources", tagName: "*", type: TYPE_URI_LIST},
	  {namespaceURI: XUL_NS, attributeName: "insertafter", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "insertbefore", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "menu", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "observes", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "popup", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "ref", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "removeelement", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "sortResource", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "sortResource2", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "src", tagName: "stringbundle", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "template", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "tooltip", tagName: "*", type: TYPE_IDREF},
	  /* eslint-enable */
	  // SVG links aren't handled yet, see bug 1158831.
	  // {namespaceURI: SVG_NS, attributeName: "fill", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "stroke", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "markerstart", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "markermid", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "markerend", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "xlink:href", tagName: "*", type: }
	];

	var parsers = {
	  [TYPE_URI]: function (attributeValue) {
	    return [{
	      type: TYPE_URI,
	      value: attributeValue
	    }];
	  },
	  [TYPE_URI_LIST]: function (attributeValue) {
	    let data = splitBy(attributeValue, " ");
	    for (let token of data) {
	      if (!token.type) {
	        token.type = TYPE_URI;
	      }
	    }
	    return data;
	  },
	  [TYPE_JS_RESOURCE_URI]: function (attributeValue) {
	    return [{
	      type: TYPE_JS_RESOURCE_URI,
	      value: attributeValue
	    }];
	  },
	  [TYPE_CSS_RESOURCE_URI]: function (attributeValue) {
	    return [{
	      type: TYPE_CSS_RESOURCE_URI,
	      value: attributeValue
	    }];
	  },
	  [TYPE_IDREF]: function (attributeValue) {
	    return [{
	      type: TYPE_IDREF,
	      value: attributeValue
	    }];
	  },
	  [TYPE_IDREF_LIST]: function (attributeValue) {
	    let data = splitBy(attributeValue, " ");
	    for (let token of data) {
	      if (!token.type) {
	        token.type = TYPE_IDREF;
	      }
	    }
	    return data;
	  }
	};

	/**
	 * Parse an attribute value.
	 * @param {String} namespaceURI The namespaceURI of the node that has the
	 * attribute.
	 * @param {String} tagName The tagName of the node that has the attribute.
	 * @param {Array} attributes The list of all attributes of the node. This should
	 * be an array of {name, value} objects.
	 * @param {String} attributeName The name of the attribute to parse.
	 * @return {Array} An array of tokens that represents the value. Each token is
	 * an object {type: [string|uri|jsresource|cssresource|idref], value}.
	 * For instance parsing the ping attribute in <a ping="uri1 uri2"> returns:
	 * [
	 *   {type: "uri", value: "uri2"},
	 *   {type: "string", value: " "},
	 *   {type: "uri", value: "uri1"}
	 * ]
	 */
	function parseAttribute(namespaceURI, tagName, attributes, attributeName) {
	  if (!hasAttribute(attributes, attributeName)) {
	    throw new Error(`Attribute ${attributeName} isn't part of the ` +
	                    "provided attributes");
	  }

	  let type = getType(namespaceURI, tagName, attributes, attributeName);
	  if (!type) {
	    return [{
	      type: TYPE_STRING,
	      value: getAttribute(attributes, attributeName)
	    }];
	  }

	  return parsers[type](getAttribute(attributes, attributeName));
	}

	/**
	 * Get the type for links in this attribute if any.
	 * @param {String} namespaceURI The node's namespaceURI.
	 * @param {String} tagName The node's tagName.
	 * @param {Array} attributes The node's attributes, as a list of {name, value}
	 * objects.
	 * @param {String} attributeName The name of the attribute to get the type for.
	 * @return {Object} null if no type exist for this attribute on this node, the
	 * type object otherwise.
	 */
	function getType(namespaceURI, tagName, attributes, attributeName) {
	  for (let typeData of ATTRIBUTE_TYPES) {
	    let containsAttribute = attributeName === typeData.attributeName ||
	                            typeData.attributeName === "*";
	    let hasNamespace = namespaceURI === typeData.namespaceURI ||
	                       typeData.namespaceURI === "*";
	    let hasTagName = tagName.toLowerCase() === typeData.tagName ||
	                     typeData.tagName === "*";
	    let isValid = typeData.isValid
	                  ? typeData.isValid(namespaceURI,
	                                     tagName,
	                                     attributes,
	                                     attributeName)
	                  : true;

	    if (containsAttribute && hasNamespace && hasTagName && isValid) {
	      return typeData.type;
	    }
	  }

	  return null;
	}

	function getAttribute(attributes, attributeName) {
	  for (let {name, value} of attributes) {
	    if (name === attributeName) {
	      return value;
	    }
	  }
	  return null;
	}

	function hasAttribute(attributes, attributeName) {
	  for (let {name} of attributes) {
	    if (name === attributeName) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Split a string by a given character and return an array of objects parts.
	 * The array will contain objects for the split character too, marked with
	 * TYPE_STRING type.
	 * @param {String} value The string to parse.
	 * @param {String} splitChar A 1 length split character.
	 * @return {Array}
	 */
	function splitBy(value, splitChar) {
	  let data = [], i = 0, buffer = "";
	  while (i <= value.length) {
	    if (i === value.length && buffer) {
	      data.push({value: buffer});
	    }
	    if (value[i] === splitChar) {
	      if (buffer) {
	        data.push({value: buffer});
	      }
	      data.push({
	        type: TYPE_STRING,
	        value: splitChar
	      });
	      buffer = "";
	    } else {
	      buffer += value[i];
	    }

	    i++;
	  }
	  return data;
	}

	exports.parseAttribute = parseAttribute;
	// Exported for testing only.
	exports.splitBy = splitBy;


/***/ },
/* 190 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Scroll the document so that the element "elem" appears in the viewport.
	 *
	 * @param {DOMNode} elem
	 *        The element that needs to appear in the viewport.
	 * @param {Boolean} centered
	 *        true if you want it centered, false if you want it to appear on the
	 *        top of the viewport. It is true by default, and that is usually what
	 *        you want.
	 */
	function scrollIntoViewIfNeeded(elem, centered = true) {
	  let win = elem.ownerDocument.defaultView;
	  let clientRect = elem.getBoundingClientRect();

	  // The following are always from the {top, bottom}
	  // of the viewport, to the {top, …} of the box.
	  // Think of them as geometrical vectors, it helps.
	  // The origin is at the top left.

	  let topToBottom = clientRect.bottom;
	  let bottomToTop = clientRect.top - win.innerHeight;
	  // We allow one translation on the y axis.
	  let yAllowed = true;

	  // Whatever `centered` is, the behavior is the same if the box is
	  // (even partially) visible.
	  if ((topToBottom > 0 || !centered) && topToBottom <= elem.offsetHeight) {
	    win.scrollBy(0, topToBottom - elem.offsetHeight);
	    yAllowed = false;
	  } else if ((bottomToTop < 0 || !centered) &&
	             bottomToTop >= -elem.offsetHeight) {
	    win.scrollBy(0, bottomToTop + elem.offsetHeight);
	    yAllowed = false;
	  }

	  // If we want it centered, and the box is completely hidden,
	  // then we center it explicitly.
	  if (centered) {
	    if (yAllowed && (topToBottom <= 0 || bottomToTop >= 0)) {
	      win.scroll(win.scrollX,
	                 win.scrollY + clientRect.top
	                 - (win.innerHeight - elem.offsetHeight) / 2);
	    }
	  }
	}
	exports.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2012, Mozilla Foundation and contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	"use strict";

	/* globals document */

	/**
	 * For full documentation, see:
	 * https://github.com/mozilla/domtemplate/blob/master/README.md
	 */

	/**
	 * Begin a new templating process.
	 * @param node A DOM element or string referring to an element's id
	 * @param data Data to use in filling out the template
	 * @param options Options to customize the template processing. One of:
	 * - allowEval: boolean (default false) Basic template interpolations are
	 *   either property paths (e.g. ${a.b.c.d}), or if allowEval=true then we
	 *   allow arbitrary JavaScript
	 * - stack: string or array of strings (default empty array) The template
	 *   engine maintains a stack of tasks to help debug where it is. This allows
	 *   this stack to be prefixed with a template name
	 * - blankNullUndefined: By default DOMTemplate exports null and undefined
	 *   values using the strings 'null' and 'undefined', which can be helpful for
	 *   debugging, but can introduce unnecessary extra logic in a template to
	 *   convert null/undefined to ''. By setting blankNullUndefined:true, this
	 *   conversion is handled by DOMTemplate
	 */
	var template = function (node, data, options) {
	  let state = {
	    options: options || {},
	    // We keep a track of the nodes that we've passed through so we can keep
	    // data.__element pointing to the correct node
	    nodes: []
	  };

	  state.stack = state.options.stack;

	  if (!Array.isArray(state.stack)) {
	    if (typeof state.stack === "string") {
	      state.stack = [ options.stack ];
	    } else {
	      state.stack = [];
	    }
	  }

	  processNode(state, node, data);
	};

	if (true) {
	  exports.template = template;
	}
	this.template = template;

	/**
	 * Helper for the places where we need to act asynchronously and keep track of
	 * where we are right now
	 */
	function cloneState(state) {
	  return {
	    options: state.options,
	    stack: state.stack.slice(),
	    nodes: state.nodes.slice()
	  };
	}

	/**
	 * Regex used to find ${...} sections in some text.
	 * Performance note: This regex uses ( and ) to capture the 'script' for
	 * further processing. Not all of the uses of this regex use this feature so
	 * if use of the capturing group is a performance drain then we should split
	 * this regex in two.
	 */
	var TEMPLATE_REGION = /\$\{([^}]*)\}/g;

	/**
	 * Recursive function to walk the tree processing the attributes as it goes.
	 * @param node the node to process. If you pass a string in instead of a DOM
	 * element, it is assumed to be an id for use with document.getElementById()
	 * @param data the data to use for node processing.
	 */
	function processNode(state, node, data) {
	  if (typeof node === "string") {
	    node = document.getElementById(node);
	  }
	  if (data == null) {
	    data = {};
	  }
	  state.stack.push(node.nodeName + (node.id ? "#" + node.id : ""));
	  let pushedNode = false;
	  try {
	    // Process attributes
	    if (node.attributes && node.attributes.length) {
	      // We need to handle 'foreach' and 'if' first because they might stop
	      // some types of processing from happening, and foreach must come first
	      // because it defines new data on which 'if' might depend.
	      if (node.hasAttribute("foreach")) {
	        processForEach(state, node, data);
	        return;
	      }
	      if (node.hasAttribute("if")) {
	        if (!processIf(state, node, data)) {
	          return;
	        }
	      }
	      // Only make the node available once we know it's not going away
	      state.nodes.push(data.__element);
	      data.__element = node;
	      pushedNode = true;
	      // It's good to clean up the attributes when we've processed them,
	      // but if we do it straight away, we mess up the array index
	      let attrs = Array.prototype.slice.call(node.attributes);
	      for (let i = 0; i < attrs.length; i++) {
	        let value = attrs[i].value;
	        let name = attrs[i].name;

	        state.stack.push(name);
	        try {
	          if (name === "save") {
	            // Save attributes are a setter using the node
	            value = stripBraces(state, value);
	            property(state, value, data, node);
	            node.removeAttribute("save");
	          } else if (name.substring(0, 2) === "on") {
	            // If this attribute value contains only an expression
	            if (value.substring(0, 2) === "${" && value.slice(-1) === "}" &&
	                    value.indexOf("${", 2) === -1) {
	              value = stripBraces(state, value);
	              let func = property(state, value, data);
	              if (typeof func === "function") {
	                node.removeAttribute(name);
	                let capture = node.hasAttribute("capture" + name.substring(2));
	                node.addEventListener(name.substring(2), func, capture);
	                if (capture) {
	                  node.removeAttribute("capture" + name.substring(2));
	                }
	              } else {
	                // Attribute value is not a function - use as a DOM-L0 string
	                node.setAttribute(name, func);
	              }
	            } else {
	              // Attribute value is not a single expression use as DOM-L0
	              node.setAttribute(name, processString(state, value, data));
	            }
	          } else {
	            node.removeAttribute(name);
	            // Remove '_' prefix of attribute names so the DOM won't try
	            // to use them before we've processed the template
	            if (name.charAt(0) === "_") {
	              name = name.substring(1);
	            }

	            // Async attributes can only work if the whole attribute is async
	            let replacement;
	            if (value.indexOf("${") === 0 &&
	                value.charAt(value.length - 1) === "}") {
	              replacement = envEval(state, value.slice(2, -1), data, value);
	              if (replacement && typeof replacement.then === "function") {
	                node.setAttribute(name, "");
	                /* jshint loopfunc:true */
	                replacement.then(function (newValue) {
	                  node.setAttribute(name, newValue);
	                }).then(null, console.error);
	              } else {
	                if (state.options.blankNullUndefined && replacement == null) {
	                  replacement = "";
	                }
	                node.setAttribute(name, replacement);
	              }
	            } else {
	              node.setAttribute(name, processString(state, value, data));
	            }
	          }
	        } finally {
	          state.stack.pop();
	        }
	      }
	    }

	    // Loop through our children calling processNode. First clone them, so the
	    // set of nodes that we visit will be unaffected by additions or removals.
	    let childNodes = Array.prototype.slice.call(node.childNodes);
	    for (let j = 0; j < childNodes.length; j++) {
	      processNode(state, childNodes[j], data);
	    }

	    /* 3 === Node.TEXT_NODE */
	    if (node.nodeType === 3) {
	      processTextNode(state, node, data);
	    }
	  } finally {
	    if (pushedNode) {
	      data.__element = state.nodes.pop();
	    }
	    state.stack.pop();
	  }
	}

	/**
	 * Handle attribute values where the output can only be a string
	 */
	function processString(state, value, data) {
	  return value.replace(TEMPLATE_REGION, function (path) {
	    let insert = envEval(state, path.slice(2, -1), data, value);
	    return state.options.blankNullUndefined && insert == null ? "" : insert;
	  });
	}

	/**
	 * Handle <x if="${...}">
	 * @param node An element with an 'if' attribute
	 * @param data The data to use with envEval()
	 * @returns true if processing should continue, false otherwise
	 */
	function processIf(state, node, data) {
	  state.stack.push("if");
	  try {
	    let originalValue = node.getAttribute("if");
	    let value = stripBraces(state, originalValue);
	    let recurse = true;
	    try {
	      let reply = envEval(state, value, data, originalValue);
	      recurse = !!reply;
	    } catch (ex) {
	      handleError(state, "Error with '" + value + "'", ex);
	      recurse = false;
	    }
	    if (!recurse) {
	      node.parentNode.removeChild(node);
	    }
	    node.removeAttribute("if");
	    return recurse;
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Handle <x foreach="param in ${array}"> and the special case of
	 * <loop foreach="param in ${array}">.
	 * This function is responsible for extracting what it has to do from the
	 * attributes, and getting the data to work on (including resolving promises
	 * in getting the array). It delegates to processForEachLoop to actually
	 * unroll the data.
	 * @param node An element with a 'foreach' attribute
	 * @param data The data to use with envEval()
	 */
	function processForEach(state, node, data) {
	  state.stack.push("foreach");
	  try {
	    let originalValue = node.getAttribute("foreach");
	    let value = originalValue;

	    let paramName = "param";
	    if (value.charAt(0) === "$") {
	      // No custom loop variable name. Use the default: 'param'
	      value = stripBraces(state, value);
	    } else {
	      // Extract the loop variable name from 'NAME in ${ARRAY}'
	      let nameArr = value.split(" in ");
	      paramName = nameArr[0].trim();
	      value = stripBraces(state, nameArr[1].trim());
	    }
	    node.removeAttribute("foreach");
	    try {
	      let evaled = envEval(state, value, data, originalValue);
	      let cState = cloneState(state);
	      handleAsync(evaled, node, function (reply, siblingNode) {
	        processForEachLoop(cState, reply, node, siblingNode, data, paramName);
	      });
	      node.parentNode.removeChild(node);
	    } catch (ex) {
	      handleError(state, "Error with " + value + "'", ex);
	    }
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Called by processForEach to handle looping over the data in a foreach loop.
	 * This works with both arrays and objects.
	 * Calls processForEachMember() for each member of 'set'
	 * @param set The object containing the data to loop over
	 * @param templNode The node to copy for each set member
	 * @param sibling The sibling node to which we add things
	 * @param data the data to use for node processing
	 * @param paramName foreach loops have a name for the parameter currently being
	 * processed. The default is 'param'. e.g. <loop foreach="param in ${x}">...
	 */
	function processForEachLoop(state, set, templNode, sibling, data, paramName) {
	  if (Array.isArray(set)) {
	    set.forEach(function (member, i) {
	      processForEachMember(state, member, templNode, sibling,
	                           data, paramName, "" + i);
	    });
	  } else {
	    for (let member in set) {
	      if (set.hasOwnProperty(member)) {
	        processForEachMember(state, member, templNode, sibling,
	                             data, paramName, member);
	      }
	    }
	  }
	}

	/**
	 * Called by processForEachLoop() to resolve any promises in the array (the
	 * array itself can also be a promise, but that is resolved by
	 * processForEach()). Handle <LOOP> elements (which are taken out of the DOM),
	 * clone the template node, and pass the processing on to processNode().
	 * @param member The data item to use in templating
	 * @param templNode The node to copy for each set member
	 * @param siblingNode The parent node to which we add things
	 * @param data the data to use for node processing
	 * @param paramName The name given to 'member' by the foreach attribute
	 * @param frame A name to push on the stack for debugging
	 */
	function processForEachMember(state, member, templNode, siblingNode, data,
	                              paramName, frame) {
	  state.stack.push(frame);
	  try {
	    let cState = cloneState(state);
	    handleAsync(member, siblingNode, function (reply, node) {
	      // Clone data because we can't be sure that we can safely mutate it
	      let newData = Object.create(null);
	      Object.keys(data).forEach(function (key) {
	        newData[key] = data[key];
	      });
	      newData[paramName] = reply;
	      if (node.parentNode != null) {
	        let clone;
	        if (templNode.nodeName.toLowerCase() === "loop") {
	          for (let i = 0; i < templNode.childNodes.length; i++) {
	            clone = templNode.childNodes[i].cloneNode(true);
	            node.parentNode.insertBefore(clone, node);
	            processNode(cState, clone, newData);
	          }
	        } else {
	          clone = templNode.cloneNode(true);
	          clone.removeAttribute("foreach");
	          node.parentNode.insertBefore(clone, node);
	          processNode(cState, clone, newData);
	        }
	      }
	    });
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Take a text node and replace it with another text node with the ${...}
	 * sections parsed out. We replace the node by altering node.parentNode but
	 * we could probably use a DOM Text API to achieve the same thing.
	 * @param node The Text node to work on
	 * @param data The data to use in calls to envEval()
	 */
	function processTextNode(state, node, data) {
	  // Replace references in other attributes
	  let value = node.data;
	  // We can't use the string.replace() with function trick (see generic
	  // attribute processing in processNode()) because we need to support
	  // functions that return DOM nodes, so we can't have the conversion to a
	  // string.
	  // Instead we process the string as an array of parts. In order to split
	  // the string up, we first replace '${' with '\uF001$' and '}' with '\uF002'
	  // We can then split using \uF001 or \uF002 to get an array of strings
	  // where scripts are prefixed with $.
	  // \uF001 and \uF002 are just unicode chars reserved for private use.
	  value = value.replace(TEMPLATE_REGION, "\uF001$$$1\uF002");
	  // Split a string using the unicode chars F001 and F002.
	  let parts = value.split(/\uF001|\uF002/);
	  if (parts.length > 1) {
	    parts.forEach(function (part) {
	      if (part === null || part === undefined || part === "") {
	        return;
	      }
	      if (part.charAt(0) === "$") {
	        part = envEval(state, part.slice(1), data, node.data);
	      }
	      let cState = cloneState(state);
	      handleAsync(part, node, function (reply, siblingNode) {
	        let doc = siblingNode.ownerDocument;
	        if (reply == null) {
	          reply = cState.options.blankNullUndefined ? "" : "" + reply;
	        }
	        if (typeof reply.cloneNode === "function") {
	          // i.e. if (reply instanceof Element) { ...
	          reply = maybeImportNode(cState, reply, doc);
	          siblingNode.parentNode.insertBefore(reply, siblingNode);
	        } else if (typeof reply.item === "function" && reply.length) {
	          // NodeLists can be live, in which case maybeImportNode can
	          // remove them from the document, and thus the NodeList, which in
	          // turn breaks iteration. So first we clone the list
	          let list = Array.prototype.slice.call(reply, 0);
	          list.forEach(function (child) {
	            let imported = maybeImportNode(cState, child, doc);
	            siblingNode.parentNode.insertBefore(imported, siblingNode);
	          });
	        } else {
	          // if thing isn't a DOM element then wrap its string value in one
	          reply = doc.createTextNode(reply.toString());
	          siblingNode.parentNode.insertBefore(reply, siblingNode);
	        }
	      });
	    });
	    node.parentNode.removeChild(node);
	  }
	}

	/**
	 * Return node or a import of node, if it's not in the given document
	 * @param node The node that we want to be properly owned
	 * @param doc The document that the given node should belong to
	 * @return A node that belongs to the given document
	 */
	function maybeImportNode(state, node, doc) {
	  return node.ownerDocument === doc ? node : doc.importNode(node, true);
	}

	/**
	 * A function to handle the fact that some nodes can be promises, so we check
	 * and resolve if needed using a marker node to keep our place before calling
	 * an inserter function.
	 * @param thing The object which could be real data or a promise of real data
	 * we use it directly if it's not a promise, or resolve it if it is.
	 * @param siblingNode The element before which we insert new elements.
	 * @param inserter The function to to the insertion. If thing is not a promise
	 * then handleAsync() is just 'inserter(thing, siblingNode)'
	 */
	function handleAsync(thing, siblingNode, inserter) {
	  if (thing != null && typeof thing.then === "function") {
	    // Placeholder element to be replaced once we have the real data
	    let tempNode = siblingNode.ownerDocument.createElement("span");
	    siblingNode.parentNode.insertBefore(tempNode, siblingNode);
	    thing.then(function (delayed) {
	      inserter(delayed, tempNode);
	      if (tempNode.parentNode != null) {
	        tempNode.parentNode.removeChild(tempNode);
	      }
	    }).then(null, function (error) {
	      console.error(error.stack);
	    });
	  } else {
	    inserter(thing, siblingNode);
	  }
	}

	/**
	 * Warn of string does not begin '${' and end '}'
	 * @param str the string to check.
	 * @return The string stripped of ${ and }, or untouched if it does not match
	 */
	function stripBraces(state, str) {
	  if (!str.match(TEMPLATE_REGION)) {
	    handleError(state, "Expected " + str + " to match ${...}");
	    return str;
	  }
	  return str.slice(2, -1);
	}

	/**
	 * Combined getter and setter that works with a path through some data set.
	 * For example:
	 * <ul>
	 * <li>property(state, 'a.b', { a: { b: 99 }}); // returns 99
	 * <li>property(state, 'a', { a: { b: 99 }}); // returns { b: 99 }
	 * <li>property(state, 'a', { a: { b: 99 }}, 42); // returns 99 and alters the
	 * input data to be { a: { b: 42 }}
	 * </ul>
	 * @param path An array of strings indicating the path through the data, or
	 * a string to be cut into an array using <tt>split('.')</tt>
	 * @param data the data to use for node processing
	 * @param newValue (optional) If defined, this value will replace the
	 * original value for the data at the path specified.
	 * @return The value pointed to by <tt>path</tt> before any
	 * <tt>newValue</tt> is applied.
	 */
	function property(state, path, data, newValue) {
	  try {
	    if (typeof path === "string") {
	      path = path.split(".");
	    }
	    let value = data[path[0]];
	    if (path.length === 1) {
	      if (newValue !== undefined) {
	        data[path[0]] = newValue;
	      }
	      if (typeof value === "function") {
	        return value.bind(data);
	      }
	      return value;
	    }
	    if (!value) {
	      handleError(state, "\"" + path[0] + "\" is undefined");
	      return null;
	    }
	    return property(state, path.slice(1), value, newValue);
	  } catch (ex) {
	    handleError(state, "Path error with '" + path + "'", ex);
	    return "${" + path + "}";
	  }
	}

	/**
	 * Like eval, but that creates a context of the variables in <tt>env</tt> in
	 * which the script is evaluated.
	 * @param script The string to be evaluated.
	 * @param data The environment in which to eval the script.
	 * @param frame Optional debugging string in case of failure.
	 * @return The return value of the script, or the error message if the script
	 * execution failed.
	 */
	function envEval(state, script, data, frame) {
	  try {
	    state.stack.push(frame.replace(/\s+/g, " "));
	    // Detect if a script is capable of being interpreted using property()
	    if (/^[_a-zA-Z0-9.]*$/.test(script)) {
	      return property(state, script, data);
	    }
	    if (!state.options.allowEval) {
	      handleError(state, "allowEval is not set, however '" + script + "'" +
	                  " can not be resolved using a simple property path.");
	      return "${" + script + "}";
	    }

	    // What we're looking to do is basically:
	    //   with(data) { return eval(script); }
	    // except in strict mode where 'with' is banned.
	    // So we create a function which has a parameter list the same as the
	    // keys in 'data' and with 'script' as its function body.
	    // We then call this function with the values in 'data'
	    let keys = allKeys(data);
	    let func = Function.apply(null, keys.concat("return " + script));

	    let values = keys.map((key) => data[key]);
	    return func.apply(null, values);

	    // TODO: The 'with' method is different from the code above in the value
	    // of 'this' when calling functions. For example:
	    //   envEval(state, 'foo()', { foo: function () { return this; } }, ...);
	    // The global for 'foo' when using 'with' is the data object. However the
	    // code above, the global is null. (Using 'func.apply(data, values)'
	    // changes 'this' in the 'foo()' frame, but not in the inside the body
	    // of 'foo', so that wouldn't help)
	  } catch (ex) {
	    handleError(state, "Template error evaluating '" + script + "'", ex);
	    return "${" + script + "}";
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Object.keys() that respects the prototype chain
	 */
	function allKeys(data) {
	  let keys = [];
	  for (let key in data) {
	    keys.push(key);
	  }
	  return keys;
	}

	/**
	 * A generic way of reporting errors, for easy overloading in different
	 * environments.
	 * @param message the error message to report.
	 * @param ex optional associated exception.
	 */
	function handleError(state, message, ex) {
	  logError(message + " (In: " + state.stack.join(" > ") + ")");
	  if (ex) {
	    logError(ex);
	  }
	}

	/**
	 * A generic way of reporting errors, for easy overloading in different
	 * environments.
	 * @param message the error message to report.
	 */
	function logError(message) {
	  console.error(message);
	}

	exports.template = template;


/***/ },
/* 192 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  FILTER_ACCEPT: 1,
	  FILTER_REJECT: 2,
	  FILTER_SKIP: 3,

	  SHOW_ALL: 0xFFFFFFFF,
	  SHOW_ELEMENT: 0x00000001,
	  SHOW_ATTRIBUTE: 0x00000002,
	  SHOW_TEXT: 0x00000004,
	  SHOW_CDATA_SECTION: 0x00000008,
	  SHOW_ENTITY_REFERENCE: 0x00000010,
	  SHOW_ENTITY: 0x00000020,
	  SHOW_PROCESSING_INSTRUCTION: 0x00000040,
	  SHOW_COMMENT: 0x00000080,
	  SHOW_DOCUMENT: 0x00000100,
	  SHOW_DOCUMENT_TYPE: 0x00000200,
	  SHOW_DOCUMENT_FRAGMENT: 0x00000400,
	  SHOW_NOTATION: 0x00000800
	};


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/*
	 * The code below is mostly is a slight modification of intl/locale/PluralForm.jsm that
	 * removes dependencies on chrome privileged APIs. To make maintenance easier, this file
	 * is kept as close as possible to the original in terms of implementation.
	 * The modified methods here are
	 * - makeGetter (remove code adding the caller name to the log)
	 * - get ruleNum() (rely on LocalizationHelper instead of String.services)
	 * - log() (rely on console.log)
	 *
	 * Disable eslint warnings to preserve original code style.
	 */

	/* eslint-disable */

	/**
	 * This module provides the PluralForm object which contains a method to figure
	 * out which plural form of a word to use for a given number based on the
	 * current localization. There is also a makeGetter method that creates a get
	 * function for the desired plural rule. This is useful for extensions that
	 * specify their own plural rule instead of relying on the browser default.
	 * (I.e., the extension hasn't been localized to the browser's locale.)
	 *
	 * See: http://developer.mozilla.org/en/docs/Localization_and_Plurals
	 *
	 * List of methods:
	 *
	 * string pluralForm
	 * get(int aNum, string aWords)
	 *
	 * int numForms
	 * numForms()
	 *
	 * [string pluralForm get(int aNum, string aWords), int numForms numForms()]
	 * makeGetter(int aRuleNum)
	 * Note: Basically, makeGetter returns 2 functions that do "get" and "numForm"
	 */

	const {LocalizationHelper} = __webpack_require__(39);
	const L10N = new LocalizationHelper("global/locale/intl.properties");

	// These are the available plural functions that give the appropriate index
	// based on the plural rule number specified. The first element is the number
	// of plural forms and the second is the function to figure out the index.
	var gFunctions = [
	  // 0: Chinese
	  [1, (n) => 0],
	  // 1: English
	  [2, (n) => n!=1?1:0],
	  // 2: French
	  [2, (n) => n>1?1:0],
	  // 3: Latvian
	  [3, (n) => n%10==1&&n%100!=11?1:n!=0?2:0],
	  // 4: Scottish Gaelic
	  [4, (n) => n==1||n==11?0:n==2||n==12?1:n>0&&n<20?2:3],
	  // 5: Romanian
	  [3, (n) => n==1?0:n==0||n%100>0&&n%100<20?1:2],
	  // 6: Lithuanian
	  [3, (n) => n%10==1&&n%100!=11?0:n%10>=2&&(n%100<10||n%100>=20)?2:1],
	  // 7: Russian
	  [3, (n) => n%10==1&&n%100!=11?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2],
	  // 8: Slovak
	  [3, (n) => n==1?0:n>=2&&n<=4?1:2],
	  // 9: Polish
	  [3, (n) => n==1?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2],
	  // 10: Slovenian
	  [4, (n) => n%100==1?0:n%100==2?1:n%100==3||n%100==4?2:3],
	  // 11: Irish Gaeilge
	  [5, (n) => n==1?0:n==2?1:n>=3&&n<=6?2:n>=7&&n<=10?3:4],
	  // 12: Arabic
	  [6, (n) => n==0?5:n==1?0:n==2?1:n%100>=3&&n%100<=10?2:n%100>=11&&n%100<=99?3:4],
	  // 13: Maltese
	  [4, (n) => n==1?0:n==0||n%100>0&&n%100<=10?1:n%100>10&&n%100<20?2:3],
	  // 14: Macedonian
	  [3, (n) => n%10==1?0:n%10==2?1:2],
	  // 15: Icelandic
	  [2, (n) => n%10==1&&n%100!=11?0:1],
	  // 16: Breton
	  [5, (n) => n%10==1&&n%100!=11&&n%100!=71&&n%100!=91?0:n%10==2&&n%100!=12&&n%100!=72&&n%100!=92?1:(n%10==3||n%10==4||n%10==9)&&n%100!=13&&n%100!=14&&n%100!=19&&n%100!=73&&n%100!=74&&n%100!=79&&n%100!=93&&n%100!=94&&n%100!=99?2:n%1000000==0&&n!=0?3:4],
	];

	this.PluralForm = {
	  /**
	   * Get the correct plural form of a word based on the number
	   *
	   * @param aNum
	   *        The number to decide which plural form to use
	   * @param aWords
	   *        A semi-colon (;) separated string of words to pick the plural form
	   * @return The appropriate plural form of the word
	   */
	  get get()
	  {
	    // This method will lazily load to avoid perf when it is first needed and
	    // creates getPluralForm function. The function it creates is based on the
	    // value of pluralRule specified in the intl stringbundle.
	    // See: http://developer.mozilla.org/en/docs/Localization_and_Plurals

	    // Delete the getters to be overwritten
	    delete PluralForm.numForms;
	    delete PluralForm.get;

	    // Make the plural form get function and set it as the default get
	    [PluralForm.get, PluralForm.numForms] = PluralForm.makeGetter(PluralForm.ruleNum);
	    return PluralForm.get;
	  },

	  /**
	   * Create a pair of plural form functions for the given plural rule number.
	   *
	   * @param aRuleNum
	   *        The plural rule number to create functions
	   * @return A pair: [function that gets the right plural form,
	   *                  function that returns the number of plural forms]
	   */
	  makeGetter: function(aRuleNum)
	  {
	    // Default to "all plural" if the value is out of bounds or invalid
	    if (aRuleNum < 0 || aRuleNum >= gFunctions.length || isNaN(aRuleNum)) {
	      log(["Invalid rule number: ", aRuleNum, " -- defaulting to 0"]);
	      aRuleNum = 0;
	    }

	    // Get the desired pluralRule function
	    let [numForms, pluralFunc] = gFunctions[aRuleNum];

	    // Return functions that give 1) the number of forms and 2) gets the right
	    // plural form
	    return [function(aNum, aWords) {
	      // Figure out which index to use for the semi-colon separated words
	      let index = pluralFunc(aNum ? Number(aNum) : 0);
	      let words = aWords ? aWords.split(/;/) : [""];

	      // Explicitly check bounds to avoid strict warnings
	      let ret = index < words.length ? words[index] : undefined;

	      // Check for array out of bounds or empty strings
	      if ((ret == undefined) || (ret == "")) {
	        // Display a message in the error console
	        log(["Index #", index, " of '", aWords, "' for value ", aNum,
	            " is invalid -- plural rule #", aRuleNum, ";"]);

	        // Default to the first entry (which might be empty, but not undefined)
	        ret = words[0];
	      }

	      return ret;
	    }, () => numForms];
	  },

	  /**
	   * Get the number of forms for the current plural rule
	   *
	   * @return The number of forms
	   */
	  get numForms()
	  {
	    // We lazily load numForms, so trigger the init logic with get()
	    PluralForm.get();
	    return PluralForm.numForms;
	  },

	  /**
	   * Get the plural rule number from the intl stringbundle
	   *
	   * @return The plural rule number
	   */
	  get ruleNum()
	  {
	    try {
	      return parseInt(L10N.getStr("pluralRule"), 10);
	    } catch (e) {
	      // Fallback to English if the pluralRule property is not available.
	      return 1;
	    }
	  }
	};

	/**
	 * Private helper function to log errors to the error console and command line
	 *
	 * @param aMsg
	 *        Error message to log or an array of strings to concat
	 */
	function log(aMsg)
	{
	  let msg = "plural-form.js: " + (aMsg.join ? aMsg.join("") : aMsg);
	  console.log(msg + "\n");
	}

	exports.PluralForm = this.PluralForm;

	/* eslint-ensable */


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var EventEmitter = __webpack_require__(6);
	var Telemetry = __webpack_require__(34);
	var { Task } = __webpack_require__(17);

	/**
	 * This object represents replacement for ToolSidebar
	 * implemented in devtools/client/framework/sidebar.js module
	 *
	 * This new component is part of devtools.html aimed at
	 * removing XUL and use HTML for entire DevTools UI.
	 * There are currently two implementation of the side bar since
	 * the `sidebar.js` module (mentioned above) is still used by
	 * other panels.
	 * As soon as all panels are using this HTML based
	 * implementation it can be removed.
	 */
	function ToolSidebar(tabbox, panel, uid, options = {}) {
	  EventEmitter.decorate(this);

	  this._tabbox = tabbox;
	  this._uid = uid;
	  this._panelDoc = this._tabbox.ownerDocument;
	  this._toolPanel = panel;
	  this._options = options;

	  if (!options.disableTelemetry) {
	    this._telemetry = new Telemetry();
	  }

	  this._tabs = [];

	  if (this._options.hideTabstripe) {
	    this._tabbox.setAttribute("hidetabs", "true");
	  }

	  this.render();

	  this._toolPanel.emit("sidebar-created", this);
	}

	exports.ToolSidebar = ToolSidebar;

	ToolSidebar.prototype = {
	  TABPANEL_ID_PREFIX: "sidebar-panel-",

	  // React

	  get React() {
	    return this._toolPanel.React;
	  },

	  get ReactDOM() {
	    return this._toolPanel.ReactDOM;
	  },

	  get browserRequire() {
	    return this._toolPanel.browserRequire;
	  },

	  get InspectorTabPanel() {
	    if (!this._InspectorTabPanel) {
	      this._InspectorTabPanel =
	        this.React.createFactory(__webpack_require__(
	        195));
	    }
	    return this._InspectorTabPanel;
	  },

	  // Rendering

	  render: function () {
	    let Tabbar = this.React.createFactory(__webpack_require__(
	      198));

	    let sidebar = Tabbar({
	      toolbox: this._toolPanel._toolbox,
	      showAllTabsMenu: true,
	      onSelect: this.handleSelectionChange.bind(this),
	    });

	    this._tabbar = this.ReactDOM.render(sidebar, this._tabbox);
	  },

	  addExistingTab: function (id, title, selected) {
	    this._tabbar.addTab(id, title, selected, this.InspectorTabPanel);

	    this.emit("new-tab-registered", id);
	  },

	  /**
	   * Register a tab. A tab is a document.
	   * The document must have a title, which will be used as the name of the tab.
	   *
	   * @param {string} tab uniq id
	   * @param {string} url
	   */
	  addFrameTab: function (id, title, url, selected) {
	    let panel = this.InspectorTabPanel({
	      id: id,
	      key: id,
	      title: title,
	      url: url,
	      onMount: this.onSidePanelMounted.bind(this),
	    });

	    this._tabbar.addTab(id, title, selected, panel);

	    this.emit("new-tab-registered", id);
	  },

	  onSidePanelMounted: function (content, props) {
	    let iframe = content.querySelector("iframe");
	    if (!iframe || iframe.getAttribute("src")) {
	      return;
	    }

	    let onIFrameLoaded = (event) => {
	      iframe.removeEventListener("load", onIFrameLoaded, true);

	      let doc = event.target;
	      let win = doc.defaultView;
	      if ("setPanel" in win) {
	        win.setPanel(this._toolPanel, iframe);
	      }
	      this.emit(props.id + "-ready");
	    };

	    iframe.addEventListener("load", onIFrameLoaded, true);
	    iframe.setAttribute("src", props.url);
	  },

	  /**
	   * Remove an existing tab.
	   * @param {String} tabId The ID of the tab that was used to register it, or
	   * the tab id attribute value if the tab existed before the sidebar
	   * got created.
	   * @param {String} tabPanelId Optional. If provided, this ID will be used
	   * instead of the tabId to retrieve and remove the corresponding <tabpanel>
	   */
	  removeTab: Task.async(function* (tabId, tabPanelId) {
	    this._tabbar.removeTab(tabId);

	    let win = this.getWindowForTab(tabId);
	    if (win && ("destroy" in win)) {
	      yield win.destroy();
	    }

	    this.emit("tab-unregistered", tabId);
	  }),

	  /**
	   * Show or hide a specific tab.
	   * @param {Boolean} isVisible True to show the tab/tabpanel, False to hide it.
	   * @param {String} id The ID of the tab to be hidden.
	   */
	  toggleTab: function (isVisible, id) {
	    this._tabbar.toggleTab(id, isVisible);
	  },

	  /**
	   * Select a specific tab.
	   */
	  select: function (id) {
	    this._tabbar.select(id);
	  },

	  /**
	   * Return the id of the selected tab.
	   */
	  getCurrentTabID: function () {
	    return this._currentTool;
	  },

	  /**
	   * Returns the requested tab panel based on the id.
	   * @param {String} id
	   * @return {DOMNode}
	   */
	  getTabPanel: function (id) {
	    // Search with and without the ID prefix as there might have been existing
	    // tabpanels by the time the sidebar got created
	    return this._panelDoc.querySelector("#" +
	      this.TABPANEL_ID_PREFIX + id + ", #" + id);
	  },

	  /**
	   * Event handler.
	   */
	  handleSelectionChange: function (id) {
	    if (this._destroyed) {
	      return;
	    }

	    let previousTool = this._currentTool;
	    if (previousTool) {
	      if (this._telemetry) {
	        this._telemetry.toolClosed(previousTool);
	      }
	      this.emit(previousTool + "-unselected");
	    }

	    this._currentTool = id;

	    if (this._telemetry) {
	      this._telemetry.toolOpened(this._currentTool);
	    }

	    this.emit(this._currentTool + "-selected");
	    this.emit("select", this._currentTool);
	  },

	  /**
	   * Show the sidebar.
	   *
	   * @param  {String} id
	   *         The sidebar tab id to select.
	   */
	  show: function (id) {
	    this._tabbox.removeAttribute("hidden");

	    // If an id is given, select the corresponding sidebar tab and record the
	    // tool opened.
	    if (id) {
	      this._currentTool = id;

	      if (this._telemetry) {
	        this._telemetry.toolOpened(this._currentTool);
	      }
	    }

	    this.emit("show");
	  },

	  /**
	   * Show the sidebar.
	   */
	  hide: function () {
	    this._tabbox.setAttribute("hidden", "true");

	    this.emit("hide");
	  },

	  /**
	   * Return the window containing the tab content.
	   */
	  getWindowForTab: function (id) {
	    // Get the tabpanel and make sure it contains an iframe
	    let panel = this.getTabPanel(id);
	    if (!panel || !panel.firstElementChild || !panel.firstElementChild.contentWindow) {
	      return null;
	    }

	    return panel.firstElementChild.contentWindow;
	  },

	  /**
	   * Clean-up.
	   */
	  destroy: Task.async(function* () {
	    if (this._destroyed) {
	      return;
	    }
	    this._destroyed = true;

	    this.emit("destroy");

	    // Note that we check for the existence of this._tabbox.tabpanels at each
	    // step as the container window may have been closed by the time one of the
	    // panel's destroy promise resolves.
	    let tabpanels = [...this._tabbox.querySelectorAll(".tab-panel-box")];
	    for (let panel of tabpanels) {
	      let iframe = panel.querySelector("iframe");
	      if (!iframe) {
	        continue;
	      }
	      let win = iframe.contentWindow;
	      if (win && ("destroy" in win)) {
	        yield win.destroy();
	      }
	      panel.remove();
	    }

	    if (this._currentTool && this._telemetry) {
	      this._telemetry.toolClosed(this._currentTool);
	    }

	    this._toolPanel.emit("sidebar-destroyed", this);

	    this._tabs = null;
	    this._tabbox = null;
	    this._panelDoc = null;
	    this._toolPanel = null;
	  })
	};


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const { DOM, createClass, PropTypes } = __webpack_require__(196);

	// Shortcuts
	const { div } = DOM;

	/**
	 * Side panel for the Inspector panel.
	 * This side panel is using an existing DOM node as a content.
	 */
	var InspectorTabPanel = createClass({
	  displayName: "InspectorTabPanel",

	  propTypes: {
	    onMount: PropTypes.func,
	  },

	  componentDidMount: function () {
	    let doc = this.refs.content.ownerDocument;
	    let panel = doc.getElementById("sidebar-panel-" + this.props.id);

	    // Append existing DOM node into panel's content.
	    this.refs.content.appendChild(panel);

	    if (this.props.onMount) {
	      this.props.onMount(this.refs.content, this.props);
	    }
	  },

	  componentWillUnmount: function () {
	    let doc = this.refs.content.ownerDocument;
	    let panels = doc.getElementById("tabpanels");

	    // Move panel's content node back into list of tab panels.
	    panels.appendChild(this.refs.content.firstChild);
	  },

	  render: function () {
	    return (
	      div({
	        ref: "content",
	        className: "devtools-inspector-tab-panel",
	      })
	    );
	  }
	});

	module.exports = InspectorTabPanel;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require; /**
	  * React (with addons) v0.14.6
	  */
	(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.React = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactWithAddons
	 */

	/**
	 * This module exists purely in the open source project, and is meant as a way
	 * to create a separate standalone build of React. This build has "addons", or
	 * functionality we've built and think might be useful but doesn't have a good
	 * place to live inside React core.
	 */

	'use strict';

	var LinkedStateMixin = _dereq_(22);
	var React = _dereq_(26);
	var ReactComponentWithPureRenderMixin = _dereq_(37);
	var ReactCSSTransitionGroup = _dereq_(29);
	var ReactFragment = _dereq_(64);
	var ReactTransitionGroup = _dereq_(94);
	var ReactUpdates = _dereq_(96);

	var cloneWithProps = _dereq_(118);
	var shallowCompare = _dereq_(140);
	var update = _dereq_(143);
	var warning = _dereq_(173);

	var warnedAboutBatchedUpdates = false;

	React.addons = {
	  CSSTransitionGroup: ReactCSSTransitionGroup,
	  LinkedStateMixin: LinkedStateMixin,
	  PureRenderMixin: ReactComponentWithPureRenderMixin,
	  TransitionGroup: ReactTransitionGroup,

	  batchedUpdates: function () {
	    if (false) {
	      "production" !== 'production' ? warning(warnedAboutBatchedUpdates, 'React.addons.batchedUpdates is deprecated. Use ' + 'ReactDOM.unstable_batchedUpdates instead.') : undefined;
	      warnedAboutBatchedUpdates = true;
	    }
	    return ReactUpdates.batchedUpdates.apply(this, arguments);
	  },
	  cloneWithProps: cloneWithProps,
	  createFragment: ReactFragment.create,
	  shallowCompare: shallowCompare,
	  update: update
	};

	React.addons.TestUtils = _dereq_(91);

	if (false) {
	  React.addons.Perf = _dereq_(55);
	}

	module.exports = React;
	},{"118":118,"140":140,"143":143,"173":173,"22":22,"26":26,"29":29,"37":37,"55":55,"64":64,"91":91,"94":94,"96":96}],2:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */

	'use strict';

	var ReactMount = _dereq_(72);

	var findDOMNode = _dereq_(122);
	var focusNode = _dereq_(155);

	var Mixin = {
	  componentDidMount: function () {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};

	var AutoFocusUtils = {
	  Mixin: Mixin,

	  focusDOMComponent: function () {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};

	module.exports = AutoFocusUtils;
	},{"122":122,"155":155,"72":72}],3:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */

	'use strict';

	var EventConstants = _dereq_(15);
	var EventPropagators = _dereq_(19);
	var ExecutionEnvironment = _dereq_(147);
	var FallbackCompositionState = _dereq_(20);
	var SyntheticCompositionEvent = _dereq_(103);
	var SyntheticInputEvent = _dereq_(107);

	var keyOf = _dereq_(166);

	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;

	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}

	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}

	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

	var topLevelTypes = EventConstants.topLevelTypes;

	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};

	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;

	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}

	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}

	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}

	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}

	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if (typeof detail === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}

	// Track the current IME composition fallback object, if any.
	var currentComposition = null;

	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;

	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }

	  if (!eventType) {
	    return null;
	  }

	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }

	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);

	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }

	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }

	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;

	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;

	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }

	      return chars;

	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}

	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }

	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}

	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;

	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }

	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }

	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);

	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}

	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};

	module.exports = BeforeInputEventPlugin;
	},{"103":103,"107":107,"147":147,"15":15,"166":166,"19":19,"20":20}],4:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */

	'use strict';

	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,

	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};

	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}

	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});

	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};

	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};

	module.exports = CSSProperty;
	},{}],5:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */

	'use strict';

	var CSSProperty = _dereq_(4);
	var ExecutionEnvironment = _dereq_(147);
	var ReactPerf = _dereq_(78);

	var camelizeStyleName = _dereq_(149);
	var dangerousStyleValue = _dereq_(119);
	var hyphenateStyleName = _dereq_(160);
	var memoizeStringOnly = _dereq_(168);
	var warning = _dereq_(173);

	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});

	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElementNS('http://www.w3.org/1999/xhtml', 'div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}

	if (false) {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;

	  var warnedStyleNames = {};
	  var warnedStyleValues = {};

	  var warnHyphenatedStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    "production" !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };

	  var warnBadVendoredStyleName = function (name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }

	    warnedStyleNames[name] = true;
	    "production" !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };

	  var warnStyleValueWithSemicolon = function (name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }

	    warnedStyleValues[value] = true;
	    "production" !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };

	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function (name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}

	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {

	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function (styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (false) {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },

	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function (node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (false) {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }

	};

	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});

	module.exports = CSSPropertyOperations;
	},{"119":119,"147":147,"149":149,"160":160,"168":168,"173":173,"4":4,"78":78}],6:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */

	'use strict';

	var PooledClass = _dereq_(25);

	var assign = _dereq_(24);
	var invariant = _dereq_(161);

	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}

	assign(CallbackQueue.prototype, {

	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function (callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },

	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function () {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ?  false ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },

	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function () {
	    this._callbacks = null;
	    this._contexts = null;
	  },

	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function () {
	    this.reset();
	  }

	});

	PooledClass.addPoolingTo(CallbackQueue);

	module.exports = CallbackQueue;
	},{"161":161,"24":24,"25":25}],7:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */

	'use strict';

	var EventConstants = _dereq_(15);
	var EventPluginHub = _dereq_(16);
	var EventPropagators = _dereq_(19);
	var ExecutionEnvironment = _dereq_(147);
	var ReactUpdates = _dereq_(96);
	var SyntheticEvent = _dereq_(105);

	var getEventTarget = _dereq_(128);
	var isEventSupported = _dereq_(133);
	var isTextInputElement = _dereq_(134);
	var keyOf = _dereq_(166);

	var topLevelTypes = EventConstants.topLevelTypes;

	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};

	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;

	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}

	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}

	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);

	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}

	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}

	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}

	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}

	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}

	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}

	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function () {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function (val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};

	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}

	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }

	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);

	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}

	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;

	  manualDispatchChangeEvent(nativeEvent);
	}

	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}

	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}

	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}

	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}

	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}

	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {

	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }

	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }

	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }

	};

	module.exports = ChangeEventPlugin;
	},{"105":105,"128":128,"133":133,"134":134,"147":147,"15":15,"16":16,"166":166,"19":19,"96":96}],8:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */

	'use strict';

	var nextReactRootIndex = 0;

	var ClientReactRootIndex = {
	  createReactRootIndex: function () {
	    return nextReactRootIndex++;
	  }
	};

	module.exports = ClientReactRootIndex;
	},{}],9:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */

	'use strict';

	var Danger = _dereq_(12);
	var ReactMultiChildUpdateTypes = _dereq_(74);
	var ReactPerf = _dereq_(78);

	var setInnerHTML = _dereq_(138);
	var setTextContent = _dereq_(139);
	var invariant = _dereq_(161);

	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.

	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);

	  parentNode.insertBefore(childNode, beforeChild);
	}

	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {

	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

	  updateTextContent: setTextContent,

	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function (updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;

	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;

	        !updatedChild ?  false ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;

	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;

	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }

	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }

	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }

	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }

	};

	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});

	module.exports = DOMChildrenOperations;
	},{"12":12,"138":138,"139":139,"161":161,"74":74,"78":78}],10:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */

	'use strict';

	var invariant = _dereq_(161);

	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}

	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function (domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }

	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ?  false ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;

	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];

	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,

	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };

	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ?  false ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ?  false ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ?  false ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;

	      if (false) {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }

	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (false) {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }

	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }

	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }

	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }

	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};

	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {

	  ID_ATTRIBUTE_NAME: 'data-reactid',

	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},

	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName:  false ? {} : null,

	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],

	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function (attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },

	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function (nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElementNS('http://www.w3.org/1999/xhtml', nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },

	  injection: DOMPropertyInjection
	};

	module.exports = DOMProperty;
	},{"161":161}],11:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */

	'use strict';

	var DOMProperty = _dereq_(10);
	var ReactPerf = _dereq_(78);

	var quoteAttributeValueForBrowser = _dereq_(136);
	var warning = _dereq_(173);

	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};

	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	   false ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}

	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}

	if (false) {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};

	  var warnUnknownProperty = function (name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }

	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();

	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    "production" !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}

	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {

	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function (id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },

	  setAttributeForID: function (node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },

	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function (name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (false) {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },

	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function (name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },

	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function (node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (false) {
	      warnUnknownProperty(name);
	    }
	  },

	  setValueForAttribute: function (node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },

	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function (node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (false) {
	      warnUnknownProperty(name);
	    }
	  }

	};

	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});

	module.exports = DOMPropertyOperations;
	},{"10":10,"136":136,"173":173,"78":78}],12:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */

	'use strict';

	var ExecutionEnvironment = _dereq_(147);

	var createNodesFromMarkup = _dereq_(152);
	var emptyFunction = _dereq_(153);
	var getMarkupWrap = _dereq_(157);
	var invariant = _dereq_(161);

	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';

	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}

	var Danger = {

	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function (markupList) {
	    !ExecutionEnvironment.canUseDOM ?  false ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ?  false ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];

	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];

	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }

	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );

	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);

	          !!resultList.hasOwnProperty(resultIndex) ?  false ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;

	          resultList[resultIndex] = renderNode;

	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (false) {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }

	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ?  false ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;

	    !(resultList.length === markupList.length) ?  false ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;

	    return resultList;
	  },

	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ?  false ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;

	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }

	};

	module.exports = Danger;
	},{"147":147,"152":152,"153":153,"157":157,"161":161}],13:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */

	'use strict';

	var keyOf = _dereq_(166);

	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];

	module.exports = DefaultEventPluginOrder;
	},{"166":166}],14:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */

	'use strict';

	var EventConstants = _dereq_(15);
	var EventPropagators = _dereq_(19);
	var SyntheticMouseEvent = _dereq_(109);

	var ReactMount = _dereq_(72);
	var keyOf = _dereq_(166);

	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;

	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};

	var extractedEvents = [null, null];

	var EnterLeaveEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }

	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }

	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }

	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }

	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;

	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;

	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;

	    return extractedEvents;
	  }

	};

	module.exports = EnterLeaveEventPlugin;
	},{"109":109,"15":15,"166":166,"19":19,"72":72}],15:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */

	'use strict';

	var keyMirror = _dereq_(165);

	var PropagationPhases = keyMirror({ bubbled: null, captured: null });

	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});

	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};

	module.exports = EventConstants;
	},{"165":165}],16:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */

	'use strict';

	var EventPluginRegistry = _dereq_(17);
	var EventPluginUtils = _dereq_(18);
	var ReactErrorUtils = _dereq_(61);

	var accumulateInto = _dereq_(115);
	var forEachAccumulated = _dereq_(124);
	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};

	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;

	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function (event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);

	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function (e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function (e) {
	  return executeDispatchesAndRelease(e, false);
	};

	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;

	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	   false ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}

	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {

	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {

	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,

	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function (InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (false) {
	        validateInstanceHandle();
	      }
	    },

	    getInstanceHandle: function () {
	      if (false) {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },

	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

	  },

	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

	  registrationNameModules: EventPluginRegistry.registrationNameModules,

	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function (id, registrationName, listener) {
	    !(typeof listener === 'function') ?  false ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;

	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;

	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },

	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function (id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },

	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function (id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }

	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },

	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function (id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }

	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }

	      delete listenerBank[registrationName][id];
	    }
	  },

	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },

	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function (events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },

	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function (simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ?  false ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },

	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function () {
	    listenerBank = {};
	  },

	  __getListenerBank: function () {
	    return listenerBank;
	  }

	};

	module.exports = EventPluginHub;
	},{"115":115,"124":124,"161":161,"17":17,"173":173,"18":18,"61":61}],17:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */

	'use strict';

	var invariant = _dereq_(161);

	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;

	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};

	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ?  false ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ?  false ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}

	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ?  false ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}

	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ?  false ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}

	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {

	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],

	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},

	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},

	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},

	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function (InjectedEventPluginOrder) {
	    !!EventPluginOrder ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },

	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function (injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ?  false ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },

	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function (event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },

	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function () {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;

	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }

	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }

	};

	module.exports = EventPluginRegistry;
	},{"161":161}],18:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */

	'use strict';

	var EventConstants = _dereq_(15);
	var ReactErrorUtils = _dereq_(61);

	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	/**
	 * Injected dependencies:
	 */

	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function (InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (false) {
	      "production" !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};

	var topLevelTypes = EventConstants.topLevelTypes;

	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}

	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}

	var validateEventDispatches;
	if (false) {
	  validateEventDispatches = function (event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;

	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

	    "production" !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}

	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (false) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}

	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (false) {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}

	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}

	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (false) {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ?  false ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}

	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}

	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,

	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,

	  getNode: function (id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function (node) {
	    return injection.Mount.getID(node);
	  },

	  injection: injection
	};

	module.exports = EventPluginUtils;
	},{"15":15,"161":161,"173":173,"61":61}],19:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */

	'use strict';

	var EventConstants = _dereq_(15);
	var EventPluginHub = _dereq_(16);

	var warning = _dereq_(173);

	var accumulateInto = _dereq_(115);
	var forEachAccumulated = _dereq_(124);

	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;

	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}

	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (false) {
	    "production" !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}

	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}

	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}

	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}

	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}

	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}

	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}

	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}

	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};

	module.exports = EventPropagators;
	},{"115":115,"124":124,"15":15,"16":16,"173":173}],20:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */

	'use strict';

	var PooledClass = _dereq_(25);

	var assign = _dereq_(24);
	var getTextContentAccessor = _dereq_(131);

	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}

	assign(FallbackCompositionState.prototype, {
	  destructor: function () {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },

	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function () {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },

	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function () {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }

	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;

	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }

	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }

	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});

	PooledClass.addPoolingTo(FallbackCompositionState);

	module.exports = FallbackCompositionState;
	},{"131":131,"24":24,"25":25}],21:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */

	'use strict';

	var DOMProperty = _dereq_(10);
	var ExecutionEnvironment = _dereq_(147);

	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}

	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,

	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,

	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};

	module.exports = HTMLDOMPropertyConfig;
	},{"10":10,"147":147}],22:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedStateMixin
	 * @typechecks static-only
	 */

	'use strict';

	var ReactLink = _dereq_(70);
	var ReactStateSetters = _dereq_(90);

	/**
	 * A simple mixin around ReactLink.forState().
	 */
	var LinkedStateMixin = {
	  /**
	   * Create a ReactLink that's linked to part of this component's state. The
	   * ReactLink will have the current value of this.state[key] and will call
	   * setState() when a change is requested.
	   *
	   * @param {string} key state key to update. Note: you may want to use keyOf()
	   * if you're using Google Closure Compiler advanced mode.
	   * @return {ReactLink} ReactLink instance linking to the state.
	   */
	  linkState: function (key) {
	    return new ReactLink(this.state[key], ReactStateSetters.createStateKeySetter(this, key));
	  }
	};

	module.exports = LinkedStateMixin;
	},{"70":70,"90":90}],23:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */

	'use strict';

	var ReactPropTypes = _dereq_(82);
	var ReactPropTypeLocations = _dereq_(81);

	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};

	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ?  false ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ?  false ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}

	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ?  false ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}

	var propTypes = {
	  value: function (props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function (props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};

	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function (tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var addendum = getDeclarationErrorAddendum(owner);
	         false ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function (inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function (inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },

	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function (inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};

	module.exports = LinkedValueUtils;
	},{"161":161,"173":173,"81":81,"82":82}],24:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

	'use strict';

	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }

	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;

	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }

	    var from = Object(nextSource);

	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.

	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }

	  return to;
	}

	module.exports = assign;
	},{}],25:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */

	'use strict';

	var invariant = _dereq_(161);

	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};

	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};

	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};

	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};

	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};

	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ?  false ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};

	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;

	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};

	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};

	module.exports = PooledClass;
	},{"161":161}],26:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */

	'use strict';

	var ReactDOM = _dereq_(40);
	var ReactDOMServer = _dereq_(50);
	var ReactIsomorphic = _dereq_(69);

	var assign = _dereq_(24);
	var deprecated = _dereq_(120);

	// `version` will be added here by ReactIsomorphic.
	var React = {};

	assign(React, ReactIsomorphic);

	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),

	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});

	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;

	module.exports = React;
	},{"120":120,"24":24,"40":40,"50":50,"69":69}],27:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */

	'use strict';

	var ReactInstanceMap = _dereq_(68);

	var findDOMNode = _dereq_(122);
	var warning = _dereq_(173);

	var didWarnKey = '_getDOMNodeDidWarn';

	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function () {
	     false ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};

	module.exports = ReactBrowserComponentMixin;
	},{"122":122,"173":173,"68":68}],28:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */

	'use strict';

	var EventConstants = _dereq_(15);
	var EventPluginHub = _dereq_(16);
	var EventPluginRegistry = _dereq_(17);
	var ReactEventEmitterMixin = _dereq_(62);
	var ReactPerf = _dereq_(78);
	var ViewportMetrics = _dereq_(114);

	var assign = _dereq_(24);
	var isEventSupported = _dereq_(133);

	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */

	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;

	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};

	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}

	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,

	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function (ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },

	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function (enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },

	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function () {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },

	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function (registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {

	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }

	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }

	        isListening[dependency] = true;
	      }
	    }
	  },

	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },

	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },

	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function () {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },

	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

	  registrationNameModules: EventPluginHub.registrationNameModules,

	  putListener: EventPluginHub.putListener,

	  getListener: EventPluginHub.getListener,

	  deleteListener: EventPluginHub.deleteListener,

	  deleteAllListeners: EventPluginHub.deleteAllListeners

	});

	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});

	module.exports = ReactBrowserEventEmitter;
	},{"114":114,"133":133,"15":15,"16":16,"17":17,"24":24,"62":62,"78":78}],29:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * @providesModule ReactCSSTransitionGroup
	 */

	'use strict';

	var React = _dereq_(26);

	var assign = _dereq_(24);

	var ReactTransitionGroup = _dereq_(94);
	var ReactCSSTransitionGroupChild = _dereq_(30);

	function createTransitionTimeoutPropValidator(transitionType) {
	  var timeoutPropName = 'transition' + transitionType + 'Timeout';
	  var enabledPropName = 'transition' + transitionType;

	  return function (props) {
	    // If the transition is enabled
	    if (props[enabledPropName]) {
	      // If no timeout duration is provided
	      if (props[timeoutPropName] == null) {
	        return new Error(timeoutPropName + ' wasn\'t supplied to ReactCSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.');

	        // If the duration isn't a number
	      } else if (typeof props[timeoutPropName] !== 'number') {
	          return new Error(timeoutPropName + ' must be a number (in milliseconds)');
	        }
	    }
	  };
	}

	var ReactCSSTransitionGroup = React.createClass({
	  displayName: 'ReactCSSTransitionGroup',

	  propTypes: {
	    transitionName: ReactCSSTransitionGroupChild.propTypes.name,

	    transitionAppear: React.PropTypes.bool,
	    transitionEnter: React.PropTypes.bool,
	    transitionLeave: React.PropTypes.bool,
	    transitionAppearTimeout: createTransitionTimeoutPropValidator('Appear'),
	    transitionEnterTimeout: createTransitionTimeoutPropValidator('Enter'),
	    transitionLeaveTimeout: createTransitionTimeoutPropValidator('Leave')
	  },

	  getDefaultProps: function () {
	    return {
	      transitionAppear: false,
	      transitionEnter: true,
	      transitionLeave: true
	    };
	  },

	  _wrapChild: function (child) {
	    // We need to provide this childFactory so that
	    // ReactCSSTransitionGroupChild can receive updates to name, enter, and
	    // leave while it is leaving.
	    return React.createElement(ReactCSSTransitionGroupChild, {
	      name: this.props.transitionName,
	      appear: this.props.transitionAppear,
	      enter: this.props.transitionEnter,
	      leave: this.props.transitionLeave,
	      appearTimeout: this.props.transitionAppearTimeout,
	      enterTimeout: this.props.transitionEnterTimeout,
	      leaveTimeout: this.props.transitionLeaveTimeout
	    }, child);
	  },

	  render: function () {
	    return React.createElement(ReactTransitionGroup, assign({}, this.props, { childFactory: this._wrapChild }));
	  }
	});

	module.exports = ReactCSSTransitionGroup;
	},{"24":24,"26":26,"30":30,"94":94}],30:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks
	 * @providesModule ReactCSSTransitionGroupChild
	 */

	'use strict';

	var React = _dereq_(26);
	var ReactDOM = _dereq_(40);

	var CSSCore = _dereq_(145);
	var ReactTransitionEvents = _dereq_(93);

	var onlyChild = _dereq_(135);

	// We don't remove the element from the DOM until we receive an animationend or
	// transitionend event. If the user screws up and forgets to add an animation
	// their node will be stuck in the DOM forever, so we detect if an animation
	// does not start and if it doesn't, we just call the end listener immediately.
	var TICK = 17;

	var ReactCSSTransitionGroupChild = React.createClass({
	  displayName: 'ReactCSSTransitionGroupChild',

	  propTypes: {
	    name: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.shape({
	      enter: React.PropTypes.string,
	      leave: React.PropTypes.string,
	      active: React.PropTypes.string
	    }), React.PropTypes.shape({
	      enter: React.PropTypes.string,
	      enterActive: React.PropTypes.string,
	      leave: React.PropTypes.string,
	      leaveActive: React.PropTypes.string,
	      appear: React.PropTypes.string,
	      appearActive: React.PropTypes.string
	    })]).isRequired,

	    // Once we require timeouts to be specified, we can remove the
	    // boolean flags (appear etc.) and just accept a number
	    // or a bool for the timeout flags (appearTimeout etc.)
	    appear: React.PropTypes.bool,
	    enter: React.PropTypes.bool,
	    leave: React.PropTypes.bool,
	    appearTimeout: React.PropTypes.number,
	    enterTimeout: React.PropTypes.number,
	    leaveTimeout: React.PropTypes.number
	  },

	  transition: function (animationType, finishCallback, userSpecifiedDelay) {
	    var node = ReactDOM.findDOMNode(this);

	    if (!node) {
	      if (finishCallback) {
	        finishCallback();
	      }
	      return;
	    }

	    var className = this.props.name[animationType] || this.props.name + '-' + animationType;
	    var activeClassName = this.props.name[animationType + 'Active'] || className + '-active';
	    var timeout = null;

	    var endListener = function (e) {
	      if (e && e.target !== node) {
	        return;
	      }

	      clearTimeout(timeout);

	      CSSCore.removeClass(node, className);
	      CSSCore.removeClass(node, activeClassName);

	      ReactTransitionEvents.removeEndEventListener(node, endListener);

	      // Usually this optional callback is used for informing an owner of
	      // a leave animation and telling it to remove the child.
	      if (finishCallback) {
	        finishCallback();
	      }
	    };

	    CSSCore.addClass(node, className);

	    // Need to do this to actually trigger a transition.
	    this.queueClass(activeClassName);

	    // If the user specified a timeout delay.
	    if (userSpecifiedDelay) {
	      // Clean-up the animation after the specified delay
	      timeout = setTimeout(endListener, userSpecifiedDelay);
	      this.transitionTimeouts.push(timeout);
	    } else {
	      // DEPRECATED: this listener will be removed in a future version of react
	      ReactTransitionEvents.addEndEventListener(node, endListener);
	    }
	  },

	  queueClass: function (className) {
	    this.classNameQueue.push(className);

	    if (!this.timeout) {
	      this.timeout = setTimeout(this.flushClassNameQueue, TICK);
	    }
	  },

	  flushClassNameQueue: function () {
	    if (this.isMounted()) {
	      this.classNameQueue.forEach(CSSCore.addClass.bind(CSSCore, ReactDOM.findDOMNode(this)));
	    }
	    this.classNameQueue.length = 0;
	    this.timeout = null;
	  },

	  componentWillMount: function () {
	    this.classNameQueue = [];
	    this.transitionTimeouts = [];
	  },

	  componentWillUnmount: function () {
	    if (this.timeout) {
	      clearTimeout(this.timeout);
	    }
	    this.transitionTimeouts.forEach(function (timeout) {
	      clearTimeout(timeout);
	    });
	  },

	  componentWillAppear: function (done) {
	    if (this.props.appear) {
	      this.transition('appear', done, this.props.appearTimeout);
	    } else {
	      done();
	    }
	  },

	  componentWillEnter: function (done) {
	    if (this.props.enter) {
	      this.transition('enter', done, this.props.enterTimeout);
	    } else {
	      done();
	    }
	  },

	  componentWillLeave: function (done) {
	    if (this.props.leave) {
	      this.transition('leave', done, this.props.leaveTimeout);
	    } else {
	      done();
	    }
	  },

	  render: function () {
	    return onlyChild(this.props.children);
	  }
	});

	module.exports = ReactCSSTransitionGroupChild;
	},{"135":135,"145":145,"26":26,"40":40,"93":93}],31:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */

	'use strict';

	var ReactReconciler = _dereq_(84);

	var instantiateReactComponent = _dereq_(132);
	var shouldUpdateReactComponent = _dereq_(141);
	var traverseAllChildren = _dereq_(142);
	var warning = _dereq_(173);

	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (false) {
	    "production" !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}

	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function (nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },

	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function (prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },

	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function (renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }

	};

	module.exports = ReactChildReconciler;
	},{"132":132,"141":141,"142":142,"173":173,"84":84}],32:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */

	'use strict';

	var PooledClass = _dereq_(25);
	var ReactElement = _dereq_(57);

	var emptyFunction = _dereq_(153);
	var traverseAllChildren = _dereq_(142);

	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;

	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;

	  func.call(context, child, bookKeeping.count++);
	}

	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;

	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}

	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}

	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}

	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}

	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}

	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}

	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};

	module.exports = ReactChildren;
	},{"142":142,"153":153,"25":25,"57":57}],33:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */

	'use strict';

	var ReactComponent = _dereq_(34);
	var ReactElement = _dereq_(57);
	var ReactPropTypeLocations = _dereq_(81);
	var ReactPropTypeLocationNames = _dereq_(80);
	var ReactNoopUpdateQueue = _dereq_(76);

	var assign = _dereq_(24);
	var emptyObject = _dereq_(154);
	var invariant = _dereq_(161);
	var keyMirror = _dereq_(165);
	var keyOf = _dereq_(166);
	var warning = _dereq_(173);

	var MIXINS_KEY = keyOf({ mixins: null });

	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});

	var injectedMixins = [];

	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	     false ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}

	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {

	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,

	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,

	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,

	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,

	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,

	  // ==== Definition methods ====

	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,

	  // ==== Delegate methods ====

	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,

	  // ==== Advanced methods ====

	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE

	};

	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (false) {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (false) {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (false) {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };

	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	       false ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}

	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ?  false ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }

	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ?  false ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}

	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }

	  !(typeof spec !== 'function') ?  false ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ?  false ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;

	  var proto = Constructor.prototype;

	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }

	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }

	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }

	    var property = spec[name];
	    validateMethodOverride(proto, name);

	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];

	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ?  false ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;

	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (false) {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}

	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }

	    var isReserved = (name in RESERVED_SPEC_KEYS);
	    !!isReserved ?  false ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;

	    var isInherited = (name in Constructor);
	    !!isInherited ?  false ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}

	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ?  false ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;

	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ?  false ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}

	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}

	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}

	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (false) {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        "production" !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        "production" !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}

	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}

	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {

	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  },

	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function (partialProps, callback) {
	    if (false) {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },

	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function (newProps, callback) {
	    if (false) {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};

	var ReactClassComponent = function () {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {

	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.

	      if (false) {
	        "production" !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }

	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }

	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;

	      this.state = null;

	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.

	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (false) {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ?  false ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;

	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;

	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

	    mixSpecIntoComponent(Constructor, spec);

	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }

	    if (false) {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }

	    !Constructor.prototype.render ?  false ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;

	    if (false) {
	      "production" !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      "production" !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }

	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }

	    return Constructor;
	  },

	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }

	};

	module.exports = ReactClass;
	},{"154":154,"161":161,"165":165,"166":166,"173":173,"24":24,"34":34,"57":57,"76":76,"80":80,"81":81}],34:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */

	'use strict';

	var ReactNoopUpdateQueue = _dereq_(76);

	var canDefineProperty = _dereq_(117);
	var emptyObject = _dereq_(154);
	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	ReactComponent.prototype.isReactComponent = {};

	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ?  false ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (false) {
	    "production" !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};

	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};

	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (false) {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          "production" !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}

	module.exports = ReactComponent;
	},{"117":117,"154":154,"161":161,"173":173,"76":76}],35:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */

	'use strict';

	var ReactDOMIDOperations = _dereq_(45);
	var ReactMount = _dereq_(72);

	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {

	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function (rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }

	};

	module.exports = ReactComponentBrowserEnvironment;
	},{"45":45,"72":72}],36:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */

	'use strict';

	var invariant = _dereq_(161);

	var injected = false;

	var ReactComponentEnvironment = {

	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,

	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,

	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,

	  injection: {
	    injectEnvironment: function (environment) {
	      !!injected ?  false ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }

	};

	module.exports = ReactComponentEnvironment;
	},{"161":161}],37:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentWithPureRenderMixin
	 */

	'use strict';

	var shallowCompare = _dereq_(140);

	/**
	 * If your React component's render function is "pure", e.g. it will render the
	 * same result given the same props and state, provide this Mixin for a
	 * considerable performance boost.
	 *
	 * Most React components have pure render functions.
	 *
	 * Example:
	 *
	 *   var ReactComponentWithPureRenderMixin =
	 *     require('ReactComponentWithPureRenderMixin');
	 *   React.createClass({
	 *     mixins: [ReactComponentWithPureRenderMixin],
	 *
	 *     render: function() {
	 *       return <div className={this.props.className}>foo</div>;
	 *     }
	 *   });
	 *
	 * Note: This only checks shallow equality for props and state. If these contain
	 * complex data structures this mixin may have false-negatives for deeper
	 * differences. Only mixin to components which have simple props and state, or
	 * use `forceUpdate()` when you know deep data structures have changed.
	 */
	var ReactComponentWithPureRenderMixin = {
	  shouldComponentUpdate: function (nextProps, nextState) {
	    return shallowCompare(this, nextProps, nextState);
	  }
	};

	module.exports = ReactComponentWithPureRenderMixin;
	},{"140":140}],38:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */

	'use strict';

	var ReactComponentEnvironment = _dereq_(36);
	var ReactCurrentOwner = _dereq_(39);
	var ReactElement = _dereq_(57);
	var ReactInstanceMap = _dereq_(68);
	var ReactPerf = _dereq_(78);
	var ReactPropTypeLocations = _dereq_(81);
	var ReactPropTypeLocationNames = _dereq_(80);
	var ReactReconciler = _dereq_(84);
	var ReactUpdateQueue = _dereq_(95);

	var assign = _dereq_(24);
	var emptyObject = _dereq_(154);
	var invariant = _dereq_(161);
	var shouldUpdateReactComponent = _dereq_(141);
	var warning = _dereq_(173);

	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};

	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */

	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;

	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {

	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function (element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;

	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    this._renderedComponent = null;

	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;

	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },

	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;

	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);

	    var Component = this._currentElement.type;

	    // Initialize the public class
	    var inst;
	    var renderedElement;

	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = ('prototype' in Component);

	    if (canInstantiate) {
	      if (false) {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }

	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }

	    if (false) {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        "production" !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        "production" !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }

	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;

	    this._instance = inst;

	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);

	    if (false) {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      "production" !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      "production" !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      "production" !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      "production" !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      "production" !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      "production" !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      "production" !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }

	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !(typeof initialState === 'object' && !Array.isArray(initialState)) ?  false ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;

	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;

	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }

	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }

	    this._renderedComponent = this._instantiateReactComponent(renderedElement);

	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }

	    return markup;
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function () {
	    var inst = this._instance;

	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }

	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;

	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;

	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;

	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);

	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function (context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },

	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function (context) {
	    var maskedContext = this._maskContext(context);
	    if (false) {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },

	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function (currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(typeof Component.childContextTypes === 'object') ?  false ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (false) {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ?  false ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },

	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function (newProps) {
	    if (false) {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },

	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function (propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ?  false ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);

	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	             false ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	             false ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },

	  receiveComponent: function (nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;

	    this._pendingElement = null;

	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },

	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }

	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },

	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;

	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;

	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.

	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }

	    var nextState = this._processPendingState(nextProps, nextContext);

	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);

	    if (false) {
	      "production" !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }

	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },

	  _processPendingState: function (props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;

	    if (!queue) {
	      return inst.state;
	    }

	    if (replace && queue.length === 1) {
	      return queue[0];
	    }

	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }

	    return nextState;
	  },

	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;

	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }

	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }

	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;

	    this._updateRenderedComponent(transaction, unmaskedContext);

	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },

	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function (transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);

	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },

	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },

	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function () {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (false) {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }

	    return renderedComponent;
	  },

	  /**
	   * @private
	   */
	  _renderValidatedComponent: function () {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ?  false ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },

	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function (ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ?  false ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (false) {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      "production" !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },

	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function (ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },

	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function () {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },

	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function () {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },

	  // Stub
	  _instantiateReactComponent: null

	};

	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});

	var ReactCompositeComponent = {

	  Mixin: ReactCompositeComponentMixin

	};

	module.exports = ReactCompositeComponent;
	},{"141":141,"154":154,"161":161,"173":173,"24":24,"36":36,"39":39,"57":57,"68":68,"78":78,"80":80,"81":81,"84":84,"95":95}],39:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */

	'use strict';

	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	var ReactCurrentOwner = {

	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null

	};

	module.exports = ReactCurrentOwner;
	},{}],40:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */

	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

	'use strict';

	var ReactCurrentOwner = _dereq_(39);
	var ReactDOMTextComponent = _dereq_(51);
	var ReactDefaultInjection = _dereq_(54);
	var ReactInstanceHandles = _dereq_(67);
	var ReactMount = _dereq_(72);
	var ReactPerf = _dereq_(78);
	var ReactReconciler = _dereq_(84);
	var ReactUpdates = _dereq_(96);
	var ReactVersion = _dereq_(97);

	var findDOMNode = _dereq_(122);
	var renderSubtreeIntoContainer = _dereq_(137);
	var warning = _dereq_(173);

	ReactDefaultInjection.inject();

	var render = ReactPerf.measure('React', 'render', ReactMount.render);

	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,

	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};

	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}

	if (false) {
	  var ExecutionEnvironment = _dereq_(147);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }

	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

	    "production" !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;

	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,

	    // shams
	    Object.create, Object.freeze];

	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}

	module.exports = React;
	},{"122":122,"137":137,"147":147,"173":173,"39":39,"51":51,"54":54,"67":67,"72":72,"78":78,"84":84,"96":96,"97":97}],41:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */

	'use strict';

	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,

	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};

	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function (inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }

	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }

	    return nativeProps;
	  }
	};

	module.exports = ReactDOMButton;
	},{}],42:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */

	/* global hasOwnProperty:true */

	'use strict';

	var AutoFocusUtils = _dereq_(2);
	var CSSPropertyOperations = _dereq_(5);
	var DOMProperty = _dereq_(10);
	var DOMPropertyOperations = _dereq_(11);
	var EventConstants = _dereq_(15);
	var ReactBrowserEventEmitter = _dereq_(28);
	var ReactComponentBrowserEnvironment = _dereq_(35);
	var ReactDOMButton = _dereq_(41);
	var ReactDOMInput = _dereq_(46);
	var ReactDOMOption = _dereq_(47);
	var ReactDOMSelect = _dereq_(48);
	var ReactDOMTextarea = _dereq_(52);
	var ReactMount = _dereq_(72);
	var ReactMultiChild = _dereq_(73);
	var ReactPerf = _dereq_(78);
	var ReactUpdateQueue = _dereq_(95);

	var assign = _dereq_(24);
	var canDefineProperty = _dereq_(117);
	var escapeTextContentForBrowser = _dereq_(121);
	var invariant = _dereq_(161);
	var isEventSupported = _dereq_(133);
	var keyOf = _dereq_(166);
	var setInnerHTML = _dereq_(138);
	var setTextContent = _dereq_(139);
	var shallowEqual = _dereq_(171);
	var validateDOMNesting = _dereq_(144);
	var warning = _dereq_(173);

	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };

	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });

	var ELEMENT_NODE_TYPE = 1;

	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}

	var legacyPropsDescriptor;
	if (false) {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function () {
	        var component = this._reactInternalComponent;
	        "production" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}

	function legacyGetDOMNode() {
	  if (false) {
	    var component = this._reactInternalComponent;
	    "production" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}

	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (false) {
	    "production" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}

	function legacySetStateEtc() {
	  if (false) {
	    var component = this._reactInternalComponent;
	    "production" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}

	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (false) {
	    "production" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}

	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (false) {
	    "production" !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}

	function friendlyStringify(obj) {
	  if (typeof obj === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}

	var styleMutationWarning = {};

	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }

	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }

	  var hash = ownerName + '|' + componentName;

	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }

	  styleMutationWarning[hash] = true;

	   false ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}

	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (false) {
	    if (voidElementTags[component._tag]) {
	      "production" !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ?  false ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ?  false ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (false) {
	    "production" !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    "production" !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || typeof props.style === 'object') ?  false ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}

	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (false) {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    "production" !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}

	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}

	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};

	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ?  false ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ?  false ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;

	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':

	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }

	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}

	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}

	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}

	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.

	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};

	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};

	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.

	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);

	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name

	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = ({}).hasOwnProperty;

	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ?  false ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}

	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}

	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}

	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (false) {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}

	ReactDOMComponent.displayName = 'ReactDOMComponent';

	ReactDOMComponent.Mixin = {

	  construct: function (element) {
	    this._currentElement = element;
	  },

	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function (rootID, transaction, context) {
	    this._rootNodeID = rootID;

	    var props = this._currentElement.props;

	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }

	    assertValidProps(this, props);
	    if (false) {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }

	    if (false) {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }

	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElementNS('http://www.w3.org/1999/xhtml', this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }

	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }

	    return mountImage;
	  },

	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
	    var ret = '<' + this._currentElement.type;

	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (false) {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }

	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }

	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },

	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function (transaction, props, context) {
	    var ret = '';

	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },

	  _createInitialChildren: function (transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },

	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function (nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },

	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function (transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;

	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }

	    if (false) {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }

	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);

	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }

	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },

	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (false) {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },

	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;

	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }

	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },

	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function () {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ?  false ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }

	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },

	  getPublicInstance: function () {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);

	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;

	      if (false) {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }

	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }

	};

	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});

	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

	module.exports = ReactDOMComponent;
	},{"10":10,"11":11,"117":117,"121":121,"133":133,"138":138,"139":139,"144":144,"15":15,"161":161,"166":166,"171":171,"173":173,"2":2,"24":24,"28":28,"35":35,"41":41,"46":46,"47":47,"48":48,"5":5,"52":52,"72":72,"73":73,"78":78,"95":95}],43:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */

	'use strict';

	var ReactElement = _dereq_(57);
	var ReactElementValidator = _dereq_(58);

	var mapObject = _dereq_(167);

	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (false) {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}

	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',

	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'

	}, createDOMFactory);

	module.exports = ReactDOMFactories;
	},{"167":167,"57":57,"58":58}],44:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */

	'use strict';

	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};

	module.exports = ReactDOMFeatureFlags;
	},{}],45:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */

	'use strict';

	var DOMChildrenOperations = _dereq_(9);
	var DOMPropertyOperations = _dereq_(11);
	var ReactMount = _dereq_(72);
	var ReactPerf = _dereq_(78);

	var invariant = _dereq_(161);

	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};

	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {

	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function (id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ?  false ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;

	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },

	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },

	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function (updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};

	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});

	module.exports = ReactDOMIDOperations;
	},{"11":11,"161":161,"72":72,"78":78,"9":9}],46:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */

	'use strict';

	var ReactDOMIDOperations = _dereq_(45);
	var LinkedValueUtils = _dereq_(23);
	var ReactMount = _dereq_(72);
	var ReactUpdates = _dereq_(96);

	var assign = _dereq_(24);
	var invariant = _dereq_(161);

	var instancesByReactID = {};

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}

	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function (inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);

	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });

	    return nativeProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (false) {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }

	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },

	  mountReadyWrapper: function (inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },

	  unmountWrapper: function (inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }

	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;

	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);

	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;

	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }

	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ?  false ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ?  false ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }

	  return returnValue;
	}

	module.exports = ReactDOMInput;
	},{"161":161,"23":23,"24":24,"45":45,"72":72,"96":96}],47:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */

	'use strict';

	var ReactChildren = _dereq_(32);
	var ReactDOMSelect = _dereq_(48);

	var assign = _dereq_(24);
	var warning = _dereq_(173);

	var valueContextKey = ReactDOMSelect.valueContextKey;

	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function (inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (false) {
	      "production" !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }

	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];

	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }

	    inst._wrapperState = { selected: selected };
	  },

	  getNativeProps: function (inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);

	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }

	    var content = '';

	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	         false ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });

	    nativeProps.children = content;
	    return nativeProps;
	  }

	};

	module.exports = ReactDOMOption;
	},{"173":173,"24":24,"32":32,"48":48}],48:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */

	'use strict';

	var LinkedValueUtils = _dereq_(23);
	var ReactMount = _dereq_(72);
	var ReactUpdates = _dereq_(96);

	var assign = _dereq_(24);
	var warning = _dereq_(173);

	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);

	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;

	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);

	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	var valuePropNames = ['value', 'defaultValue'];

	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);

	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	       false ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	       false ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}

	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;

	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}

	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,

	  getNativeProps: function (inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },

	  mountWrapper: function (inst, props) {
	    if (false) {
	      checkSelectPropTypes(inst, props);
	    }

	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },

	  processChildContext: function (inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },

	  postUpdateWrapper: function (inst) {
	    var props = inst._currentElement.props;

	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;

	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);

	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);

	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMSelect;
	},{"173":173,"23":23,"24":24,"72":72,"96":96}],49:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */

	'use strict';

	var ExecutionEnvironment = _dereq_(147);

	var getNodeForCharacterOffset = _dereq_(130);
	var getTextContentAccessor = _dereq_(131);

	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}

	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;

	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);

	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;

	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}

	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();

	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }

	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;

	  var currentRange = selection.getRangeAt(0);

	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }

	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;

	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;

	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}

	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;

	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }

	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}

	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }

	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);

	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }

	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);

	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();

	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}

	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};

	module.exports = ReactDOMSelection;
	},{"130":130,"131":131,"147":147}],50:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */

	'use strict';

	var ReactDefaultInjection = _dereq_(54);
	var ReactServerRendering = _dereq_(88);
	var ReactVersion = _dereq_(97);

	ReactDefaultInjection.inject();

	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};

	module.exports = ReactDOMServer;
	},{"54":54,"88":88,"97":97}],51:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */

	'use strict';

	var DOMChildrenOperations = _dereq_(9);
	var DOMPropertyOperations = _dereq_(11);
	var ReactComponentBrowserEnvironment = _dereq_(35);
	var ReactMount = _dereq_(72);

	var assign = _dereq_(24);
	var escapeTextContentForBrowser = _dereq_(121);
	var setTextContent = _dereq_(139);
	var validateDOMNesting = _dereq_(144);

	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function (props) {
	  // This constructor and its argument is currently used by mocks.
	};

	assign(ReactDOMTextComponent.prototype, {

	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function (text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;

	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },

	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function (rootID, transaction, context) {
	    if (false) {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }

	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElementNS('http://www.w3.org/1999/xhtml', 'span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);

	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }

	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },

	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function (nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },

	  unmountComponent: function () {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }

	});

	module.exports = ReactDOMTextComponent;
	},{"11":11,"121":121,"139":139,"144":144,"24":24,"35":35,"72":72,"9":9}],52:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */

	'use strict';

	var LinkedValueUtils = _dereq_(23);
	var ReactDOMIDOperations = _dereq_(45);
	var ReactUpdates = _dereq_(96);

	var assign = _dereq_(24);
	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}

	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function (inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ?  false ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;

	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });

	    return nativeProps;
	  },

	  mountWrapper: function (inst, props) {
	    if (false) {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }

	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (false) {
	        "production" !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ?  false ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ?  false ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }

	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);

	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },

	  updateWrapper: function (inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};

	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}

	module.exports = ReactDOMTextarea;
	},{"161":161,"173":173,"23":23,"24":24,"45":45,"96":96}],53:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */

	'use strict';

	var ReactUpdates = _dereq_(96);
	var Transaction = _dereq_(113);

	var assign = _dereq_(24);
	var emptyFunction = _dereq_(153);

	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function () {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};

	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};

	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}

	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  }
	});

	var transaction = new ReactDefaultBatchingStrategyTransaction();

	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,

	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function (callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};

	module.exports = ReactDefaultBatchingStrategy;
	},{"113":113,"153":153,"24":24,"96":96}],54:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */

	'use strict';

	var BeforeInputEventPlugin = _dereq_(3);
	var ChangeEventPlugin = _dereq_(7);
	var ClientReactRootIndex = _dereq_(8);
	var DefaultEventPluginOrder = _dereq_(13);
	var EnterLeaveEventPlugin = _dereq_(14);
	var ExecutionEnvironment = _dereq_(147);
	var HTMLDOMPropertyConfig = _dereq_(21);
	var ReactBrowserComponentMixin = _dereq_(27);
	var ReactComponentBrowserEnvironment = _dereq_(35);
	var ReactDefaultBatchingStrategy = _dereq_(53);
	var ReactDOMComponent = _dereq_(42);
	var ReactDOMTextComponent = _dereq_(51);
	var ReactEventListener = _dereq_(63);
	var ReactInjection = _dereq_(65);
	var ReactInstanceHandles = _dereq_(67);
	var ReactMount = _dereq_(72);
	var ReactReconcileTransaction = _dereq_(83);
	var SelectEventPlugin = _dereq_(99);
	var ServerReactRootIndex = _dereq_(100);
	var SimpleEventPlugin = _dereq_(101);
	var SVGDOMPropertyConfig = _dereq_(98);

	var alreadyInjected = false;

	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;

	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);

	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });

	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);

	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);

	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

	  if (false) {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = _dereq_(55);
	      ReactDefaultPerf.start();
	    }
	  }
	}

	module.exports = {
	  inject: inject
	};
	},{"100":100,"101":101,"13":13,"14":14,"147":147,"21":21,"27":27,"3":3,"35":35,"42":42,"51":51,"53":53,"55":55,"63":63,"65":65,"67":67,"7":7,"72":72,"8":8,"83":83,"98":98,"99":99}],55:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerf
	 * @typechecks static-only
	 */

	'use strict';

	var DOMProperty = _dereq_(10);
	var ReactDefaultPerfAnalysis = _dereq_(56);
	var ReactMount = _dereq_(72);
	var ReactPerf = _dereq_(78);

	var performanceNow = _dereq_(170);

	function roundFloat(val) {
	  return Math.floor(val * 100) / 100;
	}

	function addValue(obj, key, val) {
	  obj[key] = (obj[key] || 0) + val;
	}

	var ReactDefaultPerf = {
	  _allMeasurements: [], // last item in the list is the current one
	  _mountStack: [0],
	  _injected: false,

	  start: function () {
	    if (!ReactDefaultPerf._injected) {
	      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
	    }

	    ReactDefaultPerf._allMeasurements.length = 0;
	    ReactPerf.enableMeasure = true;
	  },

	  stop: function () {
	    ReactPerf.enableMeasure = false;
	  },

	  getLastMeasurements: function () {
	    return ReactDefaultPerf._allMeasurements;
	  },

	  printExclusive: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Component class name': item.componentName,
	        'Total inclusive time (ms)': roundFloat(item.inclusive),
	        'Exclusive mount time (ms)': roundFloat(item.exclusive),
	        'Exclusive render time (ms)': roundFloat(item.render),
	        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
	        'Render time per instance (ms)': roundFloat(item.render / item.count),
	        'Instances': item.count
	      };
	    }));
	    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
	    // number.
	  },

	  printInclusive: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Inclusive time (ms)': roundFloat(item.time),
	        'Instances': item.count
	      };
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },

	  getMeasurementsSummaryMap: function (measurements) {
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
	    return summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Wasted time (ms)': item.time,
	        'Instances': item.count
	      };
	    });
	  },

	  printWasted: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },

	  printDOM: function (measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
	    console.table(summary.map(function (item) {
	      var result = {};
	      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
	      result.type = item.type;
	      result.args = JSON.stringify(item.args);
	      return result;
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },

	  _recordWrite: function (id, fnName, totalTime, args) {
	    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
	    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
	    writes[id] = writes[id] || [];
	    writes[id].push({
	      type: fnName,
	      time: totalTime,
	      args: args
	    });
	  },

	  measure: function (moduleName, fnName, func) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      var totalTime;
	      var rv;
	      var start;

	      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
	        // A "measurement" is a set of metrics recorded for each flush. We want
	        // to group the metrics for a given flush together so we can look at the
	        // components that rendered and the DOM operations that actually
	        // happened to determine the amount of "wasted work" performed.
	        ReactDefaultPerf._allMeasurements.push({
	          exclusive: {},
	          inclusive: {},
	          render: {},
	          counts: {},
	          writes: {},
	          displayNames: {},
	          totalTime: 0,
	          created: {}
	        });
	        start = performanceNow();
	        rv = func.apply(this, args);
	        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
	        return rv;
	      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;

	        if (fnName === '_mountImageIntoNode') {
	          var mountID = ReactMount.getID(args[1]);
	          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
	        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
	          // special format
	          args[0].forEach(function (update) {
	            var writeArgs = {};
	            if (update.fromIndex !== null) {
	              writeArgs.fromIndex = update.fromIndex;
	            }
	            if (update.toIndex !== null) {
	              writeArgs.toIndex = update.toIndex;
	            }
	            if (update.textContent !== null) {
	              writeArgs.textContent = update.textContent;
	            }
	            if (update.markupIndex !== null) {
	              writeArgs.markup = args[1][update.markupIndex];
	            }
	            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
	          });
	        } else {
	          // basic format
	          var id = args[0];
	          if (typeof id === 'object') {
	            id = ReactMount.getID(args[0]);
	          }
	          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
	        }
	        return rv;
	      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
	      fnName === '_renderValidatedComponent')) {

	        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
	          return func.apply(this, args);
	        }

	        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
	        var isRender = fnName === '_renderValidatedComponent';
	        var isMount = fnName === 'mountComponent';

	        var mountStack = ReactDefaultPerf._mountStack;
	        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];

	        if (isRender) {
	          addValue(entry.counts, rootNodeID, 1);
	        } else if (isMount) {
	          entry.created[rootNodeID] = true;
	          mountStack.push(0);
	        }

	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;

	        if (isRender) {
	          addValue(entry.render, rootNodeID, totalTime);
	        } else if (isMount) {
	          var subMountTime = mountStack.pop();
	          mountStack[mountStack.length - 1] += totalTime;
	          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        } else {
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        }

	        entry.displayNames[rootNodeID] = {
	          current: this.getName(),
	          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
	        };

	        return rv;
	      } else {
	        return func.apply(this, args);
	      }
	    };
	  }
	};

	module.exports = ReactDefaultPerf;
	},{"10":10,"170":170,"56":56,"72":72,"78":78}],56:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerfAnalysis
	 */

	'use strict';

	var assign = _dereq_(24);

	// Don't try to save users less than 1.2ms (a number I made up)
	var DONT_CARE_THRESHOLD = 1.2;
	var DOM_OPERATION_TYPES = {
	  '_mountImageIntoNode': 'set innerHTML',
	  INSERT_MARKUP: 'set innerHTML',
	  MOVE_EXISTING: 'move',
	  REMOVE_NODE: 'remove',
	  SET_MARKUP: 'set innerHTML',
	  TEXT_CONTENT: 'set textContent',
	  'setValueForProperty': 'update attribute',
	  'setValueForAttribute': 'update attribute',
	  'deleteValueForProperty': 'remove attribute',
	  'setValueForStyles': 'update styles',
	  'replaceNodeWithMarkup': 'replace',
	  'updateTextContent': 'set textContent'
	};

	function getTotalTime(measurements) {
	  // TODO: return number of DOM ops? could be misleading.
	  // TODO: measure dropped frames after reconcile?
	  // TODO: log total time of each reconcile and the top-level component
	  // class that triggered it.
	  var totalTime = 0;
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    totalTime += measurement.totalTime;
	  }
	  return totalTime;
	}

	function getDOMSummary(measurements) {
	  var items = [];
	  measurements.forEach(function (measurement) {
	    Object.keys(measurement.writes).forEach(function (id) {
	      measurement.writes[id].forEach(function (write) {
	        items.push({
	          id: id,
	          type: DOM_OPERATION_TYPES[write.type] || write.type,
	          args: write.args
	        });
	      });
	    });
	  });
	  return items;
	}

	function getExclusiveSummary(measurements) {
	  var candidates = {};
	  var displayName;

	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

	    for (var id in allIDs) {
	      displayName = measurement.displayNames[id].current;

	      candidates[displayName] = candidates[displayName] || {
	        componentName: displayName,
	        inclusive: 0,
	        exclusive: 0,
	        render: 0,
	        count: 0
	      };
	      if (measurement.render[id]) {
	        candidates[displayName].render += measurement.render[id];
	      }
	      if (measurement.exclusive[id]) {
	        candidates[displayName].exclusive += measurement.exclusive[id];
	      }
	      if (measurement.inclusive[id]) {
	        candidates[displayName].inclusive += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[displayName].count += measurement.counts[id];
	      }
	    }
	  }

	  // Now make a sorted array with the results.
	  var arr = [];
	  for (displayName in candidates) {
	    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[displayName]);
	    }
	  }

	  arr.sort(function (a, b) {
	    return b.exclusive - a.exclusive;
	  });

	  return arr;
	}

	function getInclusiveSummary(measurements, onlyClean) {
	  var candidates = {};
	  var inclusiveKey;

	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	    var cleanComponents;

	    if (onlyClean) {
	      cleanComponents = getUnchangedComponents(measurement);
	    }

	    for (var id in allIDs) {
	      if (onlyClean && !cleanComponents[id]) {
	        continue;
	      }

	      var displayName = measurement.displayNames[id];

	      // Inclusive time is not useful for many components without knowing where
	      // they are instantiated. So we aggregate inclusive time with both the
	      // owner and current displayName as the key.
	      inclusiveKey = displayName.owner + ' > ' + displayName.current;

	      candidates[inclusiveKey] = candidates[inclusiveKey] || {
	        componentName: inclusiveKey,
	        time: 0,
	        count: 0
	      };

	      if (measurement.inclusive[id]) {
	        candidates[inclusiveKey].time += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[inclusiveKey].count += measurement.counts[id];
	      }
	    }
	  }

	  // Now make a sorted array with the results.
	  var arr = [];
	  for (inclusiveKey in candidates) {
	    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[inclusiveKey]);
	    }
	  }

	  arr.sort(function (a, b) {
	    return b.time - a.time;
	  });

	  return arr;
	}

	function getUnchangedComponents(measurement) {
	  // For a given reconcile, look at which components did not actually
	  // render anything to the DOM and return a mapping of their ID to
	  // the amount of time it took to render the entire subtree.
	  var cleanComponents = {};
	  var dirtyLeafIDs = Object.keys(measurement.writes);
	  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

	  for (var id in allIDs) {
	    var isDirty = false;
	    // For each component that rendered, see if a component that triggered
	    // a DOM op is in its subtree.
	    for (var i = 0; i < dirtyLeafIDs.length; i++) {
	      if (dirtyLeafIDs[i].indexOf(id) === 0) {
	        isDirty = true;
	        break;
	      }
	    }
	    // check if component newly created
	    if (measurement.created[id]) {
	      isDirty = true;
	    }
	    if (!isDirty && measurement.counts[id] > 0) {
	      cleanComponents[id] = true;
	    }
	  }
	  return cleanComponents;
	}

	var ReactDefaultPerfAnalysis = {
	  getExclusiveSummary: getExclusiveSummary,
	  getInclusiveSummary: getInclusiveSummary,
	  getDOMSummary: getDOMSummary,
	  getTotalTime: getTotalTime
	};

	module.exports = ReactDefaultPerfAnalysis;
	},{"24":24}],57:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */

	'use strict';

	var ReactCurrentOwner = _dereq_(39);

	var assign = _dereq_(24);
	var canDefineProperty = _dereq_(117);

	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};

	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,

	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,

	    // Record the component responsible for creating this element.
	    _owner: owner
	  };

	  if (false) {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};

	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }

	  return element;
	};

	ReactElement.createElement = function (type, config, children) {
	  var propName;

	  // Reserved names are extracted
	  var props = {};

	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;

	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }

	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};

	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};

	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

	  return newElement;
	};

	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);

	  if (false) {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }

	  return newElement;
	};

	ReactElement.cloneElement = function (element, config, children) {
	  var propName;

	  // Original props are copied
	  var props = assign({}, element.props);

	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;

	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;

	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};

	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};

	module.exports = ReactElement;
	},{"117":117,"24":24,"39":39}],58:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */

	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */

	'use strict';

	var ReactElement = _dereq_(57);
	var ReactPropTypeLocations = _dereq_(81);
	var ReactPropTypeLocationNames = _dereq_(80);
	var ReactCurrentOwner = _dereq_(39);

	var canDefineProperty = _dereq_(117);
	var getIteratorFn = _dereq_(129);
	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};

	var loggedTypeFailures = {};

	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;

	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	   false ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}

	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }

	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;

	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };

	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }

	  return addenda;
	}

	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}

	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ?  false ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	       false ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var addendum = getDeclarationErrorAddendum();
	         false ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}

	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	     false ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}

	var ReactElementValidator = {

	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	     false ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;

	    var element = ReactElement.createElement.apply(this, arguments);

	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }

	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }

	    validatePropTypes(element);

	    return element;
	  },

	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;

	    if (false) {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            "production" !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }

	    return validatedFactory;
	  },

	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }

	};

	module.exports = ReactElementValidator;
	},{"117":117,"129":129,"161":161,"173":173,"39":39,"57":57,"80":80,"81":81}],59:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */

	'use strict';

	var ReactElement = _dereq_(57);
	var ReactEmptyComponentRegistry = _dereq_(60);
	var ReactReconciler = _dereq_(84);

	var assign = _dereq_(24);

	var placeholderElement;

	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function (component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};

	var ReactEmptyComponent = function (instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function (element) {},
	  mountComponent: function (rootID, transaction, context) {
	    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function () {},
	  unmountComponent: function (rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});

	ReactEmptyComponent.injection = ReactEmptyComponentInjection;

	module.exports = ReactEmptyComponent;
	},{"24":24,"57":57,"60":60,"84":84}],60:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */

	'use strict';

	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	var nullComponentIDsRegistry = {};

	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}

	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}

	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}

	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};

	module.exports = ReactEmptyComponentRegistry;
	},{}],61:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */

	'use strict';

	var caughtError = null;

	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}

	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,

	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function () {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};

	if (false) {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}

	module.exports = ReactErrorUtils;
	},{}],62:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */

	'use strict';

	var EventPluginHub = _dereq_(16);

	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}

	var ReactEventEmitterMixin = {

	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};

	module.exports = ReactEventEmitterMixin;
	},{"16":16}],63:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */

	'use strict';

	var EventListener = _dereq_(146);
	var ExecutionEnvironment = _dereq_(147);
	var PooledClass = _dereq_(25);
	var ReactInstanceHandles = _dereq_(67);
	var ReactMount = _dereq_(72);
	var ReactUpdates = _dereq_(96);

	var assign = _dereq_(24);
	var getEventTarget = _dereq_(128);
	var getUnboundedScrollPosition = _dereq_(158);

	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}

	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function () {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }

	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}

	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;

	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }

	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}

	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);

	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);

	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}

	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}

	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,

	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

	  setHandleTopLevel: function (handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },

	  setEnabled: function (enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },

	  isEnabled: function () {
	    return ReactEventListener._enabled;
	  },

	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },

	  monitorScrollValue: function (refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },

	  dispatchEvent: function (topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }

	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};

	module.exports = ReactEventListener;
	},{"128":128,"146":146,"147":147,"158":158,"24":24,"25":25,"67":67,"72":72,"96":96}],64:[function(_dereq_,module,exports){
	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactFragment
	 */

	'use strict';

	var ReactChildren = _dereq_(32);
	var ReactElement = _dereq_(57);

	var emptyFunction = _dereq_(153);
	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	/**
	 * We used to allow keyed objects to serve as a collection of ReactElements,
	 * or nested sets. This allowed us a way to explicitly key a set a fragment of
	 * components. This is now being replaced with an opaque data structure.
	 * The upgrade path is to call React.addons.createFragment({ key: value }) to
	 * create a keyed fragment. The resulting data structure is an array.
	 */

	var numericPropertyRegex = /^\d+$/;

	var warnedAboutNumeric = false;

	var ReactFragment = {
	  // Wrap a keyed object in an opaque proxy that warns you if you access any
	  // of its properties.
	  create: function (object) {
	    if (typeof object !== 'object' || !object || Array.isArray(object)) {
	       false ? warning(false, 'React.addons.createFragment only accepts a single object. Got: %s', object) : undefined;
	      return object;
	    }
	    if (ReactElement.isValidElement(object)) {
	       false ? warning(false, 'React.addons.createFragment does not accept a ReactElement ' + 'without a wrapper object.') : undefined;
	      return object;
	    }

	    !(object.nodeType !== 1) ?  false ? invariant(false, 'React.addons.createFragment(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(false) : undefined;

	    var result = [];

	    for (var key in object) {
	      if (false) {
	        if (!warnedAboutNumeric && numericPropertyRegex.test(key)) {
	          "production" !== 'production' ? warning(false, 'React.addons.createFragment(...): Child objects should have ' + 'non-numeric keys so ordering is preserved.') : undefined;
	          warnedAboutNumeric = true;
	        }
	      }
	      ReactChildren.mapIntoWithKeyPrefixInternal(object[key], result, key, emptyFunction.thatReturnsArgument);
	    }

	    return result;
	  }
	};

	module.exports = ReactFragment;
	},{"153":153,"161":161,"173":173,"32":32,"57":57}],65:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */

	'use strict';

	var DOMProperty = _dereq_(10);
	var EventPluginHub = _dereq_(16);
	var ReactComponentEnvironment = _dereq_(36);
	var ReactClass = _dereq_(33);
	var ReactEmptyComponent = _dereq_(59);
	var ReactBrowserEventEmitter = _dereq_(28);
	var ReactNativeComponent = _dereq_(75);
	var ReactPerf = _dereq_(78);
	var ReactRootIndex = _dereq_(86);
	var ReactUpdates = _dereq_(96);

	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};

	module.exports = ReactInjection;
	},{"10":10,"16":16,"28":28,"33":33,"36":36,"59":59,"75":75,"78":78,"86":86,"96":96}],66:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */

	'use strict';

	var ReactDOMSelection = _dereq_(49);

	var containsNode = _dereq_(150);
	var focusNode = _dereq_(155);
	var getActiveElement = _dereq_(156);

	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}

	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {

	  hasSelectionCapabilities: function (elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },

	  getSelectionInformation: function () {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },

	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function (priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },

	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function (input) {
	    var selection;

	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }

	    return selection || { start: 0, end: 0 };
	  },

	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function (input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }

	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};

	module.exports = ReactInputSelection;
	},{"150":150,"155":155,"156":156,"49":49}],67:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */

	'use strict';

	var ReactRootIndex = _dereq_(86);

	var invariant = _dereq_(161);

	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;

	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;

	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}

	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}

	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}

	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}

	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}

	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ?  false ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ?  false ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}

	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ?  false ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}

	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ?  false ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ?  false ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ?  false ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}

	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {

	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function () {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },

	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function (rootID, name) {
	    return rootID + name;
	  },

	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function (id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },

	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },

	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },

	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },

	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function (targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },

	  getFirstCommonAncestorID: getFirstCommonAncestorID,

	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,

	  isAncestorIDOf: isAncestorIDOf,

	  SEPARATOR: SEPARATOR

	};

	module.exports = ReactInstanceHandles;
	},{"161":161,"86":86}],68:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */

	'use strict';

	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */

	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	var ReactInstanceMap = {

	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function (key) {
	    key._reactInternalInstance = undefined;
	  },

	  get: function (key) {
	    return key._reactInternalInstance;
	  },

	  has: function (key) {
	    return key._reactInternalInstance !== undefined;
	  },

	  set: function (key, value) {
	    key._reactInternalInstance = value;
	  }

	};

	module.exports = ReactInstanceMap;
	},{}],69:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */

	'use strict';

	var ReactChildren = _dereq_(32);
	var ReactComponent = _dereq_(34);
	var ReactClass = _dereq_(33);
	var ReactDOMFactories = _dereq_(43);
	var ReactElement = _dereq_(57);
	var ReactElementValidator = _dereq_(58);
	var ReactPropTypes = _dereq_(82);
	var ReactVersion = _dereq_(97);

	var assign = _dereq_(24);
	var onlyChild = _dereq_(135);

	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;

	if (false) {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}

	var React = {

	  // Modern

	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },

	  Component: ReactComponent,

	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,

	  // Classic

	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },

	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,

	  version: ReactVersion,

	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};

	module.exports = React;
	},{"135":135,"24":24,"32":32,"33":33,"34":34,"43":43,"57":57,"58":58,"82":82,"97":97}],70:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactLink
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * ReactLink encapsulates a common pattern in which a component wants to modify
	 * a prop received from its parent. ReactLink allows the parent to pass down a
	 * value coupled with a callback that, when invoked, expresses an intent to
	 * modify that value. For example:
	 *
	 * React.createClass({
	 *   getInitialState: function() {
	 *     return {value: ''};
	 *   },
	 *   render: function() {
	 *     var valueLink = new ReactLink(this.state.value, this._handleValueChange);
	 *     return <input valueLink={valueLink} />;
	 *   },
	 *   _handleValueChange: function(newValue) {
	 *     this.setState({value: newValue});
	 *   }
	 * });
	 *
	 * We have provided some sugary mixins to make the creation and
	 * consumption of ReactLink easier; see LinkedValueUtils and LinkedStateMixin.
	 */

	var React = _dereq_(26);

	/**
	 * @param {*} value current value of the link
	 * @param {function} requestChange callback to request a change
	 */
	function ReactLink(value, requestChange) {
	  this.value = value;
	  this.requestChange = requestChange;
	}

	/**
	 * Creates a PropType that enforces the ReactLink API and optionally checks the
	 * type of the value being passed inside the link. Example:
	 *
	 * MyComponent.propTypes = {
	 *   tabIndexLink: ReactLink.PropTypes.link(React.PropTypes.number)
	 * }
	 */
	function createLinkTypeChecker(linkType) {
	  var shapes = {
	    value: typeof linkType === 'undefined' ? React.PropTypes.any.isRequired : linkType.isRequired,
	    requestChange: React.PropTypes.func.isRequired
	  };
	  return React.PropTypes.shape(shapes);
	}

	ReactLink.PropTypes = {
	  link: createLinkTypeChecker
	};

	module.exports = ReactLink;
	},{"26":26}],71:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */

	'use strict';

	var adler32 = _dereq_(116);

	var TAG_END = /\/?>/;

	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',

	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function (markup) {
	    var checksum = adler32(markup);

	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },

	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function (markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};

	module.exports = ReactMarkupChecksum;
	},{"116":116}],72:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */

	'use strict';

	var DOMProperty = _dereq_(10);
	var ReactBrowserEventEmitter = _dereq_(28);
	var ReactCurrentOwner = _dereq_(39);
	var ReactDOMFeatureFlags = _dereq_(44);
	var ReactElement = _dereq_(57);
	var ReactEmptyComponentRegistry = _dereq_(60);
	var ReactInstanceHandles = _dereq_(67);
	var ReactInstanceMap = _dereq_(68);
	var ReactMarkupChecksum = _dereq_(71);
	var ReactPerf = _dereq_(78);
	var ReactReconciler = _dereq_(84);
	var ReactUpdateQueue = _dereq_(95);
	var ReactUpdates = _dereq_(96);

	var assign = _dereq_(24);
	var emptyObject = _dereq_(154);
	var containsNode = _dereq_(150);
	var instantiateReactComponent = _dereq_(132);
	var invariant = _dereq_(161);
	var setInnerHTML = _dereq_(138);
	var shouldUpdateReactComponent = _dereq_(141);
	var validateDOMNesting = _dereq_(144);
	var warning = _dereq_(173);

	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};

	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);

	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};

	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};

	if (false) {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}

	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];

	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}

	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }

	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}

	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}

	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ?  false ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;

	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }

	  return id;
	}

	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}

	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}

	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}

	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}

	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ?  false ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;

	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }

	  return false;
	}

	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}

	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}

	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);

	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}

	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (false) {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}

	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}

	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);

	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }

	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}

	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}

	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);

	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);

	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}

	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function () {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (false) {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};

	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {

	  TopLevelWrapper: TopLevelWrapper,

	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,

	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function (container, renderCallback) {
	    renderCallback();
	  },

	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });

	    if (false) {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }

	    return prevComponent;
	  },

	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function (nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ?  false ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;

	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },

	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	     false ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);

	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.

	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);

	    if (false) {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }

	    return componentInstance;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ?  false ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },

	  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ?  false ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;

	     false ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;

	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);

	    var prevComponent = instancesByReactRootID[getReactRootID(container)];

	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }

	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);

	    if (false) {
	      "production" !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;

	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            "production" !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }

	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },

	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function (nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },

	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function (container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },

	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function (container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	     false ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ?  false ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;

	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);

	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);

	      if (false) {
	        "production" !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }

	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (false) {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },

	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function (id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];

	    if (false) {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        "production" !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          "production" !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }

	    return container;
	  },

	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function (id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },

	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function (node) {
	    return findFirstReactDOMImpl(node);
	  },

	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function (ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;

	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

	    if (false) {
	      // This will throw on the next line; give an early warning
	      "production" !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }

	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;

	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;

	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.

	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }

	        child = child.nextSibling;
	      }

	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;

	        return targetChild;
	      }
	    }

	    firstChildren.length = 0;

	     true ?  false ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },

	  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ?  false ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;

	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

	        var normalizedMarkup = markup;
	        if (false) {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }

	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

	        !(container.nodeType !== DOC_NODE_TYPE) ?  false ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;

	        if (false) {
	          "production" !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }

	    !(container.nodeType !== DOC_NODE_TYPE) ?  false ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;

	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },

	  ownerDocumentContextKey: ownerDocumentContextKey,

	  /**
	   * React ID utilities.
	   */

	  getReactRootID: getReactRootID,

	  getID: getID,

	  setID: setID,

	  getNode: getNode,

	  getNodeFromInstance: getNodeFromInstance,

	  isValid: isValid,

	  purgeID: purgeID
	};

	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});

	module.exports = ReactMount;
	},{"10":10,"132":132,"138":138,"141":141,"144":144,"150":150,"154":154,"161":161,"173":173,"24":24,"28":28,"39":39,"44":44,"57":57,"60":60,"67":67,"68":68,"71":71,"78":78,"84":84,"95":95,"96":96}],73:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */

	'use strict';

	var ReactComponentEnvironment = _dereq_(36);
	var ReactMultiChildUpdateTypes = _dereq_(74);

	var ReactCurrentOwner = _dereq_(39);
	var ReactReconciler = _dereq_(84);
	var ReactChildReconciler = _dereq_(31);

	var flattenChildren = _dereq_(123);

	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;

	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];

	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];

	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}

	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}

	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}

	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}

	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}

	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}

	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}

	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {

	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {

	    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
	      if (false) {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },

	    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (false) {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },

	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function (nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },

	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function (nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },

	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function (nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },

	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },

	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },

	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function () {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },

	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function (child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },

	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function (child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },

	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function (child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },

	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function (textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },

	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function (markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },

	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },

	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function (child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }

	  }

	};

	module.exports = ReactMultiChild;
	},{"123":123,"31":31,"36":36,"39":39,"74":74,"84":84}],74:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */

	'use strict';

	var keyMirror = _dereq_(165);

	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});

	module.exports = ReactMultiChildUpdateTypes;
	},{"165":165}],75:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */

	'use strict';

	var assign = _dereq_(24);
	var invariant = _dereq_(161);

	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;

	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function (componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function (componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function (componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};

	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}

	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ?  false ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}

	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}

	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}

	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};

	module.exports = ReactNativeComponent;
	},{"161":161,"24":24}],76:[function(_dereq_,module,exports){
	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */

	'use strict';

	var warning = _dereq_(173);

	function warnTDZ(publicInstance, callerName) {
	  if (false) {
	    "production" !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}

	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },

	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },

	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }

	};

	module.exports = ReactNoopUpdateQueue;
	},{"173":173}],77:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */

	'use strict';

	var invariant = _dereq_(161);

	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {

	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function (object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },

	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ?  false ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },

	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function (component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ?  false ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }

	};

	module.exports = ReactOwner;
	},{"161":161}],78:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,

	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,

	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function (object, objectName, methodNames) {
	    if (false) {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },

	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function (objName, fnName, func) {
	    if (false) {
	      var measuredFunc = null;
	      var wrapper = function () {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },

	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function (measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};

	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}

	module.exports = ReactPerf;
	},{}],79:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTransferer
	 */

	'use strict';

	var assign = _dereq_(24);
	var emptyFunction = _dereq_(153);
	var joinClasses = _dereq_(164);

	/**
	 * Creates a transfer strategy that will merge prop values using the supplied
	 * `mergeStrategy`. If a prop was previously unset, this just sets it.
	 *
	 * @param {function} mergeStrategy
	 * @return {function}
	 */
	function createTransferStrategy(mergeStrategy) {
	  return function (props, key, value) {
	    if (!props.hasOwnProperty(key)) {
	      props[key] = value;
	    } else {
	      props[key] = mergeStrategy(props[key], value);
	    }
	  };
	}

	var transferStrategyMerge = createTransferStrategy(function (a, b) {
	  // `merge` overrides the first object's (`props[key]` above) keys using the
	  // second object's (`value`) keys. An object's style's existing `propA` would
	  // get overridden. Flip the order here.
	  return assign({}, b, a);
	});

	/**
	 * Transfer strategies dictate how props are transferred by `transferPropsTo`.
	 * NOTE: if you add any more exceptions to this list you should be sure to
	 * update `cloneWithProps()` accordingly.
	 */
	var TransferStrategies = {
	  /**
	   * Never transfer `children`.
	   */
	  children: emptyFunction,
	  /**
	   * Transfer the `className` prop by merging them.
	   */
	  className: createTransferStrategy(joinClasses),
	  /**
	   * Transfer the `style` prop (which is an object) by merging them.
	   */
	  style: transferStrategyMerge
	};

	/**
	 * Mutates the first argument by transferring the properties from the second
	 * argument.
	 *
	 * @param {object} props
	 * @param {object} newProps
	 * @return {object}
	 */
	function transferInto(props, newProps) {
	  for (var thisKey in newProps) {
	    if (!newProps.hasOwnProperty(thisKey)) {
	      continue;
	    }

	    var transferStrategy = TransferStrategies[thisKey];

	    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
	      transferStrategy(props, thisKey, newProps[thisKey]);
	    } else if (!props.hasOwnProperty(thisKey)) {
	      props[thisKey] = newProps[thisKey];
	    }
	  }
	  return props;
	}

	/**
	 * ReactPropTransferer are capable of transferring props to another component
	 * using a `transferPropsTo` method.
	 *
	 * @class ReactPropTransferer
	 */
	var ReactPropTransferer = {

	  /**
	   * Merge two props objects using TransferStrategies.
	   *
	   * @param {object} oldProps original props (they take precedence)
	   * @param {object} newProps new props to merge in
	   * @return {object} a new object containing both sets of props merged.
	   */
	  mergeProps: function (oldProps, newProps) {
	    return transferInto(assign({}, oldProps), newProps);
	  }

	};

	module.exports = ReactPropTransferer;
	},{"153":153,"164":164,"24":24}],80:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */

	'use strict';

	var ReactPropTypeLocationNames = {};

	if (false) {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}

	module.exports = ReactPropTypeLocationNames;
	},{}],81:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */

	'use strict';

	var keyMirror = _dereq_(165);

	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});

	module.exports = ReactPropTypeLocations;
	},{"165":165}],82:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */

	'use strict';

	var ReactElement = _dereq_(57);
	var ReactPropTypeLocationNames = _dereq_(80);

	var emptyFunction = _dereq_(153);
	var getIteratorFn = _dereq_(129);

	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */

	var ANONYMOUS = '<<anonymous>>';

	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),

	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};

	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }

	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);

	  return chainedCheckType;
	}

	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);

	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}

	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }

	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }

	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}

	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }

	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName) == null) {
	        return null;
	      }
	    }

	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}

	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }

	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }

	      return true;
	    default:
	      return false;
	  }
	}

	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}

	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}

	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}

	module.exports = ReactPropTypes;
	},{"129":129,"153":153,"57":57,"80":80}],83:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */

	'use strict';

	var CallbackQueue = _dereq_(6);
	var PooledClass = _dereq_(25);
	var ReactBrowserEventEmitter = _dereq_(28);
	var ReactDOMFeatureFlags = _dereq_(44);
	var ReactInputSelection = _dereq_(66);
	var Transaction = _dereq_(113);

	var assign = _dereq_(24);

	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};

	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function () {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },

	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function (previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};

	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },

	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function () {
	    this.reactMountReady.notifyAll();
	  }
	};

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};

	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

	PooledClass.addPoolingTo(ReactReconcileTransaction);

	module.exports = ReactReconcileTransaction;
	},{"113":113,"24":24,"25":25,"28":28,"44":44,"6":6,"66":66}],84:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */

	'use strict';

	var ReactRef = _dereq_(85);

	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}

	var ReactReconciler = {

	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function (internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },

	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function (internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },

	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function (internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;

	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.

	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }

	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }

	    internalInstance.receiveComponent(nextElement, transaction, context);

	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },

	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function (internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }

	};

	module.exports = ReactReconciler;
	},{"85":85}],85:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */

	'use strict';

	var ReactOwner = _dereq_(77);

	var ReactRef = {};

	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}

	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}

	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};

	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.

	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.

	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;

	  return(
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};

	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};

	module.exports = ReactRef;
	},{"77":77}],86:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */

	'use strict';

	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function (_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};

	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};

	module.exports = ReactRootIndex;
	},{}],87:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */

	'use strict';

	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function (callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};

	module.exports = ReactServerBatchingStrategy;
	},{}],88:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';

	var ReactDefaultBatchingStrategy = _dereq_(53);
	var ReactElement = _dereq_(57);
	var ReactInstanceHandles = _dereq_(67);
	var ReactMarkupChecksum = _dereq_(71);
	var ReactServerBatchingStrategy = _dereq_(87);
	var ReactServerRenderingTransaction = _dereq_(89);
	var ReactUpdates = _dereq_(96);

	var emptyObject = _dereq_(154);
	var instantiateReactComponent = _dereq_(132);
	var invariant = _dereq_(161);

	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ?  false ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;

	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);

	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}

	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ?  false ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;

	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);

	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}

	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};
	},{"132":132,"154":154,"161":161,"53":53,"57":57,"67":67,"71":71,"87":87,"89":89,"96":96}],89:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */

	'use strict';

	var PooledClass = _dereq_(25);
	var CallbackQueue = _dereq_(6);
	var Transaction = _dereq_(113);

	var assign = _dereq_(24);
	var emptyFunction = _dereq_(153);

	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function () {
	    this.reactMountReady.reset();
	  },

	  close: emptyFunction
	};

	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}

	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function () {
	    return this.reactMountReady;
	  },

	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function () {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};

	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

	PooledClass.addPoolingTo(ReactServerRenderingTransaction);

	module.exports = ReactServerRenderingTransaction;
	},{"113":113,"153":153,"24":24,"25":25,"6":6}],90:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactStateSetters
	 */

	'use strict';

	var ReactStateSetters = {
	  /**
	   * Returns a function that calls the provided function, and uses the result
	   * of that to set the component's state.
	   *
	   * @param {ReactCompositeComponent} component
	   * @param {function} funcReturningState Returned callback uses this to
	   *                                      determine how to update state.
	   * @return {function} callback that when invoked uses funcReturningState to
	   *                    determined the object literal to setState.
	   */
	  createStateSetter: function (component, funcReturningState) {
	    return function (a, b, c, d, e, f) {
	      var partialState = funcReturningState.call(component, a, b, c, d, e, f);
	      if (partialState) {
	        component.setState(partialState);
	      }
	    };
	  },

	  /**
	   * Returns a single-argument callback that can be used to update a single
	   * key in the component's state.
	   *
	   * Note: this is memoized function, which makes it inexpensive to call.
	   *
	   * @param {ReactCompositeComponent} component
	   * @param {string} key The key in the state that you should update.
	   * @return {function} callback of 1 argument which calls setState() with
	   *                    the provided keyName and callback argument.
	   */
	  createStateKeySetter: function (component, key) {
	    // Memoize the setters.
	    var cache = component.__keySetters || (component.__keySetters = {});
	    return cache[key] || (cache[key] = createStateKeySetter(component, key));
	  }
	};

	function createStateKeySetter(component, key) {
	  // Partial state is allocated outside of the function closure so it can be
	  // reused with every call, avoiding memory allocation when this function
	  // is called.
	  var partialState = {};
	  return function stateKeySetter(value) {
	    partialState[key] = value;
	    component.setState(partialState);
	  };
	}

	ReactStateSetters.Mixin = {
	  /**
	   * Returns a function that calls the provided function, and uses the result
	   * of that to set the component's state.
	   *
	   * For example, these statements are equivalent:
	   *
	   *   this.setState({x: 1});
	   *   this.createStateSetter(function(xValue) {
	   *     return {x: xValue};
	   *   })(1);
	   *
	   * @param {function} funcReturningState Returned callback uses this to
	   *                                      determine how to update state.
	   * @return {function} callback that when invoked uses funcReturningState to
	   *                    determined the object literal to setState.
	   */
	  createStateSetter: function (funcReturningState) {
	    return ReactStateSetters.createStateSetter(this, funcReturningState);
	  },

	  /**
	   * Returns a single-argument callback that can be used to update a single
	   * key in the component's state.
	   *
	   * For example, these statements are equivalent:
	   *
	   *   this.setState({x: 1});
	   *   this.createStateKeySetter('x')(1);
	   *
	   * Note: this is memoized function, which makes it inexpensive to call.
	   *
	   * @param {string} key The key in the state that you should update.
	   * @return {function} callback of 1 argument which calls setState() with
	   *                    the provided keyName and callback argument.
	   */
	  createStateKeySetter: function (key) {
	    return ReactStateSetters.createStateKeySetter(this, key);
	  }
	};

	module.exports = ReactStateSetters;
	},{}],91:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactTestUtils
	 */

	'use strict';

	var EventConstants = _dereq_(15);
	var EventPluginHub = _dereq_(16);
	var EventPropagators = _dereq_(19);
	var React = _dereq_(26);
	var ReactDOM = _dereq_(40);
	var ReactElement = _dereq_(57);
	var ReactBrowserEventEmitter = _dereq_(28);
	var ReactCompositeComponent = _dereq_(38);
	var ReactInstanceHandles = _dereq_(67);
	var ReactInstanceMap = _dereq_(68);
	var ReactMount = _dereq_(72);
	var ReactUpdates = _dereq_(96);
	var SyntheticEvent = _dereq_(105);

	var assign = _dereq_(24);
	var emptyObject = _dereq_(154);
	var findDOMNode = _dereq_(122);
	var invariant = _dereq_(161);

	var topLevelTypes = EventConstants.topLevelTypes;

	function Event(suffix) {}

	/**
	 * @class ReactTestUtils
	 */

	function findAllInRenderedTreeInternal(inst, test) {
	  if (!inst || !inst.getPublicInstance) {
	    return [];
	  }
	  var publicInst = inst.getPublicInstance();
	  var ret = test(publicInst) ? [publicInst] : [];
	  var currentElement = inst._currentElement;
	  if (ReactTestUtils.isDOMComponent(publicInst)) {
	    var renderedChildren = inst._renderedChildren;
	    var key;
	    for (key in renderedChildren) {
	      if (!renderedChildren.hasOwnProperty(key)) {
	        continue;
	      }
	      ret = ret.concat(findAllInRenderedTreeInternal(renderedChildren[key], test));
	    }
	  } else if (ReactElement.isValidElement(currentElement) && typeof currentElement.type === 'function') {
	    ret = ret.concat(findAllInRenderedTreeInternal(inst._renderedComponent, test));
	  }
	  return ret;
	}

	/**
	 * Todo: Support the entire DOM.scry query syntax. For now, these simple
	 * utilities will suffice for testing purposes.
	 * @lends ReactTestUtils
	 */
	var ReactTestUtils = {
	  renderIntoDocument: function (instance) {
	    var div = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
	    // None of our tests actually require attaching the container to the
	    // DOM, and doing so creates a mess that we rely on test isolation to
	    // clean up, so we're going to stop honoring the name of this method
	    // (and probably rename it eventually) if no problems arise.
	    // document.documentElement.appendChild(div);
	    return ReactDOM.render(instance, div);
	  },

	  isElement: function (element) {
	    return ReactElement.isValidElement(element);
	  },

	  isElementOfType: function (inst, convenienceConstructor) {
	    return ReactElement.isValidElement(inst) && inst.type === convenienceConstructor;
	  },

	  isDOMComponent: function (inst) {
	    return !!(inst && inst.nodeType === 1 && inst.tagName);
	  },

	  isDOMComponentElement: function (inst) {
	    return !!(inst && ReactElement.isValidElement(inst) && !!inst.tagName);
	  },

	  isCompositeComponent: function (inst) {
	    if (ReactTestUtils.isDOMComponent(inst)) {
	      // Accessing inst.setState warns; just return false as that'll be what
	      // this returns when we have DOM nodes as refs directly
	      return false;
	    }
	    return inst != null && typeof inst.render === 'function' && typeof inst.setState === 'function';
	  },

	  isCompositeComponentWithType: function (inst, type) {
	    if (!ReactTestUtils.isCompositeComponent(inst)) {
	      return false;
	    }
	    var internalInstance = ReactInstanceMap.get(inst);
	    var constructor = internalInstance._currentElement.type;

	    return constructor === type;
	  },

	  isCompositeComponentElement: function (inst) {
	    if (!ReactElement.isValidElement(inst)) {
	      return false;
	    }
	    // We check the prototype of the type that will get mounted, not the
	    // instance itself. This is a future proof way of duck typing.
	    var prototype = inst.type.prototype;
	    return typeof prototype.render === 'function' && typeof prototype.setState === 'function';
	  },

	  isCompositeComponentElementWithType: function (inst, type) {
	    var internalInstance = ReactInstanceMap.get(inst);
	    var constructor = internalInstance._currentElement.type;

	    return !!(ReactTestUtils.isCompositeComponentElement(inst) && constructor === type);
	  },

	  getRenderedChildOfCompositeComponent: function (inst) {
	    if (!ReactTestUtils.isCompositeComponent(inst)) {
	      return null;
	    }
	    var internalInstance = ReactInstanceMap.get(inst);
	    return internalInstance._renderedComponent.getPublicInstance();
	  },

	  findAllInRenderedTree: function (inst, test) {
	    if (!inst) {
	      return [];
	    }
	    !ReactTestUtils.isCompositeComponent(inst) ?  false ? invariant(false, 'findAllInRenderedTree(...): instance must be a composite component') : invariant(false) : undefined;
	    return findAllInRenderedTreeInternal(ReactInstanceMap.get(inst), test);
	  },

	  /**
	   * Finds all instance of components in the rendered tree that are DOM
	   * components with the class name matching `className`.
	   * @return {array} an array of all the matches.
	   */
	  scryRenderedDOMComponentsWithClass: function (root, classNames) {
	    if (!Array.isArray(classNames)) {
	      classNames = classNames.split(/\s+/);
	    }
	    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
	      if (ReactTestUtils.isDOMComponent(inst)) {
	        var className = inst.className;
	        if (typeof className !== 'string') {
	          // SVG, probably.
	          className = inst.getAttribute('class') || '';
	        }
	        var classList = className.split(/\s+/);
	        return classNames.every(function (name) {
	          return classList.indexOf(name) !== -1;
	        });
	      }
	      return false;
	    });
	  },

	  /**
	   * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
	   * and returns that one result, or throws exception if there is any other
	   * number of matches besides one.
	   * @return {!ReactDOMComponent} The one match.
	   */
	  findRenderedDOMComponentWithClass: function (root, className) {
	    var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
	    if (all.length !== 1) {
	      throw new Error('Did not find exactly one match ' + '(found: ' + all.length + ') for class:' + className);
	    }
	    return all[0];
	  },

	  /**
	   * Finds all instance of components in the rendered tree that are DOM
	   * components with the tag name matching `tagName`.
	   * @return {array} an array of all the matches.
	   */
	  scryRenderedDOMComponentsWithTag: function (root, tagName) {
	    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
	      return ReactTestUtils.isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();
	    });
	  },

	  /**
	   * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
	   * and returns that one result, or throws exception if there is any other
	   * number of matches besides one.
	   * @return {!ReactDOMComponent} The one match.
	   */
	  findRenderedDOMComponentWithTag: function (root, tagName) {
	    var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
	    if (all.length !== 1) {
	      throw new Error('Did not find exactly one match for tag:' + tagName);
	    }
	    return all[0];
	  },

	  /**
	   * Finds all instances of components with type equal to `componentType`.
	   * @return {array} an array of all the matches.
	   */
	  scryRenderedComponentsWithType: function (root, componentType) {
	    return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
	      return ReactTestUtils.isCompositeComponentWithType(inst, componentType);
	    });
	  },

	  /**
	   * Same as `scryRenderedComponentsWithType` but expects there to be one result
	   * and returns that one result, or throws exception if there is any other
	   * number of matches besides one.
	   * @return {!ReactComponent} The one match.
	   */
	  findRenderedComponentWithType: function (root, componentType) {
	    var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);
	    if (all.length !== 1) {
	      throw new Error('Did not find exactly one match for componentType:' + componentType + ' (found ' + all.length + ')');
	    }
	    return all[0];
	  },

	  /**
	   * Pass a mocked component module to this method to augment it with
	   * useful methods that allow it to be used as a dummy React component.
	   * Instead of rendering as usual, the component will become a simple
	   * <div> containing any provided children.
	   *
	   * @param {object} module the mock function object exported from a
	   *                        module that defines the component to be mocked
	   * @param {?string} mockTagName optional dummy root tag name to return
	   *                              from render method (overrides
	   *                              module.mockTagName if provided)
	   * @return {object} the ReactTestUtils object (for chaining)
	   */
	  mockComponent: function (module, mockTagName) {
	    mockTagName = mockTagName || module.mockTagName || 'div';

	    module.prototype.render.mockImplementation(function () {
	      return React.createElement(mockTagName, null, this.props.children);
	    });

	    return this;
	  },

	  /**
	   * Simulates a top level event being dispatched from a raw event that occurred
	   * on an `Element` node.
	   * @param {Object} topLevelType A type from `EventConstants.topLevelTypes`
	   * @param {!Element} node The dom to simulate an event occurring on.
	   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
	   */
	  simulateNativeEventOnNode: function (topLevelType, node, fakeNativeEvent) {
	    fakeNativeEvent.target = node;
	    ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(topLevelType, fakeNativeEvent);
	  },

	  /**
	   * Simulates a top level event being dispatched from a raw event that occurred
	   * on the `ReactDOMComponent` `comp`.
	   * @param {Object} topLevelType A type from `EventConstants.topLevelTypes`.
	   * @param {!ReactDOMComponent} comp
	   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
	   */
	  simulateNativeEventOnDOMComponent: function (topLevelType, comp, fakeNativeEvent) {
	    ReactTestUtils.simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);
	  },

	  nativeTouchData: function (x, y) {
	    return {
	      touches: [{ pageX: x, pageY: y }]
	    };
	  },

	  createRenderer: function () {
	    return new ReactShallowRenderer();
	  },

	  Simulate: null,
	  SimulateNative: {}
	};

	/**
	 * @class ReactShallowRenderer
	 */
	var ReactShallowRenderer = function () {
	  this._instance = null;
	};

	ReactShallowRenderer.prototype.getRenderOutput = function () {
	  return this._instance && this._instance._renderedComponent && this._instance._renderedComponent._renderedOutput || null;
	};

	var NoopInternalComponent = function (element) {
	  this._renderedOutput = element;
	  this._currentElement = element;
	};

	NoopInternalComponent.prototype = {

	  mountComponent: function () {},

	  receiveComponent: function (element) {
	    this._renderedOutput = element;
	    this._currentElement = element;
	  },

	  unmountComponent: function () {},

	  getPublicInstance: function () {
	    return null;
	  }
	};

	var ShallowComponentWrapper = function () {};
	assign(ShallowComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: function (element) {
	    return new NoopInternalComponent(element);
	  },
	  _replaceNodeWithMarkupByID: function () {},
	  _renderValidatedComponent: ReactCompositeComponent.Mixin._renderValidatedComponentWithoutOwnerOrContext
	});

	ReactShallowRenderer.prototype.render = function (element, context) {
	  !ReactElement.isValidElement(element) ?  false ? invariant(false, 'ReactShallowRenderer render(): Invalid component element.%s', typeof element === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : '') : invariant(false) : undefined;
	  !(typeof element.type !== 'string') ?  false ? invariant(false, 'ReactShallowRenderer render(): Shallow rendering works only with custom ' + 'components, not primitives (%s). Instead of calling `.render(el)` and ' + 'inspecting the rendered output, look at `el.props` directly instead.', element.type) : invariant(false) : undefined;

	  if (!context) {
	    context = emptyObject;
	  }
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(false);
	  this._render(element, transaction, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	};

	ReactShallowRenderer.prototype.unmount = function () {
	  if (this._instance) {
	    this._instance.unmountComponent();
	  }
	};

	ReactShallowRenderer.prototype._render = function (element, transaction, context) {
	  if (this._instance) {
	    this._instance.receiveComponent(element, transaction, context);
	  } else {
	    var rootID = ReactInstanceHandles.createReactRootID();
	    var instance = new ShallowComponentWrapper(element.type);
	    instance.construct(element);

	    instance.mountComponent(rootID, transaction, context);

	    this._instance = instance;
	  }
	};

	/**
	 * Exports:
	 *
	 * - `ReactTestUtils.Simulate.click(Element/ReactDOMComponent)`
	 * - `ReactTestUtils.Simulate.mouseMove(Element/ReactDOMComponent)`
	 * - `ReactTestUtils.Simulate.change(Element/ReactDOMComponent)`
	 * - ... (All keys from event plugin `eventTypes` objects)
	 */
	function makeSimulator(eventType) {
	  return function (domComponentOrNode, eventData) {
	    var node;
	    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
	      node = findDOMNode(domComponentOrNode);
	    } else if (domComponentOrNode.tagName) {
	      node = domComponentOrNode;
	    }

	    var dispatchConfig = ReactBrowserEventEmitter.eventNameDispatchConfigs[eventType];

	    var fakeNativeEvent = new Event();
	    fakeNativeEvent.target = node;
	    // We don't use SyntheticEvent.getPooled in order to not have to worry about
	    // properly destroying any properties assigned from `eventData` upon release
	    var event = new SyntheticEvent(dispatchConfig, ReactMount.getID(node), fakeNativeEvent, node);
	    assign(event, eventData);

	    if (dispatchConfig.phasedRegistrationNames) {
	      EventPropagators.accumulateTwoPhaseDispatches(event);
	    } else {
	      EventPropagators.accumulateDirectDispatches(event);
	    }

	    ReactUpdates.batchedUpdates(function () {
	      EventPluginHub.enqueueEvents(event);
	      EventPluginHub.processEventQueue(true);
	    });
	  };
	}

	function buildSimulators() {
	  ReactTestUtils.Simulate = {};

	  var eventType;
	  for (eventType in ReactBrowserEventEmitter.eventNameDispatchConfigs) {
	    /**
	     * @param {!Element|ReactDOMComponent} domComponentOrNode
	     * @param {?object} eventData Fake event data to use in SyntheticEvent.
	     */
	    ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
	  }
	}

	// Rebuild ReactTestUtils.Simulate whenever event plugins are injected
	var oldInjectEventPluginOrder = EventPluginHub.injection.injectEventPluginOrder;
	EventPluginHub.injection.injectEventPluginOrder = function () {
	  oldInjectEventPluginOrder.apply(this, arguments);
	  buildSimulators();
	};
	var oldInjectEventPlugins = EventPluginHub.injection.injectEventPluginsByName;
	EventPluginHub.injection.injectEventPluginsByName = function () {
	  oldInjectEventPlugins.apply(this, arguments);
	  buildSimulators();
	};

	buildSimulators();

	/**
	 * Exports:
	 *
	 * - `ReactTestUtils.SimulateNative.click(Element/ReactDOMComponent)`
	 * - `ReactTestUtils.SimulateNative.mouseMove(Element/ReactDOMComponent)`
	 * - `ReactTestUtils.SimulateNative.mouseIn/ReactDOMComponent)`
	 * - `ReactTestUtils.SimulateNative.mouseOut(Element/ReactDOMComponent)`
	 * - ... (All keys from `EventConstants.topLevelTypes`)
	 *
	 * Note: Top level event types are a subset of the entire set of handler types
	 * (which include a broader set of "synthetic" events). For example, onDragDone
	 * is a synthetic event. Except when testing an event plugin or React's event
	 * handling code specifically, you probably want to use ReactTestUtils.Simulate
	 * to dispatch synthetic events.
	 */

	function makeNativeSimulator(eventType) {
	  return function (domComponentOrNode, nativeEventData) {
	    var fakeNativeEvent = new Event(eventType);
	    assign(fakeNativeEvent, nativeEventData);
	    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
	      ReactTestUtils.simulateNativeEventOnDOMComponent(eventType, domComponentOrNode, fakeNativeEvent);
	    } else if (domComponentOrNode.tagName) {
	      // Will allow on actual dom nodes.
	      ReactTestUtils.simulateNativeEventOnNode(eventType, domComponentOrNode, fakeNativeEvent);
	    }
	  };
	}

	Object.keys(topLevelTypes).forEach(function (eventType) {
	  // Event type is stored as 'topClick' - we transform that to 'click'
	  var convenienceName = eventType.indexOf('top') === 0 ? eventType.charAt(3).toLowerCase() + eventType.substr(4) : eventType;
	  /**
	   * @param {!Element|ReactDOMComponent} domComponentOrNode
	   * @param {?Event} nativeEventData Fake native event to use in SyntheticEvent.
	   */
	  ReactTestUtils.SimulateNative[convenienceName] = makeNativeSimulator(eventType);
	});

	module.exports = ReactTestUtils;
	},{"105":105,"122":122,"15":15,"154":154,"16":16,"161":161,"19":19,"24":24,"26":26,"28":28,"38":38,"40":40,"57":57,"67":67,"68":68,"72":72,"96":96}],92:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactTransitionChildMapping
	 */

	'use strict';

	var flattenChildren = _dereq_(123);

	var ReactTransitionChildMapping = {
	  /**
	   * Given `this.props.children`, return an object mapping key to child. Just
	   * simple syntactic sugar around flattenChildren().
	   *
	   * @param {*} children `this.props.children`
	   * @return {object} Mapping of key to child
	   */
	  getChildMapping: function (children) {
	    if (!children) {
	      return children;
	    }
	    return flattenChildren(children);
	  },

	  /**
	   * When you're adding or removing children some may be added or removed in the
	   * same render pass. We want to show *both* since we want to simultaneously
	   * animate elements in and out. This function takes a previous set of keys
	   * and a new set of keys and merges them with its best guess of the correct
	   * ordering. In the future we may expose some of the utilities in
	   * ReactMultiChild to make this easy, but for now React itself does not
	   * directly have this concept of the union of prevChildren and nextChildren
	   * so we implement it here.
	   *
	   * @param {object} prev prev children as returned from
	   * `ReactTransitionChildMapping.getChildMapping()`.
	   * @param {object} next next children as returned from
	   * `ReactTransitionChildMapping.getChildMapping()`.
	   * @return {object} a key set that contains all keys in `prev` and all keys
	   * in `next` in a reasonable order.
	   */
	  mergeChildMappings: function (prev, next) {
	    prev = prev || {};
	    next = next || {};

	    function getValueForKey(key) {
	      if (next.hasOwnProperty(key)) {
	        return next[key];
	      } else {
	        return prev[key];
	      }
	    }

	    // For each key of `next`, the list of keys to insert before that key in
	    // the combined list
	    var nextKeysPending = {};

	    var pendingKeys = [];
	    for (var prevKey in prev) {
	      if (next.hasOwnProperty(prevKey)) {
	        if (pendingKeys.length) {
	          nextKeysPending[prevKey] = pendingKeys;
	          pendingKeys = [];
	        }
	      } else {
	        pendingKeys.push(prevKey);
	      }
	    }

	    var i;
	    var childMapping = {};
	    for (var nextKey in next) {
	      if (nextKeysPending.hasOwnProperty(nextKey)) {
	        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
	          var pendingNextKey = nextKeysPending[nextKey][i];
	          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
	        }
	      }
	      childMapping[nextKey] = getValueForKey(nextKey);
	    }

	    // Finally, add the keys which didn't appear before any key in `next`
	    for (i = 0; i < pendingKeys.length; i++) {
	      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
	    }

	    return childMapping;
	  }
	};

	module.exports = ReactTransitionChildMapping;
	},{"123":123}],93:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactTransitionEvents
	 */

	'use strict';

	var ExecutionEnvironment = _dereq_(147);

	/**
	 * EVENT_NAME_MAP is used to determine which event fired when a
	 * transition/animation ends, based on the style property used to
	 * define that event.
	 */
	var EVENT_NAME_MAP = {
	  transitionend: {
	    'transition': 'transitionend',
	    'WebkitTransition': 'webkitTransitionEnd',
	    'MozTransition': 'mozTransitionEnd',
	    'OTransition': 'oTransitionEnd',
	    'msTransition': 'MSTransitionEnd'
	  },

	  animationend: {
	    'animation': 'animationend',
	    'WebkitAnimation': 'webkitAnimationEnd',
	    'MozAnimation': 'mozAnimationEnd',
	    'OAnimation': 'oAnimationEnd',
	    'msAnimation': 'MSAnimationEnd'
	  }
	};

	var endEvents = [];

	function detectEvents() {
	  var testEl = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
	  var style = testEl.style;

	  // On some platforms, in particular some releases of Android 4.x,
	  // the un-prefixed "animation" and "transition" properties are defined on the
	  // style object but the events that fire will still be prefixed, so we need
	  // to check if the un-prefixed events are useable, and if not remove them
	  // from the map
	  if (!('AnimationEvent' in window)) {
	    delete EVENT_NAME_MAP.animationend.animation;
	  }

	  if (!('TransitionEvent' in window)) {
	    delete EVENT_NAME_MAP.transitionend.transition;
	  }

	  for (var baseEventName in EVENT_NAME_MAP) {
	    var baseEvents = EVENT_NAME_MAP[baseEventName];
	    for (var styleName in baseEvents) {
	      if (styleName in style) {
	        endEvents.push(baseEvents[styleName]);
	        break;
	      }
	    }
	  }
	}

	if (ExecutionEnvironment.canUseDOM) {
	  detectEvents();
	}

	// We use the raw {add|remove}EventListener() call because EventListener
	// does not know how to remove event listeners and we really should
	// clean up. Also, these events are not triggered in older browsers
	// so we should be A-OK here.

	function addEventListener(node, eventName, eventListener) {
	  node.addEventListener(eventName, eventListener, false);
	}

	function removeEventListener(node, eventName, eventListener) {
	  node.removeEventListener(eventName, eventListener, false);
	}

	var ReactTransitionEvents = {
	  addEndEventListener: function (node, eventListener) {
	    if (endEvents.length === 0) {
	      // If CSS transitions are not supported, trigger an "end animation"
	      // event immediately.
	      window.setTimeout(eventListener, 0);
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      addEventListener(node, endEvent, eventListener);
	    });
	  },

	  removeEndEventListener: function (node, eventListener) {
	    if (endEvents.length === 0) {
	      return;
	    }
	    endEvents.forEach(function (endEvent) {
	      removeEventListener(node, endEvent, eventListener);
	    });
	  }
	};

	module.exports = ReactTransitionEvents;
	},{"147":147}],94:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactTransitionGroup
	 */

	'use strict';

	var React = _dereq_(26);
	var ReactTransitionChildMapping = _dereq_(92);

	var assign = _dereq_(24);
	var emptyFunction = _dereq_(153);

	var ReactTransitionGroup = React.createClass({
	  displayName: 'ReactTransitionGroup',

	  propTypes: {
	    component: React.PropTypes.any,
	    childFactory: React.PropTypes.func
	  },

	  getDefaultProps: function () {
	    return {
	      component: 'span',
	      childFactory: emptyFunction.thatReturnsArgument
	    };
	  },

	  getInitialState: function () {
	    return {
	      children: ReactTransitionChildMapping.getChildMapping(this.props.children)
	    };
	  },

	  componentWillMount: function () {
	    this.currentlyTransitioningKeys = {};
	    this.keysToEnter = [];
	    this.keysToLeave = [];
	  },

	  componentDidMount: function () {
	    var initialChildMapping = this.state.children;
	    for (var key in initialChildMapping) {
	      if (initialChildMapping[key]) {
	        this.performAppear(key);
	      }
	    }
	  },

	  componentWillReceiveProps: function (nextProps) {
	    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(nextProps.children);
	    var prevChildMapping = this.state.children;

	    this.setState({
	      children: ReactTransitionChildMapping.mergeChildMappings(prevChildMapping, nextChildMapping)
	    });

	    var key;

	    for (key in nextChildMapping) {
	      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
	      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
	        this.keysToEnter.push(key);
	      }
	    }

	    for (key in prevChildMapping) {
	      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
	      if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
	        this.keysToLeave.push(key);
	      }
	    }

	    // If we want to someday check for reordering, we could do it here.
	  },

	  componentDidUpdate: function () {
	    var keysToEnter = this.keysToEnter;
	    this.keysToEnter = [];
	    keysToEnter.forEach(this.performEnter);

	    var keysToLeave = this.keysToLeave;
	    this.keysToLeave = [];
	    keysToLeave.forEach(this.performLeave);
	  },

	  performAppear: function (key) {
	    this.currentlyTransitioningKeys[key] = true;

	    var component = this.refs[key];

	    if (component.componentWillAppear) {
	      component.componentWillAppear(this._handleDoneAppearing.bind(this, key));
	    } else {
	      this._handleDoneAppearing(key);
	    }
	  },

	  _handleDoneAppearing: function (key) {
	    var component = this.refs[key];
	    if (component.componentDidAppear) {
	      component.componentDidAppear();
	    }

	    delete this.currentlyTransitioningKeys[key];

	    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

	    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
	      // This was removed before it had fully appeared. Remove it.
	      this.performLeave(key);
	    }
	  },

	  performEnter: function (key) {
	    this.currentlyTransitioningKeys[key] = true;

	    var component = this.refs[key];

	    if (component.componentWillEnter) {
	      component.componentWillEnter(this._handleDoneEntering.bind(this, key));
	    } else {
	      this._handleDoneEntering(key);
	    }
	  },

	  _handleDoneEntering: function (key) {
	    var component = this.refs[key];
	    if (component.componentDidEnter) {
	      component.componentDidEnter();
	    }

	    delete this.currentlyTransitioningKeys[key];

	    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

	    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
	      // This was removed before it had fully entered. Remove it.
	      this.performLeave(key);
	    }
	  },

	  performLeave: function (key) {
	    this.currentlyTransitioningKeys[key] = true;

	    var component = this.refs[key];
	    if (component.componentWillLeave) {
	      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
	    } else {
	      // Note that this is somewhat dangerous b/c it calls setState()
	      // again, effectively mutating the component before all the work
	      // is done.
	      this._handleDoneLeaving(key);
	    }
	  },

	  _handleDoneLeaving: function (key) {
	    var component = this.refs[key];

	    if (component.componentDidLeave) {
	      component.componentDidLeave();
	    }

	    delete this.currentlyTransitioningKeys[key];

	    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(this.props.children);

	    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
	      // This entered again before it fully left. Add it again.
	      this.performEnter(key);
	    } else {
	      this.setState(function (state) {
	        var newChildren = assign({}, state.children);
	        delete newChildren[key];
	        return { children: newChildren };
	      });
	    }
	  },

	  render: function () {
	    // TODO: we could get rid of the need for the wrapper node
	    // by cloning a single child
	    var childrenToRender = [];
	    for (var key in this.state.children) {
	      var child = this.state.children[key];
	      if (child) {
	        // You may need to apply reactive updates to a child as it is leaving.
	        // The normal React way to do it won't work since the child will have
	        // already been removed. In case you need this behavior you can provide
	        // a childFactory function to wrap every child, even the ones that are
	        // leaving.
	        childrenToRender.push(React.cloneElement(this.props.childFactory(child), { ref: key, key: key }));
	      }
	    }
	    return React.createElement(this.props.component, this.props, childrenToRender);
	  }
	});

	module.exports = ReactTransitionGroup;
	},{"153":153,"24":24,"26":26,"92":92}],95:[function(_dereq_,module,exports){
	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */

	'use strict';

	var ReactCurrentOwner = _dereq_(39);
	var ReactElement = _dereq_(57);
	var ReactInstanceMap = _dereq_(68);
	var ReactUpdates = _dereq_(96);

	var assign = _dereq_(24);
	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}

	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (false) {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      "production" !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }

	  if (false) {
	    "production" !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }

	  return internalInstance;
	}

	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    if (false) {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {
	    !(typeof callback === 'function') ?  false ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }

	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },

	  enqueueCallbackInternal: function (internalInstance, callback) {
	    !(typeof callback === 'function') ?  false ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingForceUpdate = true;

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

	    if (!internalInstance) {
	      return;
	    }

	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

	    if (!internalInstance) {
	      return;
	    }

	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);

	    enqueueUpdate(internalInstance);
	  },

	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function (publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },

	  enqueueSetPropsInternal: function (internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ?  false ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

	    enqueueUpdate(topLevelWrapper);
	  },

	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function (publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },

	  enqueueReplacePropsInternal: function (internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ?  false ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

	    enqueueUpdate(topLevelWrapper);
	  },

	  enqueueElementInternal: function (internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }

	};

	module.exports = ReactUpdateQueue;
	},{"161":161,"173":173,"24":24,"39":39,"57":57,"68":68,"96":96}],96:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */

	'use strict';

	var CallbackQueue = _dereq_(6);
	var PooledClass = _dereq_(25);
	var ReactPerf = _dereq_(78);
	var ReactReconciler = _dereq_(84);
	var Transaction = _dereq_(113);

	var assign = _dereq_(24);
	var invariant = _dereq_(161);

	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;

	var batchingStrategy = null;

	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ?  false ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}

	var NESTED_UPDATES = {
	  initialize: function () {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function () {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};

	var UPDATE_QUEUEING = {
	  initialize: function () {
	    this.callbackQueue.reset();
	  },
	  close: function () {
	    this.callbackQueue.notifyAll();
	  }
	};

	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}

	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function () {
	    return TRANSACTION_WRAPPERS;
	  },

	  destructor: function () {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },

	  perform: function (method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});

	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}

	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}

	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ?  false ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;

	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);

	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];

	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;

	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}

	var flushBatchedUpdates = function () {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }

	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);

	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();

	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)

	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }

	  dirtyComponents.push(component);
	}

	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ?  false ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}

	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function (ReconcileTransaction) {
	    !ReconcileTransaction ?  false ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },

	  injectBatchingStrategy: function (_batchingStrategy) {
	    !_batchingStrategy ?  false ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ?  false ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ?  false ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};

	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,

	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};

	module.exports = ReactUpdates;
	},{"113":113,"161":161,"24":24,"25":25,"6":6,"78":78,"84":84}],97:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */

	'use strict';

	module.exports = '0.14.6';
	},{}],98:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */

	'use strict';

	var DOMProperty = _dereq_(10);

	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};

	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};

	module.exports = SVGDOMPropertyConfig;
	},{"10":10}],99:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */

	'use strict';

	var EventConstants = _dereq_(15);
	var EventPropagators = _dereq_(19);
	var ExecutionEnvironment = _dereq_(147);
	var ReactInputSelection = _dereq_(66);
	var SyntheticEvent = _dereq_(105);

	var getActiveElement = _dereq_(156);
	var isTextInputElement = _dereq_(134);
	var keyOf = _dereq_(166);
	var shallowEqual = _dereq_(171);

	var topLevelTypes = EventConstants.topLevelTypes;

	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};

	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;

	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });

	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}

	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }

	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;

	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);

	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;

	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

	    return syntheticEvent;
	  }

	  return null;
	}

	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }

	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;

	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);

	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }

	    return null;
	  },

	  didPutListener: function (id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};

	module.exports = SelectEventPlugin;
	},{"105":105,"134":134,"147":147,"15":15,"156":156,"166":166,"171":171,"19":19,"66":66}],100:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */

	'use strict';

	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

	var ServerReactRootIndex = {
	  createReactRootIndex: function () {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};

	module.exports = ServerReactRootIndex;
	},{}],101:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */

	'use strict';

	var EventConstants = _dereq_(15);
	var EventListener = _dereq_(146);
	var EventPropagators = _dereq_(19);
	var ReactMount = _dereq_(72);
	var SyntheticClipboardEvent = _dereq_(102);
	var SyntheticEvent = _dereq_(105);
	var SyntheticFocusEvent = _dereq_(106);
	var SyntheticKeyboardEvent = _dereq_(108);
	var SyntheticMouseEvent = _dereq_(109);
	var SyntheticDragEvent = _dereq_(104);
	var SyntheticTouchEvent = _dereq_(110);
	var SyntheticUIEvent = _dereq_(111);
	var SyntheticWheelEvent = _dereq_(112);

	var emptyFunction = _dereq_(153);
	var getEventCharCode = _dereq_(125);
	var invariant = _dereq_(161);
	var keyOf = _dereq_(166);

	var topLevelTypes = EventConstants.topLevelTypes;

	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};

	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};

	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}

	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};

	var SimpleEventPlugin = {

	  eventTypes: eventTypes,

	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ?  false ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },

	  didPutListener: function (id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },

	  willDeleteListener: function (id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }

	};

	module.exports = SimpleEventPlugin;
	},{"102":102,"104":104,"105":105,"106":106,"108":108,"109":109,"110":110,"111":111,"112":112,"125":125,"146":146,"15":15,"153":153,"161":161,"166":166,"19":19,"72":72}],102:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticEvent = _dereq_(105);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function (event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

	module.exports = SyntheticClipboardEvent;
	},{"105":105}],103:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticEvent = _dereq_(105);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

	module.exports = SyntheticCompositionEvent;
	},{"105":105}],104:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticMouseEvent = _dereq_(109);

	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

	module.exports = SyntheticDragEvent;
	},{"109":109}],105:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */

	'use strict';

	var PooledClass = _dereq_(25);

	var assign = _dereq_(24);
	var emptyFunction = _dereq_(153);
	var warning = _dereq_(173);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function (event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};

	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	  this.target = nativeEventTarget;
	  this.currentTarget = nativeEventTarget;

	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      this[propName] = nativeEvent[propName];
	    }
	  }

	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}

	assign(SyntheticEvent.prototype, {

	  preventDefault: function () {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (false) {
	      "production" !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }

	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },

	  stopPropagation: function () {
	    var event = this.nativeEvent;
	    if (false) {
	      "production" !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }

	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function () {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },

	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,

	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function () {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }

	});

	SyntheticEvent.Interface = EventInterface;

	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;

	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;

	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;

	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};

	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

	module.exports = SyntheticEvent;
	},{"153":153,"173":173,"24":24,"25":25}],106:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticUIEvent = _dereq_(111);

	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

	module.exports = SyntheticFocusEvent;
	},{"111":111}],107:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticEvent = _dereq_(105);

	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

	module.exports = SyntheticInputEvent;
	},{"105":105}],108:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticUIEvent = _dereq_(111);

	var getEventCharCode = _dereq_(125);
	var getEventKey = _dereq_(126);
	var getEventModifierState = _dereq_(127);

	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function (event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.

	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function (event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.

	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function (event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

	module.exports = SyntheticKeyboardEvent;
	},{"111":111,"125":125,"126":126,"127":127}],109:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticUIEvent = _dereq_(111);
	var ViewportMetrics = _dereq_(114);

	var getEventModifierState = _dereq_(127);

	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function (event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function (event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function (event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function (event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

	module.exports = SyntheticMouseEvent;
	},{"111":111,"114":114,"127":127}],110:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticUIEvent = _dereq_(111);

	var getEventModifierState = _dereq_(127);

	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

	module.exports = SyntheticTouchEvent;
	},{"111":111,"127":127}],111:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticEvent = _dereq_(105);

	var getEventTarget = _dereq_(128);

	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function (event) {
	    if (event.view) {
	      return event.view;
	    }

	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }

	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function (event) {
	    return event.detail || 0;
	  }
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

	module.exports = SyntheticUIEvent;
	},{"105":105,"128":128}],112:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */

	'use strict';

	var SyntheticMouseEvent = _dereq_(109);

	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function (event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function (event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,

	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};

	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}

	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

	module.exports = SyntheticWheelEvent;
	},{"109":109}],113:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */

	'use strict';

	var invariant = _dereq_(161);

	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function () {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },

	  _isInTransaction: false,

	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,

	  isInTransaction: function () {
	    return !!this._isInTransaction;
	  },

	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function (method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ?  false ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },

	  initializeAll: function (startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },

	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function (startIndex) {
	    !this.isInTransaction() ?  false ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};

	var Transaction = {

	  Mixin: Mixin,

	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}

	};

	module.exports = Transaction;
	},{"161":161}],114:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */

	'use strict';

	var ViewportMetrics = {

	  currentScrollLeft: 0,

	  currentScrollTop: 0,

	  refreshScrollValues: function (scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }

	};

	module.exports = ViewportMetrics;
	},{}],115:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */

	'use strict';

	var invariant = _dereq_(161);

	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */

	function accumulateInto(current, next) {
	  !(next != null) ?  false ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }

	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);

	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }

	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }

	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }

	  return [current, next];
	}

	module.exports = accumulateInto;
	},{"161":161}],116:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */

	'use strict';

	var MOD = 65521;

	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}

	module.exports = adler32;
	},{}],117:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */

	'use strict';

	var canDefineProperty = false;
	if (false) {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}

	module.exports = canDefineProperty;
	},{}],118:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule cloneWithProps
	 */

	'use strict';

	var ReactElement = _dereq_(57);
	var ReactPropTransferer = _dereq_(79);

	var keyOf = _dereq_(166);
	var warning = _dereq_(173);

	var CHILDREN_PROP = keyOf({ children: null });

	var didDeprecatedWarn = false;

	/**
	 * Sometimes you want to change the props of a child passed to you. Usually
	 * this is to add a CSS class.
	 *
	 * @param {ReactElement} child child element you'd like to clone
	 * @param {object} props props you'd like to modify. className and style will be
	 * merged automatically.
	 * @return {ReactElement} a clone of child with props merged in.
	 * @deprecated
	 */
	function cloneWithProps(child, props) {
	  if (false) {
	    "production" !== 'production' ? warning(didDeprecatedWarn, 'cloneWithProps(...) is deprecated. ' + 'Please use React.cloneElement instead.') : undefined;
	    didDeprecatedWarn = true;
	    "production" !== 'production' ? warning(!child.ref, 'You are calling cloneWithProps() on a child with a ref. This is ' + 'dangerous because you\'re creating a new child which will not be ' + 'added as a ref to its parent.') : undefined;
	  }

	  var newProps = ReactPropTransferer.mergeProps(props, child.props);

	  // Use `child.props.children` if it is provided.
	  if (!newProps.hasOwnProperty(CHILDREN_PROP) && child.props.hasOwnProperty(CHILDREN_PROP)) {
	    newProps.children = child.props.children;
	  }

	  // The current API doesn't retain _owner, which is why this
	  // doesn't use ReactElement.cloneAndReplaceProps.
	  return ReactElement.createElement(child.type, newProps);
	}

	module.exports = cloneWithProps;
	},{"166":166,"173":173,"57":57,"79":79}],119:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */

	'use strict';

	var CSSProperty = _dereq_(4);

	var isUnitlessNumber = CSSProperty.isUnitlessNumber;

	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901

	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }

	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }

	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}

	module.exports = dangerousStyleValue;
	},{"4":4}],120:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */

	'use strict';

	var assign = _dereq_(24);
	var warning = _dereq_(173);

	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (false) {
	    var newFn = function () {
	      "production" !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }

	  return fn;
	}

	module.exports = deprecated;
	},{"173":173,"24":24}],121:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */

	'use strict';

	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};

	var ESCAPE_REGEX = /[&><"']/g;

	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}

	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}

	module.exports = escapeTextContentForBrowser;
	},{}],122:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */

	'use strict';

	var ReactCurrentOwner = _dereq_(39);
	var ReactInstanceMap = _dereq_(68);
	var ReactMount = _dereq_(72);

	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (false) {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      "production" !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ?  false ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ?  false ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}

	module.exports = findDOMNode;
	},{"161":161,"173":173,"39":39,"68":68,"72":72}],123:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */

	'use strict';

	var traverseAllChildren = _dereq_(142);
	var warning = _dereq_(173);

	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (false) {
	    "production" !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}

	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}

	module.exports = flattenChildren;
	},{"142":142,"173":173}],124:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */

	'use strict';

	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	var forEachAccumulated = function (arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};

	module.exports = forEachAccumulated;
	},{}],125:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;

	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;

	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }

	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }

	  return 0;
	}

	module.exports = getEventCharCode;
	},{}],126:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */

	'use strict';

	var getEventCharCode = _dereq_(125);

	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};

	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};

	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.

	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }

	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);

	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}

	module.exports = getEventKey;
	},{"125":125}],127:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */

	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};

	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}

	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}

	module.exports = getEventModifierState;
	},{}],128:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}

	module.exports = getEventTarget;
	},{}],129:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */

	'use strict';

	/* global Symbol */
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}

	module.exports = getIteratorFn;
	},{}],130:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */

	'use strict';

	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}

	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}

	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;

	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;

	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }

	      nodeStart = nodeEnd;
	    }

	    node = getLeafNode(getSiblingNode(node));
	  }
	}

	module.exports = getNodeForCharacterOffset;
	},{}],131:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */

	'use strict';

	var ExecutionEnvironment = _dereq_(147);

	var contentKey = null;

	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}

	module.exports = getTextContentAccessor;
	},{"147":147}],132:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */

	'use strict';

	var ReactCompositeComponent = _dereq_(38);
	var ReactEmptyComponent = _dereq_(59);
	var ReactNativeComponent = _dereq_(75);

	var assign = _dereq_(24);
	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function () {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});

	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}

	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;

	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if (typeof node === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ?  false ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;

	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ?  false ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
	  }

	  if (false) {
	    "production" !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }

	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);

	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;

	  if (false) {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }

	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (false) {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }

	  return instance;
	}

	module.exports = instantiateReactComponent;
	},{"161":161,"173":173,"24":24,"38":38,"59":59,"75":75}],133:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */

	'use strict';

	var ExecutionEnvironment = _dereq_(147);

	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}

	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }

	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = (eventName in document);

	  if (!isSupported) {
	    var element = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }

	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }

	  return isSupported;
	}

	module.exports = isEventSupported;
	},{"147":147}],134:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */

	'use strict';

	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};

	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}

	module.exports = isTextInputElement;
	},{}],135:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';

	var ReactElement = _dereq_(57);

	var invariant = _dereq_(161);

	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ?  false ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}

	module.exports = onlyChild;
	},{"161":161,"57":57}],136:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */

	'use strict';

	var escapeTextContentForBrowser = _dereq_(121);

	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}

	module.exports = quoteAttributeValueForBrowser;
	},{"121":121}],137:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/

	'use strict';

	var ReactMount = _dereq_(72);

	module.exports = ReactMount.renderSubtreeIntoContainer;
	},{"72":72}],138:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */

	/* globals MSApp */

	'use strict';

	var ExecutionEnvironment = _dereq_(147);

	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function (node, html) {
	  node.innerHTML = html;
	};

	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function (node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}

	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function (node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }

	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;

	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}

	module.exports = setInnerHTML;
	},{"147":147}],139:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */

	'use strict';

	var ExecutionEnvironment = _dereq_(147);
	var escapeTextContentForBrowser = _dereq_(121);
	var setInnerHTML = _dereq_(138);

	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function (node, text) {
	  node.textContent = text;
	};

	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function (node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}

	module.exports = setTextContent;
	},{"121":121,"138":138,"147":147}],140:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule shallowCompare
	*/

	'use strict';

	var shallowEqual = _dereq_(171);

	/**
	 * Does a shallow comparison for props and state.
	 * See ReactComponentWithPureRenderMixin
	 */
	function shallowCompare(instance, nextProps, nextState) {
	  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
	}

	module.exports = shallowCompare;
	},{"171":171}],141:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }

	  var prevType = typeof prevElement;
	  var nextType = typeof nextElement;
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}

	module.exports = shouldUpdateReactComponent;
	},{}],142:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */

	'use strict';

	var ReactCurrentOwner = _dereq_(39);
	var ReactElement = _dereq_(57);
	var ReactInstanceHandles = _dereq_(67);

	var getIteratorFn = _dereq_(129);
	var invariant = _dereq_(161);
	var warning = _dereq_(173);

	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};

	var userProvidedKeyEscapeRegex = /[=.:]/g;

	var didWarnAboutMaps = false;

	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}

	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (false) {
	          "production" !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (false) {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ?  false ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	module.exports = traverseAllChildren;
	},{"129":129,"161":161,"173":173,"39":39,"57":57,"67":67}],143:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule update
	 */

	/* global hasOwnProperty:true */

	'use strict';

	var assign = _dereq_(24);
	var keyOf = _dereq_(166);
	var invariant = _dereq_(161);
	var hasOwnProperty = ({}).hasOwnProperty;

	function shallowCopy(x) {
	  if (Array.isArray(x)) {
	    return x.concat();
	  } else if (x && typeof x === 'object') {
	    return assign(new x.constructor(), x);
	  } else {
	    return x;
	  }
	}

	var COMMAND_PUSH = keyOf({ $push: null });
	var COMMAND_UNSHIFT = keyOf({ $unshift: null });
	var COMMAND_SPLICE = keyOf({ $splice: null });
	var COMMAND_SET = keyOf({ $set: null });
	var COMMAND_MERGE = keyOf({ $merge: null });
	var COMMAND_APPLY = keyOf({ $apply: null });

	var ALL_COMMANDS_LIST = [COMMAND_PUSH, COMMAND_UNSHIFT, COMMAND_SPLICE, COMMAND_SET, COMMAND_MERGE, COMMAND_APPLY];

	var ALL_COMMANDS_SET = {};

	ALL_COMMANDS_LIST.forEach(function (command) {
	  ALL_COMMANDS_SET[command] = true;
	});

	function invariantArrayCase(value, spec, command) {
	  !Array.isArray(value) ?  false ? invariant(false, 'update(): expected target of %s to be an array; got %s.', command, value) : invariant(false) : undefined;
	  var specValue = spec[command];
	  !Array.isArray(specValue) ?  false ? invariant(false, 'update(): expected spec of %s to be an array; got %s. ' + 'Did you forget to wrap your parameter in an array?', command, specValue) : invariant(false) : undefined;
	}

	function update(value, spec) {
	  !(typeof spec === 'object') ?  false ? invariant(false, 'update(): You provided a key path to update() that did not contain one ' + 'of %s. Did you forget to include {%s: ...}?', ALL_COMMANDS_LIST.join(', '), COMMAND_SET) : invariant(false) : undefined;

	  if (hasOwnProperty.call(spec, COMMAND_SET)) {
	    !(Object.keys(spec).length === 1) ?  false ? invariant(false, 'Cannot have more than one key in an object with %s', COMMAND_SET) : invariant(false) : undefined;

	    return spec[COMMAND_SET];
	  }

	  var nextValue = shallowCopy(value);

	  if (hasOwnProperty.call(spec, COMMAND_MERGE)) {
	    var mergeObj = spec[COMMAND_MERGE];
	    !(mergeObj && typeof mergeObj === 'object') ?  false ? invariant(false, 'update(): %s expects a spec of type \'object\'; got %s', COMMAND_MERGE, mergeObj) : invariant(false) : undefined;
	    !(nextValue && typeof nextValue === 'object') ?  false ? invariant(false, 'update(): %s expects a target of type \'object\'; got %s', COMMAND_MERGE, nextValue) : invariant(false) : undefined;
	    assign(nextValue, spec[COMMAND_MERGE]);
	  }

	  if (hasOwnProperty.call(spec, COMMAND_PUSH)) {
	    invariantArrayCase(value, spec, COMMAND_PUSH);
	    spec[COMMAND_PUSH].forEach(function (item) {
	      nextValue.push(item);
	    });
	  }

	  if (hasOwnProperty.call(spec, COMMAND_UNSHIFT)) {
	    invariantArrayCase(value, spec, COMMAND_UNSHIFT);
	    spec[COMMAND_UNSHIFT].forEach(function (item) {
	      nextValue.unshift(item);
	    });
	  }

	  if (hasOwnProperty.call(spec, COMMAND_SPLICE)) {
	    !Array.isArray(value) ?  false ? invariant(false, 'Expected %s target to be an array; got %s', COMMAND_SPLICE, value) : invariant(false) : undefined;
	    !Array.isArray(spec[COMMAND_SPLICE]) ?  false ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. ' + 'Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : invariant(false) : undefined;
	    spec[COMMAND_SPLICE].forEach(function (args) {
	      !Array.isArray(args) ?  false ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. ' + 'Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : invariant(false) : undefined;
	      nextValue.splice.apply(nextValue, args);
	    });
	  }

	  if (hasOwnProperty.call(spec, COMMAND_APPLY)) {
	    !(typeof spec[COMMAND_APPLY] === 'function') ?  false ? invariant(false, 'update(): expected spec of %s to be a function; got %s.', COMMAND_APPLY, spec[COMMAND_APPLY]) : invariant(false) : undefined;
	    nextValue = spec[COMMAND_APPLY](nextValue);
	  }

	  for (var k in spec) {
	    if (!(ALL_COMMANDS_SET.hasOwnProperty(k) && ALL_COMMANDS_SET[k])) {
	      nextValue[k] = update(value[k], spec[k]);
	    }
	  }

	  return nextValue;
	}

	module.exports = update;
	},{"161":161,"166":166,"24":24}],144:[function(_dereq_,module,exports){
	/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */

	'use strict';

	var assign = _dereq_(24);
	var emptyFunction = _dereq_(153);
	var warning = _dereq_(173);

	var validateDOMNesting = emptyFunction;

	if (false) {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.

	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];

	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);

	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

	  var emptyAncestorInfo = {
	    parentTag: null,

	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,

	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };

	  var updatedAncestorInfo = function (oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };

	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }

	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }

	    ancestorInfo.parentTag = info;

	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }

	    return ancestorInfo;
	  };

	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function (tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }

	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;

	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }

	    return true;
	  };

	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':

	      case 'pre':
	      case 'listing':

	      case 'table':

	      case 'hr':

	      case 'xmp':

	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;

	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;

	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;

	      case 'button':
	        return ancestorInfo.buttonTagInScope;

	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;

	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }

	    return null;
	  };

	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function (instance) {
	    if (!instance) {
	      return [];
	    }

	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };

	  var didWarn = {};

	  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;

	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;

	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;

	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);

	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;

	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }

	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;

	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        "production" !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        "production" !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };

	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);

	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}

	module.exports = validateDOMNesting;
	},{"153":153,"173":173,"24":24}],145:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSCore
	 * @typechecks
	 */

	'use strict';

	var invariant = _dereq_(161);

	/**
	 * The CSSCore module specifies the API (and implements most of the methods)
	 * that should be used when dealing with the display of elements (via their
	 * CSS classes and visibility on screen. It is an API focused on mutating the
	 * display and not reading it as no logical state should be encoded in the
	 * display of elements.
	 */

	var CSSCore = {

	  /**
	   * Adds the class passed in to the element if it doesn't already have it.
	   *
	   * @param {DOMElement} element the element to set the class on
	   * @param {string} className the CSS className
	   * @return {DOMElement} the element passed in
	   */
	  addClass: function (element, className) {
	    !!/\s/.test(className) ?  false ? invariant(false, 'CSSCore.addClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;

	    if (className) {
	      if (element.classList) {
	        element.classList.add(className);
	      } else if (!CSSCore.hasClass(element, className)) {
	        element.className = element.className + ' ' + className;
	      }
	    }
	    return element;
	  },

	  /**
	   * Removes the class passed in from the element
	   *
	   * @param {DOMElement} element the element to set the class on
	   * @param {string} className the CSS className
	   * @return {DOMElement} the element passed in
	   */
	  removeClass: function (element, className) {
	    !!/\s/.test(className) ?  false ? invariant(false, 'CSSCore.removeClass takes only a single class name. "%s" contains ' + 'multiple classes.', className) : invariant(false) : undefined;

	    if (className) {
	      if (element.classList) {
	        element.classList.remove(className);
	      } else if (CSSCore.hasClass(element, className)) {
	        element.className = element.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ') // multiple spaces to one
	        .replace(/^\s*|\s*$/g, ''); // trim the ends
	      }
	    }
	    return element;
	  },

	  /**
	   * Helper to add or remove a class from an element based on a condition.
	   *
	   * @param {DOMElement} element the element to set the class on
	   * @param {string} className the CSS className
	   * @param {*} bool condition to whether to add or remove the class
	   * @return {DOMElement} the element passed in
	   */
	  conditionClass: function (element, className, bool) {
	    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);
	  },

	  /**
	   * Tests whether the element has the class specified.
	   *
	   * @param {DOMNode|DOMWindow} element the element to set the class on
	   * @param {string} className the CSS className
	   * @return {boolean} true if the element has the class, false if not
	   */
	  hasClass: function (element, className) {
	    !!/\s/.test(className) ?  false ? invariant(false, 'CSS.hasClass takes only a single class name.') : invariant(false) : undefined;
	    if (element.classList) {
	      return !!className && element.classList.contains(className);
	    }
	    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
	  }

	};

	module.exports = CSSCore;
	},{"161":161}],146:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */

	'use strict';

	var emptyFunction = _dereq_(153);

	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function () {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },

	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function (target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function () {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (false) {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },

	  registerDefault: function () {}
	};

	module.exports = EventListener;
	},{"153":153}],147:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */

	'use strict';

	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {

	  canUseDOM: canUseDOM,

	  canUseWorkers: typeof Worker !== 'undefined',

	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

	  canUseViewport: canUseDOM && !!window.screen,

	  isInWorker: !canUseDOM // For now, this is true - might change in the future.

	};

	module.exports = ExecutionEnvironment;
	},{}],148:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */

	"use strict";

	var _hyphenPattern = /-(.)/g;

	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}

	module.exports = camelize;
	},{}],149:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */

	'use strict';

	var camelize = _dereq_(148);

	var msPattern = /^-ms-/;

	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}

	module.exports = camelizeStyleName;
	},{"148":148}],150:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */

	'use strict';

	var isTextNode = _dereq_(163);

	/*eslint-disable no-bitwise */

	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;

	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;

	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}

	module.exports = containsNode;
	},{"163":163}],151:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */

	'use strict';

	var toArray = _dereq_(172);

	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return(
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    typeof obj == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}

	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}

	module.exports = createArrayFromMixed;
	},{"172":172}],152:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */

	/*eslint-disable fb-www/unsafe-html*/

	'use strict';

	var ExecutionEnvironment = _dereq_(147);

	var createArrayFromMixed = _dereq_(151);
	var getMarkupWrap = _dereq_(157);
	var invariant = _dereq_(161);

	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElementNS('http://www.w3.org/1999/xhtml', 'div') : null;

	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;

	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}

	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ?  false ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);

	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];

	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }

	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ?  false ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }

	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}

	module.exports = createNodesFromMarkup;

	},{"147":147,"151":151,"157":157,"161":161}],153:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */

	"use strict";

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;
	},{}],154:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */

	'use strict';

	var emptyObject = {};

	if (false) {
	  Object.freeze(emptyObject);
	}

	module.exports = emptyObject;
	},{}],155:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */

	'use strict';

	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}

	module.exports = focusNode;
	},{}],156:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */

	/* eslint-disable fb-www/typeof-undefined */

	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';

	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}

	module.exports = getActiveElement;
	},{}],157:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */

	/*eslint-disable fb-www/unsafe-html */

	'use strict';

	var ExecutionEnvironment = _dereq_(147);

	var invariant = _dereq_(161);

	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElementNS('http://www.w3.org/1999/xhtml', 'div') : null;

	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */

	var shouldWrap = {};

	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],

	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],

	  'optgroup': selectWrap,
	  'option': selectWrap,

	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,

	  'td': trWrap,
	  'th': trWrap
	};

	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});

	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ?  false ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}

	module.exports = getMarkupWrap;
	},{"147":147,"161":161}],158:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */

	'use strict';

	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}

	module.exports = getUnboundedScrollPosition;
	},{}],159:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */

	'use strict';

	var _uppercasePattern = /([A-Z])/g;

	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}

	module.exports = hyphenate;
	},{}],160:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */

	'use strict';

	var hyphenate = _dereq_(159);

	var msPattern = /^ms-/;

	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}

	module.exports = hyphenateStyleName;
	},{"159":159}],161:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	function invariant(condition, format, a, b, c, d, e, f) {
	  if (false) {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;
	},{}],162:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';

	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}

	module.exports = isNode;
	},{}],163:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */

	'use strict';

	var isNode = _dereq_(162);

	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}

	module.exports = isTextNode;
	},{"162":162}],164:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule joinClasses
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Combines multiple className strings into one.
	 * http://jsperf.com/joinclasses-args-vs-array
	 *
	 * @param {...?string} className
	 * @return {string}
	 */
	function joinClasses(className /*, ... */) {
	  if (!className) {
	    className = '';
	  }
	  var nextClass;
	  var argLength = arguments.length;
	  if (argLength > 1) {
	    for (var ii = 1; ii < argLength; ii++) {
	      nextClass = arguments[ii];
	      if (nextClass) {
	        className = (className ? className + ' ' : '') + nextClass;
	      }
	    }
	  }
	  return className;
	}

	module.exports = joinClasses;
	},{}],165:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */

	'use strict';

	var invariant = _dereq_(161);

	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function (obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ?  false ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};

	module.exports = keyMirror;
	},{"161":161}],166:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */

	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";

	var keyOf = function (oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};

	module.exports = keyOf;
	},{}],167:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */

	'use strict';

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}

	module.exports = mapObject;
	},{}],168:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */

	'use strict';

	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}

	module.exports = memoizeStringOnly;
	},{}],169:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performance
	 * @typechecks
	 */

	'use strict';

	var ExecutionEnvironment = _dereq_(147);

	var performance;

	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}

	module.exports = performance || {};
	},{"147":147}],170:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performanceNow
	 * @typechecks
	 */

	'use strict';

	var performance = _dereq_(169);

	var performanceNow;

	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function () {
	    return performance.now();
	  };
	} else {
	  performanceNow = function () {
	    return Date.now();
	  };
	}

	module.exports = performanceNow;
	},{"169":169}],171:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */

	'use strict';

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }

	  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
	    return false;
	  }

	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);

	  if (keysA.length !== keysB.length) {
	    return false;
	  }

	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }

	  return true;
	}

	module.exports = shallowEqual;
	},{}],172:[function(_dereq_,module,exports){
	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */

	'use strict';

	var invariant = _dereq_(161);

	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;

	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ?  false ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;

	  !(typeof length === 'number') ?  false ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;

	  !(length === 0 || length - 1 in obj) ?  false ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;

	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }

	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}

	module.exports = toArray;
	},{"161":161}],173:[function(_dereq_,module,exports){
	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */

	'use strict';

	var emptyFunction = _dereq_(153);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if (false) {
	  warning = function (condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }

	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }

	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }

	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}

	module.exports = warning;
	},{"153":153}]},{},[1])(1)
	});


/***/ },
/* 197 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 197;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const { DOM, createClass, PropTypes, createFactory } = __webpack_require__(196);
	const Tabs = createFactory(__webpack_require__(199).Tabs);

	const Menu = __webpack_require__(35);
	const MenuItem = __webpack_require__(36);

	// Shortcuts
	const { div } = DOM;

	/**
	 * Renders Tabbar component.
	 */
	let Tabbar = createClass({
	  displayName: "Tabbar",

	  propTypes: {
	    onSelect: PropTypes.func,
	    showAllTabsMenu: PropTypes.bool,
	    toolbox: PropTypes.object,
	  },

	  getDefaultProps: function () {
	    return {
	      showAllTabsMenu: false,
	    };
	  },

	  getInitialState: function () {
	    return {
	      tabs: [],
	      activeTab: 0
	    };
	  },

	  // Public API

	  addTab: function (id, title, selected = false, panel, url) {
	    let tabs = this.state.tabs.slice();
	    tabs.push({id, title, panel, url});

	    let newState = Object.assign({}, this.state, {
	      tabs: tabs,
	    });

	    if (selected) {
	      newState.activeTab = tabs.length - 1;
	    }

	    this.setState(newState);
	  },

	  toggleTab: function (tabId, isVisible) {
	    let index = this.getTabIndex(tabId);
	    if (index < 0) {
	      return;
	    }

	    let tabs = this.state.tabs.slice();
	    tabs[index] = Object.assign({}, tabs[index], {
	      isVisible: isVisible
	    });

	    this.setState(Object.assign({}, this.state, {
	      tabs: tabs,
	    }));
	  },

	  removeTab: function (tabId) {
	    let index = this.getTabIndex(tabId);
	    if (index < 0) {
	      return;
	    }

	    let tabs = this.state.tabs.slice();
	    tabs.splice(index, 1);

	    this.setState(Object.assign({}, this.state, {
	      tabs: tabs,
	    }));
	  },

	  select: function (tabId) {
	    let index = this.getTabIndex(tabId);
	    if (index < 0) {
	      return;
	    }

	    let newState = Object.assign({}, this.state, {
	      activeTab: index,
	    });

	    this.setState(newState, () => {
	      if (this.props.onSelect) {
	        this.props.onSelect(tabId);
	      }
	    });
	  },

	  // Helpers

	  getTabIndex: function (tabId) {
	    let tabIndex = -1;
	    this.state.tabs.forEach((tab, index) => {
	      if (tab.id == tabId) {
	        tabIndex = index;
	      }
	    });
	    return tabIndex;
	  },

	  getTabId: function (index) {
	    return this.state.tabs[index].id;
	  },

	  getCurrentTabId: function () {
	    return this.state.tabs[this.state.activeTab].id;
	  },

	  // Event Handlers

	  onTabChanged: function (index) {
	    this.setState({
	      activeTab: index
	    });

	    if (this.props.onSelect) {
	      this.props.onSelect(this.state.tabs[index].id);
	    }
	  },

	  onAllTabsMenuClick: function (event) {
	    let menu = new Menu();
	    let target = event.target;

	    // Generate list of menu items from the list of tabs.
	    this.state.tabs.forEach(tab => {
	      menu.append(new MenuItem({
	        label: tab.title,
	        type: "checkbox",
	        checked: this.getCurrentTabId() == tab.id,
	        click: () => this.select(tab.id),
	      }));
	    });

	    // Show a drop down menu with frames.
	    // XXX Missing menu API for specifying target (anchor)
	    // and relative position to it. See also:
	    // https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Method/openPopup
	    // https://bugzilla.mozilla.org/show_bug.cgi?id=1274551
	    let rect = target.getBoundingClientRect();
	    let screenX = target.ownerDocument.defaultView.mozInnerScreenX;
	    let screenY = target.ownerDocument.defaultView.mozInnerScreenY;
	    menu.popup(rect.left + screenX, rect.bottom + screenY, this.props.toolbox);

	    return menu;
	  },

	  // Rendering

	  renderTab: function (tab) {
	    if (typeof tab.panel === "function") {
	      return tab.panel({
	        key: tab.id,
	        title: tab.title,
	        id: tab.id,
	        url: tab.url,
	      });
	    }

	    return tab.panel;
	  },

	  render: function () {
	    let tabs = this.state.tabs.map(tab => {
	      return this.renderTab(tab);
	    });

	    return (
	      div({className: "devtools-sidebar-tabs"},
	        Tabs({
	          onAllTabsMenuClick: this.onAllTabsMenuClick,
	          showAllTabsMenu: this.props.showAllTabsMenu,
	          tabActive: this.state.activeTab,
	          onAfterChange: this.onTabChanged},
	          tabs
	        )
	      )
	    );
	  },
	});

	module.exports = Tabbar;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	  const React = __webpack_require__(196);
	  const { DOM } = React;
	  const { findDOMNode } = __webpack_require__(200);

	  /**
	   * Renders simple 'tab' widget.
	   *
	   * Based on ReactSimpleTabs component
	   * https://github.com/pedronauck/react-simpletabs
	   *
	   * Component markup (+CSS) example:
	   *
	   * <div class='tabs'>
	   *  <nav class='tabs-navigation'>
	   *    <ul class='tabs-menu'>
	   *      <li class='tabs-menu-item is-active'>Tab #1</li>
	   *      <li class='tabs-menu-item'>Tab #2</li>
	   *    </ul>
	   *  </nav>
	   *  <div class='panels'>
	   *    The content of active panel here
	   *  </div>
	   * <div>
	   */
	  let Tabs = React.createClass({
	    displayName: "Tabs",

	    propTypes: {
	      className: React.PropTypes.oneOfType([
	        React.PropTypes.array,
	        React.PropTypes.string,
	        React.PropTypes.object
	      ]),
	      tabActive: React.PropTypes.number,
	      onMount: React.PropTypes.func,
	      onBeforeChange: React.PropTypes.func,
	      onAfterChange: React.PropTypes.func,
	      children: React.PropTypes.oneOfType([
	        React.PropTypes.array,
	        React.PropTypes.element
	      ]).isRequired,
	      showAllTabsMenu: React.PropTypes.bool,
	      onAllTabsMenuClick: React.PropTypes.func,
	    },

	    getDefaultProps: function () {
	      return {
	        tabActive: 0,
	        showAllTabsMenu: false,
	      };
	    },

	    getInitialState: function () {
	      return {
	        tabActive: this.props.tabActive,

	        // This array is used to store an information whether a tab
	        // at specific index has already been created (e.g. selected
	        // at least once).
	        // If yes, it's rendered even if not currently selected.
	        // This is because in some cases we don't want to re-create
	        // tab content when it's being unselected/selected.
	        // E.g. in case of an iframe being used as a tab-content
	        // we want the iframe to stay in the DOM.
	        created: [],

	        // True if tabs can't fit into available horizontal space.
	        overflow: false,
	      };
	    },

	    componentDidMount: function () {
	      let node = findDOMNode(this);
	      node.addEventListener("keydown", this.onKeyDown, false);

	      // Register overflow listeners to manage visibility
	      // of all-tabs-menu. This menu is displayed when there
	      // is not enough h-space to render all tabs.
	      // It allows the user to select a tab even if it's hidden.
	      if (this.props.showAllTabsMenu) {
	        node.addEventListener("overflow", this.onOverflow, false);
	        node.addEventListener("underflow", this.onUnderflow, false);
	      }

	      let index = this.state.tabActive;
	      if (this.props.onMount) {
	        this.props.onMount(index);
	      }
	    },

	    componentWillReceiveProps: function (newProps) {
	      // Check type of 'tabActive' props to see if it's valid
	      // (it's 0-based index).
	      if (typeof newProps.tabActive == "number") {
	        let created = [...this.state.created];
	        created[newProps.tabActive] = true;

	        this.setState(Object.assign({}, this.state, {
	          tabActive: newProps.tabActive,
	          created: created,
	        }));
	      }
	    },

	    componentWillUnmount: function () {
	      let node = findDOMNode(this);
	      node.removeEventListener("keydown", this.onKeyDown, false);

	      if (this.props.showAllTabsMenu) {
	        node.removeEventListener("overflow", this.onOverflow, false);
	        node.removeEventListener("underflow", this.onUnderflow, false);
	      }
	    },

	    // DOM Events

	    onOverflow: function (event) {
	      if (event.target.classList.contains("tabs-menu")) {
	        this.setState({
	          overflow: true
	        });
	      }
	    },

	    onUnderflow: function (event) {
	      if (event.target.classList.contains("tabs-menu")) {
	        this.setState({
	          overflow: false
	        });
	      }
	    },

	    onKeyDown: function (event) {
	      // Bail out if the focus isn't on a tab.
	      if (!event.target.closest(".tabs-menu-item")) {
	        return;
	      }

	      let tabActive = this.state.tabActive;
	      let tabCount = this.props.children.length;

	      switch (event.code) {
	        case "ArrowRight":
	          tabActive = Math.min(tabCount - 1, tabActive + 1);
	          break;
	        case "ArrowLeft":
	          tabActive = Math.max(0, tabActive - 1);
	          break;
	      }

	      if (this.state.tabActive != tabActive) {
	        this.setActive(tabActive);
	      }
	    },

	    onClickTab: function (index, event) {
	      this.setActive(index);
	      event.preventDefault();
	    },

	    onAllTabsMenuClick: function (event) {
	      if (this.props.onAllTabsMenuClick) {
	        this.props.onAllTabsMenuClick(event);
	      }
	    },

	    // API

	    setActive: function (index) {
	      let onAfterChange = this.props.onAfterChange;
	      let onBeforeChange = this.props.onBeforeChange;

	      if (onBeforeChange) {
	        let cancel = onBeforeChange(index);
	        if (cancel) {
	          return;
	        }
	      }

	      let created = [...this.state.created];
	      created[index] = true;

	      let newState = Object.assign({}, this.state, {
	        tabActive: index,
	        created: created
	      });

	      this.setState(newState, () => {
	        // Properly set focus on selected tab.
	        let node = findDOMNode(this);
	        let selectedTab = node.querySelector(".is-active > a");
	        if (selectedTab) {
	          selectedTab.focus();
	        }

	        if (onAfterChange) {
	          onAfterChange(index);
	        }
	      });
	    },

	    // Rendering

	    renderMenuItems: function () {
	      if (!this.props.children) {
	        throw new Error("There must be at least one Tab");
	      }

	      if (!Array.isArray(this.props.children)) {
	        this.props.children = [this.props.children];
	      }

	      let tabs = this.props.children
	        .map(tab => {
	          return typeof tab === "function" ? tab() : tab;
	        }).filter(tab => {
	          return tab;
	        }).map((tab, index) => {
	          let ref = ("tab-menu-" + index);
	          let title = tab.props.title;
	          let tabClassName = tab.props.className;
	          let isTabSelected = this.state.tabActive === index;

	          let classes = [
	            "tabs-menu-item",
	            tabClassName,
	            isTabSelected ? "is-active" : ""
	          ].join(" ");

	          // Set tabindex to -1 (except the selected tab) so, it's focusable,
	          // but not reachable via sequential tab-key navigation.
	          // Changing selected tab (and so, moving focus) is done through
	          // left and right arrow keys.
	          // See also `onKeyDown()` event handler.
	          return (
	            DOM.li({
	              ref: ref,
	              key: index,
	              id: "tab-" + index,
	              className: classes,
	              role: "presentation",
	            },
	              DOM.a({
	                tabIndex: this.state.tabActive === index ? 0 : -1,
	                "aria-controls": "panel-" + index,
	                "aria-selected": isTabSelected,
	                role: "tab",
	                onClick: this.onClickTab.bind(this, index),
	              },
	                title
	              )
	            )
	          );
	        });

	      // Display the menu only if there is not enough horizontal
	      // space for all tabs (and overflow happened).
	      let allTabsMenu = this.state.overflow ? (
	        DOM.div({
	          className: "all-tabs-menu",
	          onClick: this.props.onAllTabsMenuClick
	        })
	      ) : null;

	      return (
	        DOM.nav({className: "tabs-navigation"},
	          DOM.ul({className: "tabs-menu", role: "tablist"},
	            tabs
	          ),
	          allTabsMenu
	        )
	      );
	    },

	    renderPanels: function () {
	      if (!this.props.children) {
	        throw new Error("There must be at least one Tab");
	      }

	      if (!Array.isArray(this.props.children)) {
	        this.props.children = [this.props.children];
	      }

	      let selectedIndex = this.state.tabActive;

	      let panels = this.props.children
	        .map(tab => {
	          return typeof tab === "function" ? tab() : tab;
	        }).filter(tab => {
	          return tab;
	        }).map((tab, index) => {
	          let selected = selectedIndex == index;

	          // Use 'visibility:hidden' + 'width/height:0' for hiding
	          // content of non-selected tab. It's faster (not sure why)
	          // than display:none and visibility:collapse.
	          let style = {
	            visibility: selected ? "visible" : "hidden",
	            height: selected ? "100%" : "0",
	            width: selected ? "100%" : "0",
	          };

	          return (
	            DOM.div({
	              key: index,
	              id: "panel-" + index,
	              style: style,
	              className: "tab-panel-box",
	              role: "tabpanel",
	              "aria-labelledby": "tab-" + index,
	            },
	              (selected || this.state.created[index]) ? tab : null
	            )
	          );
	        });

	      return (
	        DOM.div({className: "panels"},
	          panels
	        )
	      );
	    },

	    render: function () {
	      let classNames = ["tabs", this.props.className].join(" ");

	      return (
	        DOM.div({className: classNames},
	          this.renderMenuItems(),
	          this.renderPanels()
	        )
	      );
	    },
	  });

	  /**
	   * Renders simple tab 'panel'.
	   */
	  let Panel = React.createClass({
	    displayName: "Panel",

	    propTypes: {
	      title: React.PropTypes.string.isRequired,
	      children: React.PropTypes.oneOfType([
	        React.PropTypes.array,
	        React.PropTypes.element
	      ]).isRequired
	    },

	    render: function () {
	      return DOM.div({className: "tab-panel"},
	        this.props.children
	      );
	    }
	  });

	  // Exports from this module
	  exports.TabPanel = Panel;
	  exports.Tabs = Tabs;
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * ReactDOM v0.14.1
	 *
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */
	// Based off https://github.com/ForbesLindesay/umd/blob/master/template.js
	;(function(f) {
	  // CommonJS
	  if (true) {
	    module.exports = f(__webpack_require__(196));

	  // RequireJS
	  } else if (typeof define === "function" && define.amd) {
	    define(['devtools/client/shared/vendor/react'], f);

	  // <script>
	  } else {
	    var g
	    if (typeof window !== "undefined") {
	      g = window;
	    } else if (typeof global !== "undefined") {
	      g = global;
	    } else if (typeof self !== "undefined") {
	      g = self;
	    } else {
	      // works providing we're not in "use strict";
	      // needed for Java 8 Nashorn
	      // see https://github.com/facebook/react/issues/3037
	      g = this;
	    }
	    g.ReactDOM = f(g.React);
	  }

	})(function(React) {
	  return React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
	});


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {KeyCodes} = __webpack_require__(16);

	const PANE_APPEARANCE_DELAY = 50;
	const PAGE_SIZE_ITEM_COUNT_RATIO = 5;
	const WIDGET_FOCUSABLE_NODES = new Set(["vbox", "hbox"]);

	var namedTimeoutsStore = new Map();

	/**
	 * Inheritance helpers from the addon SDK's core/heritage.
	 * Remove these when all devtools are loadered.
	 */
	exports.Heritage = {
	  /**
	   * @see extend in sdk/core/heritage.
	   */
	  extend: function (prototype, properties = {}) {
	    return Object.create(prototype, this.getOwnPropertyDescriptors(properties));
	  },

	  /**
	   * @see getOwnPropertyDescriptors in sdk/core/heritage.
	   */
	  getOwnPropertyDescriptors: function (object) {
	    return Object.getOwnPropertyNames(object).reduce((descriptor, name) => {
	      descriptor[name] = Object.getOwnPropertyDescriptor(object, name);
	      return descriptor;
	    }, {});
	  }
	};

	/**
	 * Helper for draining a rapid succession of events and invoking a callback
	 * once everything settles down.
	 *
	 * @param string id
	 *        A string identifier for the named timeout.
	 * @param number wait
	 *        The amount of milliseconds to wait after no more events are fired.
	 * @param function callback
	 *        Invoked when no more events are fired after the specified time.
	 */
	const setNamedTimeout = function setNamedTimeout(id, wait, callback) {
	  clearNamedTimeout(id);

	  namedTimeoutsStore.set(id, setTimeout(() =>
	    namedTimeoutsStore.delete(id) && callback(), wait));
	};
	exports.setNamedTimeout = setNamedTimeout;

	/**
	 * Clears a named timeout.
	 * @see setNamedTimeout
	 *
	 * @param string id
	 *        A string identifier for the named timeout.
	 */
	const clearNamedTimeout = function clearNamedTimeout(id) {
	  if (!namedTimeoutsStore) {
	    return;
	  }
	  clearTimeout(namedTimeoutsStore.get(id));
	  namedTimeoutsStore.delete(id);
	};
	exports.clearNamedTimeout = clearNamedTimeout;

	/**
	 * Same as `setNamedTimeout`, but invokes the callback only if the provided
	 * predicate function returns true. Otherwise, the timeout is re-triggered.
	 *
	 * @param string id
	 *        A string identifier for the conditional timeout.
	 * @param number wait
	 *        The amount of milliseconds to wait after no more events are fired.
	 * @param function predicate
	 *        The predicate function used to determine whether the timeout restarts.
	 * @param function callback
	 *        Invoked when no more events are fired after the specified time, and
	 *        the provided predicate function returns true.
	 */
	const setConditionalTimeout = function setConditionalTimeout(id, wait,
	                                                             predicate,
	                                                             callback) {
	  setNamedTimeout(id, wait, function maybeCallback() {
	    if (predicate()) {
	      callback();
	      return;
	    }
	    setConditionalTimeout(id, wait, predicate, callback);
	  });
	};
	exports.setConditionalTimeout = setConditionalTimeout;

	/**
	 * Clears a conditional timeout.
	 * @see setConditionalTimeout
	 *
	 * @param string id
	 *        A string identifier for the conditional timeout.
	 */
	const clearConditionalTimeout = function clearConditionalTimeout(id) {
	  clearNamedTimeout(id);
	};
	exports.clearConditionalTimeout = clearConditionalTimeout;

	/**
	 * Helpers for creating and messaging between UI components.
	 */
	const ViewHelpers = exports.ViewHelpers = {
	  /**
	   * Convenience method, dispatching a custom event.
	   *
	   * @param nsIDOMNode target
	   *        A custom target element to dispatch the event from.
	   * @param string type
	   *        The name of the event.
	   * @param any detail
	   *        The data passed when initializing the event.
	   * @return boolean
	   *         True if the event was cancelled or a registered handler
	   *         called preventDefault.
	   */
	  dispatchEvent: function (target, type, detail) {
	    if (!(target instanceof Node)) {
	      // Event cancelled.
	      return true;
	    }
	    let document = target.ownerDocument || target;
	    let dispatcher = target.ownerDocument ? target : document.documentElement;

	    let event = document.createEvent("CustomEvent");
	    event.initCustomEvent(type, true, true, detail);
	    return dispatcher.dispatchEvent(event);
	  },

	  /**
	   * Helper delegating some of the DOM attribute methods of a node to a widget.
	   *
	   * @param object widget
	   *        The widget to assign the methods to.
	   * @param nsIDOMNode node
	   *        A node to delegate the methods to.
	   */
	  delegateWidgetAttributeMethods: function (widget, node) {
	    widget.getAttribute =
	      widget.getAttribute || node.getAttribute.bind(node);
	    widget.setAttribute =
	      widget.setAttribute || node.setAttribute.bind(node);
	    widget.removeAttribute =
	      widget.removeAttribute || node.removeAttribute.bind(node);
	  },

	  /**
	   * Helper delegating some of the DOM event methods of a node to a widget.
	   *
	   * @param object widget
	   *        The widget to assign the methods to.
	   * @param nsIDOMNode node
	   *        A node to delegate the methods to.
	   */
	  delegateWidgetEventMethods: function (widget, node) {
	    widget.addEventListener =
	      widget.addEventListener || node.addEventListener.bind(node);
	    widget.removeEventListener =
	      widget.removeEventListener || node.removeEventListener.bind(node);
	  },

	  /**
	   * Checks if the specified object looks like it's been decorated by an
	   * event emitter.
	   *
	   * @return boolean
	   *         True if it looks, walks and quacks like an event emitter.
	   */
	  isEventEmitter: function (object) {
	    return object && object.on && object.off && object.once && object.emit;
	  },

	  /**
	   * Checks if the specified object is an instance of a DOM node.
	   *
	   * @return boolean
	   *         True if it's a node, false otherwise.
	   */
	  isNode: function (object) {
	    return object instanceof Node ||
	           object instanceof Element ||
	           object instanceof DocumentFragment;
	  },

	  /**
	   * Prevents event propagation when navigation keys are pressed.
	   *
	   * @param Event e
	   *        The event to be prevented.
	   */
	  preventScrolling: function (e) {
	    switch (e.keyCode) {
	      case KeyCodes.DOM_VK_UP:
	      case KeyCodes.DOM_VK_DOWN:
	      case KeyCodes.DOM_VK_LEFT:
	      case KeyCodes.DOM_VK_RIGHT:
	      case KeyCodes.DOM_VK_PAGE_UP:
	      case KeyCodes.DOM_VK_PAGE_DOWN:
	      case KeyCodes.DOM_VK_HOME:
	      case KeyCodes.DOM_VK_END:
	        e.preventDefault();
	        e.stopPropagation();
	    }
	  },

	  /**
	   * Check if the enter key or space was pressed
	   *
	   * @param event event
	   *        The event triggered by a keypress on an element
	   */
	  isSpaceOrReturn: function (event) {
	    return event.keyCode === KeyCodes.DOM_VK_SPACE ||
	          event.keyCode === KeyCodes.DOM_VK_RETURN;
	  },

	  /**
	   * Sets a toggled pane hidden or visible. The pane can either be displayed on
	   * the side (right or left depending on the locale) or at the bottom.
	   *
	   * @param object flags
	   *        An object containing some of the following properties:
	   *        - visible: true if the pane should be shown, false to hide
	   *        - animated: true to display an animation on toggle
	   *        - delayed: true to wait a few cycles before toggle
	   *        - callback: a function to invoke when the toggle finishes
	   * @param nsIDOMNode pane
	   *        The element representing the pane to toggle.
	   */
	  togglePane: function (flags, pane) {
	    // Make sure a pane is actually available first.
	    if (!pane) {
	      return;
	    }

	    // Hiding is always handled via margins, not the hidden attribute.
	    pane.removeAttribute("hidden");

	    // Add a class to the pane to handle min-widths, margins and animations.
	    pane.classList.add("generic-toggled-pane");

	    // Avoid useless toggles.
	    if (flags.visible == !pane.classList.contains("pane-collapsed")) {
	      if (flags.callback) {
	        flags.callback();
	      }
	      return;
	    }

	    // The "animated" attributes enables animated toggles (slide in-out).
	    if (flags.animated) {
	      pane.setAttribute("animated", "");
	    } else {
	      pane.removeAttribute("animated");
	    }

	    // Computes and sets the pane margins in order to hide or show it.
	    let doToggle = () => {
	      // Negative margins are applied to "right" and "left" to support RTL and
	      // LTR directions, as well as to "bottom" to support vertical layouts.
	      // Unnecessary negative margins are forced to 0 via CSS in widgets.css.
	      if (flags.visible) {
	        pane.style.marginLeft = "0";
	        pane.style.marginRight = "0";
	        pane.style.marginBottom = "0";
	        pane.classList.remove("pane-collapsed");
	      } else {
	        let width = Math.floor(pane.getAttribute("width")) + 1;
	        let height = Math.floor(pane.getAttribute("height")) + 1;
	        pane.style.marginLeft = -width + "px";
	        pane.style.marginRight = -width + "px";
	        pane.style.marginBottom = -height + "px";
	        pane.classList.add("pane-collapsed");
	      }

	      // Wait for the animation to end before calling afterToggle()
	      if (flags.animated) {
	        pane.addEventListener("transitionend", function onEvent() {
	          pane.removeEventListener("transitionend", onEvent, false);
	          // Prevent unwanted transitions: if the panel is hidden and the layout
	          // changes margins will be updated and the panel will pop out.
	          pane.removeAttribute("animated");
	          if (flags.callback) {
	            flags.callback();
	          }
	        }, false);
	      } else if (flags.callback) {
	        // Invoke the callback immediately since there's no transition.
	        flags.callback();
	      }
	    };

	    // Sometimes it's useful delaying the toggle a few ticks to ensure
	    // a smoother slide in-out animation.
	    if (flags.delayed) {
	      pane.ownerDocument.defaultView.setTimeout(doToggle,
	                                                PANE_APPEARANCE_DELAY);
	    } else {
	      doToggle();
	    }
	  }
	};

	/**
	 * A generic Item is used to describe children present in a Widget.
	 *
	 * This is basically a very thin wrapper around an nsIDOMNode, with a few
	 * characteristics, like a `value` and an `attachment`.
	 *
	 * The characteristics are optional, and their meaning is entirely up to you.
	 * - The `value` should be a string, passed as an argument.
	 * - The `attachment` is any kind of primitive or object, passed as an argument.
	 *
	 * Iterable via "for (let childItem of parentItem) { }".
	 *
	 * @param object ownerView
	 *        The owner view creating this item.
	 * @param nsIDOMNode element
	 *        A prebuilt node to be wrapped.
	 * @param string value
	 *        A string identifying the node.
	 * @param any attachment
	 *        Some attached primitive/object.
	 */
	function Item(ownerView, element, value, attachment) {
	  this.ownerView = ownerView;
	  this.attachment = attachment;
	  this._value = value + "";
	  this._prebuiltNode = element;
	  this._itemsByElement = new Map();
	}

	Item.prototype = {
	  get value() {
	    return this._value;
	  },
	  get target() {
	    return this._target;
	  },
	  get prebuiltNode() {
	    return this._prebuiltNode;
	  },

	  /**
	   * Immediately appends a child item to this item.
	   *
	   * @param nsIDOMNode element
	   *        An nsIDOMNode representing the child element to append.
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attachment: some attached primitive/object for the item
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function invoked when the child item is removed
	   * @return Item
	   *         The item associated with the displayed element.
	   */
	  append: function (element, options = {}) {
	    let item = new Item(this, element, "", options.attachment);

	    // Entangle the item with the newly inserted child node.
	    // Make sure this is done with the value returned by appendChild(),
	    // to avoid storing a potential DocumentFragment.
	    this._entangleItem(item, this._target.appendChild(element));

	    // Handle any additional options after entangling the item.
	    if (options.attributes) {
	      options.attributes.forEach(e => item._target.setAttribute(e[0], e[1]));
	    }
	    if (options.finalize) {
	      item.finalize = options.finalize;
	    }

	    // Return the item associated with the displayed element.
	    return item;
	  },

	  /**
	   * Immediately removes the specified child item from this item.
	   *
	   * @param Item item
	   *        The item associated with the element to remove.
	   */
	  remove: function (item) {
	    if (!item) {
	      return;
	    }
	    this._target.removeChild(item._target);
	    this._untangleItem(item);
	  },

	  /**
	   * Entangles an item (model) with a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   * @param nsIDOMNode element
	   *        The element displaying the item.
	   */
	  _entangleItem: function (item, element) {
	    this._itemsByElement.set(element, item);
	    item._target = element;
	  },

	  /**
	   * Untangles an item (model) from a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _untangleItem: function (item) {
	    if (item.finalize) {
	      item.finalize(item);
	    }
	    for (let childItem of item) {
	      item.remove(childItem);
	    }

	    this._unlinkItem(item);
	    item._target = null;
	  },

	  /**
	   * Deletes an item from the its parent's storage maps.
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _unlinkItem: function (item) {
	    this._itemsByElement.delete(item._target);
	  },

	  /**
	   * Returns a string representing the object.
	   * Avoid using `toString` to avoid accidental JSONification.
	   * @return string
	   */
	  stringify: function () {
	    return JSON.stringify({
	      value: this._value,
	      target: this._target + "",
	      prebuiltNode: this._prebuiltNode + "",
	      attachment: this.attachment
	    }, null, 2);
	  },

	  _value: "",
	  _target: null,
	  _prebuiltNode: null,
	  finalize: null,
	  attachment: null
	};

	/**
	 * Some generic Widget methods handling Item instances.
	 * Iterable via "for (let childItem of wrappedView) { }".
	 *
	 * Usage:
	 *   function MyView() {
	 *     this.widget = new MyWidget(document.querySelector(".my-node"));
	 *   }
	 *
	 *   MyView.prototype = Heritage.extend(WidgetMethods, {
	 *     myMethod: function() {},
	 *     ...
	 *   });
	 *
	 * See https://gist.github.com/victorporof/5749386 for more details.
	 * The devtools/shared/widgets/SimpleListWidget.jsm is an implementation
	 * example.
	 *
	 * Language:
	 *   - An "item" is an instance of an Item.
	 *   - An "element" or "node" is a nsIDOMNode.
	 *
	 * The supplied widget can be any object implementing the following
	 * methods:
	 *   - function:nsIDOMNode insertItemAt(aIndex:number, aNode:nsIDOMNode,
	 *                                      aValue:string)
	 *   - function:nsIDOMNode getItemAtIndex(aIndex:number)
	 *   - function removeChild(aChild:nsIDOMNode)
	 *   - function removeAllItems()
	 *   - get:nsIDOMNode selectedItem()
	 *   - set selectedItem(aChild:nsIDOMNode)
	 *   - function getAttribute(aName:string)
	 *   - function setAttribute(aName:string, aValue:string)
	 *   - function removeAttribute(aName:string)
	 *   - function addEventListener(aName:string, aCallback:function,
	 *                               aBubbleFlag:boolean)
	 *   - function removeEventListener(aName:string, aCallback:function,
	 *                                  aBubbleFlag:boolean)
	 *
	 * Optional methods that can be implemented by the widget:
	 *   - function ensureElementIsVisible(aChild:nsIDOMNode)
	 *
	 * Optional attributes that may be handled (when calling
	 * get/set/removeAttribute):
	 *   - "emptyText": label temporarily added when there are no items present
	 *   - "headerText": label permanently added as a header
	 *
	 * For automagical keyboard and mouse accessibility, the widget should be an
	 * event emitter with the following events:
	 *   - "keyPress" -> (aName:string, aEvent:KeyboardEvent)
	 *   - "mousePress" -> (aName:string, aEvent:MouseEvent)
	 */
	const WidgetMethods = exports.WidgetMethods = {
	  /**
	   * Sets the element node or widget associated with this container.
	   * @param nsIDOMNode | object widget
	   */
	  set widget(widget) {
	    this._widget = widget;

	    // Can't use a WeakMap for _itemsByValue because keys are strings, and
	    // can't use one for _itemsByElement either, since it needs to be iterable.
	    this._itemsByValue = new Map();
	    this._itemsByElement = new Map();
	    this._stagedItems = [];

	    // Handle internal events emitted by the widget if necessary.
	    if (ViewHelpers.isEventEmitter(widget)) {
	      widget.on("keyPress", this._onWidgetKeyPress.bind(this));
	      widget.on("mousePress", this._onWidgetMousePress.bind(this));
	    }
	  },

	  /**
	   * Gets the element node or widget associated with this container.
	   * @return nsIDOMNode | object
	   */
	  get widget() {
	    return this._widget;
	  },

	  /**
	   * Prepares an item to be added to this container. This allows, for example,
	   * for a large number of items to be batched up before being sorted & added.
	   *
	   * If the "staged" flag is *not* set to true, the item will be immediately
	   * inserted at the correct position in this container, so that all the items
	   * still remain sorted. This can (possibly) be much slower than batching up
	   * multiple items.
	   *
	   * By default, this container assumes that all the items should be displayed
	   * sorted by their value. This can be overridden with the "index" flag,
	   * specifying on which position should an item be appended. The "staged" and
	   * "index" flags are mutually exclusive, meaning that all staged items
	   * will always be appended.
	   *
	   * @param nsIDOMNode element
	   *        A prebuilt node to be wrapped.
	   * @param string value
	   *        A string identifying the node.
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attachment: some attached primitive/object for the item
	   *          - staged: true to stage the item to be appended later
	   *          - index: specifies on which position should the item be appended
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function invoked when the item is removed
	   * @return Item
	   *         The item associated with the displayed element if an unstaged push,
	   *         undefined if the item was staged for a later commit.
	   */
	  push: function ([element, value], options = {}) {
	    let item = new Item(this, element, value, options.attachment);

	    // Batch the item to be added later.
	    if (options.staged) {
	      // An ulterior commit operation will ignore any specified index, so
	      // no reason to keep it around.
	      options.index = undefined;
	      return void this._stagedItems.push({ item: item, options: options });
	    }
	    // Find the target position in this container and insert the item there.
	    if (!("index" in options)) {
	      return this._insertItemAt(this._findExpectedIndexFor(item), item,
	                                options);
	    }
	    // Insert the item at the specified index. If negative or out of bounds,
	    // the item will be simply appended.
	    return this._insertItemAt(options.index, item, options);
	  },

	  /**
	   * Flushes all the prepared items into this container.
	   * Any specified index on the items will be ignored. Everything is appended.
	   *
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - sorted: true to sort all the items before adding them
	   */
	  commit: function (options = {}) {
	    let stagedItems = this._stagedItems;

	    // Sort the items before adding them to this container, if preferred.
	    if (options.sorted) {
	      stagedItems.sort((a, b) => this._currentSortPredicate(a.item, b.item));
	    }
	    // Append the prepared items to this container.
	    for (let { item, opt } of stagedItems) {
	      this._insertItemAt(-1, item, opt);
	    }
	    // Recreate the temporary items list for ulterior pushes.
	    this._stagedItems.length = 0;
	  },

	  /**
	   * Immediately removes the specified item from this container.
	   *
	   * @param Item item
	   *        The item associated with the element to remove.
	   */
	  remove: function (item) {
	    if (!item) {
	      return;
	    }
	    this._widget.removeChild(item._target);
	    this._untangleItem(item);

	    if (!this._itemsByElement.size) {
	      this._preferredValue = this.selectedValue;
	      this._widget.selectedItem = null;
	      this._widget.setAttribute("emptyText", this._emptyText);
	    }
	  },

	  /**
	   * Removes the item at the specified index from this container.
	   *
	   * @param number index
	   *        The index of the item to remove.
	   */
	  removeAt: function (index) {
	    this.remove(this.getItemAtIndex(index));
	  },

	  /**
	   * Removes the items in this container based on a predicate.
	   */
	  removeForPredicate: function (predicate) {
	    let item;
	    while ((item = this.getItemForPredicate(predicate))) {
	      this.remove(item);
	    }
	  },

	  /**
	   * Removes all items from this container.
	   */
	  empty: function () {
	    this._preferredValue = this.selectedValue;
	    this._widget.selectedItem = null;
	    this._widget.removeAllItems();
	    this._widget.setAttribute("emptyText", this._emptyText);

	    for (let [, item] of this._itemsByElement) {
	      this._untangleItem(item);
	    }

	    this._itemsByValue.clear();
	    this._itemsByElement.clear();
	    this._stagedItems.length = 0;
	  },

	  /**
	   * Ensures the specified item is visible in this container.
	   *
	   * @param Item item
	   *        The item to bring into view.
	   */
	  ensureItemIsVisible: function (item) {
	    this._widget.ensureElementIsVisible(item._target);
	  },

	  /**
	   * Ensures the item at the specified index is visible in this container.
	   *
	   * @param number index
	   *        The index of the item to bring into view.
	   */
	  ensureIndexIsVisible: function (index) {
	    this.ensureItemIsVisible(this.getItemAtIndex(index));
	  },

	  /**
	   * Sugar for ensuring the selected item is visible in this container.
	   */
	  ensureSelectedItemIsVisible: function () {
	    this.ensureItemIsVisible(this.selectedItem);
	  },

	  /**
	   * If supported by the widget, the label string temporarily added to this
	   * container when there are no child items present.
	   */
	  set emptyText(value) {
	    this._emptyText = value;

	    // Apply the emptyText attribute right now if there are no child items.
	    if (!this._itemsByElement.size) {
	      this._widget.setAttribute("emptyText", value);
	    }
	  },

	  /**
	   * If supported by the widget, the label string permanently added to this
	   * container as a header.
	   * @param string value
	   */
	  set headerText(value) {
	    this._headerText = value;
	    this._widget.setAttribute("headerText", value);
	  },

	  /**
	   * Toggles all the items in this container hidden or visible.
	   *
	   * This does not change the default filtering predicate, so newly inserted
	   * items will always be visible. Use WidgetMethods.filterContents if you care.
	   *
	   * @param boolean visibleFlag
	   *        Specifies the intended visibility.
	   */
	  toggleContents: function (visibleFlag) {
	    for (let [element] of this._itemsByElement) {
	      element.hidden = !visibleFlag;
	    }
	  },

	  /**
	   * Toggles all items in this container hidden or visible based on a predicate.
	   *
	   * @param function predicate [optional]
	   *        Items are toggled according to the return value of this function,
	   *        which will become the new default filtering predicate in this
	   *        container.
	   *        If unspecified, all items will be toggled visible.
	   */
	  filterContents: function (predicate = this._currentFilterPredicate) {
	    this._currentFilterPredicate = predicate;

	    for (let [element, item] of this._itemsByElement) {
	      element.hidden = !predicate(item);
	    }
	  },

	  /**
	   * Sorts all the items in this container based on a predicate.
	   *
	   * @param function predicate [optional]
	   *        Items are sorted according to the return value of the function,
	   *        which will become the new default sorting predicate in this
	   *        container. If unspecified, all items will be sorted by their value.
	   */
	  sortContents: function (predicate = this._currentSortPredicate) {
	    let sortedItems = this.items.sort(this._currentSortPredicate = predicate);

	    for (let i = 0, len = sortedItems.length; i < len; i++) {
	      this.swapItems(this.getItemAtIndex(i), sortedItems[i]);
	    }
	  },

	  /**
	   * Visually swaps two items in this container.
	   *
	   * @param Item first
	   *        The first item to be swapped.
	   * @param Item second
	   *        The second item to be swapped.
	   */
	  swapItems: function (first, second) {
	    if (first == second) {
	      // We're just dandy, thank you.
	      return;
	    }
	    let { _prebuiltNode: firstPrebuiltTarget, _target: firstTarget } = first;
	    let { _prebuiltNode: secondPrebuiltTarget, _target: secondTarget } = second;

	    // If the two items were constructed with prebuilt nodes as
	    // DocumentFragments, then those DocumentFragments are now
	    // empty and need to be reassembled.
	    if (firstPrebuiltTarget instanceof DocumentFragment) {
	      for (let node of firstTarget.childNodes) {
	        firstPrebuiltTarget.appendChild(node.cloneNode(true));
	      }
	    }
	    if (secondPrebuiltTarget instanceof DocumentFragment) {
	      for (let node of secondTarget.childNodes) {
	        secondPrebuiltTarget.appendChild(node.cloneNode(true));
	      }
	    }

	    // 1. Get the indices of the two items to swap.
	    let i = this._indexOfElement(firstTarget);
	    let j = this._indexOfElement(secondTarget);

	    // 2. Remeber the selection index, to reselect an item, if necessary.
	    let selectedTarget = this._widget.selectedItem;
	    let selectedIndex = -1;
	    if (selectedTarget == firstTarget) {
	      selectedIndex = i;
	    } else if (selectedTarget == secondTarget) {
	      selectedIndex = j;
	    }

	    // 3. Silently nuke both items, nobody needs to know about this.
	    this._widget.removeChild(firstTarget);
	    this._widget.removeChild(secondTarget);
	    this._unlinkItem(first);
	    this._unlinkItem(second);

	    // 4. Add the items again, but reversing their indices.
	    this._insertItemAt.apply(this, i < j ? [i, second] : [j, first]);
	    this._insertItemAt.apply(this, i < j ? [j, first] : [i, second]);

	    // 5. Restore the previous selection, if necessary.
	    if (selectedIndex == i) {
	      this._widget.selectedItem = first._target;
	    } else if (selectedIndex == j) {
	      this._widget.selectedItem = second._target;
	    }

	    // 6. Let the outside world know that these two items were swapped.
	    ViewHelpers.dispatchEvent(first.target, "swap", [second, first]);
	  },

	  /**
	   * Visually swaps two items in this container at specific indices.
	   *
	   * @param number first
	   *        The index of the first item to be swapped.
	   * @param number second
	   *        The index of the second item to be swapped.
	   */
	  swapItemsAtIndices: function (first, second) {
	    this.swapItems(this.getItemAtIndex(first), this.getItemAtIndex(second));
	  },

	  /**
	   * Checks whether an item with the specified value is among the elements
	   * shown in this container.
	   *
	   * @param string value
	   *        The item's value.
	   * @return boolean
	   *         True if the value is known, false otherwise.
	   */
	  containsValue: function (value) {
	    return this._itemsByValue.has(value) ||
	           this._stagedItems.some(({ item }) => item._value == value);
	  },

	  /**
	   * Gets the "preferred value". This is the latest selected item's value,
	   * remembered just before emptying this container.
	   * @return string
	   */
	  get preferredValue() {
	    return this._preferredValue;
	  },

	  /**
	   * Retrieves the item associated with the selected element.
	   * @return Item | null
	   */
	  get selectedItem() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement);
	    }
	    return null;
	  },

	  /**
	   * Retrieves the selected element's index in this container.
	   * @return number
	   */
	  get selectedIndex() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._indexOfElement(selectedElement);
	    }
	    return -1;
	  },

	  /**
	   * Retrieves the value of the selected element.
	   * @return string
	   */
	  get selectedValue() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement)._value;
	    }
	    return "";
	  },

	  /**
	   * Retrieves the attachment of the selected element.
	   * @return object | null
	   */
	  get selectedAttachment() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement).attachment;
	    }
	    return null;
	  },

	  _selectItem: function (item) {
	    // A falsy item is allowed to invalidate the current selection.
	    let targetElement = item ? item._target : null;
	    let prevElement = this._widget.selectedItem;

	    // Make sure the selected item's target element is focused and visible.
	    if (this.autoFocusOnSelection && targetElement) {
	      targetElement.focus();
	    }

	    if (targetElement != prevElement) {
	      this._widget.selectedItem = targetElement;
	    }
	  },

	  /**
	   * Selects the element with the entangled item in this container.
	   * @param Item | function item
	   */
	  set selectedItem(item) {
	    // A predicate is allowed to select a specific item.
	    // If no item is matched, then the current selection is removed.
	    if (typeof item == "function") {
	      item = this.getItemForPredicate(item);
	    }

	    let targetElement = item ? item._target : null;
	    let prevElement = this._widget.selectedItem;

	    if (this.maintainSelectionVisible && targetElement) {
	      // Some methods are optional. See the WidgetMethods object documentation
	      // for a comprehensive list.
	      if ("ensureElementIsVisible" in this._widget) {
	        this._widget.ensureElementIsVisible(targetElement);
	      }
	    }

	    this._selectItem(item);

	    // Prevent selecting the same item again and avoid dispatching
	    // a redundant selection event, so return early.
	    if (targetElement != prevElement) {
	      let dispTarget = targetElement || prevElement;
	      let dispName = this.suppressSelectionEvents ? "suppressed-select"
	                                                  : "select";
	      ViewHelpers.dispatchEvent(dispTarget, dispName, item);
	    }
	  },

	  /**
	   * Selects the element at the specified index in this container.
	   * @param number index
	   */
	  set selectedIndex(index) {
	    let targetElement = this._widget.getItemAtIndex(index);
	    if (targetElement) {
	      this.selectedItem = this._itemsByElement.get(targetElement);
	      return;
	    }
	    this.selectedItem = null;
	  },

	  /**
	   * Selects the element with the specified value in this container.
	   * @param string value
	   */
	  set selectedValue(value) {
	    this.selectedItem = this._itemsByValue.get(value);
	  },

	  /**
	   * Deselects and re-selects an item in this container.
	   *
	   * Useful when you want a "select" event to be emitted, even though
	   * the specified item was already selected.
	   *
	   * @param Item | function item
	   * @see `set selectedItem`
	   */
	  forceSelect: function (item) {
	    this.selectedItem = null;
	    this.selectedItem = item;
	  },

	  /**
	   * Specifies if this container should try to keep the selected item visible.
	   * (For example, when new items are added the selection is brought into view).
	   */
	  maintainSelectionVisible: true,

	  /**
	   * Specifies if "select" events dispatched from the elements in this container
	   * when their respective items are selected should be suppressed or not.
	   *
	   * If this flag is set to true, then consumers of this container won't
	   * be normally notified when items are selected.
	   */
	  suppressSelectionEvents: false,

	  /**
	   * Focus this container the first time an element is inserted?
	   *
	   * If this flag is set to true, then when the first item is inserted in
	   * this container (and thus it's the only item available), its corresponding
	   * target element is focused as well.
	   */
	  autoFocusOnFirstItem: true,

	  /**
	   * Focus on selection?
	   *
	   * If this flag is set to true, then whenever an item is selected in
	   * this container (e.g. via the selectedIndex or selectedItem setters),
	   * its corresponding target element is focused as well.
	   *
	   * You can disable this flag, for example, to maintain a certain node
	   * focused but visually indicate a different selection in this container.
	   */
	  autoFocusOnSelection: true,

	  /**
	   * Focus on input (e.g. mouse click)?
	   *
	   * If this flag is set to true, then whenever an item receives user input in
	   * this container, its corresponding target element is focused as well.
	   */
	  autoFocusOnInput: true,

	  /**
	   * When focusing on input, allow right clicks?
	   * @see WidgetMethods.autoFocusOnInput
	   */
	  allowFocusOnRightClick: false,

	  /**
	   * The number of elements in this container to jump when Page Up or Page Down
	   * keys are pressed. If falsy, then the page size will be based on the
	   * number of visible items in the container.
	   */
	  pageSize: 0,

	  /**
	   * Focuses the first visible item in this container.
	   */
	  focusFirstVisibleItem: function () {
	    this.focusItemAtDelta(-this.itemCount);
	  },

	  /**
	   * Focuses the last visible item in this container.
	   */
	  focusLastVisibleItem: function () {
	    this.focusItemAtDelta(+this.itemCount);
	  },

	  /**
	   * Focuses the next item in this container.
	   */
	  focusNextItem: function () {
	    this.focusItemAtDelta(+1);
	  },

	  /**
	   * Focuses the previous item in this container.
	   */
	  focusPrevItem: function () {
	    this.focusItemAtDelta(-1);
	  },

	  /**
	   * Focuses another item in this container based on the index distance
	   * from the currently focused item.
	   *
	   * @param number delta
	   *        A scalar specifying by how many items should the selection change.
	   */
	  focusItemAtDelta: function (delta) {
	    // Make sure the currently selected item is also focused, so that the
	    // command dispatcher mechanism has a relative node to work with.
	    // If there's no selection, just select an item at a corresponding index
	    // (e.g. the first item in this container if delta <= 1).
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      selectedElement.focus();
	    } else {
	      this.selectedIndex = Math.max(0, delta - 1);
	      return;
	    }

	    let direction = delta > 0 ? "advanceFocus" : "rewindFocus";
	    let distance = Math.abs(Math[delta > 0 ? "ceil" : "floor"](delta));
	    while (distance--) {
	      if (!this._focusChange(direction)) {
	        // Out of bounds.
	        break;
	      }
	    }

	    // Synchronize the selected item as being the currently focused element.
	    this.selectedItem = this.getItemForElement(this._focusedElement);
	  },

	  /**
	   * Focuses the next or previous item in this container.
	   *
	   * @param string direction
	   *        Either "advanceFocus" or "rewindFocus".
	   * @return boolean
	   *         False if the focus went out of bounds and the first or last item
	   *         in this container was focused instead.
	   */
	  _focusChange: function (direction) {
	    let commandDispatcher = this._commandDispatcher;
	    let prevFocusedElement = commandDispatcher.focusedElement;
	    let currFocusedElement;

	    do {
	      commandDispatcher.suppressFocusScroll = true;
	      commandDispatcher[direction]();
	      currFocusedElement = commandDispatcher.focusedElement;

	      // Make sure the newly focused item is a part of this container. If the
	      // focus goes out of bounds, revert the previously focused item.
	      if (!this.getItemForElement(currFocusedElement)) {
	        prevFocusedElement.focus();
	        return false;
	      }
	    } while (!WIDGET_FOCUSABLE_NODES.has(currFocusedElement.tagName));

	    // Focus remained within bounds.
	    return true;
	  },

	  /**
	   * Gets the command dispatcher instance associated with this container's DOM.
	   * If there are no items displayed in this container, null is returned.
	   * @return nsIDOMXULCommandDispatcher | null
	   */
	  get _commandDispatcher() {
	    if (this._cachedCommandDispatcher) {
	      return this._cachedCommandDispatcher;
	    }
	    let someElement = this._widget.getItemAtIndex(0);
	    if (someElement) {
	      let commandDispatcher = someElement.ownerDocument.commandDispatcher;
	      this._cachedCommandDispatcher = commandDispatcher;
	      return commandDispatcher;
	    }
	    return null;
	  },

	  /**
	   * Gets the currently focused element in this container.
	   *
	   * @return nsIDOMNode
	   *         The focused element, or null if nothing is found.
	   */
	  get _focusedElement() {
	    let commandDispatcher = this._commandDispatcher;
	    if (commandDispatcher) {
	      return commandDispatcher.focusedElement;
	    }
	    return null;
	  },

	  /**
	   * Gets the item in the container having the specified index.
	   *
	   * @param number index
	   *        The index used to identify the element.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemAtIndex: function (index) {
	    return this.getItemForElement(this._widget.getItemAtIndex(index));
	  },

	  /**
	   * Gets the item in the container having the specified value.
	   *
	   * @param string value
	   *        The value used to identify the element.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemByValue: function (value) {
	    return this._itemsByValue.get(value);
	  },

	  /**
	   * Gets the item in the container associated with the specified element.
	   *
	   * @param nsIDOMNode element
	   *        The element used to identify the item.
	   * @param object flags [optional]
	   *        Additional options for showing the source. Supported options:
	   *          - noSiblings: if siblings shouldn't be taken into consideration
	   *                        when searching for the associated item.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemForElement: function (element, flags = {}) {
	    while (element) {
	      let item = this._itemsByElement.get(element);

	      // Also search the siblings if allowed.
	      if (!flags.noSiblings) {
	        item = item ||
	          this._itemsByElement.get(element.nextElementSibling) ||
	          this._itemsByElement.get(element.previousElementSibling);
	      }
	      if (item) {
	        return item;
	      }
	      element = element.parentNode;
	    }
	    return null;
	  },

	  /**
	   * Gets a visible item in this container validating a specified predicate.
	   *
	   * @param function predicate
	   *        The first item which validates this predicate is returned
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemForPredicate: function (predicate, owner = this) {
	    // Recursively check the items in this widget for a predicate match.
	    for (let [element, item] of owner._itemsByElement) {
	      let match;
	      if (predicate(item) && !element.hidden) {
	        match = item;
	      } else {
	        match = this.getItemForPredicate(predicate, item);
	      }
	      if (match) {
	        return match;
	      }
	    }
	    // Also check the staged items. No need to do this recursively since
	    // they're not even appended to the view yet.
	    for (let { item } of this._stagedItems) {
	      if (predicate(item)) {
	        return item;
	      }
	    }
	    return null;
	  },

	  /**
	   * Shortcut function for getItemForPredicate which works on item attachments.
	   * @see getItemForPredicate
	   */
	  getItemForAttachment: function (predicate, owner = this) {
	    return this.getItemForPredicate(e => predicate(e.attachment));
	  },

	  /**
	   * Finds the index of an item in the container.
	   *
	   * @param Item item
	   *        The item get the index for.
	   * @return number
	   *         The index of the matched item, or -1 if nothing is found.
	   */
	  indexOfItem: function (item) {
	    return this._indexOfElement(item._target);
	  },

	  /**
	   * Finds the index of an element in the container.
	   *
	   * @param nsIDOMNode element
	   *        The element get the index for.
	   * @return number
	   *         The index of the matched element, or -1 if nothing is found.
	   */
	  _indexOfElement: function (element) {
	    for (let i = 0; i < this._itemsByElement.size; i++) {
	      if (this._widget.getItemAtIndex(i) == element) {
	        return i;
	      }
	    }
	    return -1;
	  },

	  /**
	   * Gets the total number of items in this container.
	   * @return number
	   */
	  get itemCount() {
	    return this._itemsByElement.size;
	  },

	  /**
	   * Returns a list of items in this container, in the displayed order.
	   * @return array
	   */
	  get items() {
	    let store = [];
	    let itemCount = this.itemCount;
	    for (let i = 0; i < itemCount; i++) {
	      store.push(this.getItemAtIndex(i));
	    }
	    return store;
	  },

	  /**
	   * Returns a list of values in this container, in the displayed order.
	   * @return array
	   */
	  get values() {
	    return this.items.map(e => e._value);
	  },

	  /**
	   * Returns a list of attachments in this container, in the displayed order.
	   * @return array
	   */
	  get attachments() {
	    return this.items.map(e => e.attachment);
	  },

	  /**
	   * Returns a list of all the visible (non-hidden) items in this container,
	   * in the displayed order
	   * @return array
	   */
	  get visibleItems() {
	    return this.items.filter(e => !e._target.hidden);
	  },

	  /**
	   * Checks if an item is unique in this container. If an item's value is an
	   * empty string, "undefined" or "null", it is considered unique.
	   *
	   * @param Item item
	   *        The item for which to verify uniqueness.
	   * @return boolean
	   *         True if the item is unique, false otherwise.
	   */
	  isUnique: function (item) {
	    let value = item._value;
	    if (value == "" || value == "undefined" || value == "null") {
	      return true;
	    }
	    return !this._itemsByValue.has(value);
	  },

	  /**
	   * Checks if an item is eligible for this container. By default, this checks
	   * whether an item is unique and has a prebuilt target node.
	   *
	   * @param Item item
	   *        The item for which to verify eligibility.
	   * @return boolean
	   *         True if the item is eligible, false otherwise.
	   */
	  isEligible: function (item) {
	    return this.isUnique(item) && item._prebuiltNode;
	  },

	  /**
	   * Finds the expected item index in this container based on the default
	   * sort predicate.
	   *
	   * @param Item item
	   *        The item for which to get the expected index.
	   * @return number
	   *         The expected item index.
	   */
	  _findExpectedIndexFor: function (item) {
	    let itemCount = this.itemCount;
	    for (let i = 0; i < itemCount; i++) {
	      if (this._currentSortPredicate(this.getItemAtIndex(i), item) > 0) {
	        return i;
	      }
	    }
	    return itemCount;
	  },

	  /**
	   * Immediately inserts an item in this container at the specified index.
	   *
	   * @param number index
	   *        The position in the container intended for this item.
	   * @param Item item
	   *        The item describing a target element.
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function when the item is untangled (removed)
	   * @return Item
	   *         The item associated with the displayed element, null if rejected.
	   */
	  _insertItemAt: function (index, item, options = {}) {
	    if (!this.isEligible(item)) {
	      return null;
	    }

	    // Entangle the item with the newly inserted node.
	    // Make sure this is done with the value returned by insertItemAt(),
	    // to avoid storing a potential DocumentFragment.
	    let node = item._prebuiltNode;
	    let attachment = item.attachment;
	    this._entangleItem(item,
	                       this._widget.insertItemAt(index, node, attachment));

	    // Handle any additional options after entangling the item.
	    if (!this._currentFilterPredicate(item)) {
	      item._target.hidden = true;
	    }
	    if (this.autoFocusOnFirstItem && this._itemsByElement.size == 1) {
	      item._target.focus();
	    }
	    if (options.attributes) {
	      options.attributes.forEach(e => item._target.setAttribute(e[0], e[1]));
	    }
	    if (options.finalize) {
	      item.finalize = options.finalize;
	    }

	    // Hide the empty text if the selection wasn't lost.
	    this._widget.removeAttribute("emptyText");

	    // Return the item associated with the displayed element.
	    return item;
	  },

	  /**
	   * Entangles an item (model) with a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   * @param nsIDOMNode element
	   *        The element displaying the item.
	   */
	  _entangleItem: function (item, element) {
	    this._itemsByValue.set(item._value, item);
	    this._itemsByElement.set(element, item);
	    item._target = element;
	  },

	  /**
	   * Untangles an item (model) from a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _untangleItem: function (item) {
	    if (item.finalize) {
	      item.finalize(item);
	    }
	    for (let childItem of item) {
	      item.remove(childItem);
	    }

	    this._unlinkItem(item);
	    item._target = null;
	  },

	  /**
	   * Deletes an item from the its parent's storage maps.
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _unlinkItem: function (item) {
	    this._itemsByValue.delete(item._value);
	    this._itemsByElement.delete(item._target);
	  },

	  /**
	   * The keyPress event listener for this container.
	   * @param string name
	   * @param KeyboardEvent event
	   */
	  _onWidgetKeyPress: function (name, event) {
	    // Prevent scrolling when pressing navigation keys.
	    ViewHelpers.preventScrolling(event);

	    switch (event.keyCode) {
	      case KeyCodes.DOM_VK_UP:
	      case KeyCodes.DOM_VK_LEFT:
	        this.focusPrevItem();
	        return;
	      case KeyCodes.DOM_VK_DOWN:
	      case KeyCodes.DOM_VK_RIGHT:
	        this.focusNextItem();
	        return;
	      case KeyCodes.DOM_VK_PAGE_UP:
	        this.focusItemAtDelta(-(this.pageSize ||
	                               (this.itemCount / PAGE_SIZE_ITEM_COUNT_RATIO)));
	        return;
	      case KeyCodes.DOM_VK_PAGE_DOWN:
	        this.focusItemAtDelta(+(this.pageSize ||
	                               (this.itemCount / PAGE_SIZE_ITEM_COUNT_RATIO)));
	        return;
	      case KeyCodes.DOM_VK_HOME:
	        this.focusFirstVisibleItem();
	        return;
	      case KeyCodes.DOM_VK_END:
	        this.focusLastVisibleItem();
	        return;
	    }
	  },

	  /**
	   * The mousePress event listener for this container.
	   * @param string name
	   * @param MouseEvent event
	   */
	  _onWidgetMousePress: function (name, event) {
	    if (event.button != 0 && !this.allowFocusOnRightClick) {
	      // Only allow left-click to trigger this event.
	      return;
	    }

	    let item = this.getItemForElement(event.target);
	    if (item) {
	      // The container is not empty and we clicked on an actual item.
	      this.selectedItem = item;
	      // Make sure the current event's target element is also focused.
	      this.autoFocusOnInput && item._target.focus();
	    }
	  },

	  /**
	   * The predicate used when filtering items. By default, all items in this
	   * view are visible.
	   *
	   * @param Item item
	   *        The item passing through the filter.
	   * @return boolean
	   *         True if the item should be visible, false otherwise.
	   */
	  _currentFilterPredicate: function (item) {
	    return true;
	  },

	  /**
	   * The predicate used when sorting items. By default, items in this view
	   * are sorted by their label.
	   *
	   * @param Item first
	   *        The first item used in the comparison.
	   * @param Item second
	   *        The second item used in the comparison.
	   * @return number
	   *         -1 to sort first to a lower index than second
	   *          0 to leave first and second unchanged with respect to each other
	   *          1 to sort second to a lower index than first
	   */
	  _currentSortPredicate: function (first, second) {
	    return +(first._value.toLowerCase() > second._value.toLowerCase());
	  },

	  /**
	   * Call a method on this widget named `methodName`. Any further arguments are
	   * passed on to the method. Returns the result of the method call.
	   *
	   * @param String methodName
	   *        The name of the method you want to call.
	   * @param args
	   *        Optional. Any arguments you want to pass through to the method.
	   */
	  callMethod: function (methodName, ...args) {
	    return this._widget[methodName].apply(this._widget, args);
	  },

	  _widget: null,
	  _emptyText: "",
	  _headerText: "",
	  _preferredValue: "",
	  _cachedCommandDispatcher: null
	};

	/**
	 * A generator-iterator over all the items in this container.
	 */
	Item.prototype[Symbol.iterator] =
	WidgetMethods[Symbol.iterator] = function* () {
	  yield* this._itemsByElement.values();
	};


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const { Cu } = __webpack_require__(11);
	const nodeConstants = __webpack_require__(33);
	const { getRootBindingParent } = __webpack_require__(203);
	var EventEmitter = __webpack_require__(6);

	/**
	 * API
	 *
	 *   new Selection(walker=null)
	 *   destroy()
	 *   node (readonly)
	 *   setNode(node, origin="unknown")
	 *
	 * Helpers:
	 *
	 *   window
	 *   document
	 *   isRoot()
	 *   isNode()
	 *   isHTMLNode()
	 *
	 * Check the nature of the node:
	 *
	 *   isElementNode()
	 *   isAttributeNode()
	 *   isTextNode()
	 *   isCDATANode()
	 *   isEntityRefNode()
	 *   isEntityNode()
	 *   isProcessingInstructionNode()
	 *   isCommentNode()
	 *   isDocumentNode()
	 *   isDocumentTypeNode()
	 *   isDocumentFragmentNode()
	 *   isNotationNode()
	 *
	 * Events:
	 *   "new-node-front" when the inner node changed
	 *   "before-new-node-front" when the inner node is set to change
	 *   "attribute-changed" when an attribute is changed
	 *   "detached-front" when the node (or one of its parents) is removed from
	 *   the document
	 *   "reparented" when the node (or one of its parents) is moved under
	 *   a different node
	 */

	/**
	 * A Selection object. Hold a reference to a node.
	 * Includes some helpers, fire some helpful events.
	 */
	function Selection(walker) {
	  EventEmitter.decorate(this);

	  this._onMutations = this._onMutations.bind(this);
	  this.setWalker(walker);
	  this.setNode(null);
	}

	exports.Selection = Selection;

	Selection.prototype = {
	  _walker: null,
	  _node: null,

	  _onMutations: function (mutations) {
	    let attributeChange = false;
	    let pseudoChange = false;
	    let detached = false;
	    let parentNode = null;

	    for (let m of mutations) {
	      if (!attributeChange && m.type == "attributes") {
	        attributeChange = true;
	      }
	      if (m.type == "childList") {
	        if (!detached && !this.isConnected()) {
	          if (this.isNode()) {
	            parentNode = m.target;
	          }
	          detached = true;
	        }
	      }
	      if (m.type == "pseudoClassLock") {
	        pseudoChange = true;
	      }
	    }

	    // Fire our events depending on what changed in the mutations array
	    if (attributeChange) {
	      this.emit("attribute-changed");
	    }
	    if (pseudoChange) {
	      this.emit("pseudoclass");
	    }
	    if (detached) {
	      this.emit("detached-front", parentNode);
	    }
	  },

	  destroy: function () {
	    this.setNode(null);
	    this.setWalker(null);
	  },

	  setWalker: function (walker) {
	    if (this._walker) {
	      this._walker.off("mutations", this._onMutations);
	    }
	    this._walker = walker;
	    if (this._walker) {
	      this._walker.on("mutations", this._onMutations);
	    }
	  },

	  // Not remote-safe
	  setNode: function (value, reason = "unknown") {
	    if (value) {
	      value = this._walker.frontForRawNode(value);
	    }
	    this.setNodeFront(value, reason);
	  },

	  // Not remote-safe
	  get node() {
	    return this._node;
	  },

	  // Not remote-safe
	  get document() {
	    if (this.isNode()) {
	      return this.node.ownerDocument;
	    }
	    return null;
	  },

	  setNodeFront: function (value, reason = "unknown") {
	    this.reason = reason;

	    // If an inlineTextChild text node is being set, then set it's parent instead.
	    let parentNode = value && value.parentNode();
	    if (value && parentNode && parentNode.inlineTextChild === value) {
	      value = parentNode;
	    }

	    // We used to return here if the node had not changed but we now need to
	    // set the node even if it is already set otherwise it is not possible to
	    // e.g. highlight the same node twice.
	    let rawValue = null;
	    if (value && value.isLocalToBeDeprecated()) {
	      rawValue = value.rawNode();
	    }
	    this.emit("before-new-node-front", value, reason);
	    this._node = rawValue;
	    this._nodeFront = value;
	    this.emit("new-node-front", value, this.reason);
	  },

	  get documentFront() {
	    return this._walker.document(this._nodeFront);
	  },

	  get nodeFront() {
	    return this._nodeFront;
	  },

	  isRoot: function () {
	    return this.isNode() &&
	           this.isConnected() &&
	           this._nodeFront.isDocumentElement;
	  },

	  isNode: function () {
	    if (!this._nodeFront) {
	      return false;
	    }

	    // As long as tools are still accessing node.rawNode(),
	    // this needs to stay here.
	    if (this._node && Cu.isDeadWrapper(this._node)) {
	      return false;
	    }

	    return true;
	  },

	  isLocal: function () {
	    return !!this._node;
	  },

	  isConnected: function () {
	    let node = this._nodeFront;
	    if (!node || !node.actorID) {
	      return false;
	    }

	    // As long as there are still tools going around
	    // accessing node.rawNode, this needs to stay.
	    let rawNode = null;
	    if (node.isLocalToBeDeprecated()) {
	      rawNode = node.rawNode();
	    }
	    if (rawNode) {
	      try {
	        let doc = this.document;
	        if (doc && doc.defaultView) {
	          let docEl = doc.documentElement;
	          let bindingParent = getRootBindingParent(rawNode);

	          if (docEl.contains(bindingParent)) {
	            return true;
	          }
	        }
	      } catch (e) {
	        // "can't access dead object" error
	      }
	      return false;
	    }

	    while (node) {
	      if (node === this._walker.rootNode) {
	        return true;
	      }
	      node = node.parentNode();
	    }
	    return false;
	  },

	  isHTMLNode: function () {
	    let xhtmlNs = "http://www.w3.org/1999/xhtml";
	    return this.isNode() && this.nodeFront.namespaceURI == xhtmlNs;
	  },

	  // Node type

	  isElementNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == nodeConstants.ELEMENT_NODE;
	  },

	  isPseudoElementNode: function () {
	    return this.isNode() && this.nodeFront.isPseudoElement;
	  },

	  isAnonymousNode: function () {
	    return this.isNode() && this.nodeFront.isAnonymous;
	  },

	  isAttributeNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == nodeConstants.ATTRIBUTE_NODE;
	  },

	  isTextNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == nodeConstants.TEXT_NODE;
	  },

	  isCDATANode: function () {
	    return this.isNode() && this.nodeFront.nodeType == nodeConstants.CDATA_SECTION_NODE;
	  },

	  isEntityRefNode: function () {
	    return this.isNode() &&
	      this.nodeFront.nodeType == nodeConstants.ENTITY_REFERENCE_NODE;
	  },

	  isEntityNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == nodeConstants.ENTITY_NODE;
	  },

	  isProcessingInstructionNode: function () {
	    return this.isNode() &&
	      this.nodeFront.nodeType == nodeConstants.PROCESSING_INSTRUCTION_NODE;
	  },

	  isCommentNode: function () {
	    return this.isNode() &&
	      this.nodeFront.nodeType == nodeConstants.PROCESSING_INSTRUCTION_NODE;
	  },

	  isDocumentNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == nodeConstants.DOCUMENT_NODE;
	  },

	  /**
	   * @returns true if the selection is the <body> HTML element.
	   */
	  isBodyNode: function () {
	    return this.isHTMLNode() &&
	           this.isConnected() &&
	           this.nodeFront.nodeName === "BODY";
	  },

	  /**
	   * @returns true if the selection is the <head> HTML element.
	   */
	  isHeadNode: function () {
	    return this.isHTMLNode() &&
	           this.isConnected() &&
	           this.nodeFront.nodeName === "HEAD";
	  },

	  isDocumentTypeNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == nodeConstants.DOCUMENT_TYPE_NODE;
	  },

	  isDocumentFragmentNode: function () {
	    return this.isNode() &&
	      this.nodeFront.nodeType == nodeConstants.DOCUMENT_FRAGMENT_NODE;
	  },

	  isNotationNode: function () {
	    return this.isNode() && this.nodeFront.nodeType == nodeConstants.NOTATION_NODE;
	  },
	};


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const { Ci, Cc } = __webpack_require__(11);
	const nodeFilterConstants = __webpack_require__(192);

	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "setIgnoreLayoutChanges", "devtools/server/actors/layout", true);
	exports.setIgnoreLayoutChanges = (...args) =>
	  this.setIgnoreLayoutChanges(...args);

	/**
	 * Returns the `DOMWindowUtils` for the window given.
	 *
	 * @param {DOMWindow} win
	 * @returns {DOMWindowUtils}
	 */
	const utilsFor = win => win.QueryInterface(Ci.nsIInterfaceRequestor)
	                           .getInterface(Ci.nsIDOMWindowUtils);

	/**
	 * like win.top, but goes through mozbrowsers and mozapps iframes.
	 *
	 * @param {DOMWindow} win
	 * @return {DOMWindow}
	 */
	function getTopWindow(win) {
	  let docShell = win.QueryInterface(Ci.nsIInterfaceRequestor)
	                    .getInterface(Ci.nsIWebNavigation)
	                    .QueryInterface(Ci.nsIDocShell);

	  if (!docShell.isMozBrowserOrApp) {
	    return win.top;
	  }

	  let topDocShell =
	    docShell.getSameTypeRootTreeItemIgnoreBrowserAndAppBoundaries();

	  return topDocShell
	          ? topDocShell.contentViewer.DOMDocument.defaultView
	          : null;
	}

	exports.getTopWindow = getTopWindow;

	/**
	 * Returns `true` is the window given is a top level window.
	 * like win.top === win, but goes through mozbrowsers and mozapps iframes.
	 *
	 * @param {DOMWindow} win
	 * @return {Boolean}
	 */
	const isTopWindow = win => win && getTopWindow(win) === win;
	exports.isTopWindow = isTopWindow;

	/**
	   * Check a window is part of the boundary window given.
	   *
	   * @param {DOMWindow} boundaryWindow
	   * @param {DOMWindow} win
	   * @return {Boolean}
	   */
	function isWindowIncluded(boundaryWindow, win) {
	  if (win === boundaryWindow) {
	    return true;
	  }

	  let parent = getParentWindow(win);

	  if (!parent || parent === win) {
	    return false;
	  }

	  return isWindowIncluded(boundaryWindow, parent);
	}
	exports.isWindowIncluded = isWindowIncluded;

	/**
	 * like win.parent, but goes through mozbrowsers and mozapps iframes.
	 *
	 * @param {DOMWindow} win
	 * @return {DOMWindow}
	 */
	function getParentWindow(win) {
	  if (isTopWindow(win)) {
	    return null;
	  }

	  let docShell = win.QueryInterface(Ci.nsIInterfaceRequestor)
	                 .getInterface(Ci.nsIWebNavigation)
	                 .QueryInterface(Ci.nsIDocShell);

	  if (!docShell.isMozBrowserOrApp) {
	    return win.parent;
	  }

	  let parentDocShell =
	    docShell.getSameTypeParentIgnoreBrowserAndAppBoundaries();

	  return parentDocShell
	          ? parentDocShell.contentViewer.DOMDocument.defaultView
	          : null;
	}

	exports.getParentWindow = getParentWindow;

	/**
	 * like win.frameElement, but goes through mozbrowsers and mozapps iframes.
	 *
	 * @param {DOMWindow} win
	 *        The window to get the frame for
	 * @return {DOMNode}
	 *         The element in which the window is embedded.
	 */
	const getFrameElement = (win) =>
	  isTopWindow(win) ? null : utilsFor(win).containerElement;
	exports.getFrameElement = getFrameElement;

	/**
	 * Get the x/y offsets for of all the parent frames of a given node, limited to
	 * the boundary window given.
	 *
	 * @param {DOMWindow} boundaryWindow
	 *        The window where to stop to iterate. If `null` is given, the top
	 *        window is used.
	 * @param {DOMNode} node
	 *        The node for which we are to get the offset
	 * @return {Array}
	 *         The frame offset [x, y]
	 */
	function getFrameOffsets(boundaryWindow, node) {
	  let xOffset = 0;
	  let yOffset = 0;

	  let frameWin = getWindowFor(node);
	  let scale = getCurrentZoom(node);

	  if (boundaryWindow === null) {
	    boundaryWindow = getTopWindow(frameWin);
	  } else if (typeof boundaryWindow === "undefined") {
	    throw new Error("No boundaryWindow given. Use null for the default one.");
	  }

	  while (frameWin !== boundaryWindow) {
	    let frameElement = getFrameElement(frameWin);
	    if (!frameElement) {
	      break;
	    }

	    // We are in an iframe.
	    // We take into account the parent iframe position and its
	    // offset (borders and padding).
	    let frameRect = frameElement.getBoundingClientRect();

	    let [offsetTop, offsetLeft] = getFrameContentOffset(frameElement);

	    xOffset += frameRect.left + offsetLeft;
	    yOffset += frameRect.top + offsetTop;

	    frameWin = getParentWindow(frameWin);
	  }

	  return [xOffset * scale, yOffset * scale];
	}
	exports.getFrameOffsets = getFrameOffsets;

	/**
	 * Get box quads adjusted for iframes and zoom level.
	 *
	 * @param {DOMWindow} boundaryWindow
	 *        The window where to stop to iterate. If `null` is given, the top
	 *        window is used.
	 * @param {DOMNode} node
	 *        The node for which we are to get the box model region
	 *        quads.
	 * @param {String} region
	 *        The box model region to return: "content", "padding", "border" or
	 *        "margin".
	 * @return {Array}
	 *        An array of objects that have the same structure as quads returned by
	 *        getBoxQuads. An empty array if the node has no quads or is invalid.
	 */
	function getAdjustedQuads(boundaryWindow, node, region) {
	  if (!node || !node.getBoxQuads) {
	    return [];
	  }

	  let quads = node.getBoxQuads({
	    box: region
	  });

	  if (!quads.length) {
	    return [];
	  }

	  let [xOffset, yOffset] = getFrameOffsets(boundaryWindow, node);
	  let scale = getCurrentZoom(node);

	  let adjustedQuads = [];
	  for (let quad of quads) {
	    adjustedQuads.push({
	      p1: {
	        w: quad.p1.w * scale,
	        x: quad.p1.x * scale + xOffset,
	        y: quad.p1.y * scale + yOffset,
	        z: quad.p1.z * scale
	      },
	      p2: {
	        w: quad.p2.w * scale,
	        x: quad.p2.x * scale + xOffset,
	        y: quad.p2.y * scale + yOffset,
	        z: quad.p2.z * scale
	      },
	      p3: {
	        w: quad.p3.w * scale,
	        x: quad.p3.x * scale + xOffset,
	        y: quad.p3.y * scale + yOffset,
	        z: quad.p3.z * scale
	      },
	      p4: {
	        w: quad.p4.w * scale,
	        x: quad.p4.x * scale + xOffset,
	        y: quad.p4.y * scale + yOffset,
	        z: quad.p4.z * scale
	      },
	      bounds: {
	        bottom: quad.bounds.bottom * scale + yOffset,
	        height: quad.bounds.height * scale,
	        left: quad.bounds.left * scale + xOffset,
	        right: quad.bounds.right * scale + xOffset,
	        top: quad.bounds.top * scale + yOffset,
	        width: quad.bounds.width * scale,
	        x: quad.bounds.x * scale + xOffset,
	        y: quad.bounds.y * scale + yOffset
	      }
	    });
	  }

	  return adjustedQuads;
	}
	exports.getAdjustedQuads = getAdjustedQuads;

	/**
	 * Compute the absolute position and the dimensions of a node, relativalely
	 * to the root window.

	 * @param {DOMWindow} boundaryWindow
	 *        The window where to stop to iterate. If `null` is given, the top
	 *        window is used.
	 * @param {DOMNode} node
	 *        a DOM element to get the bounds for
	 * @param {DOMWindow} contentWindow
	 *        the content window holding the node
	 * @return {Object}
	 *         A rect object with the {top, left, width, height} properties
	 */
	function getRect(boundaryWindow, node, contentWindow) {
	  let frameWin = node.ownerDocument.defaultView;
	  let clientRect = node.getBoundingClientRect();

	  if (boundaryWindow === null) {
	    boundaryWindow = getTopWindow(frameWin);
	  } else if (typeof boundaryWindow === "undefined") {
	    throw new Error("No boundaryWindow given. Use null for the default one.");
	  }

	  // Go up in the tree of frames to determine the correct rectangle.
	  // clientRect is read-only, we need to be able to change properties.
	  let rect = {
	    top: clientRect.top + contentWindow.pageYOffset,
	    left: clientRect.left + contentWindow.pageXOffset,
	    width: clientRect.width,
	    height: clientRect.height
	  };

	  // We iterate through all the parent windows.
	  while (frameWin !== boundaryWindow) {
	    let frameElement = getFrameElement(frameWin);
	    if (!frameElement) {
	      break;
	    }

	    // We are in an iframe.
	    // We take into account the parent iframe position and its
	    // offset (borders and padding).
	    let frameRect = frameElement.getBoundingClientRect();

	    let [offsetTop, offsetLeft] = getFrameContentOffset(frameElement);

	    rect.top += frameRect.top + offsetTop;
	    rect.left += frameRect.left + offsetLeft;

	    frameWin = getParentWindow(frameWin);
	  }

	  return rect;
	}
	exports.getRect = getRect;

	/**
	 * Get the 4 bounding points for a node taking iframes into account.
	 * Note that for transformed nodes, this will return the untransformed bound.
	 *
	 * @param {DOMWindow} boundaryWindow
	 *        The window where to stop to iterate. If `null` is given, the top
	 *        window is used.
	 * @param {DOMNode} node
	 * @return {Object}
	 *         An object with p1,p2,p3,p4 properties being {x,y} objects
	 */
	function getNodeBounds(boundaryWindow, node) {
	  if (!node) {
	    return null;
	  }

	  let scale = getCurrentZoom(node);

	  // Find out the offset of the node in its current frame
	  let offsetLeft = 0;
	  let offsetTop = 0;
	  let el = node;
	  while (el && el.parentNode) {
	    offsetLeft += el.offsetLeft;
	    offsetTop += el.offsetTop;
	    el = el.offsetParent;
	  }

	  // Also take scrolled containers into account
	  el = node;
	  while (el && el.parentNode) {
	    if (el.scrollTop) {
	      offsetTop -= el.scrollTop;
	    }
	    if (el.scrollLeft) {
	      offsetLeft -= el.scrollLeft;
	    }
	    el = el.parentNode;
	  }

	  // And add the potential frame offset if the node is nested
	  let [xOffset, yOffset] = getFrameOffsets(boundaryWindow, node);
	  xOffset += offsetLeft;
	  yOffset += offsetTop;

	  xOffset *= scale;
	  yOffset *= scale;

	  // Get the width and height
	  let width = node.offsetWidth * scale;
	  let height = node.offsetHeight * scale;

	  return {
	    p1: {x: xOffset, y: yOffset},
	    p2: {x: xOffset + width, y: yOffset},
	    p3: {x: xOffset + width, y: yOffset + height},
	    p4: {x: xOffset, y: yOffset + height}
	  };
	}
	exports.getNodeBounds = getNodeBounds;

	/**
	 * Same as doing iframe.contentWindow but works with all types of container
	 * elements that act like frames (e.g. <embed>), where 'contentWindow' isn't a
	 * property that can be accessed.
	 * This uses the inIDeepTreeWalker instead.
	 * @param {DOMNode} frame
	 * @return {Window}
	 */
	function safelyGetContentWindow(frame) {
	  if (frame.contentWindow) {
	    return frame.contentWindow;
	  }

	  let walker = Cc["@mozilla.org/inspector/deep-tree-walker;1"]
	               .createInstance(Ci.inIDeepTreeWalker);
	  walker.showSubDocuments = true;
	  walker.showDocumentsAsNodes = true;
	  walker.init(frame, nodeFilterConstants.SHOW_ALL);
	  walker.currentNode = frame;

	  let document = walker.nextNode();
	  if (!document || !document.defaultView) {
	    throw new Error("Couldn't get the content window inside frame " + frame);
	  }

	  return document.defaultView;
	}

	/**
	 * Returns a frame's content offset (frame border + padding).
	 * Note: this function shouldn't need to exist, had the platform provided a
	 * suitable API for determining the offset between the frame's content and
	 * its bounding client rect. Bug 626359 should provide us with such an API.
	 *
	 * @param {DOMNode} frame
	 *        The frame.
	 * @return {Array} [offsetTop, offsetLeft]
	 *         offsetTop is the distance from the top of the frame and the top of
	 *         the content document.
	 *         offsetLeft is the distance from the left of the frame and the left
	 *         of the content document.
	 */
	function getFrameContentOffset(frame) {
	  let style = safelyGetContentWindow(frame).getComputedStyle(frame, null);

	  // In some cases, the computed style is null
	  if (!style) {
	    return [0, 0];
	  }

	  let paddingTop = parseInt(style.getPropertyValue("padding-top"), 10);
	  let paddingLeft = parseInt(style.getPropertyValue("padding-left"), 10);

	  let borderTop = parseInt(style.getPropertyValue("border-top-width"), 10);
	  let borderLeft = parseInt(style.getPropertyValue("border-left-width"), 10);

	  return [borderTop + paddingTop, borderLeft + paddingLeft];
	}

	/**
	 * Find an element from the given coordinates. This method descends through
	 * frames to find the element the user clicked inside frames.
	 *
	 * @param {DOMDocument} document
	 *        The document to look into.
	 * @param {Number} x
	 * @param {Number} y
	 * @return {DOMNode}
	 *         the element node found at the given coordinates, or null if no node
	 *         was found
	 */
	function getElementFromPoint(document, x, y) {
	  let node = document.elementFromPoint(x, y);
	  if (node && node.contentDocument) {
	    if (node instanceof Ci.nsIDOMHTMLIFrameElement) {
	      let rect = node.getBoundingClientRect();

	      // Gap between the frame and its content window.
	      let [offsetTop, offsetLeft] = getFrameContentOffset(node);

	      x -= rect.left + offsetLeft;
	      y -= rect.top + offsetTop;

	      if (x < 0 || y < 0) {
	        // Didn't reach the content document, still over the frame.
	        return node;
	      }
	    }
	    if (node instanceof Ci.nsIDOMHTMLIFrameElement ||
	        node instanceof Ci.nsIDOMHTMLFrameElement) {
	      let subnode = getElementFromPoint(node.contentDocument, x, y);
	      if (subnode) {
	        node = subnode;
	      }
	    }
	  }
	  return node;
	}
	exports.getElementFromPoint = getElementFromPoint;

	/**
	 * Check if a node and its document are still alive
	 * and attached to the window.
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 */
	function isNodeConnected(node) {
	  if (!node.ownerDocument || !node.ownerDocument.defaultView) {
	    return false;
	  }

	  try {
	    return !(node.compareDocumentPosition(node.ownerDocument.documentElement) &
	             node.DOCUMENT_POSITION_DISCONNECTED);
	  } catch (e) {
	    // "can't access dead object" error
	    return false;
	  }
	}
	exports.isNodeConnected = isNodeConnected;

	/**
	 * Traverse getBindingParent until arriving upon the bound element
	 * responsible for the generation of the specified node.
	 * See https://developer.mozilla.org/en-US/docs/XBL/XBL_1.0_Reference/DOM_Interfaces#getBindingParent.
	 *
	 * @param {DOMNode} node
	 * @return {DOMNode}
	 *         If node is not anonymous, this will return node. Otherwise,
	 *         it will return the bound element
	 *
	 */
	function getRootBindingParent(node) {
	  let parent;
	  let doc = node.ownerDocument;
	  if (!doc) {
	    return node;
	  }
	  while ((parent = doc.getBindingParent(node))) {
	    node = parent;
	  }
	  return node;
	}
	exports.getRootBindingParent = getRootBindingParent;

	function getBindingParent(node) {
	  let doc = node.ownerDocument;
	  if (!doc) {
	    return null;
	  }

	  // If there is no binding parent then it is not anonymous.
	  let parent = doc.getBindingParent(node);
	  if (!parent) {
	    return null;
	  }

	  return parent;
	}
	exports.getBindingParent = getBindingParent;

	/**
	 * Determine whether a node is anonymous by determining if there
	 * is a bindingParent.
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 *
	 */
	const isAnonymous = (node) => getRootBindingParent(node) !== node;
	exports.isAnonymous = isAnonymous;

	/**
	 * Determine whether a node has a bindingParent.
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 *
	 */
	const hasBindingParent = (node) => !!getBindingParent(node);

	/**
	 * Determine whether a node is native anonymous content (as opposed
	 * to XBL anonymous or shadow DOM).
	 * Native anonymous content includes elements like internals to form
	 * controls and ::before/::after.
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 *
	 */
	const isNativeAnonymous = (node) =>
	  hasBindingParent(node) && !(isXBLAnonymous(node) || isShadowAnonymous(node));

	exports.isNativeAnonymous = isNativeAnonymous;

	/**
	 * Determine whether a node is XBL anonymous content (as opposed
	 * to native anonymous or shadow DOM).
	 * See https://developer.mozilla.org/en-US/docs/XBL/XBL_1.0_Reference/Anonymous_Content.
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 *
	 */
	function isXBLAnonymous(node) {
	  let parent = getBindingParent(node);
	  if (!parent) {
	    return false;
	  }

	  // Shadow nodes also show up in getAnonymousNodes, so return false.
	  if (parent.shadowRoot && parent.shadowRoot.contains(node)) {
	    return false;
	  }

	  let anonNodes = [...node.ownerDocument.getAnonymousNodes(parent) || []];
	  return anonNodes.indexOf(node) > -1;
	}
	exports.isXBLAnonymous = isXBLAnonymous;

	/**
	 * Determine whether a node is a child of a shadow root.
	 * See https://w3c.github.io/webcomponents/spec/shadow/
	 *
	 * @param {DOMNode} node
	 * @return {Boolean}
	 */
	function isShadowAnonymous(node) {
	  let parent = getBindingParent(node);
	  if (!parent) {
	    return false;
	  }

	  // If there is a shadowRoot and this is part of it then this
	  // is not native anonymous
	  return parent.shadowRoot && parent.shadowRoot.contains(node);
	}
	exports.isShadowAnonymous = isShadowAnonymous;

	/**
	 * Get the current zoom factor applied to the container window of a given node.
	 * Container windows are used as a weakmap key to store the corresponding
	 * nsIDOMWindowUtils instance to avoid querying it every time.
	 *
	 * @param {DOMNode|DOMWindow}
	 *        The node for which the zoom factor should be calculated, or its
	 *        owner window.
	 * @return {Number}
	 */
	function getCurrentZoom(node) {
	  let win = getWindowFor(node);

	  if (!win) {
	    throw new Error("Unable to get the zoom from the given argument.");
	  }

	  return utilsFor(win).fullZoom;
	}
	exports.getCurrentZoom = getCurrentZoom;

	/**
	 * Return the default view for a given node, where node can be:
	 * - a DOM node
	 * - the document node
	 * - the window itself
	 * @param {DOMNode|DOMWindow|DOMDocument} node The node to get the window for.
	 * @return {DOMWindow}
	 */
	function getWindowFor(node) {
	  if (node instanceof Ci.nsIDOMNode) {
	    if (node.nodeType === node.DOCUMENT_NODE) {
	      return node.defaultView;
	    }
	    return node.ownerDocument.defaultView;
	  } else if (node instanceof Ci.nsIDOMWindow) {
	    return node;
	  }
	  return null;
	}


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	__webpack_require__(205);
	__webpack_require__(207);
	const { SimpleStringFront } = __webpack_require__(209);
	const {
	  Front,
	  FrontClassWithSpec,
	  custom,
	  preEvent,
	  types
	} = __webpack_require__(19);
	const {
	  inspectorSpec,
	  nodeSpec,
	  nodeListSpec,
	  walkerSpec
	} = __webpack_require__(210);
	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);
	const { Task } = __webpack_require__(17);
	const { Class } = __webpack_require__(20);
	const events = __webpack_require__(23);
	const object = __webpack_require__(27);
	const nodeConstants = __webpack_require__(33);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "CommandUtils",
	  "devtools/client/shared/developer-toolbar", true);

	const HIDDEN_CLASS = "__fx-devtools-hide-shortcut__";

	/**
	 * Convenience API for building a list of attribute modifications
	 * for the `modifyAttributes` request.
	 */
	const AttributeModificationList = Class({
	  initialize: function (node) {
	    this.node = node;
	    this.modifications = [];
	  },

	  apply: function () {
	    let ret = this.node.modifyAttributes(this.modifications);
	    return ret;
	  },

	  destroy: function () {
	    this.node = null;
	    this.modification = null;
	  },

	  setAttributeNS: function (ns, name, value) {
	    this.modifications.push({
	      attributeNamespace: ns,
	      attributeName: name,
	      newValue: value
	    });
	  },

	  setAttribute: function (name, value) {
	    this.setAttributeNS(undefined, name, value);
	  },

	  removeAttributeNS: function (ns, name) {
	    this.setAttributeNS(ns, name, undefined);
	  },

	  removeAttribute: function (name) {
	    this.setAttributeNS(undefined, name, undefined);
	  }
	});

	/**
	 * Client side of the node actor.
	 *
	 * Node fronts are strored in a tree that mirrors the DOM tree on the
	 * server, but with a few key differences:
	 *  - Not all children will be necessary loaded for each node.
	 *  - The order of children isn't guaranteed to be the same as the DOM.
	 * Children are stored in a doubly-linked list, to make addition/removal
	 * and traversal quick.
	 *
	 * Due to the order/incompleteness of the child list, it is safe to use
	 * the parent node from clients, but the `children` request should be used
	 * to traverse children.
	 */
	const NodeFront = FrontClassWithSpec(nodeSpec, {
	  initialize: function (conn, form, detail, ctx) {
	    // The parent node
	    this._parent = null;
	    // The first child of this node.
	    this._child = null;
	    // The next sibling of this node.
	    this._next = null;
	    // The previous sibling of this node.
	    this._prev = null;
	    Front.prototype.initialize.call(this, conn, form, detail, ctx);
	  },

	  /**
	   * Destroy a node front.  The node must have been removed from the
	   * ownership tree before this is called, unless the whole walker front
	   * is being destroyed.
	   */
	  destroy: function () {
	    Front.prototype.destroy.call(this);
	  },

	  // Update the object given a form representation off the wire.
	  form: function (form, detail, ctx) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }

	    // backward-compatibility: shortValue indicates we are connected to old server
	    if (form.shortValue) {
	      // If the value is not complete, set nodeValue to null, it will be fetched
	      // when calling getNodeValue()
	      form.nodeValue = form.incompleteValue ? null : form.shortValue;
	    }

	    // Shallow copy of the form.  We could just store a reference, but
	    // eventually we'll want to update some of the data.
	    this._form = object.merge(form);
	    this._form.attrs = this._form.attrs ? this._form.attrs.slice() : [];

	    if (form.parent) {
	      // Get the owner actor for this actor (the walker), and find the
	      // parent node of this actor from it, creating a standin node if
	      // necessary.
	      let parentNodeFront = ctx.marshallPool().ensureParentFront(form.parent);
	      this.reparent(parentNodeFront);
	    }

	    if (form.inlineTextChild) {
	      this.inlineTextChild =
	        types.getType("domnode").read(form.inlineTextChild, ctx);
	    } else {
	      this.inlineTextChild = undefined;
	    }
	  },

	  /**
	   * Returns the parent NodeFront for this NodeFront.
	   */
	  parentNode: function () {
	    return this._parent;
	  },

	  /**
	   * Process a mutation entry as returned from the walker's `getMutations`
	   * request.  Only tries to handle changes of the node's contents
	   * themselves (character data and attribute changes), the walker itself
	   * will keep the ownership tree up to date.
	   */
	  updateMutation: function (change) {
	    if (change.type === "attributes") {
	      // We'll need to lazily reparse the attributes after this change.
	      this._attrMap = undefined;

	      // Update any already-existing attributes.
	      let found = false;
	      for (let i = 0; i < this.attributes.length; i++) {
	        let attr = this.attributes[i];
	        if (attr.name == change.attributeName &&
	            attr.namespace == change.attributeNamespace) {
	          if (change.newValue !== null) {
	            attr.value = change.newValue;
	          } else {
	            this.attributes.splice(i, 1);
	          }
	          found = true;
	          break;
	        }
	      }
	      // This is a new attribute. The null check is because of Bug 1192270,
	      // in the case of a newly added then removed attribute
	      if (!found && change.newValue !== null) {
	        this.attributes.push({
	          name: change.attributeName,
	          namespace: change.attributeNamespace,
	          value: change.newValue
	        });
	      }
	    } else if (change.type === "characterData") {
	      this._form.nodeValue = change.newValue;
	    } else if (change.type === "pseudoClassLock") {
	      this._form.pseudoClassLocks = change.pseudoClassLocks;
	    } else if (change.type === "events") {
	      this._form.hasEventListeners = change.hasEventListeners;
	    }
	  },

	  // Some accessors to make NodeFront feel more like an nsIDOMNode

	  get id() {
	    return this.getAttribute("id");
	  },

	  get nodeType() {
	    return this._form.nodeType;
	  },
	  get namespaceURI() {
	    return this._form.namespaceURI;
	  },
	  get nodeName() {
	    return this._form.nodeName;
	  },
	  get displayName() {
	    let {displayName, nodeName} = this._form;

	    // Keep `nodeName.toLowerCase()` for backward compatibility
	    return displayName || nodeName.toLowerCase();
	  },
	  get doctypeString() {
	    return "<!DOCTYPE " + this._form.name +
	     (this._form.publicId ? " PUBLIC \"" + this._form.publicId + "\"" : "") +
	     (this._form.systemId ? " \"" + this._form.systemId + "\"" : "") +
	     ">";
	  },

	  get baseURI() {
	    return this._form.baseURI;
	  },

	  get className() {
	    return this.getAttribute("class") || "";
	  },

	  get hasChildren() {
	    return this._form.numChildren > 0;
	  },
	  get numChildren() {
	    return this._form.numChildren;
	  },
	  get hasEventListeners() {
	    return this._form.hasEventListeners;
	  },

	  get isBeforePseudoElement() {
	    return this._form.isBeforePseudoElement;
	  },
	  get isAfterPseudoElement() {
	    return this._form.isAfterPseudoElement;
	  },
	  get isPseudoElement() {
	    return this.isBeforePseudoElement || this.isAfterPseudoElement;
	  },
	  get isAnonymous() {
	    return this._form.isAnonymous;
	  },
	  get isInHTMLDocument() {
	    return this._form.isInHTMLDocument;
	  },
	  get tagName() {
	    return this.nodeType === nodeConstants.ELEMENT_NODE ? this.nodeName : null;
	  },

	  get isDocumentElement() {
	    return !!this._form.isDocumentElement;
	  },

	  // doctype properties
	  get name() {
	    return this._form.name;
	  },
	  get publicId() {
	    return this._form.publicId;
	  },
	  get systemId() {
	    return this._form.systemId;
	  },

	  getAttribute: function (name) {
	    let attr = this._getAttribute(name);
	    return attr ? attr.value : null;
	  },
	  hasAttribute: function (name) {
	    this._cacheAttributes();
	    return (name in this._attrMap);
	  },

	  get hidden() {
	    let cls = this.getAttribute("class");
	    return cls && cls.indexOf(HIDDEN_CLASS) > -1;
	  },

	  get attributes() {
	    return this._form.attrs;
	  },

	  get pseudoClassLocks() {
	    return this._form.pseudoClassLocks || [];
	  },
	  hasPseudoClassLock: function (pseudo) {
	    return this.pseudoClassLocks.some(locked => locked === pseudo);
	  },

	  get isDisplayed() {
	    // The NodeActor's form contains the isDisplayed information as a boolean
	    // starting from FF32. Before that, the property is missing
	    return "isDisplayed" in this._form ? this._form.isDisplayed : true;
	  },

	  get isTreeDisplayed() {
	    let parent = this;
	    while (parent) {
	      if (!parent.isDisplayed) {
	        return false;
	      }
	      parent = parent.parentNode();
	    }
	    return true;
	  },

	  getNodeValue: custom(function () {
	    // backward-compatibility: if nodevalue is null and shortValue is defined, the actual
	    // value of the node needs to be fetched on the server.
	    if (this._form.nodeValue === null && this._form.shortValue) {
	      return this._getNodeValue();
	    }

	    let str = this._form.nodeValue || "";
	    return promise.resolve(new SimpleStringFront(str));
	  }, {
	    impl: "_getNodeValue"
	  }),

	  // Accessors for custom form properties.

	  getFormProperty: function (name) {
	    return this._form.props ? this._form.props[name] : null;
	  },

	  hasFormProperty: function (name) {
	    return this._form.props ? (name in this._form.props) : null;
	  },

	  get formProperties() {
	    return this._form.props;
	  },

	  /**
	   * Return a new AttributeModificationList for this node.
	   */
	  startModifyingAttributes: function () {
	    return AttributeModificationList(this);
	  },

	  _cacheAttributes: function () {
	    if (typeof this._attrMap != "undefined") {
	      return;
	    }
	    this._attrMap = {};
	    for (let attr of this.attributes) {
	      this._attrMap[attr.name] = attr;
	    }
	  },

	  _getAttribute: function (name) {
	    this._cacheAttributes();
	    return this._attrMap[name] || undefined;
	  },

	  /**
	   * Set this node's parent.  Note that the children saved in
	   * this tree are unordered and incomplete, so shouldn't be used
	   * instead of a `children` request.
	   */
	  reparent: function (parent) {
	    if (this._parent === parent) {
	      return;
	    }

	    if (this._parent && this._parent._child === this) {
	      this._parent._child = this._next;
	    }
	    if (this._prev) {
	      this._prev._next = this._next;
	    }
	    if (this._next) {
	      this._next._prev = this._prev;
	    }
	    this._next = null;
	    this._prev = null;
	    this._parent = parent;
	    if (!parent) {
	      // Subtree is disconnected, we're done
	      return;
	    }
	    this._next = parent._child;
	    if (this._next) {
	      this._next._prev = this;
	    }
	    parent._child = this;
	  },

	  /**
	   * Return all the known children of this node.
	   */
	  treeChildren: function () {
	    let ret = [];
	    for (let child = this._child; child != null; child = child._next) {
	      ret.push(child);
	    }
	    return ret;
	  },

	  /**
	   * Do we use a local target?
	   * Useful to know if a rawNode is available or not.
	   *
	   * This will, one day, be removed. External code should
	   * not need to know if the target is remote or not.
	   */
	  isLocalToBeDeprecated: function () {
	    return !!this.conn._transport._serverConnection;
	  },

	  /**
	   * Get an nsIDOMNode for the given node front.  This only works locally,
	   * and is only intended as a stopgap during the transition to the remote
	   * protocol.  If you depend on this you're likely to break soon.
	   */
	  rawNode: function (rawNode) {
	    if (!this.isLocalToBeDeprecated()) {
	      console.warn("Tried to use rawNode on a remote connection.");
	      return null;
	    }
	    const { DebuggerServer } = __webpack_require__(11);
	    let actor = DebuggerServer._searchAllConnectionsForActor(this.actorID);
	    if (!actor) {
	      // Can happen if we try to get the raw node for an already-expired
	      // actor.
	      return null;
	    }
	    return actor.rawNode;
	  }
	});

	exports.NodeFront = NodeFront;

	/**
	 * Client side of a node list as returned by querySelectorAll()
	 */
	const NodeListFront = FrontClassWithSpec(nodeListSpec, {
	  initialize: function (client, form) {
	    Front.prototype.initialize.call(this, client, form);
	  },

	  destroy: function () {
	    Front.prototype.destroy.call(this);
	  },

	  marshallPool: function () {
	    return this.parent();
	  },

	  // Update the object given a form representation off the wire.
	  form: function (json) {
	    this.length = json.length;
	  },

	  item: custom(function (index) {
	    return this._item(index).then(response => {
	      return response.node;
	    });
	  }, {
	    impl: "_item"
	  }),

	  items: custom(function (start, end) {
	    return this._items(start, end).then(response => {
	      return response.nodes;
	    });
	  }, {
	    impl: "_items"
	  })
	});

	exports.NodeListFront = NodeListFront;

	/**
	 * Client side of the DOM walker.
	 */
	const WalkerFront = FrontClassWithSpec(walkerSpec, {
	  // Set to true if cleanup should be requested after every mutation list.
	  autoCleanup: true,

	  /**
	   * This is kept for backward-compatibility reasons with older remote target.
	   * Targets previous to bug 916443
	   */
	  pick: custom(function () {
	    return this._pick().then(response => {
	      return response.node;
	    });
	  }, {impl: "_pick"}),

	  initialize: function (client, form) {
	    this._createRootNodePromise();
	    Front.prototype.initialize.call(this, client, form);
	    this._orphaned = new Set();
	    this._retainedOrphans = new Set();
	  },

	  destroy: function () {
	    Front.prototype.destroy.call(this);
	  },

	  // Update the object given a form representation off the wire.
	  form: function (json) {
	    this.actorID = json.actor;
	    this.rootNode = types.getType("domnode").read(json.root, this);
	    this._rootNodeDeferred.resolve(this.rootNode);
	    // FF42+ the actor starts exposing traits
	    this.traits = json.traits || {};
	  },

	  /**
	   * Clients can use walker.rootNode to get the current root node of the
	   * walker, but during a reload the root node might be null.  This
	   * method returns a promise that will resolve to the root node when it is
	   * set.
	   */
	  getRootNode: function () {
	    return this._rootNodeDeferred.promise;
	  },

	  /**
	   * Create the root node promise, triggering the "new-root" notification
	   * on resolution.
	   */
	  _createRootNodePromise: function () {
	    this._rootNodeDeferred = defer();
	    this._rootNodeDeferred.promise.then(() => {
	      events.emit(this, "new-root");
	    });
	  },

	  /**
	   * When reading an actor form off the wire, we want to hook it up to its
	   * parent front.  The protocol guarantees that the parent will be seen
	   * by the client in either a previous or the current request.
	   * So if we've already seen this parent return it, otherwise create
	   * a bare-bones stand-in node.  The stand-in node will be updated
	   * with a real form by the end of the deserialization.
	   */
	  ensureParentFront: function (id) {
	    let front = this.get(id);
	    if (front) {
	      return front;
	    }

	    return types.getType("domnode").read({ actor: id }, this, "standin");
	  },

	  /**
	   * See the documentation for WalkerActor.prototype.retainNode for
	   * information on retained nodes.
	   *
	   * From the client's perspective, `retainNode` can fail if the node in
	   * question is removed from the ownership tree before the `retainNode`
	   * request reaches the server.  This can only happen if the client has
	   * asked the server to release nodes but hasn't gotten a response
	   * yet: Either a `releaseNode` request or a `getMutations` with `cleanup`
	   * set is outstanding.
	   *
	   * If either of those requests is outstanding AND releases the retained
	   * node, this request will fail with noSuchActor, but the ownership tree
	   * will stay in a consistent state.
	   *
	   * Because the protocol guarantees that requests will be processed and
	   * responses received in the order they were sent, we get the right
	   * semantics by setting our local retained flag on the node only AFTER
	   * a SUCCESSFUL retainNode call.
	   */
	  retainNode: custom(function (node) {
	    return this._retainNode(node).then(() => {
	      node.retained = true;
	    });
	  }, {
	    impl: "_retainNode",
	  }),

	  unretainNode: custom(function (node) {
	    return this._unretainNode(node).then(() => {
	      node.retained = false;
	      if (this._retainedOrphans.has(node)) {
	        this._retainedOrphans.delete(node);
	        this._releaseFront(node);
	      }
	    });
	  }, {
	    impl: "_unretainNode"
	  }),

	  releaseNode: custom(function (node, options = {}) {
	    // NodeFront.destroy will destroy children in the ownership tree too,
	    // mimicking what the server will do here.
	    let actorID = node.actorID;
	    this._releaseFront(node, !!options.force);
	    return this._releaseNode({ actorID: actorID });
	  }, {
	    impl: "_releaseNode"
	  }),

	  findInspectingNode: custom(function () {
	    return this._findInspectingNode().then(response => {
	      return response.node;
	    });
	  }, {
	    impl: "_findInspectingNode"
	  }),

	  querySelector: custom(function (queryNode, selector) {
	    return this._querySelector(queryNode, selector).then(response => {
	      return response.node;
	    });
	  }, {
	    impl: "_querySelector"
	  }),

	  getNodeActorFromObjectActor: custom(function (objectActorID) {
	    return this._getNodeActorFromObjectActor(objectActorID).then(response => {
	      return response ? response.node : null;
	    });
	  }, {
	    impl: "_getNodeActorFromObjectActor"
	  }),

	  getStyleSheetOwnerNode: custom(function (styleSheetActorID) {
	    return this._getStyleSheetOwnerNode(styleSheetActorID).then(response => {
	      return response ? response.node : null;
	    });
	  }, {
	    impl: "_getStyleSheetOwnerNode"
	  }),

	  getNodeFromActor: custom(function (actorID, path) {
	    return this._getNodeFromActor(actorID, path).then(response => {
	      return response ? response.node : null;
	    });
	  }, {
	    impl: "_getNodeFromActor"
	  }),

	  /*
	   * Incrementally search the document for a given string.
	   * For modern servers, results will be searched with using the WalkerActor
	   * `search` function (includes tag names, attributes, and text contents).
	   * Only 1 result is sent back, and calling the method again with the same
	   * query will send the next result. When there are no more results to be sent
	   * back, null is sent.
	   * @param {String} query
	   * @param {Object} options
	   *    - "reverse": search backwards
	   *    - "selectorOnly": treat input as a selector string (don't search text
	   *                      tags, attributes, etc)
	   */
	  search: custom(Task.async(function* (query, options = { }) {
	    let nodeList;
	    let searchType;
	    let searchData = this.searchData = this.searchData || { };
	    let selectorOnly = !!options.selectorOnly;

	    // Backwards compat.  Use selector only search if the new
	    // search functionality isn't implemented, or if the caller (tests)
	    // want it.
	    if (selectorOnly || !this.traits.textSearch) {
	      searchType = "selector";
	      if (this.traits.multiFrameQuerySelectorAll) {
	        nodeList = yield this.multiFrameQuerySelectorAll(query);
	      } else {
	        nodeList = yield this.querySelectorAll(this.rootNode, query);
	      }
	    } else {
	      searchType = "search";
	      let result = yield this._search(query, options);
	      nodeList = result.list;
	    }

	    // If this is a new search, start at the beginning.
	    if (searchData.query !== query ||
	        searchData.selectorOnly !== selectorOnly) {
	      searchData.selectorOnly = selectorOnly;
	      searchData.query = query;
	      searchData.index = -1;
	    }

	    if (!nodeList.length) {
	      return null;
	    }

	    // Move search result cursor and cycle if necessary.
	    searchData.index = options.reverse ? searchData.index - 1 :
	                                         searchData.index + 1;
	    if (searchData.index >= nodeList.length) {
	      searchData.index = 0;
	    }
	    if (searchData.index < 0) {
	      searchData.index = nodeList.length - 1;
	    }

	    // Send back the single node, along with any relevant search data
	    let node = yield nodeList.item(searchData.index);
	    return {
	      type: searchType,
	      node: node,
	      resultsLength: nodeList.length,
	      resultsIndex: searchData.index,
	    };
	  }), {
	    impl: "_search"
	  }),

	  _releaseFront: function (node, force) {
	    if (node.retained && !force) {
	      node.reparent(null);
	      this._retainedOrphans.add(node);
	      return;
	    }

	    if (node.retained) {
	      // Forcing a removal.
	      this._retainedOrphans.delete(node);
	    }

	    // Release any children
	    for (let child of node.treeChildren()) {
	      this._releaseFront(child, force);
	    }

	    // All children will have been removed from the node by this point.
	    node.reparent(null);
	    node.destroy();
	  },

	  /**
	   * Get any unprocessed mutation records and process them.
	   */
	  getMutations: custom(function (options = {}) {
	    return this._getMutations(options).then(mutations => {
	      let emitMutations = [];
	      for (let change of mutations) {
	        // The target is only an actorID, get the associated front.
	        let targetID;
	        let targetFront;

	        if (change.type === "newRoot") {
	          this.rootNode = types.getType("domnode").read(change.target, this);
	          this._rootNodeDeferred.resolve(this.rootNode);
	          targetID = this.rootNode.actorID;
	          targetFront = this.rootNode;
	        } else {
	          targetID = change.target;
	          targetFront = this.get(targetID);
	        }

	        if (!targetFront) {
	          console.trace("Got a mutation for an unexpected actor: " + targetID +
	            ", please file a bug on bugzilla.mozilla.org!");
	          continue;
	        }

	        let emittedMutation = object.merge(change, { target: targetFront });

	        if (change.type === "childList" ||
	            change.type === "nativeAnonymousChildList") {
	          // Update the ownership tree according to the mutation record.
	          let addedFronts = [];
	          let removedFronts = [];
	          for (let removed of change.removed) {
	            let removedFront = this.get(removed);
	            if (!removedFront) {
	              console.error("Got a removal of an actor we didn't know about: " +
	                removed);
	              continue;
	            }
	            // Remove from the ownership tree
	            removedFront.reparent(null);

	            // This node is orphaned unless we get it in the 'added' list
	            // eventually.
	            this._orphaned.add(removedFront);
	            removedFronts.push(removedFront);
	          }
	          for (let added of change.added) {
	            let addedFront = this.get(added);
	            if (!addedFront) {
	              console.error("Got an addition of an actor we didn't know " +
	                "about: " + added);
	              continue;
	            }
	            addedFront.reparent(targetFront);

	            // The actor is reconnected to the ownership tree, unorphan
	            // it.
	            this._orphaned.delete(addedFront);
	            addedFronts.push(addedFront);
	          }

	          // Before passing to users, replace the added and removed actor
	          // ids with front in the mutation record.
	          emittedMutation.added = addedFronts;
	          emittedMutation.removed = removedFronts;

	          // If this is coming from a DOM mutation, the actor's numChildren
	          // was passed in. Otherwise, it is simulated from a frame load or
	          // unload, so don't change the front's form.
	          if ("numChildren" in change) {
	            targetFront._form.numChildren = change.numChildren;
	          }
	        } else if (change.type === "frameLoad") {
	          // Nothing we need to do here, except verify that we don't have any
	          // document children, because we should have gotten a documentUnload
	          // first.
	          for (let child of targetFront.treeChildren()) {
	            if (child.nodeType === nodeConstants.DOCUMENT_NODE) {
	              console.trace("Got an unexpected frameLoad in the inspector, " +
	                "please file a bug on bugzilla.mozilla.org!");
	            }
	          }
	        } else if (change.type === "documentUnload") {
	          if (targetFront === this.rootNode) {
	            this._createRootNodePromise();
	          }

	          // We try to give fronts instead of actorIDs, but these fronts need
	          // to be destroyed now.
	          emittedMutation.target = targetFront.actorID;
	          emittedMutation.targetParent = targetFront.parentNode();

	          // Release the document node and all of its children, even retained.
	          this._releaseFront(targetFront, true);
	        } else if (change.type === "unretained") {
	          // Retained orphans were force-released without the intervention of
	          // client (probably a navigated frame).
	          for (let released of change.nodes) {
	            let releasedFront = this.get(released);
	            this._retainedOrphans.delete(released);
	            this._releaseFront(releasedFront, true);
	          }
	        } else {
	          targetFront.updateMutation(change);
	        }

	        // Update the inlineTextChild property of the target for a selected list of
	        // mutation types.
	        if (change.type === "inlineTextChild" ||
	            change.type === "childList" ||
	            change.type === "nativeAnonymousChildList") {
	          if (change.inlineTextChild) {
	            targetFront.inlineTextChild =
	              types.getType("domnode").read(change.inlineTextChild, this);
	          } else {
	            targetFront.inlineTextChild = undefined;
	          }
	        }

	        emitMutations.push(emittedMutation);
	      }

	      if (options.cleanup) {
	        for (let node of this._orphaned) {
	          // This will move retained nodes to this._retainedOrphans.
	          this._releaseFront(node);
	        }
	        this._orphaned = new Set();
	      }

	      events.emit(this, "mutations", emitMutations);
	    });
	  }, {
	    impl: "_getMutations"
	  }),

	  /**
	   * Handle the `new-mutations` notification by fetching the
	   * available mutation records.
	   */
	  onMutations: preEvent("new-mutations", function () {
	    // Fetch and process the mutations.
	    this.getMutations({cleanup: this.autoCleanup}).catch(() => {});
	  }),

	  isLocal: function () {
	    return !!this.conn._transport._serverConnection;
	  },

	  // XXX hack during transition to remote inspector: get a proper NodeFront
	  // for a given local node.  Only works locally.
	  frontForRawNode: function (rawNode) {
	    if (!this.isLocal()) {
	      console.warn("Tried to use frontForRawNode on a remote connection.");
	      return null;
	    }
	    const { DebuggerServer } = __webpack_require__(11);
	    let walkerActor = DebuggerServer._searchAllConnectionsForActor(this.actorID);
	    if (!walkerActor) {
	      throw Error("Could not find client side for actor " + this.actorID);
	    }
	    let nodeActor = walkerActor._ref(rawNode);

	    // Pass the node through a read/write pair to create the client side actor.
	    let nodeType = types.getType("domnode");
	    let returnNode = nodeType.read(
	      nodeType.write(nodeActor, walkerActor), this);
	    let top = returnNode;
	    let extras = walkerActor.parents(nodeActor, {sameTypeRootTreeItem: true});
	    for (let extraActor of extras) {
	      top = nodeType.read(nodeType.write(extraActor, walkerActor), this);
	    }

	    if (top !== this.rootNode) {
	      // Imported an already-orphaned node.
	      this._orphaned.add(top);
	      walkerActor._orphaned
	        .add(DebuggerServer._searchAllConnectionsForActor(top.actorID));
	    }
	    return returnNode;
	  },

	  removeNode: custom(Task.async(function* (node) {
	    let previousSibling = yield this.previousSibling(node);
	    let nextSibling = yield this._removeNode(node);
	    return {
	      previousSibling: previousSibling,
	      nextSibling: nextSibling,
	    };
	  }), {
	    impl: "_removeNode"
	  }),
	});

	exports.WalkerFront = WalkerFront;

	/**
	 * Client side of the inspector actor, which is used to create
	 * inspector-related actors, including the walker.
	 */
	var InspectorFront = FrontClassWithSpec(inspectorSpec, {
	  initialize: function (client, tabForm) {
	    Front.prototype.initialize.call(this, client);
	    this.actorID = tabForm.inspectorActor;

	    // XXX: This is the first actor type in its hierarchy to use the protocol
	    // library, so we're going to self-own on the client side for now.
	    this.manage(this);
	  },

	  destroy: function () {
	    delete this.walker;
	    Front.prototype.destroy.call(this);
	  },

	  getWalker: custom(function (options = {}) {
	    return this._getWalker(options).then(walker => {
	      this.walker = walker;
	      return walker;
	    });
	  }, {
	    impl: "_getWalker"
	  }),

	  getPageStyle: custom(function () {
	    return this._getPageStyle().then(pageStyle => {
	      // We need a walker to understand node references from the
	      // node style.
	      if (this.walker) {
	        return pageStyle;
	      }
	      return this.getWalker().then(() => {
	        return pageStyle;
	      });
	    });
	  }, {
	    impl: "_getPageStyle"
	  }),

	  pickColorFromPage: custom(Task.async(function* (toolbox, options) {
	    if (toolbox) {
	      // If the eyedropper was already started using the gcli command, hide it so we don't
	      // end up with 2 instances of the eyedropper on the page.
	      let {target} = toolbox;
	      let requisition = yield CommandUtils.createRequisition(target, {
	        environment: CommandUtils.createEnvironment({target})
	      });
	      yield requisition.updateExec("eyedropper --hide");
	    }

	    yield this._pickColorFromPage(options);
	  }), {
	    impl: "_pickColorFromPage"
	  })
	});

	exports.InspectorFront = InspectorFront;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	__webpack_require__(206);
	const {
	  Front,
	  FrontClassWithSpec,
	  custom,
	  preEvent
	} = __webpack_require__(19);
	const {
	  pageStyleSpec,
	  styleRuleSpec
	} = __webpack_require__(124);
	const promise = __webpack_require__(4);
	const { Task } = __webpack_require__(17);
	const { Class } = __webpack_require__(20);
	const { RuleRewriter } = __webpack_require__(132);

	/**
	 * PageStyleFront, the front object for the PageStyleActor
	 */
	const PageStyleFront = FrontClassWithSpec(pageStyleSpec, {
	  initialize: function (conn, form, ctx, detail) {
	    Front.prototype.initialize.call(this, conn, form, ctx, detail);
	    this.inspector = this.parent();
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this._form = form;
	  },

	  destroy: function () {
	    Front.prototype.destroy.call(this);
	  },

	  get walker() {
	    return this.inspector.walker;
	  },

	  get supportsAuthoredStyles() {
	    return this._form.traits && this._form.traits.authoredStyles;
	  },

	  getMatchedSelectors: custom(function (node, property, options) {
	    return this._getMatchedSelectors(node, property, options).then(ret => {
	      return ret.matched;
	    });
	  }, {
	    impl: "_getMatchedSelectors"
	  }),

	  getApplied: custom(Task.async(function* (node, options = {}) {
	    // If the getApplied method doesn't recreate the style cache itself, this
	    // means a call to cssLogic.highlight is required before trying to access
	    // the applied rules. Issue a request to getLayout if this is the case.
	    // See https://bugzilla.mozilla.org/show_bug.cgi?id=1103993#c16.
	    if (!this._form.traits || !this._form.traits.getAppliedCreatesStyleCache) {
	      yield this.getLayout(node);
	    }
	    let ret = yield this._getApplied(node, options);
	    return ret.entries;
	  }), {
	    impl: "_getApplied"
	  }),

	  addNewRule: custom(function (node, pseudoClasses) {
	    let addPromise;
	    if (this.supportsAuthoredStyles) {
	      addPromise = this._addNewRule(node, pseudoClasses, true);
	    } else {
	      addPromise = this._addNewRule(node, pseudoClasses);
	    }
	    return addPromise.then(ret => {
	      return ret.entries[0];
	    });
	  }, {
	    impl: "_addNewRule"
	  })
	});

	exports.PageStyleFront = PageStyleFront;

	/**
	 * StyleRuleFront, the front for the StyleRule actor.
	 */
	const StyleRuleFront = FrontClassWithSpec(styleRuleSpec, {
	  initialize: function (client, form, ctx, detail) {
	    Front.prototype.initialize.call(this, client, form, ctx, detail);
	  },

	  destroy: function () {
	    Front.prototype.destroy.call(this);
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	    if (this._mediaText) {
	      this._mediaText = null;
	    }
	  },

	  /**
	   * Ensure _form is updated when location-changed is emitted.
	   */
	  _locationChangedPre: preEvent("location-changed", function (line, column) {
	    this._clearOriginalLocation();
	    this._form.line = line;
	    this._form.column = column;
	  }),

	  /**
	   * Return a new RuleModificationList or RuleRewriter for this node.
	   * A RuleRewriter will be returned when the rule's canSetRuleText
	   * trait is true; otherwise a RuleModificationList will be
	   * returned.
	   *
	   * @param {CssPropertiesFront} cssProperties
	   *                             This is needed by the RuleRewriter.
	   * @return {RuleModificationList}
	   */
	  startModifyingProperties: function (cssProperties) {
	    if (this.canSetRuleText) {
	      return new RuleRewriter(cssProperties.isKnown, this, this.authoredText);
	    }
	    return new RuleModificationList(this);
	  },

	  get type() {
	    return this._form.type;
	  },
	  get line() {
	    return this._form.line || -1;
	  },
	  get column() {
	    return this._form.column || -1;
	  },
	  get cssText() {
	    return this._form.cssText;
	  },
	  get authoredText() {
	    return this._form.authoredText || this._form.cssText;
	  },
	  get declarations() {
	    return this._form.declarations || [];
	  },
	  get keyText() {
	    return this._form.keyText;
	  },
	  get name() {
	    return this._form.name;
	  },
	  get selectors() {
	    return this._form.selectors;
	  },
	  get media() {
	    return this._form.media;
	  },
	  get mediaText() {
	    if (!this._form.media) {
	      return null;
	    }
	    if (this._mediaText) {
	      return this._mediaText;
	    }
	    this._mediaText = this.media.join(", ");
	    return this._mediaText;
	  },

	  get parentRule() {
	    return this.conn.getActor(this._form.parentRule);
	  },

	  get parentStyleSheet() {
	    return this.conn.getActor(this._form.parentStyleSheet);
	  },

	  get element() {
	    return this.conn.getActor(this._form.element);
	  },

	  get href() {
	    if (this._form.href) {
	      return this._form.href;
	    }
	    let sheet = this.parentStyleSheet;
	    return sheet ? sheet.href : "";
	  },

	  get nodeHref() {
	    let sheet = this.parentStyleSheet;
	    return sheet ? sheet.nodeHref : "";
	  },

	  get supportsModifySelectorUnmatched() {
	    return this._form.traits && this._form.traits.modifySelectorUnmatched;
	  },

	  get canSetRuleText() {
	    return this._form.traits && this._form.traits.canSetRuleText;
	  },

	  get location() {
	    return {
	      source: this.parentStyleSheet,
	      href: this.href,
	      line: this.line,
	      column: this.column
	    };
	  },

	  _clearOriginalLocation: function () {
	    this._originalLocation = null;
	  },

	  getOriginalLocation: function () {
	    if (this._originalLocation) {
	      return promise.resolve(this._originalLocation);
	    }
	    let parentSheet = this.parentStyleSheet;
	    if (!parentSheet) {
	      // This rule doesn't belong to a stylesheet so it is an inline style.
	      // Inline styles do not have any mediaText so we can return early.
	      return promise.resolve(this.location);
	    }
	    return parentSheet.getOriginalLocation(this.line, this.column)
	      .then(({ fromSourceMap, source, line, column }) => {
	        let location = {
	          href: source,
	          line: line,
	          column: column,
	          mediaText: this.mediaText
	        };
	        if (fromSourceMap === false) {
	          location.source = this.parentStyleSheet;
	        }
	        if (!source) {
	          location.href = this.href;
	        }
	        this._originalLocation = location;
	        return location;
	      });
	  },

	  modifySelector: custom(Task.async(function* (node, value) {
	    let response;
	    if (this.supportsModifySelectorUnmatched) {
	      // If the debugee supports adding unmatched rules (post FF41)
	      if (this.canSetRuleText) {
	        response = yield this.modifySelector2(node, value, true);
	      } else {
	        response = yield this.modifySelector2(node, value);
	      }
	    } else {
	      response = yield this._modifySelector(value);
	    }

	    if (response.ruleProps) {
	      response.ruleProps = response.ruleProps.entries[0];
	    }
	    return response;
	  }), {
	    impl: "_modifySelector"
	  }),

	  setRuleText: custom(function (newText) {
	    this._form.authoredText = newText;
	    return this._setRuleText(newText);
	  }, {
	    impl: "_setRuleText"
	  })
	});

	exports.StyleRuleFront = StyleRuleFront;

	/**
	 * Convenience API for building a list of attribute modifications
	 * for the `modifyProperties` request.  A RuleModificationList holds a
	 * list of modifications that will be applied to a StyleRuleActor.
	 * The modifications are processed in the order in which they are
	 * added to the RuleModificationList.
	 *
	 * Objects of this type expose the same API as @see RuleRewriter.
	 * This lets the inspector use (mostly) the same code, regardless of
	 * whether the server implements setRuleText.
	 */
	var RuleModificationList = Class({
	  /**
	   * Initialize a RuleModificationList.
	   * @param {StyleRuleFront} rule the associated rule
	   */
	  initialize: function (rule) {
	    this.rule = rule;
	    this.modifications = [];
	  },

	  /**
	   * Apply the modifications in this object to the associated rule.
	   *
	   * @return {Promise} A promise which will be resolved when the modifications
	   *         are complete; @see StyleRuleActor.modifyProperties.
	   */
	  apply: function () {
	    return this.rule.modifyProperties(this.modifications);
	  },

	  /**
	   * Add a "set" entry to the modification list.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name the property's name
	   * @param {String} value the property's value
	   * @param {String} priority the property's priority, either the empty
	   *                          string or "important"
	   */
	  setProperty: function (index, name, value, priority) {
	    this.modifications.push({
	      type: "set",
	      name: name,
	      value: value,
	      priority: priority
	    });
	  },

	  /**
	   * Add a "remove" entry to the modification list.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name the name of the property to remove
	   */
	  removeProperty: function (index, name) {
	    this.modifications.push({
	      type: "remove",
	      name: name
	    });
	  },

	  /**
	   * Rename a property.  This implementation acts like
	   * |removeProperty|, because |setRuleText| is not available.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name current name of the property
	   *
	   * This parameter is also passed, but as it is not used in this
	   * implementation, it is omitted.  It is documented here as this
	   * code also defined the interface implemented by @see RuleRewriter.
	   * @param {String} newName new name of the property
	   */
	  renameProperty: function (index, name) {
	    this.removeProperty(index, name);
	  },

	  /**
	   * Enable or disable a property.  This implementation acts like
	   * |removeProperty| when disabling, or a no-op when enabling,
	   * because |setRuleText| is not available.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name current name of the property
	   * @param {Boolean} isEnabled true if the property should be enabled;
	   *                        false if it should be disabled
	   */
	  setPropertyEnabled: function (index, name, isEnabled) {
	    if (!isEnabled) {
	      this.removeProperty(index, name);
	    }
	  },

	  /**
	   * Create a new property.  This implementation does nothing, because
	   * |setRuleText| is not available.
	   *
	   * These parameter are passed, but as they are not used in this
	   * implementation, they are omitted.  They are documented here as
	   * this code also defined the interface implemented by @see
	   * RuleRewriter.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name name of the new property
	   * @param {String} value value of the new property
	   * @param {String} priority priority of the new property; either
	   *                          the empty string or "important"
	   */
	  createProperty: function () {
	    // Nothing.
	  },
	});


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Front, FrontClassWithSpec } = __webpack_require__(19);
	const {
	  getIndentationFromPrefs,
	  getIndentationFromString
	} = __webpack_require__(171);
	const {
	  originalSourceSpec,
	  mediaRuleSpec,
	  styleSheetSpec,
	  styleSheetsSpec
	} = __webpack_require__(126);
	const promise = __webpack_require__(4);
	const { Task } = __webpack_require__(17);
	const events = __webpack_require__(23);

	/**
	 * The client-side counterpart for an OriginalSourceActor.
	 */
	const OriginalSourceFront = FrontClassWithSpec(originalSourceSpec, {
	  initialize: function (client, form) {
	    Front.prototype.initialize.call(this, client, form);

	    this.isOriginalSource = true;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  get href() {
	    return this._form.url;
	  },
	  get url() {
	    return this._form.url;
	  }
	});

	exports.OriginalSourceFront = OriginalSourceFront;

	/**
	 * Corresponding client-side front for a MediaRuleActor.
	 */
	const MediaRuleFront = FrontClassWithSpec(mediaRuleSpec, {
	  initialize: function (client, form) {
	    Front.prototype.initialize.call(this, client, form);

	    this._onMatchesChange = this._onMatchesChange.bind(this);
	    events.on(this, "matches-change", this._onMatchesChange);
	  },

	  _onMatchesChange: function (matches) {
	    this._form.matches = matches;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  get mediaText() {
	    return this._form.mediaText;
	  },
	  get conditionText() {
	    return this._form.conditionText;
	  },
	  get matches() {
	    return this._form.matches;
	  },
	  get line() {
	    return this._form.line || -1;
	  },
	  get column() {
	    return this._form.column || -1;
	  },
	  get parentStyleSheet() {
	    return this.conn.getActor(this._form.parentStyleSheet);
	  }
	});

	exports.MediaRuleFront = MediaRuleFront;

	/**
	 * StyleSheetFront is the client-side counterpart to a StyleSheetActor.
	 */
	const StyleSheetFront = FrontClassWithSpec(styleSheetSpec, {
	  initialize: function (conn, form) {
	    Front.prototype.initialize.call(this, conn, form);

	    this._onPropertyChange = this._onPropertyChange.bind(this);
	    events.on(this, "property-change", this._onPropertyChange);
	  },

	  destroy: function () {
	    events.off(this, "property-change", this._onPropertyChange);
	    Front.prototype.destroy.call(this);
	  },

	  _onPropertyChange: function (property, value) {
	    this._form[property] = value;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  get href() {
	    return this._form.href;
	  },
	  get nodeHref() {
	    return this._form.nodeHref;
	  },
	  get disabled() {
	    return !!this._form.disabled;
	  },
	  get title() {
	    return this._form.title;
	  },
	  get isSystem() {
	    return this._form.system;
	  },
	  get styleSheetIndex() {
	    return this._form.styleSheetIndex;
	  },
	  get ruleCount() {
	    return this._form.ruleCount;
	  },

	  /**
	   * Get the indentation to use for edits to this style sheet.
	   *
	   * @return {Promise} A promise that will resolve to a string that
	   * should be used to indent a block in this style sheet.
	   */
	  guessIndentation: function () {
	    let prefIndent = getIndentationFromPrefs();
	    if (prefIndent) {
	      let {indentUnit, indentWithTabs} = prefIndent;
	      return promise.resolve(indentWithTabs ? "\t" : " ".repeat(indentUnit));
	    }

	    return Task.spawn(function* () {
	      let longStr = yield this.getText();
	      let source = yield longStr.string();

	      let {indentUnit, indentWithTabs} = getIndentationFromString(source);

	      return indentWithTabs ? "\t" : " ".repeat(indentUnit);
	    }.bind(this));
	  }
	});

	exports.StyleSheetFront = StyleSheetFront;

	/**
	 * The corresponding Front object for the StyleSheetsActor.
	 */
	const StyleSheetsFront = FrontClassWithSpec(styleSheetsSpec, {
	  initialize: function (client, tabForm) {
	    Front.prototype.initialize.call(this, client);
	    this.actorID = tabForm.styleSheetsActor;
	    this.manage(this);
	  }
	});

	exports.StyleSheetsFront = StyleSheetsFront;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { FrontClassWithSpec } = __webpack_require__(19);
	const {
	  customHighlighterSpec,
	  highlighterSpec
	} = __webpack_require__(208);

	const HighlighterFront = FrontClassWithSpec(highlighterSpec, {
	  // Update the object given a form representation off the wire.
	  form: function (json) {
	    this.actorID = json.actor;
	    // FF42+ HighlighterActors starts exposing custom form, with traits object
	    this.traits = json.traits || {};
	  }
	});

	exports.HighlighterFront = HighlighterFront;

	const CustomHighlighterFront = FrontClassWithSpec(customHighlighterSpec, {});

	exports.CustomHighlighterFront = CustomHighlighterFront;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  Option,
	  RetVal,
	  generateActorSpec
	} = __webpack_require__(19);

	const highlighterSpec = generateActorSpec({
	  typeName: "highlighter",

	  methods: {
	    showBoxModel: {
	      request: {
	        node: Arg(0, "domnode"),
	        region: Option(1),
	        hideInfoBar: Option(1),
	        hideGuides: Option(1),
	        showOnly: Option(1),
	        onlyRegionArea: Option(1)
	      }
	    },
	    hideBoxModel: {
	      request: {}
	    },
	    pick: {},
	    cancelPick: {}
	  }
	});

	exports.highlighterSpec = highlighterSpec;

	const customHighlighterSpec = generateActorSpec({
	  typeName: "customhighlighter",

	  methods: {
	    release: {
	      release: true
	    },
	    show: {
	      request: {
	        node: Arg(0, "domnode"),
	        options: Arg(1, "nullable:json")
	      },
	      response: {
	        value: RetVal("nullable:boolean")
	      }
	    },
	    hide: {
	      request: {}
	    },
	    finalize: {
	      oneway: true
	    }
	  }
	});

	exports.customHighlighterSpec = customHighlighterSpec;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {DebuggerServer} = __webpack_require__(11);
	const promise = __webpack_require__(4);
	const {longStringSpec, SimpleStringFront} = __webpack_require__(29);
	const protocol = __webpack_require__(19);

	const LongStringFront = protocol.FrontClassWithSpec(longStringSpec, {
	  initialize: function (client) {
	    protocol.Front.prototype.initialize.call(this, client);
	  },

	  destroy: function () {
	    this.initial = null;
	    this.length = null;
	    this.strPromise = null;
	    protocol.Front.prototype.destroy.call(this);
	  },

	  form: function (form) {
	    this.actorID = form.actor;
	    this.initial = form.initial;
	    this.length = form.length;
	  },

	  string: function () {
	    if (!this.strPromise) {
	      let promiseRest = (thusFar) => {
	        if (thusFar.length === this.length) {
	          return promise.resolve(thusFar);
	        }
	        return this.substring(thusFar.length,
	                              thusFar.length + DebuggerServer.LONG_STRING_READ_LENGTH)
	          .then((next) => promiseRest(thusFar + next));
	      };

	      this.strPromise = promiseRest(this.initial);
	    }
	    return this.strPromise;
	  }
	});

	exports.LongStringFront = LongStringFront;
	exports.SimpleStringFront = SimpleStringFront;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  Option,
	  RetVal,
	  generateActorSpec,
	  types
	} = __webpack_require__(19);
	const { nodeSpec } = __webpack_require__(125);
	__webpack_require__(124);
	__webpack_require__(208);

	exports.nodeSpec = nodeSpec;

	/**
	 * Returned from any call that might return a node that isn't connected to root
	 * by nodes the child has seen, such as querySelector.
	 */
	types.addDictType("disconnectedNode", {
	  // The actual node to return
	  node: "domnode",

	  // Nodes that are needed to connect the node to a node the client has already
	  // seen
	  newParents: "array:domnode"
	});

	types.addDictType("disconnectedNodeArray", {
	  // The actual node list to return
	  nodes: "array:domnode",

	  // Nodes that are needed to connect those nodes to the root.
	  newParents: "array:domnode"
	});

	types.addDictType("dommutation", {});

	types.addDictType("searchresult", {
	  list: "domnodelist",
	  // Right now there is isn't anything required for metadata,
	  // but it's json so it can be extended with extra data.
	  metadata: "array:json"
	});

	const nodeListSpec = generateActorSpec({
	  typeName: "domnodelist",

	  methods: {
	    item: {
	      request: { item: Arg(0) },
	      response: RetVal("disconnectedNode")
	    },
	    items: {
	      request: {
	        start: Arg(0, "nullable:number"),
	        end: Arg(1, "nullable:number")
	      },
	      response: RetVal("disconnectedNodeArray")
	    },
	    release: {
	      release: true
	    }
	  }
	});

	exports.nodeListSpec = nodeListSpec;

	// Some common request/response templates for the dom walker

	var nodeArrayMethod = {
	  request: {
	    node: Arg(0, "domnode"),
	    maxNodes: Option(1),
	    center: Option(1, "domnode"),
	    start: Option(1, "domnode"),
	    whatToShow: Option(1)
	  },
	  response: RetVal(types.addDictType("domtraversalarray", {
	    nodes: "array:domnode"
	  }))
	};

	var traversalMethod = {
	  request: {
	    node: Arg(0, "domnode"),
	    whatToShow: Option(1)
	  },
	  response: {
	    node: RetVal("nullable:domnode")
	  }
	};

	const walkerSpec = generateActorSpec({
	  typeName: "domwalker",

	  events: {
	    "new-mutations": {
	      type: "newMutations"
	    },
	    "picker-node-picked": {
	      type: "pickerNodePicked",
	      node: Arg(0, "disconnectedNode")
	    },
	    "picker-node-hovered": {
	      type: "pickerNodeHovered",
	      node: Arg(0, "disconnectedNode")
	    },
	    "picker-node-canceled": {
	      type: "pickerNodeCanceled"
	    },
	    "highlighter-ready": {
	      type: "highlighter-ready"
	    },
	    "highlighter-hide": {
	      type: "highlighter-hide"
	    },
	    "display-change": {
	      type: "display-change",
	      nodes: Arg(0, "array:domnode")
	    },
	    // The walker actor emits a useful "resize" event to its front to let
	    // clients know when the browser window gets resized. This may be useful
	    // for refreshing a DOM node's styles for example, since those may depend on
	    // media-queries.
	    "resize": {
	      type: "resize"
	    }
	  },

	  methods: {
	    release: {
	      release: true
	    },
	    pick: {
	      request: {},
	      response: RetVal("disconnectedNode")
	    },
	    cancelPick: {},
	    highlight: {
	      request: {node: Arg(0, "nullable:domnode")}
	    },
	    document: {
	      request: { node: Arg(0, "nullable:domnode") },
	      response: { node: RetVal("domnode") },
	    },
	    documentElement: {
	      request: { node: Arg(0, "nullable:domnode") },
	      response: { node: RetVal("domnode") },
	    },
	    parents: {
	      request: {
	        node: Arg(0, "domnode"),
	        sameDocument: Option(1),
	        sameTypeRootTreeItem: Option(1)
	      },
	      response: {
	        nodes: RetVal("array:domnode")
	      },
	    },
	    retainNode: {
	      request: { node: Arg(0, "domnode") },
	      response: {}
	    },
	    unretainNode: {
	      request: { node: Arg(0, "domnode") },
	      response: {},
	    },
	    releaseNode: {
	      request: {
	        node: Arg(0, "domnode"),
	        force: Option(1)
	      }
	    },
	    children: nodeArrayMethod,
	    siblings: nodeArrayMethod,
	    nextSibling: traversalMethod,
	    previousSibling: traversalMethod,
	    findInspectingNode: {
	      request: {},
	      response: RetVal("disconnectedNode")
	    },
	    querySelector: {
	      request: {
	        node: Arg(0, "domnode"),
	        selector: Arg(1)
	      },
	      response: RetVal("disconnectedNode")
	    },
	    querySelectorAll: {
	      request: {
	        node: Arg(0, "domnode"),
	        selector: Arg(1)
	      },
	      response: {
	        list: RetVal("domnodelist")
	      }
	    },
	    multiFrameQuerySelectorAll: {
	      request: {
	        selector: Arg(0)
	      },
	      response: {
	        list: RetVal("domnodelist")
	      }
	    },
	    search: {
	      request: {
	        query: Arg(0),
	      },
	      response: {
	        list: RetVal("searchresult"),
	      }
	    },
	    getSuggestionsForQuery: {
	      request: {
	        query: Arg(0),
	        completing: Arg(1),
	        selectorState: Arg(2)
	      },
	      response: {
	        list: RetVal("array:array:string")
	      }
	    },
	    addPseudoClassLock: {
	      request: {
	        node: Arg(0, "domnode"),
	        pseudoClass: Arg(1),
	        parents: Option(2)
	      },
	      response: {}
	    },
	    hideNode: {
	      request: { node: Arg(0, "domnode") }
	    },
	    unhideNode: {
	      request: { node: Arg(0, "domnode") }
	    },
	    removePseudoClassLock: {
	      request: {
	        node: Arg(0, "domnode"),
	        pseudoClass: Arg(1),
	        parents: Option(2)
	      },
	      response: {}
	    },
	    clearPseudoClassLocks: {
	      request: {
	        node: Arg(0, "nullable:domnode")
	      },
	      response: {}
	    },
	    innerHTML: {
	      request: {
	        node: Arg(0, "domnode")
	      },
	      response: {
	        value: RetVal("longstring")
	      }
	    },
	    setInnerHTML: {
	      request: {
	        node: Arg(0, "domnode"),
	        value: Arg(1, "string"),
	      },
	      response: {}
	    },
	    outerHTML: {
	      request: {
	        node: Arg(0, "domnode")
	      },
	      response: {
	        value: RetVal("longstring")
	      }
	    },
	    setOuterHTML: {
	      request: {
	        node: Arg(0, "domnode"),
	        value: Arg(1, "string"),
	      },
	      response: {}
	    },
	    insertAdjacentHTML: {
	      request: {
	        node: Arg(0, "domnode"),
	        position: Arg(1, "string"),
	        value: Arg(2, "string")
	      },
	      response: RetVal("disconnectedNodeArray")
	    },
	    duplicateNode: {
	      request: {
	        node: Arg(0, "domnode")
	      },
	      response: {}
	    },
	    removeNode: {
	      request: {
	        node: Arg(0, "domnode")
	      },
	      response: {
	        nextSibling: RetVal("nullable:domnode")
	      }
	    },
	    removeNodes: {
	      request: {
	        node: Arg(0, "array:domnode")
	      },
	      response: {}
	    },
	    insertBefore: {
	      request: {
	        node: Arg(0, "domnode"),
	        parent: Arg(1, "domnode"),
	        sibling: Arg(2, "nullable:domnode")
	      },
	      response: {}
	    },
	    editTagName: {
	      request: {
	        node: Arg(0, "domnode"),
	        tagName: Arg(1, "string")
	      },
	      response: {}
	    },
	    getMutations: {
	      request: {
	        cleanup: Option(0)
	      },
	      response: {
	        mutations: RetVal("array:dommutation")
	      }
	    },
	    isInDOMTree: {
	      request: { node: Arg(0, "domnode") },
	      response: { attached: RetVal("boolean") }
	    },
	    getNodeActorFromObjectActor: {
	      request: {
	        objectActorID: Arg(0, "string")
	      },
	      response: {
	        nodeFront: RetVal("nullable:disconnectedNode")
	      }
	    },
	    getStyleSheetOwnerNode: {
	      request: {
	        styleSheetActorID: Arg(0, "string")
	      },
	      response: {
	        ownerNode: RetVal("nullable:disconnectedNode")
	      }
	    },
	    getNodeFromActor: {
	      request: {
	        actorID: Arg(0, "string"),
	        path: Arg(1, "array:string")
	      },
	      response: {
	        node: RetVal("nullable:disconnectedNode")
	      }
	    }
	  }
	});

	exports.walkerSpec = walkerSpec;

	const inspectorSpec = generateActorSpec({
	  typeName: "inspector",

	  events: {
	    "color-picked": {
	      type: "colorPicked",
	      color: Arg(0, "string")
	    },
	    "color-pick-canceled": {
	      type: "colorPickCanceled"
	    }
	  },

	  methods: {
	    getWalker: {
	      request: {
	        options: Arg(0, "nullable:json")
	      },
	      response: {
	        walker: RetVal("domwalker")
	      }
	    },
	    getPageStyle: {
	      request: {},
	      response: {
	        pageStyle: RetVal("pagestyle")
	      }
	    },
	    getHighlighter: {
	      request: {
	        autohide: Arg(0, "boolean")
	      },
	      response: {
	        highligter: RetVal("highlighter")
	      }
	    },
	    getHighlighterByType: {
	      request: {
	        typeName: Arg(0)
	      },
	      response: {
	        highlighter: RetVal("nullable:customhighlighter")
	      }
	    },
	    getImageDataFromURL: {
	      request: {url: Arg(0), maxDim: Arg(1, "nullable:number")},
	      response: RetVal("imageData")
	    },
	    resolveRelativeURL: {
	      request: {url: Arg(0, "string"), node: Arg(1, "nullable:domnode")},
	      response: {value: RetVal("string")}
	    },
	    pickColorFromPage: {
	      request: {options: Arg(0, "nullable:json")},
	      response: {}
	    },
	    cancelPickColorFromPage: {
	      request: {},
	      response: {}
	    }
	  }
	});

	exports.inspectorSpec = inspectorSpec;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);
	const {Task} = __webpack_require__(17);
	const flags = __webpack_require__(12);

	/**
	 * Client-side highlighter shared module.
	 * To be used by toolbox panels that need to highlight DOM elements.
	 *
	 * Highlighting and selecting elements is common enough that it needs to be at
	 * toolbox level, accessible by any panel that needs it.
	 * That's why the toolbox is the one that initializes the inspector and
	 * highlighter. It's also why the API returned by this module needs a reference
	 * to the toolbox which should be set once only.
	 */

	/**
	 * Get the highighterUtils instance for a given toolbox.
	 * This should be done once only by the toolbox itself and stored there so that
	 * panels can get it from there. That's because the API returned has a stateful
	 * scope that would be different for another instance returned by this function.
	 *
	 * @param {Toolbox} toolbox
	 * @return {Object} the highlighterUtils public API
	 */
	exports.getHighlighterUtils = function (toolbox) {
	  if (!toolbox || !toolbox.target) {
	    throw new Error("Missing or invalid toolbox passed to getHighlighterUtils");
	    return;
	  }

	  // Exported API properties will go here
	  let exported = {};

	  // The current toolbox target
	  let target = toolbox.target;

	  // Is the highlighter currently in pick mode
	  let isPicking = false;

	  // Is the box model already displayed, used to prevent dispatching
	  // unnecessary requests, especially during toolbox shutdown
	  let isNodeFrontHighlighted = false;

	  /**
	   * Release this utils, nullifying the references to the toolbox
	   */
	  exported.release = function () {
	    toolbox = target = null;
	  };

	  /**
	   * Does the target have the highlighter actor.
	   * The devtools must be backwards compatible with at least B2G 1.3 (28),
	   * which doesn't have the highlighter actor. This can be removed as soon as
	   * the minimal supported version becomes 1.4 (29)
	   */
	  let isRemoteHighlightable = exported.isRemoteHighlightable = function () {
	    return target.client.traits.highlightable;
	  };

	  /**
	   * Does the target support custom highlighters.
	   */
	  let supportsCustomHighlighters = exported.supportsCustomHighlighters = () => {
	    return !!target.client.traits.customHighlighters;
	  };

	  /**
	   * Make a function that initializes the inspector before it runs.
	   * Since the init of the inspector is asynchronous, the return value will be
	   * produced by Task.async and the argument should be a generator
	   * @param {Function*} generator A generator function
	   * @return {Function} A function
	   */
	  let isInspectorInitialized = false;
	  let requireInspector = generator => {
	    return Task.async(function* (...args) {
	      if (!isInspectorInitialized) {
	        yield toolbox.initInspector();
	        isInspectorInitialized = true;
	      }
	      return yield generator.apply(null, args);
	    });
	  };

	  /**
	   * Start/stop the element picker on the debuggee target.
	   * @return A promise that resolves when done
	   */
	  let togglePicker = exported.togglePicker = function () {
	    if (isPicking) {
	      return stopPicker();
	    } else {
	      return startPicker();
	    }
	  };

	  /**
	   * Start the element picker on the debuggee target.
	   * This will request the inspector actor to start listening for mouse events
	   * on the target page to highlight the hovered/picked element.
	   * Depending on the server-side capabilities, this may fire events when nodes
	   * are hovered.
	   * @return A promise that resolves when the picker has started or immediately
	   * if it is already started
	   */
	  let startPicker = exported.startPicker = requireInspector(function* () {
	    if (isPicking) {
	      return;
	    }
	    isPicking = true;

	    toolbox.pickerButtonChecked = true;
	    yield toolbox.selectTool("inspector");
	    toolbox.on("select", stopPicker);

	    if (isRemoteHighlightable()) {
	      toolbox.walker.on("picker-node-hovered", onPickerNodeHovered);
	      toolbox.walker.on("picker-node-picked", onPickerNodePicked);
	      toolbox.walker.on("picker-node-canceled", onPickerNodeCanceled);

	      yield toolbox.highlighter.pick();
	      toolbox.emit("picker-started");
	    } else {
	      // If the target doesn't have the highlighter actor, we can use the
	      // walker's pick method instead, knowing that it only responds when a node
	      // is picked (instead of emitting events)
	      toolbox.emit("picker-started");
	      let node = yield toolbox.walker.pick();
	      onPickerNodePicked({node: node});
	    }
	  });

	  /**
	   * Stop the element picker. Note that the picker is automatically stopped when
	   * an element is picked
	   * @return A promise that resolves when the picker has stopped or immediately
	   * if it is already stopped
	   */
	  let stopPicker = exported.stopPicker = requireInspector(function* () {
	    if (!isPicking) {
	      return;
	    }
	    isPicking = false;

	    toolbox.pickerButtonChecked = false;

	    if (isRemoteHighlightable()) {
	      yield toolbox.highlighter.cancelPick();
	      toolbox.walker.off("picker-node-hovered", onPickerNodeHovered);
	      toolbox.walker.off("picker-node-picked", onPickerNodePicked);
	      toolbox.walker.off("picker-node-canceled", onPickerNodeCanceled);
	    } else {
	      // If the target doesn't have the highlighter actor, use the walker's
	      // cancelPick method instead
	      yield toolbox.walker.cancelPick();
	    }

	    toolbox.off("select", stopPicker);
	    toolbox.emit("picker-stopped");
	  });

	  /**
	   * When a node is hovered by the mouse when the highlighter is in picker mode
	   * @param {Object} data Information about the node being hovered
	   */
	  function onPickerNodeHovered(data) {
	    toolbox.emit("picker-node-hovered", data.node);
	  }

	  /**
	   * When a node has been picked while the highlighter is in picker mode
	   * @param {Object} data Information about the picked node
	   */
	  function onPickerNodePicked(data) {
	    toolbox.selection.setNodeFront(data.node, "picker-node-picked");
	    stopPicker();
	  }

	  /**
	   * When the picker is canceled, stop the picker, and make sure the toolbox
	   * gets the focus.
	   */
	  function onPickerNodeCanceled() {
	    stopPicker();
	    toolbox.win.focus();
	  }

	  /**
	   * Show the box model highlighter on a node in the content page.
	   * The node needs to be a NodeFront, as defined by the inspector actor
	   * @see devtools/server/actors/inspector.js
	   * @param {NodeFront} nodeFront The node to highlight
	   * @param {Object} options
	   * @return A promise that resolves when the node has been highlighted
	   */
	  let highlightNodeFront = exported.highlightNodeFront = requireInspector(
	  function* (nodeFront, options = {}) {
	    if (!nodeFront) {
	      return;
	    }

	    isNodeFrontHighlighted = true;
	    if (isRemoteHighlightable()) {
	      yield toolbox.highlighter.showBoxModel(nodeFront, options);
	    } else {
	      // If the target doesn't have the highlighter actor, revert to the
	      // walker's highlight method, which draws a simple outline
	      yield toolbox.walker.highlight(nodeFront);
	    }

	    toolbox.emit("node-highlight", nodeFront, options.toSource());
	  });

	  /**
	   * This is a convenience method in case you don't have a nodeFront but a
	   * valueGrip. This is often the case with VariablesView properties.
	   * This method will simply translate the grip into a nodeFront and call
	   * highlightNodeFront, so it has the same signature.
	   * @see highlightNodeFront
	   */
	  let highlightDomValueGrip = exported.highlightDomValueGrip = requireInspector(
	  function* (valueGrip, options = {}) {
	    let nodeFront = yield gripToNodeFront(valueGrip);
	    if (nodeFront) {
	      yield highlightNodeFront(nodeFront, options);
	    } else {
	      throw new Error("The ValueGrip passed could not be translated to a NodeFront");
	    }
	  });

	  /**
	   * Translate a debugger value grip into a node front usable by the inspector
	   * @param {ValueGrip}
	   * @return a promise that resolves to the node front when done
	   */
	  let gripToNodeFront = exported.gripToNodeFront = requireInspector(
	  function* (grip) {
	    return yield toolbox.walker.getNodeActorFromObjectActor(grip.actor);
	  });

	  /**
	   * Hide the highlighter.
	   * @param {Boolean} forceHide Only really matters in test mode (when
	   * flags.testing is true). In test mode, hovering over several nodes
	   * in the markup view doesn't hide/show the highlighter to ease testing. The
	   * highlighter stays visible at all times, except when the mouse leaves the
	   * markup view, which is when this param is passed to true
	   * @return a promise that resolves when the highlighter is hidden
	   */
	  let unhighlight = exported.unhighlight = Task.async(
	  function* (forceHide = false) {
	    forceHide = forceHide || !flags.testing;

	    // Note that if isRemoteHighlightable is true, there's no need to hide the
	    // highlighter as the walker uses setTimeout to hide it after some time
	    if (isNodeFrontHighlighted && forceHide && toolbox.highlighter && isRemoteHighlightable()) {
	      isNodeFrontHighlighted = false;
	      yield toolbox.highlighter.hideBoxModel();
	    }

	    // unhighlight is called when destroying the toolbox, which means that by
	    // now, the toolbox reference might have been nullified already.
	    if (toolbox) {
	      toolbox.emit("node-unhighlight");
	    }
	  });

	  /**
	   * If the main, box-model, highlighter isn't enough, or if multiple
	   * highlighters are needed in parallel, this method can be used to return a
	   * new instance of a highlighter actor, given a type.
	   * The type of the highlighter passed must be known by the server.
	   * The highlighter actor returned will have the show(nodeFront) and hide()
	   * methods and needs to be released by the consumer when not needed anymore.
	   * @return a promise that resolves to the highlighter
	   */
	  let getHighlighterByType = exported.getHighlighterByType = requireInspector(
	  function* (typeName) {
	    let highlighter = null;

	    if (supportsCustomHighlighters()) {
	      highlighter = yield toolbox.inspector.getHighlighterByType(typeName);
	    }

	    return highlighter || promise.reject("The target doesn't support " +
	        `creating highlighters by types or ${typeName} is unknown`);

	  });

	  // Return the public API
	  return exported;
	};


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const { DOM, createClass, PropTypes } = __webpack_require__(196);

	// Shortcuts
	const { button } = DOM;

	/**
	 * Sidebar toggle button. This button is used to exapand
	 * and collapse Sidebar.
	 */
	var SidebarToggle = createClass({
	  displayName: "SidebarToggle",

	  propTypes: {
	    // Set to true if collapsed.
	    collapsed: PropTypes.bool.isRequired,
	    // Tooltip text used when the button indicates expanded state.
	    collapsePaneTitle: PropTypes.string.isRequired,
	    // Tooltip text used when the button indicates collapsed state.
	    expandPaneTitle: PropTypes.string.isRequired,
	    // Click callback
	    onClick: PropTypes.func.isRequired,
	  },

	  getInitialState: function () {
	    return {
	      collapsed: this.props.collapsed,
	    };
	  },

	  // Events

	  onClick: function (event) {
	    this.props.onClick(event);
	  },

	  // Rendering

	  render: function () {
	    let title = this.state.collapsed ?
	      this.props.expandPaneTitle :
	      this.props.collapsePaneTitle;

	    let classNames = ["devtools-button", "sidebar-toggle"];
	    if (this.state.collapsed) {
	      classNames.push("pane-collapsed");
	    }

	    return (
	      button({
	        className: classNames.join(" "),
	        title: title,
	        onClick: this.onClick
	      })
	    );
	  }
	});

	module.exports = SidebarToggle;


/***/ }
/******/ ]);