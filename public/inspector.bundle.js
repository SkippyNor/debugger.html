/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var Services = __webpack_require__(1);
	var promise = __webpack_require__(4);
	var defer = __webpack_require__(5);
	var EventEmitter = __webpack_require__(6);
	const {executeSoon} = __webpack_require__(8);
	var {KeyShortcuts} = __webpack_require__(13);
	var {Task} = __webpack_require__(15);
	const {initCssProperties} = __webpack_require__(16);
	const nodeConstants = __webpack_require__(31);
	const Telemetry = __webpack_require__(32);

	const Menu = __webpack_require__(33);
	const MenuItem = __webpack_require__(34);

	const {CommandUtils} = __webpack_require__(9);
	const {ComputedViewTool} = __webpack_require__(35);
	const {FontInspector} = __webpack_require__(213);
	const {HTMLBreadcrumbs} = __webpack_require__(214);
	const {InspectorSearch} = __webpack_require__(215);
	const {MarkupView} = __webpack_require__(216);
	const {RuleViewTool} = __webpack_require__(198);
	const {ToolSidebar} = __webpack_require__(242);
	const {ViewHelpers} = __webpack_require__(243);
	const clipboardHelper = __webpack_require__(207);

	const {LocalizationHelper} = __webpack_require__(56);
	const INSPECTOR_L10N = new LocalizationHelper("devtools/locale/inspector.properties");
	const TOOLBOX_L10N = new LocalizationHelper("devtools/locale/toolbox.properties");

	/**
	 * Represents an open instance of the Inspector for a tab.
	 * The inspector controls the breadcrumbs, the markup view, and the sidebar
	 * (computed view, rule view, font view and layout view).
	 *
	 * Events:
	 * - ready
	 *      Fired when the inspector panel is opened for the first time and ready to
	 *      use
	 * - new-root
	 *      Fired after a new root (navigation to a new page) event was fired by
	 *      the walker, and taken into account by the inspector (after the markup
	 *      view has been reloaded)
	 * - markuploaded
	 *      Fired when the markup-view frame has loaded
	 * - breadcrumbs-updated
	 *      Fired when the breadcrumb widget updates to a new node
	 * - layoutview-updated
	 *      Fired when the layoutview (box model) updates to a new node
	 * - markupmutation
	 *      Fired after markup mutations have been processed by the markup-view
	 * - computed-view-refreshed
	 *      Fired when the computed rules view updates to a new node
	 * - computed-view-property-expanded
	 *      Fired when a property is expanded in the computed rules view
	 * - computed-view-property-collapsed
	 *      Fired when a property is collapsed in the computed rules view
	 * - computed-view-sourcelinks-updated
	 *      Fired when the stylesheet source links have been updated (when switching
	 *      to source-mapped files)
	 * - computed-view-filtered
	 *      Fired when the computed rules view is filtered
	 * - rule-view-refreshed
	 *      Fired when the rule view updates to a new node
	 * - rule-view-sourcelinks-updated
	 *      Fired when the stylesheet source links have been updated (when switching
	 *      to source-mapped files)
	 */
	function InspectorPanel(iframeWindow, toolbox) {
	  this._toolbox = toolbox;
	  this._target = toolbox._target;
	  this.panelDoc = iframeWindow.document;
	  this.panelWin = iframeWindow;
	  this.panelWin.inspector = this;

	  this.telemetry = new Telemetry();

	  this.nodeMenuTriggerInfo = null;

	  this._handleRejectionIfNotDestroyed = this._handleRejectionIfNotDestroyed.bind(this);
	  this._onBeforeNavigate = this._onBeforeNavigate.bind(this);
	  this.onNewRoot = this.onNewRoot.bind(this);
	  this._onContextMenu = this._onContextMenu.bind(this);
	  this._updateSearchResultsLabel = this._updateSearchResultsLabel.bind(this);
	  this.onNewSelection = this.onNewSelection.bind(this);
	  this.onBeforeNewSelection = this.onBeforeNewSelection.bind(this);
	  this.onDetached = this.onDetached.bind(this);
	  this.onPaneToggleButtonClicked = this.onPaneToggleButtonClicked.bind(this);
	  this._onMarkupFrameLoad = this._onMarkupFrameLoad.bind(this);

	  this._target.on("will-navigate", this._onBeforeNavigate);
	  this._detectingActorFeatures = this._detectActorFeatures();

	  EventEmitter.decorate(this);
	}

	exports.InspectorPanel = InspectorPanel;

	InspectorPanel.prototype = {
	  /**
	   * open is effectively an asynchronous constructor
	   */
	  open: Task.async(function* () {
	    this._cssPropertiesLoaded = initCssProperties(this.toolbox);
	    yield this._cssPropertiesLoaded;
	    yield this.target.makeRemote();
	    yield this._getPageStyle();
	    let defaultSelection = yield this._getDefaultNodeForSelection();
	    return yield this._deferredOpen(defaultSelection);
	  }),

	  get toolbox() {
	    return this._toolbox;
	  },

	  get inspector() {
	    return this._toolbox.inspector;
	  },

	  get walker() {
	    return this._toolbox.walker;
	  },

	  get selection() {
	    return this._toolbox.selection;
	  },

	  get isOuterHTMLEditable() {
	    return this._target.client.traits.editOuterHTML;
	  },

	  get hasUrlToImageDataResolver() {
	    return this._target.client.traits.urlToImageDataResolver;
	  },

	  get canGetUniqueSelector() {
	    return this._target.client.traits.getUniqueSelector;
	  },

	  get canGetUsedFontFaces() {
	    return this._target.client.traits.getUsedFontFaces;
	  },

	  get canPasteInnerOrAdjacentHTML() {
	    return this._target.client.traits.pasteHTML;
	  },

	  /**
	   * Handle promise rejections for various asynchronous actions, and only log errors if
	   * the inspector panel still exists.
	   * This is useful to silence useless errors that happen when the inspector is closed
	   * while still initializing (and making protocol requests).
	   */
	  _handleRejectionIfNotDestroyed: function (e) {
	    if (!this._panelDestroyer) {
	      console.error(e);
	    }
	  },

	  /**
	   * Figure out what features the backend supports
	   */
	  _detectActorFeatures: function () {
	    this._supportsDuplicateNode = false;
	    this._supportsScrollIntoView = false;
	    this._supportsResolveRelativeURL = false;

	    // Use getActorDescription first so that all actorHasMethod calls use
	    // a cached response from the server.
	    return this._target.getActorDescription("domwalker").then(desc => {
	      return promise.all([
	        this._target.actorHasMethod("domwalker", "duplicateNode").then(value => {
	          this._supportsDuplicateNode = value;
	        }).catch(e => console.error(e)),
	        this._target.actorHasMethod("domnode", "scrollIntoView").then(value => {
	          this._supportsScrollIntoView = value;
	        }).catch(e => console.error(e)),
	        this._target.actorHasMethod("inspector", "resolveRelativeURL").then(value => {
	          this._supportsResolveRelativeURL = value;
	        }).catch(e => console.error(e)),
	      ]);
	    });
	  },

	  _deferredOpen: function (defaultSelection) {
	    let deferred = defer();

	    this.walker.on("new-root", this.onNewRoot);

	    this.selection.on("new-node-front", this.onNewSelection);
	    this.selection.on("before-new-node-front", this.onBeforeNewSelection);
	    this.selection.on("detached-front", this.onDetached);

	    this.breadcrumbs = new HTMLBreadcrumbs(this);

	    if (this.target.isLocalTab) {
	      // Show a warning when the debugger is paused.
	      // We show the warning only when the inspector
	      // is selected.
	      this.updateDebuggerPausedWarning = () => {
	        let notificationBox = this._toolbox.getNotificationBox();
	        let notification =
	          notificationBox.getNotificationWithValue("inspector-script-paused");
	        if (!notification && this._toolbox.currentToolId == "inspector" &&
	            this._toolbox.threadClient.paused) {
	          let message = INSPECTOR_L10N.getStr("debuggerPausedWarning.message");
	          notificationBox.appendNotification(message,
	            "inspector-script-paused", "", notificationBox.PRIORITY_WARNING_HIGH);
	        }

	        if (notification && this._toolbox.currentToolId != "inspector") {
	          notificationBox.removeNotification(notification);
	        }

	        if (notification && !this._toolbox.threadClient.paused) {
	          notificationBox.removeNotification(notification);
	        }
	      };
	      this.target.on("thread-paused", this.updateDebuggerPausedWarning);
	      this.target.on("thread-resumed", this.updateDebuggerPausedWarning);
	      this._toolbox.on("select", this.updateDebuggerPausedWarning);
	      this.updateDebuggerPausedWarning();
	    }

	    this._initMarkup();
	    this.isReady = false;

	    this.once("markuploaded", () => {
	      this.isReady = true;

	      // All the components are initialized. Let's select a node.
	      this.selection.setNodeFront(defaultSelection, "inspector-open");
	      this.markup.expandNode(this.selection.nodeFront);

	      // And setup the toolbar only now because it may depend on the document.
	      this.setupToolbar();

	      this.emit("ready");
	      deferred.resolve(this);
	    });

	    this.setupSearchBox();
	    this.setupSidebar();

	    return deferred.promise;
	  },

	  _onBeforeNavigate: function () {
	    this._defaultNode = null;
	    this.selection.setNodeFront(null);
	    this._destroyMarkup();
	    this.isDirty = false;
	    this._pendingSelection = null;
	  },

	  _getPageStyle: function () {
	    return this._toolbox.inspector.getPageStyle().then(pageStyle => {
	      this.pageStyle = pageStyle;
	    }, this._handleRejectionIfNotDestroyed);
	  },

	  /**
	   * Return a promise that will resolve to the default node for selection.
	   */
	  _getDefaultNodeForSelection: function () {
	    if (this._defaultNode) {
	      return this._defaultNode;
	    }
	    let walker = this.walker;
	    let rootNode = null;
	    let pendingSelection = this._pendingSelection;

	    // A helper to tell if the target has or is about to navigate.
	    // this._pendingSelection changes on "will-navigate" and "new-root" events.
	    let hasNavigated = () => pendingSelection !== this._pendingSelection;

	    // If available, set either the previously selected node or the body
	    // as default selected, else set documentElement
	    return walker.getRootNode().then(node => {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }

	      rootNode = node;
	      if (this.selectionCssSelector) {
	        return walker.querySelector(rootNode, this.selectionCssSelector);
	      }
	      return null;
	    }).then(front => {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }

	      if (front) {
	        return front;
	      }
	      return walker.querySelector(rootNode, "body");
	    }).then(front => {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }

	      if (front) {
	        return front;
	      }
	      return this.walker.documentElement();
	    }).then(node => {
	      if (hasNavigated()) {
	        return promise.reject("navigated; resolution of _defaultNode aborted");
	      }
	      this._defaultNode = node;
	      return node;
	    });
	  },

	  /**
	   * Target getter.
	   */
	  get target() {
	    return this._target;
	  },

	  /**
	   * Target setter.
	   */
	  set target(value) {
	    this._target = value;
	  },

	  /**
	   * Indicate that a tool has modified the state of the page.  Used to
	   * decide whether to show the "are you sure you want to navigate"
	   * notification.
	   */
	  markDirty: function () {
	    this.isDirty = true;
	  },

	  /**
	   * Hooks the searchbar to show result and auto completion suggestions.
	   */
	  setupSearchBox: function () {
	    this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
	    this.searchClearButton = this.panelDoc.getElementById("inspector-searchinput-clear");
	    this.searchResultsLabel = this.panelDoc.getElementById("inspector-searchlabel");

	    this.search = new InspectorSearch(this, this.searchBox, this.searchClearButton);
	    this.search.on("search-cleared", this._updateSearchResultsLabel);
	    this.search.on("search-result", this._updateSearchResultsLabel);

	    let shortcuts = new KeyShortcuts({
	      window: this.panelDoc.defaultView,
	    });
	    let key = INSPECTOR_L10N.getStr("inspector.searchHTML.key");
	    shortcuts.on(key, (name, event) => {
	      // Prevent overriding same shortcut from the computed/rule views
	      if (event.target.closest("#sidebar-panel-ruleview") ||
	          event.target.closest("#sidebar-panel-computedview")) {
	        return;
	      }
	      event.preventDefault();
	      this.searchBox.focus();
	    });
	  },

	  get searchSuggestions() {
	    return this.search.autocompleter;
	  },

	  _updateSearchResultsLabel: function (event, result) {
	    let str = "";
	    if (event !== "search-cleared") {
	      if (result) {
	        str = INSPECTOR_L10N.getFormatStr(
	          "inspector.searchResultsCount2", result.resultsIndex + 1, result.resultsLength);
	      } else {
	        str = INSPECTOR_L10N.getStr("inspector.searchResultsNone");
	      }
	    }

	    this.searchResultsLabel.textContent = str;
	  },

	  get React() {
	    return this._toolbox.React;
	  },

	  get ReactDOM() {
	    return this._toolbox.ReactDOM;
	  },

	  get browserRequire() {
	    return this._toolbox.browserRequire;
	  },

	  /**
	   * Build the sidebar.
	   */
	  setupSidebar: function () {
	    let tabbox = this.panelDoc.querySelector("#inspector-sidebar");
	    this.sidebar = new ToolSidebar(tabbox, this, "inspector", {
	      showAllTabsMenu: true
	    });

	    let defaultTab = Services.prefs.getCharPref("devtools.inspector.activeSidebar");

	    if (!Services.prefs.getBoolPref("devtools.fontinspector.enabled") &&
	       defaultTab == "fontinspector") {
	      defaultTab = "ruleview";
	    }

	    // Append all side panels
	    this.sidebar.addExistingTab(
	      "ruleview",
	      INSPECTOR_L10N.getStr("inspector.sidebar.ruleViewTitle"),
	      defaultTab == "ruleview");

	    this.sidebar.addExistingTab(
	      "computedview",
	      INSPECTOR_L10N.getStr("inspector.sidebar.computedViewTitle"),
	      defaultTab == "computedview");

	    this._setDefaultSidebar = (event, toolId) => {
	      Services.prefs.setCharPref("devtools.inspector.activeSidebar", toolId);
	    };

	    this.sidebar.on("select", this._setDefaultSidebar);

	    this.ruleview = new RuleViewTool(this, this.panelWin);
	    this.computedview = new ComputedViewTool(this, this.panelWin);

	    if (this.target.form.animationsActor) {
	      this.sidebar.addFrameTab(
	        "animationinspector",
	        INSPECTOR_L10N.getStr("inspector.sidebar.animationInspectorTitle"),
	        "chrome://devtools/content/animationinspector/animation-inspector.xhtml",
	        defaultTab == "animationinspector");
	    }

	    if (Services.prefs.getBoolPref("devtools.fontinspector.enabled") &&
	        this.canGetUsedFontFaces) {
	      this.sidebar.addExistingTab(
	        "fontinspector",
	        INSPECTOR_L10N.getStr("inspector.sidebar.fontInspectorTitle"),
	        defaultTab == "fontinspector");

	      this.fontInspector = new FontInspector(this, this.panelWin);
	      this.sidebar.toggleTab(true, "fontinspector");
	    }

	    this.setupSidebarSize();

	    this.sidebar.show(defaultTab);
	  },

	  /**
	   * Sidebar size is currently driven by vbox.inspector-sidebar-container
	   * element, which is located at the left/bottom side of the side bar splitter.
	   * Its size is changed by the splitter and stored into preferences.
	   * As soon as bug 1260552 is fixed and new HTML based splitter in place
	   * the size can be driven by div.inspector-sidebar element. This element
	   * represents the ToolSidebar and so, the entire logic related to size
	   * persistence can be done inside the ToolSidebar.
	   */
	  setupSidebarSize: function () {
	    let sidePaneContainer = this.panelDoc.querySelector(
	      "#inspector-sidebar-container");

	    this.sidebar.on("show", () => {
	      try {
	        sidePaneContainer.width = Services.prefs.getIntPref(
	          "devtools.toolsidebar-width.inspector");
	        sidePaneContainer.height = Services.prefs.getIntPref(
	          "devtools.toolsidebar-height.inspector");
	      } catch (e) {
	        // The default width is the min-width set in CSS
	        // for #inspector-sidebar-container
	        // Set width and height of the sidebar container. Only one
	        // value is really useful at a time depending on the current
	        // toolbox orientation and having both doesn't break anything.
	        sidePaneContainer.width = 450;
	        sidePaneContainer.height = 450;
	      }
	    });

	    this.sidebar.on("hide", () => {
	      Services.prefs.setIntPref("devtools.toolsidebar-width.inspector",
	        sidePaneContainer.width);
	      Services.prefs.setIntPref("devtools.toolsidebar-height.inspector",
	        sidePaneContainer.height);
	    });

	    this.sidebar.on("destroy", () => {
	      Services.prefs.setIntPref("devtools.toolsidebar-width.inspector",
	        sidePaneContainer.width);
	      Services.prefs.setIntPref("devtools.toolsidebar-height.inspector",
	        sidePaneContainer.height);
	    });
	  },

	  setupToolbar: function () {
	    this.teardownToolbar();

	    // Setup the sidebar toggle button.
	    let SidebarToggle = this.React.createFactory(this.browserRequire(
	      "devtools/client/shared/components/sidebar-toggle"));

	    let sidebarToggle = SidebarToggle({
	      onClick: this.onPaneToggleButtonClicked,
	      collapsed: false,
	      expandPaneTitle: INSPECTOR_L10N.getStr("inspector.expandPane"),
	      collapsePaneTitle: INSPECTOR_L10N.getStr("inspector.collapsePane"),
	    });

	    let parentBox = this.panelDoc.getElementById("inspector-sidebar-toggle-box");
	    this._sidebarToggle = this.ReactDOM.render(sidebarToggle, parentBox);

	    // Setup the add-node button.
	    this.addNode = this.addNode.bind(this);
	    this.addNodeButton = this.panelDoc.getElementById("inspector-element-add-button");
	    this.addNodeButton.addEventListener("click", this.addNode);

	    // Setup the eye-dropper icon if we're in an HTML document and we have actor support.
	    if (this.selection.nodeFront && this.selection.nodeFront.isInHTMLDocument) {
	      this.toolbox.target.actorHasMethod("inspector", "pickColorFromPage").then(value => {
	        if (!value) {
	          return;
	        }

	        this.onEyeDropperDone = this.onEyeDropperDone.bind(this);
	        this.onEyeDropperButtonClicked = this.onEyeDropperButtonClicked.bind(this);
	        this.eyeDropperButton = this.panelDoc
	                                    .getElementById("inspector-eyedropper-toggle");
	        this.eyeDropperButton.style.display = "initial";
	        this.eyeDropperButton.addEventListener("click", this.onEyeDropperButtonClicked);
	      }, e => console.error(e));
	    } else {
	      this.panelDoc.getElementById("inspector-eyedropper-toggle").style.display = "none";
	    }
	  },

	  teardownToolbar: function () {
	    this._sidebarToggle = null;

	    if (this.addNodeButton) {
	      this.addNodeButton.removeEventListener("click", this.addNode);
	      this.addNodeButton = null;
	    }

	    if (this.eyeDropperButton) {
	      this.eyeDropperButton.removeEventListener("click", this.onEyeDropperButtonClicked);
	      this.eyeDropperButton = null;
	    }
	  },

	  /**
	   * Reset the inspector on new root mutation.
	   */
	  onNewRoot: function () {
	    this._defaultNode = null;
	    this.selection.setNodeFront(null);
	    this._destroyMarkup();
	    this.isDirty = false;

	    let onNodeSelected = defaultNode => {
	      // Cancel this promise resolution as a new one had
	      // been queued up.
	      if (this._pendingSelection != onNodeSelected) {
	        return;
	      }
	      this._pendingSelection = null;
	      this.selection.setNodeFront(defaultNode, "navigateaway");

	      this._initMarkup();
	      this.once("markuploaded", () => {
	        if (!this.markup) {
	          return;
	        }
	        this.markup.expandNode(this.selection.nodeFront);
	        this.emit("new-root");
	      });

	      // Setup the toolbar again, since its content may depend on the current document.
	      this.setupToolbar();
	    };
	    this._pendingSelection = onNodeSelected;
	    this._getDefaultNodeForSelection()
	        .then(onNodeSelected, this._handleRejectionIfNotDestroyed);
	  },

	  _selectionCssSelector: null,

	  /**
	   * Set the currently selected node unique css selector.
	   * Will store the current target url along with it to allow pre-selection at
	   * reload
	   */
	  set selectionCssSelector(cssSelector) {
	    if (this._panelDestroyer) {
	      return;
	    }

	    this._selectionCssSelector = {
	      selector: cssSelector || null,
	      url: this._target.url
	    };
	  },

	  /**
	   * Get the current selection unique css selector if any, that is, if a node
	   * is actually selected and that node has been selected while on the same url
	   */
	  get selectionCssSelector() {
	    if (this._selectionCssSelector &&
	        this._selectionCssSelector.url === this._target.url) {
	      return this._selectionCssSelector.selector;
	    }
	    return null;
	  },

	  /**
	   * Can a new HTML element be inserted into the currently selected element?
	   * @return {Boolean}
	   */
	  canAddHTMLChild: function () {
	    let selection = this.selection;

	    // Don't allow to insert an element into these elements. This should only
	    // contain elements where walker.insertAdjacentHTML has no effect.
	    let invalidTagNames = ["html", "iframe"];

	    return selection.isHTMLNode() &&
	           selection.isElementNode() &&
	           !selection.isPseudoElementNode() &&
	           !selection.isAnonymousNode() &&
	           invalidTagNames.indexOf(
	            selection.nodeFront.nodeName.toLowerCase()) === -1;
	  },

	  /**
	   * When a new node is selected.
	   */
	  onNewSelection: function (event, value, reason) {
	    if (reason === "selection-destroy") {
	      return;
	    }

	    // Wait for all the known tools to finish updating and then let the
	    // client know.
	    let selection = this.selection.nodeFront;

	    // Update the state of the add button in the toolbar depending on the
	    // current selection.
	    let btn = this.panelDoc.querySelector("#inspector-element-add-button");
	    if (this.canAddHTMLChild()) {
	      btn.removeAttribute("disabled");
	    } else {
	      btn.setAttribute("disabled", "true");
	    }

	    // On any new selection made by the user, store the unique css selector
	    // of the selected node so it can be restored after reload of the same page
	    if (this.canGetUniqueSelector &&
	        this.selection.isElementNode()) {
	      selection.getUniqueSelector().then(selector => {
	        this.selectionCssSelector = selector;
	      }, this._handleRejectionIfNotDestroyed);
	    }

	    let selfUpdate = this.updating("inspector-panel");
	    executeSoon(() => {
	      try {
	        selfUpdate(selection);
	      } catch (ex) {
	        console.error(ex);
	      }
	    });
	  },

	  /**
	   * Delay the "inspector-updated" notification while a tool
	   * is updating itself.  Returns a function that must be
	   * invoked when the tool is done updating with the node
	   * that the tool is viewing.
	   */
	  updating: function (name) {
	    if (this._updateProgress && this._updateProgress.node != this.selection.nodeFront) {
	      this.cancelUpdate();
	    }

	    if (!this._updateProgress) {
	      // Start an update in progress.
	      let self = this;
	      this._updateProgress = {
	        node: this.selection.nodeFront,
	        outstanding: new Set(),
	        checkDone: function () {
	          if (this !== self._updateProgress) {
	            return;
	          }
	          // Cancel update if there is no `selection` anymore.
	          // It can happen if the inspector panel is already destroyed.
	          if (!self.selection || (this.node !== self.selection.nodeFront)) {
	            self.cancelUpdate();
	            return;
	          }
	          if (this.outstanding.size !== 0) {
	            return;
	          }

	          self._updateProgress = null;
	          self.emit("inspector-updated", name);
	        },
	      };
	    }

	    let progress = this._updateProgress;
	    let done = function () {
	      progress.outstanding.delete(done);
	      progress.checkDone();
	    };
	    progress.outstanding.add(done);
	    return done;
	  },

	  /**
	   * Cancel notification of inspector updates.
	   */
	  cancelUpdate: function () {
	    this._updateProgress = null;
	  },

	  /**
	   * When a new node is selected, before the selection has changed.
	   */
	  onBeforeNewSelection: function (event, node) {
	    if (this.breadcrumbs.indexOf(node) == -1) {
	      // only clear locks if we'd have to update breadcrumbs
	      this.clearPseudoClasses();
	    }
	  },

	  /**
	   * When a node is deleted, select its parent node or the defaultNode if no
	   * parent is found (may happen when deleting an iframe inside which the
	   * node was selected).
	   */
	  onDetached: function (event, parentNode) {
	    this.breadcrumbs.cutAfter(this.breadcrumbs.indexOf(parentNode));
	    this.selection.setNodeFront(parentNode ? parentNode : this._defaultNode, "detached");
	  },

	  /**
	   * Destroy the inspector.
	   */
	  destroy: function () {
	    if (this._panelDestroyer) {
	      return this._panelDestroyer;
	    }

	    if (this.walker) {
	      this.walker.off("new-root", this.onNewRoot);
	      this.pageStyle = null;
	    }

	    this.cancelUpdate();

	    this.target.off("will-navigate", this._onBeforeNavigate);

	    this.target.off("thread-paused", this.updateDebuggerPausedWarning);
	    this.target.off("thread-resumed", this.updateDebuggerPausedWarning);
	    this._toolbox.off("select", this.updateDebuggerPausedWarning);

	    if (this.ruleview) {
	      this.ruleview.destroy();
	    }

	    if (this.computedview) {
	      this.computedview.destroy();
	    }

	    if (this.fontInspector) {
	      this.fontInspector.destroy();
	    }

	    let cssPropertiesDestroyer = this._cssPropertiesLoaded.then(({front}) => {
	      if (front) {
	        front.destroy();
	      }
	    });

	    this.sidebar.off("select", this._setDefaultSidebar);
	    let sidebarDestroyer = this.sidebar.destroy();
	    this.sidebar = null;

	    this.teardownToolbar();
	    this.breadcrumbs.destroy();
	    this.selection.off("new-node-front", this.onNewSelection);
	    this.selection.off("before-new-node-front", this.onBeforeNewSelection);
	    this.selection.off("detached-front", this.onDetached);
	    let markupDestroyer = this._destroyMarkup();
	    this.panelWin.inspector = null;
	    this.target = null;
	    this.panelDoc = null;
	    this.panelWin = null;
	    this.breadcrumbs = null;
	    this._toolbox = null;
	    this.search.destroy();
	    this.search = null;
	    this.searchBox = null;

	    this._panelDestroyer = promise.all([
	      sidebarDestroyer,
	      markupDestroyer,
	      cssPropertiesDestroyer
	    ]);

	    return this._panelDestroyer;
	  },

	  /**
	   * Returns the clipboard content if it is appropriate for pasting
	   * into the current node's outer HTML, otherwise returns null.
	   */
	  _getClipboardContentForPaste: function () {
	    let flavors = clipboardHelper.getCurrentFlavors();
	    if (flavors.indexOf("text") != -1 ||
	        (flavors.indexOf("html") != -1 && flavors.indexOf("image") == -1)) {
	      let content = clipboardHelper.getData();
	      if (content && content.trim().length > 0) {
	        return content;
	      }
	    }
	    return null;
	  },

	  _onContextMenu: function (e) {
	    e.preventDefault();
	    this._openMenu({
	      screenX: e.screenX,
	      screenY: e.screenY,
	      target: e.target,
	    });
	  },

	  _openMenu: function ({ target, screenX = 0, screenY = 0 } = { }) {
	    let markupContainer = this.markup.getContainer(this.selection.nodeFront);

	    this.contextMenuTarget = target;
	    this.nodeMenuTriggerInfo = markupContainer &&
	      markupContainer.editor.getInfoAtNode(target);

	    let isSelectionElement = this.selection.isElementNode() &&
	                             !this.selection.isPseudoElementNode();
	    let isEditableElement = isSelectionElement &&
	                            !this.selection.isAnonymousNode();
	    let isDuplicatableElement = isSelectionElement &&
	                                !this.selection.isAnonymousNode() &&
	                                !this.selection.isRoot();
	    let isScreenshotable = isSelectionElement &&
	                           this.canGetUniqueSelector &&
	                           this.selection.nodeFront.isTreeDisplayed;

	    let menu = new Menu();
	    menu.append(new MenuItem({
	      id: "node-menu-edithtml",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLEdit.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorHTMLEdit.accesskey"),
	      disabled: !isEditableElement || !this.isOuterHTMLEditable,
	      click: () => this.editHTML(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-add",
	      label: INSPECTOR_L10N.getStr("inspectorAddNode.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorAddNode.accesskey"),
	      disabled: !this.canAddHTMLChild(),
	      click: () => this.addNode(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-duplicatenode",
	      label: INSPECTOR_L10N.getStr("inspectorDuplicateNode.label"),
	      hidden: !this._supportsDuplicateNode,
	      disabled: !isDuplicatableElement,
	      click: () => this.duplicateNode(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-delete",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLDelete.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorHTMLDelete.accesskey"),
	      disabled: !isEditableElement,
	      click: () => this.deleteNode(),
	    }));

	    menu.append(new MenuItem({
	      label: INSPECTOR_L10N.getStr("inspectorAttributesSubmenu.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorAttributesSubmenu.accesskey"),
	      submenu: this._getAttributesSubmenu(isEditableElement),
	    }));

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    // Set the pseudo classes
	    for (let name of ["hover", "active", "focus"]) {
	      let menuitem = new MenuItem({
	        id: "node-menu-pseudo-" + name,
	        label: name,
	        type: "checkbox",
	        click: this.togglePseudoClass.bind(this, ":" + name),
	      });

	      if (isSelectionElement) {
	        let checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
	        menuitem.checked = checked;
	      } else {
	        menuitem.disabled = true;
	      }

	      menu.append(menuitem);
	    }

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    let copySubmenu = new Menu();
	    copySubmenu.append(new MenuItem({
	      id: "node-menu-copyinner",
	      label: INSPECTOR_L10N.getStr("inspectorCopyInnerHTML.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorCopyInnerHTML.accesskey"),
	      disabled: !isSelectionElement,
	      click: () => this.copyInnerHTML(),
	    }));
	    copySubmenu.append(new MenuItem({
	      id: "node-menu-copyouter",
	      label: INSPECTOR_L10N.getStr("inspectorCopyOuterHTML.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorCopyOuterHTML.accesskey"),
	      disabled: !isSelectionElement,
	      click: () => this.copyOuterHTML(),
	    }));
	    copySubmenu.append(new MenuItem({
	      id: "node-menu-copyuniqueselector",
	      label: INSPECTOR_L10N.getStr("inspectorCopyCSSSelector.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorCopyCSSSelector.accesskey"),
	      disabled: !isSelectionElement,
	      hidden: !this.canGetUniqueSelector,
	      click: () => this.copyUniqueSelector(),
	    }));
	    copySubmenu.append(new MenuItem({
	      id: "node-menu-copyimagedatauri",
	      label: INSPECTOR_L10N.getStr("inspectorImageDataUri.label"),
	      disabled: !isSelectionElement || !markupContainer ||
	                !markupContainer.isPreviewable(),
	      click: () => this.copyImageDataUri(),
	    }));

	    menu.append(new MenuItem({
	      label: INSPECTOR_L10N.getStr("inspectorCopyHTMLSubmenu.label"),
	      submenu: copySubmenu,
	    }));

	    menu.append(new MenuItem({
	      label: INSPECTOR_L10N.getStr("inspectorPasteHTMLSubmenu.label"),
	      submenu: this._getPasteSubmenu(isEditableElement),
	    }));

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    let isNodeWithChildren = this.selection.isNode() &&
	                             markupContainer.hasChildren;
	    menu.append(new MenuItem({
	      id: "node-menu-expand",
	      label: INSPECTOR_L10N.getStr("inspectorExpandNode.label"),
	      disabled: !isNodeWithChildren,
	      click: () => this.expandNode(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-collapse",
	      label: INSPECTOR_L10N.getStr("inspectorCollapseNode.label"),
	      disabled: !isNodeWithChildren || !markupContainer.expanded,
	      click: () => this.collapseNode(),
	    }));

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    menu.append(new MenuItem({
	      id: "node-menu-scrollnodeintoview",
	      label: INSPECTOR_L10N.getStr("inspectorScrollNodeIntoView.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorScrollNodeIntoView.accesskey"),
	      hidden: !this._supportsScrollIntoView,
	      disabled: !isSelectionElement,
	      click: () => this.scrollNodeIntoView(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-screenshotnode",
	      label: INSPECTOR_L10N.getStr("inspectorScreenshotNode.label"),
	      disabled: !isScreenshotable,
	      click: () => this.screenshotNode(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-useinconsole",
	      label: INSPECTOR_L10N.getStr("inspectorUseInConsole.label"),
	      click: () => this.useInConsole(),
	    }));
	    menu.append(new MenuItem({
	      id: "node-menu-showdomproperties",
	      label: INSPECTOR_L10N.getStr("inspectorShowDOMProperties.label"),
	      click: () => this.showDOMProperties(),
	    }));

	    let nodeLinkMenuItems = this._getNodeLinkMenuItems();
	    if (nodeLinkMenuItems.filter(item => item.visible).length > 0) {
	      menu.append(new MenuItem({
	        id: "node-menu-link-separator",
	        type: "separator",
	      }));
	    }

	    for (let menuitem of nodeLinkMenuItems) {
	      menu.append(menuitem);
	    }

	    menu.popup(screenX, screenY, this._toolbox);
	    return menu;
	  },

	  _getPasteSubmenu: function (isEditableElement) {
	    let isPasteable = isEditableElement && this._getClipboardContentForPaste();
	    let disableAdjacentPaste = !isPasteable ||
	          !this.canPasteInnerOrAdjacentHTML || this.selection.isRoot() ||
	          this.selection.isBodyNode() || this.selection.isHeadNode();
	    let disableFirstLastPaste = !isPasteable ||
	          !this.canPasteInnerOrAdjacentHTML || (this.selection.isHTMLNode() &&
	          this.selection.isRoot());

	    let pasteSubmenu = new Menu();
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pasteinnerhtml",
	      label: INSPECTOR_L10N.getStr("inspectorPasteInnerHTML.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorPasteInnerHTML.accesskey"),
	      disabled: !isPasteable || !this.canPasteInnerOrAdjacentHTML,
	      click: () => this.pasteInnerHTML(),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pasteouterhtml",
	      label: INSPECTOR_L10N.getStr("inspectorPasteOuterHTML.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorPasteOuterHTML.accesskey"),
	      disabled: !isPasteable || !this.isOuterHTMLEditable,
	      click: () => this.pasteOuterHTML(),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pastebefore",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLPasteBefore.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorHTMLPasteBefore.accesskey"),
	      disabled: disableAdjacentPaste,
	      click: () => this.pasteAdjacentHTML("beforeBegin"),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pasteafter",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLPasteAfter.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorHTMLPasteAfter.accesskey"),
	      disabled: disableAdjacentPaste,
	      click: () => this.pasteAdjacentHTML("afterEnd"),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pastefirstchild",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLPasteFirstChild.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorHTMLPasteFirstChild.accesskey"),
	      disabled: disableFirstLastPaste,
	      click: () => this.pasteAdjacentHTML("afterBegin"),
	    }));
	    pasteSubmenu.append(new MenuItem({
	      id: "node-menu-pastelastchild",
	      label: INSPECTOR_L10N.getStr("inspectorHTMLPasteLastChild.label"),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorHTMLPasteLastChild.accesskey"),
	      disabled: disableFirstLastPaste,
	      click: () => this.pasteAdjacentHTML("beforeEnd"),
	    }));

	    return pasteSubmenu;
	  },

	  _getAttributesSubmenu: function (isEditableElement) {
	    let attributesSubmenu = new Menu();
	    let nodeInfo = this.nodeMenuTriggerInfo;
	    let isAttributeClicked = isEditableElement && nodeInfo &&
	                              nodeInfo.type === "attribute";

	    attributesSubmenu.append(new MenuItem({
	      id: "node-menu-add-attribute",
	      label: INSPECTOR_L10N.getStr("inspectorAddAttribute.label"),
	      accesskey: INSPECTOR_L10N.getStr("inspectorAddAttribute.accesskey"),
	      disabled: !isEditableElement,
	      click: () => this.onAddAttribute(),
	    }));
	    attributesSubmenu.append(new MenuItem({
	      id: "node-menu-edit-attribute",
	      label: INSPECTOR_L10N.getFormatStr("inspectorEditAttribute.label",
	                                        isAttributeClicked ? `"${nodeInfo.name}"` : ""),
	      accesskey: INSPECTOR_L10N.getStr("inspectorEditAttribute.accesskey"),
	      disabled: !isAttributeClicked,
	      click: () => this.onEditAttribute(),
	    }));

	    attributesSubmenu.append(new MenuItem({
	      id: "node-menu-remove-attribute",
	      label: INSPECTOR_L10N.getFormatStr("inspectorRemoveAttribute.label",
	                                        isAttributeClicked ? `"${nodeInfo.name}"` : ""),
	      accesskey:
	        INSPECTOR_L10N.getStr("inspectorRemoveAttribute.accesskey"),
	      disabled: !isAttributeClicked,
	      click: () => this.onRemoveAttribute(),
	    }));

	    return attributesSubmenu;
	  },

	  /**
	   * Link menu items can be shown or hidden depending on the context and
	   * selected node, and their labels can vary.
	   *
	   * @return {Array} list of visible menu items related to links.
	   */
	  _getNodeLinkMenuItems: function () {
	    let linkFollow = new MenuItem({
	      id: "node-menu-link-follow",
	      visible: false,
	      click: () => this.onFollowLink(),
	    });
	    let linkCopy = new MenuItem({
	      id: "node-menu-link-copy",
	      visible: false,
	      click: () => this.onCopyLink(),
	    });

	    // Get information about the right-clicked node.
	    let popupNode = this.contextMenuTarget;
	    if (!popupNode || !popupNode.classList.contains("link")) {
	      return [linkFollow, linkCopy];
	    }

	    let type = popupNode.dataset.type;
	    if (this._supportsResolveRelativeURL &&
	        (type === "uri" || type === "cssresource" || type === "jsresource")) {
	      // Links can't be opened in new tabs in the browser toolbox.
	      if (type === "uri" && !this.target.chrome) {
	        linkFollow.visible = true;
	        linkFollow.label = INSPECTOR_L10N.getStr(
	          "inspector.menu.openUrlInNewTab.label");
	      } else if (type === "cssresource") {
	        linkFollow.visible = true;
	        linkFollow.label = TOOLBOX_L10N.getStr(
	          "toolbox.viewCssSourceInStyleEditor.label");
	      } else if (type === "jsresource") {
	        linkFollow.visible = true;
	        linkFollow.label = TOOLBOX_L10N.getStr(
	          "toolbox.viewJsSourceInDebugger.label");
	      }

	      linkCopy.visible = true;
	      linkCopy.label = INSPECTOR_L10N.getStr(
	        "inspector.menu.copyUrlToClipboard.label");
	    } else if (type === "idref") {
	      linkFollow.visible = true;
	      linkFollow.label = INSPECTOR_L10N.getFormatStr(
	        "inspector.menu.selectElement.label", popupNode.dataset.link);
	    }

	    return [linkFollow, linkCopy];
	  },

	  _initMarkup: function () {
	    let doc = this.panelDoc;

	    this._markupBox = doc.getElementById("markup-box");

	    // create tool iframe
	    this._markupFrame = doc.createElement("iframe");
	    this._markupFrame.setAttribute("flex", "1");
	    this._markupFrame.setAttribute("tooltip", "aHTMLTooltip");
	    this._markupFrame.addEventListener("contextmenu", this._onContextMenu, true);

	    // This is needed to enable tooltips inside the iframe document.
	    this._markupFrame.addEventListener("load", this._onMarkupFrameLoad, true);

	    this._markupBox.setAttribute("collapsed", true);
	    this._markupBox.appendChild(this._markupFrame);
	    this._markupFrame.setAttribute("src", "chrome://devtools/content/inspector/markup/markup.xhtml");
	    this._markupFrame.setAttribute("aria-label",
	      INSPECTOR_L10N.getStr("inspector.panelLabel.markupView"));
	  },

	  _onMarkupFrameLoad: function () {
	    this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);

	    this._markupFrame.contentWindow.focus();

	    this._markupBox.removeAttribute("collapsed");

	    this.markup = new MarkupView(this, this._markupFrame, this._toolbox.win);

	    this.emit("markuploaded");
	  },

	  _destroyMarkup: function () {
	    let destroyPromise;

	    if (this._markupFrame) {
	      this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);
	      this._markupFrame.removeEventListener("contextmenu", this._onContextMenu, true);
	    }

	    if (this.markup) {
	      destroyPromise = this.markup.destroy();
	      this.markup = null;
	    } else {
	      destroyPromise = promise.resolve();
	    }

	    if (this._markupFrame) {
	      this._markupFrame.parentNode.removeChild(this._markupFrame);
	      this._markupFrame = null;
	    }

	    this._markupBox = null;

	    return destroyPromise;
	  },

	  /**
	   * When the pane toggle button is clicked or pressed, toggle the pane, change the button
	   * state and tooltip.
	   */
	  onPaneToggleButtonClicked: function (e) {
	    let sidePaneContainer = this.panelDoc.querySelector("#inspector-sidebar-container");
	    let isVisible = !this._sidebarToggle.state.collapsed;

	    // Make sure the sidebar has width and height attributes before collapsing
	    // because ViewHelpers needs it.
	    if (isVisible) {
	      let rect = sidePaneContainer.getBoundingClientRect();
	      if (!sidePaneContainer.hasAttribute("width")) {
	        sidePaneContainer.setAttribute("width", rect.width);
	      }
	      // always refresh the height attribute before collapsing, it could have
	      // been modified by resizing the container.
	      sidePaneContainer.setAttribute("height", rect.height);
	    }

	    let onAnimationDone = () => {
	      if (isVisible) {
	        this._sidebarToggle.setState({collapsed: true});
	      } else {
	        this._sidebarToggle.setState({collapsed: false});
	      }
	    };

	    ViewHelpers.togglePane({
	      visible: !isVisible,
	      animated: true,
	      delayed: true,
	      callback: onAnimationDone
	    }, sidePaneContainer);
	  },

	  onEyeDropperButtonClicked: function () {
	    this.eyeDropperButton.hasAttribute("checked")
	      ? this.hideEyeDropper()
	      : this.showEyeDropper();
	  },

	  startEyeDropperListeners: function () {
	    this.inspector.once("color-pick-canceled", this.onEyeDropperDone);
	    this.inspector.once("color-picked", this.onEyeDropperDone);
	    this.walker.once("new-root", this.onEyeDropperDone);
	  },

	  stopEyeDropperListeners: function () {
	    this.inspector.off("color-pick-canceled", this.onEyeDropperDone);
	    this.inspector.off("color-picked", this.onEyeDropperDone);
	    this.walker.off("new-root", this.onEyeDropperDone);
	  },

	  onEyeDropperDone: function () {
	    this.eyeDropperButton.removeAttribute("checked");
	    this.stopEyeDropperListeners();
	  },

	  /**
	   * Show the eyedropper on the page.
	   * @return {Promise} resolves when the eyedropper is visible.
	   */
	  showEyeDropper: function () {
	    // The eyedropper button doesn't exist, most probably because the actor doesn't
	    // support the pickColorFromPage, or because the page isn't HTML.
	    if (!this.eyeDropperButton) {
	      return null;
	    }

	    this.telemetry.toolOpened("toolbareyedropper");
	    this.eyeDropperButton.setAttribute("checked", "true");
	    this.startEyeDropperListeners();
	    return this.inspector.pickColorFromPage(this.toolbox, {copyOnSelect: true})
	                         .catch(e => console.error(e));
	  },

	  /**
	   * Hide the eyedropper.
	   * @return {Promise} resolves when the eyedropper is hidden.
	   */
	  hideEyeDropper: function () {
	    // The eyedropper button doesn't exist, most probably because the actor doesn't
	    // support the pickColorFromPage, or because the page isn't HTML.
	    if (!this.eyeDropperButton) {
	      return null;
	    }

	    this.eyeDropperButton.removeAttribute("checked");
	    this.stopEyeDropperListeners();
	    return this.inspector.cancelPickColorFromPage()
	                         .catch(e => console.error(e));
	  },

	  /**
	   * Create a new node as the last child of the current selection, expand the
	   * parent and select the new node.
	   */
	  addNode: Task.async(function* () {
	    if (!this.canAddHTMLChild()) {
	      return;
	    }

	    let html = "<div></div>";

	    // Insert the html and expect a childList markup mutation.
	    let onMutations = this.once("markupmutation");
	    let {nodes} = yield this.walker.insertAdjacentHTML(this.selection.nodeFront,
	                                                       "beforeEnd", html);
	    yield onMutations;

	    // Select the new node (this will auto-expand its parent).
	    this.selection.setNodeFront(nodes[0], "node-inserted");
	  }),

	  /**
	   * Toggle a pseudo class.
	   */
	  togglePseudoClass: function (pseudo) {
	    if (this.selection.isElementNode()) {
	      let node = this.selection.nodeFront;
	      if (node.hasPseudoClassLock(pseudo)) {
	        return this.walker.removePseudoClassLock(node, pseudo, {parents: true});
	      }

	      let hierarchical = pseudo == ":hover" || pseudo == ":active";
	      return this.walker.addPseudoClassLock(node, pseudo, {parents: hierarchical});
	    }
	    return promise.resolve();
	  },

	  /**
	   * Show DOM properties
	   */
	  showDOMProperties: function () {
	    this._toolbox.openSplitConsole().then(() => {
	      let panel = this._toolbox.getPanel("webconsole");
	      let jsterm = panel.hud.jsterm;

	      jsterm.execute("inspect($0)");
	      jsterm.focus();
	    });
	  },

	  /**
	   * Use in Console.
	   *
	   * Takes the currently selected node in the inspector and assigns it to a
	   * temp variable on the content window.  Also opens the split console and
	   * autofills it with the temp variable.
	   */
	  useInConsole: function () {
	    this._toolbox.openSplitConsole().then(() => {
	      let panel = this._toolbox.getPanel("webconsole");
	      let jsterm = panel.hud.jsterm;

	      let evalString = `{ let i = 0;
	        while (window.hasOwnProperty("temp" + i) && i < 1000) {
	          i++;
	        }
	        window["temp" + i] = $0;
	        "temp" + i;
	      }`;

	      let options = {
	        selectedNodeActor: this.selection.nodeFront.actorID,
	      };
	      jsterm.requestEvaluation(evalString, options).then((res) => {
	        jsterm.setInputValue(res.result);
	        this.emit("console-var-ready");
	      });
	    });
	  },

	  /**
	   * Clear any pseudo-class locks applied to the current hierarchy.
	   */
	  clearPseudoClasses: function () {
	    if (!this.walker) {
	      return promise.resolve();
	    }
	    return this.walker.clearPseudoClassLocks().catch(this._handleRejectionIfNotDestroyed);
	  },

	  /**
	   * Edit the outerHTML of the selected Node.
	   */
	  editHTML: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }
	    if (this.markup) {
	      this.markup.beginEditingOuterHTML(this.selection.nodeFront);
	    }
	  },

	  /**
	   * Paste the contents of the clipboard into the selected Node's outer HTML.
	   */
	  pasteOuterHTML: function () {
	    let content = this._getClipboardContentForPaste();
	    if (!content) {
	      return promise.reject("No clipboard content for paste");
	    }

	    let node = this.selection.nodeFront;
	    return this.markup.getNodeOuterHTML(node).then(oldContent => {
	      this.markup.updateNodeOuterHTML(node, content, oldContent);
	    });
	  },

	  /**
	   * Paste the contents of the clipboard into the selected Node's inner HTML.
	   */
	  pasteInnerHTML: function () {
	    let content = this._getClipboardContentForPaste();
	    if (!content) {
	      return promise.reject("No clipboard content for paste");
	    }

	    let node = this.selection.nodeFront;
	    return this.markup.getNodeInnerHTML(node).then(oldContent => {
	      this.markup.updateNodeInnerHTML(node, content, oldContent);
	    });
	  },

	  /**
	   * Paste the contents of the clipboard as adjacent HTML to the selected Node.
	   * @param position
	   *        The position as specified for Element.insertAdjacentHTML
	   *        (i.e. "beforeBegin", "afterBegin", "beforeEnd", "afterEnd").
	   */
	  pasteAdjacentHTML: function (position) {
	    let content = this._getClipboardContentForPaste();
	    if (!content) {
	      return promise.reject("No clipboard content for paste");
	    }

	    let node = this.selection.nodeFront;
	    return this.markup.insertAdjacentHTMLToNode(node, position, content);
	  },

	  /**
	   * Copy the innerHTML of the selected Node to the clipboard.
	   */
	  copyInnerHTML: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }
	    this._copyLongString(this.walker.innerHTML(this.selection.nodeFront));
	  },

	  /**
	   * Copy the outerHTML of the selected Node to the clipboard.
	   */
	  copyOuterHTML: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }
	    let node = this.selection.nodeFront;

	    switch (node.nodeType) {
	      case nodeConstants.ELEMENT_NODE :
	        this._copyLongString(this.walker.outerHTML(node));
	        break;
	      case nodeConstants.COMMENT_NODE :
	        this._getLongString(node.getNodeValue()).then(comment => {
	          clipboardHelper.copyString("<!--" + comment + "-->");
	        });
	        break;
	      case nodeConstants.DOCUMENT_TYPE_NODE :
	        clipboardHelper.copyString(node.doctypeString);
	        break;
	    }
	  },

	  /**
	   * Copy the data-uri for the currently selected image in the clipboard.
	   */
	  copyImageDataUri: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    if (container && container.isPreviewable()) {
	      container.copyImageDataUri();
	    }
	  },

	  /**
	   * Copy the content of a longString (via a promise resolving a
	   * LongStringActor) to the clipboard
	   * @param  {Promise} longStringActorPromise
	   *         promise expected to resolve a LongStringActor instance
	   * @return {Promise} promise resolving (with no argument) when the
	   *         string is sent to the clipboard
	   */
	  _copyLongString: function (longStringActorPromise) {
	    return this._getLongString(longStringActorPromise).then(string => {
	      clipboardHelper.copyString(string);
	    }).catch(e => console.error(e));
	  },

	  /**
	   * Retrieve the content of a longString (via a promise resolving a LongStringActor)
	   * @param  {Promise} longStringActorPromise
	   *         promise expected to resolve a LongStringActor instance
	   * @return {Promise} promise resolving with the retrieved string as argument
	   */
	  _getLongString: function (longStringActorPromise) {
	    return longStringActorPromise.then(longStringActor => {
	      return longStringActor.string().then(string => {
	        longStringActor.release().catch(e => console.error(e));
	        return string;
	      });
	    }).catch(e => console.error(e));
	  },

	  /**
	   * Copy a unique selector of the selected Node to the clipboard.
	   */
	  copyUniqueSelector: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }

	    this.selection.nodeFront.getUniqueSelector().then((selector) => {
	      clipboardHelper.copyString(selector);
	    }).then(null, console.error);
	  },

	  /**
	   * Initiate gcli screenshot command on selected node
	   */
	  screenshotNode: function () {
	    CommandUtils.createRequisition(this._target, {
	      environment: CommandUtils.createEnvironment(this, "_target")
	    }).then(requisition => {
	      // Bug 1180314 -  CssSelector might contain white space so need to make sure it is
	      // passed to screenshot as a single parameter.  More work *might* be needed if
	      // CssSelector could contain escaped single- or double-quotes, backslashes, etc.
	      requisition.updateExec("screenshot --selector '" + this.selectionCssSelector + "'");
	    });
	  },

	  /**
	   * Scroll the node into view.
	   */
	  scrollNodeIntoView: function () {
	    if (!this.selection.isNode()) {
	      return;
	    }

	    this.selection.nodeFront.scrollIntoView();
	  },

	  /**
	   * Duplicate the selected node
	   */
	  duplicateNode: function () {
	    let selection = this.selection;
	    if (!selection.isElementNode() ||
	        selection.isRoot() ||
	        selection.isAnonymousNode() ||
	        selection.isPseudoElementNode()) {
	      return;
	    }
	    this.walker.duplicateNode(selection.nodeFront).catch(e => console.error(e));
	  },

	  /**
	   * Delete the selected node.
	   */
	  deleteNode: function () {
	    if (!this.selection.isNode() ||
	         this.selection.isRoot()) {
	      return;
	    }

	    // If the markup panel is active, use the markup panel to delete
	    // the node, making this an undoable action.
	    if (this.markup) {
	      this.markup.deleteNode(this.selection.nodeFront);
	    } else {
	      // remove the node from content
	      this.walker.removeNode(this.selection.nodeFront);
	    }
	  },

	  /**
	   * Add attribute to node.
	   * Used for node context menu and shouldn't be called directly.
	   */
	  onAddAttribute: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    container.addAttribute();
	  },

	  /**
	   * Edit attribute for node.
	   * Used for node context menu and shouldn't be called directly.
	   */
	  onEditAttribute: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    container.editAttribute(this.nodeMenuTriggerInfo.name);
	  },

	  /**
	   * Remove attribute from node.
	   * Used for node context menu and shouldn't be called directly.
	   */
	  onRemoveAttribute: function () {
	    let container = this.markup.getContainer(this.selection.nodeFront);
	    container.removeAttribute(this.nodeMenuTriggerInfo.name);
	  },

	  expandNode: function () {
	    this.markup.expandAll(this.selection.nodeFront);
	  },

	  collapseNode: function () {
	    this.markup.collapseNode(this.selection.nodeFront);
	  },

	  /**
	   * This method is here for the benefit of the node-menu-link-follow menu item
	   * in the inspector contextual-menu.
	   */
	  onFollowLink: function () {
	    let type = this.contextMenuTarget.dataset.type;
	    let link = this.contextMenuTarget.dataset.link;

	    this.followAttributeLink(type, link);
	  },

	  /**
	   * Given a type and link found in a node's attribute in the markup-view,
	   * attempt to follow that link (which may result in opening a new tab, the
	   * style editor or debugger).
	   */
	  followAttributeLink: function (type, link) {
	    if (!type || !link) {
	      return;
	    }

	    if (type === "uri" || type === "cssresource" || type === "jsresource") {
	      // Open link in a new tab.
	      // When the inspector menu was setup on click (see _getNodeLinkMenuItems), we
	      // already checked that resolveRelativeURL existed.
	      this.inspector.resolveRelativeURL(
	        link, this.selection.nodeFront).then(url => {
	          if (type === "uri") {
	            let browserWin = this.target.tab.ownerDocument.defaultView;
	            browserWin.openUILinkIn(url, "tab");
	          } else if (type === "cssresource") {
	            return this.toolbox.viewSourceInStyleEditor(url);
	          } else if (type === "jsresource") {
	            return this.toolbox.viewSourceInDebugger(url);
	          }
	          return null;
	        }).catch(e => console.error(e));
	    } else if (type == "idref") {
	      // Select the node in the same document.
	      this.walker.document(this.selection.nodeFront).then(doc => {
	        return this.walker.querySelector(doc, "#" + CSS.escape(link)).then(node => {
	          if (!node) {
	            this.emit("idref-attribute-link-failed");
	            return;
	          }
	          this.selection.setNodeFront(node);
	        });
	      }).catch(e => console.error(e));
	    }
	  },

	  /**
	   * This method is here for the benefit of the node-menu-link-copy menu item
	   * in the inspector contextual-menu.
	   */
	  onCopyLink: function () {
	    let link = this.contextMenuTarget.dataset.link;

	    this.copyAttributeLink(link);
	  },

	  /**
	   * This method is here for the benefit of copying links.
	   */
	  copyAttributeLink: function (link) {
	    // When the inspector menu was setup on click (see _getNodeLinkMenuItems), we
	    // already checked that resolveRelativeURL existed.
	    this.inspector.resolveRelativeURL(link, this.selection.nodeFront).then(url => {
	      clipboardHelper.copyString(url);
	    }, console.error);
	  }
	};


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* globals localStorage, window, document, NodeFilter */

	// Some constants from nsIPrefBranch.idl.
	const PREF_INVALID = 0;
	const PREF_STRING = 32;
	const PREF_INT = 64;
	const PREF_BOOL = 128;
	const NS_PREFBRANCH_PREFCHANGE_TOPIC_ID = "nsPref:changed";

	// We prefix all our local storage items with this.
	const PREFIX = "Services.prefs:";

	/**
	 * Create a new preference branch.  This object conforms largely to
	 * nsIPrefBranch and nsIPrefService, though it only implements the
	 * subset needed by devtools.  A preference branch can hold child
	 * preferences while also holding a preference value itself.
	 *
	 * @param {PrefBranch} parent the parent branch, or null for the root
	 *        branch.
	 * @param {String} name the base name of this branch
	 * @param {String} fullName the fully-qualified name of this branch
	 */
	function PrefBranch(parent, name, fullName) {
	  this._parent = parent;
	  this._name = name;
	  this._fullName = fullName;
	  this._observers = {};
	  this._children = {};

	  // Properties used when this branch has a value as well.
	  this._defaultValue = null;
	  this._hasUserValue = false;
	  this._userValue = null;
	  this._type = PREF_INVALID;
	}

	PrefBranch.prototype = {
	  PREF_INVALID: PREF_INVALID,
	  PREF_STRING: PREF_STRING,
	  PREF_INT: PREF_INT,
	  PREF_BOOL: PREF_BOOL,

	  /** @see nsIPrefBranch.root.  */
	  get root() {
	    return this._fullName;
	  },

	  /** @see nsIPrefBranch.getPrefType.  */
	  getPrefType: function (prefName) {
	    return this._findPref(prefName)._type;
	  },

	  /** @see nsIPrefBranch.getBoolPref.  */
	  getBoolPref: function (prefName) {
	    let thePref = this._findPref(prefName);
	    if (thePref._type !== PREF_BOOL) {
	      throw new Error(`${prefName} does not have bool type`);
	    }
	    return thePref._get();
	  },

	  /** @see nsIPrefBranch.setBoolPref.  */
	  setBoolPref: function (prefName, value) {
	    if (typeof value !== "boolean") {
	      throw new Error("non-bool passed to setBoolPref");
	    }
	    let thePref = this._findOrCreatePref(prefName, value, true, value);
	    if (thePref._type !== PREF_BOOL) {
	      throw new Error(`${prefName} does not have bool type`);
	    }
	    thePref._set(value);
	  },

	  /** @see nsIPrefBranch.getCharPref.  */
	  getCharPref: function (prefName) {
	    let thePref = this._findPref(prefName);
	    if (thePref._type !== PREF_STRING) {
	      throw new Error(`${prefName} does not have string type`);
	    }
	    return thePref._get();
	  },

	  /** @see nsIPrefBranch.setCharPref.  */
	  setCharPref: function (prefName, value) {
	    if (typeof value !== "string") {
	      throw new Error("non-string passed to setCharPref");
	    }
	    let thePref = this._findOrCreatePref(prefName, value, true, value);
	    if (thePref._type !== PREF_STRING) {
	      throw new Error(`${prefName} does not have string type`);
	    }
	    thePref._set(value);
	  },

	  /** @see nsIPrefBranch.getIntPref.  */
	  getIntPref: function (prefName) {
	    let thePref = this._findPref(prefName);
	    if (thePref._type !== PREF_INT) {
	      throw new Error(`${prefName} does not have int type`);
	    }
	    return thePref._get();
	  },

	  /** @see nsIPrefBranch.setIntPref.  */
	  setIntPref: function (prefName, value) {
	    if (typeof value !== "number") {
	      throw new Error("non-number passed to setIntPref");
	    }
	    let thePref = this._findOrCreatePref(prefName, value, true, value);
	    if (thePref._type !== PREF_INT) {
	      throw new Error(`${prefName} does not have int type`);
	    }
	    thePref._set(value);
	  },

	  /** @see nsIPrefBranch.clearUserPref */
	  clearUserPref: function (prefName) {
	    let thePref = this._findPref(prefName);
	    thePref._clearUserValue();
	  },

	  /** @see nsIPrefBranch.prefHasUserValue */
	  prefHasUserValue: function (prefName) {
	    let thePref = this._findPref(prefName);
	    return thePref._hasUserValue;
	  },

	  /** @see nsIPrefBranch.addObserver */
	  addObserver: function (domain, observer, holdWeak) {
	    if (holdWeak) {
	      throw new Error("shim prefs only supports strong observers");
	    }

	    if (!(domain in this._observers)) {
	      this._observers[domain] = [];
	    }
	    this._observers[domain].push(observer);
	  },

	  /** @see nsIPrefBranch.removeObserver */
	  removeObserver: function (domain, observer) {
	    if (!(domain in this._observers)) {
	      return;
	    }
	    let index = this._observers[domain].indexOf(observer);
	    if (index >= 0) {
	      this._observers[domain].splice(index, 1);
	    }
	  },

	  /** @see nsIPrefService.savePrefFile */
	  savePrefFile: function (file) {
	    if (file) {
	      throw new Error("shim prefs only supports null file in savePrefFile");
	    }
	    // Nothing to do - this implementation always writes back.
	  },

	  /** @see nsIPrefService.getBranch */
	  getBranch: function (prefRoot) {
	    if (!prefRoot) {
	      return this;
	    }
	    if (prefRoot.endsWith(".")) {
	      prefRoot = prefRoot.slice(0, -1);
	    }
	    // This is a bit weird since it could erroneously return a pref,
	    // not a pref branch.
	    return this._findPref(prefRoot);
	  },

	  /**
	   * Return this preference's current value.
	   *
	   * @return {Any} The current value of this preference.  This may
	   *         return a string, a number, or a boolean depending on the
	   *         preference's type.
	   */
	  _get: function () {
	    if (this._hasUserValue) {
	      return this._userValue;
	    }
	    return this._defaultValue;
	  },

	  /**
	   * Set the preference's value.  The new value is assumed to be a
	   * user value.  After setting the value, this function emits a
	   * change notification.
	   *
	   * @param {Any} value the new value
	   */
	  _set: function (value) {
	    if (!this._hasUserValue || value !== this._userValue) {
	      this._userValue = value;
	      this._hasUserValue = true;
	      this._saveAndNotify();
	    }
	  },

	  /**
	   * Set the default value for this preference, and emit a
	   * notification if this results in a visible change.
	   *
	   * @param {Any} value the new default value
	   */
	  _setDefault: function (value) {
	    if (this._defaultValue !== value) {
	      this._defaultValue = value;
	      if (!this._hasUserValue) {
	        this._saveAndNotify();
	      }
	    }
	  },

	  /**
	   * If this preference has a user value, clear it.  If a change was
	   * made, emit a change notification.
	   */
	  _clearUserValue: function () {
	    if (this._hasUserValue) {
	      this._userValue = null;
	      this._hasUserValue = false;
	      this._saveAndNotify();
	    }
	  },

	  /**
	   * Helper function to write the preference's value to local storage
	   * and then emit a change notification.
	   */
	  _saveAndNotify: function () {
	    let store = {
	      type: this._type,
	      defaultValue: this._defaultValue,
	      hasUserValue: this._hasUserValue,
	      userValue: this._userValue,
	    };

	    localStorage.setItem(PREFIX + this.fullName, JSON.stringify(store));
	    this._parent._notify(this._name);
	  },

	  /**
	   * Change this preference's value without writing it back to local
	   * storage.  This is used to handle changes to local storage that
	   * were made externally.
	   *
	   * @param {Number} type one of the PREF_* values
	   * @param {Any} userValue the user value to use if the pref does not exist
	   * @param {Any} defaultValue the default value to use if the pref
	   *        does not exist
	   * @param {Boolean} hasUserValue if a new pref is created, whether
	   *        the default value is also a user value
	   * @param {Object} store the new value of the preference.  It should
	   *        be of the form {type, defaultValue, hasUserValue, userValue};
	   *        where |type| is one of the PREF_* type constants; |defaultValue|
	   *        and |userValue| are the default and user values, respectively;
	   *        and |hasUserValue| is a boolean indicating whether the user value
	   *        is valid
	   */
	  _storageUpdated: function (type, userValue, hasUserValue, defaultValue) {
	    this._type = type;
	    this._defaultValue = defaultValue;
	    this._hasUserValue = hasUserValue;
	    this._userValue = userValue;
	    // There's no need to write this back to local storage, since it
	    // came from there; and this avoids infinite event loops.
	    this._parent._notify(this._name);
	  },

	  /**
	   * Helper function to find either a Preference or PrefBranch object
	   * given its name.  If the name is not found, throws an exception.
	   *
	   * @param {String} prefName the fully-qualified preference name
	   * @return {Object} Either a Preference or PrefBranch object
	   */
	  _findPref: function (prefName) {
	    let branchNames = prefName.split(".");
	    let branch = this;

	    for (let branchName of branchNames) {
	      branch = branch._children[branchName];
	      if (!branch) {
	        throw new Error("could not find pref branch " + prefName);
	      }
	    }

	    return branch;
	  },

	  /**
	   * Helper function to notify any observers when a preference has
	   * changed.  This will also notify the parent branch for further
	   * reporting.
	   *
	   * @param {String} relativeName the name of the updated pref,
	   *        relative to this branch
	   */
	  _notify: function (relativeName) {
	    for (let domain in this._observers) {
	      if (relativeName === domain || domain === "" ||
	          (domain.endsWith(".") && relativeName.startsWith(domain))) {
	        // Allow mutation while walking.
	        let localList = this._observers[domain].slice();
	        for (let observer of localList) {
	          try {
	            observer.observe(this, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID,
	                             relativeName);
	          } catch (e) {
	            console.error(e);
	          }
	        }
	      }
	    }

	    if (this._parent) {
	      this._parent._notify(this._name + "." + relativeName);
	    }
	  },

	  /**
	   * Helper function to create a branch given an array of branch names
	   * representing the path of the new branch.
	   *
	   * @param {Array} branchList an array of strings, one per component
	   *        of the branch to be created
	   * @return {PrefBranch} the new branch
	   */
	  _createBranch: function (branchList) {
	    let parent = this;
	    for (let branch of branchList) {
	      if (!parent._children[branch]) {
	        parent._children[branch] = new PrefBranch(parent, branch,
	                                                  parent.root + "." + branch);
	      }
	      parent = parent._children[branch];
	    }
	    return parent;
	  },

	  /**
	   * Create a new preference.  The new preference is assumed to be in
	   * local storage already, and the new value is taken from there.
	   *
	   * @param {String} keyName the full-qualified name of the preference.
	   *        This is also the name of the key in local storage.
	   * @param {Any} userValue the user value to use if the pref does not exist
	   * @param {Any} defaultValue the default value to use if the pref
	   *        does not exist
	   * @param {Boolean} hasUserValue if a new pref is created, whether
	   *        the default value is also a user value
	   */
	  _findOrCreatePref: function (keyName, userValue, hasUserValue, defaultValue) {
	    let branch = this._createBranch(keyName.split("."));

	    if (hasUserValue && typeof (userValue) !== typeof (defaultValue)) {
	      throw new Error("inconsistent values when creating " + keyName);
	    }

	    let type;
	    switch (typeof (defaultValue)) {
	      case "boolean":
	        type = PREF_BOOL;
	        break;
	      case "number":
	        type = PREF_INT;
	        break;
	      case "string":
	        type = PREF_STRING;
	        break;
	      default:
	        throw new Error("unhandled argument type: " + typeof (defaultValue));
	    }

	    if (branch._type === PREF_INVALID) {
	      branch._storageUpdated(type, userValue, hasUserValue, defaultValue);
	    } else if (branch._type !== type) {
	      throw new Error("attempt to change type of pref " + keyName);
	    }

	    return branch;
	  },

	  /**
	   * Helper function that is called when local storage changes.  This
	   * updates the preferences and notifies pref observers as needed.
	   *
	   * @param {StorageEvent} event the event representing the local
	   *        storage change
	   */
	  _onStorageChange: function (event) {
	    if (event.storageArea !== localStorage) {
	      return;
	    }
	    // Ignore delete events.  Not clear what's correct.
	    if (event.key === null || event.newValue === null) {
	      return;
	    }

	    let {type, userValue, hasUserValue, defaultValue} =
	        JSON.parse(event.newValue);
	    if (event.oldValue === null) {
	      this._findOrCreatePref(event.key, userValue, hasUserValue, defaultValue);
	    } else {
	      let thePref = this._findPref(event.key);
	      thePref._storageUpdated(type, userValue, hasUserValue, defaultValue);
	    }
	  },

	  /**
	   * Helper function to initialize the root PrefBranch.
	   */
	  _initializeRoot: function () {
	    if (localStorage.length === 0 && Services._defaultPrefsEnabled) {
	      /* eslint-disable no-eval */
	      let devtools = __webpack_require__(2);
	      eval(devtools);
	      let all = __webpack_require__(3);
	      eval(all);
	      /* eslint-enable no-eval */
	    }

	    // Read the prefs from local storage and create the local
	    // representations.
	    for (let i = 0; i < localStorage.length; ++i) {
	      let keyName = localStorage.key(i);
	      if (keyName.startsWith(PREFIX)) {
	        let {userValue, hasUserValue, defaultValue} =
	            JSON.parse(localStorage.getItem(keyName));
	        this._findOrCreatePref(keyName.slice(PREFIX.length), userValue,
	                               hasUserValue, defaultValue);
	      }
	    }

	    this._onStorageChange = this._onStorageChange.bind(this);
	    window.addEventListener("storage", this._onStorageChange);
	  },
	};

	const Services = {
	  _prefs: null,

	  // For use by tests.  If set to false before Services.prefs is used,
	  // this will disable the reading of the default prefs.
	  _defaultPrefsEnabled: true,

	  /**
	   * An implementation of nsIPrefService that is based on local
	   * storage.  Only the subset of nsIPrefService that is actually used
	   * by devtools is implemented here.  This is lazily instantiated so
	   * that the tests have a chance to disable the loading of default
	   * prefs.
	   */
	  get prefs() {
	    if (!this._prefs) {
	      this._prefs = new PrefBranch(null, "", "");
	      this._prefs._initializeRoot();
	    }
	    return this._prefs;
	  },

	  /**
	   * An implementation of Services.appinfo that holds just the
	   * properties needed by devtools.
	   */
	  appinfo: {
	    get OS() {
	      const os = window.navigator.userAgent;
	      if (os) {
	        if (os.includes("Linux")) {
	          return "Linux";
	        } else if (os.includes("Windows")) {
	          return "WINNT";
	        } else if (os.includes("Mac")) {
	          return "Darwin";
	        }
	      }
	      return "Unknown";
	    },

	    // It's fine for this to be an approximation.
	    get name() {
	      return window.navigator.userAgent;
	    },

	    // It's fine for this to be an approximation.
	    get version() {
	      return window.navigator.appVersion;
	    },

	    // This is only used by telemetry, which is disabled for the
	    // content case.  So, being totally wrong is ok.
	    get is64Bit() {
	      return true;
	    },
	  },

	  /**
	   * A no-op implementation of Services.telemetry.  This supports just
	   * the subset of Services.telemetry that is used by devtools.
	   */
	  telemetry: {
	    getHistogramById: function (name) {
	      return {
	        add: () => {}
	      };
	    },

	    getKeyedHistogramById: function (name) {
	      return {
	        add: () => {}
	      };
	    },
	  },

	  /**
	   * An implementation of Services.focus that holds just the
	   * properties and methods needed by devtools.
	   * @see nsIFocusManager.idl for details.
	   */
	  focus: {
	    // These values match nsIFocusManager in order to make testing a
	    // bit simpler.
	    MOVEFOCUS_FORWARD: 1,
	    MOVEFOCUS_BACKWARD: 2,

	    get focusedElement() {
	      if (!document.hasFocus()) {
	        return null;
	      }
	      return document.activeElement;
	    },

	    moveFocus: function (window, startElement, type, flags) {
	      if (flags !== 0) {
	        throw new Error("shim Services.focus.moveFocus only accepts flags===0");
	      }
	      if (type !== Services.focus.MOVEFOCUS_FORWARD
	          && type !== Services.focus.MOVEFOCUS_BACKWARD) {
	        throw new Error("shim Services.focus.moveFocus only supports " +
	                        " MOVEFOCUS_FORWARD and MOVEFOCUS_BACKWARD");
	      }

	      if (!startElement) {
	        startElement = document.activeElement || document;
	      }

	      let iter = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, {
	        acceptNode: function (node) {
	          let tabIndex = node.getAttribute("tabindex");
	          if (tabIndex === "-1") {
	            return NodeFilter.FILTER_SKIP;
	          }
	          node.focus();
	          if (document.activeElement == node) {
	            return NodeFilter.FILTER_ACCEPT;
	          }
	          return NodeFilter.FILTER_SKIP;
	        }
	      });

	      iter.currentNode = startElement;

	      // Sets the focus via side effect in the filter.
	      if (type === Services.focus.MOVEFOCUS_FORWARD) {
	        iter.nextNode();
	      } else {
	        iter.previousNode();
	      }
	    },
	  },
	};

	/**
	 * Create a new preference.  This is used during startup (see
	 * devtools/client/preferences/devtools.js) to install the
	 * default preferences.
	 *
	 * @param {String} name the name of the preference
	 * @param {Any} value the default value of the preference
	 */
	function pref(name, value) {
	  let thePref = Services.prefs._findOrCreatePref(name, value, true, value);
	  thePref._setDefault(value);
	}

	module.exports = Services;
	// This is exported to silence eslint.
	exports.pref = pref;


/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = "pref(\"devtools.devedition.promo.shown\", false);\npref(\"devtools.devedition.promo.url\", \"https://www.mozilla.org/firefox/developer/?utm_source=firefox-dev-tools&utm_medium=firefox-browser&utm_content=betadoorhanger\");\n  pref(\"devtools.devedition.promo.enabled\", false);\npref(\"devtools.loader.hotreload\", false);\npref(\"devtools.toolbar.enabled\", true);\npref(\"devtools.toolbar.visible\", false);\npref(\"devtools.webide.enabled\", true);\npref(\"devtools.toolbox.footer.height\", 250);\npref(\"devtools.toolbox.sidebar.width\", 500);\npref(\"devtools.toolbox.host\", \"bottom\");\npref(\"devtools.toolbox.previousHost\", \"side\");\npref(\"devtools.toolbox.selectedTool\", \"webconsole\");\npref(\"devtools.toolbox.toolbarSpec\", '[\"splitconsole\", \"paintflashing toggle\",\"scratchpad\",\"resize toggle\",\"screenshot --fullpage\", \"rulers\", \"measure\"]');\npref(\"devtools.toolbox.sideEnabled\", true);\npref(\"devtools.toolbox.zoomValue\", \"1\");\npref(\"devtools.toolbox.splitconsoleEnabled\", false);\npref(\"devtools.toolbox.splitconsoleHeight\", 100);\npref(\"devtools.command-button-pick.enabled\", true);\npref(\"devtools.command-button-frames.enabled\", true);\npref(\"devtools.command-button-splitconsole.enabled\", true);\npref(\"devtools.command-button-paintflashing.enabled\", false);\npref(\"devtools.command-button-scratchpad.enabled\", false);\npref(\"devtools.command-button-responsive.enabled\", true);\npref(\"devtools.command-button-screenshot.enabled\", false);\npref(\"devtools.command-button-rulers.enabled\", false);\npref(\"devtools.command-button-measure.enabled\", false);\npref(\"devtools.command-button-noautohide.enabled\", false);\npref(\"devtools.inspector.enabled\", true);\npref(\"devtools.inspector.activeSidebar\", \"ruleview\");\npref(\"devtools.inspector.remote\", false);\npref(\"devtools.inspector.show_pseudo_elements\", false);\npref(\"devtools.inspector.imagePreviewTooltipSize\", 300);\npref(\"devtools.inspector.showUserAgentStyles\", false);\npref(\"devtools.inspector.showAllAnonymousContent\", false);\npref(\"devtools.inspector.mdnDocsTooltip.enabled\", true);\npref(\"devtools.markup.collapseAttributes\", true);\npref(\"devtools.markup.collapseAttributeLength\", 120);\npref(\"devtools.defaultColorUnit\", \"authored\");\npref(\"devtools.responsiveUI.no-reload-notification\", false);\npref(\"devtools.debugger.enabled\", true);\npref(\"devtools.debugger.chrome-debugging-host\", \"localhost\");\npref(\"devtools.debugger.chrome-debugging-port\", 6080);\npref(\"devtools.debugger.chrome-debugging-websocket\", false);\npref(\"devtools.debugger.remote-host\", \"localhost\");\npref(\"devtools.debugger.remote-timeout\", 20000);\npref(\"devtools.debugger.pause-on-exceptions\", false);\npref(\"devtools.debugger.ignore-caught-exceptions\", true);\npref(\"devtools.debugger.source-maps-enabled\", true);\npref(\"devtools.debugger.pretty-print-enabled\", true);\npref(\"devtools.debugger.auto-pretty-print\", false);\npref(\"devtools.debugger.auto-black-box\", true);\npref(\"devtools.debugger.workers\", false);\npref(\"devtools.debugger.promise\", false);\npref(\"devtools.debugger.new-debugger-frontend\", false);\npref(\"devtools.debugger.ui.panes-workers-and-sources-width\", 200);\npref(\"devtools.debugger.ui.panes-instruments-width\", 300);\npref(\"devtools.debugger.ui.panes-visible-on-startup\", false);\npref(\"devtools.debugger.ui.variables-sorting-enabled\", true);\npref(\"devtools.debugger.ui.variables-only-enum-visible\", false);\npref(\"devtools.debugger.ui.variables-searchbox-visible\", false);\npref(\"devtools.memory.enabled\", true);\npref(\"devtools.memory.custom-census-displays\", \"{}\");\npref(\"devtools.memory.custom-label-displays\", \"{}\");\npref(\"devtools.memory.custom-tree-map-displays\", \"{}\");\npref(\"devtools.memory.max-individuals\", 1000);\npref(\"devtools.memory.max-retaining-paths\", 10);\npref(\"devtools.performance.enabled\", true);\npref(\"devtools.performance.memory.sample-probability\", \"0.05\");\npref(\"devtools.performance.memory.max-log-length\", 125000);\npref(\"devtools.performance.timeline.hidden-markers\",\n  \"[\\\"Composite\\\",\\\"CompositeForwardTransaction\\\"]\");\npref(\"devtools.performance.profiler.buffer-size\", 10000000);\npref(\"devtools.performance.profiler.sample-frequency-khz\", 1);\npref(\"devtools.performance.ui.invert-call-tree\", true);\npref(\"devtools.performance.ui.invert-flame-graph\", false);\npref(\"devtools.performance.ui.flatten-tree-recursion\", true);\npref(\"devtools.performance.ui.show-platform-data\", false);\npref(\"devtools.performance.ui.show-idle-blocks\", true);\npref(\"devtools.performance.ui.enable-memory\", false);\npref(\"devtools.performance.ui.enable-allocations\", false);\npref(\"devtools.performance.ui.enable-framerate\", true);\npref(\"devtools.performance.ui.show-jit-optimizations\", false);\npref(\"devtools.performance.ui.show-triggers-for-gc-types\",\n  \"TOO_MUCH_MALLOC ALLOC_TRIGGER LAST_DITCH EAGER_ALLOC_TRIGGER\");\npref(\"devtools.performance.ui.enable-memory-flame\", false);\npref(\"devtools.performance.ui.experimental\", false);\npref(\"devtools.cache.disabled\", false);\npref(\"devtools.serviceWorkers.testing.enabled\", false);\npref(\"devtools.netmonitor.enabled\", true);\npref(\"devtools.netmonitor.panes-network-details-width\", 550);\npref(\"devtools.netmonitor.panes-network-details-height\", 450);\npref(\"devtools.netmonitor.statistics\", true);\npref(\"devtools.netmonitor.filters\", \"[\\\"all\\\"]\");\npref(\"devtools.netmonitor.har.defaultLogDir\", \"\");\npref(\"devtools.netmonitor.har.defaultFileName\", \"Archive %y-%m-%d %H-%M-%S\");\npref(\"devtools.netmonitor.har.jsonp\", false);\npref(\"devtools.netmonitor.har.jsonpCallback\", \"\");\npref(\"devtools.netmonitor.har.includeResponseBodies\", true);\npref(\"devtools.netmonitor.har.compress\", false);\npref(\"devtools.netmonitor.har.forceExport\", false);\npref(\"devtools.netmonitor.har.pageLoadedTimeout\", 1500);\npref(\"devtools.netmonitor.har.enableAutoExportToFile\", false);\npref(\"devtools.scratchpad.recentFilesMax\", 10);\npref(\"devtools.scratchpad.lineNumbers\", true);\npref(\"devtools.scratchpad.wrapText\", false);\npref(\"devtools.scratchpad.showTrailingSpace\", false);\npref(\"devtools.scratchpad.editorFontSize\", 12);\npref(\"devtools.scratchpad.enableAutocompletion\", true);\npref(\"devtools.storage.enabled\", false);\npref(\"devtools.styleeditor.enabled\", true);\npref(\"devtools.styleeditor.source-maps-enabled\", true);\npref(\"devtools.styleeditor.autocompletion-enabled\", true);\npref(\"devtools.styleeditor.showMediaSidebar\", true);\npref(\"devtools.styleeditor.mediaSidebarWidth\", 238);\npref(\"devtools.styleeditor.navSidebarWidth\", 245);\npref(\"devtools.styleeditor.transitions\", true);\npref(\"devtools.shadereditor.enabled\", false);\npref(\"devtools.canvasdebugger.enabled\", false);\npref(\"devtools.webaudioeditor.enabled\", false);\npref(\"devtools.scratchpad.enabled\", false);\npref(\"devtools.dom.enabled\", false);\npref(\"devtools.webaudioeditor.inspectorWidth\", 300);\npref(\"devtools.theme\", \"light\");\npref(\"devtools.webconsole.filter.network\", true);\npref(\"devtools.webconsole.filter.networkinfo\", false);\npref(\"devtools.webconsole.filter.netwarn\", true);\npref(\"devtools.webconsole.filter.netxhr\", false);\npref(\"devtools.webconsole.filter.csserror\", true);\npref(\"devtools.webconsole.filter.cssparser\", false);\npref(\"devtools.webconsole.filter.csslog\", false);\npref(\"devtools.webconsole.filter.exception\", true);\npref(\"devtools.webconsole.filter.jswarn\", true);\npref(\"devtools.webconsole.filter.jslog\", false);\npref(\"devtools.webconsole.filter.error\", true);\npref(\"devtools.webconsole.filter.warn\", true);\npref(\"devtools.webconsole.filter.info\", true);\npref(\"devtools.webconsole.filter.log\", true);\npref(\"devtools.webconsole.filter.secerror\", true);\npref(\"devtools.webconsole.filter.secwarn\", true);\npref(\"devtools.webconsole.filter.serviceworkers\", true);\npref(\"devtools.webconsole.filter.sharedworkers\", false);\npref(\"devtools.webconsole.filter.windowlessworkers\", false);\npref(\"devtools.webconsole.filter.servererror\", false);\npref(\"devtools.webconsole.filter.serverwarn\", false);\npref(\"devtools.webconsole.filter.serverinfo\", false);\npref(\"devtools.webconsole.filter.serverlog\", false);\npref(\"devtools.browserconsole.filter.network\", true);\npref(\"devtools.browserconsole.filter.networkinfo\", false);\npref(\"devtools.browserconsole.filter.netwarn\", true);\npref(\"devtools.browserconsole.filter.netxhr\", false);\npref(\"devtools.browserconsole.filter.csserror\", true);\npref(\"devtools.browserconsole.filter.cssparser\", false);\npref(\"devtools.browserconsole.filter.csslog\", false);\npref(\"devtools.browserconsole.filter.exception\", true);\npref(\"devtools.browserconsole.filter.jswarn\", true);\npref(\"devtools.browserconsole.filter.jslog\", true);\npref(\"devtools.browserconsole.filter.error\", true);\npref(\"devtools.browserconsole.filter.warn\", true);\npref(\"devtools.browserconsole.filter.info\", true);\npref(\"devtools.browserconsole.filter.log\", true);\npref(\"devtools.browserconsole.filter.secerror\", true);\npref(\"devtools.browserconsole.filter.secwarn\", true);\npref(\"devtools.browserconsole.filter.serviceworkers\", true);\npref(\"devtools.browserconsole.filter.sharedworkers\", true);\npref(\"devtools.browserconsole.filter.windowlessworkers\", true);\npref(\"devtools.browserconsole.filter.servererror\", false);\npref(\"devtools.browserconsole.filter.serverwarn\", false);\npref(\"devtools.browserconsole.filter.serverinfo\", false);\npref(\"devtools.browserconsole.filter.serverlog\", false);\npref(\"devtools.webconsole.inputHistoryCount\", 50);\npref(\"devtools.webconsole.persistlog\", false);\npref(\"devtools.webconsole.timestampMessages\", false);\npref(\"devtools.webconsole.autoMultiline\", true);\npref(\"devtools.webconsole.new-frontend-enabled\", false);\npref(\"devtools.sourcemap.locations.enabled\", false);\npref(\"devtools.hud.loglimit\", 1000);\npref(\"devtools.hud.loglimit.network\", 1000);\npref(\"devtools.hud.loglimit.cssparser\", 1000);\npref(\"devtools.hud.loglimit.exception\", 1000);\npref(\"devtools.hud.loglimit.console\", 1000);\npref(\"devtools.eyedropper.zoom\", 6);\npref(\"devtools.editor.tabsize\", 2);\npref(\"devtools.editor.expandtab\", true);\npref(\"devtools.editor.keymap\", \"default\");\npref(\"devtools.editor.autoclosebrackets\", true);\npref(\"devtools.editor.detectindentation\", true);\npref(\"devtools.editor.enableCodeFolding\", true);\npref(\"devtools.editor.autocomplete\", true);\npref(\"devtools.fontinspector.enabled\", true);\npref(\"devtools.telemetry.tools.opened.version\", \"{}\");\npref(\"devtools.jsonview.enabled\", false);"

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = "pref(\"devtools.errorconsole.deprecation_warnings\", true);\npref(\"devtools.chrome.enabled\", false);\npref(\"devtools.debugger.log\", false);\npref(\"devtools.debugger.log.verbose\", false);\npref(\"devtools.debugger.remote-enabled\", false);\npref(\"devtools.debugger.remote-port\", 6000);\npref(\"devtools.debugger.remote-websocket\", false);\npref(\"devtools.debugger.force-local\", true);\npref(\"devtools.debugger.prompt-connection\", true);\npref(\"devtools.debugger.forbid-certified-apps\", true);\npref(\"devtools.apps.forbidden-permissions\", \"embed-apps,embed-widgets\");\npref(\"devtools.defaultColorUnit\", \"authored\");\npref(\"devtools.dump.emit\", false);\npref(\"devtools.discovery.log\", false);\npref(\"devtools.remote.wifi.scan\", true);\npref(\"devtools.remote.wifi.visible\", true);\npref(\"devtools.remote.tls-handshake-timeout\", 10000);\npref(\"devtools.devices.url\", \"https://code.cdn.mozilla.net/devices/devices.json\");\npref(\"devtools.gcli.hideIntro\", false);\npref(\"devtools.gcli.eagerHelper\", 2);\npref(\"devtools.gcli.jquerySrc\", \"https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.1/jquery.min.js\");\npref(\"devtools.gcli.lodashSrc\", \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.6.1/lodash.min.js\");\npref(\"devtools.gcli.underscoreSrc\", \"https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js\");\npref(\"devtools.gcli.imgurClientID\", '0df414e888d7240');\npref(\"devtools.gcli.imgurUploadURL\", \"https://api.imgur.com/3/image\");\npref(\"devtools.commands.dir\", \"\");\npref(\"devtools.telemetry.supported_performance_marks\", \"contentInteractive,navigationInteractive,navigationLoaded,visuallyLoaded,fullyLoaded,mediaEnumerated,scanEnd\");\npref(\"devtools.migration.warnings\", true);"

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = Promise;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// See bug 1273941 to understand this choice of promise.
	const Promise = __webpack_require__(4);

	/**
	 * Returns a deferred object, with a resolve and reject property.
	 * https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred
	 */
	module.exports = function defer() {
	  let resolve, reject;
	  let promise = new Promise(function () {
	    resolve = arguments[0];
	    reject = arguments[1];
	  });
	  return {
	    resolve: resolve,
	    reject: reject,
	    promise: promise
	  };
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	  // ⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠⚠
	  // After this point the code may not use Cu.import, and should only
	  // require() modules that are "clean-for-content".
	  let EventEmitter = this.EventEmitter = function () {};
	  module.exports = EventEmitter;

	  // See comment in JSM module boilerplate when adding a new dependency.
	  const Services = __webpack_require__(1);
	  const defer = __webpack_require__(5);
	  const { describeNthCaller } = __webpack_require__(7);
	  let loggingEnabled = true;

	  if (true) {
	    loggingEnabled = Services.prefs.getBoolPref("devtools.dump.emit");
	    Services.prefs.addObserver("devtools.dump.emit", {
	      observe: () => {
	        loggingEnabled = Services.prefs.getBoolPref("devtools.dump.emit");
	      }
	    }, false);
	  }

	  /**
	   * Decorate an object with event emitter functionality.
	   *
	   * @param Object objectToDecorate
	   *        Bind all public methods of EventEmitter to
	   *        the objectToDecorate object.
	   */
	  EventEmitter.decorate = function (objectToDecorate) {
	    let emitter = new EventEmitter();
	    objectToDecorate.on = emitter.on.bind(emitter);
	    objectToDecorate.off = emitter.off.bind(emitter);
	    objectToDecorate.once = emitter.once.bind(emitter);
	    objectToDecorate.emit = emitter.emit.bind(emitter);
	  };

	  EventEmitter.prototype = {
	    /**
	     * Connect a listener.
	     *
	     * @param string event
	     *        The event name to which we're connecting.
	     * @param function listener
	     *        Called when the event is fired.
	     */
	    on(event, listener) {
	      if (!this._eventEmitterListeners) {
	        this._eventEmitterListeners = new Map();
	      }
	      if (!this._eventEmitterListeners.has(event)) {
	        this._eventEmitterListeners.set(event, []);
	      }
	      this._eventEmitterListeners.get(event).push(listener);
	    },

	    /**
	     * Listen for the next time an event is fired.
	     *
	     * @param string event
	     *        The event name to which we're connecting.
	     * @param function listener
	     *        (Optional) Called when the event is fired. Will be called at most
	     *        one time.
	     * @return promise
	     *        A promise which is resolved when the event next happens. The
	     *        resolution value of the promise is the first event argument. If
	     *        you need access to second or subsequent event arguments (it's rare
	     *        that this is needed) then use listener
	     */
	    once(event, listener) {
	      let deferred = defer();

	      let handler = (_, first, ...rest) => {
	        this.off(event, handler);
	        if (listener) {
	          listener.apply(null, [event, first, ...rest]);
	        }
	        deferred.resolve(first);
	      };

	      handler._originalListener = listener;
	      this.on(event, handler);

	      return deferred.promise;
	    },

	    /**
	     * Remove a previously-registered event listener.  Works for events
	     * registered with either on or once.
	     *
	     * @param string event
	     *        The event name whose listener we're disconnecting.
	     * @param function listener
	     *        The listener to remove.
	     */
	    off(event, listener) {
	      if (!this._eventEmitterListeners) {
	        return;
	      }
	      let listeners = this._eventEmitterListeners.get(event);
	      if (listeners) {
	        this._eventEmitterListeners.set(event, listeners.filter(l => {
	          return l !== listener && l._originalListener !== listener;
	        }));
	      }
	    },

	    /**
	     * Emit an event.  All arguments to this method will
	     * be sent to listener functions.
	     */
	    emit(event) {
	      this.logEvent(event, arguments);

	      if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(event)) {
	        return;
	      }

	      let originalListeners = this._eventEmitterListeners.get(event);
	      for (let listener of this._eventEmitterListeners.get(event)) {
	        // If the object was destroyed during event emission, stop
	        // emitting.
	        if (!this._eventEmitterListeners) {
	          break;
	        }

	        // If listeners were removed during emission, make sure the
	        // event handler we're going to fire wasn't removed.
	        if (originalListeners === this._eventEmitterListeners.get(event) ||
	          this._eventEmitterListeners.get(event).some(l => l === listener)) {
	          try {
	            listener.apply(null, arguments);
	          } catch (ex) {
	            // Prevent a bad listener from interfering with the others.
	            let msg = ex + ": " + ex.stack;
	            console.error(msg);
	            (console.log)(msg + "\n");
	          }
	        }
	      }
	    },

	    logEvent(event, args) {
	      if (!loggingEnabled) {
	        return;
	      }

	      let description = describeNthCaller(2);

	      let argOut = "(";
	      if (args.length === 1) {
	        argOut += event;
	      }

	      let out = "EMITTING: ";

	      // We need this try / catch to prevent any dead object errors.
	      try {
	        for (let i = 1; i < args.length; i++) {
	          if (i === 1) {
	            argOut = "(" + event + ", ";
	          } else {
	            argOut += ", ";
	          }

	          let arg = args[i];
	          argOut += arg;

	          if (arg && arg.nodeName) {
	            argOut += " (" + arg.nodeName;
	            if (arg.id) {
	              argOut += "#" + arg.id;
	            }
	            if (arg.className) {
	              argOut += "." + arg.className;
	            }
	            argOut += ")";
	          }
	        }
	      } catch (e) {
	        // Object is dead so the toolbox is most likely shutting down,
	        // do nothing.
	      }

	      argOut += ")";
	      out += "emit" + argOut + " from " + description + "\n";

	      (console.log)(out);
	    },
	  };


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// A few wrappers for stack-manipulation.  This version of the module
	// is used in content code.  Note that this particular copy of the
	// file can only be loaded via require(), because Cu.import doesn't
	// exist in the content case.  So, we don't need the code to handle
	// both require and import here.

	"use strict";

	/**
	 * Looks like Cu.callFunctionWithAsyncStack, but just calls the callee.
	 */
	function callFunctionWithAsyncStack(callee, stack, id) {
	  return callee();
	}

	/**
	 * Return a description of the Nth caller, suitable for logging.
	 *
	 * @param {Number} n the caller to describe
	 * @return {String} a description of the nth caller.
	 */
	function describeNthCaller(n) {
	  if (false) {
	    return "";
	  }

	  let stack = new Error().stack.split("\n");
	  // Add one here to skip this function.
	  return stack[n + 1];
	}

	/**
	 * Return a stack object that can be serialized and, when
	 * deserialized, passed to callFunctionWithAsyncStack.
	 */
	function getStack() {
	  // There's no reason for this to do anything fancy, since it's only
	  // used to pass back into callFunctionWithAsyncStack, which we can't
	  // implement.
	  return null;
	}

	exports.callFunctionWithAsyncStack = callFunctionWithAsyncStack;
	exports.describeNthCaller = describeNthCaller;
	exports.getStack = getStack;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* General utilities used throughout devtools. */

	var { Ci, Cu, Cc, components } = __webpack_require__(9);
	var Services = __webpack_require__(1);
	var promise = __webpack_require__(4);
	var defer = __webpack_require__(5);
	var flags = __webpack_require__(10);
	var {getStack, callFunctionWithAsyncStack} = __webpack_require__(7);

	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "FileUtils",
	                         "resource://gre/modules/FileUtils.jsm", true);

	// Re-export the thread-safe utils.
	const ThreadSafeDevToolsUtils = __webpack_require__(11);
	for (let key of Object.keys(ThreadSafeDevToolsUtils)) {
	  exports[key] = ThreadSafeDevToolsUtils[key];
	}

	/**
	 * Waits for the next tick in the event loop to execute a callback.
	 */
	exports.executeSoon = function executeSoon(aFn) {
	  if (false) {
	    setImmediate(aFn);
	  } else {
	    let executor;
	    // Only enable async stack reporting when DEBUG_JS_MODULES is set
	    // (customized local builds) to avoid a performance penalty.
	    if (AppConstants.DEBUG_JS_MODULES || flags.testing) {
	      let stack = getStack();
	      executor = () => {
	        callFunctionWithAsyncStack(aFn, stack, "DevToolsUtils.executeSoon");
	      };
	    } else {
	      executor = aFn;
	    }
	    Services.tm.mainThread.dispatch({
	      run: exports.makeInfallible(executor)
	    }, Ci.nsIThread.DISPATCH_NORMAL);
	  }
	};

	/**
	 * Waits for the next tick in the event loop.
	 *
	 * @return Promise
	 *         A promise that is resolved after the next tick in the event loop.
	 */
	exports.waitForTick = function waitForTick() {
	  let deferred = defer();
	  exports.executeSoon(deferred.resolve);
	  return deferred.promise;
	};

	/**
	 * Waits for the specified amount of time to pass.
	 *
	 * @param number aDelay
	 *        The amount of time to wait, in milliseconds.
	 * @return Promise
	 *         A promise that is resolved after the specified amount of time passes.
	 */
	exports.waitForTime = function waitForTime(aDelay) {
	  let deferred = defer();
	  setTimeout(deferred.resolve, aDelay);
	  return deferred.promise;
	};

	/**
	 * Like Array.prototype.forEach, but doesn't cause jankiness when iterating over
	 * very large arrays by yielding to the browser and continuing execution on the
	 * next tick.
	 *
	 * @param Array aArray
	 *        The array being iterated over.
	 * @param Function aFn
	 *        The function called on each item in the array. If a promise is
	 *        returned by this function, iterating over the array will be paused
	 *        until the respective promise is resolved.
	 * @returns Promise
	 *          A promise that is resolved once the whole array has been iterated
	 *          over, and all promises returned by the aFn callback are resolved.
	 */
	exports.yieldingEach = function yieldingEach(aArray, aFn) {
	  const deferred = defer();

	  let i = 0;
	  let len = aArray.length;
	  let outstanding = [deferred.promise];

	  (function loop() {
	    const start = Date.now();

	    while (i < len) {
	      // Don't block the main thread for longer than 16 ms at a time. To
	      // maintain 60fps, you have to render every frame in at least 16ms; we
	      // aren't including time spent in non-JS here, but this is Good
	      // Enough(tm).
	      if (Date.now() - start > 16) {
	        exports.executeSoon(loop);
	        return;
	      }

	      try {
	        outstanding.push(aFn(aArray[i], i++));
	      } catch (e) {
	        deferred.reject(e);
	        return;
	      }
	    }

	    deferred.resolve();
	  }());

	  return promise.all(outstanding);
	};

	/**
	 * Like XPCOMUtils.defineLazyGetter, but with a |this| sensitive getter that
	 * allows the lazy getter to be defined on a prototype and work correctly with
	 * instances.
	 *
	 * @param Object aObject
	 *        The prototype object to define the lazy getter on.
	 * @param String aKey
	 *        The key to define the lazy getter on.
	 * @param Function aCallback
	 *        The callback that will be called to determine the value. Will be
	 *        called with the |this| value of the current instance.
	 */
	exports.defineLazyPrototypeGetter =
	function defineLazyPrototypeGetter(aObject, aKey, aCallback) {
	  Object.defineProperty(aObject, aKey, {
	    configurable: true,
	    get: function () {
	      const value = aCallback.call(this);

	      Object.defineProperty(this, aKey, {
	        configurable: true,
	        writable: true,
	        value: value
	      });

	      return value;
	    }
	  });
	};

	/**
	 * Safely get the property value from a Debugger.Object for a given key. Walks
	 * the prototype chain until the property is found.
	 *
	 * @param Debugger.Object aObject
	 *        The Debugger.Object to get the value from.
	 * @param String aKey
	 *        The key to look for.
	 * @return Any
	 */
	exports.getProperty = function getProperty(aObj, aKey) {
	  let root = aObj;
	  try {
	    do {
	      const desc = aObj.getOwnPropertyDescriptor(aKey);
	      if (desc) {
	        if ("value" in desc) {
	          return desc.value;
	        }
	        // Call the getter if it's safe.
	        return exports.hasSafeGetter(desc) ? desc.get.call(root).return : undefined;
	      }
	      aObj = aObj.proto;
	    } while (aObj);
	  } catch (e) {
	    // If anything goes wrong report the error and return undefined.
	    exports.reportException("getProperty", e);
	  }
	  return undefined;
	};

	/**
	 * Determines if a descriptor has a getter which doesn't call into JavaScript.
	 *
	 * @param Object aDesc
	 *        The descriptor to check for a safe getter.
	 * @return Boolean
	 *         Whether a safe getter was found.
	 */
	exports.hasSafeGetter = function hasSafeGetter(aDesc) {
	  // Scripted functions that are CCWs will not appear scripted until after
	  // unwrapping.
	  try {
	    let fn = aDesc.get.unwrap();
	    return fn && fn.callable && fn.class == "Function" && fn.script === undefined;
	  } catch (e) {
	    // Avoid exception 'Object in compartment marked as invisible to Debugger'
	    return false;
	  }
	};

	/**
	 * Check if it is safe to read properties and execute methods from the given JS
	 * object. Safety is defined as being protected from unintended code execution
	 * from content scripts (or cross-compartment code).
	 *
	 * See bugs 945920 and 946752 for discussion.
	 *
	 * @type Object aObj
	 *       The object to check.
	 * @return Boolean
	 *         True if it is safe to read properties from aObj, or false otherwise.
	 */
	exports.isSafeJSObject = function isSafeJSObject(aObj) {
	  // If we are running on a worker thread, Cu is not available. In this case,
	  // we always return false, just to be on the safe side.
	  if (false) {
	    return false;
	  }

	  if (Cu.getGlobalForObject(aObj) ==
	      Cu.getGlobalForObject(exports.isSafeJSObject)) {
	    return true; // aObj is not a cross-compartment wrapper.
	  }

	  let principal = Cu.getObjectPrincipal(aObj);
	  if (Services.scriptSecurityManager.isSystemPrincipal(principal)) {
	    return true; // allow chrome objects
	  }

	  return Cu.isXrayWrapper(aObj);
	};

	exports.dumpn = function dumpn(str) {
	  if (flags.wantLogging) {
	    (console.log)("DBG-SERVER: " + str + "\n");
	  }
	};

	/**
	 * A verbose logger for low-level tracing.
	 */
	exports.dumpv = function (msg) {
	  if (flags.wantVerbose) {
	    exports.dumpn(msg);
	  }
	};

	/**
	 * Defines a getter on a specified object that will be created upon first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject.
	 * @param aLambda
	 *        A function that returns what the getter should return.  This will
	 *        only ever be called once.
	 */
	exports.defineLazyGetter = function defineLazyGetter(aObject, aName, aLambda) {
	  Object.defineProperty(aObject, aName, {
	    get: function () {
	      delete aObject[aName];
	      return aObject[aName] = aLambda.apply(aObject);
	    },
	    configurable: true,
	    enumerable: true
	  });
	};

	exports.defineLazyGetter(this, "AppConstants", () => {
	  if (false) {
	    return {};
	  }
	  const scope = {};
	  Cu.import("resource://gre/modules/AppConstants.jsm", scope);
	  return scope.AppConstants;
	});

	/**
	 * No operation. The empty function.
	 */
	exports.noop = function () { };

	let assertionFailureCount = 0;

	Object.defineProperty(exports, "assertionFailureCount", {
	  get() {
	    return assertionFailureCount;
	  }
	});

	function reallyAssert(condition, message) {
	  if (!condition) {
	    assertionFailureCount++;
	    const err = new Error("Assertion failure: " + message);
	    exports.reportException("DevToolsUtils.assert", err);
	    throw err;
	  }
	}

	/**
	 * DevToolsUtils.assert(condition, message)
	 *
	 * @param Boolean condition
	 * @param String message
	 *
	 * Assertions are enabled when any of the following are true:
	 *   - This is a DEBUG_JS_MODULES build
	 *   - This is a DEBUG build
	 *   - flags.testing is set to true
	 *
	 * If assertions are enabled, then `condition` is checked and if false-y, the
	 * assertion failure is logged and then an error is thrown.
	 *
	 * If assertions are not enabled, then this function is a no-op.
	 */
	Object.defineProperty(exports, "assert", {
	  get: () => (AppConstants.DEBUG || AppConstants.DEBUG_JS_MODULES || flags.testing)
	    ? reallyAssert
	    : exports.noop,
	});

	/**
	 * Defines a getter on a specified object for a module.  The module will not
	 * be imported until first use.
	 *
	 * @param aObject
	 *        The object to define the lazy getter on.
	 * @param aName
	 *        The name of the getter to define on aObject for the module.
	 * @param aResource
	 *        The URL used to obtain the module.
	 * @param aSymbol
	 *        The name of the symbol exported by the module.
	 *        This parameter is optional and defaults to aName.
	 */
	exports.defineLazyModuleGetter = function defineLazyModuleGetter(aObject, aName,
	                                                                 aResource,
	                                                                 aSymbol)
	{
	  this.defineLazyGetter(aObject, aName, function XPCU_moduleLambda() {
	    var temp = {};
	    Cu.import(aResource, temp);
	    return temp[aSymbol || aName];
	  });
	};

	exports.defineLazyGetter(this, "NetUtil", () => {
	  return Cu.import("resource://gre/modules/NetUtil.jsm", {}).NetUtil;
	});

	exports.defineLazyGetter(this, "OS", () => {
	  return Cu.import("resource://gre/modules/osfile.jsm", {}).OS;
	});

	exports.defineLazyGetter(this, "TextDecoder", () => {
	  return Cu.import("resource://gre/modules/osfile.jsm", {}).TextDecoder;
	});

	exports.defineLazyGetter(this, "NetworkHelper", () => {
	  return __webpack_require__(12);
	});

	/**
	 * Performs a request to load the desired URL and returns a promise.
	 *
	 * @param aURL String
	 *        The URL we will request.
	 * @param aOptions Object
	 *        An object with the following optional properties:
	 *        - loadFromCache: if false, will bypass the cache and
	 *          always load fresh from the network (default: true)
	 *        - policy: the nsIContentPolicy type to apply when fetching the URL
	 *                  (only works when loading from system principal)
	 *        - window: the window to get the loadGroup from
	 *        - charset: the charset to use if the channel doesn't provide one
	 *        - principal: the principal to use, if omitted, the request is loaded
	 *                     with the system principal
	 *        - cacheKey: when loading from cache, use this key to retrieve a cache
	 *                    specific to a given SHEntry. (Allows loading POST
	 *                    requests from cache)
	 * @returns Promise that resolves with an object with the following members on
	 *          success:
	 *           - content: the document at that URL, as a string,
	 *           - contentType: the content type of the document
	 *
	 *          If an error occurs, the promise is rejected with that error.
	 *
	 * XXX: It may be better to use nsITraceableChannel to get to the sources
	 * without relying on caching when we can (not for eval, etc.):
	 * http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/
	 */
	function mainThreadFetch(aURL, aOptions = { loadFromCache: true,
	                                          policy: Ci.nsIContentPolicy.TYPE_OTHER,
	                                          window: null,
	                                          charset: null,
	                                          principal: null,
	                                          cacheKey: null }) {
	  // Create a channel.
	  let url = aURL.split(" -> ").pop();
	  let channel;
	  try {
	    channel = newChannelForURL(url, aOptions);
	  } catch (ex) {
	    return promise.reject(ex);
	  }

	  // Set the channel options.
	  channel.loadFlags = aOptions.loadFromCache
	    ? channel.LOAD_FROM_CACHE
	    : channel.LOAD_BYPASS_CACHE;

	  // When loading from cache, the cacheKey allows us to target a specific
	  // SHEntry and offer ways to restore POST requests from cache.
	  if (aOptions.loadFromCache &&
	      aOptions.cacheKey && channel instanceof Ci.nsICacheInfoChannel) {
	    channel.cacheKey = aOptions.cacheKey;
	  }

	  if (aOptions.window) {
	    // Respect private browsing.
	    channel.loadGroup = aOptions.window.QueryInterface(Ci.nsIInterfaceRequestor)
	                          .getInterface(Ci.nsIWebNavigation)
	                          .QueryInterface(Ci.nsIDocumentLoader)
	                          .loadGroup;
	  }

	  let deferred = defer();
	  let onResponse = (stream, status, request) => {
	    if (!components.isSuccessCode(status)) {
	      deferred.reject(new Error(`Failed to fetch ${url}. Code ${status}.`));
	      return;
	    }

	    try {
	      // We cannot use NetUtil to do the charset conversion as if charset
	      // information is not available and our default guess is wrong the method
	      // might fail and we lose the stream data. This means we can't fall back
	      // to using the locale default encoding (bug 1181345).

	      // Read and decode the data according to the locale default encoding.
	      let available = stream.available();
	      let source = NetUtil.readInputStreamToString(stream, available);
	      stream.close();

	      // If the channel or the caller has correct charset information, the
	      // content will be decoded correctly. If we have to fall back to UTF-8 and
	      // the guess is wrong, the conversion fails and convertToUnicode returns
	      // the input unmodified. Essentially we try to decode the data as UTF-8
	      // and if that fails, we use the locale specific default encoding. This is
	      // the best we can do if the source does not provide charset info.
	      let charset = channel.contentCharset || aOptions.charset || "UTF-8";
	      let unicodeSource = NetworkHelper.convertToUnicode(source, charset);

	      deferred.resolve({
	        content: unicodeSource,
	        contentType: request.contentType
	      });
	    } catch (ex) {
	      let uri = request.originalURI;
	      if (ex.name === "NS_BASE_STREAM_CLOSED" && uri instanceof Ci.nsIFileURL) {
	        // Empty files cause NS_BASE_STREAM_CLOSED exception. Use OS.File to
	        // differentiate between empty files and other errors (bug 1170864).
	        // This can be removed when bug 982654 is fixed.

	        uri.QueryInterface(Ci.nsIFileURL);
	        let result = OS.File.read(uri.file.path).then(bytes => {
	          // Convert the bytearray to a String.
	          let decoder = new TextDecoder();
	          let content = decoder.decode(bytes);

	          // We can't detect the contentType without opening a channel
	          // and that failed already. This is the best we can do here.
	          return {
	            content,
	            contentType: "text/plain"
	          };
	        });

	        deferred.resolve(result);
	      } else {
	        deferred.reject(ex);
	      }
	    }
	  };

	  // Open the channel
	  try {
	    NetUtil.asyncFetch(channel, onResponse);
	  } catch (ex) {
	    return promise.reject(ex);
	  }

	  return deferred.promise;
	}

	/**
	 * Opens a channel for given URL. Tries a bit harder than NetUtil.newChannel.
	 *
	 * @param {String} url - The URL to open a channel for.
	 * @param {Object} options - The options object passed to @method fetch.
	 * @return {nsIChannel} - The newly created channel. Throws on failure.
	 */
	function newChannelForURL(url, { policy, window, principal }) {
	  var securityFlags = Ci.nsILoadInfo.SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL;
	  if (window) {
	    // Respect private browsing.
	    var req = window.QueryInterface(Ci.nsIInterfaceRequestor)
	                    .getInterface(Ci.nsIWebNavigation)
	                    .QueryInterface(Ci.nsIDocumentLoader)
	                    .loadGroup;
	    if (req) {
	      var nc = req.notificationCallbacks;
	      if (nc) {
	        try {
	          var lc = nc.getInterface(Ci.nsILoadContext);
	          if (lc) {
	            if (lc.usePrivateBrowsing) {
	              securityFlags |= Ci.nsILoadInfo.SEC_FORCE_PRIVATE_BROWSING;
	            }
	          }
	        } catch (ex) {}
	      }
	    }
	  }

	  let channelOptions = {
	    contentPolicyType: policy,
	    securityFlags: securityFlags,
	    uri: url
	  };
	  if (principal) {
	    // contentPolicyType is required when loading with a custom principal
	    if (!channelOptions.contentPolicyType) {
	      channelOptions.contentPolicyType = Ci.nsIContentPolicy.TYPE_OTHER;
	    }
	    channelOptions.loadingPrincipal = principal;
	  } else {
	    channelOptions.loadUsingSystemPrincipal = true;
	  }

	  try {
	    return NetUtil.newChannel(channelOptions);
	  } catch (e) {
	    // In the xpcshell tests, the script url is the absolute path of the test
	    // file, which will make a malformed URI error be thrown. Add the file
	    // scheme to see if it helps.
	    channelOptions.uri = "file://" + url;

	    return NetUtil.newChannel(channelOptions);
	  }
	}

	// Fetch is defined differently depending on whether we are on the main thread
	// or a worker thread.
	if (!this.isWorker) {
	  exports.fetch = mainThreadFetch;
	} else {
	  // Services is not available in worker threads, nor is there any other way
	  // to fetch a URL. We need to enlist the help from the main thread here, by
	  // issuing an rpc request, to fetch the URL on our behalf.
	  exports.fetch = function (url, options) {
	    return rpc("fetch", url, options);
	  };
	}

	/**
	 * Open the file at the given path for reading.
	 *
	 * @param {String} filePath
	 *
	 * @returns Promise<nsIInputStream>
	 */
	exports.openFileStream = function (filePath) {
	  return new Promise((resolve, reject) => {
	    const uri = NetUtil.newURI(new FileUtils.File(filePath));
	    NetUtil.asyncFetch(
	      { uri, loadUsingSystemPrincipal: true },
	      (stream, result) => {
	        if (!components.isSuccessCode(result)) {
	          reject(new Error(`Could not open "${filePath}": result = ${result}`));
	          return;
	        }

	        resolve(stream);
	      }
	    );
	  });
	};

	/*
	 * All of the flags have been moved to a different module. Make sure
	 * nobody is accessing them anymore, and don't write new code using
	 * them. We can remove this code after a while.
	 */
	function errorOnFlag(exports, name) {
	  Object.defineProperty(exports, name, {
	    get: () => {
	      const msg = `Cannot get the flag ${name}. ` +
	            `Use the "devtools/shared/flags" module instead`;
	      console.error(msg);
	      throw new Error(msg);
	    },
	    set: () => {
	      const msg = `Cannot set the flag ${name}. ` +
	            `Use the "devtools/shared/flags" module instead`;
	      console.error(msg);
	      throw new Error(msg);
	    }
	  });
	}

	errorOnFlag(exports, "testing");
	errorOnFlag(exports, "wantLogging");
	errorOnFlag(exports, "wantVerbose");


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 10 */
/***/ function(module, exports) {

	
	/*
	 * Create a writable property by tracking it with a private variable.
	 * We cannot make a normal property writeable on `exports` because
	 * the module system freezes it.
	 */
	function makeWritableFlag(exports, name) {
	  let flag = false;
	  Object.defineProperty(exports, name, {
	    get: function () { return flag; },
	    set: function (state) { flag = state; }
	  });
	}

	makeWritableFlag(exports, "wantLogging");
	makeWritableFlag(exports, "wantVerbose");

	// When the testing flag is set, various behaviors may be altered from
	// production mode, typically to enable easier testing or enhanced
	// debugging.
	makeWritableFlag(exports, "testing");


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * General utilities used throughout devtools that can also be used in
	 * workers.
	 */

	/**
	 * Immutably reduce the given `...objs` into one object. The reduction is
	 * applied from left to right, so `immutableUpdate({ a: 1 }, { a: 2 })` will
	 * result in `{ a: 2 }`. The resulting object is frozen.
	 *
	 * Example usage:
	 *
	 *     const original = { foo: 1, bar: 2, baz: 3 };
	 *     const modified = immutableUpdate(original, { baz: 0, bang: 4 });
	 *
	 *     // We get the new object that we expect...
	 *     assert(modified.baz === 0);
	 *     assert(modified.bang === 4);
	 *
	 *     // However, the original is not modified.
	 *     assert(original.baz === 2);
	 *     assert(original.bang === undefined);
	 *
	 * @param {...Object} ...objs
	 * @returns {Object}
	 */
	exports.immutableUpdate = function (...objs) {
	  return Object.freeze(Object.assign({}, ...objs));
	};

	/**
	 * Utility function for updating an object with the properties of
	 * other objects.
	 *
	 * DEPRECATED: Just use Object.assign() instead!
	 *
	 * @param aTarget Object
	 *        The object being updated.
	 * @param aNewAttrs Object
	 *        The rest params are objects to update aTarget with. You
	 *        can pass as many as you like.
	 */
	exports.update = function update(target, ...args) {
	  for (let attrs of args) {
	    for (let key in attrs) {
	      let desc = Object.getOwnPropertyDescriptor(attrs, key);

	      if (desc) {
	        Object.defineProperty(target, key, desc);
	      }
	    }
	  }
	  return target;
	};

	/**
	 * Utility function for getting the values from an object as an array
	 *
	 * @param object Object
	 *        The object to iterate over
	 */
	exports.values = function values(object) {
	  return Object.keys(object).map(k => object[k]);
	};

	/**
	 * Report that |who| threw an exception, |exception|.
	 */
	exports.reportException = function reportException(who, exception) {
	  const msg = `${who} threw an exception: ${exports.safeErrorString(exception)}`;
	  (console.log)(msg + "\n");

	  if (typeof console !== "undefined" && console && console.error) {
	    console.error(msg);
	  }
	};

	/**
	 * Given a handler function that may throw, return an infallible handler
	 * function that calls the fallible handler, and logs any exceptions it
	 * throws.
	 *
	 * @param handler function
	 *      A handler function, which may throw.
	 * @param aName string
	 *      A name for handler, for use in error messages. If omitted, we use
	 *      handler.name.
	 *
	 * (SpiderMonkey does generate good names for anonymous functions, but we
	 * don't have a way to get at them from JavaScript at the moment.)
	 */
	exports.makeInfallible = function (handler, name = handler.name) {
	  return function (/* arguments */) {
	    try {
	      return handler.apply(this, arguments);
	    } catch (ex) {
	      let who = "Handler function";
	      if (name) {
	        who += " " + name;
	      }
	      exports.reportException(who, ex);
	      return undefined;
	    }
	  };
	};

	/**
	 * Turn the |error| into a string, without fail.
	 *
	 * @param {Error|any} error
	 */
	exports.safeErrorString = function (error) {
	  try {
	    let errorString = error.toString();
	    if (typeof errorString == "string") {
	      // Attempt to attach a stack to |errorString|. If it throws an error, or
	      // isn't a string, don't use it.
	      try {
	        if (error.stack) {
	          let stack = error.stack.toString();
	          if (typeof stack == "string") {
	            errorString += "\nStack: " + stack;
	          }
	        }
	      } catch (ee) { }

	      // Append additional line and column number information to the output,
	      // since it might not be part of the stringified error.
	      if (typeof error.lineNumber == "number" && typeof error.columnNumber == "number") {
	        errorString += "Line: " + error.lineNumber + ", column: " + error.columnNumber;
	      }

	      return errorString;
	    }
	  } catch (ee) { }

	  // We failed to find a good error description, so do the next best thing.
	  return Object.prototype.toString.call(error);
	};

	/**
	 * Interleaves two arrays element by element, returning the combined array, like
	 * a zip. In the case of arrays with different sizes, undefined values will be
	 * interleaved at the end along with the extra values of the larger array.
	 *
	 * @param Array a
	 * @param Array b
	 * @returns Array
	 *          The combined array, in the form [a1, b1, a2, b2, ...]
	 */
	exports.zip = function (a, b) {
	  if (!b) {
	    return a;
	  }
	  if (!a) {
	    return b;
	  }
	  const pairs = [];
	  for (let i = 0, aLength = a.length, bLength = b.length;
	       i < aLength || i < bLength;
	       i++) {
	    pairs.push([a[i], b[i]]);
	  }
	  return pairs;
	};

	/**
	 * Converts an object into an array with 2-element arrays as key/value
	 * pairs of the object. `{ foo: 1, bar: 2}` would become
	 * `[[foo, 1], [bar 2]]` (order not guaranteed).
	 *
	 * @param object obj
	 * @returns array
	 */
	exports.entries = function entries(obj) {
	  return Object.keys(obj).map(k => [k, obj[k]]);
	};

	/*
	 * Takes an array of 2-element arrays as key/values pairs and
	 * constructs an object using them.
	 */
	exports.toObject = function (arr) {
	  const obj = {};
	  for (let [k, v] of arr) {
	    obj[k] = v;
	  }
	  return obj;
	};

	/**
	 * Composes the given functions into a single function, which will
	 * apply the results of each function right-to-left, starting with
	 * applying the given arguments to the right-most function.
	 * `compose(foo, bar, baz)` === `args => foo(bar(baz(args)))`
	 *
	 * @param ...function funcs
	 * @returns function
	 */
	exports.compose = function compose(...funcs) {
	  return (...args) => {
	    const initialValue = funcs[funcs.length - 1](...args);
	    const leftFuncs = funcs.slice(0, -1);
	    return leftFuncs.reduceRight((composed, f) => f(composed),
	                                 initialValue);
	  };
	};

	/**
	 * Return true if `thing` is a generator function, false otherwise.
	 */
	exports.isGenerator = function (fn) {
	  if (typeof fn !== "function") {
	    return false;
	  }
	  let proto = Object.getPrototypeOf(fn);
	  if (!proto) {
	    return false;
	  }
	  let ctor = proto.constructor;
	  if (!ctor) {
	    return false;
	  }
	  return ctor.name == "GeneratorFunction";
	};

	/**
	 * Return true if `thing` is a Promise or then-able, false otherwise.
	 */
	exports.isPromise = function (p) {
	  return p && typeof p.then === "function";
	};

	/**
	 * Return true if `thing` is a SavedFrame, false otherwise.
	 */
	exports.isSavedFrame = function (thing) {
	  return Object.prototype.toString.call(thing) === "[object SavedFrame]";
	};

	/**
	 * Return true iff `thing` is a `Set` object (possibly from another global).
	 */
	exports.isSet = function (thing) {
	  return Object.prototype.toString.call(thing) === "[object Set]";
	};

	/**
	 * Given a list of lists, flatten it. Only flattens one level; does not
	 * recursively flatten all levels.
	 *
	 * @param {Array<Array<Any>>} lists
	 * @return {Array<Any>}
	 */
	exports.flatten = function (lists) {
	  return Array.prototype.concat.apply([], lists);
	};

	/**
	 * Returns a promise that is resolved or rejected when all promises have settled
	 * (resolved or rejected).
	 *
	 * This differs from Promise.all, which will reject immediately after the first
	 * rejection, instead of waiting for the remaining promises to settle.
	 *
	 * @param values
	 *        Iterable of promises that may be pending, resolved, or rejected. When
	 *        when all promises have settled (resolved or rejected), the returned
	 *        promise will be resolved or rejected as well.
	 *
	 * @return A new promise that is fulfilled when all values have settled
	 *         (resolved or rejected). Its resolution value will be an array of all
	 *         resolved values in the given order, or undefined if values is an
	 *         empty array. The reject reason will be forwarded from the first
	 *         promise in the list of given promises to be rejected.
	 */
	exports.settleAll = values => {
	  if (values === null || typeof (values[Symbol.iterator]) != "function") {
	    throw new Error("settleAll() expects an iterable.");
	  }

	  return new Promise((resolve, reject) => {
	    values = Array.isArray(values) ? values : [...values];
	    let countdown = values.length;
	    let resolutionValues = new Array(countdown);
	    let rejectionValue;
	    let rejectionOccurred = false;

	    if (!countdown) {
	      resolve(resolutionValues);
	      return deferred.promise;
	    }

	    function checkForCompletion() {
	      if (--countdown > 0) {
	        return;
	      }
	      if (!rejectionOccurred) {
	        resolve(resolutionValues);
	      } else {
	        reject(rejectionValue);
	      }
	    }

	    for (let i = 0; i < values.length; i++) {
	      let index = i;
	      let value = values[i];
	      let resolver = result => {
	        resolutionValues[index] = result;
	        checkForCompletion();
	      };
	      let rejecter = error => {
	        if (!rejectionOccurred) {
	          rejectionValue = error;
	          rejectionOccurred = true;
	        }
	        checkForCompletion();
	      };

	      if (value && typeof (value.then) == "function") {
	        value.then(resolver, rejecter);
	      } else {
	        // Given value is not a promise, forward it as a resolution value.
	        resolver(value);
	      }
	    }
	  });
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et: */
	/*
	 * Software License Agreement (BSD License)
	 *
	 * Copyright (c) 2007, Parakey Inc.
	 * All rights reserved.
	 *
	 * Redistribution and use of this software in source and binary forms,
	 * with or without modification, are permitted provided that the
	 * following conditions are met:
	 *
	 * * Redistributions of source code must retain the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer.
	 *
	 * * Redistributions in binary form must reproduce the above
	 *   copyright notice, this list of conditions and the
	 *   following disclaimer in the documentation and/or other
	 *   materials provided with the distribution.
	 *
	 * * Neither the name of Parakey Inc. nor the names of its
	 *   contributors may be used to endorse or promote products
	 *   derived from this software without specific prior
	 *   written permission of Parakey Inc.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
	 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
	 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
	 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
	 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
	 * OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	/*
	 * Creator:
	 *  Joe Hewitt
	 * Contributors
	 *  John J. Barton (IBM Almaden)
	 *  Jan Odvarko (Mozilla Corp.)
	 *  Max Stepanov (Aptana Inc.)
	 *  Rob Campbell (Mozilla Corp.)
	 *  Hans Hillen (Paciello Group, Mozilla)
	 *  Curtis Bartley (Mozilla Corp.)
	 *  Mike Collins (IBM Almaden)
	 *  Kevin Decker
	 *  Mike Ratcliffe (Comartis AG)
	 *  Hernan Rodríguez Colmeiro
	 *  Austin Andrews
	 *  Christoph Dorn
	 *  Steven Roussey (AppCenter Inc, Network54)
	 *  Mihai Sucan (Mozilla Corp.)
	 */

	"use strict";

	const {components, Cc, Ci} = __webpack_require__(9);
	({ lazyRequireGetter: () => {} }).lazyImporter(this, "NetUtil", "resource://gre/modules/NetUtil.jsm");
	const DevToolsUtils = __webpack_require__(8);
	const Services = __webpack_require__(1);

	// The cache used in the `nsIURL` function.
	const gNSURLStore = new Map();

	/**
	 * Helper object for networking stuff.
	 *
	 * Most of the following functions have been taken from the Firebug source. They
	 * have been modified to match the Firefox coding rules.
	 */
	var NetworkHelper = {
	  /**
	   * Converts text with a given charset to unicode.
	   *
	   * @param string text
	   *        Text to convert.
	   * @param string charset
	   *        Charset to convert the text to.
	   * @returns string
	   *          Converted text.
	   */
	  convertToUnicode: function (text, charset) {
	    let conv = Cc["@mozilla.org/intl/scriptableunicodeconverter"]
	        .createInstance(Ci.nsIScriptableUnicodeConverter);
	    try {
	      conv.charset = charset || "UTF-8";
	      return conv.ConvertToUnicode(text);
	    } catch (ex) {
	      return text;
	    }
	  },

	  /**
	   * Reads all available bytes from stream and converts them to charset.
	   *
	   * @param nsIInputStream stream
	   * @param string charset
	   * @returns string
	   *          UTF-16 encoded string based on the content of stream and charset.
	   */
	  readAndConvertFromStream: function (stream, charset) {
	    let text = null;
	    try {
	      text = NetUtil.readInputStreamToString(stream, stream.available());
	      return this.convertToUnicode(text, charset);
	    } catch (err) {
	      return text;
	    }
	  },

	   /**
	   * Reads the posted text from request.
	   *
	   * @param nsIHttpChannel request
	   * @param string charset
	   *        The content document charset, used when reading the POSTed data.
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from request
	   *          otherwise null.
	   */
	  readPostTextFromRequest: function (request, charset) {
	    if (request instanceof Ci.nsIUploadChannel) {
	      let iStream = request.uploadStream;

	      let isSeekableStream = false;
	      if (iStream instanceof Ci.nsISeekableStream) {
	        isSeekableStream = true;
	      }

	      let prevOffset;
	      if (isSeekableStream) {
	        prevOffset = iStream.tell();
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }

	      // Read data from the stream.
	      let text = this.readAndConvertFromStream(iStream, charset);

	      // Seek locks the file, so seek to the beginning only if necko hasn't
	      // read it yet, since necko doesn't seek to 0 before reading (at lest
	      // not till 459384 is fixed).
	      if (isSeekableStream && prevOffset == 0) {
	        iStream.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);
	      }
	      return text;
	    }
	    return null;
	  },

	  /**
	   * Reads the posted text from the page's cache.
	   *
	   * @param nsIDocShell docShell
	   * @param string charset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          docShell otherwise null.
	   */
	  readPostTextFromPage: function (docShell, charset) {
	    let webNav = docShell.QueryInterface(Ci.nsIWebNavigation);
	    return this.readPostTextFromPageViaWebNav(webNav, charset);
	  },

	  /**
	   * Reads the posted text from the page's cache, given an nsIWebNavigation
	   * object.
	   *
	   * @param nsIWebNavigation webNav
	   * @param string charset
	   * @returns string or null
	   *          Returns the posted string if it was possible to read from
	   *          webNav, otherwise null.
	   */
	  readPostTextFromPageViaWebNav: function (webNav, charset) {
	    if (webNav instanceof Ci.nsIWebPageDescriptor) {
	      let descriptor = webNav.currentDescriptor;

	      if (descriptor instanceof Ci.nsISHEntry && descriptor.postData &&
	          descriptor instanceof Ci.nsISeekableStream) {
	        descriptor.seek(Ci.nsISeekableStream.NS_SEEK_SET, 0);

	        return this.readAndConvertFromStream(descriptor, charset);
	      }
	    }
	    return null;
	  },

	  /**
	   * Gets the web appId that is associated with request.
	   *
	   * @param nsIHttpChannel request
	   * @returns number|null
	   *          The appId for the given request, if available.
	   */
	  getAppIdForRequest: function (request) {
	    try {
	      return this.getRequestLoadContext(request).appId;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },

	  /**
	   * Gets the topFrameElement that is associated with request. This
	   * works in single-process and multiprocess contexts. It may cross
	   * the content/chrome boundary.
	   *
	   * @param nsIHttpChannel request
	   * @returns nsIDOMElement|null
	   *          The top frame element for the given request.
	   */
	  getTopFrameForRequest: function (request) {
	    try {
	      return this.getRequestLoadContext(request).topFrameElement;
	    } catch (ex) {
	      // request loadContent is not always available.
	    }
	    return null;
	  },

	  /**
	   * Gets the nsIDOMWindow that is associated with request.
	   *
	   * @param nsIHttpChannel request
	   * @returns nsIDOMWindow or null
	   */
	  getWindowForRequest: function (request) {
	    try {
	      return this.getRequestLoadContext(request).associatedWindow;
	    } catch (ex) {
	      // TODO: bug 802246 - getWindowForRequest() throws on b2g: there is no
	      // associatedWindow property.
	    }
	    return null;
	  },

	  /**
	   * Gets the nsILoadContext that is associated with request.
	   *
	   * @param nsIHttpChannel request
	   * @returns nsILoadContext or null
	   */
	  getRequestLoadContext: function (request) {
	    try {
	      return request.notificationCallbacks.getInterface(Ci.nsILoadContext);
	    } catch (ex) {
	      // Ignore.
	    }

	    try {
	      return request.loadGroup.notificationCallbacks
	        .getInterface(Ci.nsILoadContext);
	    } catch (ex) {
	      // Ignore.
	    }

	    return null;
	  },

	  /**
	   * Determines whether the request has been made for the top level document.
	   *
	   * @param nsIHttpChannel request
	   * @returns Boolean True if the request represents the top level document.
	   */
	  isTopLevelLoad: function (request) {
	    if (request instanceof Ci.nsIChannel) {
	      let loadInfo = request.loadInfo;
	      if (loadInfo && loadInfo.isTopLevelLoad) {
	        return (request.loadFlags & Ci.nsIChannel.LOAD_DOCUMENT_URI);
	      }
	    }

	    return false;
	  },

	  /**
	   * Loads the content of url from the cache.
	   *
	   * @param string url
	   *        URL to load the cached content for.
	   * @param string charset
	   *        Assumed charset of the cached content. Used if there is no charset
	   *        on the channel directly.
	   * @param function callback
	   *        Callback that is called with the loaded cached content if available
	   *        or null if something failed while getting the cached content.
	   */
	  loadFromCache: function (url, charset, callback) {
	    let channel = NetUtil.newChannel({uri: url,
	                                      loadUsingSystemPrincipal: true});

	    // Ensure that we only read from the cache and not the server.
	    channel.loadFlags = Ci.nsIRequest.LOAD_FROM_CACHE |
	      Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
	      Ci.nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;

	    NetUtil.asyncFetch(
	      channel,
	      (inputStream, statusCode, request) => {
	        if (!components.isSuccessCode(statusCode)) {
	          callback(null);
	          return;
	        }

	        // Try to get the encoding from the channel. If there is none, then use
	        // the passed assumed charset.
	        let requestChannel = request.QueryInterface(Ci.nsIChannel);
	        let contentCharset = requestChannel.contentCharset || charset;

	        // Read the content of the stream using contentCharset as encoding.
	        callback(this.readAndConvertFromStream(inputStream, contentCharset));
	      });
	  },

	  /**
	   * Parse a raw Cookie header value.
	   *
	   * @param string header
	   *        The raw Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name and value.
	   */
	  parseCookieHeader: function (header) {
	    let cookies = header.split(";");
	    let result = [];

	    cookies.forEach(function (cookie) {
	      let equal = cookie.indexOf("=");
	      let name = cookie.substr(0, equal);
	      let value = cookie.substr(equal + 1);
	      result.push({name: unescape(name.trim()),
	                   value: unescape(value.trim())});
	    });

	    return result;
	  },

	  /**
	   * Parse a raw Set-Cookie header value.
	   *
	   * @param string header
	   *        The raw Set-Cookie header value.
	   * @return array
	   *         Array holding an object for each cookie. Each object holds the
	   *         following properties: name, value, secure (boolean), httpOnly
	   *         (boolean), path, domain and expires (ISO date string).
	   */
	  parseSetCookieHeader: function (header) {
	    let rawCookies = header.split(/\r\n|\n|\r/);
	    let cookies = [];

	    rawCookies.forEach(function (cookie) {
	      let equal = cookie.indexOf("=");
	      let name = unescape(cookie.substr(0, equal).trim());
	      let parts = cookie.substr(equal + 1).split(";");
	      let value = unescape(parts.shift().trim());

	      cookie = {name: name, value: value};

	      parts.forEach(function (part) {
	        part = part.trim();
	        if (part.toLowerCase() == "secure") {
	          cookie.secure = true;
	        } else if (part.toLowerCase() == "httponly") {
	          cookie.httpOnly = true;
	        } else if (part.indexOf("=") > -1) {
	          let pair = part.split("=");
	          pair[0] = pair[0].toLowerCase();
	          if (pair[0] == "path" || pair[0] == "domain") {
	            cookie[pair[0]] = pair[1];
	          } else if (pair[0] == "expires") {
	            try {
	              pair[1] = pair[1].replace(/-/g, " ");
	              cookie.expires = new Date(pair[1]).toISOString();
	            } catch (ex) {
	              // Ignore.
	            }
	          }
	        }
	      });

	      cookies.push(cookie);
	    });

	    return cookies;
	  },

	  // This is a list of all the mime category maps jviereck could find in the
	  // firebug code base.
	  mimeCategoryMap: {
	    "text/plain": "txt",
	    "text/html": "html",
	    "text/xml": "xml",
	    "text/xsl": "txt",
	    "text/xul": "txt",
	    "text/css": "css",
	    "text/sgml": "txt",
	    "text/rtf": "txt",
	    "text/x-setext": "txt",
	    "text/richtext": "txt",
	    "text/javascript": "js",
	    "text/jscript": "txt",
	    "text/tab-separated-values": "txt",
	    "text/rdf": "txt",
	    "text/xif": "txt",
	    "text/ecmascript": "js",
	    "text/vnd.curl": "txt",
	    "text/x-json": "json",
	    "text/x-js": "txt",
	    "text/js": "txt",
	    "text/vbscript": "txt",
	    "view-source": "txt",
	    "view-fragment": "txt",
	    "application/xml": "xml",
	    "application/xhtml+xml": "xml",
	    "application/atom+xml": "xml",
	    "application/rss+xml": "xml",
	    "application/vnd.mozilla.maybe.feed": "xml",
	    "application/vnd.mozilla.xul+xml": "xml",
	    "application/javascript": "js",
	    "application/x-javascript": "js",
	    "application/x-httpd-php": "txt",
	    "application/rdf+xml": "xml",
	    "application/ecmascript": "js",
	    "application/http-index-format": "txt",
	    "application/json": "json",
	    "application/x-js": "txt",
	    "application/x-mpegurl": "txt",
	    "application/vnd.apple.mpegurl": "txt",
	    "multipart/mixed": "txt",
	    "multipart/x-mixed-replace": "txt",
	    "image/svg+xml": "svg",
	    "application/octet-stream": "bin",
	    "image/jpeg": "image",
	    "image/jpg": "image",
	    "image/gif": "image",
	    "image/png": "image",
	    "image/bmp": "image",
	    "application/x-shockwave-flash": "flash",
	    "video/x-flv": "flash",
	    "audio/mpeg3": "media",
	    "audio/x-mpeg-3": "media",
	    "video/mpeg": "media",
	    "video/x-mpeg": "media",
	    "video/vnd.mpeg.dash.mpd": "xml",
	    "audio/ogg": "media",
	    "application/ogg": "media",
	    "application/x-ogg": "media",
	    "application/x-midi": "media",
	    "audio/midi": "media",
	    "audio/x-mid": "media",
	    "audio/x-midi": "media",
	    "music/crescendo": "media",
	    "audio/wav": "media",
	    "audio/x-wav": "media",
	    "text/json": "json",
	    "application/x-json": "json",
	    "application/json-rpc": "json",
	    "application/x-web-app-manifest+json": "json",
	    "application/manifest+json": "json"
	  },

	  /**
	   * Check if the given MIME type is a text-only MIME type.
	   *
	   * @param string mimeType
	   * @return boolean
	   */
	  isTextMimeType: function (mimeType) {
	    if (mimeType.indexOf("text/") == 0) {
	      return true;
	    }

	    // XML and JSON often come with custom MIME types, so in addition to the
	    // standard "application/xml" and "application/json", we also look for
	    // variants like "application/x-bigcorp+xml". For JSON we allow "+json" and
	    // "-json" as suffixes.
	    if (/^application\/\w+(?:[\.-]\w+)*(?:\+xml|[-+]json)$/.test(mimeType)) {
	      return true;
	    }

	    let category = this.mimeCategoryMap[mimeType] || null;
	    switch (category) {
	      case "txt":
	      case "js":
	      case "json":
	      case "css":
	      case "html":
	      case "svg":
	      case "xml":
	        return true;

	      default:
	        return false;
	    }
	  },

	  /**
	   * Takes a securityInfo object of nsIRequest, the nsIRequest itself and
	   * extracts security information from them.
	   *
	   * @param object securityInfo
	   *        The securityInfo object of a request. If null channel is assumed
	   *        to be insecure.
	   * @param object httpActivity
	   *        The httpActivity object for the request with at least members
	   *        { private, hostname }.
	   *
	   * @return object
	   *         Returns an object containing following members:
	   *          - state: The security of the connection used to fetch this
	   *                   request. Has one of following string values:
	   *                    * "insecure": the connection was not secure (only http)
	   *                    * "weak": the connection has minor security issues
	   *                    * "broken": secure connection failed (e.g. expired cert)
	   *                    * "secure": the connection was properly secured.
	   *          If state == broken:
	   *            - errorMessage: full error message from
	   *                            nsITransportSecurityInfo.
	   *          If state == secure:
	   *            - protocolVersion: one of TLSv1, TLSv1.1, TLSv1.2, TLSv1.3.
	   *            - cipherSuite: the cipher suite used in this connection.
	   *            - cert: information about certificate used in this connection.
	   *                    See parseCertificateInfo for the contents.
	   *            - hsts: true if host uses Strict Transport Security,
	   *                    false otherwise
	   *            - hpkp: true if host uses Public Key Pinning, false otherwise
	   *          If state == weak: Same as state == secure and
	   *            - weaknessReasons: list of reasons that cause the request to be
	   *                               considered weak. See getReasonsForWeakness.
	   */
	  parseSecurityInfo: function (securityInfo, httpActivity) {
	    const info = {
	      state: "insecure",
	    };

	    // The request did not contain any security info.
	    if (!securityInfo) {
	      return info;
	    }

	    /**
	     * Different scenarios to consider here and how they are handled:
	     * - request is HTTP, the connection is not secure
	     *   => securityInfo is null
	     *      => state === "insecure"
	     *
	     * - request is HTTPS, the connection is secure
	     *   => .securityState has STATE_IS_SECURE flag
	     *      => state === "secure"
	     *
	     * - request is HTTPS, the connection has security issues
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is an NSS error code.
	     *      => state === "broken"
	     *
	     * - request is HTTPS, the connection was terminated before the security
	     *   could be validated
	     *   => .securityState has STATE_IS_INSECURE flag
	     *   => .errorCode is NOT an NSS error code.
	     *   => .errorMessage is not available.
	     *      => state === "insecure"
	     *
	     * - request is HTTPS but it uses a weak cipher or old protocol, see
	     *   http://hg.mozilla.org/mozilla-central/annotate/def6ed9d1c1a/
	     *   security/manager/ssl/nsNSSCallbacks.cpp#l1233
	     * - request is mixed content (which makes no sense whatsoever)
	     *   => .securityState has STATE_IS_BROKEN flag
	     *   => .errorCode is NOT an NSS error code
	     *   => .errorMessage is not available
	     *      => state === "weak"
	     */

	    securityInfo.QueryInterface(Ci.nsITransportSecurityInfo);
	    securityInfo.QueryInterface(Ci.nsISSLStatusProvider);

	    const wpl = Ci.nsIWebProgressListener;
	    const NSSErrorsService = Cc["@mozilla.org/nss_errors_service;1"]
	                               .getService(Ci.nsINSSErrorsService);
	    const SSLStatus = securityInfo.SSLStatus;
	    if (!NSSErrorsService.isNSSErrorCode(securityInfo.errorCode)) {
	      const state = securityInfo.securityState;

	      let uri = null;
	      if (httpActivity.channel && httpActivity.channel.URI) {
	        uri = httpActivity.channel.URI;
	      }
	      if (uri && !uri.schemeIs("https") && !uri.schemeIs("wss")) {
	        // it is not enough to look at the transport security info -
	        // schemes other than https and wss are subject to
	        // downgrade/etc at the scheme level and should always be
	        // considered insecure
	        info.state = "insecure";
	      } else if (state & wpl.STATE_IS_SECURE) {
	        // The connection is secure if the scheme is sufficient
	        info.state = "secure";
	      } else if (state & wpl.STATE_IS_BROKEN) {
	        // The connection is not secure, there was no error but there's some
	        // minor security issues.
	        info.state = "weak";
	        info.weaknessReasons = this.getReasonsForWeakness(state);
	      } else if (state & wpl.STATE_IS_INSECURE) {
	        // This was most likely an https request that was aborted before
	        // validation. Return info as info.state = insecure.
	        return info;
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo",
	          "Security state " + state + " has no known STATE_IS_* flags.");
	        return info;
	      }

	      // Cipher suite.
	      info.cipherSuite = SSLStatus.cipherName;

	      // Protocol version.
	      info.protocolVersion =
	        this.formatSecurityProtocol(SSLStatus.protocolVersion);

	      // Certificate.
	      info.cert = this.parseCertificateInfo(SSLStatus.serverCert);

	      // HSTS and HPKP if available.
	      if (httpActivity.hostname) {
	        const sss = Cc["@mozilla.org/ssservice;1"]
	                      .getService(Ci.nsISiteSecurityService);

	        // SiteSecurityService uses different storage if the channel is
	        // private. Thus we must give isSecureHost correct flags or we
	        // might get incorrect results.
	        let flags = (httpActivity.private) ?
	                      Ci.nsISocketProvider.NO_PERMANENT_STORAGE : 0;

	        let host = httpActivity.hostname;

	        info.hsts = sss.isSecureHost(sss.HEADER_HSTS, host, flags);
	        info.hpkp = sss.isSecureHost(sss.HEADER_HPKP, host, flags);
	      } else {
	        DevToolsUtils.reportException("NetworkHelper.parseSecurityInfo",
	          "Could not get HSTS/HPKP status as hostname is not available.");
	        info.hsts = false;
	        info.hpkp = false;
	      }
	    } else {
	      // The connection failed.
	      info.state = "broken";
	      info.errorMessage = securityInfo.errorMessage;
	    }

	    return info;
	  },

	  /**
	   * Takes an nsIX509Cert and returns an object with certificate information.
	   *
	   * @param nsIX509Cert cert
	   *        The certificate to extract the information from.
	   * @return object
	   *         An object with following format:
	   *           {
	   *             subject: { commonName, organization, organizationalUnit },
	   *             issuer: { commonName, organization, organizationUnit },
	   *             validity: { start, end },
	   *             fingerprint: { sha1, sha256 }
	   *           }
	   */
	  parseCertificateInfo: function (cert) {
	    let info = {};
	    if (cert) {
	      info.subject = {
	        commonName: cert.commonName,
	        organization: cert.organization,
	        organizationalUnit: cert.organizationalUnit,
	      };

	      info.issuer = {
	        commonName: cert.issuerCommonName,
	        organization: cert.issuerOrganization,
	        organizationUnit: cert.issuerOrganizationUnit,
	      };

	      info.validity = {
	        start: cert.validity.notBeforeLocalDay,
	        end: cert.validity.notAfterLocalDay,
	      };

	      info.fingerprint = {
	        sha1: cert.sha1Fingerprint,
	        sha256: cert.sha256Fingerprint,
	      };
	    } else {
	      DevToolsUtils.reportException("NetworkHelper.parseCertificateInfo",
	        "Secure connection established without certificate.");
	    }

	    return info;
	  },

	  /**
	   * Takes protocolVersion of SSLStatus object and returns human readable
	   * description.
	   *
	   * @param Number version
	   *        One of nsISSLStatus version constants.
	   * @return string
	   *         One of TLSv1, TLSv1.1, TLSv1.2, TLSv1.3 if @param version
	   *         is valid, Unknown otherwise.
	   */
	  formatSecurityProtocol: function (version) {
	    switch (version) {
	      case Ci.nsISSLStatus.TLS_VERSION_1:
	        return "TLSv1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_1:
	        return "TLSv1.1";
	      case Ci.nsISSLStatus.TLS_VERSION_1_2:
	        return "TLSv1.2";
	      case Ci.nsISSLStatus.TLS_VERSION_1_3:
	        return "TLSv1.3";
	      default:
	        DevToolsUtils.reportException("NetworkHelper.formatSecurityProtocol",
	          "protocolVersion " + version + " is unknown.");
	        return "Unknown";
	    }
	  },

	  /**
	   * Takes the securityState bitfield and returns reasons for weak connection
	   * as an array of strings.
	   *
	   * @param Number state
	   *        nsITransportSecurityInfo.securityState.
	   *
	   * @return Array[String]
	   *         List of weakness reasons. A subset of { cipher } where
	   *         * cipher: The cipher suite is consireded to be weak (RC4).
	   */
	  getReasonsForWeakness: function (state) {
	    const wpl = Ci.nsIWebProgressListener;

	    // If there's non-fatal security issues the request has STATE_IS_BROKEN
	    // flag set. See http://hg.mozilla.org/mozilla-central/file/44344099d119
	    // /security/manager/ssl/nsNSSCallbacks.cpp#l1233
	    let reasons = [];

	    if (state & wpl.STATE_IS_BROKEN) {
	      let isCipher = state & wpl.STATE_USES_WEAK_CRYPTO;

	      if (isCipher) {
	        reasons.push("cipher");
	      }

	      if (!isCipher) {
	        DevToolsUtils.reportException("NetworkHelper.getReasonsForWeakness",
	          "STATE_IS_BROKEN without a known reason. Full state was: " + state);
	      }
	    }

	    return reasons;
	  },

	  /**
	   * Parse a url's query string into its components
	   *
	   * @param string queryString
	   *        The query part of a url
	   * @return array
	   *         Array of query params {name, value}
	   */
	  parseQueryString: function (queryString) {
	    // Make sure there's at least one param available.
	    // Be careful here, params don't necessarily need to have values, so
	    // no need to verify the existence of a "=".
	    if (!queryString) {
	      return null;
	    }

	    // Turn the params string into an array containing { name: value } tuples.
	    let paramsArray = queryString.replace(/^[?&]/, "").split("&").map(e => {
	      let param = e.split("=");
	      return {
	        name: param[0] ?
	          NetworkHelper.convertToUnicode(unescape(param[0])) : "",
	        value: param[1] ?
	          NetworkHelper.convertToUnicode(unescape(param[1])) : ""
	      };
	    });

	    return paramsArray;
	  },

	  /**
	   * Helper for getting an nsIURL instance out of a string.
	   */
	  nsIURL: function (url, store = gNSURLStore) {
	    if (store.has(url)) {
	      return store.get(url);
	    }

	    let uri = Services.io.newURI(url, null, null).QueryInterface(Ci.nsIURL);
	    store.set(url, uri);
	    return uri;
	  }
	};

	for (let prop of Object.getOwnPropertyNames(NetworkHelper)) {
	  exports[prop] = NetworkHelper[prop];
	}


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);
	const EventEmitter = __webpack_require__(6);
	const isOSX = Services.appinfo.OS === "Darwin";
	const {KeyCodes} = __webpack_require__(14);

	// List of electron keys mapped to DOM API (DOM_VK_*) key code
	const ElectronKeysMapping = {
	  "F1": "DOM_VK_F1",
	  "F2": "DOM_VK_F2",
	  "F3": "DOM_VK_F3",
	  "F4": "DOM_VK_F4",
	  "F5": "DOM_VK_F5",
	  "F6": "DOM_VK_F6",
	  "F7": "DOM_VK_F7",
	  "F8": "DOM_VK_F8",
	  "F9": "DOM_VK_F9",
	  "F10": "DOM_VK_F10",
	  "F11": "DOM_VK_F11",
	  "F12": "DOM_VK_F12",
	  "F13": "DOM_VK_F13",
	  "F14": "DOM_VK_F14",
	  "F15": "DOM_VK_F15",
	  "F16": "DOM_VK_F16",
	  "F17": "DOM_VK_F17",
	  "F18": "DOM_VK_F18",
	  "F19": "DOM_VK_F19",
	  "F20": "DOM_VK_F20",
	  "F21": "DOM_VK_F21",
	  "F22": "DOM_VK_F22",
	  "F23": "DOM_VK_F23",
	  "F24": "DOM_VK_F24",
	  "Space": "DOM_VK_SPACE",
	  "Backspace": "DOM_VK_BACK_SPACE",
	  "Delete": "DOM_VK_DELETE",
	  "Insert": "DOM_VK_INSERT",
	  "Return": "DOM_VK_RETURN",
	  "Enter": "DOM_VK_RETURN",
	  "Up": "DOM_VK_UP",
	  "Down": "DOM_VK_DOWN",
	  "Left": "DOM_VK_LEFT",
	  "Right": "DOM_VK_RIGHT",
	  "Home": "DOM_VK_HOME",
	  "End": "DOM_VK_END",
	  "PageUp": "DOM_VK_PAGE_UP",
	  "PageDown": "DOM_VK_PAGE_DOWN",
	  "Escape": "DOM_VK_ESCAPE",
	  "Esc": "DOM_VK_ESCAPE",
	  "Tab": "DOM_VK_TAB",
	  "VolumeUp": "DOM_VK_VOLUME_UP",
	  "VolumeDown": "DOM_VK_VOLUME_DOWN",
	  "VolumeMute": "DOM_VK_VOLUME_MUTE",
	  "PrintScreen": "DOM_VK_PRINTSCREEN",
	};

	/**
	 * Helper to listen for keyboard events decribed in .properties file.
	 *
	 * let shortcuts = new KeyShortcuts({
	 *   window
	 * });
	 * shortcuts.on("Ctrl+F", event => {
	 *   // `event` is the KeyboardEvent which relates to the key shortcuts
	 * });
	 *
	 * @param DOMWindow window
	 *        The window object of the document to listen events from.
	 * @param DOMElement target
	 *        Optional DOM Element on which we should listen events from.
	 *        If omitted, we listen for all events fired on `window`.
	 */
	function KeyShortcuts({ window, target }) {
	  this.window = window;
	  this.target = target || window;
	  this.keys = new Map();
	  this.eventEmitter = new EventEmitter();
	  this.target.addEventListener("keydown", this);
	}

	/*
	 * Parse an electron-like key string and return a normalized object which
	 * allow efficient match on DOM key event. The normalized object matches DOM
	 * API.
	 *
	 * @param DOMWindow window
	 *        Any DOM Window object, just to fetch its `KeyboardEvent` object
	 * @param String str
	 *        The shortcut string to parse, following this document:
	 *        https://github.com/electron/electron/blob/master/docs/api/accelerator.md
	 */
	KeyShortcuts.parseElectronKey = function (window, str) {
	  let modifiers = str.split("+");
	  let key = modifiers.pop();

	  let shortcut = {
	    ctrl: false,
	    meta: false,
	    alt: false,
	    shift: false,
	    // Set for character keys
	    key: undefined,
	    // Set for non-character keys
	    keyCode: undefined,
	  };
	  for (let mod of modifiers) {
	    if (mod === "Alt") {
	      shortcut.alt = true;
	    } else if (["Command", "Cmd"].includes(mod)) {
	      shortcut.meta = true;
	    } else if (["CommandOrControl", "CmdOrCtrl"].includes(mod)) {
	      if (isOSX) {
	        shortcut.meta = true;
	      } else {
	        shortcut.ctrl = true;
	      }
	    } else if (["Control", "Ctrl"].includes(mod)) {
	      shortcut.ctrl = true;
	    } else if (mod === "Shift") {
	      shortcut.shift = true;
	    } else {
	      console.error("Unsupported modifier:", mod, "from key:", str);
	      return null;
	    }
	  }

	  // Plus is a special case. It's a character key and shouldn't be matched
	  // against a keycode as it is only accessible via Shift/Capslock
	  if (key === "Plus") {
	    key = "+";
	  }

	  if (typeof key === "string" && key.length === 1) {
	    // Match any single character
	    shortcut.key = key.toLowerCase();
	  } else if (key in ElectronKeysMapping) {
	    // Maps the others manually to DOM API DOM_VK_*
	    key = ElectronKeysMapping[key];
	    shortcut.keyCode = KeyCodes[key];
	    // Used only to stringify the shortcut
	    shortcut.keyCodeString = key;
	    shortcut.key = key;
	  } else {
	    console.error("Unsupported key:", key);
	    return null;
	  }

	  return shortcut;
	};

	KeyShortcuts.stringify = function (shortcut) {
	  let list = [];
	  if (shortcut.alt) {
	    list.push("Alt");
	  }
	  if (shortcut.ctrl) {
	    list.push("Ctrl");
	  }
	  if (shortcut.meta) {
	    list.push("Cmd");
	  }
	  if (shortcut.shift) {
	    list.push("Shift");
	  }
	  let key;
	  if (shortcut.key) {
	    key = shortcut.key.toUpperCase();
	  } else {
	    key = shortcut.keyCodeString;
	  }
	  list.push(key);
	  return list.join("+");
	};

	KeyShortcuts.prototype = {
	  destroy() {
	    this.target.removeEventListener("keydown", this);
	    this.keys.clear();
	  },

	  doesEventMatchShortcut(event, shortcut) {
	    if (shortcut.meta != event.metaKey) {
	      return false;
	    }
	    if (shortcut.ctrl != event.ctrlKey) {
	      return false;
	    }
	    if (shortcut.alt != event.altKey) {
	      return false;
	    }
	    // Shift is a special modifier, it may implicitely be required if the
	    // expected key is a special character accessible via shift.
	    if (shortcut.shift != event.shiftKey && event.key &&
	        event.key.match(/[a-zA-Z]/)) {
	      return false;
	    }
	    if (shortcut.keyCode) {
	      return event.keyCode == shortcut.keyCode;
	    } else if (event.key in ElectronKeysMapping) {
	      return ElectronKeysMapping[event.key] === shortcut.key;
	    }

	    // get the key from the keyCode if key is not provided.
	    let key = event.key || String.fromCharCode(event.keyCode);

	    // For character keys, we match if the final character is the expected one.
	    // But for digits we also accept indirect match to please azerty keyboard,
	    // which requires Shift to be pressed to get digits.
	    return key.toLowerCase() == shortcut.key ||
	      (shortcut.key.match(/[0-9]/) &&
	       event.keyCode == shortcut.key.charCodeAt(0));
	  },

	  handleEvent(event) {
	    for (let [key, shortcut] of this.keys) {
	      if (this.doesEventMatchShortcut(event, shortcut)) {
	        this.eventEmitter.emit(key, event);
	      }
	    }
	  },

	  on(key, listener) {
	    if (typeof listener !== "function") {
	      throw new Error("KeyShortcuts.on() expects a function as " +
	                      "second argument");
	    }
	    if (!this.keys.has(key)) {
	      let shortcut = KeyShortcuts.parseElectronKey(this.window, key);
	      // The key string is wrong and we were unable to compute the key shortcut
	      if (!shortcut) {
	        return;
	      }
	      this.keys.set(key, shortcut);
	    }
	    this.eventEmitter.on(key, listener);
	  },

	  off(key, listener) {
	    this.eventEmitter.off(key, listener);
	  },
	};
	exports.KeyShortcuts = KeyShortcuts;


/***/ },
/* 14 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// This was copied (and slightly modified) from
	// devtools/shared/gcli/source/lib/gcli/util/util.js, which in turn
	// says:

	/**
	 * Keyboard handling is a mess. http://unixpapa.com/js/key.html
	 * It would be good to use DOM L3 Keyboard events,
	 * http://www.w3.org/TR/2010/WD-DOM-Level-3-Events-20100907/#events-keyboardevents
	 * however only Webkit supports them, and there isn't a shim on Modernizr:
	 * https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-browser-Polyfills
	 * and when the code that uses this KeyEvent was written, nothing was clear,
	 * so instead, we're using this unmodern shim:
	 * http://stackoverflow.com/questions/5681146/chrome-10-keyevent-or-something-similar-to-firefoxs-keyevent
	 * See BUG 664991: GCLI's keyboard handling should be updated to use DOM-L3
	 * https://bugzilla.mozilla.org/show_bug.cgi?id=664991
	 */

	exports.KeyCodes = {
	  DOM_VK_CANCEL: 3,
	  DOM_VK_HELP: 6,
	  DOM_VK_BACK_SPACE: 8,
	  DOM_VK_TAB: 9,
	  DOM_VK_CLEAR: 12,
	  DOM_VK_RETURN: 13,
	  DOM_VK_SHIFT: 16,
	  DOM_VK_CONTROL: 17,
	  DOM_VK_ALT: 18,
	  DOM_VK_PAUSE: 19,
	  DOM_VK_CAPS_LOCK: 20,
	  DOM_VK_ESCAPE: 27,
	  DOM_VK_SPACE: 32,
	  DOM_VK_PAGE_UP: 33,
	  DOM_VK_PAGE_DOWN: 34,
	  DOM_VK_END: 35,
	  DOM_VK_HOME: 36,
	  DOM_VK_LEFT: 37,
	  DOM_VK_UP: 38,
	  DOM_VK_RIGHT: 39,
	  DOM_VK_DOWN: 40,
	  DOM_VK_PRINTSCREEN: 44,
	  DOM_VK_INSERT: 45,
	  DOM_VK_DELETE: 46,
	  DOM_VK_0: 48,
	  DOM_VK_1: 49,
	  DOM_VK_2: 50,
	  DOM_VK_3: 51,
	  DOM_VK_4: 52,
	  DOM_VK_5: 53,
	  DOM_VK_6: 54,
	  DOM_VK_7: 55,
	  DOM_VK_8: 56,
	  DOM_VK_9: 57,
	  DOM_VK_SEMICOLON: 59,
	  DOM_VK_EQUALS: 61,
	  DOM_VK_A: 65,
	  DOM_VK_B: 66,
	  DOM_VK_C: 67,
	  DOM_VK_D: 68,
	  DOM_VK_E: 69,
	  DOM_VK_F: 70,
	  DOM_VK_G: 71,
	  DOM_VK_H: 72,
	  DOM_VK_I: 73,
	  DOM_VK_J: 74,
	  DOM_VK_K: 75,
	  DOM_VK_L: 76,
	  DOM_VK_M: 77,
	  DOM_VK_N: 78,
	  DOM_VK_O: 79,
	  DOM_VK_P: 80,
	  DOM_VK_Q: 81,
	  DOM_VK_R: 82,
	  DOM_VK_S: 83,
	  DOM_VK_T: 84,
	  DOM_VK_U: 85,
	  DOM_VK_V: 86,
	  DOM_VK_W: 87,
	  DOM_VK_X: 88,
	  DOM_VK_Y: 89,
	  DOM_VK_Z: 90,
	  DOM_VK_CONTEXT_MENU: 93,
	  DOM_VK_NUMPAD0: 96,
	  DOM_VK_NUMPAD1: 97,
	  DOM_VK_NUMPAD2: 98,
	  DOM_VK_NUMPAD3: 99,
	  DOM_VK_NUMPAD4: 100,
	  DOM_VK_NUMPAD5: 101,
	  DOM_VK_NUMPAD6: 102,
	  DOM_VK_NUMPAD7: 103,
	  DOM_VK_NUMPAD8: 104,
	  DOM_VK_NUMPAD9: 105,
	  DOM_VK_MULTIPLY: 106,
	  DOM_VK_ADD: 107,
	  DOM_VK_SEPARATOR: 108,
	  DOM_VK_SUBTRACT: 109,
	  DOM_VK_DECIMAL: 110,
	  DOM_VK_DIVIDE: 111,
	  DOM_VK_F1: 112,
	  DOM_VK_F2: 113,
	  DOM_VK_F3: 114,
	  DOM_VK_F4: 115,
	  DOM_VK_F5: 116,
	  DOM_VK_F6: 117,
	  DOM_VK_F7: 118,
	  DOM_VK_F8: 119,
	  DOM_VK_F9: 120,
	  DOM_VK_F10: 121,
	  DOM_VK_F11: 122,
	  DOM_VK_F12: 123,
	  DOM_VK_F13: 124,
	  DOM_VK_F14: 125,
	  DOM_VK_F15: 126,
	  DOM_VK_F16: 127,
	  DOM_VK_F17: 128,
	  DOM_VK_F18: 129,
	  DOM_VK_F19: 130,
	  DOM_VK_F20: 131,
	  DOM_VK_F21: 132,
	  DOM_VK_F22: 133,
	  DOM_VK_F23: 134,
	  DOM_VK_F24: 135,
	  DOM_VK_NUM_LOCK: 144,
	  DOM_VK_SCROLL_LOCK: 145,
	  DOM_VK_COMMA: 188,
	  DOM_VK_PERIOD: 190,
	  DOM_VK_SLASH: 191,
	  DOM_VK_BACK_QUOTE: 192,
	  DOM_VK_OPEN_BRACKET: 219,
	  DOM_VK_BACK_SLASH: 220,
	  DOM_VK_CLOSE_BRACKET: 221,
	  DOM_VK_QUOTE: 222,
	  DOM_VK_META: 224,

	  // A few that did not appear in gcli, but that are apparently used
	  // in devtools.
	  DOM_VK_COLON: 58,
	  DOM_VK_VOLUME_MUTE: 181,
	  DOM_VK_VOLUME_DOWN: 182,
	  DOM_VK_VOLUME_UP: 183,
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
	 * You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* eslint-disable spaced-comment */
	/* globals StopIteration */

	/**
	 * This module implements a subset of "Task.js" <http://taskjs.org/>.
	 * It is a copy of toolkit/modules/Task.jsm.  Please try not to
	 * diverge the API here.
	 *
	 * Paraphrasing from the Task.js site, tasks make sequential, asynchronous
	 * operations simple, using the power of JavaScript's "yield" operator.
	 *
	 * Tasks are built upon generator functions and promises, documented here:
	 *
	 * <https://developer.mozilla.org/en/JavaScript/Guide/Iterators_and_Generators>
	 * <http://wiki.commonjs.org/wiki/Promises/A>
	 *
	 * The "Task.spawn" function takes a generator function and starts running it as
	 * a task.  Every time the task yields a promise, it waits until the promise is
	 * fulfilled.  "Task.spawn" returns a promise that is resolved when the task
	 * completes successfully, or is rejected if an exception occurs.
	 *
	 * -----------------------------------------------------------------------------
	 *
	 * const {Task} = require("devtools/shared/task");
	 *
	 * Task.spawn(function* () {
	 *
	 *   // This is our task. Let's create a promise object, wait on it and capture
	 *   // its resolution value.
	 *   let myPromise = getPromiseResolvedOnTimeoutWithValue(1000, "Value");
	 *   let result = yield myPromise;
	 *
	 *   // This part is executed only after the promise above is fulfilled (after
	 *   // one second, in this imaginary example).  We can easily loop while
	 *   // calling asynchronous functions, and wait multiple times.
	 *   for (let i = 0; i < 3; i++) {
	 *     result += yield getPromiseResolvedOnTimeoutWithValue(50, "!");
	 *   }
	 *
	 *   return "Resolution result for the task: " + result;
	 * }).then(function (result) {
	 *
	 *   // result == "Resolution result for the task: Value!!!"
	 *
	 *   // The result is undefined if no value was returned.
	 *
	 * }, function (exception) {
	 *
	 *   // Failure!  We can inspect or report the exception.
	 *
	 * });
	 *
	 * -----------------------------------------------------------------------------
	 *
	 * This module implements only the "Task.js" interfaces described above, with no
	 * additional features to control the task externally, or do custom scheduling.
	 * It also provides the following extensions that simplify task usage in the
	 * most common cases:
	 *
	 * - The "Task.spawn" function also accepts an iterator returned by a generator
	 *   function, in addition to a generator function.  This way, you can call into
	 *   the generator function with the parameters you want, and with "this" bound
	 *   to the correct value.  Also, "this" is never bound to the task object when
	 *   "Task.spawn" calls the generator function.
	 *
	 * - In addition to a promise object, a task can yield the iterator returned by
	 *   a generator function.  The iterator is turned into a task automatically.
	 *   This reduces the syntax overhead of calling "Task.spawn" explicitly when
	 *   you want to recurse into other task functions.
	 *
	 * - The "Task.spawn" function also accepts a primitive value, or a function
	 *   returning a primitive value, and treats the value as the result of the
	 *   task.  This makes it possible to call an externally provided function and
	 *   spawn a task from it, regardless of whether it is an asynchronous generator
	 *   or a synchronous function.  This comes in handy when iterating over
	 *   function lists where some items have been converted to tasks and some not.
	 */

	////////////////////////////////////////////////////////////////////////////////
	//// Globals

	const Promise = __webpack_require__(4);
	const defer = __webpack_require__(5);

	// The following error types are considered programmer errors, which should be
	// reported (possibly redundantly) so as to let programmers fix their code.
	const ERRORS_TO_REPORT = ["EvalError", "RangeError", "ReferenceError",
	                          "TypeError"];

	/**
	 * The Task currently being executed
	 */
	var gCurrentTask = null;

	/**
	 * If `true`, capture stacks whenever entering a Task and rewrite the
	 * stack any exception thrown through a Task.
	 */
	var gMaintainStack = false;

	/**
	 * Iterate through the lines of a string.
	 *
	 * @return Iterator<string>
	 */
	function* linesOf(string) {
	  let reLine = /([^\r\n])+/g;
	  let match;
	  while ((match = reLine.exec(string))) {
	    yield [match[0], match.index];
	  }
	}

	/**
	 * Detect whether a value is a generator.
	 *
	 * @param aValue
	 *        The value to identify.
	 * @return A boolean indicating whether the value is a generator.
	 */
	function isGenerator(value) {
	  return Object.prototype.toString.call(value) == "[object Generator]";
	}

	////////////////////////////////////////////////////////////////////////////////
	//// Task

	/**
	 * This object provides the public module functions.
	 */
	var Task = {
	  /**
	   * Creates and starts a new task.
	   *
	   * @param task
	   *        - If you specify a generator function, it is called with no
	   *          arguments to retrieve the associated iterator.  The generator
	   *          function is a task, that is can yield promise objects to wait
	   *          upon.
	   *        - If you specify the iterator returned by a generator function you
	   *          called, the generator function is also executed as a task.  This
	   *          allows you to call the function with arguments.
	   *        - If you specify a function that is not a generator, it is called
	   *          with no arguments, and its return value is used to resolve the
	   *          returned promise.
	   *        - If you specify anything else, you get a promise that is already
	   *          resolved with the specified value.
	   *
	   * @return A promise object where you can register completion callbacks to be
	   *         called when the task terminates.
	   */
	  spawn: function (task) {
	    return createAsyncFunction(task).call(undefined);
	  },

	  /**
	   * Create and return an 'async function' that starts a new task.
	   *
	   * This is similar to 'spawn' except that it doesn't immediately start
	   * the task, it binds the task to the async function's 'this' object and
	   * arguments, and it requires the task to be a function.
	   *
	   * It simplifies the common pattern of implementing a method via a task,
	   * like this simple object with a 'greet' method that has a 'name' parameter
	   * and spawns a task to send a greeting and return its reply:
	   *
	   * let greeter = {
	   *   message: "Hello, NAME!",
	   *   greet: function(name) {
	   *     return Task.spawn((function* () {
	   *       return yield sendGreeting(this.message.replace(/NAME/, name));
	   *     }).bind(this);
	   *   })
	   * };
	   *
	   * With Task.async, the method can be declared succinctly:
	   *
	   * let greeter = {
	   *   message: "Hello, NAME!",
	   *   greet: Task.async(function* (name) {
	   *     return yield sendGreeting(this.message.replace(/NAME/, name));
	   *   })
	   * };
	   *
	   * While maintaining identical semantics:
	   *
	   * greeter.greet("Mitchell").then((reply) => { ... }); // behaves the same
	   *
	   * @param task
	   *        The task function to start.
	   *
	   * @return A function that starts the task function and returns its promise.
	   */
	  async: function (task) {
	    if (typeof (task) != "function") {
	      throw new TypeError("task argument must be a function");
	    }

	    return createAsyncFunction(task);
	  },

	  /**
	   * Constructs a special exception that, when thrown inside a legacy generator
	   * function (non-star generator), allows the associated task to be resolved
	   * with a specific value.
	   *
	   * Example: throw new Task.Result("Value");
	   */
	  Result: function (value) {
	    this.value = value;
	  }
	};

	function createAsyncFunction(task) {
	  let asyncFunction = function () {
	    let result = task;
	    if (task && typeof (task) == "function") {
	      if (task.isAsyncFunction) {
	        throw new TypeError(
	          "Cannot use an async function in place of a promise. " +
	          "You should either invoke the async function first " +
	          "or use 'Task.spawn' instead of 'Task.async' to start " +
	          "the Task and return its promise.");
	      }

	      try {
	        // Let's call into the function ourselves.
	        result = task.apply(this, arguments);
	      } catch (ex) {
	        if (ex instanceof Task.Result) {
	          return Promise.resolve(ex.value);
	        }
	        return Promise.reject(ex);
	      }
	    }

	    if (isGenerator(result)) {
	      // This is an iterator resulting from calling a generator function.
	      return new TaskImpl(result).deferred.promise;
	    }

	    // Just propagate the given value to the caller as a resolved promise.
	    return Promise.resolve(result);
	  };

	  asyncFunction.isAsyncFunction = true;

	  return asyncFunction;
	}

	////////////////////////////////////////////////////////////////////////////////
	//// TaskImpl

	/**
	 * Executes the specified iterator as a task, and gives access to the promise
	 * that is fulfilled when the task terminates.
	 */
	function TaskImpl(iterator) {
	  if (gMaintainStack) {
	    this._stack = (new Error()).stack;
	  }
	  this.deferred = defer();
	  this._iterator = iterator;
	  this._isStarGenerator = !("send" in iterator);
	  this._run(true);
	}

	TaskImpl.prototype = {
	  /**
	   * Includes the promise object where task completion callbacks are registered,
	   * and methods to resolve or reject the promise at task completion.
	   */
	  deferred: null,

	  /**
	   * The iterator returned by the generator function associated with this task.
	   */
	  _iterator: null,

	  /**
	   * Whether this Task is using a star generator.
	   */
	  _isStarGenerator: false,

	  /**
	   * Main execution routine, that calls into the generator function.
	   *
	   * @param sendResolved
	   *        If true, indicates that we should continue into the generator
	   *        function regularly (if we were waiting on a promise, it was
	   *        resolved). If true, indicates that we should cause an exception to
	   *        be thrown into the generator function (if we were waiting on a
	   *        promise, it was rejected).
	   * @param sendValue
	   *        Resolution result or rejection exception, if any.
	   */
	  _run: function (sendResolved, sendValue) {
	    try {
	      gCurrentTask = this;

	      if (this._isStarGenerator) {
	        try {
	          let result = sendResolved ? this._iterator.next(sendValue)
	                                    : this._iterator.throw(sendValue);

	          if (result.done) {
	            // The generator function returned.
	            this.deferred.resolve(result.value);
	          } else {
	            // The generator function yielded.
	            this._handleResultValue(result.value);
	          }
	        } catch (ex) {
	          // The generator function failed with an uncaught exception.
	          this._handleException(ex);
	        }
	      } else {
	        try {
	          let yielded = sendResolved ? this._iterator.send(sendValue)
	                                     : this._iterator.throw(sendValue);
	          this._handleResultValue(yielded);
	        } catch (ex) {
	          if (ex instanceof Task.Result) {
	            // The generator function threw the special exception that
	            // allows it to return a specific value on resolution.
	            this.deferred.resolve(ex.value);
	          } else if (ex instanceof StopIteration) {
	            // The generator function terminated with no specific result.
	            this.deferred.resolve(undefined);
	          } else {
	            // The generator function failed with an uncaught exception.
	            this._handleException(ex);
	          }
	        }
	      }
	    } finally {
	      //
	      // At this stage, the Task may have finished executing, or have
	      // walked through a `yield` or passed control to a sub-Task.
	      // Regardless, if we still own `gCurrentTask`, reset it. If we
	      // have not finished execution of this Task, re-entering `_run`
	      // will set `gCurrentTask` to `this` as needed.
	      //
	      // We just need to be careful here in case we hit the following
	      // pattern:
	      //
	      //   Task.spawn(foo);
	      //   Task.spawn(bar);
	      //
	      // Here, `foo` and `bar` may be interleaved, so when we finish
	      // executing `foo`, `gCurrentTask` may actually either `foo` or
	      // `bar`. If `gCurrentTask` has already been set to `bar`, leave
	      // it be and it will be reset to `null` once `bar` is complete.
	      //
	      if (gCurrentTask == this) {
	        gCurrentTask = null;
	      }
	    }
	  },

	  /**
	   * Handle a value yielded by a generator.
	   *
	   * @param value
	   *        The yielded value to handle.
	   */
	  _handleResultValue: function (value) {
	    // If our task yielded an iterator resulting from calling another
	    // generator function, automatically spawn a task from it, effectively
	    // turning it into a promise that is fulfilled on task completion.
	    if (isGenerator(value)) {
	      value = Task.spawn(value);
	    }

	    if (value && typeof (value.then) == "function") {
	      // We have a promise object now. When fulfilled, call again into this
	      // function to continue the task, with either a resolution or rejection
	      // condition.
	      value.then(this._run.bind(this, true),
	                  this._run.bind(this, false));
	    } else {
	      // If our task yielded a value that is not a promise, just continue and
	      // pass it directly as the result of the yield statement.
	      this._run(true, value);
	    }
	  },

	  /**
	   * Handle an uncaught exception thrown from a generator.
	   *
	   * @param exception
	   *        The uncaught exception to handle.
	   */
	  _handleException: function (exception) {
	    gCurrentTask = this;

	    if (exception && typeof exception == "object" && "stack" in exception) {
	      let stack = exception.stack;

	      if (gMaintainStack &&
	          exception._capturedTaskStack != this._stack &&
	          typeof stack == "string") {
	        // Rewrite the stack for more readability.

	        let bottomStack = this._stack;

	        stack = Task.Debugging.generateReadableStack(stack);

	        exception.stack = stack;

	        // If exception is reinjected in the same task and rethrown,
	        // we don't want to perform the rewrite again.
	        exception._capturedTaskStack = bottomStack;
	      } else if (!stack) {
	        stack = "Not available";
	      }

	      if ("name" in exception &&
	          ERRORS_TO_REPORT.indexOf(exception.name) != -1) {
	        // We suspect that the exception is a programmer error, so we now
	        // display it using dump().  Note that we do not use Cu.reportError as
	        // we assume that this is a programming error, so we do not want end
	        // users to see it. Also, if the programmer handles errors correctly,
	        // they will either treat the error or log them somewhere.

	        (console.log)("*************************\n");
	        (console.log)("A coding exception was thrown and uncaught in a Task.\n\n");
	        (console.log)("Full message: " + exception + "\n");
	        (console.log)("Full stack: " + exception.stack + "\n");
	        (console.log)("*************************\n");
	      }
	    }

	    this.deferred.reject(exception);
	  },

	  get callerStack() {
	    // Cut `this._stack` at the last line of the first block that
	    // contains task.js, keep the tail.
	    for (let [line, index] of linesOf(this._stack || "")) {
	      if (line.indexOf("/task.js:") == -1) {
	        return this._stack.substring(index);
	      }
	    }
	    return "";
	  }
	};

	Task.Debugging = {

	  /**
	   * Control stack rewriting.
	   *
	   * If `true`, any exception thrown from a Task will be rewritten to
	   * provide a human-readable stack trace. Otherwise, stack traces will
	   * be left unchanged.
	   *
	   * There is a (small but existing) runtime cost associated to stack
	   * rewriting, so you should probably not activate this in production
	   * code.
	   *
	   * @type {bool}
	   */
	  get maintainStack() {
	    return gMaintainStack;
	  },
	  set maintainStack(x) {
	    if (!x) {
	      gCurrentTask = null;
	    }
	    gMaintainStack = x;
	    return x;
	  },

	  /**
	   * Generate a human-readable stack for an error raised in
	   * a Task.
	   *
	   * @param {string} topStack The stack provided by the error.
	   * @param {string=} prefix Optionally, a prefix for each line.
	   */
	  generateReadableStack: function (topStack, prefix = "") {
	    if (!gCurrentTask) {
	      return topStack;
	    }

	    // Cut `topStack` at the first line that contains task.js, keep the head.
	    let lines = [];
	    for (let [line] of linesOf(topStack)) {
	      if (line.indexOf("/task.js:") != -1) {
	        break;
	      }
	      lines.push(prefix + line);
	    }
	    if (!prefix) {
	      lines.push(gCurrentTask.callerStack);
	    } else {
	      for (let [line] of linesOf(gCurrentTask.callerStack)) {
	        lines.push(prefix + line);
	      }
	    }

	    return lines.join("\n");
	  }
	};

	exports.Task = Task;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { FrontClassWithSpec, Front } = __webpack_require__(17);
	const { cssPropertiesSpec } = __webpack_require__(28);
	const { Task } = __webpack_require__(15);
	const { CSS_PROPERTIES_DB } = __webpack_require__(29);
	const { cssColors } = __webpack_require__(30);

	/**
	 * Build up a regular expression that matches a CSS variable token. This is an
	 * ident token that starts with two dashes "--".
	 *
	 * https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	 */
	var NON_ASCII = "[^\\x00-\\x7F]";
	var ESCAPE = "\\\\[^\n\r]";
	var FIRST_CHAR = ["[_a-z]", NON_ASCII, ESCAPE].join("|");
	var TRAILING_CHAR = ["[_a-z0-9-]", NON_ASCII, ESCAPE].join("|");
	var IS_VARIABLE_TOKEN = new RegExp(`^--(${FIRST_CHAR})(${TRAILING_CHAR})*$`,
	                                   "i");
	/**
	 * Check that this is a CSS variable.
	 *
	 * @param {String} input
	 * @return {Boolean}
	 */
	function isCssVariable(input) {
	  return !!input.match(IS_VARIABLE_TOKEN);
	}

	var cachedCssProperties = new WeakMap();

	/**
	 * The CssProperties front provides a mechanism to have a one-time asynchronous
	 * load of a CSS properties database. This is then fed into the CssProperties
	 * interface that provides synchronous methods for finding out what CSS
	 * properties the current server supports.
	 */
	const CssPropertiesFront = FrontClassWithSpec(cssPropertiesSpec, {
	  initialize: function (client, { cssPropertiesActor }) {
	    Front.prototype.initialize.call(this, client, {actor: cssPropertiesActor});
	    this.manage(this);
	  }
	});

	/**
	 * Ask questions to a CSS database. This class does not care how the database
	 * gets loaded in, only the questions that you can ask to it.
	 * Prototype functions are bound to 'this' so they can be passed around as helper
	 * functions.
	 *
	 * @param {Object} db
	 *                 A database of CSS properties
	 * @param {Object} inheritedList
	 *                 The key is the property name, the value is whether or not
	 *                 that property is inherited.
	 */
	function CssProperties(db) {
	  this.properties = db.properties;
	  this.pseudoElements = db.pseudoElements;

	  this.isKnown = this.isKnown.bind(this);
	  this.isInherited = this.isInherited.bind(this);
	  this.supportsType = this.supportsType.bind(this);
	}

	CssProperties.prototype = {
	  /**
	   * Checks to see if the property is known by the browser. This function has
	   * `this` already bound so that it can be passed around by reference.
	   *
	   * @param {String} property The property name to be checked.
	   * @return {Boolean}
	   */
	  isKnown(property) {
	    return !!this.properties[property] || isCssVariable(property);
	  },

	  /**
	   * Checks to see if the property is an inherited one.
	   *
	   * @param {String} property The property name to be checked.
	   * @return {Boolean}
	   */
	  isInherited(property) {
	    return this.properties[property] && this.properties[property].isInherited;
	  },

	  /**
	   * Checks if the property supports the given CSS type.
	   * CSS types should come from devtools/shared/css-properties-db.js' CSS_TYPES.
	   *
	   * @param {String} property The property to be checked.
	   * @param {Number} type One of the type values from CSS_TYPES.
	   * @return {Boolean}
	   */
	  supportsType(property, type) {
	    return this.properties[property] && this.properties[property].supports.includes(type);
	  },

	  /**
	   * Gets the CSS values for a given property name.
	   *
	   * @param {String} property The property to use.
	   * @return {Array} An array of strings.
	   */
	  getValues(property) {
	    return this.properties[property] ? this.properties[property].values : [];
	  },

	  /**
	   * Gets the CSS property names.
	   *
	   * @return {Array} An array of strings.
	   */
	  getNames(property) {
	    return Object.keys(this.properties);
	  }
	};

	/**
	 * Create a CssProperties object with a fully loaded CSS database. The
	 * CssProperties interface can be queried synchronously, but the initialization
	 * is potentially async and should be handled up-front when the tool is created.
	 *
	 * The front is returned only with this function so that it can be destroyed
	 * once the toolbox is destroyed.
	 *
	 * @param {Toolbox} The current toolbox.
	 * @returns {Promise} Resolves to {cssProperties, cssPropertiesFront}.
	 */
	const initCssProperties = Task.async(function* (toolbox) {
	  const client = toolbox.target.client;
	  if (cachedCssProperties.has(client)) {
	    return cachedCssProperties.get(client);
	  }

	  let db, front;

	  // Get the list dynamically if the cssProperties actor exists.
	  if (toolbox.target.hasActor("cssProperties")) {
	    front = CssPropertiesFront(client, toolbox.target.form);
	    const serverDB = yield front.getCSSDatabase(getClientBrowserVersion(toolbox));

	    // The serverDB will be blank if the browser versions match, so use the static list.
	    if (!serverDB.properties && !serverDB.margin) {
	      db = CSS_PROPERTIES_DB;
	    } else {
	      db = serverDB;
	    }
	  } else {
	    // The target does not support this actor, so require a static list of supported
	    // properties.
	    db = CSS_PROPERTIES_DB;
	  }

	  const cssProperties = new CssProperties(normalizeCssData(db));
	  cachedCssProperties.set(client, {cssProperties, front});
	  return {cssProperties, front};
	});

	/**
	 * Synchronously get a cached and initialized CssProperties.
	 *
	 * @param {Toolbox} The current toolbox.
	 * @returns {CssProperties}
	 */
	function getCssProperties(toolbox) {
	  if (!cachedCssProperties.has(toolbox.target.client)) {
	    throw new Error("The CSS database has not been initialized, please make " +
	                    "sure initCssDatabase was called once before for this " +
	                    "toolbox.");
	  }
	  return cachedCssProperties.get(toolbox.target.client).cssProperties;
	}

	/**
	 * Get a client-side CssProperties. This is useful for dependencies in tests, or parts
	 * of the codebase that don't particularly need to match every known CSS property on
	 * the target.
	 * @return {CssProperties}
	 */
	function getClientCssProperties() {
	  return new CssProperties(normalizeCssData(CSS_PROPERTIES_DB));
	}

	/**
	 * Get the current browser version.
	 * @returns {string} The browser version.
	 */
	function getClientBrowserVersion(toolbox) {
	  if (!toolbox._host) {
	    return "0";
	  }
	  const regexResult = toolbox._host.frame.contentWindow.navigator
	                             .userAgent.match(/Firefox\/(\d+)\.\d/);
	  return Array.isArray(regexResult) ? regexResult[1] : "0";
	}

	/**
	 * Even if the target has the cssProperties actor, the returned data may not be in the
	 * same shape or have all of the data we need. This normalizes the data and fills in
	 * any missing information like color values.
	 *
	 * @return {Object} The normalized CSS database.
	 */
	function normalizeCssData(db) {
	  if (db !== CSS_PROPERTIES_DB) {
	    // Firefox 49's getCSSDatabase() just returned the properties object, but
	    // now it returns an object with multiple types of CSS information.
	    if (!db.properties) {
	      db = { properties: db };
	    }

	    // Fill in any missing DB information from the static database.
	    db = Object.assign({}, CSS_PROPERTIES_DB, db);

	    // Add "supports" information to the css properties if it's missing.
	    if (!db.properties.color.supports) {
	      for (let name in db.properties) {
	        if (typeof CSS_PROPERTIES_DB.properties[name] === "object") {
	          db.properties[name].supports = CSS_PROPERTIES_DB.properties[name].supports;
	        }
	      }
	    }

	    // Add "values" information to the css properties if it's missing.
	    if (!db.properties.color.values) {
	      for (let name in db.properties) {
	        if (typeof CSS_PROPERTIES_DB.properties[name] === "object") {
	          db.properties[name].values = CSS_PROPERTIES_DB.properties[name].values;
	        }
	      }
	    }
	  }

	  reattachCssColorValues(db);

	  return db;
	}

	/**
	 * Color values are omitted to save on space. Add them back here.
	 * @param {Object} The CSS database.
	 */
	function reattachCssColorValues(db) {
	  if (db.properties.color.values[0] === "COLOR") {
	    const colors = Object.keys(cssColors);

	    for (let name in db.properties) {
	      const property = db.properties[name];
	      if (property.values[0] === "COLOR") {
	        property.values.shift();
	        property.values = property.values.concat(colors).sort();
	      }
	    }
	  }
	}

	module.exports = {
	  CssPropertiesFront,
	  CssProperties,
	  getCssProperties,
	  getClientCssProperties,
	  initCssProperties
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var promise = __webpack_require__(4);
	var defer = __webpack_require__(5);
	var {Class} = __webpack_require__(18);
	var {EventTarget} = __webpack_require__(20);
	var events = __webpack_require__(21);
	var object = __webpack_require__(25);
	var {getStack, callFunctionWithAsyncStack} = __webpack_require__(7);

	exports.emit = events.emit;

	/**
	 * Types: named marshallers/demarshallers.
	 *
	 * Types provide a 'write' function that takes a js representation and
	 * returns a protocol representation, and a "read" function that
	 * takes a protocol representation and returns a js representation.
	 *
	 * The read and write methods are also passed a context object that
	 * represent the actor or front requesting the translation.
	 *
	 * Types are referred to with a typestring.  Basic types are
	 * registered by name using addType, and more complex types can
	 * be generated by adding detail to the type name.
	 */

	var types = Object.create(null);
	exports.types = types;

	var registeredTypes = types.registeredTypes = new Map();
	var registeredLifetimes = types.registeredLifetimes = new Map();

	/**
	 * Return the type object associated with a given typestring.
	 * If passed a type object, it will be returned unchanged.
	 *
	 * Types can be registered with addType, or can be created on
	 * the fly with typestrings.  Examples:
	 *
	 *   boolean
	 *   threadActor
	 *   threadActor#detail
	 *   array:threadActor
	 *   array:array:threadActor#detail
	 *
	 * @param [typestring|type] type
	 *    Either a typestring naming a type or a type object.
	 *
	 * @returns a type object.
	 */
	types.getType = function (type) {
	  if (!type) {
	    return types.Primitive;
	  }

	  if (typeof (type) !== "string") {
	    return type;
	  }

	  // If already registered, we're done here.
	  let reg = registeredTypes.get(type);
	  if (reg) return reg;

	  // New type, see if it's a collection/lifetime type:
	  let sep = type.indexOf(":");
	  if (sep >= 0) {
	    let collection = type.substring(0, sep);
	    let subtype = types.getType(type.substring(sep + 1));

	    if (collection === "array") {
	      return types.addArrayType(subtype);
	    } else if (collection === "nullable") {
	      return types.addNullableType(subtype);
	    }

	    if (registeredLifetimes.has(collection)) {
	      return types.addLifetimeType(collection, subtype);
	    }

	    throw Error("Unknown collection type: " + collection);
	  }

	  // Not a collection, might be actor detail
	  let pieces = type.split("#", 2);
	  if (pieces.length > 1) {
	    return types.addActorDetail(type, pieces[0], pieces[1]);
	  }

	  // Might be a lazily-loaded type
	  if (type === "longstring") {
	    __webpack_require__(27);
	    return registeredTypes.get("longstring");
	  }

	  throw Error("Unknown type: " + type);
	};

	/**
	 * Don't allow undefined when writing primitive types to packets.  If
	 * you want to allow undefined, use a nullable type.
	 */
	function identityWrite(v) {
	  if (v === undefined) {
	    throw Error("undefined passed where a value is required");
	  }
	  // This has to handle iterator->array conversion because arrays of
	  // primitive types pass through here.
	  if (v && typeof (v) === "object" && Symbol.iterator in v) {
	    return [...v];
	  }
	  return v;
	}

	/**
	 * Add a type to the type system.
	 *
	 * When registering a type, you can provide `read` and `write` methods.
	 *
	 * The `read` method will be passed a JS object value from the JSON
	 * packet and must return a native representation.  The `write` method will
	 * be passed a native representation and should provide a JSONable value.
	 *
	 * These methods will both be passed a context.  The context is the object
	 * performing or servicing the request - on the server side it will be
	 * an Actor, on the client side it will be a Front.
	 *
	 * @param typestring name
	 *    Name to register
	 * @param object typeObject
	 *    An object whose properties will be stored in the type, including
	 *    the `read` and `write` methods.
	 * @param object options
	 *    Can specify `thawed` to prevent the type from being frozen.
	 *
	 * @returns a type object that can be used in protocol definitions.
	 */
	types.addType = function (name, typeObject = {}, options = {}) {
	  if (registeredTypes.has(name)) {
	    throw Error("Type '" + name + "' already exists.");
	  }

	  let type = object.merge({
	    toString() { return "[protocol type:" + name + "]";},
	    name: name,
	    primitive: !(typeObject.read || typeObject.write),
	    read: identityWrite,
	    write: identityWrite
	  }, typeObject);

	  registeredTypes.set(name, type);

	  return type;
	};

	/**
	 * Remove a type previously registered with the system.
	 * Primarily useful for types registered by addons.
	 */
	types.removeType = function (name) {
	  // This type may still be referenced by other types, make sure
	  // those references don't work.
	  let type = registeredTypes.get(name);

	  type.name = "DEFUNCT:" + name;
	  type.category = "defunct";
	  type.primitive = false;
	  type.read = type.write = function () { throw new Error("Using defunct type: " + name); };

	  registeredTypes.delete(name);
	};

	/**
	 * Add an array type to the type system.
	 *
	 * getType() will call this function if provided an "array:<type>"
	 * typestring.
	 *
	 * @param type subtype
	 *    The subtype to be held by the array.
	 */
	types.addArrayType = function (subtype) {
	  subtype = types.getType(subtype);

	  let name = "array:" + subtype.name;

	  // Arrays of primitive types are primitive types themselves.
	  if (subtype.primitive) {
	    return types.addType(name);
	  }
	  return types.addType(name, {
	    category: "array",
	    read: (v, ctx) => [...v].map(i => subtype.read(i, ctx)),
	    write: (v, ctx) => [...v].map(i => subtype.write(i, ctx))
	  });
	};

	/**
	 * Add a dict type to the type system.  This allows you to serialize
	 * a JS object that contains non-primitive subtypes.
	 *
	 * Properties of the value that aren't included in the specializations
	 * will be serialized as primitive values.
	 *
	 * @param object specializations
	 *    A dict of property names => type
	 */
	types.addDictType = function (name, specializations) {
	  return types.addType(name, {
	    category: "dict",
	    specializations: specializations,
	    read: (v, ctx) => {
	      let ret = {};
	      for (let prop in v) {
	        if (prop in specializations) {
	          ret[prop] = types.getType(specializations[prop]).read(v[prop], ctx);
	        } else {
	          ret[prop] = v[prop];
	        }
	      }
	      return ret;
	    },

	    write: (v, ctx) => {
	      let ret = {};
	      for (let prop in v) {
	        if (prop in specializations) {
	          ret[prop] = types.getType(specializations[prop]).write(v[prop], ctx);
	        } else {
	          ret[prop] = v[prop];
	        }
	      }
	      return ret;
	    }
	  });
	};

	/**
	 * Register an actor type with the type system.
	 *
	 * Types are marshalled differently when communicating server->client
	 * than they are when communicating client->server.  The server needs
	 * to provide useful information to the client, so uses the actor's
	 * `form` method to get a json representation of the actor.  When
	 * making a request from the client we only need the actor ID string.
	 *
	 * This function can be called before the associated actor has been
	 * constructed, but the read and write methods won't work until
	 * the associated addActorImpl or addActorFront methods have been
	 * called during actor/front construction.
	 *
	 * @param string name
	 *    The typestring to register.
	 */
	types.addActorType = function (name) {
	  let type = types.addType(name, {
	    _actor: true,
	    category: "actor",
	    read: (v, ctx, detail) => {
	      // If we're reading a request on the server side, just
	      // find the actor registered with this actorID.
	      if (ctx instanceof Actor) {
	        return ctx.conn.getActor(v);
	      }

	      // Reading a response on the client side, check for an
	      // existing front on the connection, and create the front
	      // if it isn't found.
	      let actorID = typeof (v) === "string" ? v : v.actor;
	      let front = ctx.conn.getActor(actorID);
	      if (!front) {
	        front = new type.frontClass(ctx.conn);
	        front.actorID = actorID;
	        ctx.marshallPool().manage(front);
	      }

	      v = type.formType(detail).read(v, front, detail);
	      front.form(v, detail, ctx);

	      return front;
	    },
	    write: (v, ctx, detail) => {
	      // If returning a response from the server side, make sure
	      // the actor is added to a parent object and return its form.
	      if (v instanceof Actor) {
	        if (!v.actorID) {
	          ctx.marshallPool().manage(v);
	        }
	        return type.formType(detail).write(v.form(detail), ctx, detail);
	      }

	      // Writing a request from the client side, just send the actor id.
	      return v.actorID;
	    },
	    formType: (detail) => {
	      if (!("formType" in type.actorSpec)) {
	        return types.Primitive;
	      }

	      let formAttr = "formType";
	      if (detail) {
	        formAttr += "#" + detail;
	      }

	      if (!(formAttr in type.actorSpec)) {
	        throw new Error("No type defined for " + formAttr);
	      }

	      return type.actorSpec[formAttr];
	    }
	  });
	  return type;
	};

	types.addNullableType = function (subtype) {
	  subtype = types.getType(subtype);
	  return types.addType("nullable:" + subtype.name, {
	    category: "nullable",
	    read: (value, ctx) => {
	      if (value == null) {
	        return value;
	      }
	      return subtype.read(value, ctx);
	    },
	    write: (value, ctx) => {
	      if (value == null) {
	        return value;
	      }
	      return subtype.write(value, ctx);
	    }
	  });
	};

	/**
	 * Register an actor detail type.  This is just like an actor type, but
	 * will pass a detail hint to the actor's form method during serialization/
	 * deserialization.
	 *
	 * This is called by getType() when passed an 'actorType#detail' string.
	 *
	 * @param string name
	 *   The typestring to register this type as.
	 * @param type actorType
	 *   The actor type you'll be detailing.
	 * @param string detail
	 *   The detail to pass.
	 */
	types.addActorDetail = function (name, actorType, detail) {
	  actorType = types.getType(actorType);
	  if (!actorType._actor) {
	    throw Error("Details only apply to actor types, tried to add detail '" + detail + "'' to " + actorType.name + "\n");
	  }
	  return types.addType(name, {
	    _actor: true,
	    category: "detail",
	    read: (v, ctx) => actorType.read(v, ctx, detail),
	    write: (v, ctx) => actorType.write(v, ctx, detail)
	  });
	};

	/**
	 * Register an actor lifetime.  This lets the type system find a parent
	 * actor that differs from the actor fulfilling the request.
	 *
	 * @param string name
	 *    The lifetime name to use in typestrings.
	 * @param string prop
	 *    The property of the actor that holds the parent that should be used.
	 */
	types.addLifetime = function (name, prop) {
	  if (registeredLifetimes.has(name)) {
	    throw Error("Lifetime '" + name + "' already registered.");
	  }
	  registeredLifetimes.set(name, prop);
	};

	/**
	 * Remove a previously-registered lifetime.  Useful for lifetimes registered
	 * in addons.
	 */
	types.removeLifetime = function (name) {
	  registeredLifetimes.delete(name);
	};

	/**
	 * Register a lifetime type.  This creates an actor type tied to the given
	 * lifetime.
	 *
	 * This is called by getType() when passed a '<lifetimeType>:<actorType>'
	 * typestring.
	 *
	 * @param string lifetime
	 *    A lifetime string previously regisered with addLifetime()
	 * @param type subtype
	 *    An actor type
	 */
	types.addLifetimeType = function (lifetime, subtype) {
	  subtype = types.getType(subtype);
	  if (!subtype._actor) {
	    throw Error("Lifetimes only apply to actor types, tried to apply lifetime '" + lifetime + "'' to " + subtype.name);
	  }
	  let prop = registeredLifetimes.get(lifetime);
	  return types.addType(lifetime + ":" + subtype.name, {
	    category: "lifetime",
	    read: (value, ctx) => subtype.read(value, ctx[prop]),
	    write: (value, ctx) => subtype.write(value, ctx[prop])
	  });
	};

	// Add a few named primitive types.
	types.Primitive = types.addType("primitive");
	types.String = types.addType("string");
	types.Number = types.addType("number");
	types.Boolean = types.addType("boolean");
	types.JSON = types.addType("json");

	/**
	 * Request/Response templates and generation
	 *
	 * Request packets are specified as json templates with
	 * Arg and Option placeholders where arguments should be
	 * placed.
	 *
	 * Reponse packets are also specified as json templates,
	 * with a RetVal placeholder where the return value should be
	 * placed.
	 */

	/**
	 * Placeholder for simple arguments.
	 *
	 * @param number index
	 *    The argument index to place at this position.
	 * @param type type
	 *    The argument should be marshalled as this type.
	 * @constructor
	 */
	var Arg = Class({
	  initialize: function (index, type) {
	    this.index = index;
	    this.type = types.getType(type);
	  },

	  write: function (arg, ctx) {
	    return this.type.write(arg, ctx);
	  },

	  read: function (v, ctx, outArgs) {
	    outArgs[this.index] = this.type.read(v, ctx);
	  },

	  describe: function () {
	    return {
	      _arg: this.index,
	      type: this.type.name,
	    };
	  }
	});
	exports.Arg = Arg;

	/**
	 * Placeholder for an options argument value that should be hoisted
	 * into the packet.
	 *
	 * If provided in a method specification:
	 *
	 *   { optionArg: Option(1)}
	 *
	 * Then arguments[1].optionArg will be placed in the packet in this
	 * value's place.
	 *
	 * @param number index
	 *    The argument index of the options value.
	 * @param type type
	 *    The argument should be marshalled as this type.
	 * @constructor
	 */
	var Option = Class({
	  extends: Arg,
	  initialize: function (index, type) {
	    Arg.prototype.initialize.call(this, index, type);
	  },

	  write: function (arg, ctx, name) {
	    // Ignore if arg is undefined or null; allow other falsy values
	    if (arg == undefined || arg[name] == undefined) {
	      return undefined;
	    }
	    let v = arg[name];
	    return this.type.write(v, ctx);
	  },
	  read: function (v, ctx, outArgs, name) {
	    if (outArgs[this.index] === undefined) {
	      outArgs[this.index] = {};
	    }
	    if (v === undefined) {
	      return;
	    }
	    outArgs[this.index][name] = this.type.read(v, ctx);
	  },

	  describe: function () {
	    return {
	      _option: this.index,
	      type: this.type.name,
	    };
	  }
	});

	exports.Option = Option;

	/**
	 * Placeholder for return values in a response template.
	 *
	 * @param type type
	 *    The return value should be marshalled as this type.
	 */
	var RetVal = Class({
	  initialize: function (type) {
	    this.type = types.getType(type);
	  },

	  write: function (v, ctx) {
	    return this.type.write(v, ctx);
	  },

	  read: function (v, ctx) {
	    return this.type.read(v, ctx);
	  },

	  describe: function () {
	    return {
	      _retval: this.type.name
	    };
	  }
	});

	exports.RetVal = RetVal;

	/* Template handling functions */

	/**
	 * Get the value at a given path, or undefined if not found.
	 */
	function getPath(obj, path) {
	  for (let name of path) {
	    if (!(name in obj)) {
	      return undefined;
	    }
	    obj = obj[name];
	  }
	  return obj;
	}

	/**
	 * Find Placeholders in the template and save them along with their
	 * paths.
	 */
	function findPlaceholders(template, constructor, path = [], placeholders = []) {
	  if (!template || typeof (template) != "object") {
	    return placeholders;
	  }

	  if (template instanceof constructor) {
	    placeholders.push({ placeholder: template, path: [...path] });
	    return placeholders;
	  }

	  for (let name in template) {
	    path.push(name);
	    findPlaceholders(template[name], constructor, path, placeholders);
	    path.pop();
	  }

	  return placeholders;
	}


	function describeTemplate(template) {
	  return JSON.parse(JSON.stringify(template, (key, value) => {
	    if (value.describe) {
	      return value.describe();
	    }
	    return value;
	  }));
	}

	/**
	 * Manages a request template.
	 *
	 * @param object template
	 *    The request template.
	 * @construcor
	 */
	var Request = Class({
	  initialize: function (template = {}) {
	    this.type = template.type;
	    this.template = template;
	    this.args = findPlaceholders(template, Arg);
	  },

	  /**
	   * Write a request.
	   *
	   * @param array fnArgs
	   *    The function arguments to place in the request.
	   * @param object ctx
	   *    The object making the request.
	   * @returns a request packet.
	   */
	  write: function (fnArgs, ctx) {
	    let str = JSON.stringify(this.template, (key, value) => {
	      if (value instanceof Arg) {
	        return value.write(value.index in fnArgs ? fnArgs[value.index] : undefined,
	                           ctx, key);
	      }
	      return value;
	    });
	    return JSON.parse(str);
	  },

	  /**
	   * Read a request.
	   *
	   * @param object packet
	   *    The request packet.
	   * @param object ctx
	   *    The object making the request.
	   * @returns an arguments array
	   */
	  read: function (packet, ctx) {
	    let fnArgs = [];
	    for (let templateArg of this.args) {
	      let arg = templateArg.placeholder;
	      let path = templateArg.path;
	      let name = path[path.length - 1];
	      arg.read(getPath(packet, path), ctx, fnArgs, name);
	    }
	    return fnArgs;
	  },

	  describe: function () { return describeTemplate(this.template); }
	});

	/**
	 * Manages a response template.
	 *
	 * @param object template
	 *    The response template.
	 * @construcor
	 */
	var Response = Class({
	  initialize: function (template = {}) {
	    this.template = template;
	    let placeholders = findPlaceholders(template, RetVal);
	    if (placeholders.length > 1) {
	      throw Error("More than one RetVal specified in response");
	    }
	    let placeholder = placeholders.shift();
	    if (placeholder) {
	      this.retVal = placeholder.placeholder;
	      this.path = placeholder.path;
	    }
	  },

	  /**
	   * Write a response for the given return value.
	   *
	   * @param val ret
	   *    The return value.
	   * @param object ctx
	   *    The object writing the response.
	   */
	  write: function (ret, ctx) {
	    return JSON.parse(JSON.stringify(this.template, function (key, value) {
	      if (value instanceof RetVal) {
	        return value.write(ret, ctx);
	      }
	      return value;
	    }));
	  },

	  /**
	   * Read a return value from the given response.
	   *
	   * @param object packet
	   *    The response packet.
	   * @param object ctx
	   *    The object reading the response.
	   */
	  read: function (packet, ctx) {
	    if (!this.retVal) {
	      return undefined;
	    }
	    let v = getPath(packet, this.path);
	    return this.retVal.read(v, ctx);
	  },

	  describe: function () { return describeTemplate(this.template); }
	});

	/**
	 * Actor and Front implementations
	 */

	/**
	 * A protocol object that can manage the lifetime of other protocol
	 * objects.
	 */
	var Pool = Class({
	  extends: EventTarget,

	  /**
	   * Pools are used on both sides of the connection to help coordinate
	   * lifetimes.
	   *
	   * @param optional conn
	   *   Either a DebuggerServerConnection or a DebuggerClient.  Must have
	   *   addActorPool, removeActorPool, and poolFor.
	   *   conn can be null if the subclass provides a conn property.
	   * @constructor
	   */
	  initialize: function (conn) {
	    if (conn) {
	      this.conn = conn;
	    }
	  },

	  /**
	   * Return the parent pool for this client.
	   */
	  parent: function () { return this.conn.poolFor(this.actorID); },

	  /**
	   * Override this if you want actors returned by this actor
	   * to belong to a different actor by default.
	   */
	  marshallPool: function () { return this; },

	  /**
	   * Pool is the base class for all actors, even leaf nodes.
	   * If the child map is actually referenced, go ahead and create
	   * the stuff needed by the pool.
	   */
	  __poolMap: null,
	  get _poolMap() {
	    if (this.__poolMap) return this.__poolMap;
	    this.__poolMap = new Map();
	    this.conn.addActorPool(this);
	    return this.__poolMap;
	  },

	  /**
	   * Add an actor as a child of this pool.
	   */
	  manage: function (actor) {
	    if (!actor.actorID) {
	      actor.actorID = this.conn.allocID(actor.actorPrefix || actor.typeName);
	    }

	    this._poolMap.set(actor.actorID, actor);
	    return actor;
	  },

	  /**
	   * Remove an actor as a child of this pool.
	   */
	  unmanage: function (actor) {
	    this.__poolMap && this.__poolMap.delete(actor.actorID);
	  },

	  // true if the given actor ID exists in the pool.
	  has: function (actorID) {
	    return this.__poolMap && this._poolMap.has(actorID);
	  },

	  // The actor for a given actor id stored in this pool
	  actor: function (actorID) {
	    return this.__poolMap ? this._poolMap.get(actorID) : null;
	  },

	  // Same as actor, should update debugger connection to use 'actor'
	  // and then remove this.
	  get: function (actorID) {
	    return this.__poolMap ? this._poolMap.get(actorID) : null;
	  },

	  // True if this pool has no children.
	  isEmpty: function () {
	    return !this.__poolMap || this._poolMap.size == 0;
	  },

	  /**
	   * Destroy this item, removing it from a parent if it has one,
	   * and destroying all children if necessary.
	   */
	  destroy: function () {
	    let parent = this.parent();
	    if (parent) {
	      parent.unmanage(this);
	    }
	    if (!this.__poolMap) {
	      return;
	    }
	    for (let actor of this.__poolMap.values()) {
	      // Self-owned actors are ok, but don't need destroying twice.
	      if (actor === this) {
	        continue;
	      }
	      let destroy = actor.destroy;
	      if (destroy) {
	        // Disconnect destroy while we're destroying in case of (misbehaving)
	        // circular ownership.
	        actor.destroy = null;
	        destroy.call(actor);
	        actor.destroy = destroy;
	      }
	    }
	    this.conn.removeActorPool(this, true);
	    this.__poolMap.clear();
	    this.__poolMap = null;
	  },

	  /**
	   * For getting along with the debugger server pools, should be removable
	   * eventually.
	   */
	  cleanup: function () {
	    this.destroy();
	  }
	});
	exports.Pool = Pool;

	/**
	 * An actor in the actor tree.
	 */
	var Actor = Class({
	  extends: Pool,

	  // Will contain the actor's ID
	  actorID: null,

	  /**
	   * Initialize an actor.
	   *
	   * @param optional conn
	   *   Either a DebuggerServerConnection or a DebuggerClient.  Must have
	   *   addActorPool, removeActorPool, and poolFor.
	   *   conn can be null if the subclass provides a conn property.
	   * @constructor
	   */
	  initialize: function (conn) {
	    Pool.prototype.initialize.call(this, conn);

	    // Forward events to the connection.
	    if (this._actorSpec && this._actorSpec.events) {
	      for (let key of this._actorSpec.events.keys()) {
	        let name = key;
	        let sendEvent = this._sendEvent.bind(this, name);
	        this.on(name, (...args) => {
	          sendEvent.apply(null, args);
	        });
	      }
	    }
	  },

	  toString: function () { return "[Actor " + this.typeName + "/" + this.actorID + "]"; },

	  _sendEvent: function (name, ...args) {
	    if (!this._actorSpec.events.has(name)) {
	      // It's ok to emit events that don't go over the wire.
	      return;
	    }
	    let request = this._actorSpec.events.get(name);
	    let packet;
	    try {
	      packet = request.write(args, this);
	    } catch (ex) {
	      console.error("Error sending event: " + name);
	      throw ex;
	    }
	    packet.from = packet.from || this.actorID;
	    this.conn.send(packet);
	  },

	  destroy: function () {
	    Pool.prototype.destroy.call(this);
	    this.actorID = null;
	  },

	  /**
	   * Override this method in subclasses to serialize the actor.
	   * @param [optional] string hint
	   *   Optional string to customize the form.
	   * @returns A jsonable object.
	   */
	  form: function (hint) {
	    return { actor: this.actorID };
	  },

	  writeError: function (error) {
	    console.error(error);
	    if (error.stack) {
	      (console.log)(error.stack);
	    }
	    this.conn.send({
	      from: this.actorID,
	      error: error.error || "unknownError",
	      message: error.message
	    });
	  },

	  _queueResponse: function (create) {
	    let pending = this._pendingResponse || promise.resolve(null);
	    let response = create(pending);
	    this._pendingResponse = response;
	  }
	});
	exports.Actor = Actor;

	/**
	 * Tags a prtotype method as an actor method implementation.
	 *
	 * @param function fn
	 *    The implementation function, will be returned.
	 * @param spec
	 *    The method specification, with the following (optional) properties:
	 *      request (object): a request template.
	 *      response (object): a response template.
	 *      oneway (bool): 'true' if no response should be sent.
	 */
	exports.method = function (fn, spec = {}) {
	  fn._methodSpec = Object.freeze(spec);
	  if (spec.request) Object.freeze(spec.request);
	  if (spec.response) Object.freeze(spec.response);
	  return fn;
	};

	/**
	 * Generates an actor specification from an actor description.
	 */
	var generateActorSpec = function (actorDesc) {
	  let actorSpec = {
	    typeName: actorDesc.typeName,
	    methods: []
	  };

	  // Find method and form specifications attached to properties.
	  for (let name of Object.getOwnPropertyNames(actorDesc)) {
	    let desc = Object.getOwnPropertyDescriptor(actorDesc, name);
	    if (!desc.value) {
	      continue;
	    }

	    if (name.startsWith("formType")) {
	      if (typeof (desc.value) === "string") {
	        actorSpec[name] = types.getType(desc.value);
	      } else if (desc.value.name && registeredTypes.has(desc.value.name)) {
	        actorSpec[name] = desc.value;
	      } else {
	        // Shorthand for a newly-registered DictType.
	        actorSpec[name] = types.addDictType(actorDesc.typeName + "__" + name, desc.value);
	      }
	    }

	    if (desc.value._methodSpec) {
	      let methodSpec = desc.value._methodSpec;
	      let spec = {};
	      spec.name = methodSpec.name || name;
	      spec.request = Request(object.merge({type: spec.name}, methodSpec.request || undefined));
	      spec.response = Response(methodSpec.response || undefined);
	      spec.release = methodSpec.release;
	      spec.oneway = methodSpec.oneway;

	      actorSpec.methods.push(spec);
	    }
	  }

	  // Find additional method specifications
	  if (actorDesc.methods) {
	    for (let name in actorDesc.methods) {
	      let methodSpec = actorDesc.methods[name];
	      let spec = {};

	      spec.name = methodSpec.name || name;
	      spec.request = Request(object.merge({type: spec.name}, methodSpec.request || undefined));
	      spec.response = Response(methodSpec.response || undefined);
	      spec.release = methodSpec.release;
	      spec.oneway = methodSpec.oneway;

	      actorSpec.methods.push(spec);
	    }
	  }

	  // Find event specifications
	  if (actorDesc.events) {
	    actorSpec.events = new Map();
	    for (let name in actorDesc.events) {
	      let eventRequest = actorDesc.events[name];
	      Object.freeze(eventRequest);
	      actorSpec.events.set(name, Request(object.merge({type: name}, eventRequest)));
	    }
	  }

	  if (!registeredTypes.has(actorSpec.typeName)) {
	    types.addActorType(actorSpec.typeName);
	  }
	  registeredTypes.get(actorSpec.typeName).actorSpec = actorSpec;

	  return actorSpec;
	};
	exports.generateActorSpec = generateActorSpec;

	/**
	 * Generates request handlers as described by the given actor specification on
	 * the given actor prototype. Returns the actor prototype.
	 */
	var generateRequestHandlers = function (actorSpec, actorProto) {
	  if (actorProto._actorSpec) {
	    throw new Error("actorProto called twice on the same actor prototype!");
	  }

	  actorProto.typeName = actorSpec.typeName;

	  // Generate request handlers for each method definition
	  actorProto.requestTypes = Object.create(null);
	  actorSpec.methods.forEach(spec => {
	    let handler = function (packet, conn) {
	      try {
	        let args;
	        try {
	          args = spec.request.read(packet, this);
	        } catch (ex) {
	          console.error("Error reading request: " + packet.type);
	          throw ex;
	        }

	        let ret = this[spec.name].apply(this, args);

	        let sendReturn = (ret) => {
	          if (spec.oneway) {
	            // No need to send a response.
	            return;
	          }

	          let response;
	          try {
	            response = spec.response.write(ret, this);
	          } catch (ex) {
	            console.error("Error writing response to: " + spec.name);
	            throw ex;
	          }
	          response.from = this.actorID;
	          // If spec.release has been specified, destroy the object.
	          if (spec.release) {
	            try {
	              this.destroy();
	            } catch (e) {
	              this.writeError(e);
	              return;
	            }
	          }

	          conn.send(response);
	        };

	        this._queueResponse(p => {
	          return p
	            .then(() => ret)
	            .then(sendReturn)
	            .then(null, this.writeError.bind(this));
	        });
	      } catch (e) {
	        this._queueResponse(p => {
	          return p.then(() => this.writeError(e));
	        });
	      }
	    };

	    actorProto.requestTypes[spec.request.type] = handler;
	  });

	  actorProto._actorSpec = actorSpec;

	  return actorProto;
	};

	/**
	 * THIS METHOD IS DEPRECATED, AND PRESERVED ONLY FOR ADD-ONS. IT SHOULD NOT BE
	 * USED INSIDE THE TREE.
	 *
	 * Create an actor class for the given actor prototype.
	 *
	 * @param object actorProto
	 *    The actor prototype.  Must have a 'typeName' property,
	 *    should have method definitions, can have event definitions.
	 */
	exports.ActorClass = function (actorProto) {
	  return ActorClassWithSpec(generateActorSpec(actorProto), actorProto);
	};

	/**
	 * THIS METHOD IS DEPRECATED, AND PRESERVED ONLY FOR ADD-ONS. IT SHOULD NOT BE
	 * USED INSIDE THE TREE.
	 *
	 * Create an actor class for the given actor specification and prototype.
	 *
	 * @param object actorSpec
	 *    The actor specification. Must have a 'typeName' property.
	 * @param object actorProto
	 *    The actor prototype. Should have method definitions, can have event
	 *    definitions.
	 */
	var ActorClassWithSpec = function (actorSpec, actorProto) {
	  if (!actorSpec.typeName) {
	    throw Error("Actor specification must have a typeName member.");
	  }

	  actorProto.extends = Actor;
	  let cls = Class(generateRequestHandlers(actorSpec, actorProto));

	  return cls;
	};
	exports.ActorClassWithSpec = ActorClassWithSpec;

	/**
	 * Base class for client-side actor fronts.
	 */
	var Front = Class({
	  extends: Pool,

	  actorID: null,

	  /**
	   * The base class for client-side actor fronts.
	   *
	   * @param optional conn
	   *   Either a DebuggerServerConnection or a DebuggerClient.  Must have
	   *   addActorPool, removeActorPool, and poolFor.
	   *   conn can be null if the subclass provides a conn property.
	   * @param optional form
	   *   The json form provided by the server.
	   * @constructor
	   */
	  initialize: function (conn = null, form = null, detail = null, context = null) {
	    Pool.prototype.initialize.call(this, conn);
	    this._requests = [];

	    // protocol.js no longer uses this data in the constructor, only external
	    // uses do.  External usage of manually-constructed fronts will be
	    // drastically reduced if we convert the root and tab actors to
	    // protocol.js, in which case this can probably go away.
	    if (form) {
	      this.actorID = form.actor;
	      form = types.getType(this.typeName).formType(detail).read(form, this, detail);
	      this.form(form, detail, context);
	    }
	  },

	  destroy: function () {
	    // Reject all outstanding requests, they won't make sense after
	    // the front is destroyed.
	    while (this._requests && this._requests.length > 0) {
	      let { deferred, to, type, stack } = this._requests.shift();
	      let msg = "Connection closed, pending request to " + to +
	                ", type " + type + " failed" +
	                "\n\nRequest stack:\n" + stack.formattedStack;
	      deferred.reject(new Error(msg));
	    }
	    Pool.prototype.destroy.call(this);
	    this.actorID = null;
	  },

	  manage: function (front) {
	    if (!front.actorID) {
	      throw new Error("Can't manage front without an actor ID.\n" +
	                      "Ensure server supports " + front.typeName + ".");
	    }
	    return Pool.prototype.manage.call(this, front);
	  },

	  /**
	   * @returns a promise that will resolve to the actorID this front
	   * represents.
	   */
	  actor: function () { return promise.resolve(this.actorID); },

	  toString: function () { return "[Front for " + this.typeName + "/" + this.actorID + "]"; },

	  /**
	   * Update the actor from its representation.
	   * Subclasses should override this.
	   */
	  form: function (form) {},

	  /**
	   * Send a packet on the connection.
	   */
	  send: function (packet) {
	    if (packet.to) {
	      this.conn._transport.send(packet);
	    } else {
	      this.actor().then(actorID => {
	        packet.to = actorID;
	        this.conn._transport.send(packet);
	      }).then(null, e => console.error(e));
	    }
	  },

	  /**
	   * Send a two-way request on the connection.
	   */
	  request: function (packet) {
	    let deferred = defer();
	    // Save packet basics for debugging
	    let { to, type } = packet;
	    this._requests.push({
	      deferred,
	      to: to || this.actorID,
	      type,
	      stack: getStack(),
	    });
	    this.send(packet);
	    return deferred.promise;
	  },

	  /**
	   * Handler for incoming packets from the client's actor.
	   */
	  onPacket: function (packet) {
	    // Pick off event packets
	    let type = packet.type || undefined;
	    if (this._clientSpec.events && this._clientSpec.events.has(type)) {
	      let event = this._clientSpec.events.get(packet.type);
	      let args;
	      try {
	        args = event.request.read(packet, this);
	      } catch (ex) {
	        console.error("Error reading event: " + packet.type);
	        console.exception(ex);
	        throw ex;
	      }
	      if (event.pre) {
	        let results = event.pre.map(pre => pre.apply(this, args));

	        // Check to see if any of the preEvents returned a promise -- if so,
	        // wait for their resolution before emitting. Otherwise, emit synchronously.
	        if (results.some(result => result && typeof result.then === "function")) {
	          promise.all(results).then(() => events.emit.apply(null, [this, event.name].concat(args)));
	          return;
	        }
	      }

	      events.emit.apply(null, [this, event.name].concat(args));
	      return;
	    }

	    // Remaining packets must be responses.
	    if (this._requests.length === 0) {
	      let msg = "Unexpected packet " + this.actorID + ", " + JSON.stringify(packet);
	      let err = Error(msg);
	      console.error(err);
	      throw err;
	    }

	    let { deferred, stack } = this._requests.shift();
	    callFunctionWithAsyncStack(() => {
	      if (packet.error) {
	        // "Protocol error" is here to avoid TBPL heuristics. See also
	        // https://dxr.mozilla.org/webtools-central/source/tbpl/php/inc/GeneralErrorFilter.php
	        let message;
	        if (packet.error && packet.message) {
	          message = "Protocol error (" + packet.error + "): " + packet.message;
	        } else {
	          message = packet.error;
	        }
	        deferred.reject(message);
	      } else {
	        deferred.resolve(packet);
	      }
	    }, stack, "DevTools RDP");
	  }
	});
	exports.Front = Front;

	/**
	 * A method tagged with preEvent will be called after recieving a packet
	 * for that event, and before the front emits the event.
	 */
	exports.preEvent = function (eventName, fn) {
	  fn._preEvent = eventName;
	  return fn;
	};

	/**
	 * Mark a method as a custom front implementation, replacing the generated
	 * front method.
	 *
	 * @param function fn
	 *    The front implementation, will be returned.
	 * @param object options
	 *    Options object:
	 *      impl (string): If provided, the generated front method will be
	 *        stored as this property on the prototype.
	 */
	exports.custom = function (fn, options = {}) {
	  fn._customFront = options;
	  return fn;
	};

	function prototypeOf(obj) {
	  return typeof (obj) === "function" ? obj.prototype : obj;
	}

	/**
	 * Generates request methods as described by the given actor specification on
	 * the given front prototype. Returns the front prototype.
	 */
	var generateRequestMethods = function (actorSpec, frontProto) {
	  if (frontProto._actorSpec) {
	    throw new Error("frontProto called twice on the same front prototype!");
	  }

	  frontProto.typeName = actorSpec.typeName;

	  // Generate request methods.
	  let methods = actorSpec.methods;
	  methods.forEach(spec => {
	    let name = spec.name;

	    // If there's already a property by this name in the front, it must
	    // be a custom front method.
	    if (name in frontProto) {
	      let custom = frontProto[spec.name]._customFront;
	      if (custom === undefined) {
	        throw Error("Existing method for " + spec.name + " not marked customFront while processing " + actorType.typeName + ".");
	      }
	      // If the user doesn't need the impl don't generate it.
	      if (!custom.impl) {
	        return;
	      }
	      name = custom.impl;
	    }

	    frontProto[name] = function (...args) {
	      let packet;
	      try {
	        packet = spec.request.write(args, this);
	      } catch (ex) {
	        console.error("Error writing request: " + name);
	        throw ex;
	      }
	      if (spec.oneway) {
	        // Fire-and-forget oneway packets.
	        this.send(packet);
	        return undefined;
	      }

	      return this.request(packet).then(response => {
	        let ret;
	        try {
	          ret = spec.response.read(response, this);
	        } catch (ex) {
	          console.error("Error reading response to: " + name);
	          throw ex;
	        }
	        return ret;
	      });
	    };

	    // Release methods should call the destroy function on return.
	    if (spec.release) {
	      let fn = frontProto[name];
	      frontProto[name] = function (...args) {
	        return fn.apply(this, args).then(result => {
	          this.destroy();
	          return result;
	        });
	      };
	    }
	  });


	  // Process event specifications
	  frontProto._clientSpec = {};

	  let events = actorSpec.events;
	  if (events) {
	    // This actor has events, scan the prototype for preEvent handlers...
	    let preHandlers = new Map();
	    for (let name of Object.getOwnPropertyNames(frontProto)) {
	      let desc = Object.getOwnPropertyDescriptor(frontProto, name);
	      if (!desc.value) {
	        continue;
	      }
	      if (desc.value._preEvent) {
	        let preEvent = desc.value._preEvent;
	        if (!events.has(preEvent)) {
	          throw Error("preEvent for event that doesn't exist: " + preEvent);
	        }
	        let handlers = preHandlers.get(preEvent);
	        if (!handlers) {
	          handlers = [];
	          preHandlers.set(preEvent, handlers);
	        }
	        handlers.push(desc.value);
	      }
	    }

	    frontProto._clientSpec.events = new Map();

	    for (let [name, request] of events) {
	      frontProto._clientSpec.events.set(request.type, {
	        name: name,
	        request: request,
	        pre: preHandlers.get(name)
	      });
	    }
	  }

	  frontProto._actorSpec = actorSpec;

	  return frontProto;
	};

	/**
	 * Create a front class for the given actor class and front prototype.
	 *
	 * @param ActorClass actorType
	 *    The actor class you're creating a front for.
	 * @param object frontProto
	 *    The front prototype.  Must have a 'typeName' property,
	 *    should have method definitions, can have event definitions.
	 */
	exports.FrontClass = function (actorType, frontProto) {
	  return FrontClassWithSpec(prototypeOf(actorType)._actorSpec, frontProto);
	};

	/**
	 * Create a front class for the given actor specification and front prototype.
	 *
	 * @param object actorSpec
	 *    The actor specification you're creating a front for.
	 * @param object proto
	 *    The object prototype.  Must have a 'typeName' property,
	 *    should have method definitions, can have event definitions.
	 */
	var FrontClassWithSpec = function (actorSpec, frontProto) {
	  frontProto.extends = Front;
	  let cls = Class(generateRequestMethods(actorSpec, frontProto));

	  if (!registeredTypes.has(actorSpec.typeName)) {
	    types.addActorType(actorSpec.typeName);
	  }
	  registeredTypes.get(actorSpec.typeName).frontClass = cls;

	  return cls;
	};
	exports.FrontClassWithSpec = FrontClassWithSpec;

	exports.dumpActorSpec = function (type) {
	  let actorSpec = type.actorSpec;
	  let ret = {
	    category: "actor",
	    typeName: type.name,
	    methods: [],
	    events: {}
	  };

	  for (let method of actorSpec.methods) {
	    ret.methods.push({
	      name: method.name,
	      release: method.release || undefined,
	      oneway: method.oneway || undefined,
	      request: method.request.describe(),
	      response: method.response.describe()
	    });
	  }

	  if (actorSpec.events) {
	    for (let [name, request] of actorSpec.events) {
	      ret.events[name] = request.describe();
	    }
	  }


	  JSON.stringify(ret);

	  return ret;
	};

	exports.dumpProtocolSpec = function () {
	  let ret = {
	    types: {},
	  };

	  for (let [name, type] of registeredTypes) {
	    // Force lazy instantiation if needed.
	    type = types.getType(name);
	    let category = type.category || undefined;
	    if (category === "dict") {
	      ret.types[name] = {
	        category: "dict",
	        typeName: name,
	        specializations: type.specializations
	      };
	    } else if (category === "actor") {
	      ret.types[name] = exports.dumpActorSpec(type);
	    }
	  }

	  return ret;
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	'use strict';

	module.metadata = {
	  "stability": "unstable"
	};

	var getPrototypeOf = Object.getPrototypeOf;
	var getNames = x => [...Object.getOwnPropertyNames(x),
	                     ...Object.getOwnPropertySymbols(x)];
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var create = Object.create;
	var freeze = Object.freeze;
	var unbind = Function.call.bind(Function.bind, Function.call);

	// This shortcut makes sure that we do perform desired operations, even if
	// associated methods have being overridden on the used object.
	var owns = unbind(Object.prototype.hasOwnProperty);
	var apply = unbind(Function.prototype.apply);
	var slice = Array.slice || unbind(Array.prototype.slice);
	var reduce = Array.reduce || unbind(Array.prototype.reduce);
	var map = Array.map || unbind(Array.prototype.map);
	var concat = Array.concat || unbind(Array.prototype.concat);

	// Utility function to get own properties descriptor map.
	function getOwnPropertyDescriptors(object) {
	  return reduce(getNames(object), function(descriptor, name) {
	    descriptor[name] = getOwnPropertyDescriptor(object, name);
	    return descriptor;
	  }, {});
	}

	function isDataProperty(property) {
	  var value = property.value;
	  var type = typeof(property.value);
	  return "value" in property &&
	         (type !== "object" || value === null) &&
	         type !== "function";
	}

	function getDataProperties(object) {
	  var properties = getOwnPropertyDescriptors(object);
	  return getNames(properties).reduce(function(result, name) {
	    var property = properties[name];
	    if (isDataProperty(property)) {
	      result[name] = {
	        value: property.value,
	        writable: true,
	        configurable: true,
	        enumerable: false
	      };
	    }
	    return result;
	  }, {})
	}

	/**
	 * Takes `source` object as an argument and returns identical object
	 * with the difference that all own properties will be non-enumerable
	 */
	function obscure(source) {
	  var descriptor = reduce(getNames(source), function(descriptor, name) {
	    var property = getOwnPropertyDescriptor(source, name);
	    property.enumerable = false;
	    descriptor[name] = property;
	    return descriptor;
	  }, {});
	  return create(getPrototypeOf(source), descriptor);
	}
	exports.obscure = obscure;

	/**
	 * Takes arbitrary number of source objects and returns fresh one, that
	 * inherits from the same prototype as a first argument and implements all
	 * own properties of all argument objects. If two or more argument objects
	 * have own properties with the same name, the property is overridden, with
	 * precedence from right to left, implying, that properties of the object on
	 * the left are overridden by a same named property of the object on the right.
	 */
	var mix = function(source) {
	  var descriptor = reduce(slice(arguments), function(descriptor, source) {
	    return reduce(getNames(source), function(descriptor, name) {
	      descriptor[name] = getOwnPropertyDescriptor(source, name);
	      return descriptor;
	    }, descriptor);
	  }, {});

	  return create(getPrototypeOf(source), descriptor);
	};
	exports.mix = mix;

	/**
	 * Returns a frozen object with that inherits from the given `prototype` and
	 * implements all own properties of the given `properties` object.
	 */
	function extend(prototype, properties) {
	  return create(prototype, getOwnPropertyDescriptors(properties));
	}
	exports.extend = extend;

	/**
	 * Returns a constructor function with a proper `prototype` setup. Returned
	 * constructor's `prototype` inherits from a given `options.extends` or
	 * `Class.prototype` if omitted and implements all the properties of the
	 * given `option`. If `options.implemens` array is passed, it's elements
	 * will be mixed into prototype as well. Also, `options.extends` can be
	 * a function or a prototype. If function than it's prototype is used as
	 * an ancestor of the prototype, if it's an object that it's used directly.
	 * Also `options.implements` may contain functions or objects, in case of
	 * functions their prototypes are used for mixing.
	 */
	var Class = new function() {
	  function prototypeOf(input) {
	    return typeof(input) === 'function' ? input.prototype : input;
	  }
	  var none = freeze([]);

	  return function Class(options) {
	    // Create descriptor with normalized `options.extends` and
	    // `options.implements`.
	    var descriptor = {
	      // Normalize extends property of `options.extends` to a prototype object
	      // in case it's constructor. If property is missing that fallback to
	      // `Type.prototype`.
	      extends: owns(options, 'extends') ?
	               prototypeOf(options.extends) : Class.prototype,
	      // Normalize `options.implements` to make sure that it's array of
	      // prototype objects instead of constructor functions.
	      implements: owns(options, 'implements') ?
	                  freeze(map(options.implements, prototypeOf)) : none
	    };

	    // Create array of property descriptors who's properties will be defined
	    // on the resulting prototype. Note: Using reflection `concat` instead of
	    // method as it may be overridden.
	    var descriptors = concat(descriptor.implements, options, descriptor, {
	      constructor: constructor
	    });

	    // Note: we use reflection `apply` in the constructor instead of method
	    // call since later may be overridden.
	    function constructor() {
	      var instance = create(prototype, attributes);
	      if (initialize) apply(initialize, instance, arguments);
	      return instance;
	    }
	    // Create `prototype` that inherits from given ancestor passed as
	    // `options.extends`, falling back to `Type.prototype`, implementing all
	    // properties of given `options.implements` and `options` itself.
	    var prototype = extend(descriptor.extends, mix.apply(mix, descriptors));
	    var initialize = prototype.initialize;

	    // Combine ancestor attributes with prototype's attributes so that
	    // ancestors attributes also become initializeable.
	    var attributes = mix(descriptor.extends.constructor.attributes || {},
	                         getDataProperties(prototype));

	    constructor.attributes = attributes;
	    Object.defineProperty(constructor, 'prototype', {
	      configurable: false,
	      writable: false,
	      value: prototype
	    });
	    return constructor;
	  };
	}
	Class.prototype = extend(null, obscure({
	  constructor: function constructor() {
	    this.initialize.apply(this, arguments);
	    return this;
	  },
	  initialize: function initialize() {
	    // Do your initialization logic here
	  },
	  // Copy useful properties from `Object.prototype`.
	  toString: Object.prototype.toString,
	  toLocaleString: Object.prototype.toLocaleString,
	  toSource: Object.prototype.toSource,
	  valueOf: Object.prototype.valueOf,
	  isPrototypeOf: Object.prototype.isPrototypeOf
	}));
	exports.Class = freeze(Class);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 19 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	'use strict';

	module.metadata = {
	  "stability": "stable"
	};

	const { on, once, off, setListeners } = __webpack_require__(21);
	const { method, chainable } = __webpack_require__(23);
	const { Class } = __webpack_require__(18);

	/**
	 * `EventTarget` is an exemplar for creating an objects that can be used to
	 * add / remove event listeners on them. Events on these objects may be emitted
	 * via `emit` function exported by 'event/core' module.
	 */
	const EventTarget = Class({
	  /**
	   * Method initializes `this` event source. It goes through properties of a
	   * given `options` and registers listeners for the ones that look like an
	   * event listeners.
	   */
	  /**
	   * Method initializes `this` event source. It goes through properties of a
	   * given `options` and registers listeners for the ones that look like an
	   * event listeners.
	   */
	  initialize: function initialize(options) {
	    setListeners(this, options);
	  },
	  /**
	   * Registers an event `listener` that is called every time events of
	   * specified `type` are emitted.
	   * @param {String} type
	   *    The type of event.
	   * @param {Function} listener
	   *    The listener function that processes the event.
	   * @example
	   *      worker.on('message', function (data) {
	   *        console.log('data received: ' + data)
	   *      })
	   */
	  on: chainable(method(on)),
	  /**
	   * Registers an event `listener` that is called once the next time an event
	   * of the specified `type` is emitted.
	   * @param {String} type
	   *    The type of the event.
	   * @param {Function} listener
	   *    The listener function that processes the event.
	   */
	  once: chainable(method(once)),
	  /**
	   * Removes an event `listener` for the given event `type`.
	   * @param {String} type
	   *    The type of event.
	   * @param {Function} listener
	   *    The listener function that processes the event.
	   */
	  removeListener: function removeListener(type, listener) {
	    // Note: We can't just wrap `off` in `method` as we do it for other methods
	    // cause skipping a second or third argument will behave very differently
	    // than intended. This way we make sure all arguments are passed and only
	    // one listener is removed at most.
	    off(this, type, listener);
	    return this;
	  },
	  // but we can wrap `off` here, as the semantics are the same
	  off: chainable(method(off))

	});
	exports.EventTarget = EventTarget;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const UNCAUGHT_ERROR = 'An error event was emitted for which there was no listener.';
	const BAD_LISTENER = 'The event listener must be a function.';

	const { ns } = __webpack_require__(22);

	const event = ns();

	const EVENT_TYPE_PATTERN = /^on([A-Z]\w+$)/;
	exports.EVENT_TYPE_PATTERN = EVENT_TYPE_PATTERN;

	// Utility function to access given event `target` object's event listeners for
	// the specific event `type`. If listeners for this type does not exists they
	// will be created.
	const observers = function observers(target, type) {
	  if (!target) throw TypeError("Event target must be an object");
	  let listeners = event(target);
	  return type in listeners ? listeners[type] : listeners[type] = [];
	};

	/**
	 * Registers an event `listener` that is called every time events of
	 * specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function on(target, type, listener) {
	  if (typeof(listener) !== 'function')
	    throw new Error(BAD_LISTENER);

	  let listeners = observers(target, type);
	  if (!~listeners.indexOf(listener))
	    listeners.push(listener);
	}
	exports.on = on;


	var onceWeakMap = new WeakMap();


	/**
	 * Registers an event `listener` that is called only the next time an event
	 * of the specified `type` is emitted on the given event `target`.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of the event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function once(target, type, listener) {
	  let replacement = function observer(...args) {
	    off(target, type, observer);
	    onceWeakMap.delete(listener);
	    listener.apply(target, args);
	  };
	  onceWeakMap.set(listener, replacement);
	  on(target, type, replacement);
	}
	exports.once = once;

	/**
	 * Execute each of the listeners in order with the supplied arguments.
	 * All the exceptions that are thrown by listeners during the emit
	 * are caught and can be handled by listeners of 'error' event. Thrown
	 * exceptions are passed as an argument to an 'error' event listener.
	 * If no 'error' listener is registered exception will be logged into an
	 * error console.
	 * @param {Object} target
	 *    Event target object.
	 * @param {String} type
	 *    The type of event.
	 * @params {Object|Number|String|Boolean} args
	 *    Arguments that will be passed to listeners.
	 */
	function emit (target, type, ...args) {
	  emitOnObject(target, type, target, ...args);
	}
	exports.emit = emit;

	/**
	 * A variant of emit that allows setting the this property for event listeners
	 */
	function emitOnObject(target, type, thisArg, ...args) {
	  let all = observers(target, '*').length;
	  let state = observers(target, type);
	  let listeners = state.slice();
	  let count = listeners.length;
	  let index = 0;

	  // If error event and there are no handlers (explicit or catch-all)
	  // then print error message to the console.
	  if (count === 0 && type === 'error' && all === 0)
	    console.exception(args[0]);
	  while (index < count) {
	    try {
	      let listener = listeners[index];
	      // Dispatch only if listener is still registered.
	      if (~state.indexOf(listener))
	        listener.apply(thisArg, args);
	    }
	    catch (error) {
	      // If exception is not thrown by a error listener and error listener is
	      // registered emit `error` event. Otherwise dump exception to the console.
	      if (type !== 'error') emit(target, 'error', error);
	      else console.exception(error);
	    }
	    index++;
	  }
	   // Also emit on `"*"` so that one could listen for all events.
	  if (type !== '*') emit(target, '*', type, ...args);
	}
	exports.emitOnObject = emitOnObject;

	/**
	 * Removes an event `listener` for the given event `type` on the given event
	 * `target`. If no `listener` is passed removes all listeners of the given
	 * `type`. If `type` is not passed removes all the listeners of the given
	 * event `target`.
	 * @param {Object} target
	 *    The event target object.
	 * @param {String} type
	 *    The type of event.
	 * @param {Function} listener
	 *    The listener function that processes the event.
	 */
	function off(target, type, listener) {
	  let length = arguments.length;
	  if (length === 3) {
	    if (onceWeakMap.has(listener)) {
	      listener = onceWeakMap.get(listener);
	      onceWeakMap.delete(listener);
	    }

	    let listeners = observers(target, type);
	    let index = listeners.indexOf(listener);
	    if (~index)
	      listeners.splice(index, 1);
	  }
	  else if (length === 2) {
	    observers(target, type).splice(0);
	  }
	  else if (length === 1) {
	    let listeners = event(target);
	    Object.keys(listeners).forEach(type => delete listeners[type]);
	  }
	}
	exports.off = off;

	/**
	 * Returns a number of event listeners registered for the given event `type`
	 * on the given event `target`.
	 */
	function count(target, type) {
	  return observers(target, type).length;
	}
	exports.count = count;

	/**
	 * Registers listeners on the given event `target` from the given `listeners`
	 * dictionary. Iterates over the listeners and if property name matches name
	 * pattern `onEventType` and property is a function, then registers it as
	 * an `eventType` listener on `target`.
	 *
	 * @param {Object} target
	 *    The type of event.
	 * @param {Object} listeners
	 *    Dictionary of listeners.
	 */
	function setListeners(target, listeners) {
	  Object.keys(listeners || {}).forEach(key => {
	    let match = EVENT_TYPE_PATTERN.exec(key);
	    let type = match && match[1].toLowerCase();
	    if (!type) return;

	    let listener = listeners[key];
	    if (typeof(listener) === 'function')
	      on(target, type, listener);
	  });
	}
	exports.setListeners = setListeners;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const create = Object.create;
	const prototypeOf = Object.getPrototypeOf;

	/**
	 * Returns a new namespace, function that may can be used to access an
	 * namespaced object of the argument argument. Namespaced object are associated
	 * with owner objects via weak references. Namespaced objects inherit from the
	 * owners ancestor namespaced object. If owner's ancestor is `null` then
	 * namespaced object inherits from given `prototype`. Namespaces can be used
	 * to define internal APIs that can be shared via enclosing `namespace`
	 * function.
	 * @examples
	 *    const internals = ns();
	 *    internals(object).secret = secret;
	 */
	function ns() {
	  const map = new WeakMap();
	  return function namespace(target) {
	    if (!target)        // If `target` is not an object return `target` itself.
	      return target;
	    // If target has no namespaced object yet, create one that inherits from
	    // the target prototype's namespaced object.
	    if (!map.has(target))
	      map.set(target, create(namespace(prototypeOf(target) || null)));

	    return map.get(target);
	  };
	};

	// `Namespace` is a e4x function in the scope, so we export the function also as
	// `ns` as alias to avoid clashing.
	exports.ns = ns;
	exports.Namespace = ns;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Disclaimer: Some of the functions in this module implement APIs from
	// Jeremy Ashkenas's http://underscorejs.org/ library and all credits for
	// those goes to him.

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	}
	const { arity, name, derive, invoke } = __webpack_require__(24);

	/**
	 * Takes variadic numeber of functions and returns composed one.
	 * Returned function pushes `this` pseudo-variable to the head
	 * of the passed arguments and invokes all the functions from
	 * left to right passing same arguments to them. Composite function
	 * returns return value of the right most funciton.
	 */
	const method = (...lambdas) => {
	  return function method(...args) {
	    args.unshift(this);
	    return lambdas.reduce((_, lambda) => lambda.apply(this, args),
	                          void(0));
	  };
	};
	exports.method = method;

	/**
	 * Invokes `callee` by passing `params` as an arguments and `self` as `this`
	 * pseudo-variable. Returns value that is returned by a callee.
	 * @param {Function} callee
	 *    Function to invoke.
	 * @param {Array} params
	 *    Arguments to invoke function with.
	 * @param {Object} self
	 *    Object to be passed as a `this` pseudo variable.
	 */
	exports.invoke = invoke;

	/**
	 * Takes a function and bind values to one or more arguments, returning a new
	 * function of smaller arity.
	 *
	 * @param {Function} fn
	 *    The function to partial
	 *
	 * @returns The new function with binded values
	 */
	const partial = (f, ...curried) => {
	  if (typeof(f) !== "function")
	    throw new TypeError(String(f) + " is not a function");

	  let fn = derive(function(...args) {
	    return f.apply(this, curried.concat(args));
	  }, f);
	  fn.arity = arity(f) - curried.length;
	  return fn;
	};
	exports.partial = partial;

	/**
	 * Returns function with implicit currying, which will continue currying until
	 * expected number of argument is collected. Expected number of arguments is
	 * determined by `fn.length`. Using this with variadic functions is stupid,
	 * so don't do it.
	 *
	 * @examples
	 *
	 * var sum = curry(function(a, b) {
	 *   return a + b
	 * })
	 * console.log(sum(2, 2)) // 4
	 * console.log(sum(2)(4)) // 6
	 */
	const curry = new function() {
	  const currier = (fn, arity, params) => {
	    // Function either continues to curry arguments or executes function
	    // if desired arguments have being collected.
	    const curried = function(...input) {
	      // Prepend all curried arguments to the given arguments.
	      if (params) input.unshift.apply(input, params);
	      // If expected number of arguments has being collected invoke fn,
	      // othrewise return curried version Otherwise continue curried.
	      return (input.length >= arity) ? fn.apply(this, input) :
	             currier(fn, arity, input);
	    };
	    curried.arity = arity - (params ? params.length : 0);

	    return curried;
	  };

	  return fn => currier(fn, arity(fn));
	};
	exports.curry = curry;

	/**
	 * Returns the composition of a list of functions, where each function consumes
	 * the return value of the function that follows. In math terms, composing the
	 * functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
	 * @example
	 *
	 *   var greet = function(name) { return "hi: " + name; };
	 *   var exclaim = function(statement) { return statement + "!"; };
	 *   var welcome = compose(exclaim, greet);
	 *
	 *   welcome('moe');    // => 'hi: moe!'
	 */
	function compose(...lambdas) {
	  return function composed(...args) {
	    let index = lambdas.length;
	    while (0 <= --index)
	      args = [lambdas[index].apply(this, args)];

	    return args[0];
	  };
	}
	exports.compose = compose;

	/*
	 * Returns the first function passed as an argument to the second,
	 * allowing you to adjust arguments, run code before and after, and
	 * conditionally execute the original function.
	 * @example
	 *
	 *  var hello = function(name) { return "hello: " + name; };
	 *  hello = wrap(hello, function(f) {
	 *    return "before, " + f("moe") + ", after";
	 *  });
	 *
	 *  hello();    // => 'before, hello: moe, after'
	 */
	const wrap = (f, wrapper) => derive(function wrapped(...args) {
	  return wrapper.apply(this, [f].concat(args));
	}, f);
	exports.wrap = wrap;

	/**
	 * Returns the same value that is used as the argument. In math: f(x) = x
	 */
	const identity = value => value;
	exports.identity = identity;

	/**
	 * Memoizes a given function by caching the computed result. Useful for
	 * speeding up slow-running computations. If passed an optional hashFunction,
	 * it will be used to compute the hash key for storing the result, based on
	 * the arguments to the original function. The default hashFunction just uses
	 * the first argument to the memoized function as the key.
	 */
	const memoize = (f, hasher) => {
	  let memo = Object.create(null);
	  let cache = new WeakMap();
	  hasher = hasher || identity;
	  return derive(function memoizer(...args) {
	    const key = hasher.apply(this, args);
	    const type = typeof(key);
	    if (key && (type === "object" || type === "function")) {
	      if (!cache.has(key))
	        cache.set(key, f.apply(this, args));
	      return cache.get(key);
	    }
	    else {
	      if (!(key in memo))
	        memo[key] = f.apply(this, args);
	      return memo[key];
	    }
	  }, f);
	};
	exports.memoize = memoize;

	/*
	 * Creates a version of the function that can only be called one time. Repeated
	 * calls to the modified function will have no effect, returning the value from
	 * the original call. Useful for initialization functions, instead of having to
	 * set a boolean flag and then check it later.
	 */
	const once = f => {
	  let ran = false, cache;
	  return derive(function(...args) {
	    return ran ? cache : (ran = true, cache = f.apply(this, args));
	  }, f);
	};
	exports.once = once;
	// export cache as once will may be conflicting with event once a lot.
	exports.cache = once;

	// Takes a `f` function and returns a function that takes the same
	// arguments as `f`, has the same effects, if any, and returns the
	// opposite truth value.
	const complement = f => derive(function(...args) {
	  return args.length < arity(f) ? complement(partial(f, ...args)) :
	         !f.apply(this, args);
	}, f);
	exports.complement = complement;

	// Constructs function that returns `x` no matter what is it
	// invoked with.
	const constant = x => _ => x;
	exports.constant = constant;

	// Takes `p` predicate, `consequent` function and an optional
	// `alternate` function and composes function that returns
	// application of arguments over `consequent` if application over
	// `p` is `true` otherwise returns application over `alternate`.
	// If `alternate` is not a function returns `undefined`.
	const when = (p, consequent, alternate) => {
	  if (typeof(alternate) !== "function" && alternate !== void(0))
	    throw TypeError("alternate must be a function");
	  if (typeof(consequent) !== "function")
	    throw TypeError("consequent must be a function");

	  return function(...args) {
	    return p.apply(this, args) ?
	           consequent.apply(this, args) :
	           alternate && alternate.apply(this, args);
	  };
	};
	exports.when = when;

	// Apply function that behaves as `apply` does in lisp:
	// apply(f, x, [y, z]) => f.apply(f, [x, y, z])
	// apply(f, x) => f.apply(f, [x])
	const apply = (f, ...rest) => f.apply(f, rest.concat(rest.pop()));
	exports.apply = apply;

	// Returns function identical to given `f` but with flipped order
	// of arguments.
	const flip = f => derive(function(...args) {
	  return f.apply(this, args.reverse());
	}, f);
	exports.flip = flip;

	// Takes field `name` and `target` and returns value of that field.
	// If `target` is `null` or `undefined` it would be returned back
	// instead of attempt to access it's field. Function is implicitly
	// curried, this allows accessor function generation by calling it
	// with only `name` argument.
	const field = curry((name, target) =>
	  // Note: Permisive `==` is intentional.
	  target == null ? target : target[name]);
	exports.field = field;

	// Takes `.` delimited string representing `path` to a nested field
	// and a `target` to get it from. For convinience function is
	// implicitly curried, there for accessors can be created by invoking
	// it with just a `path` argument.
	const query = curry((path, target) => {
	  const names = path.split(".");
	  const count = names.length;
	  let index = 0;
	  let result = target;
	  // Note: Permisive `!=` is intentional.
	  while (result != null && index < count) {
	    result = result[names[index]];
	    index = index + 1;
	  }
	  return result;
	});
	exports.query = query;

	// Takes `Type` (constructor function) and a `value` and returns
	// `true` if `value` is instance of the given `Type`. Function is
	// implicitly curried this allows predicate generation by calling
	// function with just first argument.
	const isInstance = curry((Type, value) => value instanceof Type);
	exports.isInstance = isInstance;

	/*
	 * Takes a funtion and returns a wrapped function that returns `this`
	 */
	const chainable = f => derive(function(...args) {
	  f.apply(this, args);
	  return this;
	}, f);
	exports.chainable = chainable;

	// Functions takes `expected` and `actual` values and returns `true` if
	// `expected === actual`. Returns curried function if called with less then
	// two arguments.
	//
	// [ 1, 0, 1, 0, 1 ].map(is(1)) // => [ true, false, true, false, true ]
	const is = curry((expected, actual) => actual === expected);
	exports.is = is;

	const isnt = complement(is);
	exports.isnt = isnt;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Disclaimer: Some of the functions in this module implement APIs from
	// Jeremy Ashkenas's http://underscorejs.org/ library and all credits for
	// those goes to him.

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	}

	const arity = f => f.arity || f.length;
	exports.arity = arity;

	const name = f => f.displayName || f.name;
	exports.name = name;

	const derive = (f, source) => {
	  f.displayName = name(source);
	  f.arity = arity(source);
	  return f;
	};
	exports.derive = derive;

	const invoke = (callee, params, self) => callee.apply(self, params);
	exports.invoke = invoke;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const { flatten } = __webpack_require__(26);

	/**
	 * Merges all the properties of all arguments into first argument. If two or
	 * more argument objects have own properties with the same name, the property
	 * is overridden, with precedence from right to left, implying, that properties
	 * of the object on the left are overridden by a same named property of the
	 * object on the right.
	 *
	 * Any argument given with "falsy" value - commonly `null` and `undefined` in
	 * case of objects - are skipped.
	 *
	 * @examples
	 *    var a = { bar: 0, a: 'a' }
	 *    var b = merge(a, { foo: 'foo', bar: 1 }, { foo: 'bar', name: 'b' });
	 *    b === a   // true
	 *    b.a       // 'a'
	 *    b.foo     // 'bar'
	 *    b.bar     // 1
	 *    b.name    // 'b'
	 */
	function merge(source) {
	  let descriptor = {};

	  // `Boolean` converts the first parameter to a boolean value. Any object is
	  // converted to `true` where `null` and `undefined` becames `false`. Therefore
	  // the `filter` method will keep only objects that are defined and not null.
	  Array.slice(arguments, 1).filter(Boolean).forEach(function onEach(properties) {
	    getOwnPropertyIdentifiers(properties).forEach(function(name) {
	      descriptor[name] = Object.getOwnPropertyDescriptor(properties, name);
	    });
	  });
	  return Object.defineProperties(source, descriptor);
	}
	exports.merge = merge;

	/**
	 * Returns an object that inherits from the first argument and contains all the
	 * properties from all following arguments.
	 * `extend(source1, source2, source3)` is equivalent of
	 * `merge(Object.create(source1), source2, source3)`.
	 */
	function extend(source) {
	  let rest = Array.slice(arguments, 1);
	  rest.unshift(Object.create(source));
	  return merge.apply(null, rest);
	}
	exports.extend = extend;

	function has(obj, key) {
	  return obj.hasOwnProperty(key);
	}
	exports.has = has;

	function each(obj, fn) {
	  for (let key in obj) has(obj, key) && fn(obj[key], key, obj);
	}
	exports.each = each;

	/**
	 * Like `merge`, except no property descriptors are manipulated, for use
	 * with platform objects. Identical to underscore's `extend`. Useful for
	 * merging XPCOM objects
	 */
	function safeMerge(source) {
	  Array.slice(arguments, 1).forEach(function onEach (obj) {
	    for (let prop in obj) source[prop] = obj[prop];
	  });
	  return source;
	}
	exports.safeMerge = safeMerge;

	/*
	 * Returns a copy of the object without omitted properties
	 */
	function omit(source, ...values) {
	  let copy = {};
	  let keys = flatten(values);
	  for (let prop in source)
	    if (!~keys.indexOf(prop))
	      copy[prop] = source[prop];
	  return copy;
	}
	exports.omit = omit;

	// get object's own property Symbols and/or Names, including nonEnumerables by default
	function getOwnPropertyIdentifiers(object, options = { names: true, symbols: true, nonEnumerables: true }) {
	  const symbols = !options.symbols ? [] :
	                  Object.getOwnPropertySymbols(object);
	  const names = !options.names ? [] :
	                options.nonEnumerables ? Object.getOwnPropertyNames(object) :
	                Object.keys(object);
	  return [...names, ...symbols];
	}
	exports.getOwnPropertyIdentifiers = getOwnPropertyIdentifiers;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "experimental"
	};

	/**
	 * Returns `true` if given `array` contain given `element` or `false`
	 * otherwise.
	 * @param {Array} array
	 *    Target array.
	 * @param {Object|String|Number|Boolean} element
	 *    Element being looked up.
	 * @returns {Boolean}
	 */
	var has = exports.has = function has(array, element) {
	  // shorter and faster equivalent of `array.indexOf(element) >= 0`
	  return !!~array.indexOf(element);
	};
	var hasAny = exports.hasAny = function hasAny(array, elements) {
	  if (arguments.length < 2)
	    return false;
	  if (!Array.isArray(elements))
	    elements = [ elements ];
	  return array.some(function (element) {
	      return has(elements, element);
	  });
	};

	/**
	 * Adds given `element` to the given `array` if it does not contain it yet.
	 * `true` is returned if element was added otherwise `false` is returned.
	 * @param {Array} array
	 *    Target array.
	 * @param {Object|String|Number|Boolean} element
	 *    Element to be added.
	 * @returns {Boolean}
	 */
	var add = exports.add = function add(array, element) {
	  var result;
	  if ((result = !has(array, element)))
	    array.push(element);

	  return result;
	};

	/**
	 * Removes first occurrence of the given `element` from the given `array`. If
	 * `array` does not contain given `element` `false` is returned otherwise
	 * `true` is returned.
	 * @param {Array} array
	 *    Target array.
	 * @param {Object|String|Number|Boolean} element
	 *    Element to be removed.
	 * @returns {Boolean}
	 */
	exports.remove = function remove(array, element) {
	  var result;
	  if ((result = has(array, element)))
	    array.splice(array.indexOf(element), 1);

	  return result;
	};

	/**
	 * Produces a duplicate-free version of the given `array`.
	 * @param {Array} array
	 *    Source array.
	 * @returns {Array}
	 */
	function unique(array) {
	  return array.reduce(function(result, item) {
	    add(result, item);
	    return result;
	  }, []);
	};
	exports.unique = unique;

	/**
	 * Produce an array that contains the union: each distinct element from all
	 * of the passed-in arrays.
	 */
	function union() {
	  return unique(Array.concat.apply(null, arguments));
	};
	exports.union = union;

	exports.flatten = function flatten(array){
	   var flat = [];
	   for (var i = 0, l = array.length; i < l; i++) {
	    flat = flat.concat(Array.isArray(array[i]) ? flatten(array[i]) : array[i]);
	   }
	   return flat;
	};

	function fromIterator(iterator) {
	  let array = [];
	  if (iterator.__iterator__) {
	    for (let item of iterator)
	      array.push(item);
	  }
	  else {
	    for (let item of iterator)
	      array.push(item);
	  }
	  return array;
	}
	exports.fromIterator = fromIterator;

	function find(array, predicate, fallback) {
	  var index = 0;
	  var count = array.length;
	  while (index < count) {
	    var value = array[index];
	    if (predicate(value)) return value;
	    else index = index + 1;
	  }
	  return fallback;
	}
	exports.find = find;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const protocol = __webpack_require__(17);
	const {Arg, RetVal, generateActorSpec} = protocol;
	const promise = __webpack_require__(4);
	const {Class} = __webpack_require__(18);

	const longStringSpec = generateActorSpec({
	  typeName: "longstractor",

	  methods: {
	    substring: {
	      request: {
	        start: Arg(0),
	        end: Arg(1)
	      },
	      response: { substring: RetVal() },
	    },
	    release: { release: true },
	  },
	});

	exports.longStringSpec = longStringSpec;

	/**
	 * When a caller is expecting a LongString actor but the string is already available on
	 * client, the SimpleStringFront can be used as it shares the same API as a
	 * LongStringFront but will not make unnecessary trips to the server.
	 */
	const SimpleStringFront = Class({
	  initialize: function (str) {
	    this.str = str;
	  },

	  get length() {
	    return this.str.length;
	  },

	  get initial() {
	    return this.str;
	  },

	  string: function () {
	    return promise.resolve(this.str);
	  },

	  substring: function (start, end) {
	    return promise.resolve(this.str.substring(start, end));
	  },

	  release: function () {
	    this.str = null;
	    return promise.resolve(undefined);
	  }
	});

	exports.SimpleStringFront = SimpleStringFront;

	// The long string actor needs some custom marshalling, because it is sometimes
	// returned as a primitive rather than a complete form.

	var stringActorType = protocol.types.getType("longstractor");
	protocol.types.addType("longstring", {
	  _actor: true,
	  write: (value, context, detail) => {
	    if (!(context instanceof protocol.Actor)) {
	      throw Error("Passing a longstring as an argument isn't supported.");
	    }

	    if (value.short) {
	      return value.str;
	    }
	    return stringActorType.write(value, context, detail);
	  },
	  read: (value, context, detail) => {
	    if (context instanceof protocol.Actor) {
	      throw Error("Passing a longstring as an argument isn't supported.");
	    }
	    if (typeof (value) === "string") {
	      return new SimpleStringFront(value);
	    }
	    return stringActorType.read(value, context, detail);
	  }
	});


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Arg, RetVal, generateActorSpec } = __webpack_require__(17);

	const cssPropertiesSpec = generateActorSpec({
	  typeName: "cssProperties",

	  methods: {
	    getCSSDatabase: {
	      request: {
	        clientBrowserVersion: Arg(0, "string"),
	      },

	      response: RetVal("json"),
	    }
	  }
	});

	exports.cssPropertiesSpec = cssPropertiesSpec;


/***/ },
/* 29 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * This file contains static lists of CSS properties and values. Some of the small lists
	 * are edited manually, while the larger ones are generated by a script. The comments
	 * above each list indicates how it should be updated.
	 */

	/**
	 * All CSS types that properties can support. This list can be manually edited.
	 */
	exports.CSS_TYPES = {
	  "ANGLE": 1,
	  "COLOR": 2,
	  "FREQUENCY": 3,
	  "GRADIENT": 4,
	  "IMAGE_RECT": 5,
	  "LENGTH": 6,
	  "NUMBER": 7,
	  "PERCENTAGE": 8,
	  "TIME": 9,
	  "TIMING_FUNCTION": 10,
	  "URL": 11,
	};

	/**
	 * All cubic-bezier CSS timing-function names. This list can be manually edited.
	 */
	exports.BEZIER_KEYWORDS = ["linear", "ease-in-out", "ease-in", "ease-out", "ease"];

	/**
	 * Functions that accept a color argument. This list can be manually edited.
	 */
	exports.COLOR_TAKING_FUNCTIONS = ["linear-gradient", "-moz-linear-gradient",
	                                  "repeating-linear-gradient",
	                                  "-moz-repeating-linear-gradient", "radial-gradient",
	                                  "-moz-radial-gradient", "repeating-radial-gradient",
	                                  "-moz-repeating-radial-gradient", "drop-shadow"];

	/**
	 * Functions that accept an angle argument. This list can be manually edited.
	 */
	exports.ANGLE_TAKING_FUNCTIONS = ["linear-gradient", "-moz-linear-gradient",
	                                  "repeating-linear-gradient",
	                                  "-moz-repeating-linear-gradient", "rotate", "rotateX",
	                                  "rotateY", "rotateZ", "rotate3d", "skew", "skewX",
	                                  "skewY", "hue-rotate"];

	/**
	 * The list of all CSS Pseudo Elements. This list MUST be automatically generated.
	 *
	 * The following script will copy the pseudo-elements to your clipboard if run from the
	 * Browser Console, which can be launched from Tools -> Web Developer -> Browser Console.

	var domUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	var json = JSON.stringify(domUtils.getCSSPseudoElementNames(), null, 0);
	copy(`exports.PSEUDO_ELEMENTS = ${json};\n`);
	console.log("The PSEUDO_ELEMENTS have been copied to your clipboard.")
	 */

	/*eslint-disable */
	exports.PSEUDO_ELEMENTS = [":after",":before",":backdrop",":first-letter",":first-line",":-moz-selection",":-moz-focus-inner",":-moz-focus-outer",":-moz-list-bullet",":-moz-list-number",":-moz-math-anonymous",":-moz-progress-bar",":-moz-range-track",":-moz-range-progress",":-moz-range-thumb",":-moz-meter-bar",":-moz-placeholder",":-moz-color-swatch"];
	/*eslint-enable */

	/**
	 * A list of CSS Properties and their various characteristics. This is used on the
	 * client-side when the CssPropertiesActor is not found, or when the client and server
	 * are the same version. A single property takes the form:
	 *
	 *  "animation": {
	 *    "isInherited": false,
	 *    "supports": [ 7, 9, 10 ]
	 *  }
	 *
	 * The following script will copy the CSS properties to your clipboard if run from the
	 * Browser Console, which can be launched from Tools -> Web Developer -> Browser Console.

	var {require} = Components.utils.import("resource://devtools/shared/Loader.jsm", {});
	var {generateCssProperties} = require("devtools/server/actors/css-properties");
	var cssProperties = generateCssProperties();
	for (var key in cssProperties) {
	  // Ignore OS-specific properties
	  if (key.indexOf('-moz-osx-') !== -1) {
	    cssProperties[key] = undefined;
	  }
	}
	var json = JSON.stringify(cssProperties, null, 0);
	copy(`exports.CSS_PROPERTIES = ${json};\n`);
	console.log("The CSS_PROPERTIES have been copied to your clipboard.");
	 */

	/*eslint-disable */
	exports.CSS_PROPERTIES = {"align-content":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","space-around","space-between","space-evenly","start","stretch","unset"]},"align-items":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"align-self":{"isInherited":false,"supports":[],"values":["auto","baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"animation-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"animation-direction":{"isInherited":false,"supports":[],"values":["alternate","alternate-reverse","inherit","initial","normal","reverse","unset"]},"animation-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"animation-fill-mode":{"isInherited":false,"supports":[],"values":["backwards","both","forwards","inherit","initial","none","unset"]},"animation-iteration-count":{"isInherited":false,"supports":[7],"values":["infinite","inherit","initial","unset"]},"animation-name":{"isInherited":false,"supports":[],"values":["inherit","initial","none","unset"]},"animation-play-state":{"isInherited":false,"supports":[],"values":["inherit","initial","paused","running","unset"]},"animation-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-moz-appearance":{"isInherited":false,"supports":[],"values":["-moz-gtk-info-bar","-moz-mac-disclosure-button-closed","-moz-mac-disclosure-button-open","-moz-mac-fullscreen-button","-moz-mac-help-button","-moz-mac-source-list","-moz-mac-vibrancy-dark","-moz-mac-vibrancy-light","-moz-win-borderless-glass","-moz-win-browsertabbar-toolbox","-moz-win-communications-toolbox","-moz-win-exclude-glass","-moz-win-glass","-moz-win-media-toolbox","-moz-window-button-box","-moz-window-button-box-maximized","-moz-window-button-close","-moz-window-button-maximize","-moz-window-button-minimize","-moz-window-button-restore","-moz-window-frame-bottom","-moz-window-frame-left","-moz-window-frame-right","-moz-window-titlebar","-moz-window-titlebar-maximized","button","button-arrow-down","button-arrow-next","button-arrow-previous","button-arrow-up","button-bevel","button-focus","caret","checkbox","checkbox-container","checkbox-label","checkmenuitem","dialog","dualbutton","groupbox","inherit","initial","listbox","listitem","menuarrow","menubar","menucheckbox","menuimage","menuitem","menuitemtext","menulist","menulist-button","menulist-text","menulist-textfield","menupopup","menuradio","menuseparator","meterbar","meterchunk","none","number-input","progressbar","progressbar-vertical","progresschunk","progresschunk-vertical","radio","radio-container","radio-label","radiomenuitem","range","range-thumb","resizer","resizerpanel","scale-horizontal","scale-vertical","scalethumb-horizontal","scalethumb-vertical","scalethumbend","scalethumbstart","scalethumbtick","scrollbar","scrollbar-horizontal","scrollbar-small","scrollbar-vertical","scrollbarbutton-down","scrollbarbutton-left","scrollbarbutton-right","scrollbarbutton-up","scrollbarthumb-horizontal","scrollbarthumb-vertical","scrollbartrack-horizontal","scrollbartrack-vertical","searchfield","separator","spinner","spinner-downbutton","spinner-textfield","spinner-upbutton","splitter","statusbar","statusbarpanel","tab","tab-scroll-arrow-back","tab-scroll-arrow-forward","tabpanel","tabpanels","textfield","textfield-multiline","toolbar","toolbarbutton","toolbarbutton-dropdown","toolbargripper","toolbox","tooltip","treeheader","treeheadercell","treeheadersortarrow","treeitem","treeline","treetwisty","treetwistyopen","treeview","unset","window"]},"backface-visibility":{"isInherited":false,"supports":[],"values":["hidden","inherit","initial","unset","visible"]},"background-attachment":{"isInherited":false,"supports":[],"values":["fixed","inherit","initial","local","scroll","unset"]},"background-blend-mode":{"isInherited":false,"supports":[],"values":["color","color-burn","color-dodge","darken","difference","exclusion","hard-light","hue","inherit","initial","lighten","luminosity","multiply","normal","overlay","saturation","screen","soft-light","unset"]},"background-clip":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","padding-box","text","unset"]},"background-color":{"isInherited":false,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"background-image":{"isInherited":false,"supports":[4,5,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"background-origin":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","padding-box","unset"]},"background-position-x":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"background-position-y":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"background-repeat":{"isInherited":false,"supports":[],"values":["inherit","initial","no-repeat","repeat","repeat-x","repeat-y","round","space","unset"]},"background-size":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-binding":{"isInherited":false,"supports":[11],"values":["inherit","initial","none","unset","url"]},"block-size":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"border-block-end-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-block-end-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-block-end-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-block-start-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-block-start-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-block-start-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-bottom-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-bottom-colors":{"isInherited":false,"supports":[2],"values":["inherit","initial","unset"]},"border-bottom-left-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-bottom-right-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-bottom-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-bottom-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-collapse":{"isInherited":true,"supports":[],"values":["collapse","inherit","initial","separate","unset"]},"border-image-outset":{"isInherited":false,"supports":[6,7],"values":["inherit","initial","unset"]},"border-image-repeat":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"border-image-slice":{"isInherited":false,"supports":[7,8],"values":["inherit","initial","unset"]},"border-image-source":{"isInherited":false,"supports":[4,5,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"border-image-width":{"isInherited":false,"supports":[6,7,8],"values":["inherit","initial","unset"]},"border-inline-end-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-inline-end-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-inline-end-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-inline-start-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-inline-start-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-inline-start-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-left-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-left-colors":{"isInherited":false,"supports":[2],"values":["inherit","initial","unset"]},"border-left-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-left-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-right-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-right-colors":{"isInherited":false,"supports":[2],"values":["inherit","initial","unset"]},"border-right-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-right-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"border-spacing":{"isInherited":true,"supports":[6],"values":["inherit","initial","unset"]},"border-top-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-top-colors":{"isInherited":false,"supports":[2],"values":["inherit","initial","unset"]},"border-top-left-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-top-right-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-top-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-top-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"bottom":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-box-align":{"isInherited":false,"supports":[],"values":["baseline","center","end","inherit","initial","start","stretch","unset"]},"box-decoration-break":{"isInherited":false,"supports":[],"values":["clone","inherit","initial","slice","unset"]},"-moz-box-direction":{"isInherited":false,"supports":[],"values":["inherit","initial","normal","reverse","unset"]},"-moz-box-flex":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-moz-box-ordinal-group":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-moz-box-orient":{"isInherited":false,"supports":[],"values":["block-axis","horizontal","inherit","initial","inline-axis","unset","vertical"]},"-moz-box-pack":{"isInherited":false,"supports":[],"values":["center","end","inherit","initial","justify","start","unset"]},"box-shadow":{"isInherited":false,"supports":[2,6],"values":["inherit","initial","unset"]},"box-sizing":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","unset"]},"caption-side":{"isInherited":true,"supports":[],"values":["bottom","bottom-outside","inherit","initial","left","right","top","top-outside","unset"]},"clear":{"isInherited":false,"supports":[],"values":["both","inherit","initial","inline-end","inline-start","left","none","right","unset"]},"clip":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"clip-path":{"isInherited":false,"supports":[11],"values":["inherit","initial","unset"]},"clip-rule":{"isInherited":true,"supports":[],"values":["evenodd","inherit","initial","nonzero","unset"]},"color":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"color-adjust":{"isInherited":true,"supports":[],"values":["economy","exact","inherit","initial","unset"]},"color-interpolation":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","linearrgb","srgb","unset"]},"color-interpolation-filters":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","linearrgb","srgb","unset"]},"-moz-column-count":{"isInherited":false,"supports":[7],"values":["auto","inherit","initial","unset"]},"-moz-column-fill":{"isInherited":false,"supports":[],"values":["auto","balance","inherit","initial","unset"]},"-moz-column-gap":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","normal","unset"]},"-moz-column-rule-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-column-rule-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"-moz-column-rule-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-column-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"content":{"isInherited":false,"supports":[11],"values":["inherit","initial","unset"]},"-moz-control-character-visibility":{"isInherited":true,"supports":[],"values":["hidden","inherit","initial","unset","visible"]},"counter-increment":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"counter-reset":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"cursor":{"isInherited":true,"supports":[11],"values":["inherit","initial","unset"]},"direction":{"isInherited":true,"supports":[],"values":["inherit","initial","ltr","rtl","unset"]},"display":{"isInherited":false,"supports":[],"values":["-moz-box","-moz-deck","-moz-grid","-moz-grid-group","-moz-grid-line","-moz-groupbox","-moz-inline-box","-moz-inline-grid","-moz-inline-stack","-moz-popup","-moz-stack","-webkit-box","-webkit-flex","-webkit-inline-box","-webkit-inline-flex","block","contents","flex","grid","inherit","initial","inline","inline-block","inline-flex","inline-grid","inline-table","list-item","none","ruby","ruby-base","ruby-base-container","ruby-text","ruby-text-container","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","unset"]},"dominant-baseline":{"isInherited":false,"supports":[],"values":["alphabetic","auto","central","hanging","ideographic","inherit","initial","mathematical","middle","no-change","reset-size","text-after-edge","text-before-edge","unset","use-script"]},"empty-cells":{"isInherited":true,"supports":[],"values":["hide","inherit","initial","show","unset"]},"fill":{"isInherited":true,"supports":[2,11],"values":["inherit","initial","unset"]},"fill-opacity":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"fill-rule":{"isInherited":true,"supports":[],"values":["evenodd","inherit","initial","nonzero","unset"]},"filter":{"isInherited":false,"supports":[11],"values":["inherit","initial","unset"]},"flex-basis":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"flex-direction":{"isInherited":false,"supports":[],"values":["column","column-reverse","inherit","initial","row","row-reverse","unset"]},"flex-grow":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"flex-shrink":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"flex-wrap":{"isInherited":false,"supports":[],"values":["inherit","initial","nowrap","unset","wrap","wrap-reverse"]},"float":{"isInherited":false,"supports":[],"values":["inherit","initial","inline-end","inline-start","left","none","right","unset"]},"-moz-float-edge":{"isInherited":false,"supports":[],"values":["content-box","inherit","initial","margin-box","unset"]},"flood-color":{"isInherited":false,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"flood-opacity":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"font-family":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-feature-settings":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-kerning":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","none","normal","unset"]},"font-language-override":{"isInherited":true,"supports":[],"values":["inherit","initial","normal","unset"]},"font-size":{"isInherited":true,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","large","larger","medium","small","smaller","unset","x-large","x-small","xx-large","xx-small"]},"font-size-adjust":{"isInherited":true,"supports":[7],"values":["inherit","initial","none","unset"]},"font-stretch":{"isInherited":true,"supports":[],"values":["condensed","expanded","extra-condensed","extra-expanded","inherit","initial","normal","semi-condensed","semi-expanded","ultra-condensed","ultra-expanded","unset"]},"font-style":{"isInherited":true,"supports":[],"values":["inherit","initial","italic","normal","oblique","unset"]},"font-synthesis":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-alternates":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-caps":{"isInherited":true,"supports":[],"values":["all-petite-caps","all-small-caps","inherit","initial","normal","petite-caps","small-caps","titling-caps","unicase","unset"]},"font-variant-east-asian":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-ligatures":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-numeric":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"font-variant-position":{"isInherited":true,"supports":[],"values":["inherit","initial","normal","sub","super","unset"]},"font-weight":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"-moz-force-broken-image-icon":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-auto-columns":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"grid-auto-flow":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"grid-auto-rows":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"grid-column-end":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-column-gap":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"grid-column-start":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-row-end":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-row-gap":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"grid-row-start":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-template-areas":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"grid-template-columns":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"grid-template-rows":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"height":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"hyphens":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","manual","none","unset"]},"image-orientation":{"isInherited":true,"supports":[1],"values":["inherit","initial","unset"]},"-moz-image-region":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"image-rendering":{"isInherited":true,"supports":[],"values":["-moz-crisp-edges","auto","inherit","initial","optimizequality","optimizespeed","unset"]},"ime-mode":{"isInherited":false,"supports":[],"values":["active","auto","disabled","inactive","inherit","initial","normal","unset"]},"inline-size":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"isolation":{"isInherited":false,"supports":[],"values":["auto","inherit","initial","isolate","unset"]},"justify-content":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","space-around","space-between","space-evenly","start","stretch","unset"]},"justify-items":{"isInherited":false,"supports":[],"values":["auto","baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"justify-self":{"isInherited":false,"supports":[],"values":["auto","baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"left":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"letter-spacing":{"isInherited":true,"supports":[6],"values":["-moz-calc","calc","inherit","initial","normal","unset"]},"lighting-color":{"isInherited":false,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"line-height":{"isInherited":true,"supports":[6,7,8],"values":["-moz-block-height","-moz-calc","calc","inherit","initial","normal","unset"]},"list-style-image":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"list-style-position":{"isInherited":true,"supports":[],"values":["inherit","initial","inside","outside","unset"]},"list-style-type":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"margin-block-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-block-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-bottom":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-inline-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-inline-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-left":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-right":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"margin-top":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"marker-end":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"marker-mid":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"marker-offset":{"isInherited":false,"supports":[6],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"marker-start":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"mask-clip":{"isInherited":false,"values":["border-box","content-box","inherit","initial","padding-box","unset"],"supports":[]},"mask-composite":{"isInherited":false,"values":["add","exclude","inherit","initial","intersect","subtract","unset"],"supports":[]},"mask-image":{"isInherited":false,"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"],"supports":[4,5,11]},"mask-mode":{"isInherited":false,"values":["alpha","inherit","initial","luminance","match-source","unset"],"supports":[]},"mask-origin":{"isInherited":false,"values":["border-box","content-box","inherit","initial","padding-box","unset"],"supports":[]},"mask-position-x":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"mask-position-y":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"mask-repeat":{"isInherited":false,"values":["inherit","initial","no-repeat","repeat","repeat-x","repeat-y","round","space","unset"],"supports":[]},"mask-size":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"mask-type":{"isInherited":false,"supports":[],"values":["alpha","inherit","initial","luminance","unset"]},"max-block-size":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","none","unset"]},"max-height":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","calc","inherit","initial","none","unset"]},"max-inline-size":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","calc","inherit","initial","none","unset"]},"max-width":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","calc","inherit","initial","none","unset"]},"min-block-size":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"min-height":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"min-inline-size":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"min-width":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"mix-blend-mode":{"isInherited":false,"supports":[],"values":["color","color-burn","color-dodge","darken","difference","exclusion","hard-light","hue","inherit","initial","lighten","luminosity","multiply","normal","overlay","saturation","screen","soft-light","unset"]},"object-fit":{"isInherited":false,"supports":[],"values":["contain","cover","fill","inherit","initial","none","scale-down","unset"]},"object-position":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"offset-block-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"offset-block-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"offset-inline-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"offset-inline-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"opacity":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"order":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-moz-orient":{"isInherited":false,"supports":[],"values":["block","horizontal","inherit","initial","inline","unset","vertical"]},"outline-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"outline-offset":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","unset"]},"-moz-outline-radius-bottomleft":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-outline-radius-bottomright":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-outline-radius-topleft":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-outline-radius-topright":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"outline-style":{"isInherited":false,"supports":[],"values":["auto","dashed","dotted","double","groove","inherit","initial","inset","none","outset","ridge","solid","unset"]},"outline-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"overflow-x":{"isInherited":false,"supports":[],"values":["-moz-hidden-unscrollable","auto","hidden","inherit","initial","scroll","unset","visible"]},"overflow-y":{"isInherited":false,"supports":[],"values":["-moz-hidden-unscrollable","auto","hidden","inherit","initial","scroll","unset","visible"]},"padding-block-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-block-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-bottom":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-inline-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-inline-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-left":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-right":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"padding-top":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"page-break-after":{"isInherited":false,"supports":[],"values":["always","auto","avoid","inherit","initial","left","right","unset"]},"page-break-before":{"isInherited":false,"supports":[],"values":["always","auto","avoid","inherit","initial","left","right","unset"]},"page-break-inside":{"isInherited":false,"supports":[],"values":["auto","avoid","inherit","initial","unset"]},"paint-order":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"perspective":{"isInherited":false,"supports":[6],"values":["inherit","initial","none","unset"]},"perspective-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"pointer-events":{"isInherited":true,"supports":[],"values":["all","auto","fill","inherit","initial","none","painted","stroke","unset","visible","visiblefill","visiblepainted","visiblestroke"]},"position":{"isInherited":false,"supports":[],"values":["absolute","fixed","inherit","initial","relative","static","sticky","unset"]},"quotes":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"resize":{"isInherited":false,"supports":[],"values":["both","horizontal","inherit","initial","none","unset","vertical"]},"right":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"ruby-align":{"isInherited":true,"supports":[],"values":["center","inherit","initial","space-around","space-between","start","unset"]},"ruby-position":{"isInherited":true,"supports":[],"values":["inherit","initial","over","under","unset"]},"scroll-behavior":{"isInherited":false,"supports":[],"values":["auto","inherit","initial","smooth","unset"]},"scroll-snap-coordinate":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"scroll-snap-destination":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"scroll-snap-points-x":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"scroll-snap-points-y":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"scroll-snap-type-x":{"isInherited":false,"supports":[],"values":["inherit","initial","mandatory","none","proximity","unset"]},"scroll-snap-type-y":{"isInherited":false,"supports":[],"values":["inherit","initial","mandatory","none","proximity","unset"]},"shape-rendering":{"isInherited":true,"supports":[],"values":["auto","crispedges","geometricprecision","inherit","initial","optimizespeed","unset"]},"-moz-stack-sizing":{"isInherited":false,"supports":[],"values":["ignore","inherit","initial","stretch-to-fit","unset"]},"stop-color":{"isInherited":false,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"stop-opacity":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"stroke":{"isInherited":true,"supports":[2,11],"values":["inherit","initial","unset"]},"stroke-dasharray":{"isInherited":true,"supports":[6,7,8],"values":["inherit","initial","unset"]},"stroke-dashoffset":{"isInherited":true,"supports":[6,7,8],"values":["inherit","initial","unset"]},"stroke-linecap":{"isInherited":true,"supports":[],"values":["butt","inherit","initial","round","square","unset"]},"stroke-linejoin":{"isInherited":true,"supports":[],"values":["bevel","inherit","initial","miter","round","unset"]},"stroke-miterlimit":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"stroke-opacity":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"stroke-width":{"isInherited":true,"supports":[6,7,8],"values":["inherit","initial","unset"]},"-moz-tab-size":{"isInherited":true,"supports":[7],"values":["inherit","initial","unset"]},"table-layout":{"isInherited":false,"supports":[],"values":["auto","fixed","inherit","initial","unset"]},"text-align":{"isInherited":true,"supports":[],"values":["-moz-center","-moz-left","-moz-right","center","end","inherit","initial","justify","left","right","start","unset"]},"text-align-last":{"isInherited":true,"supports":[],"values":["auto","center","end","inherit","initial","justify","left","right","start","unset"]},"text-anchor":{"isInherited":true,"supports":[],"values":["end","inherit","initial","middle","start","unset"]},"text-combine-upright":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"text-decoration-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"text-decoration-line":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"text-decoration-style":{"isInherited":false,"supports":[],"values":["-moz-none","dashed","dotted","double","inherit","initial","solid","unset","wavy"]},"text-emphasis-color":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"text-emphasis-position":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"text-emphasis-style":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"-webkit-text-fill-color":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"text-indent":{"isInherited":true,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"text-orientation":{"isInherited":true,"supports":[],"values":["inherit","initial","mixed","sideways","sideways-right","unset","upright"]},"text-overflow":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"text-rendering":{"isInherited":true,"supports":[],"values":["auto","geometricprecision","inherit","initial","optimizelegibility","optimizespeed","unset"]},"text-shadow":{"isInherited":true,"supports":[2,6],"values":["inherit","initial","unset"]},"-moz-text-size-adjust":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","none","unset"]},"-webkit-text-stroke-color":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-webkit-text-stroke-width":{"isInherited":true,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"text-transform":{"isInherited":true,"supports":[],"values":["capitalize","full-width","inherit","initial","lowercase","none","unset","uppercase"]},"top":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"touch-action":{"isInherited":false,"supports":[],"values":["auto","inherit","initial","manipulation","none","pan-x","pan-y","unset"]},"transform":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"transform-box":{"isInherited":false,"supports":[],"values":["border-box","fill-box","inherit","initial","unset","view-box"]},"transform-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"transform-style":{"isInherited":false,"supports":[],"values":["flat","inherit","initial","preserve-3d","unset"]},"transition-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"transition-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"transition-property":{"isInherited":false,"supports":[],"values":["all","inherit","initial","none","unset"]},"transition-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"unicode-bidi":{"isInherited":false,"supports":[],"values":["-moz-isolate","-moz-isolate-override","-moz-plaintext","bidi-override","embed","inherit","initial","isolate","isolate-override","normal","plaintext","unset"]},"-moz-user-focus":{"isInherited":true,"supports":[],"values":["ignore","inherit","initial","none","normal","select-after","select-all","select-before","select-menu","select-same","unset"]},"-moz-user-input":{"isInherited":true,"supports":[],"values":["auto","disabled","enabled","inherit","initial","none","unset"]},"-moz-user-modify":{"isInherited":true,"supports":[],"values":["inherit","initial","read-only","read-write","unset","write-only"]},"-moz-user-select":{"isInherited":false,"supports":[],"values":["-moz-all","-moz-none","-moz-text","all","auto","element","elements","inherit","initial","none","text","toggle","tri-state","unset"]},"vector-effect":{"isInherited":false,"supports":[],"values":["inherit","initial","non-scaling-stroke","none","unset"]},"vertical-align":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","-moz-middle-with-baseline","baseline","bottom","calc","inherit","initial","middle","sub","super","text-bottom","text-top","top","unset"]},"visibility":{"isInherited":true,"supports":[],"values":["collapse","hidden","inherit","initial","unset","visible"]},"white-space":{"isInherited":true,"supports":[],"values":["-moz-pre-space","inherit","initial","normal","nowrap","pre","pre-line","pre-wrap","unset"]},"width":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"will-change":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"-moz-window-dragging":{"isInherited":false,"supports":[],"values":["default","drag","inherit","initial","no-drag","unset"]},"word-break":{"isInherited":true,"supports":[],"values":["break-all","inherit","initial","keep-all","normal","unset"]},"word-spacing":{"isInherited":true,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","normal","unset"]},"overflow-wrap":{"isInherited":true,"supports":[],"values":["break-word","inherit","initial","normal","unset"]},"writing-mode":{"isInherited":true,"supports":[],"values":["horizontal-tb","inherit","initial","lr","lr-tb","rl","rl-tb","sideways-lr","sideways-rl","tb","tb-rl","unset","vertical-lr","vertical-rl"]},"z-index":{"isInherited":false,"supports":[7],"values":["auto","inherit","initial","unset"]},"all":{"isInherited":false,"supports":[1,2,4,5,6,7,8,9,10,11],"values":["COLOR","-moz-all","-moz-available","-moz-block-height","-moz-box","-moz-calc","-moz-center","-moz-crisp-edges","-moz-deck","-moz-element","-moz-fit-content","-moz-grid","-moz-grid-group","-moz-grid-line","-moz-groupbox","-moz-gtk-info-bar","-moz-hidden-unscrollable","-moz-image-rect","-moz-inline-box","-moz-inline-grid","-moz-inline-stack","-moz-left","-moz-linear-gradient","-moz-mac-disclosure-button-closed","-moz-mac-disclosure-button-open","-moz-mac-fullscreen-button","-moz-mac-help-button","-moz-mac-source-list","-moz-mac-vibrancy-dark","-moz-mac-vibrancy-light","-moz-max-content","-moz-middle-with-baseline","-moz-min-content","-moz-none","-moz-popup","-moz-pre-space","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","-moz-right","-moz-stack","-moz-text","-moz-use-text-color","-moz-win-borderless-glass","-moz-win-browsertabbar-toolbox","-moz-win-communications-toolbox","-moz-win-exclude-glass","-moz-win-glass","-moz-win-media-toolbox","-moz-window-button-box","-moz-window-button-box-maximized","-moz-window-button-close","-moz-window-button-maximize","-moz-window-button-minimize","-moz-window-button-restore","-moz-window-frame-bottom","-moz-window-frame-left","-moz-window-frame-right","-moz-window-titlebar","-moz-window-titlebar-maximized","-webkit-box","-webkit-flex","-webkit-inline-box","-webkit-inline-flex","absolute","active","add","all","all-petite-caps","all-small-caps","alpha","alphabetic","alternate","alternate-reverse","always","auto","avoid","backwards","balance","baseline","bevel","block","block-axis","border-box","both","bottom","bottom-outside","break-all","break-word","butt","button","button-arrow-down","button-arrow-next","button-arrow-previous","button-arrow-up","button-bevel","button-focus","calc","capitalize","caret","center","central","checkbox","checkbox-container","checkbox-label","checkmenuitem","clone","collapse","color","color-burn","color-dodge","column","column-reverse","condensed","contain","content-box","contents","cover","crispedges","cubic-bezier","currentColor","darken","dashed","default","dialog","difference","disabled","dotted","double","drag","dualbutton","ease","ease-in","ease-in-out","ease-out","economy","element","elements","enabled","end","evenodd","exact","exclude","exclusion","expanded","extra-condensed","extra-expanded","fill","fill-box","fixed","flat","flex","flex-end","flex-start","forwards","full-width","geometricprecision","grayscale","grid","groove","groupbox","hanging","hard-light","hidden","hide","horizontal","horizontal-tb","hsl","hsla","hue","ideographic","ignore","inactive","infinite","inherit","initial","inline","inline-axis","inline-block","inline-end","inline-flex","inline-grid","inline-start","inline-table","inset","inside","intersect","isolate","italic","justify","keep-all","large","larger","last-baseline","left","lighten","linear","linear-gradient","linearrgb","list-item","listbox","listitem","local","lowercase","lr","lr-tb","luminance","luminosity","mandatory","manipulation","manual","margin-box","match-source","mathematical","medium","menuarrow","menubar","menucheckbox","menuimage","menuitem","menuitemtext","menulist","menulist-button","menulist-text","menulist-textfield","menupopup","menuradio","menuseparator","meterbar","meterchunk","middle","miter","mixed","multiply","no-change","no-drag","no-repeat","non-scaling-stroke","none","nonzero","normal","nowrap","number-input","oblique","optimizelegibility","optimizequality","optimizespeed","outset","outside","over","overlay","padding-box","painted","pan-x","pan-y","paused","petite-caps","pre","pre-line","pre-wrap","preserve-3d","progressbar","progressbar-vertical","progresschunk","progresschunk-vertical","proximity","radial-gradient","radio","radio-container","radio-label","radiomenuitem","range","range-thumb","read-only","read-write","relative","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","reset-size","resizer","resizerpanel","reverse","rgb","rgba","ridge","right","rl","rl-tb","round","row","row-reverse","ruby","ruby-base","ruby-base-container","ruby-text","ruby-text-container","running","saturation","scale-down","scale-horizontal","scale-vertical","scalethumb-horizontal","scalethumb-vertical","scalethumbend","scalethumbstart","scalethumbtick","screen","scroll","scrollbar","scrollbar-horizontal","scrollbar-small","scrollbar-vertical","scrollbarbutton-down","scrollbarbutton-left","scrollbarbutton-right","scrollbarbutton-up","scrollbarthumb-horizontal","scrollbarthumb-vertical","scrollbartrack-horizontal","scrollbartrack-vertical","searchfield","select-after","select-all","select-before","select-menu","select-same","self-end","self-start","semi-condensed","semi-expanded","separate","separator","show","sideways","sideways-lr","sideways-right","sideways-rl","slice","small","small-caps","smaller","smooth","soft-light","solid","space","space-around","space-between","space-evenly","spinner","spinner-downbutton","spinner-textfield","spinner-upbutton","splitter","square","srgb","start","static","statusbar","statusbarpanel","step-end","step-start","steps","sticky","stretch","stretch-to-fit","stroke","sub","subtract","super","tab","tab-scroll-arrow-back","tab-scroll-arrow-forward","table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row","table-row-group","tabpanel","tabpanels","tb","tb-rl","text","text-after-edge","text-before-edge","text-bottom","text-top","textfield","textfield-multiline","thick","thin","titling-caps","toggle","toolbar","toolbarbutton","toolbarbutton-dropdown","toolbargripper","toolbox","tooltip","top","top-outside","transparent","treeheader","treeheadercell","treeheadersortarrow","treeitem","treeline","treetwisty","treetwistyopen","treeview","tri-state","ultra-condensed","ultra-expanded","under","unicase","unset","uppercase","upright","url","use-script","vertical","vertical-lr","vertical-rl","view-box","visible","visiblefill","visiblepainted","visiblestroke","wavy","window","wrap","wrap-reverse","write-only","x-large","x-small","xx-large","xx-small"]},"animation":{"isInherited":false,"supports":[7,9,10],"values":["alternate","alternate-reverse","backwards","both","cubic-bezier","ease","ease-in","ease-in-out","ease-out","forwards","infinite","inherit","initial","linear","none","normal","paused","reverse","running","step-end","step-start","steps","unset"]},"background":{"isInherited":false,"supports":[2,4,5,6,8,11],"values":["COLOR","-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","border-box","content-box","currentColor","fixed","hsl","hsla","inherit","initial","linear-gradient","local","no-repeat","none","padding-box","radial-gradient","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","rgb","rgba","round","scroll","space","text","transparent","unset","url"]},"background-position":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","linear-gradient","medium","none","outset","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","rgb","rgba","ridge","solid","thick","thin","transparent","unset","url"]},"border-block-end":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-block-start":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-bottom":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"border-image":{"isInherited":false,"supports":[4,5,6,7,8,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"border-inline-end":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-inline-start":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-left":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"border-right":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"border-top":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"border-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-column-rule":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"-moz-columns":{"isInherited":false,"supports":[6,7],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"flex":{"isInherited":false,"supports":[6,7,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"flex-flow":{"isInherited":false,"supports":[],"values":["column","column-reverse","inherit","initial","nowrap","row","row-reverse","unset","wrap","wrap-reverse"]},"font":{"isInherited":true,"supports":[6,7,8],"values":["-moz-block-height","-moz-calc","all-petite-caps","all-small-caps","auto","calc","condensed","expanded","extra-condensed","extra-expanded","inherit","initial","italic","large","larger","medium","none","normal","oblique","petite-caps","semi-condensed","semi-expanded","small","small-caps","smaller","sub","super","titling-caps","ultra-condensed","ultra-expanded","unicase","unset","x-large","x-small","xx-large","xx-small"]},"font-variant":{"isInherited":true,"supports":[],"values":["all-petite-caps","all-small-caps","inherit","initial","normal","petite-caps","small-caps","sub","super","titling-caps","unicase","unset"]},"grid":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"grid-area":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-column":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-gap":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"grid-row":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"grid-template":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"list-style":{"isInherited":true,"supports":[11],"values":["inherit","initial","inside","none","outside","unset","url"]},"margin":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"marker":{"isInherited":true,"supports":[11],"values":["inherit","initial","none","unset","url"]},"mask":{"isInherited":false,"supports":[4,5,6,8,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","add","alpha","border-box","content-box","exclude","inherit","initial","intersect","linear-gradient","luminance","match-source","no-repeat","none","padding-box","radial-gradient","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","round","space","subtract","unset","url"]},"mask-position":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"outline":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","auto","calc","currentColor","dashed","dotted","double","groove","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"-moz-outline-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"overflow":{"isInherited":false,"supports":[],"values":["-moz-hidden-unscrollable","auto","hidden","inherit","initial","scroll","unset","visible"]},"padding":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"scroll-snap-type":{"isInherited":false,"supports":[],"values":["inherit","initial","mandatory","none","proximity","unset"]},"text-decoration":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-none","-moz-use-text-color","currentColor","dashed","dotted","double","hsl","hsla","inherit","initial","rgb","rgba","solid","transparent","unset","wavy"]},"text-emphasis":{"isInherited":true,"supports":[2],"values":["COLOR","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-webkit-text-stroke":{"isInherited":true,"supports":[2,6],"values":["COLOR","-moz-calc","calc","currentColor","hsl","hsla","inherit","initial","medium","rgb","rgba","thick","thin","transparent","unset"]},"-moz-transform":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"transition":{"isInherited":false,"supports":[9,10],"values":["all","cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","none","step-end","step-start","steps","unset"]},"word-wrap":{"isInherited":true,"supports":[],"values":["break-word","inherit","initial","normal","unset"]},"-moz-transform-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-perspective-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-moz-perspective":{"isInherited":false,"supports":[6],"values":["inherit","initial","none","unset"]},"-moz-transform-style":{"isInherited":false,"supports":[],"values":["flat","inherit","initial","preserve-3d","unset"]},"-moz-backface-visibility":{"isInherited":false,"supports":[],"values":["hidden","inherit","initial","unset","visible"]},"-moz-border-image":{"isInherited":false,"supports":[4,5,6,7,8,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"-moz-transition":{"isInherited":false,"supports":[9,10],"values":["all","cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","none","step-end","step-start","steps","unset"]},"-moz-transition-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-moz-transition-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-moz-transition-property":{"isInherited":false,"supports":[],"values":["all","inherit","initial","none","unset"]},"-moz-transition-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-moz-animation":{"isInherited":false,"supports":[7,9,10],"values":["alternate","alternate-reverse","backwards","both","cubic-bezier","ease","ease-in","ease-in-out","ease-out","forwards","infinite","inherit","initial","linear","none","normal","paused","reverse","running","step-end","step-start","steps","unset"]},"-moz-animation-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-moz-animation-direction":{"isInherited":false,"supports":[],"values":["alternate","alternate-reverse","inherit","initial","normal","reverse","unset"]},"-moz-animation-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-moz-animation-fill-mode":{"isInherited":false,"supports":[],"values":["backwards","both","forwards","inherit","initial","none","unset"]},"-moz-animation-iteration-count":{"isInherited":false,"supports":[7],"values":["infinite","inherit","initial","unset"]},"-moz-animation-name":{"isInherited":false,"supports":[],"values":["inherit","initial","none","unset"]},"-moz-animation-play-state":{"isInherited":false,"supports":[],"values":["inherit","initial","paused","running","unset"]},"-moz-animation-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-moz-box-sizing":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","unset"]},"-moz-font-feature-settings":{"isInherited":true,"supports":[],"values":["inherit","initial","unset"]},"-moz-font-language-override":{"isInherited":true,"supports":[],"values":["inherit","initial","normal","unset"]},"-moz-padding-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"-moz-padding-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","calc","inherit","initial","unset"]},"-moz-margin-end":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-margin-start":{"isInherited":false,"supports":[6,8],"values":["-moz-calc","auto","calc","inherit","initial","unset"]},"-moz-border-end":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"-moz-border-end-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-end-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"-moz-border-end-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-border-start":{"isInherited":false,"supports":[2,6],"values":["COLOR","-moz-calc","-moz-use-text-color","calc","currentColor","dashed","dotted","double","groove","hidden","hsl","hsla","inherit","initial","inset","medium","none","outset","rgb","rgba","ridge","solid","thick","thin","transparent","unset"]},"-moz-border-start-color":{"isInherited":false,"supports":[2],"values":["COLOR","-moz-use-text-color","currentColor","hsl","hsla","inherit","initial","rgb","rgba","transparent","unset"]},"-moz-border-start-style":{"isInherited":false,"supports":[],"values":["dashed","dotted","double","groove","hidden","inherit","initial","inset","none","outset","ridge","solid","unset"]},"-moz-border-start-width":{"isInherited":false,"supports":[6],"values":["-moz-calc","calc","inherit","initial","medium","thick","thin","unset"]},"-moz-hyphens":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","manual","none","unset"]},"-moz-text-align-last":{"isInherited":true,"supports":[],"values":["auto","center","end","inherit","initial","justify","left","right","start","unset"]},"-webkit-animation":{"isInherited":false,"supports":[7,9,10],"values":["alternate","alternate-reverse","backwards","both","cubic-bezier","ease","ease-in","ease-in-out","ease-out","forwards","infinite","inherit","initial","linear","none","normal","paused","reverse","running","step-end","step-start","steps","unset"]},"-webkit-animation-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-webkit-animation-direction":{"isInherited":false,"supports":[],"values":["alternate","alternate-reverse","inherit","initial","normal","reverse","unset"]},"-webkit-animation-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-webkit-animation-fill-mode":{"isInherited":false,"supports":[],"values":["backwards","both","forwards","inherit","initial","none","unset"]},"-webkit-animation-iteration-count":{"isInherited":false,"supports":[7],"values":["infinite","inherit","initial","unset"]},"-webkit-animation-name":{"isInherited":false,"supports":[],"values":["inherit","initial","none","unset"]},"-webkit-animation-play-state":{"isInherited":false,"supports":[],"values":["inherit","initial","paused","running","unset"]},"-webkit-animation-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-webkit-filter":{"isInherited":false,"supports":[11],"values":["inherit","initial","unset"]},"-webkit-text-size-adjust":{"isInherited":true,"supports":[],"values":["auto","inherit","initial","none","unset"]},"-webkit-transform":{"isInherited":false,"supports":[],"values":["inherit","initial","unset"]},"-webkit-transform-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-transform-style":{"isInherited":false,"supports":[],"values":["flat","inherit","initial","preserve-3d","unset"]},"-webkit-backface-visibility":{"isInherited":false,"supports":[],"values":["hidden","inherit","initial","unset","visible"]},"-webkit-perspective":{"isInherited":false,"supports":[6],"values":["inherit","initial","none","unset"]},"-webkit-perspective-origin":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-transition":{"isInherited":false,"supports":[9,10],"values":["all","cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","none","step-end","step-start","steps","unset"]},"-webkit-transition-delay":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-webkit-transition-duration":{"isInherited":false,"supports":[9],"values":["inherit","initial","unset"]},"-webkit-transition-property":{"isInherited":false,"supports":[],"values":["all","inherit","initial","none","unset"]},"-webkit-transition-timing-function":{"isInherited":false,"supports":[10],"values":["cubic-bezier","ease","ease-in","ease-in-out","ease-out","inherit","initial","linear","step-end","step-start","steps","unset"]},"-webkit-border-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-top-left-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-top-right-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-bottom-left-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-bottom-right-radius":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-background-clip":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","padding-box","text","unset"]},"-webkit-background-origin":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","padding-box","unset"]},"-webkit-background-size":{"isInherited":false,"supports":[6,8],"values":["inherit","initial","unset"]},"-webkit-border-image":{"isInherited":false,"supports":[4,5,6,7,8,11],"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"]},"-webkit-box-shadow":{"isInherited":false,"supports":[2,6],"values":["inherit","initial","unset"]},"-webkit-box-sizing":{"isInherited":false,"supports":[],"values":["border-box","content-box","inherit","initial","unset"]},"-webkit-box-flex":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-box-ordinal-group":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-box-orient":{"isInherited":false,"supports":[],"values":["block-axis","horizontal","inherit","initial","inline-axis","unset","vertical"]},"-webkit-box-direction":{"isInherited":false,"supports":[],"values":["inherit","initial","normal","reverse","unset"]},"-webkit-box-align":{"isInherited":false,"supports":[],"values":["baseline","center","end","inherit","initial","start","stretch","unset"]},"-webkit-box-pack":{"isInherited":false,"supports":[],"values":["center","end","inherit","initial","justify","start","unset"]},"-webkit-flex-direction":{"isInherited":false,"supports":[],"values":["column","column-reverse","inherit","initial","row","row-reverse","unset"]},"-webkit-flex-wrap":{"isInherited":false,"supports":[],"values":["inherit","initial","nowrap","unset","wrap","wrap-reverse"]},"-webkit-flex-flow":{"isInherited":false,"supports":[],"values":["column","column-reverse","inherit","initial","nowrap","row","row-reverse","unset","wrap","wrap-reverse"]},"-webkit-order":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-flex":{"isInherited":false,"supports":[6,7,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"-webkit-flex-grow":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-flex-shrink":{"isInherited":false,"supports":[7],"values":["inherit","initial","unset"]},"-webkit-flex-basis":{"isInherited":false,"supports":[6,8],"values":["-moz-available","-moz-calc","-moz-fit-content","-moz-max-content","-moz-min-content","auto","calc","inherit","initial","unset"]},"-webkit-justify-content":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","space-around","space-between","space-evenly","start","stretch","unset"]},"-webkit-align-items":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"-webkit-align-self":{"isInherited":false,"supports":[],"values":["auto","baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","self-end","self-start","start","stretch","unset"]},"-webkit-align-content":{"isInherited":false,"supports":[],"values":["baseline","center","end","flex-end","flex-start","inherit","initial","last-baseline","left","normal","right","space-around","space-between","space-evenly","start","stretch","unset"]},"-webkit-user-select":{"isInherited":false,"supports":[],"values":["-moz-all","-moz-none","-moz-text","all","auto","element","elements","inherit","initial","none","text","toggle","tri-state","unset"]},"-webkit-mask":{"isInherited":false,"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","add","alpha","border-box","content-box","exclude","inherit","initial","intersect","linear-gradient","luminance","match-source","no-repeat","none","padding-box","radial-gradient","repeat","repeat-x","repeat-y","repeating-linear-gradient","repeating-radial-gradient","round","space","subtract","unset","url"],"supports":[4,5,6,8,11]},"-webkit-mask-clip":{"isInherited":false,"values":["border-box","content-box","inherit","initial","padding-box","unset"],"supports":[]},"-webkit-mask-composite":{"isInherited":false,"values":["add","exclude","inherit","initial","intersect","subtract","unset"],"supports":[]},"-webkit-mask-image":{"isInherited":false,"values":["-moz-element","-moz-image-rect","-moz-linear-gradient","-moz-radial-gradient","-moz-repeating-linear-gradient","-moz-repeating-radial-gradient","inherit","initial","linear-gradient","none","radial-gradient","repeating-linear-gradient","repeating-radial-gradient","unset","url"],"supports":[4,5,11]},"-webkit-mask-origin":{"isInherited":false,"values":["border-box","content-box","inherit","initial","padding-box","unset"],"supports":[]},"-webkit-mask-position":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"-webkit-mask-position-x":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"-webkit-mask-position-y":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]},"-webkit-mask-repeat":{"isInherited":false,"values":["inherit","initial","no-repeat","repeat","repeat-x","repeat-y","round","space","unset"],"supports":[]},"-webkit-mask-size":{"isInherited":false,"values":["inherit","initial","unset"],"supports":[6,8]}};
	/*eslint-enable */

	exports.CSS_PROPERTIES_DB = {
	  properties: exports.CSS_PROPERTIES,
	  pseudoElements: exports.PSEUDO_ELEMENTS
	};


/***/ },
/* 30 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// /!\  Auto-generated from nsColorNameList.h.
	// This should be kept in sync with that list.
	// test_cssColorDatabase.js tries to enforce this.

	const cssColors = {
	  aliceblue: [240, 248, 255, 1],
	  antiquewhite: [250, 235, 215, 1],
	  aqua: [0, 255, 255, 1],
	  aquamarine: [127, 255, 212, 1],
	  azure: [240, 255, 255, 1],
	  beige: [245, 245, 220, 1],
	  bisque: [255, 228, 196, 1],
	  black: [0, 0, 0, 1],
	  blanchedalmond: [255, 235, 205, 1],
	  blue: [0, 0, 255, 1],
	  blueviolet: [138, 43, 226, 1],
	  brown: [165, 42, 42, 1],
	  burlywood: [222, 184, 135, 1],
	  cadetblue: [95, 158, 160, 1],
	  chartreuse: [127, 255, 0, 1],
	  chocolate: [210, 105, 30, 1],
	  coral: [255, 127, 80, 1],
	  cornflowerblue: [100, 149, 237, 1],
	  cornsilk: [255, 248, 220, 1],
	  crimson: [220, 20, 60, 1],
	  cyan: [0, 255, 255, 1],
	  darkblue: [0, 0, 139, 1],
	  darkcyan: [0, 139, 139, 1],
	  darkgoldenrod: [184, 134, 11, 1],
	  darkgray: [169, 169, 169, 1],
	  darkgreen: [0, 100, 0, 1],
	  darkgrey: [169, 169, 169, 1],
	  darkkhaki: [189, 183, 107, 1],
	  darkmagenta: [139, 0, 139, 1],
	  darkolivegreen: [85, 107, 47, 1],
	  darkorange: [255, 140, 0, 1],
	  darkorchid: [153, 50, 204, 1],
	  darkred: [139, 0, 0, 1],
	  darksalmon: [233, 150, 122, 1],
	  darkseagreen: [143, 188, 143, 1],
	  darkslateblue: [72, 61, 139, 1],
	  darkslategray: [47, 79, 79, 1],
	  darkslategrey: [47, 79, 79, 1],
	  darkturquoise: [0, 206, 209, 1],
	  darkviolet: [148, 0, 211, 1],
	  deeppink: [255, 20, 147, 1],
	  deepskyblue: [0, 191, 255, 1],
	  dimgray: [105, 105, 105, 1],
	  dimgrey: [105, 105, 105, 1],
	  dodgerblue: [30, 144, 255, 1],
	  firebrick: [178, 34, 34, 1],
	  floralwhite: [255, 250, 240, 1],
	  forestgreen: [34, 139, 34, 1],
	  fuchsia: [255, 0, 255, 1],
	  gainsboro: [220, 220, 220, 1],
	  ghostwhite: [248, 248, 255, 1],
	  gold: [255, 215, 0, 1],
	  goldenrod: [218, 165, 32, 1],
	  gray: [128, 128, 128, 1],
	  grey: [128, 128, 128, 1],
	  green: [0, 128, 0, 1],
	  greenyellow: [173, 255, 47, 1],
	  honeydew: [240, 255, 240, 1],
	  hotpink: [255, 105, 180, 1],
	  indianred: [205, 92, 92, 1],
	  indigo: [75, 0, 130, 1],
	  ivory: [255, 255, 240, 1],
	  khaki: [240, 230, 140, 1],
	  lavender: [230, 230, 250, 1],
	  lavenderblush: [255, 240, 245, 1],
	  lawngreen: [124, 252, 0, 1],
	  lemonchiffon: [255, 250, 205, 1],
	  lightblue: [173, 216, 230, 1],
	  lightcoral: [240, 128, 128, 1],
	  lightcyan: [224, 255, 255, 1],
	  lightgoldenrodyellow: [250, 250, 210, 1],
	  lightgray: [211, 211, 211, 1],
	  lightgreen: [144, 238, 144, 1],
	  lightgrey: [211, 211, 211, 1],
	  lightpink: [255, 182, 193, 1],
	  lightsalmon: [255, 160, 122, 1],
	  lightseagreen: [32, 178, 170, 1],
	  lightskyblue: [135, 206, 250, 1],
	  lightslategray: [119, 136, 153, 1],
	  lightslategrey: [119, 136, 153, 1],
	  lightsteelblue: [176, 196, 222, 1],
	  lightyellow: [255, 255, 224, 1],
	  lime: [0, 255, 0, 1],
	  limegreen: [50, 205, 50, 1],
	  linen: [250, 240, 230, 1],
	  magenta: [255, 0, 255, 1],
	  maroon: [128, 0, 0, 1],
	  mediumaquamarine: [102, 205, 170, 1],
	  mediumblue: [0, 0, 205, 1],
	  mediumorchid: [186, 85, 211, 1],
	  mediumpurple: [147, 112, 219, 1],
	  mediumseagreen: [60, 179, 113, 1],
	  mediumslateblue: [123, 104, 238, 1],
	  mediumspringgreen: [0, 250, 154, 1],
	  mediumturquoise: [72, 209, 204, 1],
	  mediumvioletred: [199, 21, 133, 1],
	  midnightblue: [25, 25, 112, 1],
	  mintcream: [245, 255, 250, 1],
	  mistyrose: [255, 228, 225, 1],
	  moccasin: [255, 228, 181, 1],
	  navajowhite: [255, 222, 173, 1],
	  navy: [0, 0, 128, 1],
	  oldlace: [253, 245, 230, 1],
	  olive: [128, 128, 0, 1],
	  olivedrab: [107, 142, 35, 1],
	  orange: [255, 165, 0, 1],
	  orangered: [255, 69, 0, 1],
	  orchid: [218, 112, 214, 1],
	  palegoldenrod: [238, 232, 170, 1],
	  palegreen: [152, 251, 152, 1],
	  paleturquoise: [175, 238, 238, 1],
	  palevioletred: [219, 112, 147, 1],
	  papayawhip: [255, 239, 213, 1],
	  peachpuff: [255, 218, 185, 1],
	  peru: [205, 133, 63, 1],
	  pink: [255, 192, 203, 1],
	  plum: [221, 160, 221, 1],
	  powderblue: [176, 224, 230, 1],
	  purple: [128, 0, 128, 1],
	  rebeccapurple: [102, 51, 153, 1],
	  red: [255, 0, 0, 1],
	  rosybrown: [188, 143, 143, 1],
	  royalblue: [65, 105, 225, 1],
	  saddlebrown: [139, 69, 19, 1],
	  salmon: [250, 128, 114, 1],
	  sandybrown: [244, 164, 96, 1],
	  seagreen: [46, 139, 87, 1],
	  seashell: [255, 245, 238, 1],
	  sienna: [160, 82, 45, 1],
	  silver: [192, 192, 192, 1],
	  skyblue: [135, 206, 235, 1],
	  slateblue: [106, 90, 205, 1],
	  slategray: [112, 128, 144, 1],
	  slategrey: [112, 128, 144, 1],
	  snow: [255, 250, 250, 1],
	  springgreen: [0, 255, 127, 1],
	  steelblue: [70, 130, 180, 1],
	  tan: [210, 180, 140, 1],
	  teal: [0, 128, 128, 1],
	  thistle: [216, 191, 216, 1],
	  tomato: [255, 99, 71, 1],
	  turquoise: [64, 224, 208, 1],
	  violet: [238, 130, 238, 1],
	  wheat: [245, 222, 179, 1],
	  white: [255, 255, 255, 1],
	  whitesmoke: [245, 245, 245, 1],
	  yellow: [255, 255, 0, 1],
	  yellowgreen: [154, 205, 50, 1],
	};

	exports.cssColors = cssColors;


/***/ },
/* 31 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  ELEMENT_NODE: 1,
	  ATTRIBUTE_NODE: 2,
	  TEXT_NODE: 3,
	  CDATA_SECTION_NODE: 4,
	  ENTITY_REFERENCE_NODE: 5,
	  ENTITY_NODE: 6,
	  PROCESSING_INSTRUCTION_NODE: 7,
	  COMMENT_NODE: 8,
	  DOCUMENT_NODE: 9,
	  DOCUMENT_TYPE_NODE: 10,
	  DOCUMENT_FRAGMENT_NODE: 11,
	  NOTATION_NODE: 12,

	  // DocumentPosition
	  DOCUMENT_POSITION_DISCONNECTED: 0x01,
	  DOCUMENT_POSITION_PRECEDING: 0x02,
	  DOCUMENT_POSITION_FOLLOWING: 0x04,
	  DOCUMENT_POSITION_CONTAINS: 0x08,
	  DOCUMENT_POSITION_CONTAINED_BY: 0x10,
	  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20
	}


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Telemetry.
	 *
	 * To add metrics for a tool:
	 *
	 * 1. Create count, flag, and exponential entries in
	 *    toolkit/components/telemetry/Histograms.json. Each type is optional but it
	 *    is best if all three can be included.
	 *
	 * 2. Add your chart entries to devtools/client/shared/telemetry.js
	 *    (Telemetry.prototype._histograms):
	 *    mytoolname: {
	 *      histogram: "DEVTOOLS_MYTOOLNAME_OPENED_COUNT",
	 *      timerHistogram: "DEVTOOLS_MYTOOLNAME_TIME_ACTIVE_SECONDS"
	 *    },
	 *
	 * 3. Include this module at the top of your tool. Use:
	 *      let Telemetry = require("devtools/client/shared/telemetry")
	 *
	 * 4. Create a telemetry instance in your tool's constructor:
	 *      this._telemetry = new Telemetry();
	 *
	 * 5. When your tool is opened call:
	 *      this._telemetry.toolOpened("mytoolname");
	 *
	 * 6. When your tool is closed call:
	 *      this._telemetry.toolClosed("mytoolname");
	 *
	 * Note:
	 * You can view telemetry stats for your local Firefox instance via
	 * about:telemetry.
	 *
	 * You can view telemetry stats for large groups of Firefox users at
	 * telemetry.mozilla.org.
	 */

	"use strict";

	const TOOLS_OPENED_PREF = "devtools.telemetry.tools.opened.version";

	function Telemetry() {
	  // Bind pretty much all functions so that callers do not need to.
	  this.toolOpened = this.toolOpened.bind(this);
	  this.toolClosed = this.toolClosed.bind(this);
	  this.log = this.log.bind(this);
	  this.logOncePerBrowserVersion = this.logOncePerBrowserVersion.bind(this);
	  this.destroy = this.destroy.bind(this);

	  this._timers = new Map();
	}

	module.exports = Telemetry;

	var Services = __webpack_require__(1);

	Telemetry.prototype = {
	  _histograms: {
	    toolbox: {
	      histogram: "DEVTOOLS_TOOLBOX_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_TOOLBOX_TIME_ACTIVE_SECONDS"
	    },
	    options: {
	      histogram: "DEVTOOLS_OPTIONS_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_OPTIONS_TIME_ACTIVE_SECONDS"
	    },
	    webconsole: {
	      histogram: "DEVTOOLS_WEBCONSOLE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_WEBCONSOLE_TIME_ACTIVE_SECONDS"
	    },
	    browserconsole: {
	      histogram: "DEVTOOLS_BROWSERCONSOLE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_BROWSERCONSOLE_TIME_ACTIVE_SECONDS"
	    },
	    inspector: {
	      histogram: "DEVTOOLS_INSPECTOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_INSPECTOR_TIME_ACTIVE_SECONDS"
	    },
	    ruleview: {
	      histogram: "DEVTOOLS_RULEVIEW_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_RULEVIEW_TIME_ACTIVE_SECONDS"
	    },
	    computedview: {
	      histogram: "DEVTOOLS_COMPUTEDVIEW_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_COMPUTEDVIEW_TIME_ACTIVE_SECONDS"
	    },
	    fontinspector: {
	      histogram: "DEVTOOLS_FONTINSPECTOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_FONTINSPECTOR_TIME_ACTIVE_SECONDS"
	    },
	    animationinspector: {
	      histogram: "DEVTOOLS_ANIMATIONINSPECTOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_ANIMATIONINSPECTOR_TIME_ACTIVE_SECONDS"
	    },
	    jsdebugger: {
	      histogram: "DEVTOOLS_JSDEBUGGER_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_JSDEBUGGER_TIME_ACTIVE_SECONDS"
	    },
	    jsbrowserdebugger: {
	      histogram: "DEVTOOLS_JSBROWSERDEBUGGER_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_JSBROWSERDEBUGGER_TIME_ACTIVE_SECONDS"
	    },
	    styleeditor: {
	      histogram: "DEVTOOLS_STYLEEDITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_STYLEEDITOR_TIME_ACTIVE_SECONDS"
	    },
	    shadereditor: {
	      histogram: "DEVTOOLS_SHADEREDITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_SHADEREDITOR_TIME_ACTIVE_SECONDS"
	    },
	    webaudioeditor: {
	      histogram: "DEVTOOLS_WEBAUDIOEDITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_WEBAUDIOEDITOR_TIME_ACTIVE_SECONDS"
	    },
	    canvasdebugger: {
	      histogram: "DEVTOOLS_CANVASDEBUGGER_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_CANVASDEBUGGER_TIME_ACTIVE_SECONDS"
	    },
	    performance: {
	      histogram: "DEVTOOLS_JSPROFILER_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_JSPROFILER_TIME_ACTIVE_SECONDS"
	    },
	    memory: {
	      histogram: "DEVTOOLS_MEMORY_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_MEMORY_TIME_ACTIVE_SECONDS"
	    },
	    netmonitor: {
	      histogram: "DEVTOOLS_NETMONITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_NETMONITOR_TIME_ACTIVE_SECONDS"
	    },
	    storage: {
	      histogram: "DEVTOOLS_STORAGE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_STORAGE_TIME_ACTIVE_SECONDS"
	    },
	    paintflashing: {
	      histogram: "DEVTOOLS_PAINTFLASHING_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_PAINTFLASHING_TIME_ACTIVE_SECONDS"
	    },
	    scratchpad: {
	      histogram: "DEVTOOLS_SCRATCHPAD_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_SCRATCHPAD_TIME_ACTIVE_SECONDS"
	    },
	    "scratchpad-window": {
	      histogram: "DEVTOOLS_SCRATCHPAD_WINDOW_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_SCRATCHPAD_WINDOW_TIME_ACTIVE_SECONDS"
	    },
	    responsive: {
	      histogram: "DEVTOOLS_RESPONSIVE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_RESPONSIVE_TIME_ACTIVE_SECONDS"
	    },
	    eyedropper: {
	      histogram: "DEVTOOLS_EYEDROPPER_OPENED_COUNT",
	    },
	    menueyedropper: {
	      histogram: "DEVTOOLS_MENU_EYEDROPPER_OPENED_COUNT",
	    },
	    pickereyedropper: {
	      histogram: "DEVTOOLS_PICKER_EYEDROPPER_OPENED_COUNT",
	    },
	    toolbareyedropper: {
	      histogram: "DEVTOOLS_TOOLBAR_EYEDROPPER_OPENED_COUNT",
	    },
	    developertoolbar: {
	      histogram: "DEVTOOLS_DEVELOPERTOOLBAR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_DEVELOPERTOOLBAR_TIME_ACTIVE_SECONDS"
	    },
	    aboutdebugging: {
	      histogram: "DEVTOOLS_ABOUTDEBUGGING_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_ABOUTDEBUGGING_TIME_ACTIVE_SECONDS"
	    },
	    webide: {
	      histogram: "DEVTOOLS_WEBIDE_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_WEBIDE_TIME_ACTIVE_SECONDS"
	    },
	    webideProjectEditor: {
	      histogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_TIME_ACTIVE_SECONDS"
	    },
	    webideProjectEditorSave: {
	      histogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_SAVE_COUNT",
	    },
	    webideNewProject: {
	      histogram: "DEVTOOLS_WEBIDE_NEW_PROJECT_COUNT",
	    },
	    webideImportProject: {
	      histogram: "DEVTOOLS_WEBIDE_IMPORT_PROJECT_COUNT",
	    },
	    custom: {
	      histogram: "DEVTOOLS_CUSTOM_OPENED_COUNT",
	      timerHistogram: "DEVTOOLS_CUSTOM_TIME_ACTIVE_SECONDS"
	    },
	    reloadAddonInstalled: {
	      histogram: "DEVTOOLS_RELOAD_ADDON_INSTALLED_COUNT",
	    },
	    reloadAddonReload: {
	      histogram: "DEVTOOLS_RELOAD_ADDON_RELOAD_COUNT",
	    },
	  },

	  /**
	   * Add an entry to a histogram.
	   *
	   * @param  {String} id
	   *         Used to look up the relevant histogram ID and log true to that
	   *         histogram.
	   */
	  toolOpened: function (id) {
	    let charts = this._histograms[id] || this._histograms.custom;

	    if (charts.histogram) {
	      this.log(charts.histogram, true);
	    }
	    if (charts.timerHistogram) {
	      this.startTimer(charts.timerHistogram);
	    }
	  },

	  /**
	   * Record that an action occurred.  Aliases to `toolOpened`, so it's just for
	   * readability at the call site for cases where we aren't actually opening
	   * tools.
	   */
	  actionOccurred(id) {
	    this.toolOpened(id);
	  },

	  toolClosed: function (id) {
	    let charts = this._histograms[id];

	    if (!charts || !charts.timerHistogram) {
	      return;
	    }

	    this.stopTimer(charts.timerHistogram);
	  },

	  /**
	   * Record the start time for a timing-based histogram entry.
	   *
	   * @param String histogramId
	   *        Histogram in which the data is to be stored.
	   */
	  startTimer: function (histogramId) {
	    this._timers.set(histogramId, new Date());
	  },

	  /**
	   * Stop the timer and log elasped time for a timing-based histogram entry.
	   *
	   * @param String histogramId
	   *        Histogram in which the data is to be stored.
	   * @param String key [optional]
	   *        Optional key for a keyed histogram.
	   */
	  stopTimer: function (histogramId, key) {
	    let startTime = this._timers.get(histogramId);
	    if (startTime) {
	      let time = (new Date() - startTime) / 1000;
	      if (!key) {
	        this.log(histogramId, time);
	      } else {
	        this.logKeyed(histogramId, key, time);
	      }
	      this._timers.delete(histogramId);
	    }
	  },

	  /**
	   * Log a value to a histogram.
	   *
	   * @param  {String} histogramId
	   *         Histogram in which the data is to be stored.
	   * @param  value
	   *         Value to store.
	   */
	  log: function (histogramId, value) {
	    if (histogramId) {
	      try {
	        let histogram = Services.telemetry.getHistogramById(histogramId);
	        histogram.add(value);
	      } catch (e) {
	        (console.log)("Warning: An attempt was made to write to the " + histogramId +
	             " histogram, which is not defined in Histograms.json\n");
	      }
	    }
	  },

	  /**
	   * Log a value to a keyed histogram.
	   *
	   * @param  {String} histogramId
	   *         Histogram in which the data is to be stored.
	   * @param  {String} key
	   *         The key within the single histogram.
	   * @param  value
	   *         Value to store.
	   */
	  logKeyed: function (histogramId, key, value) {
	    if (histogramId) {
	      try {
	        let histogram = Services.telemetry.getKeyedHistogramById(histogramId);
	        histogram.add(key, value);
	      } catch (e) {
	        (console.log)("Warning: An attempt was made to write to the " + histogramId +
	             " histogram, which is not defined in Histograms.json\n");
	      }
	    }
	  },

	  /**
	   * Log info about usage once per browser version. This allows us to discover
	   * how many individual users are using our tools for each browser version.
	   *
	   * @param  {String} perUserHistogram
	   *         Histogram in which the data is to be stored.
	   */
	  logOncePerBrowserVersion: function (perUserHistogram, value) {
	    let currentVersion = Services.appinfo.version;
	    let latest = Services.prefs.getCharPref(TOOLS_OPENED_PREF);
	    let latestObj = JSON.parse(latest);

	    let lastVersionHistogramUpdated = latestObj[perUserHistogram];

	    if (typeof lastVersionHistogramUpdated == "undefined" ||
	        lastVersionHistogramUpdated !== currentVersion) {
	      latestObj[perUserHistogram] = currentVersion;
	      latest = JSON.stringify(latestObj);
	      Services.prefs.setCharPref(TOOLS_OPENED_PREF, latest);
	      this.log(perUserHistogram, value);
	    }
	  },

	  destroy: function () {
	    for (let histogramId of this._timers.keys()) {
	      this.stopTimer(histogramId);
	    }
	  }
	};


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const EventEmitter = __webpack_require__(6);

	/**
	 * A partial implementation of the Menu API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu.md.
	 *
	 * Extra features:
	 *  - Emits an 'open' and 'close' event when the menu is opened/closed

	 * @param String id (non standard)
	 *        Needed so tests can confirm the XUL implementation is working
	 */
	function Menu({ id = null } = {}) {
	  this.menuitems = [];
	  this.id = id;

	  Object.defineProperty(this, "items", {
	    get() {
	      return this.menuitems;
	    }
	  });

	  EventEmitter.decorate(this);
	}

	/**
	 * Add an item to the end of the Menu
	 *
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.append = function (menuItem) {
	  this.menuitems.push(menuItem);
	};

	/**
	 * Add an item to a specified position in the menu
	 *
	 * @param {int} pos
	 * @param {MenuItem} menuItem
	 */
	Menu.prototype.insert = function (pos, menuItem) {
	  throw Error("Not implemented");
	};

	/**
	 * Show the Menu at a specified location on the screen
	 *
	 * Missing features:
	 *   - browserWindow - BrowserWindow (optional) - Default is null.
	 *   - positioningItem Number - (optional) OS X
	 *
	 * @param {int} screenX
	 * @param {int} screenY
	 * @param Toolbox toolbox (non standard)
	 *        Needed so we in which window to inject XUL
	 */
	Menu.prototype.popup = function (screenX, screenY, toolbox) {
	  let doc = toolbox.doc;
	  let popupset = doc.querySelector("popupset");
	  // See bug 1285229, on Windows, opening the same popup multiple times in a
	  // row ends up duplicating the popup. The newly inserted popup doesn't
	  // dismiss the old one. So remove any previously displayed popup before
	  // opening a new one.
	  let popup = popupset.querySelector("menupopup[menu-api=\"true\"]");
	  if (popup) {
	    popup.hidePopup();
	  }

	  popup = doc.createElement("menupopup");
	  popup.setAttribute("menu-api", "true");

	  if (this.id) {
	    popup.id = this.id;
	  }
	  this._createMenuItems(popup);

	  // Remove the menu from the DOM once it's hidden.
	  popup.addEventListener("popuphidden", (e) => {
	    if (e.target === popup) {
	      popup.remove();
	      this.emit("close");
	    }
	  });

	  popup.addEventListener("popupshown", (e) => {
	    if (e.target === popup) {
	      this.emit("open");
	    }
	  });

	  popupset.appendChild(popup);
	  popup.openPopupAtScreen(screenX, screenY, true);
	};

	Menu.prototype._createMenuItems = function (parent) {
	  let doc = parent.ownerDocument;
	  this.menuitems.forEach(item => {
	    if (!item.visible) {
	      return;
	    }

	    if (item.submenu) {
	      let menupopup = doc.createElement("menupopup");
	      item.submenu._createMenuItems(menupopup);

	      let menu = doc.createElement("menu");
	      menu.appendChild(menupopup);
	      menu.setAttribute("label", item.label);
	      if (item.disabled) {
	        menu.setAttribute("disabled", "true");
	      }
	      if (item.accesskey) {
	        menu.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menu.id = item.id;
	      }
	      parent.appendChild(menu);
	    } else if (item.type === "separator") {
	      let menusep = doc.createElement("menuseparator");
	      parent.appendChild(menusep);
	    } else {
	      let menuitem = doc.createElement("menuitem");
	      menuitem.setAttribute("label", item.label);
	      menuitem.addEventListener("command", () => {
	        item.click();
	      });

	      if (item.type === "checkbox") {
	        menuitem.setAttribute("type", "checkbox");
	      }
	      if (item.type === "radio") {
	        menuitem.setAttribute("type", "radio");
	      }
	      if (item.disabled) {
	        menuitem.setAttribute("disabled", "true");
	      }
	      if (item.checked) {
	        menuitem.setAttribute("checked", "true");
	      }
	      if (item.accesskey) {
	        menuitem.setAttribute("accesskey", item.accesskey);
	      }
	      if (item.id) {
	        menuitem.id = item.id;
	      }

	      parent.appendChild(menuitem);
	    }
	  });
	};

	Menu.setApplicationMenu = () => {
	  throw Error("Not implemented");
	};

	Menu.sendActionToFirstResponder = () => {
	  throw Error("Not implemented");
	};

	Menu.buildFromTemplate = () => {
	  throw Error("Not implemented");
	};

	module.exports = Menu;


/***/ },
/* 34 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * A partial implementation of the MenuItem API provided by electron:
	 * https://github.com/electron/electron/blob/master/docs/api/menu-item.md.
	 *
	 * Missing features:
	 *   - id String - Unique within a single menu. If defined then it can be used
	 *                 as a reference to this item by the position attribute.
	 *   - role String - Define the action of the menu item; when specified the
	 *                   click property will be ignored
	 *   - sublabel String
	 *   - accelerator Accelerator
	 *   - icon NativeImage
	 *   - position String - This field allows fine-grained definition of the
	 *                       specific location within a given menu.
	 *
	 * Implemented features:
	 *  @param Object options
	 *    Function click
	 *      Will be called with click(menuItem, browserWindow) when the menu item
	 *       is clicked
	 *    String type
	 *      Can be normal, separator, submenu, checkbox or radio
	 *    String label
	 *    Boolean enabled
	 *      If false, the menu item will be greyed out and unclickable.
	 *    Boolean checked
	 *      Should only be specified for checkbox or radio type menu items.
	 *    Menu submenu
	 *      Should be specified for submenu type menu items. If submenu is specified,
	 *      the type: 'submenu' can be omitted. If the value is not a Menu then it
	 *      will be automatically converted to one using Menu.buildFromTemplate.
	 *    Boolean visible
	 *      If false, the menu item will be entirely hidden.
	 */
	function MenuItem({
	    accesskey = null,
	    checked = false,
	    click = () => {},
	    disabled = false,
	    label = "",
	    id = null,
	    submenu = null,
	    type = "normal",
	    visible = true,
	} = { }) {
	  this.accesskey = accesskey;
	  this.checked = checked;
	  this.click = click;
	  this.disabled = disabled;
	  this.id = id;
	  this.label = label;
	  this.submenu = submenu;
	  this.type = type;
	  this.visible = visible;
	}

	module.exports = MenuItem;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/* globals StopIteration */

	"use strict";

	const ToolDefinitions = __webpack_require__(36).Tools;
	const CssLogic = __webpack_require__(173);
	const {ELEMENT_STYLE} = __webpack_require__(175);
	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);
	const Services = __webpack_require__(1);
	const {OutputParser} = __webpack_require__(177);
	const {PrefObserver, PREF_ORIG_SOURCES} = __webpack_require__(180);
	const {createChild} = __webpack_require__(181);
	const {gDevTools} = __webpack_require__(38);
	const {getCssProperties} = __webpack_require__(16);

	const overlays = __webpack_require__(183);
	const StyleInspectorMenu = __webpack_require__(206);
	const {KeyShortcuts} = __webpack_require__(13);
	const {LayoutView} = __webpack_require__(210);
	const clipboardHelper = __webpack_require__(207);

	const STYLE_INSPECTOR_PROPERTIES = "devtools-shared/locale/styleinspector.properties";
	const {LocalizationHelper} = __webpack_require__(56);
	const STYLE_INSPECTOR_L10N = new LocalizationHelper(STYLE_INSPECTOR_PROPERTIES);

	const FILTER_CHANGED_TIMEOUT = 150;
	const HTML_NS = "http://www.w3.org/1999/xhtml";

	/**
	 * Helper for long-running processes that should yield occasionally to
	 * the mainloop.
	 *
	 * @param {Window} win
	 *        Timeouts will be set on this window when appropriate.
	 * @param {Generator} generator
	 *        Will iterate this generator.
	 * @param {Object} options
	 *        Options for the update process:
	 *          onItem {function} Will be called with the value of each iteration.
	 *          onBatch {function} Will be called after each batch of iterations,
	 *            before yielding to the main loop.
	 *          onDone {function} Will be called when iteration is complete.
	 *          onCancel {function} Will be called if the process is canceled.
	 *          threshold {int} How long to process before yielding, in ms.
	 */
	function UpdateProcess(win, generator, options) {
	  this.win = win;
	  this.iter = _Iterator(generator);
	  this.onItem = options.onItem || function () {};
	  this.onBatch = options.onBatch || function () {};
	  this.onDone = options.onDone || function () {};
	  this.onCancel = options.onCancel || function () {};
	  this.threshold = options.threshold || 45;

	  this.canceled = false;
	}

	UpdateProcess.prototype = {
	  /**
	   * Schedule a new batch on the main loop.
	   */
	  schedule: function () {
	    if (this.canceled) {
	      return;
	    }
	    this._timeout = setTimeout(this._timeoutHandler.bind(this), 0);
	  },

	  /**
	   * Cancel the running process.  onItem will not be called again,
	   * and onCancel will be called.
	   */
	  cancel: function () {
	    if (this._timeout) {
	      clearTimeout(this._timeout);
	      this._timeout = 0;
	    }
	    this.canceled = true;
	    this.onCancel();
	  },

	  _timeoutHandler: function () {
	    this._timeout = null;
	    try {
	      this._runBatch();
	      this.schedule();
	    } catch (e) {
	      if (e instanceof StopIteration) {
	        this.onBatch();
	        this.onDone();
	        return;
	      }
	      console.error(e);
	      throw e;
	    }
	  },

	  _runBatch: function () {
	    let time = Date.now();
	    while (!this.canceled) {
	      // Continue until iter.next() throws...
	      let next = this.iter.next();
	      this.onItem(next[1]);
	      if ((Date.now() - time) > this.threshold) {
	        this.onBatch();
	        return;
	      }
	    }
	  }
	};

	/**
	 * CssComputedView is a panel that manages the display of a table
	 * sorted by style. There should be one instance of CssComputedView
	 * per style display (of which there will generally only be one).
	 *
	 * @param {Inspector} inspector
	 *        Inspector toolbox panel
	 * @param {Document} document
	 *        The document that will contain the computed view.
	 * @param {PageStyleFront} pageStyle
	 *        Front for the page style actor that will be providing
	 *        the style information.
	 */
	function CssComputedView(inspector, document, pageStyle) {
	  this.inspector = inspector;
	  this.styleDocument = document;
	  this.styleWindow = this.styleDocument.defaultView;
	  this.pageStyle = pageStyle;

	  this.propertyViews = [];

	  let cssProperties = getCssProperties(inspector.toolbox);
	  this._outputParser = new OutputParser(document, cssProperties.supportsType);

	  // Create bound methods.
	  this.focusWindow = this.focusWindow.bind(this);
	  this._onContextMenu = this._onContextMenu.bind(this);
	  this._onClick = this._onClick.bind(this);
	  this._onCopy = this._onCopy.bind(this);
	  this._onFilterStyles = this._onFilterStyles.bind(this);
	  this._onClearSearch = this._onClearSearch.bind(this);
	  this._onIncludeBrowserStyles = this._onIncludeBrowserStyles.bind(this);
	  this._onFilterTextboxContextMenu =
	    this._onFilterTextboxContextMenu.bind(this);

	  let doc = this.styleDocument;
	  this.element = doc.getElementById("propertyContainer");
	  this.searchField = doc.getElementById("computedview-searchbox");
	  this.searchClearButton = doc.getElementById("computedview-searchinput-clear");
	  this.includeBrowserStylesCheckbox =
	    doc.getElementById("browser-style-checkbox");

	  this.shortcuts = new KeyShortcuts({ window: this.styleWindow });
	  this._onShortcut = this._onShortcut.bind(this);
	  this.shortcuts.on("CmdOrCtrl+F", this._onShortcut);
	  this.shortcuts.on("Escape", this._onShortcut);
	  this.styleDocument.addEventListener("mousedown", this.focusWindow);
	  this.element.addEventListener("click", this._onClick);
	  this.element.addEventListener("copy", this._onCopy);
	  this.element.addEventListener("contextmenu", this._onContextMenu);
	  this.searchField.addEventListener("input", this._onFilterStyles);
	  this.searchField.addEventListener("contextmenu",
	                                    this._onFilterTextboxContextMenu);
	  this.searchClearButton.addEventListener("click", this._onClearSearch);
	  this.includeBrowserStylesCheckbox.addEventListener("input",
	    this._onIncludeBrowserStyles);

	  this.searchClearButton.hidden = true;

	  // No results text.
	  this.noResults = this.styleDocument.getElementById("computedview-no-results");

	  // Refresh panel when color unit changed.
	  this._handlePrefChange = this._handlePrefChange.bind(this);
	  gDevTools.on("pref-changed", this._handlePrefChange);

	  // Refresh panel when pref for showing original sources changes
	  this._onSourcePrefChanged = this._onSourcePrefChanged.bind(this);
	  this._prefObserver = new PrefObserver("devtools.");
	  this._prefObserver.on(PREF_ORIG_SOURCES, this._onSourcePrefChanged);

	  // The element that we're inspecting, and the document that it comes from.
	  this._viewedElement = null;

	  this.createStyleViews();

	  this._contextmenu = new StyleInspectorMenu(this, { isRuleView: false });

	  // Add the tooltips and highlightersoverlay
	  this.tooltips = new overlays.TooltipsOverlay(this);
	  this.tooltips.addToView();

	  this.highlighters = new overlays.HighlightersOverlay(this);
	  this.highlighters.addToView();
	}

	/**
	 * Lookup a l10n string in the shared styleinspector string bundle.
	 *
	 * @param {String} name
	 *        The key to lookup.
	 * @returns {String} localized version of the given key.
	 */
	CssComputedView.l10n = function (name) {
	  try {
	    return STYLE_INSPECTOR_L10N.getStr(name);
	  } catch (ex) {
	    console.log("Error reading '" + name + "'");
	    throw new Error("l10n error with " + name);
	  }
	};

	CssComputedView.prototype = {
	  // Cache the list of properties that match the selected element.
	  _matchedProperties: null,

	  // Used for cancelling timeouts in the style filter.
	  _filterChangedTimeout: null,

	  // Holds the ID of the panelRefresh timeout.
	  _panelRefreshTimeout: null,

	  // Toggle for zebra striping
	  _darkStripe: true,

	  // Number of visible properties
	  numVisibleProperties: 0,

	  setPageStyle: function (pageStyle) {
	    this.pageStyle = pageStyle;
	  },

	  get includeBrowserStyles() {
	    return this.includeBrowserStylesCheckbox.checked;
	  },

	  _handlePrefChange: function (event, data) {
	    if (this._computed && (data.pref === "devtools.defaultColorUnit" ||
	        data.pref === PREF_ORIG_SOURCES)) {
	      this.refreshPanel();
	    }
	  },

	  /**
	   * Update the view with a new selected element. The CssComputedView panel
	   * will show the style information for the given element.
	   *
	   * @param {NodeFront} element
	   *        The highlighted node to get styles for.
	   * @returns a promise that will be resolved when highlighting is complete.
	   */
	  selectElement: function (element) {
	    if (!element) {
	      this._viewedElement = null;
	      this.noResults.hidden = false;

	      if (this._refreshProcess) {
	        this._refreshProcess.cancel();
	      }
	      // Hiding all properties
	      for (let propView of this.propertyViews) {
	        propView.refresh();
	      }
	      return promise.resolve(undefined);
	    }

	    if (element === this._viewedElement) {
	      return promise.resolve(undefined);
	    }

	    this._viewedElement = element;
	    this.refreshSourceFilter();

	    return this.refreshPanel();
	  },

	  /**
	   * Get the type of a given node in the computed-view
	   *
	   * @param {DOMNode} node
	   *        The node which we want information about
	   * @return {Object} The type information object contains the following props:
	   * - type {String} One of the VIEW_NODE_XXX_TYPE const in
	   *   style-inspector-overlays
	   * - value {Object} Depends on the type of the node
	   * returns null if the node isn't anything we care about
	   */
	  getNodeInfo: function (node) {
	    if (!node) {
	      return null;
	    }

	    let classes = node.classList;

	    // Check if the node isn't a selector first since this doesn't require
	    // walking the DOM
	    if (classes.contains("matched") ||
	        classes.contains("bestmatch") ||
	        classes.contains("parentmatch")) {
	      let selectorText = "";
	      for (let child of node.childNodes) {
	        if (child.nodeType === node.TEXT_NODE) {
	          selectorText += child.textContent;
	        }
	      }
	      return {
	        type: overlays.VIEW_NODE_SELECTOR_TYPE,
	        value: selectorText.trim()
	      };
	    }

	    // Walk up the nodes to find out where node is
	    let propertyView;
	    let propertyContent;
	    let parent = node;
	    while (parent.parentNode) {
	      if (parent.classList.contains("property-view")) {
	        propertyView = parent;
	        break;
	      }
	      if (parent.classList.contains("property-content")) {
	        propertyContent = parent;
	        break;
	      }
	      parent = parent.parentNode;
	    }
	    if (!propertyView && !propertyContent) {
	      return null;
	    }

	    let value, type;

	    // Get the property and value for a node that's a property name or value
	    let isHref = classes.contains("theme-link") && !classes.contains("link");
	    if (propertyView && (classes.contains("property-name") ||
	                         classes.contains("property-value") ||
	                         isHref)) {
	      value = {
	        property: parent.querySelector(".property-name").textContent,
	        value: parent.querySelector(".property-value").textContent
	      };
	    }
	    if (propertyContent && (classes.contains("other-property-value") ||
	                            isHref)) {
	      let view = propertyContent.previousSibling;
	      value = {
	        property: view.querySelector(".property-name").textContent,
	        value: node.textContent
	      };
	    }

	    // Get the type
	    if (classes.contains("property-name")) {
	      type = overlays.VIEW_NODE_PROPERTY_TYPE;
	    } else if (classes.contains("property-value") ||
	               classes.contains("other-property-value")) {
	      type = overlays.VIEW_NODE_VALUE_TYPE;
	    } else if (isHref) {
	      type = overlays.VIEW_NODE_IMAGE_URL_TYPE;
	      value.url = node.href;
	    } else {
	      return null;
	    }

	    return {type, value};
	  },

	  _createPropertyViews: function () {
	    if (this._createViewsPromise) {
	      return this._createViewsPromise;
	    }

	    let deferred = defer();
	    this._createViewsPromise = deferred.promise;

	    this.refreshSourceFilter();
	    this.numVisibleProperties = 0;
	    let fragment = this.styleDocument.createDocumentFragment();

	    this._createViewsProcess = new UpdateProcess(
	      this.styleWindow, CssComputedView.propertyNames, {
	        onItem: (propertyName) => {
	          // Per-item callback.
	          let propView = new PropertyView(this, propertyName);
	          fragment.appendChild(propView.buildMain());
	          fragment.appendChild(propView.buildSelectorContainer());

	          if (propView.visible) {
	            this.numVisibleProperties++;
	          }
	          this.propertyViews.push(propView);
	        },
	        onCancel: () => {
	          deferred.reject("_createPropertyViews cancelled");
	        },
	        onDone: () => {
	          // Completed callback.
	          this.element.appendChild(fragment);
	          this.noResults.hidden = this.numVisibleProperties > 0;
	          deferred.resolve(undefined);
	        }
	      }
	    );

	    this._createViewsProcess.schedule();
	    return deferred.promise;
	  },

	  /**
	   * Refresh the panel content.
	   */
	  refreshPanel: function () {
	    if (!this._viewedElement) {
	      return promise.resolve();
	    }

	    // Capture the current viewed element to return from the promise handler
	    // early if it changed
	    let viewedElement = this._viewedElement;

	    return promise.all([
	      this._createPropertyViews(),
	      this.pageStyle.getComputed(this._viewedElement, {
	        filter: this._sourceFilter,
	        onlyMatched: !this.includeBrowserStyles,
	        markMatched: true
	      })
	    ]).then(([, computed]) => {
	      if (viewedElement !== this._viewedElement) {
	        return promise.resolve();
	      }

	      this._matchedProperties = new Set();
	      for (let name in computed) {
	        if (computed[name].matched) {
	          this._matchedProperties.add(name);
	        }
	      }
	      this._computed = computed;

	      if (this._refreshProcess) {
	        this._refreshProcess.cancel();
	      }

	      this.noResults.hidden = true;

	      // Reset visible property count
	      this.numVisibleProperties = 0;

	      // Reset zebra striping.
	      this._darkStripe = true;

	      let deferred = defer();
	      this._refreshProcess = new UpdateProcess(
	        this.styleWindow, this.propertyViews, {
	          onItem: (propView) => {
	            propView.refresh();
	          },
	          onCancel: () => {
	            deferred.reject("_refreshProcess of computed view cancelled");
	          },
	          onDone: () => {
	            this._refreshProcess = null;
	            this.noResults.hidden = this.numVisibleProperties > 0;

	            if (this.searchField.value.length > 0 &&
	                !this.numVisibleProperties) {
	              this.searchField.classList
	                              .add("devtools-style-searchbox-no-match");
	            } else {
	              this.searchField.classList
	                              .remove("devtools-style-searchbox-no-match");
	            }

	            this.inspector.emit("computed-view-refreshed");
	            deferred.resolve(undefined);
	          }
	        }
	      );
	      this._refreshProcess.schedule();
	      return deferred.promise;
	    }).then(null, (err) => console.error(err));
	  },

	  /**
	   * Handle the shortcut events in the computed view.
	   */
	  _onShortcut: function (name, event) {
	    if (!event.target.closest("#sidebar-panel-computedview")) {
	      return;
	    }
	    // Handle the search box's keypress event. If the escape key is pressed,
	    // clear the search box field.
	    if (name === "Escape" && event.target === this.searchField &&
	        this._onClearSearch()) {
	      event.preventDefault();
	      event.stopPropagation();
	    } else if (name === "CmdOrCtrl+F") {
	      this.searchField.focus();
	      event.preventDefault();
	    }
	  },

	  /**
	   * Set the filter style search value.
	   * @param {String} value
	   *        The search value.
	   */
	  setFilterStyles: function (value = "") {
	    this.searchField.value = value;
	    this.searchField.focus();
	    this._onFilterStyles();
	  },

	  /**
	   * Called when the user enters a search term in the filter style search box.
	   */
	  _onFilterStyles: function () {
	    if (this._filterChangedTimeout) {
	      clearTimeout(this._filterChangedTimeout);
	    }

	    let filterTimeout = (this.searchField.value.length > 0)
	      ? FILTER_CHANGED_TIMEOUT : 0;
	    this.searchClearButton.hidden = this.searchField.value.length === 0;

	    this._filterChangedTimeout = setTimeout(() => {
	      if (this.searchField.value.length > 0) {
	        this.searchField.setAttribute("filled", true);
	        this.inspector.emit("computed-view-filtered", true);
	      } else {
	        this.searchField.removeAttribute("filled");
	        this.inspector.emit("computed-view-filtered", false);
	      }

	      this.refreshPanel();
	      this._filterChangeTimeout = null;
	    }, filterTimeout);
	  },

	  /**
	   * Context menu handler for filter style search box.
	   */
	  _onFilterTextboxContextMenu: function (event) {
	    try {
	      this.styleDocument.defaultView.focus();
	      let contextmenu = this.inspector.toolbox.textboxContextMenuPopup;
	      contextmenu.openPopupAtScreen(event.screenX, event.screenY, true);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  /**
	   * Called when the user clicks on the clear button in the filter style search
	   * box. Returns true if the search box is cleared and false otherwise.
	   */
	  _onClearSearch: function () {
	    if (this.searchField.value) {
	      this.setFilterStyles("");
	      return true;
	    }

	    return false;
	  },

	  /**
	   * The change event handler for the includeBrowserStyles checkbox.
	   */
	  _onIncludeBrowserStyles: function () {
	    this.refreshSourceFilter();
	    this.refreshPanel();
	  },

	  /**
	   * When includeBrowserStylesCheckbox.checked is false we only display
	   * properties that have matched selectors and have been included by the
	   * document or one of thedocument's stylesheets. If .checked is false we
	   * display all properties including those that come from UA stylesheets.
	   */
	  refreshSourceFilter: function () {
	    this._matchedProperties = null;
	    this._sourceFilter = this.includeBrowserStyles ?
	                                 CssLogic.FILTER.UA :
	                                 CssLogic.FILTER.USER;
	  },

	  _onSourcePrefChanged: function () {
	    for (let propView of this.propertyViews) {
	      propView.updateSourceLinks();
	    }
	    this.inspector.emit("computed-view-sourcelinks-updated");
	  },

	  /**
	   * The CSS as displayed by the UI.
	   */
	  createStyleViews: function () {
	    if (CssComputedView.propertyNames) {
	      return;
	    }

	    CssComputedView.propertyNames = [];

	    // Here we build and cache a list of css properties supported by the browser
	    // We could use any element but let's use the main document's root element
	    let styles = this.styleWindow
	      .getComputedStyle(this.styleDocument.documentElement);
	    let mozProps = [];
	    for (let i = 0, numStyles = styles.length; i < numStyles; i++) {
	      let prop = styles.item(i);
	      if (prop.startsWith("--")) {
	        // Skip any CSS variables used inside of browser CSS files
	        continue;
	      } else if (prop.startsWith("-")) {
	        mozProps.push(prop);
	      } else {
	        CssComputedView.propertyNames.push(prop);
	      }
	    }

	    CssComputedView.propertyNames.sort();
	    CssComputedView.propertyNames.push.apply(CssComputedView.propertyNames,
	      mozProps.sort());

	    this._createPropertyViews().then(null, e => {
	      if (!this._isDestroyed) {
	        console.warn("The creation of property views was cancelled because " +
	          "the computed-view was destroyed before it was done creating views");
	      } else {
	        console.error(e);
	      }
	    });
	  },

	  /**
	   * Get a set of properties that have matched selectors.
	   *
	   * @return {Set} If a property name is in the set, it has matching selectors.
	   */
	  get matchedProperties() {
	    return this._matchedProperties || new Set();
	  },

	  /**
	   * Focus the window on mousedown.
	   */
	  focusWindow: function () {
	    let win = this.styleDocument.defaultView;
	    win.focus();
	  },

	  /**
	   * Context menu handler.
	   */
	  _onContextMenu: function (event) {
	    this._contextmenu.show(event);
	  },

	  _onClick: function (event) {
	    let target = event.target;

	    if (target.nodeName === "a") {
	      event.stopPropagation();
	      event.preventDefault();
	      let browserWin = this.inspector.target.tab.ownerDocument.defaultView;
	      browserWin.openUILinkIn(target.href, "tab");
	    }
	  },

	  /**
	   * Callback for copy event. Copy selected text.
	   *
	   * @param {Event} event
	   *        copy event object.
	   */
	  _onCopy: function (event) {
	    this.copySelection();
	    event.preventDefault();
	  },

	  /**
	   * Copy the current selection to the clipboard
	   */
	  copySelection: function () {
	    try {
	      let win = this.styleDocument.defaultView;
	      let text = win.getSelection().toString().trim();

	      // Tidy up block headings by moving CSS property names and their
	      // values onto the same line and inserting a colon between them.
	      let textArray = text.split(/[\r\n]+/);
	      let result = "";

	      // Parse text array to output string.
	      if (textArray.length > 1) {
	        for (let prop of textArray) {
	          if (CssComputedView.propertyNames.indexOf(prop) !== -1) {
	            // Property name
	            result += prop;
	          } else {
	            // Property value
	            result += ": " + prop + ";\n";
	          }
	        }
	      } else {
	        // Short text fragment.
	        result = textArray[0];
	      }

	      clipboardHelper.copyString(result);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  /**
	   * Destructor for CssComputedView.
	   */
	  destroy: function () {
	    this._viewedElement = null;
	    this._outputParser = null;

	    gDevTools.off("pref-changed", this._handlePrefChange);

	    this._prefObserver.off(PREF_ORIG_SOURCES, this._onSourcePrefChanged);
	    this._prefObserver.destroy();

	    // Cancel tree construction
	    if (this._createViewsProcess) {
	      this._createViewsProcess.cancel();
	    }
	    if (this._refreshProcess) {
	      this._refreshProcess.cancel();
	    }

	    // Remove context menu
	    if (this._contextmenu) {
	      this._contextmenu.destroy();
	      this._contextmenu = null;
	    }

	    this.tooltips.destroy();
	    this.highlighters.destroy();

	    // Remove bound listeners
	    this.styleDocument.removeEventListener("mousedown", this.focusWindow);
	    this.element.removeEventListener("click", this._onClick);
	    this.element.removeEventListener("copy", this._onCopy);
	    this.element.removeEventListener("contextmenu", this._onContextMenu);
	    this.searchField.removeEventListener("input", this._onFilterStyles);
	    this.searchField.removeEventListener("contextmenu",
	                                         this._onFilterTextboxContextMenu);
	    this.searchClearButton.removeEventListener("click", this._onClearSearch);
	    this.includeBrowserStylesCheckbox.removeEventListener("input",
	      this._onIncludeBrowserStyles);

	    // Nodes used in templating
	    this.element = null;
	    this.panel = null;
	    this.searchField = null;
	    this.searchClearButton = null;
	    this.includeBrowserStylesCheckbox = null;

	    // Property views
	    for (let propView of this.propertyViews) {
	      propView.destroy();
	    }
	    this.propertyViews = null;

	    this.inspector = null;
	    this.styleDocument = null;
	    this.styleWindow = null;

	    this._isDestroyed = true;
	  }
	};

	function PropertyInfo(tree, name) {
	  this.tree = tree;
	  this.name = name;
	}

	PropertyInfo.prototype = {
	  get value() {
	    if (this.tree._computed) {
	      let value = this.tree._computed[this.name].value;
	      return value;
	    }
	    return null;
	  }
	};

	/**
	 * A container to give easy access to property data from the template engine.
	 *
	 * @param {CssComputedView} tree
	 *        The CssComputedView instance we are working with.
	 * @param {String} name
	 *        The CSS property name for which this PropertyView
	 *        instance will render the rules.
	 */
	function PropertyView(tree, name) {
	  this.tree = tree;
	  this.name = name;

	  this.link = "https://developer.mozilla.org/CSS/" + name;

	  this._propertyInfo = new PropertyInfo(tree, name);
	}

	PropertyView.prototype = {
	  // The parent element which contains the open attribute
	  element: null,

	  // Property header node
	  propertyHeader: null,

	  // Destination for property names
	  nameNode: null,

	  // Destination for property values
	  valueNode: null,

	  // Are matched rules expanded?
	  matchedExpanded: false,

	  // Matched selector container
	  matchedSelectorsContainer: null,

	  // Matched selector expando
	  matchedExpander: null,

	  // Cache for matched selector views
	  _matchedSelectorViews: null,

	  // The previously selected element used for the selector view caches
	  _prevViewedElement: null,

	  /**
	   * Get the computed style for the current property.
	   *
	   * @return {String} the computed style for the current property of the
	   * currently highlighted element.
	   */
	  get value() {
	    return this.propertyInfo.value;
	  },

	  /**
	   * An easy way to access the CssPropertyInfo behind this PropertyView.
	   */
	  get propertyInfo() {
	    return this._propertyInfo;
	  },

	  /**
	   * Does the property have any matched selectors?
	   */
	  get hasMatchedSelectors() {
	    return this.tree.matchedProperties.has(this.name);
	  },

	  /**
	   * Should this property be visible?
	   */
	  get visible() {
	    if (!this.tree._viewedElement) {
	      return false;
	    }

	    if (!this.tree.includeBrowserStyles && !this.hasMatchedSelectors) {
	      return false;
	    }

	    let searchTerm = this.tree.searchField.value.toLowerCase();
	    let isValidSearchTerm = searchTerm.trim().length > 0;
	    if (isValidSearchTerm &&
	        this.name.toLowerCase().indexOf(searchTerm) === -1 &&
	        this.value.toLowerCase().indexOf(searchTerm) === -1) {
	      return false;
	    }

	    return true;
	  },

	  /**
	   * Returns the className that should be assigned to the propertyView.
	   *
	   * @return {String}
	   */
	  get propertyHeaderClassName() {
	    if (this.visible) {
	      let isDark = this.tree._darkStripe = !this.tree._darkStripe;
	      return isDark ? "property-view row-striped" : "property-view";
	    }
	    return "property-view-hidden";
	  },

	  /**
	   * Returns the className that should be assigned to the propertyView content
	   * container.
	   *
	   * @return {String}
	   */
	  get propertyContentClassName() {
	    if (this.visible) {
	      let isDark = this.tree._darkStripe;
	      return isDark ? "property-content row-striped" : "property-content";
	    }
	    return "property-content-hidden";
	  },

	  /**
	   * Build the markup for on computed style
	   *
	   * @return {Element}
	   */
	  buildMain: function () {
	    let doc = this.tree.styleDocument;

	    // Build the container element
	    this.onMatchedToggle = this.onMatchedToggle.bind(this);
	    this.element = doc.createElementNS(HTML_NS, "div");
	    this.element.setAttribute("class", this.propertyHeaderClassName);
	    this.element.addEventListener("dblclick", this.onMatchedToggle, false);

	    // Make it keyboard navigable
	    this.element.setAttribute("tabindex", "0");
	    this.shortcuts = new KeyShortcuts({
	      window: this.tree.styleWindow,
	      target: this.element
	    });
	    this.shortcuts.on("F1", (name, event) => {
	      this.mdnLinkClick(event);
	    });
	    this.shortcuts.on("Return", (name, event) => this.onMatchedToggle(event));
	    this.shortcuts.on("Space", (name, event) => this.onMatchedToggle(event));

	    let nameContainer = doc.createElementNS(HTML_NS, "div");
	    nameContainer.className = "property-name-container";
	    this.element.appendChild(nameContainer);

	    // Build the twisty expand/collapse
	    this.matchedExpander = doc.createElementNS(HTML_NS, "div");
	    this.matchedExpander.className = "expander theme-twisty";
	    this.matchedExpander.addEventListener("click", this.onMatchedToggle, false);
	    nameContainer.appendChild(this.matchedExpander);

	    // Build the style name element
	    this.nameNode = doc.createElementNS(HTML_NS, "div");
	    this.nameNode.setAttribute("class", "property-name theme-fg-color5");
	    // Reset its tabindex attribute otherwise, if an ellipsis is applied
	    // it will be reachable via TABing
	    this.nameNode.setAttribute("tabindex", "");
	    this.nameNode.textContent = this.nameNode.title = this.name;
	    // Make it hand over the focus to the container
	    this.onFocus = () => this.element.focus();
	    this.nameNode.addEventListener("click", this.onFocus, false);
	    nameContainer.appendChild(this.nameNode);

	    let valueContainer = doc.createElementNS(HTML_NS, "div");
	    valueContainer.className = "property-value-container";
	    this.element.appendChild(valueContainer);

	    // Build the style value element
	    this.valueNode = doc.createElementNS(HTML_NS, "div");
	    this.valueNode.setAttribute("class", "property-value theme-fg-color1");
	    // Reset its tabindex attribute otherwise, if an ellipsis is applied
	    // it will be reachable via TABing
	    this.valueNode.setAttribute("tabindex", "");
	    this.valueNode.setAttribute("dir", "ltr");
	    // Make it hand over the focus to the container
	    this.valueNode.addEventListener("click", this.onFocus, false);
	    valueContainer.appendChild(this.valueNode);

	    return this.element;
	  },

	  buildSelectorContainer: function () {
	    let doc = this.tree.styleDocument;
	    let element = doc.createElementNS(HTML_NS, "div");
	    element.setAttribute("class", this.propertyContentClassName);
	    this.matchedSelectorsContainer = doc.createElementNS(HTML_NS, "div");
	    this.matchedSelectorsContainer.setAttribute("class", "matchedselectors");
	    element.appendChild(this.matchedSelectorsContainer);

	    return element;
	  },

	  /**
	   * Refresh the panel's CSS property value.
	   */
	  refresh: function () {
	    this.element.className = this.propertyHeaderClassName;
	    this.element.nextElementSibling.className = this.propertyContentClassName;

	    if (this._prevViewedElement !== this.tree._viewedElement) {
	      this._matchedSelectorViews = null;
	      this._prevViewedElement = this.tree._viewedElement;
	    }

	    if (!this.tree._viewedElement || !this.visible) {
	      this.valueNode.textContent = this.valueNode.title = "";
	      this.matchedSelectorsContainer.parentNode.hidden = true;
	      this.matchedSelectorsContainer.textContent = "";
	      this.matchedExpander.removeAttribute("open");
	      return;
	    }

	    this.tree.numVisibleProperties++;

	    let outputParser = this.tree._outputParser;
	    let frag = outputParser.parseCssProperty(this.propertyInfo.name,
	      this.propertyInfo.value,
	      {
	        colorSwatchClass: "computedview-colorswatch",
	        colorClass: "computedview-color",
	        urlClass: "theme-link"
	        // No need to use baseURI here as computed URIs are never relative.
	      });
	    this.valueNode.innerHTML = "";
	    this.valueNode.appendChild(frag);

	    this.refreshMatchedSelectors();
	  },

	  /**
	   * Refresh the panel matched rules.
	   */
	  refreshMatchedSelectors: function () {
	    let hasMatchedSelectors = this.hasMatchedSelectors;
	    this.matchedSelectorsContainer.parentNode.hidden = !hasMatchedSelectors;

	    if (hasMatchedSelectors) {
	      this.matchedExpander.classList.add("expandable");
	    } else {
	      this.matchedExpander.classList.remove("expandable");
	    }

	    if (this.matchedExpanded && hasMatchedSelectors) {
	      return this.tree.pageStyle
	        .getMatchedSelectors(this.tree._viewedElement, this.name)
	        .then(matched => {
	          if (!this.matchedExpanded) {
	            return promise.resolve(undefined);
	          }

	          this._matchedSelectorResponse = matched;

	          return this._buildMatchedSelectors().then(() => {
	            this.matchedExpander.setAttribute("open", "");
	            this.tree.inspector.emit("computed-view-property-expanded");
	          });
	        }).then(null, console.error);
	    }

	    this.matchedSelectorsContainer.innerHTML = "";
	    this.matchedExpander.removeAttribute("open");
	    this.tree.inspector.emit("computed-view-property-collapsed");
	    return promise.resolve(undefined);
	  },

	  get matchedSelectors() {
	    return this._matchedSelectorResponse;
	  },

	  _buildMatchedSelectors: function () {
	    let promises = [];
	    let frag = this.element.ownerDocument.createDocumentFragment();

	    for (let selector of this.matchedSelectorViews) {
	      let p = createChild(frag, "p");
	      let span = createChild(p, "span", {
	        class: "rule-link"
	      });
	      let link = createChild(span, "a", {
	        target: "_blank",
	        class: "link theme-link",
	        title: selector.href,
	        sourcelocation: selector.source,
	        tabindex: "0",
	        textContent: selector.source
	      });
	      link.addEventListener("click", selector.openStyleEditor, false);
	      let shortcuts = new KeyShortcuts({
	        window: this.tree.styleWindow,
	        target: link
	      });
	      shortcuts.on("Return", () => selector.openStyleEditor());

	      let status = createChild(p, "span", {
	        dir: "ltr",
	        class: "rule-text theme-fg-color3 " + selector.statusClass,
	        title: selector.statusText,
	        textContent: selector.sourceText
	      });
	      let valueSpan = createChild(status, "span", {
	        class: "other-property-value theme-fg-color1"
	      });
	      valueSpan.appendChild(selector.outputFragment);
	      promises.push(selector.ready);
	    }

	    this.matchedSelectorsContainer.innerHTML = "";
	    this.matchedSelectorsContainer.appendChild(frag);
	    return promise.all(promises);
	  },

	  /**
	   * Provide access to the matched SelectorViews that we are currently
	   * displaying.
	   */
	  get matchedSelectorViews() {
	    if (!this._matchedSelectorViews) {
	      this._matchedSelectorViews = [];
	      this._matchedSelectorResponse.forEach(selectorInfo => {
	        let selectorView = new SelectorView(this.tree, selectorInfo);
	        this._matchedSelectorViews.push(selectorView);
	      }, this);
	    }
	    return this._matchedSelectorViews;
	  },

	  /**
	   * Update all the selector source links to reflect whether we're linking to
	   * original sources (e.g. Sass files).
	   */
	  updateSourceLinks: function () {
	    if (!this._matchedSelectorViews) {
	      return;
	    }
	    for (let view of this._matchedSelectorViews) {
	      view.updateSourceLink();
	    }
	  },

	  /**
	   * The action when a user expands matched selectors.
	   *
	   * @param {Event} event
	   *        Used to determine the class name of the targets click
	   *        event.
	   */
	  onMatchedToggle: function (event) {
	    if (event.shiftKey) {
	      return;
	    }
	    this.matchedExpanded = !this.matchedExpanded;
	    this.refreshMatchedSelectors();
	    event.preventDefault();
	  },

	  /**
	   * The action when a user clicks on the MDN help link for a property.
	   */
	  mdnLinkClick: function (event) {
	    let inspector = this.tree.inspector;

	    if (inspector.target.tab) {
	      let browserWin = inspector.target.tab.ownerDocument.defaultView;
	      browserWin.openUILinkIn(this.link, "tab");
	    }
	    event.preventDefault();
	    event.stopPropagation();
	  },

	  /**
	   * Destroy this property view, removing event listeners
	   */
	  destroy: function () {
	    this.element.removeEventListener("dblclick", this.onMatchedToggle, false);
	    this.shortcuts.destroy();
	    this.element = null;

	    this.matchedExpander.removeEventListener("click", this.onMatchedToggle,
	                                             false);
	    this.matchedExpander = null;

	    this.nameNode.removeEventListener("click", this.onFocus, false);
	    this.nameNode = null;

	    this.valueNode.removeEventListener("click", this.onFocus, false);
	    this.valueNode = null;
	  }
	};

	/**
	 * A container to give us easy access to display data from a CssRule
	 *
	 * @param CssComputedView tree
	 *        the owning CssComputedView
	 * @param selectorInfo
	 */
	function SelectorView(tree, selectorInfo) {
	  this.tree = tree;
	  this.selectorInfo = selectorInfo;
	  this._cacheStatusNames();

	  this.openStyleEditor = this.openStyleEditor.bind(this);

	  this.ready = this.updateSourceLink();
	}

	/**
	 * Decode for cssInfo.rule.status
	 * @see SelectorView.prototype._cacheStatusNames
	 * @see CssLogic.STATUS
	 */
	SelectorView.STATUS_NAMES = [
	  // "Parent Match", "Matched", "Best Match"
	];

	SelectorView.CLASS_NAMES = [
	  "parentmatch", "matched", "bestmatch"
	];

	SelectorView.prototype = {
	  /**
	   * Cache localized status names.
	   *
	   * These statuses are localized inside the styleinspector.properties string
	   * bundle.
	   * @see css-logic.js - the CssLogic.STATUS array.
	   */
	  _cacheStatusNames: function () {
	    if (SelectorView.STATUS_NAMES.length) {
	      return;
	    }

	    for (let status in CssLogic.STATUS) {
	      let i = CssLogic.STATUS[status];
	      if (i > CssLogic.STATUS.UNMATCHED) {
	        let value = CssComputedView.l10n("rule.status." + status);
	        // Replace normal spaces with non-breaking spaces
	        SelectorView.STATUS_NAMES[i] = value.replace(/ /g, "\u00A0");
	      }
	    }
	  },

	  /**
	   * A localized version of cssRule.status
	   */
	  get statusText() {
	    return SelectorView.STATUS_NAMES[this.selectorInfo.status];
	  },

	  /**
	   * Get class name for selector depending on status
	   */
	  get statusClass() {
	    return SelectorView.CLASS_NAMES[this.selectorInfo.status - 1];
	  },

	  get href() {
	    if (this._href) {
	      return this._href;
	    }
	    let sheet = this.selectorInfo.rule.parentStyleSheet;
	    this._href = sheet ? sheet.href : "#";
	    return this._href;
	  },

	  get sourceText() {
	    return this.selectorInfo.sourceText;
	  },

	  get value() {
	    return this.selectorInfo.value;
	  },

	  get outputFragment() {
	    // Sadly, because this fragment is added to the template by DOM Templater
	    // we lose any events that are attached. This means that URLs will open in a
	    // new window. At some point we should fix this by stopping using the
	    // templater.
	    let outputParser = this.tree._outputParser;
	    let frag = outputParser.parseCssProperty(
	      this.selectorInfo.name,
	      this.selectorInfo.value, {
	        colorSwatchClass: "computedview-colorswatch",
	        colorClass: "computedview-color",
	        urlClass: "theme-link",
	        baseURI: this.selectorInfo.rule.href
	      }
	    );
	    return frag;
	  },

	  /**
	   * Update the text of the source link to reflect whether we're showing
	   * original sources or not.
	   */
	  updateSourceLink: function () {
	    return this.updateSource().then((oldSource) => {
	      if (oldSource !== this.source && this.tree.element) {
	        let selector = '[sourcelocation="' + oldSource + '"]';
	        let link = this.tree.element.querySelector(selector);
	        if (link) {
	          link.textContent = this.source;
	          link.setAttribute("sourcelocation", this.source);
	        }
	      }
	    });
	  },

	  /**
	   * Update the 'source' store based on our original sources preference.
	   */
	  updateSource: function () {
	    let rule = this.selectorInfo.rule;
	    this.sheet = rule.parentStyleSheet;

	    if (!rule || !this.sheet) {
	      let oldSource = this.source;
	      this.source = CssLogic.l10n("rule.sourceElement");
	      return promise.resolve(oldSource);
	    }

	    let showOrig = Services.prefs.getBoolPref(PREF_ORIG_SOURCES);

	    if (showOrig && rule.type !== ELEMENT_STYLE) {
	      let deferred = defer();

	      // set as this first so we show something while we're fetching
	      this.source = CssLogic.shortSource(this.sheet) + ":" + rule.line;

	      rule.getOriginalLocation().then(({href, line}) => {
	        let oldSource = this.source;
	        this.source = CssLogic.shortSource({href: href}) + ":" + line;
	        deferred.resolve(oldSource);
	      });

	      return deferred.promise;
	    }

	    let oldSource = this.source;
	    this.source = CssLogic.shortSource(this.sheet) + ":" + rule.line;
	    return promise.resolve(oldSource);
	  },

	  /**
	   * When a css link is clicked this method is called in order to either:
	   *   1. Open the link in view source (for chrome stylesheets).
	   *   2. Open the link in the style editor.
	   *
	   *   We can only view stylesheets contained in document.styleSheets inside the
	   *   style editor.
	   */
	  openStyleEditor: function () {
	    let inspector = this.tree.inspector;
	    let rule = this.selectorInfo.rule;

	    // The style editor can only display stylesheets coming from content because
	    // chrome stylesheets are not listed in the editor's stylesheet selector.
	    //
	    // If the stylesheet is a content stylesheet we send it to the style
	    // editor else we display it in the view source window.
	    let parentStyleSheet = rule.parentStyleSheet;
	    if (!parentStyleSheet || parentStyleSheet.isSystem) {
	      let toolbox = gDevTools.getToolbox(inspector.target);
	      toolbox.viewSource(rule.href, rule.line);
	      return;
	    }

	    let location = promise.resolve(rule.location);
	    if (Services.prefs.getBoolPref(PREF_ORIG_SOURCES)) {
	      location = rule.getOriginalLocation();
	    }

	    location.then(({source, href, line, column}) => {
	      let target = inspector.target;
	      if (ToolDefinitions.styleEditor.isTargetSupported(target)) {
	        gDevTools.showToolbox(target, "styleeditor").then(function (toolbox) {
	          let sheet = source || href;
	          toolbox.getCurrentPanel().selectStyleSheet(sheet, line, column);
	        });
	      }
	    });
	  }
	};

	function ComputedViewTool(inspector, window) {
	  this.inspector = inspector;
	  this.document = window.document;

	  this.computedView = new CssComputedView(this.inspector, this.document,
	    this.inspector.pageStyle);
	  this.layoutView = new LayoutView(this.inspector, this.document);

	  this.onSelected = this.onSelected.bind(this);
	  this.refresh = this.refresh.bind(this);
	  this.onPanelSelected = this.onPanelSelected.bind(this);
	  this.onMutations = this.onMutations.bind(this);
	  this.onResized = this.onResized.bind(this);

	  this.inspector.selection.on("detached-front", this.onSelected);
	  this.inspector.selection.on("new-node-front", this.onSelected);
	  this.inspector.selection.on("pseudoclass", this.refresh);
	  this.inspector.sidebar.on("computedview-selected", this.onPanelSelected);
	  this.inspector.pageStyle.on("stylesheet-updated", this.refresh);
	  this.inspector.walker.on("mutations", this.onMutations);
	  this.inspector.walker.on("resize", this.onResized);

	  this.computedView.selectElement(null);

	  this.onSelected();
	}

	ComputedViewTool.prototype = {
	  isSidebarActive: function () {
	    if (!this.computedView) {
	      return false;
	    }
	    return this.inspector.sidebar.getCurrentTabID() == "computedview";
	  },

	  onSelected: function (event) {
	    // Ignore the event if the view has been destroyed, or if it's inactive.
	    // But only if the current selection isn't null. If it's been set to null,
	    // let the update go through as this is needed to empty the view on
	    // navigation.
	    if (!this.computedView) {
	      return;
	    }

	    let isInactive = !this.isSidebarActive() &&
	                     this.inspector.selection.nodeFront;
	    if (isInactive) {
	      return;
	    }

	    this.computedView.setPageStyle(this.inspector.pageStyle);

	    if (!this.inspector.selection.isConnected() ||
	        !this.inspector.selection.isElementNode()) {
	      this.computedView.selectElement(null);
	      return;
	    }

	    if (!event || event == "new-node-front") {
	      let done = this.inspector.updating("computed-view");
	      this.computedView.selectElement(this.inspector.selection.nodeFront).then(() => {
	        done();
	      });
	    }
	  },

	  refresh: function () {
	    if (this.isSidebarActive()) {
	      this.computedView.refreshPanel();
	    }
	  },

	  onPanelSelected: function () {
	    if (this.inspector.selection.nodeFront === this.computedView._viewedElement) {
	      this.refresh();
	    } else {
	      this.onSelected();
	    }
	  },

	  /**
	   * When markup mutations occur, if an attribute of the selected node changes,
	   * we need to refresh the view as that might change the node's styles.
	   */
	  onMutations: function (mutations) {
	    for (let {type, target} of mutations) {
	      if (target === this.inspector.selection.nodeFront &&
	          type === "attributes") {
	        this.refresh();
	        break;
	      }
	    }
	  },

	  /**
	   * When the window gets resized, this may cause media-queries to match, and
	   * therefore, different styles may apply.
	   */
	  onResized: function () {
	    this.refresh();
	  },

	  destroy: function () {
	    this.inspector.walker.off("mutations", this.onMutations);
	    this.inspector.walker.off("resize", this.onResized);
	    this.inspector.sidebar.off("computedview-selected", this.refresh);
	    this.inspector.selection.off("pseudoclass", this.refresh);
	    this.inspector.selection.off("new-node-front", this.onSelected);
	    this.inspector.selection.off("detached-front", this.onSelected);
	    this.inspector.sidebar.off("computedview-selected", this.onPanelSelected);
	    if (this.inspector.pageStyle) {
	      this.inspector.pageStyle.off("stylesheet-updated", this.refresh);
	    }

	    this.computedView.destroy();
	    this.layoutView.destroy();

	    this.computedView = this.layoutView = this.document = this.inspector = null;
	  }
	};

	exports.CssComputedView = CssComputedView;
	exports.ComputedViewTool = ComputedViewTool;
	exports.PropertyView = PropertyView;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);
	const osString = Services.appinfo.OS;

	// Panels
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "OptionsPanel", () => __webpack_require__(37).OptionsPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "InspectorPanel", () => __webpack_require__(9).InspectorPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "WebConsolePanel", () => __webpack_require__(137).WebConsolePanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "DebuggerPanel", () => __webpack_require__(141).DebuggerPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "StyleEditorPanel", () => __webpack_require__(142).StyleEditorPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "ShaderEditorPanel", () => __webpack_require__(150).ShaderEditorPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "CanvasDebuggerPanel", () => __webpack_require__(153).CanvasDebuggerPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "WebAudioEditorPanel", () => __webpack_require__(156).WebAudioEditorPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "MemoryPanel", () => __webpack_require__(160).MemoryPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "PerformancePanel", () => __webpack_require__(166).PerformancePanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "NetMonitorPanel", () => __webpack_require__(167).NetMonitorPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "StoragePanel", () => __webpack_require__(168).StoragePanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "ScratchpadPanel", () => __webpack_require__(169).ScratchpadPanel);
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "DomPanel", () => __webpack_require__(170).DomPanel);

	// Strings
	const toolboxProps = "devtools/locale/toolbox.properties";
	const inspectorProps = "devtools/locale/inspector.properties";
	const webConsoleProps = "devtools/locale/webconsole.properties";
	const debuggerProps = "devtools/locale/debugger.properties";
	const styleEditorProps = "devtools/locale/styleeditor.properties";
	const shaderEditorProps = "devtools/locale/shadereditor.properties";
	const canvasDebuggerProps = "devtools/locale/canvasdebugger.properties";
	const webAudioEditorProps = "devtools/locale/webaudioeditor.properties";
	const performanceProps = "devtools/locale/performance.properties";
	const netMonitorProps = "devtools/locale/netmonitor.properties";
	const storageProps = "devtools/locale/storage.properties";
	const scratchpadProps = "devtools/locale/scratchpad.properties";
	const memoryProps = "devtools/locale/memory.properties";
	const domProps = "devtools/locale/dom.properties";

	const {LocalizationHelper} = __webpack_require__(56);
	const toolboxStrings = new LocalizationHelper(toolboxProps);
	const performanceStrings = new LocalizationHelper(performanceProps);
	const webConsoleStrings = new LocalizationHelper(webConsoleProps);
	const debuggerStrings = new LocalizationHelper(debuggerProps);
	const styleEditorStrings = new LocalizationHelper(styleEditorProps);
	const shaderEditorStrings = new LocalizationHelper(shaderEditorProps);
	const canvasDebuggerStrings = new LocalizationHelper(canvasDebuggerProps);
	const webAudioEditorStrings = new LocalizationHelper(webAudioEditorProps);
	const inspectorStrings = new LocalizationHelper(inspectorProps);
	const netMonitorStrings = new LocalizationHelper(netMonitorProps);
	const storageStrings = new LocalizationHelper(storageProps);
	const scratchpadStrings = new LocalizationHelper(scratchpadProps);
	const memoryStrings = new LocalizationHelper(memoryProps);
	const domStrings = new LocalizationHelper(domProps);

	var Tools = {};
	exports.Tools = Tools;

	// Definitions
	Tools.options = {
	  id: "options",
	  ordinal: 0,
	  url: "chrome://devtools/content/framework/toolbox-options.xhtml",
	  icon: "chrome://devtools/skin/images/tool-options.svg",
	  invertIconForDarkTheme: true,
	  bgTheme: "theme-body",
	  label: l10n("options.label", toolboxStrings),
	  iconOnly: true,
	  panelLabel: l10n("options.panelLabel", toolboxStrings),
	  tooltip: l10n("optionsButton.tooltip", toolboxStrings),
	  inMenu: false,

	  isTargetSupported: function () {
	    return true;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new OptionsPanel(iframeWindow, toolbox);
	  }
	};

	Tools.inspector = {
	  id: "inspector",
	  accesskey: l10n("inspector.accesskey", inspectorStrings),
	  key: l10n("inspector.commandkey", inspectorStrings),
	  ordinal: 1,
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  icon: "chrome://devtools/skin/images/tool-inspector.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/inspector/inspector.xul",
	  label: l10n("inspector.label", inspectorStrings),
	  panelLabel: l10n("inspector.panelLabel", inspectorStrings),
	  get tooltip() {
	    return l10n("inspector.tooltip2", inspectorStrings,
	    (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,
	  commands: [
	    "devtools/client/responsivedesign/resize-commands",
	    "devtools/client/inspector/inspector-commands"
	  ],

	  preventClosingOnKey: true,
	  onkey: function (panel, toolbox) {
	    toolbox.highlighterUtils.togglePicker();
	  },

	  isTargetSupported: function (target) {
	    return target.hasActor("inspector");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new InspectorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.webConsole = {
	  id: "webconsole",
	  key: l10n("cmd.commandkey", webConsoleStrings),
	  accesskey: l10n("webConsoleCmd.accesskey", webConsoleStrings),
	  modifiers: Services.appinfo.OS == "Darwin" ? "accel,alt" : "accel,shift",
	  ordinal: 2,
	  icon: "chrome://devtools/skin/images/tool-webconsole.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/webconsole/webconsole.xul",
	  label: l10n("ToolboxTabWebconsole.label", webConsoleStrings),
	  menuLabel: l10n("MenuWebconsole.label", webConsoleStrings),
	  panelLabel: l10n("ToolboxWebConsole.panelLabel", webConsoleStrings),
	  get tooltip() {
	    return l10n("ToolboxWebconsole.tooltip2", webConsoleStrings,
	    (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,
	  commands: "devtools/client/webconsole/console-commands",

	  preventClosingOnKey: true,
	  onkey: function (panel, toolbox) {
	    if (toolbox.splitConsole) {
	      return toolbox.focusConsoleInput();
	    }

	    panel.focusInput();
	    return undefined;
	  },

	  isTargetSupported: function () {
	    return true;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new WebConsolePanel(iframeWindow, toolbox);
	  }
	};

	Tools.jsdebugger = {
	  id: "jsdebugger",
	  key: l10n("debuggerMenu.commandkey", debuggerStrings),
	  accesskey: l10n("debuggerMenu.accesskey", debuggerStrings),
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  ordinal: 3,
	  icon: "chrome://devtools/skin/images/tool-debugger.svg",
	  invertIconForDarkTheme: true,
	  highlightedicon: "chrome://devtools/skin/images/tool-debugger-paused.svg",
	  url: "chrome://devtools/content/debugger/debugger.xul",
	  label: l10n("ToolboxDebugger.label", debuggerStrings),
	  panelLabel: l10n("ToolboxDebugger.panelLabel", debuggerStrings),
	  get tooltip() {
	    return l10n("ToolboxDebugger.tooltip2", debuggerStrings,
	    (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,
	  commands: "devtools/client/debugger/debugger-commands",

	  isTargetSupported: function () {
	    return true;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new DebuggerPanel(iframeWindow, toolbox);
	  }
	};

	function switchDebugger() {
	  if (Services.prefs.getBoolPref("devtools.debugger.new-debugger-frontend")) {
	    const NewDebuggerPanel = __webpack_require__(172).DebuggerPanel;

	    Tools.jsdebugger.url = "chrome://devtools/content/debugger/new/index.html";
	    Tools.jsdebugger.build = function (iframeWindow, toolbox) {
	      return new NewDebuggerPanel(iframeWindow, toolbox);
	    };
	  } else {
	    Tools.jsdebugger.url = "chrome://devtools/content/debugger/debugger.xul";
	    Tools.jsdebugger.build = function (iframeWindow, toolbox) {
	      return new DebuggerPanel(iframeWindow, toolbox);
	    };
	  }
	}
	switchDebugger();

	Services.prefs.addObserver(
	  "devtools.debugger.new-debugger-frontend",
	  { observe: switchDebugger },
	  false
	);

	Tools.styleEditor = {
	  id: "styleeditor",
	  key: l10n("open.commandkey", styleEditorStrings),
	  ordinal: 4,
	  visibilityswitch: "devtools.styleeditor.enabled",
	  accesskey: l10n("open.accesskey", styleEditorStrings),
	  modifiers: "shift",
	  icon: "chrome://devtools/skin/images/tool-styleeditor.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/styleeditor/styleeditor.xul",
	  label: l10n("ToolboxStyleEditor.label", styleEditorStrings),
	  panelLabel: l10n("ToolboxStyleEditor.panelLabel", styleEditorStrings),
	  get tooltip() {
	    return l10n("ToolboxStyleEditor.tooltip3", styleEditorStrings,
	    "Shift+" + functionkey(this.key));
	  },
	  inMenu: true,
	  commands: "devtools/client/styleeditor/styleeditor-commands",

	  isTargetSupported: function (target) {
	    return target.hasActor("styleEditor") || target.hasActor("styleSheets");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new StyleEditorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.shaderEditor = {
	  id: "shadereditor",
	  ordinal: 5,
	  visibilityswitch: "devtools.shadereditor.enabled",
	  icon: "chrome://devtools/skin/images/tool-shadereditor.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/shadereditor/shadereditor.xul",
	  label: l10n("ToolboxShaderEditor.label", shaderEditorStrings),
	  panelLabel: l10n("ToolboxShaderEditor.panelLabel", shaderEditorStrings),
	  tooltip: l10n("ToolboxShaderEditor.tooltip", shaderEditorStrings),

	  isTargetSupported: function (target) {
	    return target.hasActor("webgl") && !target.chrome;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new ShaderEditorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.canvasDebugger = {
	  id: "canvasdebugger",
	  ordinal: 6,
	  visibilityswitch: "devtools.canvasdebugger.enabled",
	  icon: "chrome://devtools/skin/images/tool-canvas.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/canvasdebugger/canvasdebugger.xul",
	  label: l10n("ToolboxCanvasDebugger.label", canvasDebuggerStrings),
	  panelLabel: l10n("ToolboxCanvasDebugger.panelLabel", canvasDebuggerStrings),
	  tooltip: l10n("ToolboxCanvasDebugger.tooltip", canvasDebuggerStrings),

	  // Hide the Canvas Debugger in the Add-on Debugger and Browser Toolbox
	  // (bug 1047520).
	  isTargetSupported: function (target) {
	    return target.hasActor("canvas") && !target.chrome;
	  },

	  build: function (iframeWindow, toolbox) {
	    return new CanvasDebuggerPanel(iframeWindow, toolbox);
	  }
	};

	Tools.performance = {
	  id: "performance",
	  ordinal: 7,
	  icon: "chrome://devtools/skin/images/tool-profiler.svg",
	  invertIconForDarkTheme: true,
	  highlightedicon: "chrome://devtools/skin/images/tool-profiler-active.svg",
	  url: "chrome://devtools/content/performance/performance.xul",
	  visibilityswitch: "devtools.performance.enabled",
	  label: l10n("performance.label", performanceStrings),
	  panelLabel: l10n("performance.panelLabel", performanceStrings),
	  get tooltip() {
	    return l10n("performance.tooltip", performanceStrings,
	    "Shift+" + functionkey(this.key));
	  },
	  accesskey: l10n("performance.accesskey", performanceStrings),
	  key: l10n("performance.commandkey", performanceStrings),
	  modifiers: "shift",
	  inMenu: true,

	  isTargetSupported: function (target) {
	    return target.hasActor("profiler");
	  },

	  build: function (frame, target) {
	    return new PerformancePanel(frame, target);
	  }
	};

	Tools.memory = {
	  id: "memory",
	  ordinal: 8,
	  icon: "chrome://devtools/skin/images/tool-memory.svg",
	  invertIconForDarkTheme: true,
	  highlightedicon: "chrome://devtools/skin/images/tool-memory-active.svg",
	  url: "chrome://devtools/content/memory/memory.xhtml",
	  visibilityswitch: "devtools.memory.enabled",
	  label: l10n("memory.label", memoryStrings),
	  panelLabel: l10n("memory.panelLabel", memoryStrings),
	  tooltip: l10n("memory.tooltip", memoryStrings),

	  isTargetSupported: function (target) {
	    return target.getTrait("heapSnapshots") && !target.isAddon;
	  },

	  build: function (frame, target) {
	    return new MemoryPanel(frame, target);
	  }
	};

	Tools.netMonitor = {
	  id: "netmonitor",
	  accesskey: l10n("netmonitor.accesskey", netMonitorStrings),
	  key: l10n("netmonitor.commandkey", netMonitorStrings),
	  ordinal: 9,
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  visibilityswitch: "devtools.netmonitor.enabled",
	  icon: "chrome://devtools/skin/images/tool-network.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/netmonitor/netmonitor.xul",
	  label: l10n("netmonitor.label", netMonitorStrings),
	  panelLabel: l10n("netmonitor.panelLabel", netMonitorStrings),
	  get tooltip() {
	    return l10n("netmonitor.tooltip2", netMonitorStrings,
	    (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,

	  isTargetSupported: function (target) {
	    return target.getTrait("networkMonitor");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new NetMonitorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.storage = {
	  id: "storage",
	  key: l10n("storage.commandkey", storageStrings),
	  ordinal: 10,
	  accesskey: l10n("storage.accesskey", storageStrings),
	  modifiers: "shift",
	  visibilityswitch: "devtools.storage.enabled",
	  icon: "chrome://devtools/skin/images/tool-storage.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/storage/storage.xul",
	  label: l10n("storage.label", storageStrings),
	  menuLabel: l10n("storage.menuLabel", storageStrings),
	  panelLabel: l10n("storage.panelLabel", storageStrings),
	  get tooltip() {
	    return l10n("storage.tooltip3", storageStrings,
	    "Shift+" + functionkey(this.key));
	  },
	  inMenu: true,

	  isTargetSupported: function (target) {
	    return target.isLocalTab ||
	           (target.hasActor("storage") && target.getTrait("storageInspector"));
	  },

	  build: function (iframeWindow, toolbox) {
	    return new StoragePanel(iframeWindow, toolbox);
	  }
	};

	Tools.webAudioEditor = {
	  id: "webaudioeditor",
	  ordinal: 11,
	  visibilityswitch: "devtools.webaudioeditor.enabled",
	  icon: "chrome://devtools/skin/images/tool-webaudio.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/webaudioeditor/webaudioeditor.xul",
	  label: l10n("ToolboxWebAudioEditor1.label", webAudioEditorStrings),
	  panelLabel: l10n("ToolboxWebAudioEditor1.panelLabel", webAudioEditorStrings),
	  tooltip: l10n("ToolboxWebAudioEditor1.tooltip", webAudioEditorStrings),

	  isTargetSupported: function (target) {
	    return !target.chrome && target.hasActor("webaudio");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new WebAudioEditorPanel(iframeWindow, toolbox);
	  }
	};

	Tools.scratchpad = {
	  id: "scratchpad",
	  ordinal: 12,
	  visibilityswitch: "devtools.scratchpad.enabled",
	  icon: "chrome://devtools/skin/images/tool-scratchpad.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/scratchpad/scratchpad.xul",
	  label: l10n("scratchpad.label", scratchpadStrings),
	  panelLabel: l10n("scratchpad.panelLabel", scratchpadStrings),
	  tooltip: l10n("scratchpad.tooltip", scratchpadStrings),
	  inMenu: false,
	  commands: "devtools/client/scratchpad/scratchpad-commands",

	  isTargetSupported: function (target) {
	    return target.hasActor("console");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new ScratchpadPanel(iframeWindow, toolbox);
	  }
	};

	Tools.dom = {
	  id: "dom",
	  accesskey: l10n("dom.accesskey", domStrings),
	  key: l10n("dom.commandkey", domStrings),
	  ordinal: 13,
	  modifiers: osString == "Darwin" ? "accel,alt" : "accel,shift",
	  visibilityswitch: "devtools.dom.enabled",
	  icon: "chrome://devtools/skin/images/tool-dom.svg",
	  invertIconForDarkTheme: true,
	  url: "chrome://devtools/content/dom/dom.html",
	  label: l10n("dom.label", domStrings),
	  panelLabel: l10n("dom.panelLabel", domStrings),
	  get tooltip() {
	    return l10n("dom.tooltip", domStrings,
	    (osString == "Darwin" ? "Cmd+Opt+" : "Ctrl+Shift+") + this.key);
	  },
	  inMenu: true,

	  isTargetSupported: function (target) {
	    return target.getTrait("webConsoleCommands");
	  },

	  build: function (iframeWindow, toolbox) {
	    return new DomPanel(iframeWindow, toolbox);
	  }
	};

	var defaultTools = [
	  Tools.options,
	  Tools.webConsole,
	  Tools.inspector,
	  Tools.jsdebugger,
	  Tools.styleEditor,
	  Tools.shaderEditor,
	  Tools.canvasDebugger,
	  Tools.webAudioEditor,
	  Tools.performance,
	  Tools.netMonitor,
	  Tools.storage,
	  Tools.scratchpad,
	  Tools.memory,
	  Tools.dom,
	];

	exports.defaultTools = defaultTools;

	Tools.darkTheme = {
	  id: "dark",
	  label: l10n("options.darkTheme.label2", toolboxStrings),
	  ordinal: 1,
	  stylesheets: ["chrome://devtools/skin/dark-theme.css"],
	  classList: ["theme-dark"],
	};

	Tools.lightTheme = {
	  id: "light",
	  label: l10n("options.lightTheme.label2", toolboxStrings),
	  ordinal: 2,
	  stylesheets: ["chrome://devtools/skin/light-theme.css"],
	  classList: ["theme-light"],
	};

	Tools.firebugTheme = {
	  id: "firebug",
	  label: l10n("options.firebugTheme.label2", toolboxStrings),
	  ordinal: 3,
	  stylesheets: ["chrome://devtools/skin/firebug-theme.css"],
	  classList: ["theme-light", "theme-firebug"],
	};

	exports.defaultThemes = [
	  Tools.darkTheme,
	  Tools.lightTheme,
	  Tools.firebugTheme,
	];

	/**
	 * Lookup l10n string from a string bundle.
	 *
	 * @param {string} name
	 *        The key to lookup.
	 * @param {StringBundle} bundle
	 *        The key to lookup.
	 * @returns A localized version of the given key.
	 */
	function l10n(name, bundle, arg) {
	  try {
	    return arg ? bundle.getFormatStr(name, arg) : bundle.getStr(name);
	  } catch (ex) {
	    console.log("Error reading '" + name + "'");
	    throw new Error("l10n error with " + name);
	  }
	}

	function functionkey(shortkey) {
	  return shortkey.split("_")[1];
	}


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);
	const defer = __webpack_require__(5);
	const {Task} = __webpack_require__(15);
	const {gDevTools} = __webpack_require__(38);

	const {LocalizationHelper} = __webpack_require__(56);
	const L10N = new LocalizationHelper("devtools/locale/toolbox.properties");

	exports.OptionsPanel = OptionsPanel;

	function GetPref(name) {
	  let type = Services.prefs.getPrefType(name);
	  switch (type) {
	    case Services.prefs.PREF_STRING:
	      return Services.prefs.getCharPref(name);
	    case Services.prefs.PREF_INT:
	      return Services.prefs.getIntPref(name);
	    case Services.prefs.PREF_BOOL:
	      return Services.prefs.getBoolPref(name);
	    default:
	      throw new Error("Unknown type");
	  }
	}

	function SetPref(name, value) {
	  let type = Services.prefs.getPrefType(name);
	  switch (type) {
	    case Services.prefs.PREF_STRING:
	      return Services.prefs.setCharPref(name, value);
	    case Services.prefs.PREF_INT:
	      return Services.prefs.setIntPref(name, value);
	    case Services.prefs.PREF_BOOL:
	      return Services.prefs.setBoolPref(name, value);
	    default:
	      throw new Error("Unknown type");
	  }
	}

	function InfallibleGetBoolPref(key) {
	  try {
	    return Services.prefs.getBoolPref(key);
	  } catch (ex) {
	    return true;
	  }
	}

	/**
	 * Represents the Options Panel in the Toolbox.
	 */
	function OptionsPanel(iframeWindow, toolbox) {
	  this.panelDoc = iframeWindow.document;
	  this.panelWin = iframeWindow;

	  this.toolbox = toolbox;
	  this.isReady = false;

	  this._prefChanged = this._prefChanged.bind(this);
	  this._themeRegistered = this._themeRegistered.bind(this);
	  this._themeUnregistered = this._themeUnregistered.bind(this);
	  this._disableJSClicked = this._disableJSClicked.bind(this);

	  this.disableJSNode = this.panelDoc.getElementById(
	    "devtools-disable-javascript");

	  this._addListeners();

	  const EventEmitter = __webpack_require__(6);
	  EventEmitter.decorate(this);
	}

	OptionsPanel.prototype = {

	  get target() {
	    return this.toolbox.target;
	  },

	  open: Task.async(function* () {
	    // For local debugging we need to make the target remote.
	    if (!this.target.isRemote) {
	      yield this.target.makeRemote();
	    }

	    this.setupToolsList();
	    this.setupToolbarButtonsList();
	    this.setupThemeList();
	    yield this.populatePreferences();
	    this.isReady = true;
	    this.emit("ready");
	    return this;
	  }),

	  _addListeners: function () {
	    gDevTools.on("pref-changed", this._prefChanged);
	    gDevTools.on("theme-registered", this._themeRegistered);
	    gDevTools.on("theme-unregistered", this._themeUnregistered);
	  },

	  _removeListeners: function () {
	    gDevTools.off("pref-changed", this._prefChanged);
	    gDevTools.off("theme-registered", this._themeRegistered);
	    gDevTools.off("theme-unregistered", this._themeUnregistered);
	  },

	  _prefChanged: function (event, data) {
	    if (data.pref === "devtools.cache.disabled") {
	      let cacheDisabled = data.newValue;
	      let cbx = this.panelDoc.getElementById("devtools-disable-cache");

	      cbx.checked = cacheDisabled;
	    } else if (data.pref === "devtools.theme") {
	      this.updateCurrentTheme();
	    }
	  },

	  _themeRegistered: function (event, themeId) {
	    this.setupThemeList();
	  },

	  _themeUnregistered: function (event, theme) {
	    let themeBox = this.panelDoc.getElementById("devtools-theme-box");
	    let themeInput = themeBox.querySelector(`[value=${theme.id}]`);

	    if (themeInput) {
	      themeInput.parentNode.remove();
	    }
	  },

	  setupToolbarButtonsList: function () {
	    let enabledToolbarButtonsBox = this.panelDoc.getElementById(
	      "enabled-toolbox-buttons-box");

	    let toggleableButtons = this.toolbox.toolboxButtons;
	    let setToolboxButtonsVisibility =
	      this.toolbox.setToolboxButtonsVisibility.bind(this.toolbox);

	    let onCheckboxClick = (checkbox) => {
	      let toolDefinition = toggleableButtons.filter(
	        toggleableButton => toggleableButton.id === checkbox.id)[0];
	      Services.prefs.setBoolPref(
	        toolDefinition.visibilityswitch, checkbox.checked);
	      setToolboxButtonsVisibility();
	    };

	    let createCommandCheckbox = tool => {
	      let checkboxLabel = this.panelDoc.createElement("label");
	      let checkboxSpanLabel = this.panelDoc.createElement("span");
	      checkboxSpanLabel.textContent = tool.label;
	      let checkboxInput = this.panelDoc.createElement("input");
	      checkboxInput.setAttribute("type", "checkbox");
	      checkboxInput.setAttribute("id", tool.id);
	      if (InfallibleGetBoolPref(tool.visibilityswitch)) {
	        checkboxInput.setAttribute("checked", true);
	      }
	      checkboxInput.addEventListener("change",
	        onCheckboxClick.bind(this, checkboxInput));

	      checkboxLabel.appendChild(checkboxInput);
	      checkboxLabel.appendChild(checkboxSpanLabel);
	      return checkboxLabel;
	    };

	    for (let tool of toggleableButtons) {
	      if (!tool.isTargetSupported(this.toolbox.target)) {
	        continue;
	      }

	      enabledToolbarButtonsBox.appendChild(createCommandCheckbox(tool));
	    }
	  },

	  setupToolsList: function () {
	    let defaultToolsBox = this.panelDoc.getElementById("default-tools-box");
	    let additionalToolsBox = this.panelDoc.getElementById(
	      "additional-tools-box");
	    let toolsNotSupportedLabel = this.panelDoc.getElementById(
	      "tools-not-supported-label");
	    let atleastOneToolNotSupported = false;

	    let onCheckboxClick = function (id) {
	      let toolDefinition = gDevTools._tools.get(id);
	      // Set the kill switch pref boolean to true
	      Services.prefs.setBoolPref(toolDefinition.visibilityswitch, this.checked);
	      if (this.checked) {
	        gDevTools.emit("tool-registered", id);
	      } else {
	        gDevTools.emit("tool-unregistered", toolDefinition);
	      }
	    };

	    let createToolCheckbox = tool => {
	      let checkboxLabel = this.panelDoc.createElement("label");
	      let checkboxInput = this.panelDoc.createElement("input");
	      checkboxInput.setAttribute("type", "checkbox");
	      checkboxInput.setAttribute("id", tool.id);
	      checkboxInput.setAttribute("title", tool.tooltip || "");

	      let checkboxSpanLabel = this.panelDoc.createElement("span");
	      if (tool.isTargetSupported(this.target)) {
	        checkboxSpanLabel.textContent = tool.label;
	      } else {
	        atleastOneToolNotSupported = true;
	        checkboxSpanLabel.textContent =
	          L10N.getFormatStr("options.toolNotSupportedMarker", tool.label);
	        checkboxInput.setAttribute("data-unsupported", "true");
	        checkboxInput.setAttribute("disabled", "true");
	      }

	      if (InfallibleGetBoolPref(tool.visibilityswitch)) {
	        checkboxInput.setAttribute("checked", "true");
	      }

	      checkboxInput.addEventListener("change",
	        onCheckboxClick.bind(checkboxInput, tool.id));

	      checkboxLabel.appendChild(checkboxInput);
	      checkboxLabel.appendChild(checkboxSpanLabel);
	      return checkboxLabel;
	    };

	    // Populating the default tools lists
	    let toggleableTools = gDevTools.getDefaultTools().filter(tool => {
	      return tool.visibilityswitch && !tool.hiddenInOptions;
	    });

	    for (let tool of toggleableTools) {
	      defaultToolsBox.appendChild(createToolCheckbox(tool));
	    }

	    // Populating the additional tools list that came from add-ons.
	    let atleastOneAddon = false;
	    for (let tool of gDevTools.getAdditionalTools()) {
	      atleastOneAddon = true;
	      additionalToolsBox.appendChild(createToolCheckbox(tool));
	    }

	    if (!atleastOneAddon) {
	      additionalToolsBox.style.display = "none";
	    }

	    if (!atleastOneToolNotSupported) {
	      toolsNotSupportedLabel.style.display = "none";
	    }

	    this.panelWin.focus();
	  },

	  setupThemeList: function () {
	    let themeBox = this.panelDoc.getElementById("devtools-theme-box");

	    let createThemeOption = theme => {
	      let inputLabel = this.panelDoc.createElement("label");
	      let inputRadio = this.panelDoc.createElement("input");
	      inputRadio.setAttribute("type", "radio");
	      inputRadio.setAttribute("value", theme.id);
	      inputRadio.setAttribute("name", "devtools-theme-item");
	      inputRadio.addEventListener("change", function (e) {
	        setPrefAndEmit(themeBox.getAttribute("data-pref"),
	          e.target.value);
	      });

	      let inputSpanLabel = this.panelDoc.createElement("span");
	      inputSpanLabel.textContent = theme.label;
	      inputLabel.appendChild(inputRadio);
	      inputLabel.appendChild(inputSpanLabel);

	      return inputLabel;
	    };

	    // Populating the default theme list
	    let themes = gDevTools.getThemeDefinitionArray();
	    for (let theme of themes) {
	      themeBox.appendChild(createThemeOption(theme));
	    }

	    this.updateCurrentTheme();
	  },

	  populatePreferences: function () {
	    let prefCheckboxes = this.panelDoc.querySelectorAll(
	      "input[type=checkbox][data-pref]");
	    for (let prefCheckbox of prefCheckboxes) {
	      if (GetPref(prefCheckbox.getAttribute("data-pref"))) {
	        prefCheckbox.setAttribute("checked", true);
	      }
	      prefCheckbox.addEventListener("change", function (e) {
	        let checkbox = e.target;
	        setPrefAndEmit(checkbox.getAttribute("data-pref"), checkbox.checked);
	      });
	    }
	    // Themes radio inputs are handled in setupThemeList
	    let prefRadiogroups = this.panelDoc.querySelectorAll(
	      ".radiogroup[data-pref]:not(#devtools-theme-box)");
	    for (let radioGroup of prefRadiogroups) {
	      let selectedValue = GetPref(radioGroup.getAttribute("data-pref"));

	      for (let radioInput of radioGroup.querySelectorAll("input[type=radio]")) {
	        if (radioInput.getAttribute("value") == selectedValue) {
	          radioInput.setAttribute("checked", true);
	        }

	        radioInput.addEventListener("change", function (e) {
	          setPrefAndEmit(radioGroup.getAttribute("data-pref"),
	            e.target.value);
	        });
	      }
	    }
	    let prefSelects = this.panelDoc.querySelectorAll("select[data-pref]");
	    for (let prefSelect of prefSelects) {
	      let pref = GetPref(prefSelect.getAttribute("data-pref"));
	      let options = [...prefSelect.options];
	      options.some(function (option) {
	        let value = option.value;
	        // non strict check to allow int values.
	        if (value == pref) {
	          prefSelect.selectedIndex = options.indexOf(option);
	          return true;
	        }
	      });

	      prefSelect.addEventListener("change", function (e) {
	        let select = e.target;
	        setPrefAndEmit(select.getAttribute("data-pref"),
	          select.options[select.selectedIndex].value);
	      });
	    }

	    if (this.target.activeTab) {
	      return this.target.client.attachTab(this.target.activeTab._actor)
	        .then(([response, client]) => {
	          this._origJavascriptEnabled = !response.javascriptEnabled;
	          this.disableJSNode.checked = this._origJavascriptEnabled;
	          this.disableJSNode.addEventListener("click",
	            this._disableJSClicked, false);
	        });
	    }
	    this.disableJSNode.hidden = true;
	  },

	  updateCurrentTheme: function () {
	    let currentTheme = GetPref("devtools.theme");
	    let themeBox = this.panelDoc.getElementById("devtools-theme-box");
	    let themeRadioInput = themeBox.querySelector(`[value=${currentTheme}]`);

	    if (themeRadioInput) {
	      themeRadioInput.click();
	    } else {
	      // If the current theme does not exist anymore, switch to light theme
	      let lightThemeInputRadio = themeBox.querySelector("[value=light]");
	      lightThemeInputRadio.click();
	    }
	  },

	  /**
	   * Disables JavaScript for the currently loaded tab. We force a page refresh
	   * here because setting docShell.allowJavascript to true fails to block JS
	   * execution from event listeners added using addEventListener(), AJAX calls
	   * and timers. The page refresh prevents these things from being added in the
	   * first place.
	   *
	   * @param {Event} event
	   *        The event sent by checking / unchecking the disable JS checkbox.
	   */
	  _disableJSClicked: function (event) {
	    let checked = event.target.checked;

	    let options = {
	      "javascriptEnabled": !checked
	    };

	    this.target.activeTab.reconfigure(options);
	  },

	  destroy: function () {
	    if (this.destroyPromise) {
	      return this.destroyPromise;
	    }

	    let deferred = defer();
	    this.destroyPromise = deferred.promise;

	    this._removeListeners();

	    if (this.target.activeTab) {
	      this.disableJSNode.removeEventListener("click", this._disableJSClicked);
	      // FF41+ automatically cleans up state in actor on disconnect
	      if (!this.target.activeTab.traits.noTabReconfigureOnClose) {
	        let options = {
	          "javascriptEnabled": this._origJavascriptEnabled,
	          "performReload": false
	        };
	        this.target.activeTab.reconfigure(options, deferred.resolve);
	      } else {
	        deferred.resolve();
	      }
	    } else {
	      deferred.resolve();
	    }

	    this.panelWin = this.panelDoc = this.disableJSNode = this.toolbox = null;

	    return this.destroyPromise;
	  }
	};

	/* Set a pref and emit the pref-changed event if needed. */
	function setPrefAndEmit(prefName, newValue) {
	  let data = {
	    pref: prefName,
	    newValue: newValue
	  };
	  data.oldValue = GetPref(data.pref);
	  SetPref(data.pref, data.newValue);

	  if (data.newValue != data.oldValue) {
	    gDevTools.emit("pref-changed", data);
	  }
	}


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);
	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);

	// Load gDevToolsBrowser toolbox lazily as they need gDevTools to be fully initialized
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "Toolbox", "devtools/client/framework/toolbox", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "gDevToolsBrowser", "devtools/client/framework/devtools-browser", true);

	const {defaultTools: DefaultTools, defaultThemes: DefaultThemes} =
	  __webpack_require__(36);
	const EventEmitter = __webpack_require__(6);
	const {JsonView} = __webpack_require__(39);
	const AboutDevTools = __webpack_require__(48);
	const {when: unload} = __webpack_require__(49);

	const FORBIDDEN_IDS = new Set(["toolbox", ""]);
	const MAX_ORDINAL = 99;

	/**
	 * DevTools is a class that represents a set of developer tools, it holds a
	 * set of tools and keeps track of open toolboxes in the browser.
	 */
	this.DevTools = function DevTools() {
	  this._tools = new Map();     // Map<toolId, tool>
	  this._themes = new Map();    // Map<themeId, theme>
	  this._toolboxes = new Map(); // Map<target, toolbox>

	  // destroy() is an observer's handler so we need to preserve context.
	  this.destroy = this.destroy.bind(this);

	  // JSON Viewer for 'application/json' documents.
	  JsonView.initialize();

	  AboutDevTools.register();

	  EventEmitter.decorate(this);

	  Services.obs.addObserver(this.destroy, "quit-application", false);

	  // This is important step in initialization codepath where we are going to
	  // start registering all default tools and themes: create menuitems, keys, emit
	  // related events.
	  this.registerDefaults();
	};

	DevTools.prototype = {
	  // The windowtype of the main window, used in various tools. This may be set
	  // to something different by other gecko apps.
	  chromeWindowType: "navigator:browser",

	  registerDefaults() {
	    // Ensure registering items in the sorted order (getDefault* functions
	    // return sorted lists)
	    this.getDefaultTools().forEach(definition => this.registerTool(definition));
	    this.getDefaultThemes().forEach(definition => this.registerTheme(definition));
	  },

	  unregisterDefaults() {
	    for (let definition of this.getToolDefinitionArray()) {
	      this.unregisterTool(definition.id);
	    }
	    for (let definition of this.getThemeDefinitionArray()) {
	      this.unregisterTheme(definition.id);
	    }
	  },

	  /**
	   * Register a new developer tool.
	   *
	   * A definition is a light object that holds different information about a
	   * developer tool. This object is not supposed to have any operational code.
	   * See it as a "manifest".
	   * The only actual code lives in the build() function, which will be used to
	   * start an instance of this tool.
	   *
	   * Each toolDefinition has the following properties:
	   * - id: Unique identifier for this tool (string|required)
	   * - visibilityswitch: Property name to allow us to hide this tool from the
	   *                     DevTools Toolbox.
	   *                     A falsy value indicates that it cannot be hidden.
	   * - icon: URL pointing to a graphic which will be used as the src for an
	   *         16x16 img tag (string|required)
	   * - invertIconForLightTheme: The icon can automatically have an inversion
	   *         filter applied (default is false).  All builtin tools are true, but
	   *         addons may omit this to prevent unwanted changes to the `icon`
	   *         image. filter: invert(1) is applied to the image (boolean|optional)
	   * - url: URL pointing to a XUL/XHTML document containing the user interface
	   *        (string|required)
	   * - label: Localized name for the tool to be displayed to the user
	   *          (string|required)
	   * - hideInOptions: Boolean indicating whether or not this tool should be
	                      shown in toolbox options or not. Defaults to false.
	   *                  (boolean)
	   * - build: Function that takes an iframe, which has been populated with the
	   *          markup from |url|, and also the toolbox containing the panel.
	   *          And returns an instance of ToolPanel (function|required)
	   */
	  registerTool: function DT_registerTool(toolDefinition) {
	    let toolId = toolDefinition.id;

	    if (!toolId || FORBIDDEN_IDS.has(toolId)) {
	      throw new Error("Invalid definition.id");
	    }

	    // Make sure that additional tools will always be able to be hidden.
	    // When being called from main.js, defaultTools has not yet been exported.
	    // But, we can assume that in this case, it is a default tool.
	    if (DefaultTools.indexOf(toolDefinition) == -1) {
	      toolDefinition.visibilityswitch = "devtools." + toolId + ".enabled";
	    }

	    this._tools.set(toolId, toolDefinition);

	    this.emit("tool-registered", toolId);
	  },

	  /**
	   * Removes all tools that match the given |toolId|
	   * Needed so that add-ons can remove themselves when they are deactivated
	   *
	   * @param {string|object} tool
	   *        Definition or the id of the tool to unregister. Passing the
	   *        tool id should be avoided as it is a temporary measure.
	   * @param {boolean} isQuitApplication
	   *        true to indicate that the call is due to app quit, so we should not
	   *        cause a cascade of costly events
	   */
	  unregisterTool: function DT_unregisterTool(tool, isQuitApplication) {
	    let toolId = null;
	    if (typeof tool == "string") {
	      toolId = tool;
	      tool = this._tools.get(tool);
	    }
	    else {
	      toolId = tool.id;
	    }
	    this._tools.delete(toolId);

	    if (!isQuitApplication) {
	      this.emit("tool-unregistered", tool);
	    }
	  },

	  /**
	   * Sorting function used for sorting tools based on their ordinals.
	   */
	  ordinalSort: function DT_ordinalSort(d1, d2) {
	    let o1 = (typeof d1.ordinal == "number") ? d1.ordinal : MAX_ORDINAL;
	    let o2 = (typeof d2.ordinal == "number") ? d2.ordinal : MAX_ORDINAL;
	    return o1 - o2;
	  },

	  getDefaultTools: function DT_getDefaultTools() {
	    return DefaultTools.sort(this.ordinalSort);
	  },

	  getAdditionalTools: function DT_getAdditionalTools() {
	    let tools = [];
	    for (let [key, value] of this._tools) {
	      if (DefaultTools.indexOf(value) == -1) {
	        tools.push(value);
	      }
	    }
	    return tools.sort(this.ordinalSort);
	  },

	  getDefaultThemes() {
	    return DefaultThemes.sort(this.ordinalSort);
	  },

	  /**
	   * Get a tool definition if it exists and is enabled.
	   *
	   * @param {string} toolId
	   *        The id of the tool to show
	   *
	   * @return {ToolDefinition|null} tool
	   *         The ToolDefinition for the id or null.
	   */
	  getToolDefinition: function DT_getToolDefinition(toolId) {
	    let tool = this._tools.get(toolId);
	    if (!tool) {
	      return null;
	    } else if (!tool.visibilityswitch) {
	      return tool;
	    }

	    let enabled;
	    try {
	      enabled = Services.prefs.getBoolPref(tool.visibilityswitch);
	    } catch (e) {
	      enabled = true;
	    }

	    return enabled ? tool : null;
	  },

	  /**
	   * Allow ToolBoxes to get at the list of tools that they should populate
	   * themselves with.
	   *
	   * @return {Map} tools
	   *         A map of the the tool definitions registered in this instance
	   */
	  getToolDefinitionMap: function DT_getToolDefinitionMap() {
	    let tools = new Map();

	    for (let [id, definition] of this._tools) {
	      if (this.getToolDefinition(id)) {
	        tools.set(id, definition);
	      }
	    }

	    return tools;
	  },

	  /**
	   * Tools have an inherent ordering that can't be represented in a Map so
	   * getToolDefinitionArray provides an alternative representation of the
	   * definitions sorted by ordinal value.
	   *
	   * @return {Array} tools
	   *         A sorted array of the tool definitions registered in this instance
	   */
	  getToolDefinitionArray: function DT_getToolDefinitionArray() {
	    let definitions = [];

	    for (let [id, definition] of this._tools) {
	      if (this.getToolDefinition(id)) {
	        definitions.push(definition);
	      }
	    }

	    return definitions.sort(this.ordinalSort);
	  },

	  /**
	   * Register a new theme for developer tools toolbox.
	   *
	   * A definition is a light object that holds various information about a
	   * theme.
	   *
	   * Each themeDefinition has the following properties:
	   * - id: Unique identifier for this theme (string|required)
	   * - label: Localized name for the theme to be displayed to the user
	   *          (string|required)
	   * - stylesheets: Array of URLs pointing to a CSS document(s) containing
	   *                the theme style rules (array|required)
	   * - classList: Array of class names identifying the theme within a document.
	   *              These names are set to document element when applying
	   *              the theme (array|required)
	   * - onApply: Function that is executed by the framework when the theme
	   *            is applied. The function takes the current iframe window
	   *            and the previous theme id as arguments (function)
	   * - onUnapply: Function that is executed by the framework when the theme
	   *            is unapplied. The function takes the current iframe window
	   *            and the new theme id as arguments (function)
	   */
	  registerTheme: function DT_registerTheme(themeDefinition) {
	    let themeId = themeDefinition.id;

	    if (!themeId) {
	      throw new Error("Invalid theme id");
	    }

	    if (this._themes.get(themeId)) {
	      throw new Error("Theme with the same id is already registered");
	    }

	    this._themes.set(themeId, themeDefinition);

	    this.emit("theme-registered", themeId);
	  },

	  /**
	   * Removes an existing theme from the list of registered themes.
	   * Needed so that add-ons can remove themselves when they are deactivated
	   *
	   * @param {string|object} theme
	   *        Definition or the id of the theme to unregister.
	   */
	  unregisterTheme: function DT_unregisterTheme(theme) {
	    let themeId = null;
	    if (typeof theme == "string") {
	      themeId = theme;
	      theme = this._themes.get(theme);
	    }
	    else {
	      themeId = theme.id;
	    }

	    let currTheme = Services.prefs.getCharPref("devtools.theme");

	    // Note that we can't check if `theme` is an item
	    // of `DefaultThemes` as we end up reloading definitions
	    // module and end up with different theme objects
	    let isCoreTheme = DefaultThemes.some(t => t.id === themeId);

	    // Reset the theme if an extension theme that's currently applied
	    // is being removed.
	    // Ignore shutdown since addons get disabled during that time.
	    if (!Services.startup.shuttingDown &&
	        !isCoreTheme &&
	        theme.id == currTheme) {
	      Services.prefs.setCharPref("devtools.theme", "light");

	      let data = {
	        pref: "devtools.theme",
	        newValue: "light",
	        oldValue: currTheme
	      };

	      this.emit("pref-changed", data);

	      this.emit("theme-unregistered", theme);
	    }

	    this._themes.delete(themeId);
	  },

	  /**
	   * Get a theme definition if it exists.
	   *
	   * @param {string} themeId
	   *        The id of the theme
	   *
	   * @return {ThemeDefinition|null} theme
	   *         The ThemeDefinition for the id or null.
	   */
	  getThemeDefinition: function DT_getThemeDefinition(themeId) {
	    let theme = this._themes.get(themeId);
	    if (!theme) {
	      return null;
	    }
	    return theme;
	  },

	  /**
	   * Get map of registered themes.
	   *
	   * @return {Map} themes
	   *         A map of the the theme definitions registered in this instance
	   */
	  getThemeDefinitionMap: function DT_getThemeDefinitionMap() {
	    let themes = new Map();

	    for (let [id, definition] of this._themes) {
	      if (this.getThemeDefinition(id)) {
	        themes.set(id, definition);
	      }
	    }

	    return themes;
	  },

	  /**
	   * Get registered themes definitions sorted by ordinal value.
	   *
	   * @return {Array} themes
	   *         A sorted array of the theme definitions registered in this instance
	   */
	  getThemeDefinitionArray: function DT_getThemeDefinitionArray() {
	    let definitions = [];

	    for (let [id, definition] of this._themes) {
	      if (this.getThemeDefinition(id)) {
	        definitions.push(definition);
	      }
	    }

	    return definitions.sort(this.ordinalSort);
	  },

	  /**
	   * Show a Toolbox for a target (either by creating a new one, or if a toolbox
	   * already exists for the target, by bring to the front the existing one)
	   * If |toolId| is specified then the displayed toolbox will have the
	   * specified tool selected.
	   * If |hostType| is specified then the toolbox will be displayed using the
	   * specified HostType.
	   *
	   * @param {Target} target
	   *         The target the toolbox will debug
	   * @param {string} toolId
	   *        The id of the tool to show
	   * @param {Toolbox.HostType} hostType
	   *        The type of host (bottom, window, side)
	   * @param {object} hostOptions
	   *        Options for host specifically
	   *
	   * @return {Toolbox} toolbox
	   *        The toolbox that was opened
	   */
	  showToolbox: function (target, toolId, hostType, hostOptions) {
	    let deferred = defer();

	    let toolbox = this._toolboxes.get(target);
	    if (toolbox) {

	      let hostPromise = (hostType != null && toolbox.hostType != hostType) ?
	          toolbox.switchHost(hostType) :
	          promise.resolve(null);

	      if (toolId != null && toolbox.currentToolId != toolId) {
	        hostPromise = hostPromise.then(function () {
	          return toolbox.selectTool(toolId);
	        });
	      }

	      return hostPromise.then(function () {
	        toolbox.raise();
	        return toolbox;
	      });
	    }
	    else {
	      // No toolbox for target, create one
	      toolbox = new Toolbox(target, toolId, hostType, hostOptions);

	      this.emit("toolbox-created", toolbox);

	      this._toolboxes.set(target, toolbox);

	      toolbox.once("destroy", () => {
	        this.emit("toolbox-destroy", target);
	      });

	      toolbox.once("destroyed", () => {
	        this._toolboxes.delete(target);
	        this.emit("toolbox-destroyed", target);
	      });

	      // If toolId was passed in, it will already be selected before the
	      // open promise resolves.
	      toolbox.open().then(() => {
	        deferred.resolve(toolbox);
	        this.emit("toolbox-ready", toolbox);
	      });
	    }

	    return deferred.promise;
	  },

	  /**
	   * Return the toolbox for a given target.
	   *
	   * @param  {object} target
	   *         Target value e.g. the target that owns this toolbox
	   *
	   * @return {Toolbox} toolbox
	   *         The toolbox that is debugging the given target
	   */
	  getToolbox: function DT_getToolbox(target) {
	    return this._toolboxes.get(target);
	  },

	  /**
	   * Close the toolbox for a given target
	   *
	   * @return promise
	   *         This promise will resolve to false if no toolbox was found
	   *         associated to the target. true, if the toolbox was successfully
	   *         closed.
	   */
	  closeToolbox: function DT_closeToolbox(target) {
	    let toolbox = this._toolboxes.get(target);
	    if (toolbox == null) {
	      return promise.resolve(false);
	    }
	    return toolbox.destroy().then(() => true);
	  },

	  /**
	   * Called to tear down a tools provider.
	   */
	  _teardown: function DT_teardown() {
	    for (let [target, toolbox] of this._toolboxes) {
	      toolbox.destroy();
	    }
	    AboutDevTools.unregister();
	  },

	  /**
	   * All browser windows have been closed, tidy up remaining objects.
	   */
	  destroy: function () {
	    Services.obs.removeObserver(this.destroy, "quit-application");

	    for (let [key, tool] of this.getToolDefinitionMap()) {
	      this.unregisterTool(key, true);
	    }

	    JsonView.destroy();

	    gDevTools.unregisterDefaults();

	    // Cleaning down the toolboxes: i.e.
	    //   for (let [target, toolbox] of this._toolboxes) toolbox.destroy();
	    // Is taken care of by the gDevToolsBrowser.forgetBrowserWindow
	  },

	  /**
	   * Iterator that yields each of the toolboxes.
	   */
	  *[Symbol.iterator ]() {
	    for (let toolbox of this._toolboxes) {
	      yield toolbox;
	    }
	  }
	};

	const gDevTools = exports.gDevTools = new DevTools();

	// Watch for module loader unload. Fires when the tools are reloaded.
	unload(function () {
	  gDevTools._teardown();
	});


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* globals JsonViewUtils*/

	"use strict";

	const { Cu } = __webpack_require__(9);
	const Services = __webpack_require__(1);

	const { XPCOMUtils } = Cu.import("resource://gre/modules/XPCOMUtils.jsm", {});

	XPCOMUtils.defineLazyGetter(this, "JsonViewUtils", function () {
	  return __webpack_require__(40);
	});

	/**
	 * Singleton object that represents the JSON View in-content tool.
	 * It has the same lifetime as the browser. Initialization done by
	 * DevTools() object from devtools/client/framework/devtools.js
	 */
	var JsonView = {
	  initialize: function () {
	    // Load JSON converter module. This converter is responsible
	    // for handling 'application/json' documents and converting
	    // them into a simple web-app that allows easy inspection
	    // of the JSON data.
	    Services.ppmm.loadProcessScript(
	      "resource://devtools/client/jsonview/converter-observer.js",
	      true);

	    this.onSaveListener = this.onSave.bind(this);

	    // Register for messages coming from the child process.
	    Services.ppmm.addMessageListener(
	      "devtools:jsonview:save", this.onSaveListener);
	  },

	  destroy: function () {
	    Services.ppmm.removeMessageListener(
	      "devtools:jsonview:save", this.onSaveListener);
	  },

	  // Message handlers for events from child processes

	  /**
	   * Save JSON to a file needs to be implemented here
	   * in the parent process.
	   */
	  onSave: function (message) {
	    let value = message.data;
	    let file = JsonViewUtils.getTargetFile();
	    if (file) {
	      JsonViewUtils.saveToFile(file, value);
	    }
	  }
	};

	// Exports from this module
	module.exports.JsonView = JsonView;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const { Cu, Cc, Ci } = __webpack_require__(9);
	const Services = __webpack_require__(1);
	const { getMostRecentBrowserWindow } = __webpack_require__(41);

	const OPEN_FLAGS = {
	  RDONLY: parseInt("0x01", 16),
	  WRONLY: parseInt("0x02", 16),
	  CREATE_FILE: parseInt("0x08", 16),
	  APPEND: parseInt("0x10", 16),
	  TRUNCATE: parseInt("0x20", 16),
	  EXCL: parseInt("0x80", 16)
	};

	/**
	 * Open File Save As dialog and let the user to pick proper file location.
	 */
	exports.getTargetFile = function () {
	  let fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);

	  let win = getMostRecentBrowserWindow();
	  fp.init(win, null, Ci.nsIFilePicker.modeSave);
	  fp.appendFilter("JSON Files", "*.json; *.jsonp;");
	  fp.appendFilters(Ci.nsIFilePicker.filterText);
	  fp.appendFilters(Ci.nsIFilePicker.filterAll);
	  fp.filterIndex = 0;

	  let rv = fp.show();
	  if (rv == Ci.nsIFilePicker.returnOK || rv == Ci.nsIFilePicker.returnReplace) {
	    return fp.file;
	  }

	  return null;
	};

	/**
	 * Save JSON to a file
	 */
	exports.saveToFile = function (file, jsonString) {
	  let foStream = Cc["@mozilla.org/network/file-output-stream;1"]
	    .createInstance(Ci.nsIFileOutputStream);

	  // write, create, truncate
	  let openFlags = OPEN_FLAGS.WRONLY | OPEN_FLAGS.CREATE_FILE |
	    OPEN_FLAGS.TRUNCATE;

	  let permFlags = parseInt("0666", 8);
	  foStream.init(file, openFlags, permFlags, 0);

	  let converter = Cc["@mozilla.org/intl/converter-output-stream;1"]
	    .createInstance(Ci.nsIConverterOutputStream);

	  converter.init(foStream, "UTF-8", 0, 0);

	  // The entire jsonString can be huge so, write the data in chunks.
	  let chunkLength = 1024 * 1204;
	  for (let i = 0; i <= jsonString.length; i++) {
	    let data = jsonString.substr(i, chunkLength + 1);
	    if (data) {
	      converter.writeString(data);
	    }
	    i = i + chunkLength;
	  }

	  // this closes foStream
	  converter.close();
	};

	/**
	 * Get the current theme from preferences.
	 */
	exports.getCurrentTheme = function () {
	  return Services.prefs.getCharPref("devtools.theme");
	};

	/**
	 * Export given object into the target window scope.
	 */
	exports.exportIntoContentScope = function (win, obj, defineAs) {
	  let clone = Cu.createObjectIn(win, {
	    defineAs: defineAs
	  });

	  let props = Object.getOwnPropertyNames(obj);
	  for (let i = 0; i < props.length; i++) {
	    let propName = props[i];
	    let propValue = obj[propName];
	    if (typeof propValue == "function") {
	      Cu.exportFunction(propValue, clone, {
	        defineAs: propName
	      });
	    }
	  }
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	'use strict';

	module.metadata = {
	  'stability': 'unstable'
	};

	const { Cc, Ci } = __webpack_require__(9);
	const array = __webpack_require__(26);
	const { defer } = __webpack_require__(42);
	const { dispatcher } = __webpack_require__(44);

	const windowWatcher = Cc['@mozilla.org/embedcomp/window-watcher;1'].
	                       getService(Ci.nsIWindowWatcher);
	const appShellService = Cc['@mozilla.org/appshell/appShellService;1'].
	                        getService(Ci.nsIAppShellService);
	const WM = Cc['@mozilla.org/appshell/window-mediator;1'].
	           getService(Ci.nsIWindowMediator);
	const io = Cc['@mozilla.org/network/io-service;1'].
	           getService(Ci.nsIIOService);
	const FM = Cc["@mozilla.org/focus-manager;1"].
	              getService(Ci.nsIFocusManager);

	const XUL_NS = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';

	const prefs = __webpack_require__(47);
	const BROWSER = 'navigator:browser',
	      URI_BROWSER = prefs.get('browser.chromeURL', null),
	      NAME = '_blank',
	      FEATURES = 'chrome,all,dialog=no,non-private';

	function isWindowPrivate(win) {
	  if (!win)
	    return false;

	  // if the pbService is undefined, the PrivateBrowsingUtils.jsm is available,
	  // and the app is Firefox, then assume per-window private browsing is
	  // enabled.
	  try {
	    return win.QueryInterface(Ci.nsIInterfaceRequestor)
	                  .getInterface(Ci.nsIWebNavigation)
	                  .QueryInterface(Ci.nsILoadContext)
	                  .usePrivateBrowsing;
	  }
	  catch(e) {}

	  // Sometimes the input is not a nsIDOMWindow.. but it is still a winodw.
	  try {
	    return !!win.docShell.QueryInterface(Ci.nsILoadContext).usePrivateBrowsing;
	  }
	  catch (e) {}

	  return false;
	}
	exports.isWindowPrivate = isWindowPrivate;

	function getMostRecentBrowserWindow() {
	  return getMostRecentWindow(BROWSER);
	}
	exports.getMostRecentBrowserWindow = getMostRecentBrowserWindow;

	function getHiddenWindow() {
	  return appShellService.hiddenDOMWindow;
	}
	exports.getHiddenWindow = getHiddenWindow;

	function getMostRecentWindow(type) {
	  return WM.getMostRecentWindow(type);
	}
	exports.getMostRecentWindow = getMostRecentWindow;

	/**
	 * Returns the ID of the window's current inner window.
	 */
	function getInnerId(window) {
	  return window.QueryInterface(Ci.nsIInterfaceRequestor).
	                getInterface(Ci.nsIDOMWindowUtils).currentInnerWindowID;
	};
	exports.getInnerId = getInnerId;

	/**
	 * Returns the ID of the window's outer window.
	 */
	function getOuterId(window) {
	  return window.QueryInterface(Ci.nsIInterfaceRequestor).
	                getInterface(Ci.nsIDOMWindowUtils).outerWindowID;
	};
	exports.getOuterId = getOuterId;

	/**
	 * Returns window by the outer window id.
	 */
	const getByOuterId = WM.getOuterWindowWithId;
	exports.getByOuterId = getByOuterId;

	const getByInnerId = WM.getCurrentInnerWindowWithId;
	exports.getByInnerId = getByInnerId;

	/**
	 * Returns `nsIXULWindow` for the given `nsIDOMWindow`.
	 */
	function getXULWindow(window) {
	  return window.QueryInterface(Ci.nsIInterfaceRequestor).
	    getInterface(Ci.nsIWebNavigation).
	    QueryInterface(Ci.nsIDocShellTreeItem).
	    treeOwner.QueryInterface(Ci.nsIInterfaceRequestor).
	    getInterface(Ci.nsIXULWindow);
	};
	exports.getXULWindow = getXULWindow;

	function getDOMWindow(xulWindow) {
	  return xulWindow.QueryInterface(Ci.nsIInterfaceRequestor).
	    getInterface(Ci.nsIDOMWindow);
	}
	exports.getDOMWindow = getDOMWindow;

	/**
	 * Returns `nsIBaseWindow` for the given `nsIDOMWindow`.
	 */
	function getBaseWindow(window) {
	  return window.QueryInterface(Ci.nsIInterfaceRequestor).
	    getInterface(Ci.nsIWebNavigation).
	    QueryInterface(Ci.nsIDocShell).
	    QueryInterface(Ci.nsIDocShellTreeItem).
	    treeOwner.
	    QueryInterface(Ci.nsIBaseWindow);
	}
	exports.getBaseWindow = getBaseWindow;

	/**
	 * Returns the `nsIDOMWindow` toplevel window for any child/inner window
	 */
	function getToplevelWindow(window) {
	  return window.QueryInterface(Ci.nsIInterfaceRequestor)
	               .getInterface(Ci.nsIWebNavigation)
	               .QueryInterface(Ci.nsIDocShellTreeItem)
	               .rootTreeItem
	               .QueryInterface(Ci.nsIInterfaceRequestor)
	               .getInterface(Ci.nsIDOMWindow);
	}
	exports.getToplevelWindow = getToplevelWindow;

	function getWindowDocShell(window) {
	  return window.gBrowser.docShell;
	}
	exports.getWindowDocShell = getWindowDocShell;

	function getWindowLoadingContext(window) {
	  return getWindowDocShell(window).
	         QueryInterface(Ci.nsILoadContext);
	}
	exports.getWindowLoadingContext = getWindowLoadingContext;

	const isTopLevel = window => window && getToplevelWindow(window) === window;
	exports.isTopLevel = isTopLevel;

	/**
	 * Takes hash of options and serializes it to a features string that
	 * can be used passed to `window.open`. For more details on features string see:
	 * https://developer.mozilla.org/en/DOM/window.open#Position_and_size_features
	 */
	function serializeFeatures(options) {
	  return Object.keys(options).reduce(function(result, name) {
	    let value = options[name];

	    // the chrome and private features are special
	    if ((name == 'private' || name == 'chrome' || name == 'all'))
	      return result + ((value === true) ? ',' + name : '');

	    return result + ',' + name + '=' +
	           (value === true ? 'yes' : value === false ? 'no' : value);
	  }, '').substr(1);
	}

	/**
	 * Opens a top level window and returns it's `nsIDOMWindow` representation.
	 * @params {String} uri
	 *    URI of the document to be loaded into window.
	 * @params {nsIDOMWindow} options.parent
	 *    Used as parent for the created window.
	 * @params {String} options.name
	 *    Optional name that is assigned to the window.
	 * @params {Object} options.features
	 *    Map of key, values like: `{ width: 10, height: 15, chrome: true, private: true }`.
	 */
	function open(uri, options) {
	  uri = uri || URI_BROWSER;
	  options = options || {};

	  if (!uri)
	    throw new Error('browser.chromeURL is undefined, please provide an explicit uri');

	  if (['chrome', 'resource', 'data'].indexOf(io.newURI(uri, null, null).scheme) < 0)
	    throw new Error('only chrome, resource and data uris are allowed');

	  let newWindow = windowWatcher.
	    openWindow(options.parent || null,
	               uri,
	               options.name || null,
	               options.features ? serializeFeatures(options.features) : null,
	               options.args || null);

	  return newWindow;
	}
	exports.open = open;

	function onFocus(window) {
	  let { resolve, promise } = defer();

	  if (isFocused(window)) {
	    resolve(window);
	  }
	  else {
	    window.addEventListener("focus", function focusListener() {
	      window.removeEventListener("focus", focusListener, true);
	      resolve(window);
	    }, true);
	  }

	  return promise;
	}
	exports.onFocus = onFocus;

	var isFocused = dispatcher("window-isFocused");
	isFocused.when(x => x instanceof Ci.nsIDOMWindow, (window) => {
	  const FM = Cc["@mozilla.org/focus-manager;1"].
	                getService(Ci.nsIFocusManager);

	  let childTargetWindow = {};
	  FM.getFocusedElementForWindow(window, true, childTargetWindow);
	  childTargetWindow = childTargetWindow.value;

	  let focusedChildWindow = {};
	  if (FM.activeWindow) {
	    FM.getFocusedElementForWindow(FM.activeWindow, true, focusedChildWindow);
	    focusedChildWindow = focusedChildWindow.value;
	  }

	  return (focusedChildWindow === childTargetWindow);
	});
	exports.isFocused = isFocused;

	/**
	 * Opens a top level window and returns it's `nsIDOMWindow` representation.
	 * Same as `open` but with more features
	 * @param {Object} options
	 *
	 */
	function openDialog(options) {
	  options = options || {};

	  let features = options.features || FEATURES;
	  let featureAry = features.toLowerCase().split(',');

	  if (!!options.private) {
	    // add private flag if private window is desired
	    if (!array.has(featureAry, 'private')) {
	      featureAry.push('private');
	    }

	    // remove the non-private flag ig a private window is desired
	    let nonPrivateIndex = featureAry.indexOf('non-private');
	    if (nonPrivateIndex >= 0) {
	      featureAry.splice(nonPrivateIndex, 1);
	    }

	    features = featureAry.join(',');
	  }

	  let browser = getMostRecentBrowserWindow();

	  // if there is no browser then do nothing
	  if (!browser)
	    return undefined;

	  let newWindow = browser.openDialog.apply(
	      browser,
	      array.flatten([
	        options.url || URI_BROWSER,
	        options.name || NAME,
	        features,
	        options.args || null
	      ])
	  );

	  return newWindow;
	}
	exports.openDialog = openDialog;

	/**
	 * Returns an array of all currently opened windows.
	 * Note that these windows may still be loading.
	 */
	function windows(type, options) {
	  options = options || {};
	  let list = [];
	  let winEnum = WM.getEnumerator(type);
	  while (winEnum.hasMoreElements()) {
	    let window = winEnum.getNext().QueryInterface(Ci.nsIDOMWindow);
	    // Only add non-private windows when pb permission isn't set,
	    // unless an option forces the addition of them.
	    if (!window.closed && (options.includePrivate || !isWindowPrivate(window))) {
	      list.push(window);
	    }
	  }
	  return list;
	}
	exports.windows = windows;

	/**
	 * Check if the given window is interactive.
	 * i.e. if its "DOMContentLoaded" event has already been fired.
	 * @params {nsIDOMWindow} window
	 */
	const isInteractive = window =>
	  window.document.readyState === "interactive" ||
	  isDocumentLoaded(window) ||
	  // XUL documents stays '"uninitialized"' until it's `readyState` becomes
	  // `"complete"`.
	  isXULDocumentWindow(window) && window.document.readyState === "interactive";
	exports.isInteractive = isInteractive;

	/**
	 * Check if the given browser window has finished the startup.
	 * @params {nsIDOMWindow} window
	 */
	const isStartupFinished = (window) =>
	  isBrowser(window) &&
	  window.gBrowserInit &&
	  window.gBrowserInit.delayedStartupFinished;

	exports.isStartupFinished = isStartupFinished;

	const isXULDocumentWindow = ({document}) =>
	  document.documentElement &&
	  document.documentElement.namespaceURI === XUL_NS;

	/**
	 * Check if the given window is completely loaded.
	 * i.e. if its "load" event has already been fired and all possible DOM content
	 * is done loading (the whole DOM document, images content, ...)
	 * @params {nsIDOMWindow} window
	 */
	function isDocumentLoaded(window) {
	  return window.document.readyState == "complete";
	}
	exports.isDocumentLoaded = isDocumentLoaded;

	function isBrowser(window) {
	  try {
	    return window.document.documentElement.getAttribute("windowtype") === BROWSER;
	  }
	  catch (e) {}
	  return false;
	};
	exports.isBrowser = isBrowser;

	function getWindowTitle(window) {
	  return window && window.document ? window.document.title : null;
	}
	exports.getWindowTitle = getWindowTitle;

	function isXULBrowser(window) {
	  return !!(isBrowser(window) && window.XULBrowserWindow);
	}
	exports.isXULBrowser = isXULBrowser;

	/**
	 * Returns the most recent focused window
	 */
	function getFocusedWindow() {
	  let window = WM.getMostRecentWindow(BROWSER);

	  return window ? window.document.commandDispatcher.focusedWindow : null;
	}
	exports.getFocusedWindow = getFocusedWindow;

	/**
	 * Returns the focused browser window if any, or the most recent one.
	 * Opening new window, updates most recent window, but focus window
	 * changes later; so most recent window and focused window are not always
	 * the same.
	 */
	function getFocusedBrowser() {
	  let window = FM.activeWindow;
	  return isBrowser(window) ? window : getMostRecentBrowserWindow()
	}
	exports.getFocusedBrowser = getFocusedBrowser;

	/**
	 * Returns the focused element in the most recent focused window
	 */
	function getFocusedElement() {
	  let window = WM.getMostRecentWindow(BROWSER);

	  return window ? window.document.commandDispatcher.focusedElement : null;
	}
	exports.getFocusedElement = getFocusedElement;

	function getFrames(window) {
	  return Array.slice(window.frames).reduce(function(frames, frame) {
	    return frames.concat(frame, getFrames(frame));
	  }, []);
	}
	exports.getFrames = getFrames;

	function getScreenPixelsPerCSSPixel(window) {
	  return window.QueryInterface(Ci.nsIInterfaceRequestor).
	                getInterface(Ci.nsIDOMWindowUtils).screenPixelsPerCSSPixel;
	}
	exports.getScreenPixelsPerCSSPixel = getScreenPixelsPerCSSPixel;

	function getOwnerBrowserWindow(node) {
	  /**
	  Takes DOM node and returns browser window that contains it.
	  **/
	  let window = getToplevelWindow(node.ownerDocument.defaultView);
	  // If anchored window is browser then it's target browser window.
	  return isBrowser(window) ? window : null;
	}
	exports.getOwnerBrowserWindow = getOwnerBrowserWindow;

	function getParentWindow(window) {
	  try {
	    return window.QueryInterface(Ci.nsIInterfaceRequestor)
	      .getInterface(Ci.nsIWebNavigation)
	      .QueryInterface(Ci.nsIDocShellTreeItem).parent
	      .QueryInterface(Ci.nsIInterfaceRequestor)
	      .getInterface(Ci.nsIDOMWindow);
	  }
	  catch (e) {}
	  return null;
	}
	exports.getParentWindow = getParentWindow;


	function getParentFrame(window) {
	  try {
	    return window.QueryInterface(Ci.nsIInterfaceRequestor)
	      .getInterface(Ci.nsIWebNavigation)
	      .QueryInterface(Ci.nsIDocShellTreeItem).parent
	      .QueryInterface(Ci.nsIInterfaceRequestor)
	      .getInterface(Ci.nsIDOMWindow);
	  }
	  catch (e) {}
	  return null;
	}
	exports.getParentWindow = getParentWindow;

	// The element in which the window is embedded, or `null`
	// if the window is top-level. Similar to `window.frameElement`
	// but can cross chrome-content boundries.
	const getFrameElement = target =>
	  (target instanceof Ci.nsIDOMDocument ? target.defaultView : target).
	  QueryInterface(Ci.nsIInterfaceRequestor).
	  getInterface(Ci.nsIDOMWindowUtils).
	  containerElement;
	exports.getFrameElement = getFrameElement;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	'use strict';

	/*
	 * Uses `Promise.jsm` as a core implementation, with additional sugar
	 * from previous implementation, with inspiration from `Q` and `when`
	 *
	 * https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm
	 * https://github.com/cujojs/when
	 * https://github.com/kriskowal/q
	 */
	const PROMISE_URI = 'resource://gre/modules/Promise.jsm';

	getEnvironment.call(this, function ({ require, exports, module, Cu }) {

	const Promise = Cu.import(PROMISE_URI, {}).Promise;
	const { Debugging, defer, resolve, all, reject, race } = Promise;

	module.metadata = {
	  'stability': 'unstable'
	};

	var promised = (function() {
	  // Note: Define shortcuts and utility functions here in order to avoid
	  // slower property accesses and unnecessary closure creations on each
	  // call of this popular function.

	  var call = Function.call;
	  var concat = Array.prototype.concat;

	  // Utility function that does following:
	  // execute([ f, self, args...]) => f.apply(self, args)
	  function execute (args) {
	    return call.apply(call, args);
	  }

	  // Utility function that takes promise of `a` array and maybe promise `b`
	  // as arguments and returns promise for `a.concat(b)`.
	  function promisedConcat(promises, unknown) {
	    return promises.then(function (values) {
	      return resolve(unknown)
	        .then(value => values.concat([value]));
	    });
	  }

	  return function promised(f, prototype) {
	    /**
	    Returns a wrapped `f`, which when called returns a promise that resolves to
	    `f(...)` passing all the given arguments to it, which by the way may be
	    promises. Optionally second `prototype` argument may be provided to be used
	    a prototype for a returned promise.

	    ## Example

	    var promise = promised(Array)(1, promise(2), promise(3))
	    promise.then(console.log) // => [ 1, 2, 3 ]
	    **/

	    return function promised(...args) {
	      // create array of [ f, this, args... ]
	      return [f, this, ...args].
	        // reduce it via `promisedConcat` to get promised array of fulfillments
	        reduce(promisedConcat, resolve([], prototype)).
	        // finally map that to promise of `f.apply(this, args...)`
	        then(execute);
	    };
	  };
	})();

	exports.promised = promised;
	exports.all = all;
	exports.defer = defer;
	exports.resolve = resolve;
	exports.reject = reject;
	exports.race = race;
	exports.Promise = Promise;
	exports.Debugging = Debugging;
	});

	function getEnvironment (callback) {
	  let Cu, _exports, _module, _require;

	  // CommonJS / SDK
	  if (true) {
	    Cu = __webpack_require__(9).Cu;
	    _exports = exports;
	    _module = module;
	    _require = require;
	  }
	  // JSM
	  else if (String(this).indexOf('BackstagePass') >= 0) {
	    Cu = this['Components'].utils;
	    _exports = this.Promise = {};
	    _module = { uri: __URI__, id: 'promise/core' };
	    _require = uri => {
	      let imports = {};
	      Cu.import(uri, imports);
	      return imports;
	    };
	    this.EXPORTED_SYMBOLS = ['Promise'];
	  // mozIJSSubScriptLoader.loadSubscript
	  } else if (~String(this).indexOf('Sandbox')) {
	    Cu = this['Components'].utils;
	    _exports = this;
	    _module = { id: 'promise/core' };
	    _require = uri => {};
	  }

	  callback({
	    Cu: Cu,
	    exports: _exports,
	    module: _module,
	    require: !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())
	  });
	}


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 43 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 43;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "experimental"
	};

	const method = __webpack_require__(45);

	// Utility function that is just an enhancement over `method` to
	// allow predicate based dispatch in addition to polymorphic
	// dispatch. Unfortunately polymorphic dispatch does not quite
	// cuts it in the world of XPCOM where no types / classes exist
	// and all the XUL nodes share same type / prototype.
	// Probably this is more generic and belongs some place else, but
	// we can move it later once this will be relevant.
	var dispatcher = hint => {
	  const base = method(hint);
	  // Make a map for storing predicate, implementation mappings.
	  let implementations = new Map();

	  // Dispatcher function goes through `predicate, implementation`
	  // pairs to find predicate that matches first argument and
	  // returns application of arguments on the associated
	  // `implementation`. If no matching predicate is found delegates
	  // to a `base` polymorphic function.
	  let dispatch = (value, ...rest) => {
	    for (let [predicate, implementation] of implementations) {
	      if (predicate(value))
	        return implementation(value, ...rest);
	    }

	    return base(value, ...rest);
	  };

	  // Expose base API.
	  dispatch.define = base.define;
	  dispatch.implement = base.implement;
	  dispatch.toString = base.toString;

	  // Add a `when` function to allow extending function via
	  // predicates.
	  dispatch.when = (predicate, implementation) => {
	    if (implementations.has(predicate))
	      throw TypeError("Already implemented for the given predicate");
	    implementations.set(predicate, implementation);
	  };

	  return dispatch;
	};

	exports.dispatcher = dispatcher;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var defineProperty = Object.defineProperty || function(object, name, property) {
	  object[name] = property.value
	  return object
	}

	// Shortcut for `Object.prototype.toString` for faster access.
	var typefy = Object.prototype.toString

	// Map to for jumping from typeof(value) to associated type prefix used
	// as a hash in the map of builtin implementations.
	var types = { "function": "Object", "object": "Object" }

	// Array is used to save method implementations for the host objects in order
	// to avoid extending them with non-primitive values that could cause leaks.
	var host = []
	// Hash map is used to save method implementations for builtin types in order
	// to avoid extending their prototypes. This also allows to share method
	// implementations for types across diff contexts / frames / compartments.
	var builtin = {}

	function Primitive() {}
	function ObjectType() {}
	ObjectType.prototype = new Primitive()
	function ErrorType() {}
	ErrorType.prototype = new ObjectType()

	var Default = builtin.Default = Primitive.prototype
	var Null = builtin.Null = new Primitive()
	var Void = builtin.Void = new Primitive()
	builtin.String = new Primitive()
	builtin.Number = new Primitive()
	builtin.Boolean = new Primitive()

	builtin.Object = ObjectType.prototype
	builtin.Error = ErrorType.prototype

	builtin.EvalError = new ErrorType()
	builtin.InternalError = new ErrorType()
	builtin.RangeError = new ErrorType()
	builtin.ReferenceError = new ErrorType()
	builtin.StopIteration = new ErrorType()
	builtin.SyntaxError = new ErrorType()
	builtin.TypeError = new ErrorType()
	builtin.URIError = new ErrorType()


	function Method(hint) {
	  /**
	  Private Method is a callable private name that dispatches on the first
	  arguments same named Method:

	      method(object, ...rest) => object[method](...rest)

	  Optionally hint string may be provided that will be used in generated names
	  to ease debugging.

	  ## Example

	      var foo = Method()

	      // Implementation for any types
	      foo.define(function(value, arg1, arg2) {
	        // ...
	      })

	      // Implementation for a specific type
	      foo.define(BarType, function(bar, arg1, arg2) {
	        // ...
	      })
	  **/

	  // Create an internal unique name if `hint` is provided it is used to
	  // prefix name to ease debugging.
	  var name = (hint || "") + "#" + Math.random().toString(32).substr(2)

	  function dispatch(value) {
	    // Method dispatches on type of the first argument.
	    // If first argument is `null` or `void` associated implementation is
	    // looked up in the `builtin` hash where implementations for built-ins
	    // are stored.
	    var type = null
	    var method = value === null ? Null[name] :
	                 value === void(0) ? Void[name] :
	                 // Otherwise attempt to use method with a generated private
	                 // `name` that is supposedly in the prototype chain of the
	                 // `target`.
	                 value[name] ||
	                 // Otherwise assume it's one of the built-in type instances,
	                 // in which case implementation is stored in a `builtin` hash.
	                 // Attempt to find a implementation for the given built-in
	                 // via constructor name and method name.
	                 ((type = builtin[(value.constructor || "").name]) &&
	                  type[name]) ||
	                 // Otherwise assume it's a host object. For host objects
	                 // actual method implementations are stored in the `host`
	                 // array and only index for the implementation is stored
	                 // in the host object's prototype chain. This avoids memory
	                 // leaks that otherwise could happen when saving JS objects
	                 // on host object.
	                 host[value["!" + name] || void(0)] ||
	                 // Otherwise attempt to lookup implementation for builtins by
	                 // a type of the value. This basically makes sure that all
	                 // non primitive values will delegate to an `Object`.
	                 ((type = builtin[types[typeof(value)]]) && type[name])


	    // If method implementation for the type is still not found then
	    // just fallback for default implementation.
	    method = method || Default[name]


	    // If implementation is still not found (which also means there is no
	    // default) just throw an error with a descriptive message.
	    if (!method) throw TypeError("Type does not implements method: " + name)

	    // If implementation was found then just delegate.
	    return method.apply(method, arguments)
	  }

	  // Make `toString` of the dispatch return a private name, this enables
	  // method definition without sugar:
	  //
	  //    var method = Method()
	  //    object[method] = function() { /***/ }
	  dispatch.toString = function toString() { return name }

	  // Copy utility methods for convenient API.
	  dispatch.implement = implementMethod
	  dispatch.define = defineMethod

	  return dispatch
	}

	// Create method shortcuts form functions.
	var defineMethod = function defineMethod(Type, lambda) {
	  return __webpack_require__(46)(this, Type, lambda)
	}
	var implementMethod = function implementMethod(object, lambda) {
	  return implement(this, object, lambda)
	}

	// Define `implement` and `define` polymorphic methods to allow definitions
	// and implementations through them.
	var implement = Method("implement")
	var define = Method("define")


	function _implement(method, object, lambda) {
	  /**
	  Implements `Method` for the given `object` with a provided `implementation`.
	  Calling `Method` with `object` as a first argument will dispatch on provided
	  implementation.
	  **/
	  return defineProperty(object, method.toString(), {
	    enumerable: false,
	    configurable: false,
	    writable: false,
	    value: lambda
	  })
	}

	function _define(method, Type, lambda) {
	  /**
	  Defines `Method` for the given `Type` with a provided `implementation`.
	  Calling `Method` with a first argument of this `Type` will dispatch on
	  provided `implementation`. If `Type` is a `Method` default implementation
	  is defined. If `Type` is a `null` or `undefined` `Method` is implemented
	  for that value type.
	  **/

	  // Attempt to guess a type via `Object.prototype.toString.call` hack.
	  var type = Type && typefy.call(Type.prototype)

	  // If only two arguments are passed then `Type` is actually an implementation
	  // for a default type.
	  if (!lambda) Default[method] = Type
	  // If `Type` is `null` or `void` store implementation accordingly.
	  else if (Type === null) Null[method] = lambda
	  else if (Type === void(0)) Void[method] = lambda
	  // If `type` hack indicates built-in type and type has a name us it to
	  // store a implementation into associated hash. If hash for this type does
	  // not exists yet create one.
	  else if (type !== "[object Object]" && Type.name) {
	    var Bulitin = builtin[Type.name] || (builtin[Type.name] = new ObjectType())
	    Bulitin[method] = lambda
	  }
	  // If `type` hack indicates an object, that may be either object or any
	  // JS defined "Class". If name of the constructor is `Object`, assume it's
	  // built-in `Object` and store implementation accordingly.
	  else if (Type.name === "Object")
	    builtin.Object[method] = lambda
	  // Host objects are pain!!! Every browser does some crazy stuff for them
	  // So far all browser seem to not implement `call` method for host object
	  // constructors. If that is a case here, assume it's a host object and
	  // store implementation in a `host` array and store `index` in the array
	  // in a `Type.prototype` itself. This avoids memory leaks that could be
	  // caused by storing JS objects on a host objects.
	  else if (Type.call === void(0)) {
	    var index = host.indexOf(lambda)
	    if (index < 0) index = host.push(lambda) - 1
	    // Prefix private name with `!` so it can be dispatched from the method
	    // without type checks.
	    implement("!" + method, Type.prototype, index)
	  }
	  // If Got that far `Type` is user defined JS `Class`. Define private name
	  // as hidden property on it's prototype.
	  else
	    implement(method, Type.prototype, lambda)
	}

	// And provided implementations for a polymorphic equivalents.
	_define(define, _define)
	_define(implement, _implement)

	// Define exports on `Method` as it's only thing being exported.
	Method.implement = implement
	Method.define = define
	Method.Method = Method
	Method.method = Method
	Method.builtin = builtin
	Method.host = host

	module.exports = Method


/***/ },
/* 46 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	// The minimum and maximum integers that can be set as preferences.
	// The range of valid values is narrower than the range of valid JS values
	// because the native preferences code treats integers as NSPR PRInt32s,
	// which are 32-bit signed integers on all platforms.
	const MAX_INT = 0x7FFFFFFF;
	const MIN_INT = -0x80000000;

	const {Cc,Ci,Cr} = __webpack_require__(9);

	const prefService = Cc["@mozilla.org/preferences-service;1"].
	                getService(Ci.nsIPrefService);
	const prefSvc = prefService.getBranch(null);
	const defaultBranch = prefService.getDefaultBranch(null);

	const { Preferences } = __webpack_require__(9);
	const prefs = new Preferences({});

	const branchKeys = branchName =>
	  keys(branchName).map($ => $.replace(branchName, ""));

	const Branch = function(branchName) {
	  return new Proxy(Branch.prototype, {
	    getOwnPropertyDescriptor(target, name, receiver) {
	      return {
	        configurable: true,
	        enumerable: true,
	        writable: false,
	        value: this.get(target, name, receiver)
	      };
	    },
	    ownKeys(target) {
	      return branchKeys(branchName);
	    },
	    get(target, name, receiver) {
	      return get(`${branchName}${name}`);
	    },
	    set(target, name, value, receiver) {
	      set(`${branchName}${name}`, value);
	      return true;
	    },
	    has(target, name) {
	      return this.hasOwn(target, name);
	    },
	    hasOwn(target, name) {
	      return has(`${branchName}${name}`);
	    },
	    deleteProperty(target, name) {
	      reset(`${branchName}${name}`);
	      return true;
	    }
	  });
	}


	function get(name, defaultValue) {
	  return prefs.get(name, defaultValue);
	}
	exports.get = get;


	function set(name, value) {
	  var prefType;
	  if (typeof value != "undefined" && value != null)
	    prefType = value.constructor.name;

	  switch (prefType) {
	  case "Number":
	    if (value % 1 != 0)
	      throw new Error("cannot store non-integer number: " + value);
	  }

	  prefs.set(name, value);
	}
	exports.set = set;

	const has = prefs.has.bind(prefs)
	exports.has = has;

	function keys(root) {
	  return prefSvc.getChildList(root);
	}
	exports.keys = keys;

	const isSet = prefs.isSet.bind(prefs);
	exports.isSet = isSet;

	function reset(name) {
	  try {
	    prefSvc.clearUserPref(name);
	  }
	  catch (e) {
	    // The pref service throws NS_ERROR_UNEXPECTED when the caller tries
	    // to reset a pref that doesn't exist or is already set to its default
	    // value.  This interface fails silently in those cases, so callers
	    // can unconditionally reset a pref without having to check if it needs
	    // resetting first or trap exceptions after the fact.  It passes through
	    // other exceptions, however, so callers know about them, since we don't
	    // know what other exceptions might be thrown and what they might mean.
	    if (e.result != Cr.NS_ERROR_UNEXPECTED) {
	      throw e;
	    }
	  }
	}
	exports.reset = reset;

	function getLocalized(name, defaultValue) {
	  let value = null;
	  try {
	    value = prefSvc.getComplexValue(name, Ci.nsIPrefLocalizedString).data;
	  }
	  finally {
	    return value || defaultValue;
	  }
	}
	exports.getLocalized = getLocalized;

	function setLocalized(name, value) {
	  // We can't use `prefs.set` here as we have to use `getDefaultBranch`
	  // (instead of `getBranch`) in order to have `mIsDefault` set to true, here:
	  // http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/nsPrefBranch.cpp#233
	  // Otherwise, we do not enter into this expected condition:
	  // http://mxr.mozilla.org/mozilla-central/source/modules/libpref/src/nsPrefBranch.cpp#244
	  defaultBranch.setCharPref(name, value);
	}
	exports.setLocalized = setLocalized;

	exports.Branch = Branch;


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// Register about:devtools-toolbox which allows to open a devtools toolbox
	// in a Firefox tab or a custom html iframe in browser.html

	const { Ci, Cu, Cm, components } = __webpack_require__(9);
	const registrar = Cm.QueryInterface(Ci.nsIComponentRegistrar);
	const Services = __webpack_require__(1);
	const { XPCOMUtils } = Cu.import("resource://gre/modules/XPCOMUtils.jsm", {});
	const { nsIAboutModule } = Ci;

	function AboutURL() {}

	AboutURL.prototype = {
	  uri: Services.io.newURI("chrome://devtools/content/framework/toolbox.xul",
	                          null, null),
	  classDescription: "about:devtools-toolbox",
	  classID: components.ID("11342911-3135-45a8-8d71-737a2b0ad469"),
	  contractID: "@mozilla.org/network/protocol/about;1?what=devtools-toolbox",

	  QueryInterface: XPCOMUtils.generateQI([nsIAboutModule]),

	  newChannel: function (aURI, aLoadInfo) {
	    let chan = Services.io.newChannelFromURIWithLoadInfo(this.uri, aLoadInfo);
	    chan.owner = Services.scriptSecurityManager.getSystemPrincipal();
	    return chan;
	  },

	  getURIFlags: function (aURI) {
	    return nsIAboutModule.ALLOW_SCRIPT || nsIAboutModule.ENABLE_INDEXED_DB;
	  }
	};

	AboutURL.createInstance = function (outer, iid) {
	  if (outer) {
	    throw Cr.NS_ERROR_NO_AGGREGATION;
	  }
	  return new AboutURL();
	};

	exports.register = function () {
	  if (registrar.isCIDRegistered(AboutURL.prototype.classID)) {
	    console.error("Trying to register " + AboutURL.prototype.classDescription +
	                  " more than once.");
	  } else {
	    registrar.registerFactory(AboutURL.prototype.classID,
	                       AboutURL.prototype.classDescription,
	                       AboutURL.prototype.contractID,
	                       AboutURL);
	  }
	};

	exports.unregister = function () {
	  if (registrar.isCIDRegistered(AboutURL.prototype.classID)) {
	    registrar.unregisterFactory(AboutURL.prototype.classID, AboutURL);
	  }
	};


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Parts of this module were taken from narwhal:
	//
	// http://narwhaljs.org

	module.metadata = {
	  "stability": "experimental"
	};

	const { Cu } = __webpack_require__(9);
	const { on, off } = __webpack_require__(50);
	const unloadSubject = __webpack_require__(9);

	const observers = [];
	const unloaders = [];

	function WeakObserver(inner) {
	  this._inner = Cu.getWeakReference(inner);
	}

	Object.defineProperty(WeakObserver.prototype, 'value', {
	  get: function() { this._inner.get() }
	});

	var when = exports.when = function when(observer, opts) {
	  opts = opts || {};
	  for (var i = 0; i < observers.length; ++i) {
	    if (observers[i] === observer || observers[i].value === observer) {
	      return;
	    }
	  }
	  if (opts.weak) {
	    observers.unshift(new WeakObserver(observer));
	  } else {
	    observers.unshift(observer);
	  }
	};

	var ensure = exports.ensure = function ensure(obj, destructorName) {
	  if (!destructorName)
	    destructorName = "unload";
	  if (!(destructorName in obj))
	    throw new Error("object has no '" + destructorName + "' property");

	  let called = false;
	  let originalDestructor = obj[destructorName];

	  function unloadWrapper(reason) {
	    if (!called) {
	      called = true;
	      let index = unloaders.indexOf(unloadWrapper);
	      if (index == -1)
	        throw new Error("internal error: unloader not found");
	      unloaders.splice(index, 1);
	      originalDestructor.call(obj, reason);
	      originalDestructor = null;
	      destructorName = null;
	      obj = null;
	    }
	  };

	  // TODO: Find out why the order is inverted here. It seems that
	  // it may be causing issues!
	  unloaders.push(unloadWrapper);

	  obj[destructorName] = unloadWrapper;
	};

	function unload(reason) {
	  observers.forEach(function(observer) {
	    try {
	      if (observer instanceof WeakObserver) {
	        observer = observer.value;
	      }
	      if (typeof observer === 'function') {
	        observer(reason);
	      }
	    }
	    catch (error) {
	      console.exception(error);
	    }
	  });
	}

	when(function(reason) {
	  unloaders.slice().forEach(function(unloadWrapper) {
	    unloadWrapper(reason);
	  });
	});

	on('sdk:loader:destroy', function onunload({ subject, data: reason }) {
	  // If this loader is unload then `subject.wrappedJSObject` will be
	  // `destructor`.
	  if (subject.wrappedJSObject === unloadSubject) {
	    off('sdk:loader:destroy', onunload);
	    unload(reason);
	  }
	// Note that we use strong reference to listener here to make sure it's not
	// GC-ed, which may happen otherwise since nothing keeps reference to `onunolad`
	// function.
	}, true);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	'use strict';

	module.metadata = {
	  'stability': 'unstable'
	};

	const { Cc, Ci, Cu } = __webpack_require__(9);
	const { Unknown } = __webpack_require__(51);
	const { Class } = __webpack_require__(18);
	const { ns } = __webpack_require__(22);
	const observerService =
	  Cc['@mozilla.org/observer-service;1'].getService(Ci.nsIObserverService);
	const { addObserver, removeObserver, notifyObservers } = observerService;
	const { ShimWaiver } = Cu.import("resource://gre/modules/ShimWaiver.jsm");
	const addObserverNoShim = ShimWaiver.getProperty(observerService, "addObserver");
	const removeObserverNoShim = ShimWaiver.getProperty(observerService, "removeObserver");
	const notifyObserversNoShim = ShimWaiver.getProperty(observerService, "notifyObservers");
	const unloadSubject = __webpack_require__(9);

	const Subject = Class({
	  extends: Unknown,
	  initialize: function initialize(object) {
	    // Double-wrap the object and set a property identifying the
	    // wrappedJSObject as one of our wrappers to distinguish between
	    // subjects that are one of our wrappers (which we should unwrap
	    // when notifying our observers) and those that are real JS XPCOM
	    // components (which we should pass through unaltered).
	    this.wrappedJSObject = {
	      observersModuleSubjectWrapper: true,
	      object: object
	    };
	  },
	  getScriptableHelper: function() {},
	  getInterfaces: function() {}
	});

	function emit(type, event, shimmed = false) {
	  // From bug 910599
	  // We must test to see if 'subject' or 'data' is a defined property
	  // of the event object, but also allow primitives to be passed in,
	  // which the `in` operator breaks, yet `null` is an object, hence
	  // the long conditional
	  let subject = event && typeof event === 'object' && 'subject' in event ?
	    Subject(event.subject) :
	    null;
	  let data = event && typeof event === 'object' ?
	    // An object either returns its `data` property or null
	    ('data' in event ? event.data : null) :
	    // All other types return themselves (and cast to strings/null
	    // via observer service)
	    event;
	  if (shimmed) {
	    notifyObservers(subject, type, data);
	  } else {
	    notifyObserversNoShim(subject, type, data);
	  }
	}
	exports.emit = emit;

	const Observer = Class({
	  extends: Unknown,
	  initialize: function initialize(listener) {
	    this.listener = listener;
	  },
	  interfaces: [ 'nsIObserver', 'nsISupportsWeakReference' ],
	  observe: function(subject, topic, data) {
	    // Extract the wrapped object for subjects that are one of our
	    // wrappers around a JS object.  This way we support both wrapped
	    // subjects created using this module and those that are real
	    // XPCOM components.
	    if (subject && typeof(subject) == 'object' &&
	        ('wrappedJSObject' in subject) &&
	        ('observersModuleSubjectWrapper' in subject.wrappedJSObject))
	      subject = subject.wrappedJSObject.object;

	    try {
	      this.listener({
	        type: topic,
	        subject: subject,
	        data: data
	      });
	    }
	    catch (error) {
	      console.exception(error);
	    }
	  }
	});

	const subscribers = ns();

	function on(type, listener, strong, shimmed = false) {
	  // Unless last optional argument is `true` we use a weak reference to a
	  // listener.
	  let weak = !strong;
	  // Take list of observers associated with given `listener` function.
	  let observers = subscribers(listener);
	  // If `observer` for the given `type` is not registered yet, then
	  // associate an `observer` and register it.
	  if (!(type in observers)) {
	    let observer = Observer(listener);
	    observers[type] = observer;
	    if (shimmed) {
	      addObserver(observer, type, weak);
	    } else {
	      addObserverNoShim(observer, type, weak);
	    }
	    // WeakRef gymnastics to remove all alive observers on unload
	    let ref = Cu.getWeakReference(observer);
	    weakRefs.set(observer, ref);
	    stillAlive.set(ref, type);
	    wasShimmed.set(ref, shimmed);
	  }
	}
	exports.on = on;

	function once(type, listener, shimmed = false) {
	  // Note: this code assumes order in which listeners are called, which is fine
	  // as long as dispatch happens in same order as listener registration which
	  // is the case now. That being said we should be aware that this may break
	  // in a future if order will change.
	  on(type, listener, shimmed);
	  on(type, function cleanup() {
	    off(type, listener, shimmed);
	    off(type, cleanup, shimmed);
	  }, true, shimmed);
	}
	exports.once = once;

	function off(type, listener, shimmed = false) {
	  // Take list of observers as with the given `listener`.
	  let observers = subscribers(listener);
	  // If `observer` for the given `type` is registered, then
	  // remove it & unregister.
	  if (type in observers) {
	    let observer = observers[type];
	    delete observers[type];
	    if (shimmed) {
	      removeObserver(observer, type);
	    } else {
	      removeObserverNoShim(observer, type);
	    }
	    stillAlive.delete(weakRefs.get(observer));
	    wasShimmed.delete(weakRefs.get(observer));
	  }
	}
	exports.off = off;

	// must use WeakMap to keep reference to all the WeakRefs (!), see bug 986115
	var weakRefs = new WeakMap();

	// and we're out of beta, we're releasing on time!
	var stillAlive = new Map();

	var wasShimmed = new Map();

	on('sdk:loader:destroy', function onunload({ subject, data: reason }) {
	  // using logic from ./unload, to avoid a circular module reference
	  if (subject.wrappedJSObject === unloadSubject) {
	    off('sdk:loader:destroy', onunload, false);

	    // don't bother
	    if (reason === 'shutdown') 
	      return;

	    stillAlive.forEach( (type, ref) => {
	      let observer = ref.get();
	      if (observer) {
	        if (wasShimmed.get(ref)) {
	          removeObserver(observer, type);
	        } else {
	          removeObserverNoShim(observer, type);
	        }
	      }
	    })
	  }
	  // a strong reference
	}, true, false);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const { Cc, Ci, Cr, Cm, components: { classesByID } } = __webpack_require__(9);
	const { registerFactory, unregisterFactory, isCIDRegistered } =
	      Cm.QueryInterface(Ci.nsIComponentRegistrar);

	const { merge } = __webpack_require__(25);
	const { Class, extend, mix } = __webpack_require__(18);
	const { uuid } = __webpack_require__(52);

	// This is a base prototype, that provides bare bones of XPCOM. JS based
	// components can be easily implement by extending it.
	const Unknown = new function() {
	  function hasInterface(component, iid) {
	    return component && component.interfaces &&
	      ( component.interfaces.some(id => iid.equals(Ci[id])) ||
	        component.implements.some($ => hasInterface($, iid)) ||
	        hasInterface(Object.getPrototypeOf(component), iid));
	  }

	  return Class({
	    /**
	     * The `QueryInterface` method provides runtime type discovery used by XPCOM.
	     * This method return queried instance of `this` if given `iid` is listed in
	     * the `interfaces` property or in equivalent properties of objects in it's
	     * prototype chain. In addition it will look up in the prototypes under
	     * `implements` array property, this ways compositions made via `Class`
	     * utility will carry interfaces implemented by composition components.
	     */
	    QueryInterface: function QueryInterface(iid) {
	      // For some reason there are cases when `iid` is `null`. In such cases we
	      // just return `this`. Otherwise we verify that component implements given
	      // `iid` interface. This will be no longer necessary once Bug 748003 is
	      // fixed.
	      if (iid && !hasInterface(this, iid))
	        throw Cr.NS_ERROR_NO_INTERFACE;

	      return this;
	    },
	    /**
	     * Array of `XPCOM` interfaces (as strings) implemented by this component.
	     * All components implement `nsISupports` by default which is default value
	     * here. Provide array of interfaces implemented by an object when
	     * extending, to append them to this list (Please note that there is no
	     * need to repeat interfaces implemented by super as they will be added
	     * automatically).
	     */
	    interfaces: Object.freeze([ 'nsISupports' ])
	  });
	}
	exports.Unknown = Unknown;

	// Base exemplar for creating instances implementing `nsIFactory` interface,
	// that maybe registered into runtime via `register` function. Instances of
	// this factory create instances of enclosed component on `createInstance`.
	const Factory = Class({
	  extends: Unknown,
	  interfaces: [ 'nsIFactory' ],
	  /**
	   * All the descendants will get auto generated `id` (also known as `classID`
	   * in XPCOM world) unless one is manually provided.
	   */
	  get id() { throw Error('Factory must implement `id` property') },
	  /**
	   * XPCOM `contractID` may optionally  be provided to associate this factory
	   * with it. `contract` is a unique string that has a following format:
	   * '@vendor.com/unique/id;1'.
	   */
	  contract: null,
	  /**
	   * Class description that is being registered. This value is intended as a
	   * human-readable description for the given class and does not needs to be
	   * globally unique.
	   */
	  description: 'Jetpack generated factory',
	  /**
	   * This method is required by `nsIFactory` interfaces, but as in most
	   * implementations it does nothing interesting.
	   */
	  lockFactory: function lockFactory(lock) {
	    return undefined;
	  },
	  /**
	   * If property is `true` XPCOM service / factory will be registered
	   * automatically on creation.
	   */
	  register: true,
	  /**
	   * If property is `true` XPCOM factory will be unregistered prior to add-on
	   * unload.
	   */
	  unregister: true,
	  /**
	   * Method is called on `Service.new(options)` passing given `options` to
	   * it. Options is expected to have `component` property holding XPCOM
	   * component implementation typically decedent of `Unknown` or any custom
	   * implementation with a `new` method and optional `register`, `unregister`
	   * flags. Unless `register` is `false` Service / Factory will be
	   * automatically registered. Unless `unregister` is `false` component will
	   * be automatically unregistered on add-on unload.
	   */
	  initialize: function initialize(options) {
	    merge(this, {
	      id: 'id' in options ? options.id : uuid(),
	      register: 'register' in options ? options.register : this.register,
	      unregister: 'unregister' in options ? options.unregister : this.unregister,
	      contract: 'contract' in options ? options.contract : null,
	      Component: options.Component
	    });

	    // If service / factory has auto registration enabled then register.
	    if (this.register)
	      register(this);
	  },
	  /**
	   * Creates an instance of the class associated with this factory.
	   */
	  createInstance: function createInstance(outer, iid) {
	    try {
	      if (outer)
	        throw Cr.NS_ERROR_NO_AGGREGATION;
	      return this.create().QueryInterface(iid);
	    }
	    catch (error) {
	      throw error instanceof Ci.nsIException ? error : Cr.NS_ERROR_FAILURE;
	    }
	  },
	  create: function create() {
	    return this.Component();
	  }
	});
	exports.Factory = Factory;

	// Exemplar for creating services that implement `nsIFactory` interface, that
	// can be registered into runtime via call to `register`. This services return
	// enclosed `component` on `getService`.
	const Service = Class({
	  extends: Factory,
	  initialize: function initialize(options) {
	    this.component = options.Component();
	    Factory.prototype.initialize.call(this, options);
	  },
	  description: 'Jetpack generated service',
	  /**
	   * Creates an instance of the class associated with this factory.
	   */
	  create: function create() {
	    return this.component;
	  }
	});
	exports.Service = Service;

	function isRegistered({ id }) {
	  return isCIDRegistered(id);
	}
	exports.isRegistered = isRegistered;

	/**
	 * Registers given `component` object to be used to instantiate a particular
	 * class identified by `component.id`, and creates an association of class
	 * name and `component.contract` with the class.
	 */
	function register(factory) {
	  if (!(factory instanceof Factory)) {
	    throw new Error("xpcom.register() expect a Factory instance.\n" +
	                    "Please refactor your code to new xpcom module if you" +
	                    " are repacking an addon from SDK <= 1.5:\n" +
	                    "https://developer.mozilla.org/en-US/Add-ons/SDK/Low-Level_APIs/platform_xpcom");
	  }

	  registerFactory(factory.id, factory.description, factory.contract, factory);

	  if (factory.unregister)
	    __webpack_require__(49).when(unregister.bind(null, factory));
	}
	exports.register = register;

	/**
	 * Unregister a factory associated with a particular class identified by
	 * `factory.classID`.
	 */
	function unregister(factory) {
	  if (isRegistered(factory))
	    unregisterFactory(factory.id, factory);
	}
	exports.unregister = unregister;

	function autoRegister(path) {
	  // TODO: This assumes that the url points to a directory
	  // that contains subdirectories corresponding to OS/ABI and then
	  // further subdirectories corresponding to Gecko platform version.
	  // we should probably either behave intelligently here or allow
	  // the caller to pass-in more options if e.g. there aren't
	  // Gecko-specific binaries for a component (which will be the case
	  // if only frozen interfaces are used).

	  var runtime = __webpack_require__(53);
	  var osDirName = runtime.OS + "_" + runtime.XPCOMABI;
	  var platformVersion = __webpack_require__(54).platformVersion.substring(0, 5);

	  var file = Cc['@mozilla.org/file/local;1']
	             .createInstance(Ci.nsILocalFile);
	  file.initWithPath(path);
	  file.append(osDirName);
	  file.append(platformVersion);

	  if (!(file.exists() && file.isDirectory()))
	    throw new Error("component not available for OS/ABI " +
	                    osDirName + " and platform " + platformVersion);

	  Cm.QueryInterface(Ci.nsIComponentRegistrar);
	  Cm.autoRegister(file);
	}
	exports.autoRegister = autoRegister;

	/**
	 * Returns registered factory that has a given `id` or `null` if not found.
	 */
	function factoryByID(id) {
	  return classesByID[id] || null;
	}
	exports.factoryByID = factoryByID;

	/**
	 * Returns factory registered with a given `contract` or `null` if not found.
	 * In contrast to `Cc[contract]` that does ignores new factory registration
	 * with a given `contract` this will return a factory currently associated
	 * with a `contract`.
	 */
	function factoryByContract(contract) {
	  return factoryByID(Cm.contractIDToCID(contract));
	}
	exports.factoryByContract = factoryByContract;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const { Cc, Ci, components: { ID: parseUUID } } = __webpack_require__(9);
	const { generateUUID } = Cc['@mozilla.org/uuid-generator;1'].
	                          getService(Ci.nsIUUIDGenerator);

	// Returns `uuid`. If `id` is passed then it's parsed to `uuid` and returned
	// if not then new one is generated.
	exports.uuid = function uuid(id) {
	  return id ? parseUUID(id) : generateUUID();
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	module.metadata = {
	  "stability": "unstable"
	};

	const { Cc, Ci } = __webpack_require__(9);
	const runtime = Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime);

	exports.inSafeMode = runtime.inSafeMode;
	exports.OS = runtime.OS;
	exports.processType = runtime.processType;
	exports.widgetToolkit = runtime.widgetToolkit;
	exports.processID = runtime.processID;

	// Attempt to access `XPCOMABI` may throw exception, in which case exported
	// `XPCOMABI` will be set to `null`.
	// https://mxr.mozilla.org/mozilla-central/source/toolkit/xre/nsAppRunner.cpp#732
	try {
	  exports.XPCOMABI = runtime.XPCOMABI;
	}
	catch (error) {
	  exports.XPCOMABI = null;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	module.metadata = {
	  "stability": "experimental"
	};

	const { XulApp } = __webpack_require__(55);

	Object.keys(XulApp).forEach(k => exports[k] = XulApp[k]);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 55 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	this.EXPORTED_SYMBOLS = [ "XulApp" ];

	var { classes: Cc, interfaces: Ci } = Components;

	var exports = {};
	this.XulApp = exports;

	var appInfo;

	// NOTE: below is required to avoid failing xpcshell tests,
	//       which do not implement nsIXULAppInfo
	// See Bug 1114752 https://bugzilla.mozilla.org/show_bug.cgi?id=1114752
	try {
	 appInfo = Cc["@mozilla.org/xre/app-info;1"]
	              .getService(Ci.nsIXULAppInfo);
	}
	catch (e) {
	  // xpcshell test case
	  appInfo = {};
	}
	var vc = Cc["@mozilla.org/xpcom/version-comparator;1"]
	         .getService(Ci.nsIVersionComparator);

	var ID = exports.ID = appInfo.ID;
	var name = exports.name = appInfo.name;
	var version = exports.version = appInfo.version;
	var platformVersion = exports.platformVersion = appInfo.platformVersion;

	// The following mapping of application names to GUIDs was taken from:
	//
	//   https://addons.mozilla.org/en-US/firefox/pages/appversions
	//
	// Using the GUID instead of the app's name is preferable because sometimes
	// re-branded versions of a product have different names: for instance,
	// Firefox, Minefield, Iceweasel, and Shiretoko all have the same
	// GUID.

	var ids = exports.ids = {
	  Firefox: "{ec8030f7-c20a-464f-9b0e-13a3a9e97384}",
	  Mozilla: "{86c18b42-e466-45a9-ae7a-9b95ba6f5640}",
	  SeaMonkey: "{92650c4d-4b8e-4d2a-b7eb-24ecf4f6b63a}",
	  Fennec: "{aa3c5121-dab2-40e2-81ca-7ea25febc110}",
	  Thunderbird: "{3550f703-e582-4d05-9a08-453d09bdfdc6}",
	  Instantbird: "{33cb9019-c295-46dd-be21-8c4936574bee}"
	};

	function is(name) {
	  if (!(name in ids))
	    throw new Error("Unkown Mozilla Application: " + name);
	  return ID == ids[name];
	};
	exports.is = is;

	function isOneOf(names) {
	  for (var i = 0; i < names.length; i++)
	    if (is(names[i]))
	      return true;
	  return false;
	};
	exports.isOneOf = isOneOf;

	/**
	 * Use this to check whether the given version (e.g. xulApp.platformVersion)
	 * is in the given range. Versions must be in version comparator-compatible
	 * format. See MDC for details:
	 * https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsIVersionComparator
	 */
	var versionInRange = exports.versionInRange =
	function versionInRange(version, lowInclusive, highExclusive) {
	  return (vc.compare(version, lowInclusive) >= 0) &&
	         (vc.compare(version, highExclusive) < 0);
	}

	const reVersionRange = /^((?:<|>)?=?)?\s*((?:\d+[\S]*)|\*)(?:\s+((?:<|>)=?)?(\d+[\S]+))?$/;
	const reOnlyInifinity = /^[<>]?=?\s*[*x]$/;
	const reSubInfinity = /\.[*x]/g;
	const reHyphenRange = /^(\d+.*?)\s*-\s*(\d+.*?)$/;
	const reRangeSeparator = /\s*\|\|\s*/;

	const compares = {
	  "=": function (c) { return c === 0 },
	  ">=": function (c) { return c >= 0 },
	  "<=": function (c) { return c <= 0},
	  "<": function (c) { return c < 0 },
	  ">": function (c) { return c > 0 }
	}

	function normalizeRange(range) {
	    return range
	        .replace(reOnlyInifinity, "")
	        .replace(reSubInfinity, ".*")
	        .replace(reHyphenRange, ">=$1 <=$2")
	}

	/**
	 * Compare the versions given, using the comparison operator provided.
	 * Internal use only.
	 *
	 * @example
	 *  compareVersion("1.2", "<=", "1.*") // true
	 *
	 * @param {String} version
	 *  A version to compare
	 *
	 * @param {String} comparison
	 *  The comparison operator
	 *
	 * @param {String} compareVersion
	 *  A version to compare
	 */
	function compareVersion(version, comparison, compareVersion) {
	  let hasWildcard = compareVersion.indexOf("*") !== -1;

	  comparison = comparison || "=";

	  if (hasWildcard) {
	    switch (comparison) {
	      case "=":
	        let zeroVersion = compareVersion.replace(reSubInfinity, ".0");
	        return versionInRange(version, zeroVersion, compareVersion);
	      case ">=":
	        compareVersion = compareVersion.replace(reSubInfinity, ".0");
	        break;
	    }
	  }

	  let compare = compares[comparison];

	  return typeof compare === "function" && compare(vc.compare(version, compareVersion));
	}

	/**
	 * Returns `true` if `version` satisfies the `versionRange` given.
	 * If only an argument is passed, is used as `versionRange` and compared against
	 * `xulApp.platformVersion`.
	 *
	 * `versionRange` is either a string which has one or more space-separated
	 * descriptors, or a range like "fromVersion - toVersion".
	 * Version range descriptors may be any of the following styles:
	 *
	 * - "version" Must match `version` exactly
	 * - "=version" Same as just `version`
	 * - ">version" Must be greater than `version`
	 * - ">=version" Must be greater or equal than `version`
	 * - "<version" Must be less than `version`
	 * - "<=version" Must be less or equal than `version`
	 * - "1.2.x" or "1.2.*" See 'X version ranges' below
	 * - "*" or "" (just an empty string) Matches any version
	 * - "version1 - version2" Same as ">=version1 <=version2"
	 * - "range1 || range2" Passes if either `range1` or `range2` are satisfied
	 *
	 * For example, these are all valid:
	 * - "1.0.0 - 2.9999.9999"
	 * - ">=1.0.2 <2.1.2"
	 * - ">1.0.2 <=2.3.4"
	 * - "2.0.1"
	 * - "<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0"
	 * - "2.x" (equivalent to "2.*")
	 * - "1.2.x" (equivalent to "1.2.*" and ">=1.2.0 <1.3.0")
	 */
	function satisfiesVersion(version, versionRange) {
	  if (arguments.length === 1) {
	    versionRange = version;
	    version = appInfo.version;
	  }

	  let ranges = versionRange.trim().split(reRangeSeparator);

	  return ranges.some(function(range) {
	    range = normalizeRange(range);

	    // No versions' range specified means that any version satisfies the
	    // requirements.
	    if (range === "")
	      return true;

	    let matches = range.match(reVersionRange);

	    if (!matches)
	      return false;

	    let [, lowMod, lowVer, highMod, highVer] = matches;

	    return compareVersion(version, lowMod, lowVer) && (highVer !== undefined
	      ? compareVersion(version, highMod, highVer)
	      : true);
	  });
	}
	exports.satisfiesVersion = satisfiesVersion;

	/**
	 * Ensure the current application satisfied the requirements specified in the
	 * module given. If not, an exception related to the incompatibility is
	 * returned; `null` otherwise.
	 *
	 * @param {Object} module
	 *  The module to check
	 * @returns {Error}
	 */
	function incompatibility(module) {
	  let { metadata, id } = module;

	  // if metadata or engines are not specified we assume compatibility is not
	  // an issue.
	  if (!metadata || !("engines" in metadata))
	    return null;

	  let { engines } = metadata;

	  if (engines === null || typeof(engines) !== "object")
	    return new Error("Malformed engines' property in metadata");

	  let applications = Object.keys(engines);

	  let versionRange;
	  applications.forEach(function(name) {
	    if (is(name)) {
	      versionRange = engines[name];
	      // Continue iteration. We want to ensure the module doesn't
	      // contain a typo in the applications' name or some unknown
	      // application - `is` function throws an exception in that case.
	    }
	  });

	  if (typeof(versionRange) === "string") {
	    if (satisfiesVersion(versionRange))
	      return null;

	    return new Error("Unsupported Application version: The module " + id +
	            " currently supports only version " + versionRange + " of " +
	            name + ".");
	  }

	  return new Error("Unsupported Application: The module " + id +
	            " currently supports only " + applications.join(", ") + ".")
	}
	exports.incompatibility = incompatibility;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const parsePropertiesFile = __webpack_require__(57);
	const { sprintf } = __webpack_require__(58);

	const propertiesMap = {};

	// Some shenanigans are needed for LocalizationHelper's dynamic
	// require to work with Webpack.  Here we a create different context
	// require for each possible locale directory.  Then later we use
	// these functions, rather than plain |require|, to load the resource.
	const reqShared = __webpack_require__(59);
	const reqClient = __webpack_require__(66);
	const reqGlobal = __webpack_require__(103);

	/**
	 * Memoized getter for properties files that ensures a given url is only required and
	 * parsed once.
	 *
	 * @param {String} url
	 *        The URL of the properties file to parse.
	 * @return {Object} parsed properties mapped in an object.
	 */
	function getProperties(url) {
	  if (!propertiesMap[url]) {
	    // More shenanigans.  Here we take an input like
	    // "devtools-shared/locale/debugger.properties" and decide which
	    // context require function to use.  Despite the string processing
	    // here, in the end a string identical to |url| ends up being
	    // passed to "require".
	    let index = url.lastIndexOf("/");
	    // Turn "mumble/locale/resource.properties" => "./resource.properties".
	    let baseName = "." + url.substr(index);
	    let reqFn;
	    if (/^global/.test(url)) {
	      reqFn = reqGlobal;
	    } else if (/^devtools-shared/.test(url)) {
	      reqFn = reqShared;
	    } else {
	      reqFn = reqClient;
	    }
	    propertiesMap[url] = parsePropertiesFile(reqFn(baseName));
	  }

	  return propertiesMap[url];
	}

	/**
	 * Localization convenience methods.
	 *
	 * @param string stringBundleName
	 *        The desired string bundle's name.
	 */
	function LocalizationHelper(stringBundleName) {
	  this.stringBundleName = stringBundleName;
	}

	LocalizationHelper.prototype = {
	  /**
	   * L10N shortcut function.
	   *
	   * @param string name
	   * @return string
	   */
	  getStr: function (name) {
	    let properties = getProperties(this.stringBundleName);
	    if (name in properties) {
	      return properties[name];
	    }

	    throw new Error("No localization found for [" + name + "]");
	  },

	  /**
	   * L10N shortcut function.
	   *
	   * @param string name
	   * @param array args
	   * @return string
	   */
	  getFormatStr: function (name, ...args) {
	    return sprintf(this.getStr(name), ...args);
	  },

	  /**
	   * L10N shortcut function for numeric arguments that need to be formatted.
	   * All numeric arguments will be fixed to 2 decimals and given a localized
	   * decimal separator. Other arguments will be left alone.
	   *
	   * @param string name
	   * @param array args
	   * @return string
	   */
	  getFormatStrWithNumbers: function (name, ...args) {
	    let newArgs = args.map(x => {
	      return typeof x == "number" ? this.numberWithDecimals(x, 2) : x;
	    });

	    return this.getFormatStr(name, ...newArgs);
	  },

	  /**
	   * Converts a number to a locale-aware string format and keeps a certain
	   * number of decimals.
	   *
	   * @param number number
	   *        The number to convert.
	   * @param number decimals [optional]
	   *        Total decimals to keep.
	   * @return string
	   *         The localized number as a string.
	   */
	  numberWithDecimals: function (number, decimals = 0) {
	    // If this is an integer, don't do anything special.
	    if (number === (number|0)) {
	      return number;
	    }
	    // If this isn't a number (and yes, `isNaN(null)` is false), return zero.
	    if (isNaN(number) || number === null) {
	      return "0";
	    }

	    let localized = number.toLocaleString();

	    // If no grouping or decimal separators are available, bail out, because
	    // padding with zeros at the end of the string won't make sense anymore.
	    if (!localized.match(/[^\d]/)) {
	      return localized;
	    }

	    return number.toLocaleString(undefined, {
	      maximumFractionDigits: decimals,
	      minimumFractionDigits: decimals
	    });
	  }
	};

	function getPropertiesForNode(node) {
	  let bundleEl = node.closest("[data-localization-bundle]");
	  if (!bundleEl) {
	    return null;
	  }

	  let propertiesUrl = bundleEl.getAttribute("data-localization-bundle");
	  return getProperties(propertiesUrl);
	}

	/**
	 * Translate existing markup annotated with data-localization attributes.
	 *
	 * How to use data-localization in markup:
	 *
	 *   <div data-localization="content=myContent;title=myTitle"/>
	 *
	 * The data-localization attribute identifies an element as being localizable.
	 * The content of the attribute is semi-colon separated list of descriptors.
	 * - "title=myTitle" means the "title" attribute should be replaced with the localized
	 *   string corresponding to the key "myTitle".
	 * - "content=myContent" means the text content of the node should be replaced by the
	 *   string corresponding to "myContent"
	 *
	 * How to define the localization bundle in markup:
	 *
	 *   <div data-localization-bundle="url/to/my.properties">
	 *     [...]
	 *       <div data-localization="content=myContent;title=myTitle"/>
	 *
	 * Set the data-localization-bundle on an ancestor of the nodes that should be localized.
	 *
	 * @param {Element} root
	 *        The root node to use for the localization
	 */
	function localizeMarkup(root) {
	  let elements = root.querySelectorAll("[data-localization]");
	  for (let element of elements) {
	    let properties = getPropertiesForNode(element);
	    if (!properties) {
	      continue;
	    }

	    let attributes = element.getAttribute("data-localization").split(";");
	    for (let attribute of attributes) {
	      let [name, value] = attribute.trim().split("=");
	      if (name === "content") {
	        element.textContent = properties[value];
	      } else {
	        element.setAttribute(name, properties[value]);
	      }
	    }

	    element.removeAttribute("data-localization");
	  }
	}

	const sharedL10N = new LocalizationHelper("devtools-shared/locale/shared.properties");
	const ELLIPSIS = sharedL10N.getStr("ellipsis");

	/**
	 * A helper for having the same interface as LocalizationHelper, but for more
	 * than one file. Useful for abstracting l10n string locations.
	 */
	function MultiLocalizationHelper(...stringBundleNames) {
	  let instances = stringBundleNames.map(bundle => {
	    return new LocalizationHelper(bundle);
	  });

	  // Get all function members of the LocalizationHelper class, making sure we're
	  // not executing any potential getters while doing so, and wrap all the
	  // methods we've found to work on all given string bundles.
	  Object.getOwnPropertyNames(LocalizationHelper.prototype)
	    .map(name => ({
	      name: name,
	      descriptor: Object.getOwnPropertyDescriptor(LocalizationHelper.prototype,
	                                                  name)
	    }))
	    .filter(({ descriptor }) => descriptor.value instanceof Function)
	    .forEach(method => {
	      this[method.name] = (...args) => {
	        for (let l10n of instances) {
	          try {
	            return method.descriptor.value.apply(l10n, args);
	          } catch (e) {
	            // Do nothing
	          }
	        }
	        return null;
	      };
	    });
	}

	exports.LocalizationHelper = LocalizationHelper;
	exports.localizeMarkup = localizeMarkup;
	exports.MultiLocalizationHelper = MultiLocalizationHelper;
	exports.ELLIPSIS = ELLIPSIS;


/***/ },
/* 57 */
/***/ function(module, exports) {

	/**
	 * The MIT License (MIT)
	 *
	 * Copyright (c) 2014 Gabriel Llamas
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */

	"use strict";

	var hex = function (c){
	  switch (c){
	    case "0": return 0;
	    case "1": return 1;
	    case "2": return 2;
	    case "3": return 3;
	    case "4": return 4;
	    case "5": return 5;
	    case "6": return 6;
	    case "7": return 7;
	    case "8": return 8;
	    case "9": return 9;
	    case "a": case "A": return 10;
	    case "b": case "B": return 11;
	    case "c": case "C": return 12;
	    case "d": case "D": return 13;
	    case "e": case "E": return 14;
	    case "f": case "F": return 15;
	  }
	};

	var parse = function (data, options, handlers, control){
	  var c;
	  var code;
	  var escape;
	  var skipSpace = true;
	  var isCommentLine;
	  var isSectionLine;
	  var newLine = true;
	  var multiLine;
	  var isKey = true;
	  var key = "";
	  var value = "";
	  var section;
	  var unicode;
	  var unicodeRemaining;
	  var escapingUnicode;
	  var keySpace;
	  var sep;
	  var ignoreLine;

	  var line = function (){
	    if (key || value || sep){
	      handlers.line (key, value);
	      key = "";
	      value = "";
	      sep = false;
	    }
	  };

	  var escapeString = function (key, c, code){
	    if (escapingUnicode && unicodeRemaining){
	      unicode = (unicode << 4) + hex (c);
	      if (--unicodeRemaining) return key;
	      escape = false;
	      escapingUnicode = false;
	      return key + String.fromCharCode (unicode);
	    }

	    //code 117: u
	    if (code === 117){
	      unicode = 0;
	      escapingUnicode = true;
	      unicodeRemaining = 4;
	      return key;
	    }

	    escape = false;

	    //code 116: t
	    //code 114: r
	    //code 110: n
	    //code 102: f
	    if (code === 116) return key + "\t";
	    else if (code === 114) return key + "\r";
	    else if (code === 110) return key + "\n";
	    else if (code === 102) return key + "\f";

	    return key + c;
	  };

	  var isComment;
	  var isSeparator;

	  if (options._strict){
	    isComment = function (c, code, options){
	      return options._comments[c];
	    };

	    isSeparator = function (c, code, options){
	      return options._separators[c];
	    };
	  }else{
	    isComment = function (c, code, options){
	      //code 35: #
	      //code 33: !
	      return code === 35 || code === 33 || options._comments[c];
	    };

	    isSeparator = function (c, code, options){
	      //code 61: =
	      //code 58: :
	      return code === 61 || code === 58 || options._separators[c];
	    };
	  }

	  for (var i=~~control.resume; i<data.length; i++){
	    if (control.abort) return;
	    if (control.pause){
	      //The next index is always the start of a new line, it's a like a fresh
	      //start, there's no need to save the current state
	      control.resume = i;
	      return;
	    }

	    c = data[i];
	    code = data.charCodeAt (i);

	    //code 13: \r
	    if (code === 13) continue;

	    if (isCommentLine){
	      //code 10: \n
	      if (code === 10){
	        isCommentLine = false;
	        newLine = true;
	        skipSpace = true;
	      }
	      continue;
	    }

	    //code 93: ]
	    if (isSectionLine && code === 93){
	      handlers.section (section);
	      //Ignore chars after the section in the same line
	      ignoreLine = true;
	      continue;
	    }

	    if (skipSpace){
	      //code 32: " " (space)
	      //code 9: \t
	      //code 12: \f
	      if (code === 32 || code === 9 || code === 12){
	        continue;
	      }
	      //code 10: \n
	      if (!multiLine && code === 10){
	        //Empty line or key w/ separator and w/o value
	        isKey = true;
	        keySpace = false;
	        newLine = true;
	        line ();
	        continue;
	      }
	      skipSpace = false;
	      multiLine = false;
	    }

	    if (newLine){
	      newLine = false;
	      if (isComment (c, code, options)){
	        isCommentLine = true;
	        continue;
	      }
	      //code 91: [
	      if (options.sections && code === 91){
	        section = "";
	        isSectionLine = true;
	        control.skipSection = false;
	        continue;
	      }
	    }

	    //code 10: \n
	    if (code !== 10){
	      if (control.skipSection || ignoreLine) continue;

	      if (!isSectionLine){
	        if (!escape && isKey && isSeparator (c, code, options)){
	          //sep is needed to detect empty key and empty value with a
	          //non-whitespace separator
	          sep = true;
	          isKey = false;
	          keySpace = false;
	          //Skip whitespace between separator and value
	          skipSpace = true;
	          continue;
	        }
	      }

	      //code 92: "\" (backslash)
	      if (code === 92){
	        if (escape){
	          if (escapingUnicode) continue;

	          if (keySpace){
	            //Line with whitespace separator
	            keySpace = false;
	            isKey = false;
	          }

	          if (isSectionLine) section += "\\";
	          else if (isKey) key += "\\";
	          else value += "\\";
	        }
	        escape = !escape;
	      }else{
	        if (keySpace){
	          //Line with whitespace separator
	          keySpace = false;
	          isKey = false;
	        }

	        if (isSectionLine){
	          if (escape) section = escapeString (section, c, code);
	          else section += c;
	        }else if (isKey){
	          if (escape){
	            key = escapeString (key, c, code);
	          }else{
	            //code 32: " " (space)
	            //code 9: \t
	            //code 12: \f
	            if (code === 32 || code === 9 || code === 12){
	              keySpace = true;
	              //Skip whitespace between key and separator
	              skipSpace = true;
	              continue;
	            }
	            key += c;
	          }
	        }else{
	          if (escape) value = escapeString (value, c, code);
	          else value += c;
	        }
	      }
	    }else{
	      if (escape){
	        if (!escapingUnicode){
	          escape = false;
	        }
	        skipSpace = true;
	        multiLine = true;
	      }else{
	        if (isSectionLine){
	          isSectionLine = false;
	          if (!ignoreLine){
	            //The section doesn't end with ], it's a key
	            control.error = new Error ("The section line \"" + section +
	                "\" must end with \"]\"");
	            return;
	          }
	          ignoreLine = false;
	        }
	        newLine = true;
	        skipSpace = true;
	        isKey = true;

	        line ();
	      }
	    }
	  }

	  control.parsed = true;

	  if (isSectionLine && !ignoreLine){
	    //The section doesn't end with ], it's a key
	    control.error = new Error ("The section line \"" + section + "\" must end" +
	        "with \"]\"");
	    return;
	  }
	  line ();
	};

	var INCLUDE_KEY = "include";
	var INDEX_FILE = "index.properties";

	var cast = function (value){
	  if (value === null || value === "null") return null;
	  if (value === "undefined") return undefined;
	  if (value === "true") return true;
	  if (value === "false") return false;
	  var v = Number (value);
	  return isNaN (v) ? value : v;
	};

	var expand = function  (o, str, options, cb){
	  if (!options.variables || !str) return cb (null, str);

	  var stack = [];
	  var c;
	  var cp;
	  var key = "";
	  var section = null;
	  var v;
	  var holder;
	  var t;
	  var n;

	  for (var i=0; i<str.length; i++){
	    c = str[i];

	    if (cp === "$" && c === "{"){
	      key = key.substring (0, key.length - 1);
	      stack.push ({
	        key: key,
	        section: section
	      });
	      key = "";
	      section = null;
	      continue;
	    }else if (stack.length){
	      if (options.sections && c === "|"){
	        section = key;
	        key = "";
	        continue;
	      }else if (c === "}"){
	        holder = section !== null ? searchValue (o, section, true) : o;
	        if (!holder){
	          return cb (new Error ("The section \"" + section + "\" does not " +
	              "exist"));
	        }

	        v = options.namespaces ? searchValue (holder, key) : holder[key];
	        if (v === undefined){
	          //Read the external vars
	          v = options.namespaces
	              ? searchValue (options._vars, key)
	              : options._vars[key]

	          if (v === undefined){
	            return cb (new Error ("The property \"" + key + "\" does not " +
	                "exist"));
	          }
	        }

	        t = stack.pop ();
	        section = t.section;
	        key = t.key + (v === null ? "" : v);
	        continue;
	      }
	    }

	    cp = c;
	    key += c;
	  }

	  if (stack.length !== 0){
	    return cb (new Error ("Malformed variable: " + str));
	  }

	  cb (null, key);
	};

	var searchValue = function (o, chain, section){
	  var n = chain.split (".");
	  var str;

	  for (var i=0; i<n.length-1; i++){
	    str = n[i];
	    if (o[str] === undefined) return;
	    o = o[str];
	  }

	  var v = o[n[n.length - 1]];
	  if (section){
	    if (typeof v !== "object") return;
	    return v;
	  }else{
	    if (typeof v === "object") return;
	    return v;
	  }
	};

	var namespaceKey = function (o, key, value){
	  var n = key.split (".");
	  var str;

	  for (var i=0; i<n.length-1; i++){
	    str = n[i];
	    if (o[str] === undefined){
	      o[str] = {};
	    }else if (typeof o[str] !== "object"){
	      throw new Error ("Invalid namespace chain in the property name '" +
	          key + "' ('" + str + "' has already a value)");
	    }
	    o = o[str];
	  }

	  o[n[n.length - 1]] = value;
	};

	var namespaceSection = function (o, section){
	  var n = section.split (".");
	  var str;

	  for (var i=0; i<n.length; i++){
	    str = n[i];
	    if (o[str] === undefined){
	      o[str] = {};
	    }else if (typeof o[str] !== "object"){
	      throw new Error ("Invalid namespace chain in the section name '" +
	          section + "' ('" + str + "' has already a value)");
	    }
	    o = o[str];
	  }

	  return o;
	};

	var merge = function (o1, o2){
	  for (var p in o2){
	    try{
	      if (o1[p].constructor === Object){
	        o1[p] = merge (o1[p], o2[p]);
	      }else{
	        o1[p] = o2[p];
	      }
	    }catch (e){
	      o1[p] = o2[p];
	    }
	  }
	  return o1;
	}

	var build = function (data, options, dirname, cb){
	  var o = {};

	  if (options.namespaces){
	    var n = {};
	  }

	  var control = {
	    abort: false,
	    skipSection: false
	  };

	  if (options.include){
	    var remainingIncluded = 0;

	    var include = function (value){
	      if (currentSection !== null){
	        return abort (new Error ("Cannot include files from inside a " +
	            "section: " + currentSection));
	      }

	      var p = path.resolve (dirname, value);
	      if (options._included[p]) return;

	      options._included[p] = true;
	      remainingIncluded++;
	      control.pause = true;

	      read (p, options, function (error, included){
	        if (error) return abort (error);

	        remainingIncluded--;
	        merge (options.namespaces ? n : o, included);
	        control.pause = false;

	        if (!control.parsed){
	          parse (data, options, handlers, control);
	          if (control.error) return abort (control.error);
	        }

	        if (!remainingIncluded) cb (null, options.namespaces ? n : o);
	      });
	    };
	  }

	  if (!data){
	    if (cb) return cb (null, o);
	    return o;
	  }

	  var currentSection = null;
	  var currentSectionStr = null;

	  var abort = function (error){
	    control.abort = true;
	    if (cb) return cb (error);
	    throw error;
	  };

	  var handlers = {};
	  var reviver = {
	    assert: function (){
	      return this.isProperty ? reviverLine.value : true;
	    }
	  };
	  var reviverLine = {};

	  //Line handler
	  //For speed reasons, if "namespaces" is enabled, the old object is still
	  //populated, e.g.: ${a.b} reads the "a.b" property from { "a.b": 1 }, instead
	  //of having a unique object { a: { b: 1 } } which is slower to search for
	  //the "a.b" value
	  //If "a.b" is not found, then the external vars are read. If "namespaces" is
	  //enabled, the var "a.b" is split and it searches the a.b value. If it is not
	  //enabled, then the var "a.b" searches the "a.b" value

	  var line;
	  var error;

	  if (options.reviver){
	    if (options.sections){
	      line = function (key, value){
	        if (options.include && key === INCLUDE_KEY) return include (value);

	        reviverLine.value = value;
	        reviver.isProperty = true;
	        reviver.isSection = false;

	        value = options.reviver.call (reviver, key, value, currentSectionStr);
	        if (value !== undefined){
	          if (options.namespaces){
	            try{
	              namespaceKey (currentSection === null ? n : currentSection,
	                  key, value);
	            }catch (error){
	              abort (error);
	            }
	          }else{
	            if (currentSection === null) o[key] = value;
	            else currentSection[key] = value;
	          }
	        }
	      };
	    }else{
	      line = function (key, value){
	        if (options.include && key === INCLUDE_KEY) return include (value);

	        reviverLine.value = value;
	        reviver.isProperty = true;
	        reviver.isSection = false;

	        value = options.reviver.call (reviver, key, value);
	        if (value !== undefined){
	          if (options.namespaces){
	            try{
	              namespaceKey (n, key, value);
	            }catch (error){
	              abort (error);
	            }
	          }else{
	            o[key] = value;
	          }
	        }
	      };
	    }
	  }else{
	    if (options.sections){
	      line = function (key, value){
	        if (options.include && key === INCLUDE_KEY) return include (value);

	        if (options.namespaces){
	          try{
	            namespaceKey (currentSection === null ? n : currentSection, key,
	                value);
	          }catch (error){
	            abort (error);
	          }
	        }else{
	          if (currentSection === null) o[key] = value;
	          else currentSection[key] = value;
	        }
	      };
	    }else{
	      line = function (key, value){
	        if (options.include && key === INCLUDE_KEY) return include (value);

	        if (options.namespaces){
	          try{
	            namespaceKey (n, key, value);
	          }catch (error){
	            abort (error);
	          }
	        }else{
	          o[key] = value;
	        }
	      };
	    }
	  }

	  //Section handler
	  var section;
	  if (options.sections){
	    if (options.reviver){
	      section = function (section){
	        currentSectionStr = section;
	        reviverLine.section = section;
	        reviver.isProperty = false;
	        reviver.isSection = true;

	        var add = options.reviver.call (reviver, null, null, section);
	        if (add){
	          if (options.namespaces){
	            try{
	              currentSection = namespaceSection (n, section);
	            }catch (error){
	              abort (error);
	            }
	          }else{
	            currentSection = o[section] = {};
	          }
	        }else{
	          control.skipSection = true;
	        }
	      };
	    }else{
	      section = function (section){
	        currentSectionStr = section;
	        if (options.namespaces){
	          try{
	            currentSection = namespaceSection (n, section);
	          }catch (error){
	            abort (error);
	          }
	        }else{
	          currentSection = o[section] = {};
	        }
	      };
	    }
	  }

	  //Variables
	  if (options.variables){
	    handlers.line = function (key, value){
	      expand (options.namespaces ? n : o, key, options, function (error, key){
	        if (error) return abort (error);

	        expand (options.namespaces ? n : o, value, options,
	            function (error, value){
	          if (error) return abort (error);

	          line (key, cast (value || null));
	        });
	      });
	    };

	    if (options.sections){
	      handlers.section = function (s){
	        expand (options.namespaces ? n : o, s, options, function (error, s){
	          if (error) return abort (error);

	          section (s);
	        });
	      };
	    }
	  }else{
	    handlers.line = function (key, value){
	      line (key, cast (value || null));
	    };

	    if (options.sections){
	      handlers.section = section;
	    }
	  }

	  parse (data, options, handlers, control);
	  if (control.error) return abort (control.error);

	  if (control.abort || control.pause) return;

	  if (cb) return cb (null, options.namespaces ? n : o);
	  return options.namespaces ? n : o;
	};

	var read = function (f, options, cb){
	  fs.stat (f, function (error, stats){
	    if (error) return cb (error);

	    var dirname;

	    if (stats.isDirectory ()){
	      dirname = f;
	      f = path.join (f, INDEX_FILE);
	    }else{
	      dirname = path.dirname (f);
	    }

	    fs.readFile (f, { encoding: "utf8" }, function (error, data){
	      if (error) return cb (error);
	      build (data, options, dirname, cb);
	    });
	  });
	};

	module.exports = function (data, options, cb){
	  if (typeof options === "function"){
	    cb = options;
	    options = {};
	  }

	  options = options || {};
	  var code;

	  if (options.include){
	    if (!cb) throw new Error ("A callback must be passed if the 'include' " +
	        "option is enabled");
	    options._included = {};
	  }

	  options = options || {};
	  options._strict = options.strict && (options.comments || options.separators);
	  options._vars = options.vars || {};

	  var comments = options.comments || [];
	  if (!Array.isArray (comments)) comments = [comments];
	  var c = {};
	  comments.forEach (function (comment){
	    code = comment.charCodeAt (0);
	    if (comment.length > 1 || code < 33 || code > 126){
	      throw new Error ("The comment token must be a single printable ASCII " +
	          "character");
	    }
	    c[comment] = true;
	  });
	  options._comments = c;

	  var separators = options.separators || [];
	  if (!Array.isArray (separators)) separators = [separators];
	  var s = {};
	  separators.forEach (function (separator){
	    code = separator.charCodeAt (0);
	    if (separator.length > 1 || code < 33 || code > 126){
	      throw new Error ("The separator token must be a single printable ASCII " +
	          "character");
	    }
	    s[separator] = true;
	  });
	  options._separators = s;

	  if (options.path){
	    if (!cb) throw new Error ("A callback must be passed if the 'path' " +
	        "option is enabled");
	    if (options.include){
	      read (data, options, cb);
	    }else{
	      fs.readFile (data, { encoding: "utf8" }, function (error, data){
	        if (error) return cb (error);
	        build (data, options, ".", cb);
	      });
	    }
	  }else{
	    return build (data, options, ".", cb);
	  }
	};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2007-2016, Alexandru Marasteanu <hello [at) alexei (dot] ro>
	 * All rights reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 * * Neither the name of this software nor the names of its contributors may be
	 *   used to endorse or promote products derived from this software without
	 *   specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	 * DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
	 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 */

	/* globals window, exports, define */

	(function(window) {
	    'use strict'

	    var re = {
	        not_string: /[^s]/,
	        not_bool: /[^t]/,
	        not_type: /[^T]/,
	        not_primitive: /[^v]/,
	        number: /[diefg]/,
	        numeric_arg: /bcdiefguxX/,
	        json: /[j]/,
	        not_json: /[^j]/,
	        text: /^[^\x25]+/,
	        modulo: /^\x25{2}/,
	        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosStTuvxX])/,
	        key: /^([a-z_][a-z_\d]*)/i,
	        key_access: /^\.([a-z_][a-z_\d]*)/i,
	        index_access: /^\[(\d+)\]/,
	        sign: /^[\+\-]/
	    }

	    function sprintf() {
	        var key = arguments[0], cache = sprintf.cache
	        if (!(cache[key] && cache.hasOwnProperty(key))) {
	            cache[key] = sprintf.parse(key)
	        }
	        return sprintf.format.call(null, cache[key], arguments)
	    }

	    sprintf.format = function(parse_tree, argv) {
	        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ''
	        for (i = 0; i < tree_length; i++) {
	            node_type = get_type(parse_tree[i])
	            if (node_type === 'string') {
	                output[output.length] = parse_tree[i]
	            }
	            else if (node_type === 'array') {
	                match = parse_tree[i] // convenience purposes only
	                if (match[2]) { // keyword argument
	                    arg = argv[cursor]
	                    for (k = 0; k < match[2].length; k++) {
	                        if (!arg.hasOwnProperty(match[2][k])) {
	                            throw new Error(sprintf('[sprintf] property "%s" does not exist', match[2][k]))
	                        }
	                        arg = arg[match[2][k]]
	                    }
	                }
	                else if (match[1]) { // positional argument (explicit)
	                    arg = argv[match[1]]
	                }
	                else { // positional argument (implicit)
	                    arg = argv[cursor++]
	                }

	                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && get_type(arg) == 'function') {
	                    arg = arg()
	                }

	                if (re.numeric_arg.test(match[8]) && (get_type(arg) != 'number' && isNaN(arg))) {
	                    throw new TypeError(sprintf("[sprintf] expecting number but found %s", get_type(arg)))
	                }

	                if (re.number.test(match[8])) {
	                    is_positive = arg >= 0
	                }

	                switch (match[8]) {
	                    case 'b':
	                        arg = parseInt(arg, 10).toString(2)
	                    break
	                    case 'c':
	                        arg = String.fromCharCode(parseInt(arg, 10))
	                    break
	                    case 'd':
	                    case 'i':
	                        arg = parseInt(arg, 10)
	                    break
	                    case 'j':
	                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)
	                    break
	                    case 'e':
	                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()
	                    break
	                    case 'f':
	                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)
	                    break
	                    case 'g':
	                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)
	                    break
	                    case 'o':
	                        arg = arg.toString(8)
	                    break
	                    case 's':
	                    case 'S':
	                        arg = String(arg)
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 't':
	                        arg = String(!!arg)
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 'T':
	                        arg = get_type(arg)
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 'u':
	                        arg = parseInt(arg, 10) >>> 0
	                    break
	                    case 'v':
	                        arg = arg.valueOf()
	                        arg = (match[7] ? arg.substring(0, match[7]) : arg)
	                    break
	                    case 'x':
	                        arg = parseInt(arg, 10).toString(16)
	                    break
	                    case 'X':
	                        arg = parseInt(arg, 10).toString(16).toUpperCase()
	                    break
	                }
	                if (re.json.test(match[8])) {
	                    output[output.length] = arg
	                }
	                else {
	                    if (re.number.test(match[8]) && (!is_positive || match[3])) {
	                        sign = is_positive ? '+' : '-'
	                        arg = arg.toString().replace(re.sign, '')
	                    }
	                    else {
	                        sign = ''
	                    }
	                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '
	                    pad_length = match[6] - (sign + arg).length
	                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : '') : ''
	                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)
	                }
	            }
	        }
	        return output.join('')
	    }

	    sprintf.cache = {}

	    sprintf.parse = function(fmt) {
	        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0
	        while (_fmt) {
	            if ((match = re.text.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = match[0]
	            }
	            else if ((match = re.modulo.exec(_fmt)) !== null) {
	                parse_tree[parse_tree.length] = '%'
	            }
	            else if ((match = re.placeholder.exec(_fmt)) !== null) {
	                if (match[2]) {
	                    arg_names |= 1
	                    var field_list = [], replacement_field = match[2], field_match = []
	                    if ((field_match = re.key.exec(replacement_field)) !== null) {
	                        field_list[field_list.length] = field_match[1]
	                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
	                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
	                                field_list[field_list.length] = field_match[1]
	                            }
	                            else {
	                                throw new SyntaxError("[sprintf] failed to parse named argument key")
	                            }
	                        }
	                    }
	                    else {
	                        throw new SyntaxError("[sprintf] failed to parse named argument key")
	                    }
	                    match[2] = field_list
	                }
	                else {
	                    arg_names |= 2
	                }
	                if (arg_names === 3) {
	                    throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported")
	                }
	                parse_tree[parse_tree.length] = match
	            }
	            else {
	                throw new SyntaxError("[sprintf] unexpected placeholder")
	            }
	            _fmt = _fmt.substring(match[0].length)
	        }
	        return parse_tree
	    }

	    var vsprintf = function(fmt, argv, _argv) {
	        _argv = (argv || []).slice(0)
	        _argv.splice(0, 0, fmt)
	        return sprintf.apply(null, _argv)
	    }

	    /**
	     * helpers
	     */
	    function get_type(variable) {
	        if (typeof variable === 'number') {
	            return 'number'
	        }
	        else if (typeof variable === 'string') {
	            return 'string'
	        }
	        else {
	            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()
	        }
	    }

	    var preformattedPadding = {
	        '0': ['', '0', '00', '000', '0000', '00000', '000000', '0000000'],
	        ' ': ['', ' ', '  ', '   ', '    ', '     ', '      ', '       '],
	        '_': ['', '_', '__', '___', '____', '_____', '______', '_______'],
	    }
	    function str_repeat(input, multiplier) {
	        if (multiplier >= 0 && multiplier <= 7 && preformattedPadding[input]) {
	            return preformattedPadding[input][multiplier]
	        }
	        return Array(multiplier + 1).join(input)
	    }

	    /**
	     * export to either browser or node.js
	     */
	    if (true) {
	        exports.sprintf = sprintf
	        exports.vsprintf = vsprintf
	    }
	    else {
	        window.sprintf = sprintf
	        window.vsprintf = vsprintf

	        if (typeof define === 'function' && define.amd) {
	            define(function() {
	                return {
	                    sprintf: sprintf,
	                    vsprintf: vsprintf
	                }
	            })
	        }
	    }
	})(typeof window === 'undefined' ? this : window);


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./csscoverage.properties": 60,
		"./debugger.properties": 61,
		"./gcli.properties": 62,
		"./gclicommands.properties": 63,
		"./shared.properties": 64,
		"./styleinspector.properties": 65
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 59;


/***/ },
/* 60 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the 'csscoverage' command and in\n# the user interface that this command creates.\n\n# LOCALIZATION NOTE (csscoverageDesc, csscoverageStartDesc2,\n# csscoverageStopDesc2, csscoverageOneShotDesc2, csscoverageToggleDesc2,\n# csscoverageReportDesc2): Short descriptions of the csscoverage commands\ncsscoverageDesc=Control CSS coverage analysis\ncsscoverageStartDesc2=Begin collecting CSS coverage data\ncsscoverageStopDesc2=Stop collecting CSS coverage data\ncsscoverageOneShotDesc2=Collect instantaneous CSS coverage data\ncsscoverageToggleDesc2=Toggle collecting CSS coverage data\ncsscoverageReportDesc2=Show CSS coverage report\ncsscoverageStartNoReloadDesc=Don’t start with a page reload\ncsscoverageStartNoReloadManual=It’s best if we start by reloading the current page because that starts the test at a known point, but there could be reasons why we don’t want to do that (e.g. the page contains state that will be lost across a reload)\n\n# LOCALIZATION NOTE (csscoverageRunningReply, csscoverageDoneReply): Text that\n# describes the current state of the css coverage system\ncsscoverageRunningReply=Running CSS coverage analysis\ncsscoverageDoneReply=CSS Coverage analysis completed\n\n# LOCALIZATION NOTE (csscoverageRunningError, csscoverageNotRunningError,\n# csscoverageNotRunError): Error message that describe things that can go wrong\n# with the css coverage system\ncsscoverageRunningError=CSS coverage analysis already running\ncsscoverageNotRunningError=CSS coverage analysis not running\ncsscoverageNotRunError=CSS coverage analysis has not been run\ncsscoverageNoRemoteError=Target does not support CSS Coverage\ncsscoverageOneShotReportError=CSS coverage report is not available for ‘oneshot’ data. Please use start/stop.\n"

/***/ },
/* 61 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Debugger\n# which is available from the Web Developer sub-menu -> 'Debugger'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (remoteIncomingPromptTitle): The title displayed on the\n# dialog that prompts the user to allow the incoming connection.\nremoteIncomingPromptTitle=Incoming Connection\n\n# LOCALIZATION NOTE (remoteIncomingPromptHeader): Header displayed on the\n# dialog that prompts the user to allow the incoming connection.\nremoteIncomingPromptHeader=An incoming request to permit remote debugging connection was detected. A remote client can take complete control over your browser!\n# LOCALIZATION NOTE (remoteIncomingPromptClientEndpoint): Part of the prompt\n# dialog for the user to choose whether an incoming connection should be\n# allowed.\n# %1$S: The host and port of the client such as \"127.0.0.1:6000\"\nremoteIncomingPromptClientEndpoint=Client Endpoint: %1$S\n# LOCALIZATION NOTE (remoteIncomingPromptServerEndpoint): Part of the prompt\n# dialog for the user to choose whether an incoming connection should be\n# allowed.\n# %1$S: The host and port of the server such as \"127.0.0.1:6000\"\nremoteIncomingPromptServerEndpoint=Server Endpoint: %1$S\n# LOCALIZATION NOTE (remoteIncomingPromptFooter): Footer displayed on the\n# dialog that prompts the user to allow the incoming connection.\nremoteIncomingPromptFooter=Allow connection?\n\n# LOCALIZATION NOTE (remoteIncomingPromptDisable): The label displayed on the\n# third button in the incoming connection dialog that lets the user disable the\n# remote debugger server.\nremoteIncomingPromptDisable=Disable\n\n# LOCALIZATION NOTE (clientSendOOBTitle): The title displayed on the dialog that\n# instructs the user to transfer an authentication token to the server.\nclientSendOOBTitle=Client Identification\n# LOCALIZATION NOTE (clientSendOOBHeader): Header displayed on the dialog that\n# instructs the user to transfer an authentication token to the server.\nclientSendOOBHeader=The endpoint you are connecting to needs more information to authenticate this connection.  Please provide the token below in the prompt that appears on the other end.\n# LOCALIZATION NOTE (clientSendOOBHash): Part of the dialog that instructs the\n# user to transfer an authentication token to the server.\n# %1$S: The client's cert fingerprint\nclientSendOOBHash=My Cert: %1$S\n# LOCALIZATION NOTE (clientSendOOBToken): Part of the dialog that instructs the\n# user to transfer an authentication token to the server.\n# %1$S: The authentication token that the user will transfer.\nclientSendOOBToken=Token: %1$S\n\n# LOCALIZATION NOTE (serverReceiveOOBTitle): The title displayed on the dialog\n# that instructs the user to provide an authentication token from the client.\nserverReceiveOOBTitle=Provide Client Token\n# LOCALIZATION NOTE (serverReceiveOOBBody): Main text displayed on the dialog\n# that instructs the user to provide an authentication token from the client.\nserverReceiveOOBBody=The client should be displaying a token value.  Enter that token value here to complete authentication with this client.\n"

/***/ },
/* 62 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Web Console\n# command line which is available from the Web Developer sub-menu\n# -> 'Web Console'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# For each command there are in general two strings. As an example consider\n# the 'pref' command.\n# commandDesc (e.g. prefDesc for the command 'pref'): this string contains a\n# very short description of the command. It's designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\n# commandManual (e.g. prefManual for the command 'pref'): this string will\n# contain a fuller description of the command. It's diplayed when the user\n# asks for help about a specific command (e.g. 'help pref').\n\n# LOCALIZATION NOTE: This message is used to describe any command or command\n# parameter when no description has been provided.\ncanonDescNone=(No description)\n\n# LOCALIZATION NOTE: The default name for a group of parameters.\ncanonDefaultGroupName=Options\n\n# LOCALIZATION NOTE (canonProxyDesc, canonProxyManual): These commands are\n# used to execute commands on a remote system (using a proxy). Parameters: %S\n# is the name of the remote system.\ncanonProxyDesc=Execute a command on %S\ncanonProxyManual=A set of commands that are executed on a remote system. The remote system is reached via %S\n\n# LOCALIZATION NOTE: This error message is displayed when we try to add a new\n# command (using a proxy) where one already exists with the same name.\ncanonProxyExists=There is already a command called ‘%S’\n\n# LOCALIZATION NOTE: This message describes the '{' command, which allows\n# entry of JavaScript like traditional developer tool command lines.\ncliEvalJavascript=Enter JavaScript directly\n\n# LOCALIZATION NOTE: This message is displayed when the command line has more\n# arguments than the current command can understand.\ncliUnusedArg=Too many arguments\n\n# LOCALIZATION NOTE: The title of the dialog which displays the options that\n# are available to the current command.\ncliOptions=Available Options\n\n# LOCALIZATION NOTE: The error message when the user types a command that\n# isn't registered\ncliUnknownCommand2=Invalid Command: ‘%1$S’.\n\n# LOCALIZATION NOTE: A parameter should have a value, but doesn't\ncliIncompleteParam=Value required for ‘%1$S’.\n\n# LOCALIZATION NOTE: Error message given when a file argument points to a file\n# that does not exist, but should (e.g. for use with File->Open) %1$S is a\n# filename\nfileErrNotExists=‘%1$S’ doesn’t exist\n\n# LOCALIZATION NOTE: Error message given when a file argument points to a file\n# that exists, but should not (e.g. for use with File->Save As) %1$S is a\n# filename\nfileErrExists=‘%1$S’ already exists\n\n# LOCALIZATION NOTE: Error message given when a file argument points to a\n# non-file, when a file is needed. %1$S is a filename\nfileErrIsNotFile=‘%1$S’ is not a file\n\n# LOCALIZATION NOTE: Error message given when a file argument points to a\n# non-directory, when a directory is needed (e.g. for use with 'cd') %1$S is a\n# filename\nfileErrIsNotDirectory=‘%1$S’ is not a directory\n\n# LOCALIZATION NOTE: Error message given when a file argument does not match\n# the specified regular expression %1$S is a filename %2$S is a regular\n# expression\nfileErrDoesntMatch=‘%1$S’ does not match ‘%2$S’\n\n# LOCALIZATION NOTE: When the menu has displayed all the matches that it\n# should (i.e. about 10 items) then we display this to alert the user that\n# more matches are available.\nfieldMenuMore=More matches, keep typing\n\n# LOCALIZATION NOTE: The command line provides completion for JavaScript\n# commands, however there are times when the scope of what we're completing\n# against can't be used. This error message is displayed when this happens.\njstypeParseScope=Scope lost\n\n# LOCALIZATION NOTE (jstypeParseMissing, jstypeBeginSyntax,\n# jstypeBeginUnterm): These error messages are displayed when the command line\n# is doing JavaScript completion and encounters errors.\njstypeParseMissing=Can’t find property ‘%S’\njstypeBeginSyntax=Syntax error\njstypeBeginUnterm=Unterminated string literal\n\n# LOCALIZATION NOTE: This message is displayed if the system for providing\n# JavaScript completions encounters and error it displays this.\njstypeParseError=Error\n\n# LOCALIZATION NOTE (typesNumberNan, typesNumberNotInt2, typesDateNan): These\n# error messages are displayed when the command line is passed a variable\n# which has the wrong format and can't be converted. Parameters: %S is the\n# passed variable.\ntypesNumberNan=Can’t convert “%S” to a number.\ntypesNumberNotInt2=Can’t convert “%S” to an integer.\ntypesDateNan=Can’t convert “%S” to a date.\n\n# LOCALIZATION NOTE (typesNumberMax, typesNumberMin, typesDateMax,\n# typesDateMin): These error messages are displayed when the command line is\n# passed a variable which has a value out of range (number or date).\n# Parameters: %1$S is the passed variable, %2$S is the limit value.\ntypesNumberMax=%1$S is greater than maximum allowed: %2$S.\ntypesNumberMin=%1$S is smaller than minimum allowed: %2$S.\ntypesDateMax=%1$S is later than maximum allowed: %2$S.\ntypesDateMin=%1$S is earlier than minimum allowed: %2$S.\n\n# LOCALIZATION NOTE: This error message is displayed when the command line is\n# passed an option with a limited number of correct values, but the passed\n# value is not one of them.\ntypesSelectionNomatch=Can’t use ‘%S’.\n\n# LOCALIZATION NOTE: This error message is displayed when the command line is\n# expecting a CSS query string, however the passed string is not valid.\nnodeParseSyntax=Syntax error in CSS query\n\n# LOCALIZATION NOTE (nodeParseMultiple, nodeParseNone): These error messages\n# are displayed when the command line is expecting a CSS string that matches a\n# single node, but more nodes (or none) match.\nnodeParseMultiple=Too many matches (%S)\nnodeParseNone=No matches\n\n# LOCALIZATION NOTE (helpDesc, helpManual, helpSearchDesc, helpSearchManual3):\n# These strings describe the \"help\" command, used to display a description of\n# a command (e.g. \"help pref\"), and its parameter 'search'.\nhelpDesc=Get help on the available commands\nhelpManual=Provide help either on a specific command (if a search string is provided and an exact match is found) or on the available commands (if a search string is not provided, or if no exact match is found).\nhelpSearchDesc=Search string\nhelpSearchManual3=search string to use in narrowing down the displayed commands. Regular expressions not supported.\n\n# LOCALIZATION NOTE: These strings are displayed in the help page for a\n# command in the console.\nhelpManSynopsis=Synopsis\n\n# LOCALIZATION NOTE: This message is displayed in the help page if the command\n# has no parameters.\nhelpManNone=None\n\n# LOCALIZATION NOTE: This message is displayed in response to the 'help'\n# command when used without a filter, just above the list of known commands.\nhelpListAll=Available Commands:\n\n# LOCALIZATION NOTE (helpListPrefix, helpListNone): These messages are\n# displayed in response to the 'help <search>' command (i.e. with a search\n# string), just above the list of matching commands. Parameters: %S is the\n# search string.\nhelpListPrefix=Commands starting with ‘%S’:\nhelpListNone=No commands starting with ‘%S’\n\n# LOCALIZATION NOTE (helpManRequired, helpManOptional, helpManDefault): When\n# the 'help x' command wants to show the manual for the 'x' command, it needs\n# to be able to describe the parameters as either required or optional, or if\n# they have a default value.\nhelpManRequired=required\nhelpManOptional=optional\nhelpManDefault=optional, default=%S\n\n# LOCALIZATION NOTE: This forms part of the output from the 'help' command.\n# 'GCLI' is a project name and should be left untranslated.\nhelpIntro=GCLI is an experiment to create a highly usable command line for web developers.\n\n# LOCALIZATION NOTE: Text shown as part of the output of the 'help' command\n# when the command in question has sub-commands, before a list of the matching\n# sub-commands.\nsubCommands=Sub-Commands\n\n# LOCALIZATION NOTE: This error message is displayed when the command line is\n# cannot find a match for the parse types.\ncommandParseError=Command line parsing error\n\n# LOCALIZATION NOTE (contextDesc, contextManual, contextPrefixDesc): These\n# strings are used to describe the 'context' command and its 'prefix'\n# parameter. See localization comment for 'connect' for an explanation about\n# 'prefix'.\ncontextDesc=Concentrate on a group of commands\ncontextManual=Setup a default prefix to future commands. For example ‘context git’ would allow you to type ‘commit’ rather than ‘git commit’.\ncontextPrefixDesc=The command prefix\n\n# LOCALIZATION NOTE: This message message displayed during the processing of\n# the 'context' command, when the found command is not a parent command.\ncontextNotParentError=Can’t use ‘%S’ as a prefix because it is not a parent command.\n\n# LOCALIZATION NOTE (contextReply, contextEmptyReply): These messages are\n# displayed during the processing of the 'context' command, to indicate\n# success or that there is no command prefix.\ncontextReply=Using %S as a command prefix\ncontextEmptyReply=Command prefix is unset\n\n# LOCALIZATION NOTE (connectDesc, connectManual, connectPrefixDesc,\n# connectMethodDesc, connectUrlDesc, connectDupReply): These strings describe\n# the 'connect' command and all its available parameters. A 'prefix' is an \n# alias for the remote server (think of it as a \"connection name\"), and it\n# allows to identify a specific server when connected to multiple remote\n# servers.\nconnectDesc=Proxy commands to server\nconnectManual=Connect to the server, creating local versions of the commands on the server. Remote commands initially have a prefix to distinguish them from local commands (but see the context command to get past this)\nconnectPrefixDesc=Parent prefix for imported commands\nconnectMethodDesc=The method of connecting\nconnectUrlDesc=The URL to connect to\nconnectDupReply=Connection called %S already exists.\n\n# LOCALIZATION NOTE: The output of the 'connect' command, telling the user\n# what it has done. Parameters: %S is the prefix command. See localization\n# comment for 'connect' for an explanation about 'prefix'.\nconnectReply=Added %S commands.\n\n# LOCALIZATION NOTE (disconnectDesc2, disconnectManual2,\n# disconnectPrefixDesc): These strings describe the 'disconnect' command and\n# all its available parameters. See localization comment for 'connect' for an\n# explanation about 'prefix'.\ndisconnectDesc2=Disconnect from server\ndisconnectManual2=Disconnect from a server currently connected for remote commands execution\ndisconnectPrefixDesc=Parent prefix for imported commands\n\n# LOCALIZATION NOTE: This is the output of the 'disconnect' command,\n# explaining the user what has been done. Parameters: %S is the number of\n# commands removed.\ndisconnectReply=Removed %S commands.\n\n# LOCALIZATION NOTE (globalDesc, globalWindowDesc, globalOutput): These\n# strings describe the 'global' command and its parameters\nglobalDesc=Change the JS global\nglobalWindowDesc=The new window/global\nglobalOutput=JS global is now %S\n\n# LOCALIZATION NOTE: These strings describe the 'clear' command\nclearDesc=Clear the output area\n\n# LOCALIZATION NOTE (langDesc, langOutput): These strings describe the 'lang'\n# command and its parameters\nlangDesc=Enter commands in different languages\nlangOutput=You are now using %S\n\n# LOCALIZATION NOTE (prefDesc, prefManual, prefListDesc, prefListManual,\n# prefListSearchDesc, prefListSearchManual, prefShowDesc, prefShowManual,\n# prefShowSettingDesc, prefShowSettingManual): These strings describe the\n# 'pref' command and all its available sub-commands and parameters.\nprefDesc=Commands to control settings\nprefManual=Commands to display and alter preferences both for GCLI and the surrounding environment\nprefListDesc=Display available settings\nprefListManual=Display a list of preferences, optionally filtered when using the ‘search’ parameter\nprefListSearchDesc=Filter the list of settings displayed\nprefListSearchManual=Search for the given string in the list of available preferences\nprefShowDesc=Display setting value\nprefShowManual=Display the value of a given preference\nprefShowSettingDesc=Setting to display\nprefShowSettingManual=The name of the setting to display\n\n# LOCALIZATION NOTE: This message is used to show the preference name and the\n# associated preference value. Parameters: %1$S is the preference name, %2$S\n# is the preference value.\nprefShowSettingValue=%1$S: %2$S\n\n# LOCALIZATION NOTE (prefSetDesc, prefSetManual, prefSetSettingDesc,\n# prefSetSettingManual, prefSetValueDesc, prefSetValueManual): These strings\n# describe the 'pref set' command and all its parameters.\nprefSetDesc=Alter a setting\nprefSetManual=Alter preferences defined by the environment\nprefSetSettingDesc=Setting to alter\nprefSetSettingManual=The name of the setting to alter.\nprefSetValueDesc=New value for setting\nprefSetValueManual=The new value for the specified setting\n\n# LOCALIZATION NOTE (prefResetDesc, prefResetManual, prefResetSettingDesc,\n# prefResetSettingManual): These strings describe the 'pref reset' command and\n# all its parameters.\nprefResetDesc=Reset a setting\nprefResetManual=Reset the value of a setting to the system defaults\nprefResetSettingDesc=Setting to reset\nprefResetSettingManual=The name of the setting to reset to the system default value\n\n# LOCALIZATION NOTE: This string is displayed in the output from the 'pref\n# list' command as a label to an input element that allows the user to filter\n# the results.\nprefOutputFilter=Filter\n\n# LOCALIZATION NOTE (prefOutputName, prefOutputValue): These strings are\n# displayed in the output from the 'pref list' command as table headings.\nprefOutputName=Name\nprefOutputValue=Value\n\n# LOCALIZATION NOTE (introDesc, introManual): These strings describe the\n# 'intro' command. The localization of 'Got it!' should be the same used in\n# introTextGo.\nintroDesc=Show the opening message\nintroManual=Redisplay the message that is shown to new users until they click the ‘Got it!’ button\n\n# LOCALIZATION NOTE (introTextOpening3, introTextCommands, introTextKeys2,\n# introTextF1Escape, introTextGo): These strings are displayed when the user\n# first opens the developer toolbar to explain the command line, and is shown\n# each time it is opened until the user clicks the 'Got it!' button.\nintroTextOpening3=GCLI is an experiment to create a highly usable command line for web developers.\nintroTextCommands=For a list of commands type\nintroTextKeys2=, or to show/hide command hints press\nintroTextF1Escape=F1/Escape\nintroTextGo=Got it!\n\n# LOCALIZATION NOTE: This is a short description of the 'hideIntro' setting.\nhideIntroDesc=Show the initial welcome message\n\n# LOCALIZATION NOTE: This is a description of the 'eagerHelper' setting. It's\n# displayed when the user asks for help on the settings. eagerHelper allows\n# users to select between showing no tooltips, permanent tooltips, and only\n# important tooltips.\neagerHelperDesc=How eager are the tooltips\n"

/***/ },
/* 63 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside Web Console commands.\n# The Web Console command line is available from the Web Developer sub-menu\n# -> 'Web Console'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (helpDesc) A very short string used to describe the\n# function of the help command.\nhelpDesc=Get help on the available commands\n\n# LOCALIZATION NOTE (helpAvailable) Used in the output of the help command to\n# explain the contents of the command help table.\nhelpAvailable=Available Commands\n\n# LOCALIZATION NOTE (notAvailableInE10S) Used in the output of any command that\n# is not compatible with multiprocess mode (E10S).\nnotAvailableInE10S=The command ‘%1$S’ is not available in multiprocess mode (E10S)\n\n# LOCALIZATION NOTE (consoleDesc) A very short string used to describe the\n# function of the console command.\nconsoleDesc=Commands to control the console\n\n# LOCALIZATION NOTE (consoleManual) A longer description describing the\n# set of commands that control the console.\nconsoleManual=Filter, clear and close the web console\n\n# LOCALIZATION NOTE (consoleclearDesc) A very short string used to describe the\n# function of the 'console clear' command.\nconsoleclearDesc=Clear the console\n\n# LOCALIZATION NOTE (screenshotDesc) A very short description of the\n# 'screenshot' command. See screenshotManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nscreenshotDesc=Save an image of the page\n\n# LOCALIZATION NOTE (screenshotManual) A fuller description of the 'screenshot'\n# command, displayed when the user asks for help on what it does.\nscreenshotManual=Save a PNG image of the entire visible window (optionally after a delay)\n\n# LOCALIZATION NOTE (screenshotFilenameDesc) A very short string to describe\n# the 'filename' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotFilenameDesc=Destination filename\n\n# LOCALIZATION NOTE (screenshotFilenameManual) A fuller description of the\n# 'filename' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotFilenameManual=The name of the file (should have a ‘.png’ extension) to which we write the screenshot.\n\n# LOCALIZATION NOTE (screenshotClipboardDesc) A very short string to describe\n# the 'clipboard' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotClipboardDesc=Copy screenshot to clipboard? (true/false)\n\n# LOCALIZATION NOTE (screenshotClipboardManual) A fuller description of the\n# 'clipboard' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotClipboardManual=True if you want to copy the screenshot instead of saving it to a file.\n\n# LOCALIZATION NOTE (screenshotGroupOptions) A label for the optional options of\n# the screenshot command.\nscreenshotGroupOptions=Options\n\n# LOCALIZATION NOTE (screenshotDelayDesc) A very short string to describe\n# the 'delay' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotDelayDesc=Delay (seconds)\n\n# LOCALIZATION NOTE (screenshotDelayManual) A fuller description of the\n# 'delay' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotDelayManual=The time to wait (in seconds) before the screenshot is taken\n\n# LOCALIZATION NOTE (screenshotDPRDesc) A very short string to describe\n# the 'dpr' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotDPRDesc=Device pixel ratio\n\n# LOCALIZATION NOTE (screenshotDPRManual) A fuller description of the\n# 'dpr' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotDPRManual=The device pixel ratio to use when taking the screenshot\n\n# LOCALIZATION NOTE (screenshotFullscreenDesc) A very short string to describe\n# the 'fullscreen' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotFullPageDesc=Entire webpage? (true/false)\n\n# LOCALIZATION NOTE (screenshotFullscreenManual) A fuller description of the\n# 'fullscreen' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotFullPageManual=True if the screenshot should also include parts of the webpage which are outside the current scrolled bounds.\n\n# LOCALIZATION NOTE (screenshotGeneratedFilename) The auto generated filename\n# when no file name is provided. The first argument (%1$S) is the date string\n# in yyyy-mm-dd format and the second argument (%2$S) is the time string\n# in HH.MM.SS format. Please don't add the extension here.\nscreenshotGeneratedFilename=Screen Shot %1$S at %2$S\n\n# LOCALIZATION NOTE (screenshotErrorSavingToFile) Text displayed to user upon\n# encountering error while saving the screenshot to the file specified.\nscreenshotErrorSavingToFile=Error saving to\n\n# LOCALIZATION NOTE (screenshotSavedToFile) Text displayed to user when the\n# screenshot is successfully saved to the file specified.\nscreenshotSavedToFile=Saved to\n\n# LOCALIZATION NOTE (screenshotErrorCopying) Text displayed to user upon\n# encountering error while copying the screenshot to clipboard.\nscreenshotErrorCopying=Error occurred while copying to clipboard.\n\n# LOCALIZATION NOTE (screenshotCopied) Text displayed to user when the\n# screenshot is successfully copied to the clipboard.\nscreenshotCopied=Copied to clipboard.\n\n# LOCALIZATION NOTE (screenshotTooltipPage) Text displayed as tooltip for screenshot button in devtools ToolBox.\nscreenshotTooltipPage=Take a screenshot of the entire page\n\n# LOCALIZATION NOTE (screenshotImgurDesc) A very short string to describe\n# the 'imgur' parameter to the 'screenshot' command, which is displayed in\n# a dialog when the user is using this command.\nscreenshotImgurDesc=Upload to imgur.com\n\n# LOCALIZATION NOTE (screenshotImgurManual) A fuller description of the\n# 'imgur' parameter to the 'screenshot' command, displayed when the user\n# asks for help on what it does.\nscreenshotImgurManual=Use if you want to upload to imgur.com instead of saving to disk\n\n# LOCALIZATION NOTE (screenshotImgurError) Text displayed to user upon\n# encountering error while uploading the screenshot to imgur.com.\nscreenshotImgurError=Could not reach imgur API\n\n# LOCALIZATION NOTE (screenshotImgurUploading) Text displayed to user when the\n# screenshot is successfully sent to Imgur but the program is waiting on a response.\n# The argument (%1$S) is a new image URL at Imgur.\nscreenshotImgurUploaded=Uploaded to %1$S\n\n# LOCALIZATION NOTE (highlightDesc) A very short description of the\n# 'highlight' command. See highlightManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nhighlightDesc=Highlight nodes\n\n# LOCALIZATION NOTE (highlightManual) A fuller description of the 'highlight'\n# command, displayed when the user asks for help on what it does.\nhighlightManual=Highlight nodes that match a selector on the page\n\n# LOCALIZATION NOTE (highlightSelectorDesc) A very short string to describe\n# the 'selector' parameter to the 'highlight' command, which is displayed in\n# a dialog when the user is using this command.\nhighlightSelectorDesc=CSS selector\n\n# LOCALIZATION NOTE (highlightSelectorManual) A fuller description of the\n# 'selector' parameter to the 'highlight' command, displayed when the user\n# asks for help on what it does.\nhighlightSelectorManual=The CSS selector used to match nodes in the page\n\n# LOCALIZATION NOTE (highlightOptionsDesc) The title of a set of options to\n# the 'highlight' command, displayed as a heading to the list of option.\nhighlightOptionsDesc=Options\n\n# LOCALIZATION NOTE (highlightHideGuidesDesc) A very short string to describe\n# the 'hideguides' option parameter to the 'highlight' command, which is\n# displayed in a dialog when the user is using this command.\nhighlightHideGuidesDesc=Hide guides\n\n# LOCALIZATION NOTE (highlightHideGuidesManual) A fuller description of the\n# 'hideguides' option parameter to the 'highlight' command, displayed when the\n# user asks for help on what it does.\nhighlightHideGuidesManual=Hide the guides around the highlighted node\n\n# LOCALIZATION NOTE (highlightShowInfoBarDesc) A very short string to describe\n# the 'showinfobar' option parameter to the 'highlight' command, which is\n# displayed in a dialog when the user is using this command.\nhighlightShowInfoBarDesc=Show the node infobar\n\n# LOCALIZATION NOTE (highlightShowInfoBarManual) A fuller description of the\n# 'showinfobar' option parameter to the 'highlight' command, displayed when the\n# user asks for help on what it does.\nhighlightShowInfoBarManual=Show the infobar above the highlighted node (the infobar displays the tagname, attributes and dimension)\n\n# LOCALIZATION NOTE (highlightShowAllDesc) A very short string to describe\n# the 'showall' option parameter to the 'highlight' command, which is\n# displayed in a dialog when the user is using this command.\nhighlightShowAllDesc=Show all matches\n\n# LOCALIZATION NOTE (highlightShowAllManual) A fuller description of the\n# 'showall' option parameter to the 'highlight' command, displayed when the\n# user asks for help on what it does.\nhighlightShowAllManual=If too many nodes match the selector, only the first 100 will be shown to avoid slowing down the page too much. Use this option to show all matches instead\n\n# LOCALIZATION NOTE (highlightRegionDesc) A very short string to describe the\n# 'region' option parameter to the 'highlight' command, which is displayed in a\n# dialog when the user is using this command.\nhighlightRegionDesc=Box model region\n\n# LOCALIZATION NOTE (highlightRegionManual) A fuller description of the 'region'\n# option parameter to the 'highlight' command, displayed when the user asks for\n# help on what it does.\nhighlightRegionManual=Which box model region should be highlighted: ‘content’, ‘padding’, ‘border’ or ‘margin’\n\n# LOCALIZATION NOTE (highlightFillDesc) A very short string to describe the\n# 'fill' option parameter to the 'highlight' command, which is displayed in a\n# dialog when the user is using this command.\nhighlightFillDesc=Fill style\n\n# LOCALIZATION NOTE (highlightFillManual) A fuller description of the 'fill'\n# option parameter to the 'highlight' command, displayed when the user asks for\n# help on what it does.\nhighlightFillManual=Override the default region fill style with a custom color\n\n# LOCALIZATION NOTE (highlightKeepDesc) A very short string to describe the\n# 'keep' option parameter to the 'highlight' command, which is displayed in a\n# dialog when the user is using this command.\nhighlightKeepDesc=Keep existing highlighters\n\n# LOCALIZATION NOTE (highlightKeepManual) A fuller description of the 'keep'\n# option parameter to the 'highlight' command, displayed when the user asks for\n# help on what it does.\nhighlightKeepManual=By default, existing highlighters are hidden when running the command, unless this option is set\n\n# LOCALIZATION NOTE (highlightOutputConfirm) A confirmation message for the\n# 'highlight' command, displayed to the user once the command has been entered,\n# informing the user how many nodes have been highlighted successfully and how\n# to turn highlighting off\nhighlightOutputConfirm2=%1$S node highlighted;%1$S nodes highlighted\n\n# LOCALIZATION NOTE (highlightOutputMaxReached) A confirmation message for the\n# 'highlight' command, displayed to the user once the command has been entered,\n# informing the user how many nodes have been highlighted successfully and that\n# some nodes could not be highlighted due to the maximum number of nodes being\n# reached, and how to turn highlighting off\nhighlightOutputMaxReached=%1$S nodes matched, but only %2$S nodes highlighted. Use ‘--showall’ to show all\n\n# LOCALIZATION NOTE (unhighlightDesc) A very short description of the\n# 'unhighlight' command. See unhighlightManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nunhighlightDesc=Unhighlight all nodes\n\n# LOCALIZATION NOTE (unhighlightManual) A fuller description of the 'unhighlight'\n# command, displayed when the user asks for help on what it does.\nunhighlightManual=Unhighlight all nodes previously highlighted with the ‘highlight’ command\n\n# LOCALIZATION NOTE (restartBrowserDesc) A very short description of the\n# 'restart' command. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\n# The argument (%1$S) is the browser name.\nrestartBrowserDesc=Restart %1$S\n\n# LOCALIZATION NOTE (restartBrowserNocacheDesc) A very short string to\n# describe the 'nocache' parameter to the 'restart' command, which is\n# displayed in a dialog when the user is using this command.\nrestartBrowserNocacheDesc=Disables loading content from cache upon restart\n\n# LOCALIZATION NOTE (restartBrowserRequestCancelled) A string displayed to the\n# user when a scheduled restart has been aborted by the user.\nrestartBrowserRequestCancelled=Restart request cancelled by user.\n\n# LOCALIZATION NOTE (restartBrowserRestarting) A string displayed to the\n# user when a restart has been initiated without a delay.\n# The argument (%1$S) is the browser name.\nrestartBrowserRestarting=Restarting %1$S…\n\n# LOCALIZATION NOTE (restartBrowserGroupOptions) A label for the optional options of\n# the restart command.\nrestartBrowserGroupOptions=Options\n\n# LOCALIZATION NOTE (restartBrowserSafemodeDesc) A very short string to\n# describe the 'safemode' parameter to the 'restart' command, which is\n# displayed in a dialog when the user is using this command.\nrestartBrowserSafemodeDesc=Enables Safe Mode upon restart\n\n# LOCALIZATION NOTE (inspectDesc) A very short description of the 'inspect'\n# command. See inspectManual for a fuller description of what it does. This\n# string is designed to be shown in a menu alongside the command name, which\n# is why it should be as short as possible.\ninspectDesc=Inspect a node\n\n# LOCALIZATION NOTE (inspectManual) A fuller description of the 'inspect'\n# command, displayed when the user asks for help on what it does.\ninspectManual=Investigate the dimensions and properties of an element using a CSS selector to open the DOM highlighter\n\n# LOCALIZATION NOTE (inspectNodeDesc) A very short string to describe the\n# 'node' parameter to the 'inspect' command, which is displayed in a dialog\n# when the user is using this command.\ninspectNodeDesc=CSS selector\n\n# LOCALIZATION NOTE (inspectNodeManual) A fuller description of the 'node'\n# parameter to the 'inspect' command, displayed when the user asks for help\n# on what it does.\ninspectNodeManual=A CSS selector for use with document.querySelector which identifies a single element\n\n# LOCALIZATION NOTE (eyedropperDesc) A very short description of the 'eyedropper'\n# command. See eyedropperManual for a fuller description of what it does. This\n# string is designed to be shown in a menu alongside the command name, which\n# is why it should be as short as possible.\neyedropperDesc=Grab a color from the page\n\n# LOCALIZATION NOTE (eyedropperManual) A fuller description of the 'eyedropper'\n# command, displayed when the user asks for help on what it does.\neyedropperManual=Open a panel that magnifies an area of page to inspect pixels and copy color values\n\n# LOCALIZATION NOTE (debuggerClosed) Used in the output of several commands\n# to explain that the debugger must be opened first.\ndebuggerClosed=The debugger must be opened before using this command\n\n# LOCALIZATION NOTE (debuggerStopped) Used in the output of several commands\n# to explain that the debugger must be opened first before setting breakpoints.\ndebuggerStopped=The debugger must be opened before setting breakpoints\n\n# LOCALIZATION NOTE (breakDesc) A very short string used to describe the\n# function of the break command.\nbreakDesc=Manage breakpoints\n\n# LOCALIZATION NOTE (breakManual) A longer description describing the\n# set of commands that control breakpoints.\nbreakManual=Commands to list, add and remove breakpoints\n\n# LOCALIZATION NOTE (breaklistDesc) A very short string used to describe the\n# function of the 'break list' command.\nbreaklistDesc=Display known breakpoints\n\n# LOCALIZATION NOTE (breaklistNone) Used in the output of the 'break list'\n# command to explain that the list is empty.\nbreaklistNone=No breakpoints set\n\n# LOCALIZATION NOTE (breaklistOutRemove) A title used in the output from the\n# 'break list' command on a button which can be used to remove breakpoints\nbreaklistOutRemove=Remove\n\n# LOCALIZATION NOTE (breakaddAdded) Used in the output of the 'break add'\n# command to explain that a breakpoint was added.\nbreakaddAdded=Added breakpoint\n\n# LOCALIZATION NOTE (breakaddFailed) Used in the output of the 'break add'\n# command to explain that a breakpoint could not be added.\nbreakaddFailed=Could not set breakpoint: %S\n\n# LOCALIZATION NOTE (breakaddDesc) A very short string used to describe the\n# function of the 'break add' command.\nbreakaddDesc=Add a breakpoint\n\n# LOCALIZATION NOTE (breakaddManual) A longer description describing the\n# set of commands that are responsible for adding breakpoints.\nbreakaddManual=Breakpoint types supported: line\n\n# LOCALIZATION NOTE (breakaddlineDesc) A very short string used to describe the\n# function of the 'break add line' command.\nbreakaddlineDesc=Add a line breakpoint\n\n# LOCALIZATION NOTE (breakaddlineFileDesc) A very short string used to describe\n# the function of the file parameter in the 'break add line' command.\nbreakaddlineFileDesc=JS file URI\n\n# LOCALIZATION NOTE (breakaddlineLineDesc) A very short string used to describe\n# the function of the line parameter in the 'break add line' command.\nbreakaddlineLineDesc=Line number\n\n# LOCALIZATION NOTE (breakdelDesc) A very short string used to describe the\n# function of the 'break del' command.\nbreakdelDesc=Remove a breakpoint\n\n# LOCALIZATION NOTE (breakdelBreakidDesc) A very short string used to describe\n# the function of the index parameter in the 'break del' command.\nbreakdelBreakidDesc=Index of breakpoint\n\n# LOCALIZATION NOTE (breakdelRemoved) Used in the output of the 'break del'\n# command to explain that a breakpoint was removed.\nbreakdelRemoved=Breakpoint removed\n\n# LOCALIZATION NOTE (dbgDesc) A very short string used to describe the\n# function of the dbg command.\ndbgDesc=Manage debugger\n\n# LOCALIZATION NOTE (dbgManual) A longer description describing the\n# set of commands that control the debugger.\ndbgManual=Commands to interrupt or resume the main thread, step in, out and over lines of code\n\n# LOCALIZATION NOTE (dbgOpen) A very short string used to describe the function\n# of the dbg open command.\ndbgOpen=Open the debugger\n\n# LOCALIZATION NOTE (dbgClose) A very short string used to describe the function\n# of the dbg close command.\ndbgClose=Close the debugger\n\n# LOCALIZATION NOTE (dbgInterrupt) A very short string used to describe the\n# function of the dbg interrupt command.\ndbgInterrupt=Pauses the main thread\n\n# LOCALIZATION NOTE (dbgContinue) A very short string used to describe the\n# function of the dbg continue command.\ndbgContinue=Resumes the main thread, and continues execution following a breakpoint, until the next breakpoint or the termination of the script.\n\n# LOCALIZATION NOTE (dbgStepDesc) A very short string used to describe the\n# function of the dbg step command.\ndbgStepDesc=Manage stepping\n\n# LOCALIZATION NOTE (dbgStepManual) A longer description describing the\n# set of commands that control stepping.\ndbgStepManual=Commands to step in, out and over lines of code\n\n# LOCALIZATION NOTE (dbgStepOverDesc) A very short string used to describe the\n# function of the dbg step over command.\ndbgStepOverDesc=Executes the current statement and then stops at the next statement. If the current statement is a function call then the debugger executes the whole function, and it stops at the next statement after the function call\n\n# LOCALIZATION NOTE (dbgStepInDesc) A very short string used to describe the\n# function of the dbg step in command.\ndbgStepInDesc=Executes the current statement and then stops at the next statement. If the current statement is a function call, then the debugger steps into that function, otherwise it stops at the next statement\n\n# LOCALIZATION NOTE (dbgStepOutDesc) A very short string used to describe the\n# function of the dbg step out command.\ndbgStepOutDesc=Steps out of the current function and up one level if the function is nested. If in the main body, the script is executed to the end, or to the next breakpoint. The skipped statements are executed, but not stepped through\n\n# LOCALIZATION NOTE (dbgListSourcesDesc) A very short string used to describe the\n# function of the dbg list command.\ndbgListSourcesDesc=List the source URLs loaded in the debugger\n\n# LOCALIZATION NOTE (dbgBlackBoxDesc) A very short string used to describe the\n# function of the 'dbg blackbox' command.\ndbgBlackBoxDesc=Black box sources in the debugger\n\n# LOCALIZATION NOTE (dbgBlackBoxSourceDesc) A very short string used to describe the\n# 'source' parameter to the 'dbg blackbox' command.\ndbgBlackBoxSourceDesc=A specific source to black box\n\n# LOCALIZATION NOTE (dbgBlackBoxGlobDesc) A very short string used to describe the\n# 'glob' parameter to the 'dbg blackbox' command.\ndbgBlackBoxGlobDesc=Black box all sources that match this glob (for example: “*.min.js”)\n\n# LOCALIZATION NOTE (dbgBlackBoxInvertDesc) A very short string used to describe the\n# 'invert' parameter to the 'dbg blackbox' command.\ndbgBlackBoxInvertDesc=Invert matching, so that we black box every source that is not the source provided or does not match the provided glob pattern.\n\n# LOCALIZATION NOTE (dbgBlackBoxEmptyDesc) A very short string used to let the\n# user know that no sources were black boxed.\ndbgBlackBoxEmptyDesc=(No sources black boxed)\n\n# LOCALIZATION NOTE (dbgBlackBoxNonEmptyDesc) A very short string used to let the\n# user know which sources were black boxed.\ndbgBlackBoxNonEmptyDesc=The following sources were black boxed:\n\n# LOCALIZATION NOTE (dbgBlackBoxErrorDesc) A very short string used to let the\n# user know there was an error black boxing a source (whose url follows this\n# text).\ndbgBlackBoxErrorDesc=Error black boxing:\n\n# LOCALIZATION NOTE (dbgUnBlackBoxDesc) A very short string used to describe the\n# function of the 'dbg unblackbox' command.\ndbgUnBlackBoxDesc=Stop black boxing sources in the debugger\n\n# LOCALIZATION NOTE (dbgUnBlackBoxSourceDesc) A very short string used to describe the\n# 'source' parameter to the 'dbg unblackbox' command.\ndbgUnBlackBoxSourceDesc=A specific source to stop black boxing\n\n# LOCALIZATION NOTE (dbgUnBlackBoxGlobDesc) A very short string used to describe the\n# 'glob' parameter to the 'dbg blackbox' command.\ndbgUnBlackBoxGlobDesc=Stop black boxing all sources that match this glob (for example: “*.min.js”)\n\n# LOCALIZATION NOTE (dbgUnBlackBoxEmptyDesc) A very short string used to let the\n# user know that we did not stop black boxing any sources.\ndbgUnBlackBoxEmptyDesc=(Did not stop black boxing any sources)\n\n# LOCALIZATION NOTE (dbgUnBlackBoxNonEmptyDesc) A very short string used to let the\n# user know which sources we stopped black boxing.\ndbgUnBlackBoxNonEmptyDesc=Stopped black boxing the following sources:\n\n# LOCALIZATION NOTE (dbgUnBlackBoxErrorDesc) A very short string used to let the\n# user know there was an error black boxing a source (whose url follows this\n# text).\ndbgUnBlackBoxErrorDesc=Error stopping black boxing:\n\n# LOCALIZATION NOTE (dbgUnBlackBoxInvertDesc) A very short string used to describe the\n# 'invert' parameter to the 'dbg unblackbox' command.\ndbgUnBlackBoxInvertDesc=Invert matching, so that we stop black boxing every source that is not the source provided or does not match the provided glob pattern.\n\n# LOCALIZATION NOTE (consolecloseDesc) A very short description of the\n# 'console close' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nconsolecloseDesc=Close the console\n\n# LOCALIZATION NOTE (consoleopenDesc) A very short description of the\n# 'console open' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nconsoleopenDesc=Open the console\n\n# LOCALIZATION NOTE (editDesc) A very short description of the 'edit'\n# command. See editManual2 for a fuller description of what it does. This\n# string is designed to be shown in a menu alongside the command name, which\n# is why it should be as short as possible.\neditDesc=Tweak a page resource\n\n# LOCALIZATION NOTE (editManual2) A fuller description of the 'edit' command,\n# displayed when the user asks for help on what it does.\neditManual2=Edit one of the resources that is part of this page\n\n# LOCALIZATION NOTE (editResourceDesc) A very short string to describe the\n# 'resource' parameter to the 'edit' command, which is displayed in a dialog\n# when the user is using this command.\neditResourceDesc=URL to edit\n\n# LOCALIZATION NOTE (editLineToJumpToDesc) A very short string to describe the\n# 'line' parameter to the 'edit' command, which is displayed in a dialog\n# when the user is using this command.\neditLineToJumpToDesc=Line to jump to\n\n# LOCALIZATION NOTE (resizePageDesc) A very short string to describe the\n# 'resizepage' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizePageDesc=Resize the page\n\n# LOCALIZATION NOTE (resizePageArgWidthDesc) A very short string to describe the\n# 'width' parameter to the 'resizepage' command, which is displayed in a dialog\n# when the user is using this command.\nresizePageArgWidthDesc=Width in pixels\n\n# LOCALIZATION NOTE (resizePageArgWidthDesc) A very short string to describe the\n# 'height' parameter to the 'resizepage' command, which is displayed in a dialog\n# when the user is using this command.\nresizePageArgHeightDesc=Height in pixels\n\n# LOCALIZATION NOTE (resizeModeOnDesc) A very short string to describe the\n# 'resizeon ' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeOnDesc=Enter Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeOffDesc) A very short string to describe the\n# 'resize off' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeOffDesc=Exit Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeToggleDesc) A very short string to describe the\n# 'resize toggle' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeToggleDesc=Toggle Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeToggleTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles Responsive Design Mode.\nresizeModeToggleTooltip=Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeToDesc) A very short string to describe the\n# 'resize to' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeToDesc=Alter page size\n\n# LOCALIZATION NOTE (resizeModeDesc) A very short string to describe the\n# 'resize' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\nresizeModeDesc=Control Responsive Design Mode\n\n# LOCALIZATION NOTE (resizeModeManual) A fuller description of the 'resize'\n# command, displayed when the user asks for help on what it does.\n# The argument (%1$S) is the browser name.\nresizeModeManual2=Responsive websites respond to their environment, so they look good on a mobile display, a cinema display and everything in-between. Responsive Design Mode allows you to easily test a variety of page sizes in %1$S without needing to resize your whole browser.\n\n# LOCALIZATION NOTE (cmdDesc) A very short description of the 'cmd'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\ncmdDesc=Manipulate the commands\n\n# LOCALIZATION NOTE (cmdRefreshDesc) A very short description of the 'cmd refresh'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\ncmdRefreshDesc=Re-read mozcmd directory\n\n# LOCALIZATION NOTE (cmdStatus3) When the we load new commands from mozcmd\n# directory, we report where we loaded from using %1$S.\ncmdStatus3=Loaded commands from ‘%1$S’\n\n# LOCALIZATION NOTE (cmdSetdirDesc)  A very short description of the 'cmd setdir'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\ncmdSetdirDesc=Setup a mozcmd directory\n\n# LOCALIZATION NOTE (cmdSetdirManual3) A fuller description of the 'cmd setdir'\n# command, displayed when the user asks for help on what it does.\ncmdSetdirManual3=A ‘mozcmd’ directory is an easy way to create new custom commands. For more information see https://developer.mozilla.org/docs/Tools/GCLI/Customization\n\n# LOCALIZATION NOTE (cmdSetdirDirectoryDesc) The description of the directory\n# parameter to the 'cmd setdir' command.\ncmdSetdirDirectoryDesc=Directory containing .mozcmd files\n\n# LOCALIZATION NOTE (addonDesc) A very short description of the 'addon'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\naddonDesc=Manipulate add-ons\n\n# LOCALIZATION NOTE (addonListDesc) A very short description of the 'addon list'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\naddonListDesc=List installed add-ons\n\n# LOCALIZATION NOTE (addonListTypeDesc) A very short description of the\n# 'addon list <type>' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\naddonListTypeDesc=Select an add-on type\n\n# LOCALIZATION NOTE (addonListDictionaryHeading, addonListExtensionHeading,\n# addonListLocaleHeading, addonListPluginHeading, addonListThemeHeading,\n# addonListUnknownHeading) Used in the output of the 'addon list' command as the\n# first line of output.\naddonListDictionaryHeading=The following dictionaries are currently installed:\naddonListExtensionHeading=The following extensions are currently installed:\naddonListLocaleHeading=The following locales are currently installed:\naddonListPluginHeading=The following plugins are currently installed:\naddonListThemeHeading=The following themes are currently installed:\naddonListAllHeading=The following add-ons are currently installed:\naddonListUnknownHeading=The following add-ons of the selected type are currently installed:\n\n# LOCALIZATION NOTE (addonListOutEnable, addonListOutDisable) Used in the\n# output of the 'addon list' command as the labels for the enable/disable\n# action buttons in the listing. This string is designed to be shown in a\n# small action button next to the addon name, which is why it should be as\n# short as possible.\naddonListOutEnable=Enable\naddonListOutDisable=Disable\n\n# LOCALIZATION NOTE (addonPending, addonPendingEnable, addonPendingDisable,\n# addonPendingUninstall, addonPendingInstall, addonPendingUpgrade) Used in\n# the output of the 'addon list' command as the descriptions of pending\n# addon operations. addonPending is used as a prefix for a list of pending\n# actions (named by the other lookup variables). These strings are designed\n# to be shown alongside addon names, which is why they should be as short\n# as possible.\naddonPending=pending\naddonPendingEnable=enable\naddonPendingDisable=disable\naddonPendingUninstall=uninstall\naddonPendingInstall=install\naddonPendingUpgrade=upgrade\n\n# LOCALIZATION NOTE (addonNameDesc) A very short description of the\n# name parameter of numerous add-on commands. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\naddonNameDesc=The name of the add-on\n\n# LOCALIZATION NOTE (addonNoneOfType) Used in the output of the 'addon list'\n# command when a search for add-ons of a particular type were not found.\naddonNoneOfType=There are no add-ons of that type installed.\n\n# LOCALIZATION NOTE (addonEnableDesc) A very short description of the\n# 'addon enable <type>' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\naddonEnableDesc=Enable the specified add-on\n\n# LOCALIZATION NOTE (addonAlreadyEnabled) Used in the output of the\n# 'addon enable' command when an attempt is made to enable an add-on that is\n# already enabled.\naddonAlreadyEnabled=%S is already enabled.\n\n# LOCALIZATION NOTE (addonEnabled) Used in the output of the 'addon enable'\n# command when an add-on is enabled.\naddonEnabled=%S enabled.\n\n# LOCALIZATION NOTE (addonDisableDesc) A very short description of the\n# 'addon disable <type>' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\naddonDisableDesc=Disable the specified add-on\n\n# LOCALIZATION NOTE (addonAlreadyDisabled) Used in the output of the\n# 'addon disable' command when an attempt is made to disable an add-on that is\n# already disabled.\naddonAlreadyDisabled=%S is already disabled.\n\n# LOCALIZATION NOTE (addonDisabled) Used in the output of the 'addon disable'\n# command when an add-on is disabled.\naddonDisabled=%S disabled.\n\n# LOCALIZATION NOTE (addonCtpDesc) A very short description of the\n# 'addon ctp <type>' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\naddonCtpDesc=Set the specified plugin to click-to-play.\n\n# LOCALIZATION NOTE (addonCtp) Used in the output of the 'addon ctp'\n# command when a plugin is set to click-to-play.\naddonCtp=%S set to click-to-play.\n\n# LOCALIZATION NOTE (addonAlreadyCtp) Used in the output of the\n# 'addon ctp' command when an attempt is made to set a plugin to\n# click-to-play that is already set to click-to-play.\naddonAlreadyCtp=%S is already set to click-to-play.\n\n# LOCALIZATION NOTE (addonCantCtp) Used in the output of the 'addon\n# ctp' command when an attempt is made to set an addon to click-to-play,\n# but the addon is not a plugin.\naddonCantCtp=%S cannot be set to click-to-play because it is not a plugin.\n\n# LOCALIZATION NOTE (addonNoCtp) Used in the output of the 'addon\n# ctp' command when an attempt is made to set an addon to click-to-play,\n# but the plugin cannot be set to click-to-play for some reason.\naddonNoCtp=%S cannot be set to click-to-play.\n\n# LOCALIZATION NOTE (exportDesc) A very short description of the 'export'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\nexportDesc=Export resources\n\n# LOCALIZATION NOTE (exportHtmlDesc) A very short description of the 'export\n# html' command. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nexportHtmlDesc=Export HTML from page\n\n# LOCALIZATION NOTE (pagemodDesc) A very short description of the 'pagemod'\n# command. This string is designed to be shown in a menu alongside the command\n# name, which is why it should be as short as possible.\npagemodDesc=Make page changes\n\n# LOCALIZATION NOTE (pagemodReplaceDesc) A very short description of the\n# 'pagemod replace' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\npagemodReplaceDesc=Search and replace in page elements\n\n# LOCALIZATION NOTE (pagemodReplaceSearchDesc) A very short string to describe\n# the 'search' parameter to the 'pagemod replace' command, which is displayed in\n# a dialog when the user is using this command.\npagemodReplaceSearchDesc=What to search for\n\n# LOCALIZATION NOTE (pagemodReplaceReplaceDesc) A very short string to describe\n# the 'replace' parameter to the 'pagemod replace' command, which is displayed in\n# a dialog when the user is using this command.\npagemodReplaceReplaceDesc=Replacement string\n\n# LOCALIZATION NOTE (pagemodReplaceIgnoreCaseDesc) A very short string to\n# describe the 'ignoreCase' parameter to the 'pagemod replace' command, which is\n# displayed in a dialog when the user is using this command.\npagemodReplaceIgnoreCaseDesc=Perform case-insensitive search\n\n# LOCALIZATION NOTE (pagemodReplaceRootDesc) A very short string to describe the\n# 'root' parameter to the 'pagemod replace' command, which is displayed in\n# a dialog when the user is using this command.\npagemodReplaceRootDesc=CSS selector to root of search\n\n# LOCALIZATION NOTE (pagemodReplaceSelectorDesc) A very short string to describe\n# the 'selector' parameter to the 'pagemod replace' command, which is displayed\n# in a dialog when the user is using this command.\npagemodReplaceSelectorDesc=CSS selector to match in search\n\n# LOCALIZATION NOTE (pagemodReplaceAttributesDesc) A very short string to\n# describe the 'attributes' parameter to the 'pagemod replace' command, which is\n# displayed in a dialog when the user is using this command.\npagemodReplaceAttributesDesc=Attribute match regexp\n\n# LOCALIZATION NOTE (pagemodReplaceAttrOnlyDesc) A very short string to describe\n# the 'attrOnly' parameter to the 'pagemod replace' command, which is displayed\n# in a dialog when the user is using this command.\npagemodReplaceAttrOnlyDesc=Restrict search to attributes\n\n# LOCALIZATION NOTE (pagemodReplaceContentOnlyDesc) A very short string to\n# describe the 'contentOnly' parameter to the 'pagemod replace' command, which\n# is displayed in a dialog when the user is using this command.\npagemodReplaceContentOnlyDesc=Restrict search to text nodes\n\n# LOCALIZATION NOTE (pagemodReplaceResultMatchedElements) A string displayed as\n# the result of the 'pagemod replace' command.\npagemodReplaceResult=Elements matched by selector: %1$S. Replaces in text nodes: %2$S. Replaces in attributes: %3$S.\n\n# LOCALIZATION NOTE (pagemodRemoveDesc) A very short description of the\n# 'pagemod remove' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\npagemodRemoveDesc=Remove elements and attributes from page\n\n# LOCALIZATION NOTE (pagemodRemoveElementDesc) A very short description of the\n# 'pagemod remove element' command. This string is designed to be shown in\n# a menu alongside the command name, which is why it should be as short as\n# possible.\npagemodRemoveElementDesc=Remove elements from page\n\n# LOCALIZATION NOTE (pagemodRemoveElementSearchDesc) A very short string to\n# describe the 'search' parameter to the 'pagemod remove element' command, which\n# is displayed in a dialog when the user is using this command.\npagemodRemoveElementSearchDesc=CSS selector specifying elements to remove\n\n# LOCALIZATION NOTE (pagemodRemoveElementRootDesc) A very short string to\n# describe the 'root' parameter to the 'pagemod remove element' command, which\n# is displayed in a dialog when the user is using this command.\npagemodRemoveElementRootDesc=CSS selector specifying root of search\n\n# LOCALIZATION NOTE (pagemodRemoveElementStripOnlyDesc) A very short string to\n# describe the 'stripOnly' parameter to the 'pagemod remove element' command,\n# which is displayed in a dialog when the user is using this command.\npagemodRemoveElementStripOnlyDesc=Remove element, but leave content\n\n# LOCALIZATION NOTE (pagemodRemoveElementIfEmptyOnlyDesc) A very short string to\n# describe the 'ifEmptyOnly' parameter to the 'pagemod remove element' command,\n# which is displayed in a dialog when the user is using this command.\npagemodRemoveElementIfEmptyOnlyDesc=Remove only empty elements\n\n# LOCALIZATION NOTE (pagemodRemoveElementResultMatchedAndRemovedElements)\n# A string displayed as the result of the 'pagemod remove element' command.\npagemodRemoveElementResultMatchedAndRemovedElements=Elements matched by selector: %1$S. Elements removed: %2$S.\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeDesc) A very short description of the\n# 'pagemod remove attribute' command. This string is designed to be shown in\n# a menu alongside the command name, which is why it should be as short as\n# possible.\npagemodRemoveAttributeDesc=Remove matching attributes\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeSearchAttributesDesc) A very short\n# string to describe the 'searchAttributes' parameter to the 'pagemod remove\n# attribute' command, which is displayed in a dialog when the user is using this\n# command.\npagemodRemoveAttributeSearchAttributesDesc=Regexp specifying attributes to remove\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeSearchElementsDesc) A very short\n# string to describe the 'searchElements' parameter to the 'pagemod remove\n# attribute' command, which is displayed in a dialog when the user is using this\n# command.\npagemodRemoveAttributeSearchElementsDesc=CSS selector of elements to include\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeRootDesc) A very short string to\n# describe the 'root' parameter to the 'pagemod remove attribute' command, which\n# is displayed in a dialog when the user is using this command.\npagemodRemoveAttributeRootDesc=CSS selector of root of search\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeIgnoreCaseDesc) A very short string\n# to describe the 'ignoreCase' parameter to the 'pagemod remove attribute'\n# command, which is displayed in a dialog when the user is using this command.\npagemodRemoveAttributeIgnoreCaseDesc=Perform case-insensitive search\n\n# LOCALIZATION NOTE (pagemodRemoveAttributeResult) A string displayed as the\n# result of the 'pagemod remove attribute' command.\npagemodRemoveAttributeResult=Elements matched by selector: %1$S. Attributes removed: %2$S.\n\n# LOCALIZATION NOTE (toolsDesc2) A very short description of the 'tools'\n# command, the parent command for tool-hacking commands.\n# The argument (%1$S) is the browser name.\ntoolsDesc2=Hack the %1$S Developer Tools\n\n# LOCALIZATION NOTE (toolsManual2) A fuller description of the 'tools'\n# command. The argument (%1$S) is the browser name.\ntoolsManual2=Various commands related to hacking directly on the %1$S Developer Tools.\n\n# LOCALIZATION NOTE (toolsSrcdirDesc) A very short description of the 'tools srcdir'\n# command, for pointing your developer tools loader at a mozilla-central source tree.\ntoolsSrcdirDesc=Load tools from a mozilla-central checkout\n\n# LOCALIZATION NOTE (toolsSrcdirNotFound2) Shown when the 'tools srcdir' command was handed\n# an invalid srcdir.\ntoolsSrcdirNotFound2=%1$S does not exist or is not a mozilla-central checkout.\n\n# LOCALIZATION NOTE (toolsSrcdirReloaded2) Displayed when tools have been reloaded by the\n# 'tools srcdir' command.\ntoolsSrcdirReloaded2=Tools loaded from %1$S.\n\n# LOCALIZATION NOTE (toolsSrcdirManual2) A full description of the 'tools srcdir'\n# command. The argument (%1$S) is the browser name.\ntoolsSrcdirManual2=Load the %1$S Developer Tools from a complete mozilla-central checkout.\n\n# LOCALIZATION NOTE (toolsSrcdirDir) The srcdir argument to the 'tools srcdir' command.\ntoolsSrcdirDir=A mozilla-central checkout\n\n# LOCALIZATION NOTE (toolsBuiltinDesc) A short description of the 'tools builtin'\n# command, which overrides a previous 'tools srcdir' command.\ntoolsBuiltinDesc=Use the builtin tools\n\n# LOCALIZATION NOTE (toolsBuiltinDesc) A fuller description of the 'tools builtin'\n# command.\ntoolsBuiltinManual=Use the builtin tools, overriding any previous srcdir command.\n\n# LOCALIZATION NOTE (toolsBuiltinReloaded) Displayed when tools are loaded with the\n# 'tools builtin' command.\ntoolsBuiltinReloaded=Builtin tools loaded.\n\n# LOCALIZATION NOTE (toolsReloadDesc) A short description of the 'tools reload' command.\n# which will reload the tools from the current srcdir.\ntoolsReloadDesc=Reload the developer tools\n\n# LOCALIZATION NOTE (toolsReloaded2) Displayed when tools are reloaded with the 'tools\n# reload' command.\ntoolsReloaded2=Tools reloaded.\n\n# LOCALIZATION NOTE (cookieDesc) A very short description of the 'cookie'\n# command. See cookieManual for a fuller description of what it does. This\n# string is designed to be shown in a menu alongside the command name, which\n# is why it should be as short as possible.\ncookieDesc=Display and alter cookies\n\n# LOCALIZATION NOTE (cookieManual) A fuller description of the 'cookie'\n# command, displayed when the user asks for help on what it does.\ncookieManual=Commands to list, create, delete and alter cookies for the current domain.\n\n# LOCALIZATION NOTE (cookieListDesc) A very short description of the\n# 'cookie list' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncookieListDesc=Display cookies\n\n# LOCALIZATION NOTE (cookieListManual) A fuller description of the 'cookie list'\n# command, displayed when the user asks for help on what it does.\ncookieListManual=Display a list of the cookies relevant to the current page.\n\n# LOCALIZATION NOTE (cookieListOutHost,cookieListOutPath,cookieListOutExpires,cookieListOutAttributes):\n# The 'cookie list' command has a number of headings for cookie properties.\n# Particular care should be taken in translating these strings as they have\n# references to names in the cookies spec.\ncookieListOutHost=Host:\ncookieListOutPath=Path:\ncookieListOutExpires=Expires:\ncookieListOutAttributes=Attributes:\n\n# LOCALIZATION NOTE (cookieListOutNone) The output of the 'cookie list' command\n# uses this string when no cookie attributes (like httpOnly, secure, etc) apply\ncookieListOutNone=None\n\n# LOCALIZATION NOTE (cookieListOutSession) The output of the 'cookie list'\n# command uses this string to describe a cookie with an expiry value of '0'\n# that is to say it is a session cookie\ncookieListOutSession=At browser exit (session)\n\n# LOCALIZATION NOTE (cookieListOutNonePage) The output of the 'cookie list'\n# command uses this string for pages like 'about:blank' which can't contain\n# cookies\ncookieListOutNonePage=No cookies found for this page\n\n# LOCALIZATION NOTE (cookieListOutNoneHost) The output of the 'cookie list'\n# command uses this string when there are no cookies on a given web page\ncookieListOutNoneHost=No cookies found for host %1$S\n\n# LOCALIZATION NOTE (cookieListOutEdit) A title used in the output from the\n# 'cookie list' command on a button which can be used to edit cookie values\ncookieListOutEdit=Edit\n\n# LOCALIZATION NOTE (cookieListOutRemove) A title used in the output from the\n# 'cookie list' command on a button which can be used to remove cookies\ncookieListOutRemove=Remove\n\n# LOCALIZATION NOTE (cookieRemoveDesc) A very short description of the\n# 'cookie remove' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncookieRemoveDesc=Remove a cookie\n\n# LOCALIZATION NOTE (cookieRemoveManual) A fuller description of the 'cookie remove'\n# command, displayed when the user asks for help on what it does.\ncookieRemoveManual=Remove a cookie, given its key\n\n# LOCALIZATION NOTE (cookieRemoveKeyDesc) A very short string to describe the\n# 'key' parameter to the 'cookie remove' command, which is displayed in a dialog\n# when the user is using this command.\ncookieRemoveKeyDesc=The key of the cookie to remove\n\n# LOCALIZATION NOTE (cookieSetDesc) A very short description of the\n# 'cookie set' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncookieSetDesc=Set a cookie\n\n# LOCALIZATION NOTE (cookieSetManual) A fuller description of the 'cookie set'\n# command, displayed when the user asks for help on what it does.\ncookieSetManual=Set a cookie by specifying a key name, its value and optionally one or more of the following attributes: expires (max-age in seconds or the expires date in GMTString format), path, domain, secure\n\n# LOCALIZATION NOTE (cookieSetKeyDesc) A very short string to describe the\n# 'key' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetKeyDesc=The key of the cookie to set\n\n# LOCALIZATION NOTE (cookieSetValueDesc) A very short string to describe the\n# 'value' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetValueDesc=The value of the cookie to set\n\n# LOCALIZATION NOTE (cookieSetOptionsDesc) The title of a set of options to\n# the 'cookie set' command, displayed as a heading to the list of option.\ncookieSetOptionsDesc=Options\n\n# LOCALIZATION NOTE (cookieSetPathDesc) A very short string to describe the\n# 'path' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetPathDesc=The path of the cookie to set\n\n# LOCALIZATION NOTE (cookieSetDomainDesc) A very short string to describe the\n# 'domain' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetDomainDesc=The domain of the cookie to set\n\n# LOCALIZATION NOTE (cookieSetSecureDesc) A very short string to describe the\n# 'secure' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetSecureDesc=Only transmitted over https\n\n# LOCALIZATION NOTE (cookieSetHttpOnlyDesc) A very short string to describe the\n# 'httpOnly' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetHttpOnlyDesc=Not accessible from client side script\n\n# LOCALIZATION NOTE (cookieSetSessionDesc) A very short string to describe the\n# 'session' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetSessionDesc=Only valid for the lifetime of the browser session\n\n# LOCALIZATION NOTE (cookieSetExpiresDesc) A very short string to describe the\n# 'expires' parameter to the 'cookie set' command, which is displayed in a dialog\n# when the user is using this command.\ncookieSetExpiresDesc=The expiry date of the cookie (quoted RFC2822 or ISO 8601 date)\n\n# LOCALIZATION NOTE (jsbDesc) A very short description of the\n# 'jsb' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\njsbDesc=JavaScript beautifier\n\n# LOCALIZATION NOTE (jsbUrlDesc) A very short description of the\n# 'jsb <url>' parameter. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\njsbUrlDesc=The URL of the JS file to beautify\n\n# LOCALIZATION NOTE (jsbIndentSizeDesc) A very short description of the\n# 'jsb <indentSize>' parameter. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\njsbIndentSizeDesc=Indentation size in chars\n\n# LOCALIZATION NOTE (jsbIndentSizeManual) A fuller description of the\n# 'jsb <indentChar>' parameter, displayed when the user asks for help on what it\n# does.\njsbIndentSizeManual=The number of chars with which to indent each line\n\n# LOCALIZATION NOTE (jsbIndentCharDesc) A very short description of the\n# 'jsb <indentChar>' parameter. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\njsbIndentCharDesc=The chars used to indent each line\n\n# LOCALIZATION NOTE (jsbIndentCharManual) A fuller description of the\n# 'jsb <indentChar>' parameter, displayed when the user asks for help on what it\n# does.\njsbIndentCharManual=The chars used to indent each line. The possible choices are space or tab.\n\n# the 'jsb <doNotPreserveNewlines>' parameter. This string is designed to be\n# shown in a menu alongside the command name, which is why it should be as short\n# as possible.\njsbDoNotPreserveNewlinesDesc=Do not preserve line breaks\n\n# LOCALIZATION NOTE (jsbPreserveNewlinesManual) A fuller description of the\n# 'jsb <jsbPreserveNewlines>' parameter, displayed when the user asks for help\n# on what it does.\njsbPreserveNewlinesManual=Should existing line breaks be preserved\n\n# LOCALIZATION NOTE (jsbPreserveMaxNewlinesDesc) A very short description of the\n# 'jsb <preserveMaxNewlines>' parameter. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\njsbPreserveMaxNewlinesDesc=Max consecutive line breaks\n\n# LOCALIZATION NOTE (jsbPreserveMaxNewlinesManual) A fuller description of the\n# 'jsb <preserveMaxNewlines>' parameter, displayed when the user asks for help\n# on what it does.\njsbPreserveMaxNewlinesManual=The maximum number of consecutive line breaks to preserve\n\n# LOCALIZATION NOTE (jsbJslintHappyDesc) A very short description of the\n# 'jsb <jslintHappy>' parameter. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\njsbJslintHappyDesc=Enforce jslint-stricter mode?\n\n# LOCALIZATION NOTE (jsbJslintHappyManual) A fuller description of the\n# 'jsb <jslintHappy>' parameter, displayed when the user asks for help\n# on what it does.\njsbJslintHappyManual=When set to true, jslint-stricter mode is enforced\n\n# LOCALIZATION NOTE (jsbBraceStyleDesc2) A very short description of the\n# 'jsb <braceStyle>' parameter. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\njsbBraceStyleDesc2=Select the coding style of braces\n\n# LOCALIZATION NOTE (jsbBraceStyleManual2) A fuller description of the\n# 'jsb <braceStyle>' parameter, displayed when the user asks for help\n# on what it does.\n#\n# NOTES: The keywords collapse, expand, end-expand and expand-strict should not\n# be translated. \"even if it will break your code\" means that the resulting code\n# may no longer be functional.\njsbBraceStyleManual2=Select the coding style of braces: collapse - put braces on the same line as control statements; expand - put braces on own line (Allman / ANSI style); end-expand - put end braces on own line; expand-strict - put braces on own line even if it will break your code.\n\n# LOCALIZATION NOTE (jsbNoSpaceBeforeConditionalDesc) A very short description\n# of the 'jsb <noSpaceBeforeConditional>' parameter. This string is designed to\n# be shown in a menu alongside the command name, which is why it should be as\n# short as possible.\njsbNoSpaceBeforeConditionalDesc=No space before conditional statements\n\n# LOCALIZATION NOTE (jsbUnescapeStringsDesc) A very short description of the\n# 'jsb <unescapeStrings>' parameter. This string is designed to be shown\n# in a menu alongside the command name, which is why it should be as short as\n# possible.\njsbUnescapeStringsDesc=Unescape \\\\xNN characters?\n\n# LOCALIZATION NOTE (jsbUnescapeStringsManual) A fuller description of the\n# 'jsb <unescapeStrings>' parameter, displayed when the user asks for help\n# on what it does.\njsbUnescapeStringsManual=Should printable characters in strings encoded in \\\\xNN notation be unescaped?\n\n# LOCALIZATION NOTE (jsbInvalidURL) Displayed when an invalid URL is passed to\n# the jsb command.\njsbInvalidURL=Please enter a valid URL\n\n# LOCALIZATION NOTE (jsbOptionsDesc) The title of a set of options to\n# the 'jsb' command, displayed as a heading to the list of options.\njsbOptionsDesc=Options\n\n# LOCALIZATION NOTE (calllogDesc) A very short description of the\n# 'calllog' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogDesc=Commands to manipulate function call logging\n\n# LOCALIZATION NOTE (calllogStartDesc) A very short description of the\n# 'calllog start' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogStartDesc=Start logging function calls to the console\n\n# LOCALIZATION NOTE (calllogStartReply) A string displayed as the result of\n# the 'calllog start' command.\ncalllogStartReply=Call logging started.\n\n# LOCALIZATION NOTE (calllogStopDesc) A very short description of the\n# 'calllog stop' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogStopDesc=Stop function call logging\n\n# LOCALIZATION NOTE (calllogStopNoLogging) A string displayed as the result of\n# the 'calllog stop' command when there is nothing to stop.\ncalllogStopNoLogging=No call logging is currently active\n\n# LOCALIZATION NOTE (calllogStopReply) A string displayed as the result of\n# the 'calllog stop' command when there are logging actions to stop.\ncalllogStopReply=Stopped call logging. Active contexts: %1$S.\n\n# LOCALIZATION NOTE (calllogStartChromeDesc) A very short description of the\n# 'calllog chromestart' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogChromeStartDesc=Start logging function calls for chrome code to the console\n\n# LOCALIZATION NOTE (calllogChromeSourceTypeDesc) A very short description of the\n# 'calllog chromestart <sourceType>' parameter. This string is designed to be\n# shown in a menu alongside the command name, which is why it should be as short as possible.\ncalllogChromeSourceTypeDesc=Global object, JSM URI, or JS to get a global object from\n\n# LOCALIZATION NOTE (calllogChromeSourceTypeDesc) A very short description of the\n# 'calllog chromestart' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogChromeSourceTypeManual=The global object, URI of a JSM, or JS to execute in the chrome window from which to obtain a global object\n\n# LOCALIZATION NOTE (calllogChromeStartReply) A string displayed as the result\n# of the 'calllog chromestart' command.\ncalllogChromeStartReply=Call logging started.\n\n# LOCALIZATION NOTE (calllogChromeStopDesc) A very short description of the\n# 'calllog chromestop' command. This string is designed to be shown in a menu\n# alongside the command name, which is why it should be as short as possible.\ncalllogChromeStopDesc=Stop function call logging\n\n# LOCALIZATION NOTE (calllogChromeStopNoLogging) A string displayed as the\n# result of the 'calllog chromestop' command when there is nothing to stop.\ncalllogChromeStopNoLogging=No call logging for chrome code is currently active\n\n# LOCALIZATION NOTE (calllogStopReply) A string displayed as the result of\n# the 'calllog chromestop' command when there are logging actions to stop.\ncalllogChromeStopReply=Stopped call logging. Active contexts: %1$S.\n\n# LOCALIZATION NOTE (callLogChromeAnonFunction) A string displayed as the result\n# of the 'calllog chromestart' command when an anonymouse function is to be\n# logged.\ncallLogChromeAnonFunction=<anonymous>\n\n# LOCALIZATION NOTE (callLogChromeMethodCall) A string displayed as the result\n# of the 'calllog chromestart' command to proceed a method name when it is to be\n# logged.\ncallLogChromeMethodCall=Method call\n\n# LOCALIZATION NOTE (callLogChromeInvalidJSM) A string displayed as the result\n# of the 'calllog chromestart' command with an invalid JSM or JSM path.\ncallLogChromeInvalidJSM=Invalid JSM!\n\n# LOCALIZATION NOTE (callLogChromeVarNotFoundContent) A string displayed as the\n# result of the 'calllog chromestart' command with a source type of\n# content-variable and an invalid variable name.\ncallLogChromeVarNotFoundContent=Variable not found in content window.\n\n# LOCALIZATION NOTE (callLogChromeVarNotFoundChrome) A string displayed as the\n# result of the 'calllog chromestart' command with a source type of\n# chrome-variable and an invalid variable name.\ncallLogChromeVarNotFoundChrome=Variable not found in chrome window.\n\n# LOCALIZATION NOTE (callLogChromeEvalException) A string displayed as the\n# result of the 'calllog chromestart' command with a source type of JavaScript\n# and invalid JavaScript code.\ncallLogChromeEvalException=Evaluated JavaScript threw the following exception\n\n# LOCALIZATION NOTE (callLogChromeEvalNeedsObject) A string displayed as the\n# result of passing a non-JavaScript object creating source via the\n# 'calllog chromestart javascript' command.\ncallLogChromeEvalNeedsObject=The JavaScript source must evaluate to an object whose method calls are to be logged e.g. “({a1: function() {this.a2()},a2: function() {}});”\n\n# LOCALIZATION NOTE (scratchpadOpenTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which opens Scratchpad.\nscratchpadOpenTooltip=Scratchpad\n\n# LOCALIZATION NOTE (paintflashingDesc) A very short string used to describe the\n# function of the \"paintflashing\" command\npaintflashingDesc=Highlight painted area\n\n# LOCALIZATION NOTE (paintflashingOnDesc) A very short string used to describe the\n# function of the \"paintflashing on\" command.\npaintflashingOnDesc=Turn on paint flashing\n\n# LOCALIZATION NOTE (paintflashingOffDesc) A very short string used to describe the\n# function of the \"paintflashing off\" command.\npaintflashingOffDesc=Turn off paint flashing\n\n# LOCALIZATION NOTE (paintflashingChrome) A very short string used to describe the\n# function of the \"paintflashing on/off chrome\" command.\npaintflashingChromeDesc=chrome frames\n\n# LOCALIZATION NOTE (paintflashingManual) A longer description describing the\n# set of commands that control paint flashing.\npaintflashingManual=Draw repainted areas in different colors\n\n# LOCALIZATION NOTE (paintflashingTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles paint flashing.\npaintflashingTooltip=Highlight painted area\n\n# LOCALIZATION NOTE (paintflashingToggleDesc) A very short string used to describe the\n# function of the \"paintflashing toggle\" command.\npaintflashingToggleDesc=Toggle paint flashing\n\n# LOCALIZATION NOTE (splitconsoleTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles the split webconsole.\nsplitconsoleTooltip=Toggle split console\n\n# LOCALIZATION NOTE (appCacheDesc) A very short string used to describe the\n# function of the \"appcache\" command\nappCacheDesc=Application cache utilities\n\n# LOCALIZATION NOTE (appCacheValidateDesc) A very short string used to describe\n# the function of the \"appcache validate\" command.\nappCacheValidateDesc=Validate cache manifest\n\n# LOCALIZATION NOTE (appCacheValidateManual) A fuller description of the\n# 'validate' parameter to the 'appcache' command, displayed when the user asks\n# for help on what it does.\nappCacheValidateManual=Find issues relating to a cache manifest and the files that it references\n\n# LOCALIZATION NOTE (appCacheValidateUriDesc) A very short string used to describe\n# the function of the \"uri\" parameter of the appcache validate\" command.\nappCacheValidateUriDesc=URI to check\n\n# LOCALIZATION NOTE (appCacheValidated) Displayed by the \"appcache validate\"\n# command when it has been successfully validated.\nappCacheValidatedSuccessfully=Appcache validated successfully.\n\n# LOCALIZATION NOTE (appCacheClearDesc) A very short string used to describe\n# the function of the \"appcache clear\" command.\nappCacheClearDesc=Clear entries from the application cache\n\n# LOCALIZATION NOTE (appCacheClearManual) A fuller description of the\n# 'appcache clear' command, displayed when the user asks for help on what it does.\nappCacheClearManual=Clear one or more entries from the application cache\n\n# LOCALIZATION NOTE (appCacheClearCleared) Displayed by the \"appcache clear\"\n# command when entries are successfully cleared.\nappCacheClearCleared=Entries cleared successfully.\n\n# LOCALIZATION NOTE (AppCacheListDesc) A very short string used to describe\n# the function of the \"appcache list\" command.\nappCacheListDesc=Display a list of application cache entries.\n\n# LOCALIZATION NOTE (AppCacheListManual) A fuller description of the\n# 'appcache list' command, displayed when the user asks for help on what it does.\nappCacheListManual=Display a list of all application cache entries. If the search parameter is used then the table displays the entries containing the search term.\n\n# LOCALIZATION NOTE (AppCacheListSearchDesc) A very short string used to describe\n# the function of the \"search\" parameter of the appcache list\" command.\nappCacheListSearchDesc=Filter results using a search term.\n\n# LOCALIZATION NOTE (AppCacheList*) Row headers for the 'appcache list' command.\nappCacheListKey=Key:\nappCacheListDataSize=Data size:\nappCacheListDeviceID=Device ID:\nappCacheListExpirationTime=Expires:\nappCacheListFetchCount=Fetch count:\nappCacheListLastFetched=Last fetched:\nappCacheListLastModified=Last modified:\n\n# LOCALIZATION NOTE (appCacheListViewEntry) The text for the view entry button\n# of the 'appcache list' command.\nappCacheListViewEntry=View Entry\n\n# LOCALIZATION NOTE (appCacheViewEntryDesc) A very short string used to describe\n# the function of the \"appcache viewentry\" command.\nappCacheViewEntryDesc=Open a new tab containing the specified cache entry information.\n\n# LOCALIZATION NOTE (appCacheViewEntryManual) A fuller description of the\n# 'appcache viewentry' command, displayed when the user asks for help on what it\n# does.\nappCacheViewEntryManual=Open a new tab containing the specified cache entry information.\n\n# LOCALIZATION NOTE (appCacheViewEntryKey) A very short string used to describe\n# the function of the \"key\" parameter of the 'appcache viewentry' command.\nappCacheViewEntryKey=The key for the entry to display.\n\n# LOCALIZATION NOTE (profilerDesc) A very short string used to describe the\n# function of the profiler command.\nprofilerDesc=Manage profiler\n\n# LOCALIZATION NOTE (profilerManual) A longer description describing the\n# set of commands that control the profiler.\nprofilerManual=Commands to start or stop a JavaScript profiler\n\n# LOCALIZATION NOTE (profilerOpen) A very short string used to describe the function\n# of the profiler open command.\nprofilerOpenDesc=Open the profiler\n\n# LOCALIZATION NOTE (profilerClose) A very short string used to describe the function\n# of the profiler close command.\nprofilerCloseDesc=Close the profiler\n\n# LOCALIZATION NOTE (profilerStart) A very short string used to describe the function\n# of the profiler start command.\nprofilerStartDesc=Start profiling\n\n# LOCALIZATION NOTE (profilerStartManual) A fuller description of the 'profile name'\n# parameter. This parameter is used to name a newly created profile or to lookup\n# an existing profile by its name.\nprofilerStartManual=Name of a profile you wish to start.\n\n# LOCALIZATION NOTE (profilerStop) A very short string used to describe the function\n# of the profiler stop command.\nprofilerStopDesc=Stop profiling\n\n# LOCALIZATION NOTE (profilerStopManual) A fuller description of the 'profile name'\n# parameter. This parameter is used to lookup an existing profile by its name.\nprofilerStopManual=Name of a profile you wish to stop.\n\n# LOCALIZATION NOTE (profilerList) A very short string used to describe the function\n# of the profiler list command.\nprofilerListDesc=List all profiles\n\n# LOCALIZATION NOTE (profilerShow) A very short string used to describe the function\n# of the profiler show command.\nprofilerShowDesc=Show individual profile\n\n# LOCALIZATION NOTE (profilerShowManual) A fuller description of the 'profile name'\n# parameter. This parameter is used to name a newly created profile or to lookup\n# an existing profile by its name.\nprofilerShowManual=Name of a profile.\n\n# LOCALIZATION NOTE (profilerAlreadyStarted) A message that is displayed whenever\n# an operation cannot be completed because the profile in question has already\n# been started.\nprofilerAlreadyStarted2=Profile has already been started\n\n# LOCALIZATION NOTE (profilerNotFound) A message that is displayed whenever\n# an operation cannot be completed because the profile in question could not be\n# found.\nprofilerNotFound=Profile not found\n\n# LOCALIZATION NOTE (profilerNotStarted) A message that is displayed whenever\n# an operation cannot be completed because the profile in question has not been\n# started yet. It also contains a hint to use the 'profile start' command to\n# start the profiler.\nprofilerNotStarted3=Profiler has not been started yet. Use ‘profile start’ to start profiling\n\n# LOCALIZATION NOTE (profilerStarted2) A very short string that indicates that\n# we have started recording.\nprofilerStarted2=Recording…\n\n# LOCALIZATION NOTE (profilerStopped) A very short string that indicates that\n# we have stopped recording.\nprofilerStopped=Stopped…\n\n# LOCALIZATION NOTE (profilerNotReady) A message that is displayed whenever\n# an operation cannot be completed because the profiler has not been opened yet.\nprofilerNotReady=For this command to work you need to open the profiler first\n\n# LOCALIZATION NOTE (listenDesc) A very short string used to describe the\n# function of the 'listen' command.\nlistenDesc=Open a remote debug port\n\n# LOCALIZATION NOTE (listenManual2) A longer description of the 'listen'\n# command.\nlistenManual2=%1$S can allow remote debugging over a TCP/IP connection. For security reasons this is turned off by default, but can be enabled using this command.\n\n# LOCALIZATION NOTE (listenPortDesc) A very short string used to describe the\n# function of 'port' parameter to the 'listen' command.\nlistenPortDesc=The TCP port to listen on\n\n# LOCALIZATION NOTE (listenDisabledOutput) Text of a message output during the\n# execution of the 'listen' command.\nlistenDisabledOutput=Listen is disabled by the devtools.debugger.remote-enabled preference\n\n# LOCALIZATION NOTE (listenInitOutput) Text of a message output during the\n# execution of the 'listen' command. %1$S is a port number\nlistenInitOutput=Listening on port %1$S\n\n# LOCALIZATION NOTE (listenNoInitOutput) Text of a message output during the\n# execution of the 'listen' command.\nlistenNoInitOutput=DebuggerServer not initialized\n\n# LOCALIZATION NOTE (unlistenDesc) A very short string used to describe the\n# function of the 'unlisten' command.\nunlistenDesc=Close all remote debug ports\n\n# LOCALIZATION NOTE (unlistenManual) A longer description of the 'unlisten'\n# command.\nunlistenManual=Closes all the open ports for remote debugging.\n\n# LOCALIZATION NOTE (unlistenOutput) Text of a message output during the\n# execution of the 'unlisten' command.\nunlistenOutput=All TCP ports closed\n\n# LOCALIZATION NOTE (mediaDesc, mediaEmulateDesc, mediaEmulateManual,\n# mediaEmulateType, mediaResetDesc, mediaResetManual) These strings describe\n# the 'media' commands and all available parameters.\nmediaDesc=CSS media type emulation\nmediaEmulateDesc=Emulate a specified CSS media type\nmediaEmulateManual=View the document as if rendered on a device supporting the given media type, with the relevant CSS rules applied.\nmediaEmulateType=The media type to emulate\nmediaResetDesc=Stop emulating a CSS media type\n\n# LOCALIZATION NOTE (qsaDesc, qsaQueryDesc)\n# These strings describe the 'qsa' commands and all available parameters.\nqsaDesc=Perform querySelectorAll on the current document and return number of matches\nqsaQueryDesc=CSS selectors separated by comma\n\n# LOCALIZATION NOTE (injectDesc, injectManual, injectLibraryDesc, injectLoaded,\n# injectFailed) These strings describe the 'inject' commands and all available\n# parameters.\ninjectDesc=Inject common libraries into the page\ninjectManual2=Inject common libraries into the content of the page which can also be accessed from the console.\ninjectLibraryDesc=Select the library to inject or enter a valid script URI to inject\ninjectLoaded=%1$S loaded\ninjectFailed=Failed to load %1$S - Invalid URI\n\n# LOCALIZATION NOTE (folderDesc, folderOpenDesc, folderOpenDir,\n# folderOpenProfileDesc) These strings describe the 'folder' commands and\n# all available parameters.\nfolderDesc=Open folders\nfolderOpenDesc=Open folder path\nfolderOpenDir=Directory Path\nfolderOpenProfileDesc=Open profile directory\n\n# LOCALIZATION NOTE (folderInvalidPath) A string displayed as the result\n# of the 'folder open' command with an invalid folder path.\nfolderInvalidPath=Please enter a valid path\n\n# LOCALIZATION NOTE (folderOpenDirResult) A very short string used to\n# describe the result of the 'folder open' command.\n# The argument (%1$S) is the folder path.\nfolderOpenDirResult=Opened %1$S\n\n# LOCALIZATION NOTE (mdnDesc) A very short string used to describe the\n# use of 'mdn' command.\nmdnDesc=Retrieve documentation from MDN\n# LOCALIZATION NOTE (mdnCssDesc) A very short string used to describe the\n# result of the 'mdn css' command.\nmdnCssDesc=Retrieve documentation about a given CSS property name from MDN\n# LOCALIZATION NOTE (mdnCssProp) String used to describe the 'property name'\n# parameter used in the 'mdn css' command.\nmdnCssProp=Property name\n# LOCALIZATION NOTE (mdnCssPropertyNotFound) String used to display an error in\n# the result of the 'mdn css' command. Errors occur when a given CSS property\n# wasn't found on MDN. The %1$S parameter will be replaced with the name of the\n# CSS property.\nmdnCssPropertyNotFound=MDN documentation for the CSS property ‘%1$S’ was not found.\n# LOCALIZATION NOTE (mdnCssVisitPage) String used as the label of a link to the\n# MDN page for a given CSS property.\nmdnCssVisitPage=Visit MDN page\n\n# LOCALIZATION NOTE (security)\nsecurityPrivacyDesc=Display supported security and privacy features\nsecurityManual=Commands to list and get suggestions about security features for the current domain.\nsecurityListDesc=Display security features\nsecurityListManual=Display a list of all relevant security features of the current page.\n# CSP specific\nsecurityCSPDesc=Display CSP specific security features\nsecurityCSPManual=Display feedback about the CSP applied to the current page.\nsecurityCSPRemWildCard=Can you remove the wildcard(*)?\nsecurityCSPPotentialXSS=Potential XSS vulnerability!\n# LOCALIZATION NOTE: do not translate 'Content-Security-Policy'\nsecurityCSPNoCSPOnPage=Could not find Content-Security-Policy for\nsecurityCSPHeaderOnPage=Content-Security-Policy for\nsecurityCSPROHeaderOnPage=Content-Security-Policy-Report-Only for\n# Referrer Policy specific\nsecurityReferrerPolicyDesc=Display the current Referrer Policy\nsecurityReferrerPolicyManual=Display the Referrer Policy for the current page with example referrers for different URIs.\nsecurityReferrerNextURI=When Visiting\nsecurityReferrerCalculatedReferrer=Referrer Will Be\n# LOCALIZATION NOTE: %1$S is the current page URI\nsecurityReferrerPolicyReportHeader=Referrer Policy for %1$S\nsecurityReferrerPolicyOtherDomain=Other Origin\nsecurityReferrerPolicyOtherDomainDowngrade=Other Origin HTTP\nsecurityReferrerPolicySameDomain=Same Origin\nsecurityReferrerPolicySameDomainDowngrade=Same Host HTTP\n\n# LOCALIZATION NOTE (rulersDesc) A very short description of the\n# 'rulers' command. See rulersManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nrulersDesc=Toggle rulers for the page\n\n# LOCALIZATION NOTE (rulersManual) A fuller description of the 'rulers'\n# command, displayed when the user asks for help on what it does.\nrulersManual=Toggle the horizontal and vertical rulers for the current page\n\n# LOCALIZATION NOTE (rulersTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles the rulers.\nrulersTooltip=Toggle rulers for the page\n\n# LOCALIZATION NOTE (measureDesc) A very short description of the\n# 'measure' command. See measureManual for a fuller description of what\n# it does. This string is designed to be shown in a menu alongside the\n# command name, which is why it should be as short as possible.\nmeasureDesc=Measure a portion of the page\n\n# LOCALIZATION NOTE (measureManual) A fuller description of the 'measure'\n# command, displayed when the user asks for help on what it does.\nmeasureManual=Activate the measuring tool to measure an arbitrary area of the page\n\n# LOCALIZATION NOTE (measureTooltip) A string displayed as the\n# tooltip of button in devtools toolbox which toggles the measuring tool.\nmeasureTooltip=Measure a portion of the page\n"

/***/ },
/* 64 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (ellipsis): The ellipsis (three dots) character\nellipsis=…"

/***/ },
/* 65 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Style Inspector.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n\n# LOCALIZATION NOTE (panelTitle): This is the panel title\npanelTitle=Style Inspector\n\n# LOCALIZATION NOTE (rule.status): For each style property the panel shows\n# the rules which hold that specific property. For every rule, the rule status\n# is also displayed: a rule can be the best match, a match, a parent match, or a\n# rule did not match the element the user has highlighted.\nrule.status.BEST=Best Match\nrule.status.MATCHED=Matched\nrule.status.PARENT_MATCH=Parent Match\n\n# LOCALIZATION NOTE (rule.sourceElement, rule.sourceInline): For each\n# style property the panel shows the rules which hold that specific property.\n# For every rule, the rule source is also displayed: a rule can come from a\n# file, from the same page (inline), or from the element itself (element).\nrule.sourceInline=inline\nrule.sourceElement=element\n\n# LOCALIZATION NOTE (rule.inheritedFrom): Shown for CSS rules\n# that were inherited from a parent node. Will be passed a node\n# identifier of the parent node.\n# e.g \"Inherited from body#bodyID\"\nrule.inheritedFrom=Inherited from %S\n\n# LOCALIZATION NOTE (rule.keyframe): Shown for CSS Rules keyframe header.\n# Will be passed an identifier of the keyframe animation name.\nrule.keyframe=Keyframes %S\n\n# LOCALIZATION NOTE (rule.userAgentStyles): Shown next to the style sheet\n# link for CSS rules that were loaded from a user agent style sheet.\n# These styles will not be editable, and will only be visible if the\n# devtools.inspector.showUserAgentStyles pref is true.\nrule.userAgentStyles=(user agent)\n\n# LOCALIZATION NOTE (rule.pseudoElement): Shown for CSS rules\n# pseudo element header\nrule.pseudoElement=Pseudo-elements\n\n# LOCALIZATION NOTE (rule.pseudoElement): Shown for CSS rules\n# pseudo element header\nrule.selectedElement=This Element\n\n# LOCALIZATION NOTE (helpLinkTitle): For each style property\n# the user can hover it and get a help link button which allows one to\n# quickly jump to the documentation from the Mozilla Developer Network site.\n# This is the link title shown in the hover tooltip.\nhelpLinkTitle=Read the documentation for this property\n\n# LOCALIZATION NOTE (rule.warning.title): When an invalid property value is\n# entered into the rule view a warning icon is displayed. This text is used for\n# the title attribute of the warning icon.\nrule.warning.title=Invalid property value\n\n# LOCALIZATION NOTE (rule.filterProperty.title): Text displayed in the tooltip\n# of the search button that is shown next to a property that has been overridden\n# in the rule view.\nrule.filterProperty.title=Filter rules containing this property\n\n# LOCALIZATION NOTE (ruleView.empty): Text displayed when the highlighter is\n# first opened and there's no node selected in the rule view.\nrule.empty=No element selected.\n\n# LOCALIZATION NOTE (ruleView.selectorHighlighter.tooltip): Text displayed in a\n# tooltip when the mouse is over a selector highlighter icon in the rule view.\nrule.selectorHighlighter.tooltip=Highlight all elements matching this selector\n\n# LOCALIZATION NOTE (rule.colorSwatch.tooltip): Text displayed in a tooltip\n# when the mouse is over a color swatch in the rule view.\nrule.colorSwatch.tooltip=Click to open the color picker, shift+click to change the color format\n\n# LOCALIZATION NOTE (rule.bezierSwatch.tooltip): Text displayed in a tooltip\n# when the mouse is over a cubic-bezier swatch in the rule view.\nrule.bezierSwatch.tooltip=Click to open the timing-function editor\n\n# LOCALIZATION NOTE (rule.filterSwatch.tooltip): Text displayed in a tooltip\n# when the mouse is over a filter swatch in the rule view.\nrule.filterSwatch.tooltip=Click to open the filter editor\n\n# LOCALIZATION NOTE (rule.angleSwatch.tooltip): Text displayed in a tooltip\n# when the mouse is over a angle swatch in the rule view.\nrule.angleSwatch.tooltip=Shift+click to change the angle format\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyColor): Text displayed in the rule\n# and computed view context menu when a color value was clicked.\nstyleinspector.contextmenu.copyColor=Copy Color\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyColor.accessKey): Access key for\n# the rule and computed view context menu \"Copy Color\" entry.\nstyleinspector.contextmenu.copyColor.accessKey=L\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyUrl): In rule and computed view :\n# text displayed in the context menu for an image URL.\n# Clicking it copies the URL to the clipboard of the user.\nstyleinspector.contextmenu.copyUrl=Copy URL\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyUrl.accessKey): Access key for\n# the rule and computed view context menu \"Copy URL\" entry.\nstyleinspector.contextmenu.copyUrl.accessKey=U\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyImageDataUrl): In rule and computed view :\n# text displayed in the context menu for an image URL.\n# Clicking it copies the image as Data-URL to the clipboard of the user.\nstyleinspector.contextmenu.copyImageDataUrl=Copy Image Data-URL\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyDataUri.accessKey): Access key for\n# the rule and computed view context menu \"Copy Image Data-URL\" entry.\nstyleinspector.contextmenu.copyImageDataUrl.accessKey=I\n\n# LOCALIZATION NOTE (styleinspector.copyDataUriError): Text set in the clipboard\n# if an error occurs when using the copyImageDataUrl context menu action\n# (invalid image link, timeout, etc...)\nstyleinspector.copyImageDataUrlError=Failed to copy image Data-URL\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.toggleOrigSources): Text displayed in the rule view\n# context menu.\nstyleinspector.contextmenu.toggleOrigSources=Show Original Sources\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.toggleOrigSources.accessKey): Access key for\n# the rule view context menu \"Show original sources\" entry.\nstyleinspector.contextmenu.toggleOrigSources.accessKey=O\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.showMdnDocs): Text displayed in the rule view\n# context menu to display docs from MDN for an item.\nstyleinspector.contextmenu.showMdnDocs=Show MDN Docs\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.showMdnDocs.accessKey): Access key for\n# the rule view context menu \"Show MDN docs\" entry.\nstyleinspector.contextmenu.showMdnDocs.accessKey=D\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.addNewRule): Text displayed in the\n# rule view context menu for adding a new rule to the element.\n# This should match addRuleButton.tooltip in styleinspector.dtd\nstyleinspector.contextmenu.addNewRule=Add New Rule\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.addRule.accessKey): Access key for\n# the rule view context menu \"Add rule\" entry.\nstyleinspector.contextmenu.addNewRule.accessKey=R\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.selectAll): Text displayed in the\n# computed view context menu.\nstyleinspector.contextmenu.selectAll=Select All\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.selectAll.accessKey): Access key for\n# the computed view context menu \"Select all\" entry.\nstyleinspector.contextmenu.selectAll.accessKey=A\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copy): Text displayed in the\n# computed view context menu.\nstyleinspector.contextmenu.copy=Copy\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copy.accessKey): Access key for\n# the computed view context menu \"Copy\" entry.\nstyleinspector.contextmenu.copy.accessKey=C\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyLocation): Text displayed in the\n# rule view context menu for copying the source location.\nstyleinspector.contextmenu.copyLocation=Copy Location\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyPropertyDeclaration): Text\n# displayed in the rule view context menu for copying the property declaration.\nstyleinspector.contextmenu.copyPropertyDeclaration=Copy Property Declaration\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyPropertyName): Text displayed in\n# the rule view context menu for copying the property name.\nstyleinspector.contextmenu.copyPropertyName=Copy Property Name\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyPropertyValue): Text displayed in\n# the rule view context menu for copying the property value.\nstyleinspector.contextmenu.copyPropertyValue=Copy Property Value\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copyRule): Text displayed in the\n# rule view context menu for copying the rule.\nstyleinspector.contextmenu.copyRule=Copy Rule\n\n# LOCALIZATION NOTE (styleinspector.contextmenu.copySelector): Text displayed in the\n# rule view context menu for copying the selector.\nstyleinspector.contextmenu.copySelector=Copy Selector\n"

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./aboutdebugging.properties": 67,
		"./animationinspector.properties": 68,
		"./app-manager.properties": 69,
		"./appcacheutils.properties": 70,
		"./canvasdebugger.properties": 71,
		"./components.properties": 72,
		"./connection-screen.properties": 73,
		"./debugger.properties": 74,
		"./device.properties": 75,
		"./dom.properties": 76,
		"./eyedropper.properties": 77,
		"./filterwidget.properties": 78,
		"./graphs.properties": 79,
		"./har.properties": 80,
		"./inspector.properties": 81,
		"./jit-optimizations.properties": 82,
		"./jsonview.properties": 83,
		"./markers.properties": 84,
		"./memory.properties": 85,
		"./menus.properties": 86,
		"./netmonitor.properties": 87,
		"./performance.properties": 88,
		"./projecteditor.properties": 89,
		"./promisedebugger.properties": 90,
		"./responsive.properties": 91,
		"./responsiveUI.properties": 92,
		"./scratchpad.properties": 93,
		"./shadereditor.properties": 94,
		"./shared.properties": 95,
		"./sourceeditor.properties": 96,
		"./storage.properties": 97,
		"./styleeditor.properties": 98,
		"./toolbox.properties": 99,
		"./webaudioeditor.properties": 100,
		"./webconsole.properties": 101,
		"./webide.properties": 102
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 66;


/***/ },
/* 67 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (debug):\n# This string is displayed as a label of the button that starts\n# debugging a service worker.\ndebug = Debug\n\n# LOCALIZATION NOTE (push):\n# This string is displayed as a label of the button that pushes a test payload\n# to a service worker.\npush = Push\n\n# LOCALIZATION NOTE (start):\n# This string is displayed as a label of the button that starts a service worker.\nstart = Start\n\nscope = Scope\nunregister = unregister\n\npushService = Push Service\n\n# LOCALIZATION NOTE (addons):\n# This string is displayed as a header of the about:debugging#addons page.\naddons = Add-ons\n\n# LOCALIZATION NOTE (addonDebugging.label):\n# This string is displayed next to a check box that enables the user to switch\n# addon debugging on/off.\naddonDebugging.label = Enable add-on debugging\n\n# LOCALIZATION NOTE (addonDebugging.tooltip):\n# This string is displayed in a tooltip that appears when hovering over a check\n# box that switches addon debugging on/off.\naddonDebugging.tooltip = Turning this on will allow you to debug add-ons and various other parts of the browser chrome\n\n# LOCALIZATION NOTE (moreInfo):\n# This string is displayed next to addonDebugging.label as a link to a page\n# with documentation.\nmoreInfo = more info\n\n# LOCALIZATION NOTE (loadTemporaryAddon):\n# This string is displayed as a label of a button that allows the user to\n# load additional add-ons.\nloadTemporaryAddon = Load Temporary Add-on\n\n# LOCALIZATION NOTE (extensions):\n# This string is displayed as a header above the list of loaded add-ons.\nextensions = Extensions\n\n# LOCALIZATION NOTE (selectAddonFromFile2):\n# This string is displayed as the title of the file picker that appears when\n# the user clicks the 'Load Temporary Add-on' button\nselectAddonFromFile2 = Select Manifest File or Package (.xpi)\n\n# LOCALIZATION NOTE (reload):\n# This string is displayed as a label of the button that reloads a given addon.\nreload = Reload\n\n# LOCALIZATION NOTE (reloadDisabledTooltip):\n# This string is displayed in a tooltip that appears when hovering over a\n# disabled 'reload' button.\nreloadDisabledTooltip = Only temporarily installed add-ons can be reloaded\n\n# LOCALIZATION NOTE (workers):\n# This string is displayed as a header of the about:debugging#workers page.\nworkers = Workers\n\nserviceWorkers = Service Workers\nsharedWorkers = Shared Workers\notherWorkers = Other Workers\n\n# LOCALIZATION NOTE (tabs):\n# This string is displayed as a header of the about:debugging#tabs page.\ntabs = Tabs\n\n# LOCALIZATION NOTE (pageNotFound):\n# This string is displayed as the main message at any error/invalid page.\npageNotFound = Page not found\n\n# LOCALIZATION NOTE (doesNotExist):\n# This string is displayed as an error message when navigating to an invalid page\n# %S will be replaced by the name of the page at run-time.\ndoesNotExist = #%S does not exist!\n\n# LOCALIZATION NOTE (nothing):\n# This string is displayed when the list of workers is empty.\nnothing = Nothing yet.\n\nconfigurationIsNotCompatible = Your browser configuration is not compatible with Service Workers\n"

/***/ },
/* 68 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Animation inspector\n# which is available as a sidebar panel in the Inspector.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (panel.invalidElementSelected):\n# This is the label shown in the panel when an invalid node is currently\n# selected in the inspector (i.e. a non-element node or a node that is not\n# animated).\npanel.invalidElementSelected=No animations were found for the current element.\n\n# LOCALIZATION NOTE (panel.selectElement): This is the label shown in the panel\n# when an invalid node is currently selected in the inspector, to invite the\n# user to select a new node by clicking on the element-picker icon.\npanel.selectElement=Pick another element from the page.\n\n# LOCALIZATION NOTE (panel.allAnimations): This is the label shown at the bottom of\n# the panel, in a toolbar, to let the user know the toolbar applies to all\n# animations, not just the ones applying to the current element.\npanel.allAnimations=All animations\n\n# LOCALIZATION NOTE (player.animationNameLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the animation name.\nplayer.animationNameLabel=Animation:\n\n# LOCALIZATION NOTE (player.transitionNameLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed in the header, when the element is animated by mean of a css\n# transition\nplayer.transitionNameLabel=Transition\n\n# LOCALIZATION NOTE (player.animationDurationLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the animation duration.\nplayer.animationDurationLabel=Duration:\n\n# LOCALIZATION NOTE (player.animationDelayLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the animation delay.\nplayer.animationDelayLabel=Delay:\n\n# LOCALIZATION NOTE (player.animationEndDelayLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the animation endDelay.\nplayer.animationEndDelayLabel=End delay:\n\n# LOCALIZATION NOTE (player.animationRateLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the animation playback rate.\nplayer.animationRateLabel=Playback rate:\n\n# LOCALIZATION NOTE (player.animationIterationCountLabel):\n# This string is displayed in each animation player widget. It is the label\n# displayed before the number of times the animation is set to repeat.\nplayer.animationIterationCountLabel=Repeats:\n\n# LOCALIZATION NOTE (player.infiniteIterationCount):\n# In case the animation repeats infinitely, this string is displayed next to the\n# player.animationIterationCountLabel string, instead of a number.\nplayer.infiniteIterationCount=&#8734;\n\n# LOCALIZATION NOTE (player.infiniteIterationCountText):\n# See player.infiniteIterationCount for a description of what this is.\n# Unlike player.infiniteIterationCount, this string isn't used in HTML, but in\n# a tooltip.\nplayer.infiniteIterationCountText=∞\n\n# LOCALIZATION NOTE (player.animationIterationStartLabel):\n# This string is displayed in a tooltip that appears when hovering over\n# animations in the timeline. It is the label displayed before the animation\n# iterationStart value.\n# %1$S will be replaced by the original iteration start value\n# %2$S will be replaced by the actual time of iteration start\nplayer.animationIterationStartLabel=Iteration start: %1$S (%2$Ss)\n\n# LOCALIZATION NOTE (player.timeLabel):\n# This string is displayed in each animation player widget, to indicate either\n# how long (in seconds) the animation lasts, or what is the animation's current\n# time (in seconds too);\nplayer.timeLabel=%Ss\n\n# LOCALIZATION NOTE (player.playbackRateLabel):\n# This string is displayed in each animation player widget, as the label of\n# drop-down list items that can be used to change the rate at which the\n# animation runs (1× being the default, 2× being twice as fast).\nplayer.playbackRateLabel=%S×\n\n# LOCALIZATION NOTE (player.runningOnCompositorTooltip):\n# This string is displayed as a tooltip for the icon that indicates that the\n# animation is running on the compositor thread.\nplayer.runningOnCompositorTooltip=This animation is running on compositor thread\n\n# LOCALIZATION NOTE (player.allPropertiesOnCompositorTooltip):\n# This string is displayed as a tooltip for the icon that indicates that\n# all of animation is running on the compositor thread.\nplayer.allPropertiesOnCompositorTooltip=All animation properties are optimized\n\n# LOCALIZATION NOTE (player.somePropertiesOnCompositorTooltip):\n# This string is displayed as a tooltip for the icon that indicates that\n# all of animation is not running on the compositor thread.\nplayer.somePropertiesOnCompositorTooltip=Some animation properties are optimized\n\n# LOCALIZATION NOTE (timeline.rateSelectorTooltip):\n# This string is displayed in the timeline toolbar, as the tooltip of the\n# drop-down list that can be used to change the rate at which the animations\n# run.\ntimeline.rateSelectorTooltip=Set the animations playback rates\n\n# LOCALIZATION NOTE (timeline.pauseResumeButtonTooltip):\n# This string is displayed in the timeline toolbar, as the tooltip of the\n# pause/resume button that can be used to pause or resume the animations\ntimeline.pausedButtonTooltip=Resume the animations\n\n# LOCALIZATION NOTE (timeline.pauseResumeButtonTooltip):\n# This string is displayed in the timeline toolbar, as the tooltip of the\n# pause/resume button that can be used to pause or resume the animations\ntimeline.resumedButtonTooltip=Pause the animations\n\n# LOCALIZATION NOTE (timeline.rewindButtonTooltip):\n# This string is displayed in the timeline toolbar, as the tooltip of the\n# rewind button that can be used to rewind the animations\ntimeline.rewindButtonTooltip=Rewind the animations\n\n# LOCALIZATION NOTE (timeline.timeGraduationLabel):\n# This string is displayed at the top of the animation panel, next to each time\n# graduation, to indicate what duration (in milliseconds) this graduation\n# corresponds to.\ntimeline.timeGraduationLabel=%Sms\n\n# LOCALIZATION NOTE (timeline.cssanimation.nameLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over the name of a CSS Animation in the timeline UI.\n# %S will be replaced by the name of the animation at run-time.\ntimeline.cssanimation.nameLabel=%S - CSS Animation\n\n# LOCALIZATION NOTE (timeline.csstransition.nameLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over the name of a CSS Transition in the timeline UI.\n# %S will be replaced by the name of the transition at run-time.\ntimeline.csstransition.nameLabel=%S - CSS Transition\n\n# LOCALIZATION NOTE (timeline.scriptanimation.nameLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over the name of a script-generated animation in the timeline UI.\n# %S will be replaced by the name of the animation at run-time.\ntimeline.scriptanimation.nameLabel=%S - Script Animation\n\n# LOCALIZATION NOTE (timeline.scriptanimation.unnamedLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over an unnamed script-generated animation in the timeline UI.\ntimeline.scriptanimation.unnamedLabel=Script Animation\n\n# LOCALIZATION NOTE (timeline.unknown.nameLabel):\n# This string is displayed in a tooltip of the animation panel that is shown\n# when hovering over the name of an unknown animation type in the timeline UI.\n# This can happen if devtools couldn't figure out the type of the animation.\n# %S will be replaced by the name of the transition at run-time.\ntimeline.unknown.nameLabel=%S\n"

/***/ },
/* 69 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nvalidator.nonExistingFolder=The project folder doesn’t exist\nvalidator.expectProjectFolder=The project folder ends up being a file\nvalidator.noManifestFile=A manifest file is required at project root folder, named either ‘manifest.webapp’ for packaged apps or ‘manifest.json’ for add-ons.\nvalidator.invalidManifestURL=Invalid manifest URL ‘%S’\n# LOCALIZATION NOTE (validator.invalidManifestJSON, validator.noAccessManifestURL):\n# %1$S is the error message, %2$S is the URI of the manifest.\nvalidator.invalidManifestJSON=The webapp manifest isn’t a valid JSON file: %1$S at: %2$S\nvalidator.noAccessManifestURL=Unable to read manifest file: %1$S at: %2$S\n# LOCALIZATION NOTE (validator.invalidHostedManifestURL): %1$S is the URI of\n# the manifest, %2$S is the error message.\nvalidator.invalidHostedManifestURL=Invalid hosted manifest URL ‘%1$S’: %2$S\nvalidator.invalidProjectType=Unknown project type ‘%S’\n# LOCALIZATION NOTE (validator.missNameManifestProperty, validator.missIconsManifestProperty):\n# don't translate 'icons' and 'name'.\nvalidator.missNameManifestProperty=Missing mandatory ‘name’ in Manifest.\nvalidator.missIconsManifestProperty=Missing ‘icons’ in Manifest.\nvalidator.missIconMarketplace2=app submission to the Marketplace requires a 128px icon\nvalidator.invalidAppType=Unknown app type: ‘%S’.\nvalidator.invalidHostedPriviledges=Hosted App can’t be type ‘%S’.\nvalidator.noCertifiedSupport=‘certified’ apps are not fully supported on the App manager.\nvalidator.nonAbsoluteLaunchPath=Launch path has to be an absolute path starting with ‘/’: ‘%S’\nvalidator.accessFailedLaunchPath=Unable to access the app starting document ‘%S’\n# LOCALIZATION NOTE (validator.accessFailedLaunchPathBadHttpCode): %1$S is the URI of\n# the launch document, %2$S is the http error code.\nvalidator.accessFailedLaunchPathBadHttpCode=Unable to access the app starting document ‘%1$S’, got HTTP code %2$S\n"

/***/ },
/* 70 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Web Console\n# command line which is available from the Web Developer sub-menu\n# -> 'Web Console'.\n# These messages are displayed when an attempt is made to validate a\n# page or a cache manifest using AppCacheUtils.jsm\n\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (noManifest): the specified page has no cache manifest.\nnoManifest=The specified page has no manifest.\n\n# LOCALIZATION NOTE (notUTF8): the associated cache manifest has a character\n# encoding that is not UTF-8. Parameters: %S is the current encoding.\nnotUTF8=Manifest has a character encoding of %S. Manifests must have the utf-8 character encoding.\n\n# LOCALIZATION NOTE (badMimeType): the associated cache manifest has a\n# mimetype that is not text/cache-manifest. Parameters: %S is the current\n# mimetype.\nbadMimeType=Manifest has a mimetype of %S. Manifests must have a mimetype of text/cache-manifest.\n\n# LOCALIZATION NOTE (duplicateURI): the associated cache manifest references\n# the same URI from multiple locations. Parameters: %1$S is the URI, %2$S is a\n# list of references to this URI.\nduplicateURI=URI %1$S is referenced in multiple locations. This is not allowed: %2$S.\n\n# LOCALIZATION NOTE (networkBlocksURI, fallbackBlocksURI): the associated\n# cache manifest references the same URI in the NETWORK (or FALLBACK) section\n# as it does in other sections. Parameters: %1$S is the line number, %2$S is\n# the resource name, %3$S is the line number, %4$S is the resource name, %5$S\n# is the section name.\nnetworkBlocksURI=NETWORK section line %1$S (%2$S) prevents caching of line %3$S (%4$S) in the %5$S section.\nfallbackBlocksURI=FALLBACK section line %1$S (%2$S) prevents caching of line %3$S (%4$S) in the %5$S section.\n\n# LOCALIZATION NOTE (fileChangedButNotManifest): the associated cache manifest\n# references a URI that has a file modified after the cache manifest.\n# Parameters: %1$S is the resource name, %2$S is the cache manifest, %3$S is\n# the line number.\nfileChangedButNotManifest=The file %1$S was modified after %2$S. Unless the text in the manifest file is changed the cached version will be used instead at line %3$S.\n\n# LOCALIZATION NOTE (cacheControlNoStore): the specified page has a header\n# preventing caching or storing information. Parameters: %1$S is the resource\n# name, %2$S is the line number.\ncacheControlNoStore=%1$S has cache-control set to no-store. This will prevent the application cache from storing the file at line %2$S.\n\n# LOCALIZATION NOTE (notAvailable): the specified resource is not available.\n# Parameters: %1$S is the resource name, %2$S is the line number.\nnotAvailable=%1$S points to a resource that is not available at line %2$S.\n\n# LOCALIZATION NOTE (invalidURI): it's used when an invalid URI is passed to\n# the appcache.\ninvalidURI=The URI passed to AppCacheUtils is invalid.\n\n# LOCALIZATION NOTE (noResults): it's used when a search returns no results.\nnoResults=Your search returned no results.\n\n# LOCALIZATION NOTE (cacheDisabled): it's used when the cache is disabled and\n# an attempt is made to view offline data.\ncacheDisabled=Your disk cache is disabled. Please set browser.cache.disk.enable to true in about:config and try again.\n\n# LOCALIZATION NOTE (firstLineMustBeCacheManifest): the associated cache\n# manifest has a first line that is not \"CACHE MANIFEST\". Parameters: %S is\n# the line number.\nfirstLineMustBeCacheManifest=The first line of the manifest must be “CACHE MANIFEST” at line %S.\n\n# LOCALIZATION NOTE (cacheManifestOnlyFirstLine2): the associated cache\n# manifest has \"CACHE MANIFEST\" on a line other than the first line.\n# Parameters: %S is the line number where \"CACHE MANIFEST\" appears.\ncacheManifestOnlyFirstLine2=“CACHE MANIFEST” is only valid on the first line but was found at line %S.\n\n# LOCALIZATION NOTE (asteriskInWrongSection2): the associated cache manifest\n# has an asterisk (*) in a section other than the NETWORK section. Parameters:\n# %1$S is the section name, %2$S is the line number.\nasteriskInWrongSection2=Asterisk (*) incorrectly used in the %1$S section at line %2$S. If a line in the NETWORK section contains only a single asterisk character, then any URI not listed in the manifest will be treated as if the URI was listed in the NETWORK section. Otherwise such URIs will be treated as unavailable. Other uses of the * character are prohibited.\n\n# LOCALIZATION NOTE (escapeSpaces): the associated cache manifest has a space\n# in a URI. Spaces must be replaced with %20. Parameters: %S is the line\n# number where this error occurs.\nescapeSpaces=Spaces in URIs need to be replaced with %20 at line %S.\n\n# LOCALIZATION NOTE (slashDotDotSlashBad): the associated cache manifest has a\n# URI containing /../, which is invalid. Parameters: %S is the line number\n# where this error occurs.\nslashDotDotSlashBad=/../ is not a valid URI prefix at line %S.\n\n# LOCALIZATION NOTE (tooManyDotDotSlashes): the associated cache manifest has\n# a URI containing too many ../ operators. Too many of these operators mean\n# that the file would be below the root of the site, which is not possible.\n# Parameters: %S is the line number where this error occurs.\ntooManyDotDotSlashes=Too many dot dot slash operators (../) at line %S.\n\n# LOCALIZATION NOTE (fallbackUseSpaces): the associated cache manifest has a\n# FALLBACK section containing more or less than the standard two URIs\n# separated by a single space. Parameters: %S is the line number where this\n# error occurs.\nfallbackUseSpaces=Only two URIs separated by spaces are allowed in the FALLBACK section at line %S.\n\n# LOCALIZATION NOTE (fallbackAsterisk2): the associated cache manifest has a\n# FALLBACK section that attempts to use an asterisk (*) as a wildcard. In this\n# section the URI is simply a path prefix. Parameters: %S is the line number\n# where this error occurs.\nfallbackAsterisk2=Asterisk (*) incorrectly used in the FALLBACK section at line %S. URIs in the FALLBACK section simply need to match a prefix of the request URI.\n\n# LOCALIZATION NOTE (settingsBadValue): the associated cache manifest has a\n# SETTINGS section containing something other than the valid \"prefer-online\"\n# or \"fast\". Parameters: %S is the line number where this error occurs.\nsettingsBadValue=The SETTINGS section may only contain a single value, “prefer-online” or “fast” at line %S.\n\n# LOCALIZATION NOTE (invalidSectionName): the associated cache manifest\n# contains an invalid section name. Parameters: %1$S is the section name, %2$S\n# is the line number.\ninvalidSectionName=Invalid section name (%1$S) at line %2$S.\n\n# LOCALIZATION NOTE (entryNotFound): the requested cache entry that does not\n# exist.\nentryNotFound=Entry not found.\n"

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Canvas Debugger\n# which is available from the Web Developer sub-menu -> 'Canvas'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (ToolboxCanvasDebugger.label):\n# This string is displayed in the title of the tab when the Shader Editor is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxCanvasDebugger.label=Canvas\n\n# LOCALIZATION NOTE (ToolboxCanvasDebugger.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxCanvasDebugger.panelLabel=Canvas Panel\n\n# LOCALIZATION NOTE (ToolboxCanvasDebugger.tooltip):\n# This string is displayed in the tooltip of the tab when the Shader Editor is\n# displayed inside the developer tools window.\nToolboxCanvasDebugger.tooltip=Tools to inspect and debug <canvas> contexts\n\n# LOCALIZATION NOTE (noSnapshotsText): The text to display in the snapshots menu\n# when there are no recorded snapshots yet.\nnoSnapshotsText=There are no snapshots yet.\n\n# LOCALIZATION NOTE (snapshotsList.itemLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# identifying a set of function calls of a recorded animation frame.\nsnapshotsList.itemLabel=Snapshot #%S\n\n# LOCALIZATION NOTE (snapshotsList.loadingLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# for an item that has not finished loading.\nsnapshotsList.loadingLabel=Loading…\n\n# LOCALIZATION NOTE (snapshotsList.saveLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# for saving an item to disk.\nsnapshotsList.saveLabel=Save\n\n# LOCALIZATION NOTE (snapshotsList.savingLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# while saving an item to disk.\nsnapshotsList.savingLabel=Saving…\n\n# LOCALIZATION NOTE (snapshotsList.loadedLabel):\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# for an item which was loaded from disk\nsnapshotsList.loadedLabel=Loaded from disk\n\n# LOCALIZATION NOTE (snapshotsList.saveDialogTitle):\n# This string is displayed as a title for saving a snapshot to disk.\nsnapshotsList.saveDialogTitle=Save animation frame snapshot…\n\n# LOCALIZATION NOTE (snapshotsList.saveDialogJSONFilter):\n# This string is displayed as a filter for saving a snapshot to disk.\nsnapshotsList.saveDialogJSONFilter=JSON Files\n\n# LOCALIZATION NOTE (snapshotsList.saveDialogAllFilter):\n# This string is displayed as a filter for saving a snapshot to disk.\nsnapshotsList.saveDialogAllFilter=All Files\n\n# LOCALIZATION NOTE (snapshotsList.drawCallsLabel):\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# as a generic description about how many draw calls were made.\nsnapshotsList.drawCallsLabel=#1 draw;#1 draws\n\n# LOCALIZATION NOTE (snapshotsList.functionCallsLabel):\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This string is displayed in the snapshots list of the Canvas Debugger,\n# as a generic description about how many function calls were made in total.\nsnapshotsList.functionCallsLabel=#1 call;#1 calls\n\n# LOCALIZATION NOTE (recordingTimeoutFailure):\n# This notification alert is displayed when attempting to record a requestAnimationFrame\n# cycle in the Canvas Debugger and no cycles detected. This alerts the user that no\n# loops were found.\nrecordingTimeoutFailure=Canvas Debugger could not find a requestAnimationFrame or setTimeout cycle.\n"

/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the shared React components,\n# so files in `devtools/client/shared/components/*`.\n\n# LOCALIZATION NOTE (frame.unknownSource): When we do not know the source filename of\n# a frame, we use this string instead.\nframe.unknownSource=(unknown)\n\n# LOCALIZATION NOTE (viewsourceindebugger): The label for the tooltip when hovering over\n# a source link that links to the debugger.\n# %S represents the URL to match in the debugger.\nframe.viewsourceindebugger=View source in Debugger → %S\n\n# LOCALIZATION NOTE (notificationBox.closeTooltip): The content of a tooltip that\n# appears when hovering over the close button in a notification box.\nnotificationBox.closeTooltip=Close this message\n"

/***/ },
/* 73 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE : FILE This file contains the Remote Connection strings.\n# The Remote Connection window can reached from the \"connect…\" menuitem\n# in the Web Developer menu.\n\nmainProcess=Main Process\n"

/***/ },
/* 74 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Debugger\n# which is available from the Web Developer sub-menu -> 'Debugger'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (ToolboxDebugger.label):\n# This string is displayed in the title of the tab when the debugger is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxDebugger.label=Debugger\n\n# LOCALIZATION NOTE (ToolboxDebugger.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxDebugger.panelLabel=Debugger Panel\n\n# LOCALIZATION NOTE (ToolboxDebugger.tooltip2):\n# This string is displayed in the tooltip of the tab when the debugger is\n# displayed inside the developer tools window..\n# A keyboard shortcut for JS Debugger will be shown inside brackets.\nToolboxDebugger.tooltip2=JavaScript Debugger (%S)\n\n# LOCALIZATION NOTE (debuggerMenu.commandkey, debuggerMenu.accesskey)\n# Used for the menuitem in the tool menu\ndebuggerMenu.commandkey=S\ndebuggerMenu.accesskey=D\n\n# LOCALIZATION NOTE (collapsePanes): This is the tooltip for the button\n# that collapses the left and right panes in the debugger UI.\ncollapsePanes=Collapse panes\n\n# LOCALIZATION NOTE (expandPanes): This is the tooltip for the button\n# that expands the left and right panes in the debugger UI.\nexpandPanes=Expand panes\n\n# LOCALIZATION NOTE (pauseButtonTooltip): The tooltip that is displayed for the pause\n# button when the debugger is in a running state.\npauseButtonTooltip=Click to pause (%S)\n\n# LOCALIZATION NOTE (pausePendingButtonTooltip): The tooltip that is displayed for\n# the pause button after it's been clicked but before the next JavaScript to run.\npausePendingButtonTooltip=Waiting for next execution\n\n# LOCALIZATION NOTE (resumeButtonTooltip): The label that is displayed on the pause\n# button when the debugger is in a paused state.\nresumeButtonTooltip=Click to resume (%S)\n\n# LOCALIZATION NOTE (startTracingTooltip): The label that is displayed on the trace\n# button when execution tracing is stopped.\nstartTracingTooltip=Click to start tracing\n\n# LOCALIZATION NOTE (stopTracingTooltip): The label that is displayed on the trace\n# button when execution tracing is started.\nstopTracingTooltip=Click to stop tracing\n\n# LOCALIZATION NOTE (stepOverTooltip): The label that is displayed on the\n# button that steps over a function call.\nstepOverTooltip=Step Over (%S)\n\n# LOCALIZATION NOTE (stepInTooltip): The label that is displayed on the\n# button that steps into a function call.\nstepInTooltip=Step In (%S)\n\n# LOCALIZATION NOTE (stepOutTooltip): The label that is displayed on the\n# button that steps out of a function call.\nstepOutTooltip=Step Out (%S)\n\n# LOCALIZATION NOTE (emptyGlobalsText): The text to display in the menulist\n# when there are no chrome globals available.\nnoGlobalsText=No globals\n\n# LOCALIZATION NOTE (noWorkersText): The text to display in the workers list\n# when there are no workers.\nnoWorkersText=This page has no workers.\n\n# LOCALIZATION NOTE (noSourcesText): The text to display in the sources list\n# when there are no sources.\nnoSourcesText=This page has no sources.\n\n# LOCALIZATION NOTE (loadingSourcesText): The text to display in the sources menu\n# when waiting for scripts to load.\nloadingSourcesText=Waiting for sources…\n\n# LOCALIZATION NOTE (noEventListenersText): The text to display in the events tab\n# when there are no events.\nnoEventListenersText=No event listeners to display\n\n# LOCALIZATION NOTE (noStackFramesText): The text to display in the call stack tab\n# when there are no stack frames.\nnoStackFramesText=No stack frames to display\n\n# LOCALIZATION NOTE (noStackFramesText): The text to display in the traces tab\n# when there are no function calls.\nnoFunctionCallsText=No function calls to display\n\n# LOCALIZATION NOTE (tracingNotStartedText): The text to display in the traces tab\n# when when tracing hasn't started yet.\ntracingNotStartedText=Tracing has not started\n\n# LOCALIZATION NOTE (eventCheckboxTooltip): The tooltip text to display when\n# the user hovers over the checkbox used to toggle an event breakpoint.\neventCheckboxTooltip=Toggle breaking on this event\n\n# LOCALIZATION NOTE (eventOnSelector): The text to display in the events tab\n# for every event item, between the event type and event selector.\neventOnSelector=on\n\n# LOCALIZATION NOTE (eventInSource): The text to display in the events tab\n# for every event item, between the event selector and listener's owner source.\neventInSource=in\n\n# LOCALIZATION NOTE (eventNodes): The text to display in the events tab when\n# an event is listened on more than one target node.\neventNodes=%S nodes\n\n# LOCALIZATION NOTE (eventNative): The text to display in the events tab when\n# a listener is added from plugins, thus getting translated to native code.\neventNative=[native code]\n\n# LOCALIZATION NOTE (*Events): The text to display in the events tab for\n# each group of sub-level event entries.\nanimationEvents=Animation\naudioEvents=Audio\nbatteryEvents=Battery\nclipboardEvents=Clipboard\ncompositionEvents=Composition\ndeviceEvents=Device\ndisplayEvents=Display\ndragAndDropEvents=Drag and Drop\ngamepadEvents=Gamepad\nindexedDBEvents=IndexedDB\ninteractionEvents=Interaction\nkeyboardEvents=Keyboard\nmediaEvents=HTML5 Media\nmouseEvents=Mouse\nmutationEvents=Mutation\nnavigationEvents=Navigation\npointerLockEvents=Pointer Lock\nsensorEvents=Sensor\nstorageEvents=Storage\ntimeEvents=Time\ntouchEvents=Touch\notherEvents=Other\n\n# LOCALIZATION NOTE (blackBoxCheckboxTooltip): The tooltip text to display when\n# the user hovers over the checkbox used to toggle black boxing its associated\n# source.\nblackBoxCheckboxTooltip=Toggle black boxing\n\n# LOCALIZATION NOTE (noMatchingStringsText): The text to display in the\n# global search results when there are no matching strings after filtering.\nnoMatchingStringsText=No matches found\n\n# LOCALIZATION NOTE (emptySearchText): This is the text that appears in the\n# filter text box when it is empty and the scripts container is selected.\nemptySearchText=Search scripts (%S)\n\n# LOCALIZATION NOTE (emptyChromeGlobalsFilterText): This is the text that\n# appears in the filter text box when it is empty and the chrome globals\n# container is selected.\nemptyChromeGlobalsFilterText=Filter chrome globals (%S)\n\n# LOCALIZATION NOTE (emptyVariablesFilterText): This is the text that\n# appears in the filter text box for the variables view container.\nemptyVariablesFilterText=Filter variables\n\n# LOCALIZATION NOTE (emptyPropertiesFilterText): This is the text that\n# appears in the filter text box for the editor's variables view bubble.\nemptyPropertiesFilterText=Filter properties\n\n# LOCALIZATION NOTE (searchPanelFilter): This is the text that appears in the\n# filter panel popup for the filter scripts operation.\nsearchPanelFilter=Filter scripts (%S)\n\n# LOCALIZATION NOTE (searchPanelGlobal): This is the text that appears in the\n# filter panel popup for the global search operation.\nsearchPanelGlobal=Search in all files (%S)\n\n# LOCALIZATION NOTE (searchPanelFunction): This is the text that appears in the\n# filter panel popup for the function search operation.\nsearchPanelFunction=Search for function definition (%S)\n\n# LOCALIZATION NOTE (searchPanelToken): This is the text that appears in the\n# filter panel popup for the token search operation.\nsearchPanelToken=Find in this file (%S)\n\n# LOCALIZATION NOTE (searchPanelGoToLine): This is the text that appears in the\n# filter panel popup for the line search operation.\nsearchPanelGoToLine=Go to line (%S)\n\n# LOCALIZATION NOTE (searchPanelVariable): This is the text that appears in the\n# filter panel popup for the variables search operation.\nsearchPanelVariable=Filter variables (%S)\n\n# LOCALIZATION NOTE (breakpointMenuItem): The text for all the elements that\n# are displayed in the breakpoints menu item popup.\nbreakpointMenuItem.setConditional=Configure conditional breakpoint\nbreakpointMenuItem.enableSelf=Enable breakpoint\nbreakpointMenuItem.disableSelf=Disable breakpoint\nbreakpointMenuItem.deleteSelf=Remove breakpoint\nbreakpointMenuItem.enableOthers=Enable others\nbreakpointMenuItem.disableOthers=Disable others\nbreakpointMenuItem.deleteOthers=Remove others\nbreakpointMenuItem.enableAll=Enable all breakpoints\nbreakpointMenuItem.disableAll=Disable all breakpoints\nbreakpointMenuItem.deleteAll=Remove all breakpoints\n\n# LOCALIZATION NOTE (loadingText): The text that is displayed in the script\n# editor when the loading process has started but there is no file to display\n# yet.\nloadingText=Loading\\u2026\n\n# LOCALIZATION NOTE (errorLoadingText2): The text that is displayed in the debugger\n# viewer when there is an error loading a file\nerrorLoadingText2=Error loading this URL: %S\n\n# LOCALIZATION NOTE (addWatchExpressionText): The text that is displayed in the\n# watch expressions list to add a new item.\naddWatchExpressionText=Add watch expression\n\n# LOCALIZATION NOTE (addWatchExpressionButton): The button that is displayed in the\n# variables view popup.\naddWatchExpressionButton=Watch\n\n# LOCALIZATION NOTE (emptyVariablesText): The text that is displayed in the\n# variables pane when there are no variables to display.\nemptyVariablesText=No variables to display\n\n# LOCALIZATION NOTE (scopeLabel): The text that is displayed in the variables\n# pane as a header for each variable scope (e.g. \"Global scope, \"With scope\",\n# etc.).\nscopeLabel=%S scope\n\n# LOCALIZATION NOTE (watchExpressionsScopeLabel): The name of the watch\n# expressions scope. This text is displayed in the variables pane as a header for\n# the watch expressions scope.\nwatchExpressionsScopeLabel=Watch expressions\n\n# LOCALIZATION NOTE (globalScopeLabel): The name of the global scope. This text\n# is added to scopeLabel and displayed in the variables pane as a header for\n# the global scope.\nglobalScopeLabel=Global\n\n# LOCALIZATION NOTE (variablesViewErrorStacktrace): This is the text that is\n# shown before the stack trace in an error.\nvariablesViewErrorStacktrace=Stack trace:\n\n# LOCALIZATION NOTE (variablesViewMoreObjects): the text that is displayed\n# when you have an object preview that does not show all of the elements. At the end of the list\n# you see \"N more...\" in the web console output.\n# This is a semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of remaining items in the object\n# example: 3 more…\nvariablesViewMoreObjects=#1 more…;#1 more…\n\n# LOCALIZATION NOTE (variablesEditableNameTooltip): The text that is displayed\n# in the variables list on an item with an editable name.\nvariablesEditableNameTooltip=Double click to edit\n\n# LOCALIZATION NOTE (variablesEditableValueTooltip): The text that is displayed\n# in the variables list on an item with an editable value.\nvariablesEditableValueTooltip=Click to change value\n\n# LOCALIZATION NOTE (variablesCloseButtonTooltip): The text that is displayed\n# in the variables list on an item which can be removed.\nvariablesCloseButtonTooltip=Click to remove\n\n# LOCALIZATION NOTE (variablesEditButtonTooltip): The text that is displayed\n# in the variables list on a getter or setter which can be edited.\nvariablesEditButtonTooltip=Click to set value\n\n# LOCALIZATION NOTE (variablesEditableValueTooltip): The text that is displayed\n# in a tooltip on the \"open in inspector\" button in the the variables list for a\n# DOMNode item.\nvariablesDomNodeValueTooltip=Click to select the node in the inspector\n\n# LOCALIZATION NOTE (configurable|...|Tooltip): The text that is displayed\n# in the variables list on certain variables or properties as tooltips.\n# Expanations of what these represent can be found at the following links:\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n# https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n# It's probably best to keep these in English.\nconfigurableTooltip=configurable\nenumerableTooltip=enumerable\nwritableTooltip=writable\nfrozenTooltip=frozen\nsealedTooltip=sealed\nextensibleTooltip=extensible\noverriddenTooltip=overridden\nWebIDLTooltip=WebIDL\n\n# LOCALIZATION NOTE (variablesSeparatorLabel): The text that is displayed\n# in the variables list as a separator between the name and value.\nvariablesSeparatorLabel=:\n\n# LOCALIZATION NOTE (watchExpressionsSeparatorLabel2): The text that is displayed\n# in the watch expressions list as a separator between the code and evaluation.\nwatchExpressionsSeparatorLabel2=\\u0020→\n\n# LOCALIZATION NOTE (functionSearchSeparatorLabel): The text that is displayed\n# in the functions search panel as a separator between function's inferred name\n# and its real name (if available).\nfunctionSearchSeparatorLabel=←\n\n# LOCALIZATION NOTE (resumptionOrderPanelTitle): This is the text that appears\n# as a description in the notification panel popup, when multiple debuggers are\n# open in separate tabs and the user tries to resume them in the wrong order.\n# The substitution parameter is the URL of the last paused window that must be\n# resumed first.\nresumptionOrderPanelTitle=There are one or more paused debuggers. Please resume the most-recently paused debugger first at: %S\n\nvariablesViewOptimizedOut=(optimized away)\nvariablesViewUninitialized=(uninitialized)\nvariablesViewMissingArgs=(unavailable)\n\nanonymousSourcesLabel=Anonymous Sources\n\nexperimental=This is an experimental feature"

/***/ },
/* 75 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside Device Emulation developer\n# tools. The correct localization of this file might be to keep it in English,\n# or another language commonly spoken among web developers.  You want to make\n# that choice consistent across the developer tools.  A good criteria is the\n# language in which you'd find the best documentation on web development on the\n# web.\n\n# LOCALIZATION NOTE:\n# These strings are category names in a list of devices that a user can choose\n# to simulate (e.g. \"ZTE Open C\", \"VIA Vixen\", \"720p HD Television\", etc).\ndevice.phones=Phones\ndevice.tablets=Tablets\ndevice.laptops=Laptops\ndevice.televisions=TVs\ndevice.consoles=Gaming consoles\ndevice.watches=Watches\n"

/***/ },
/* 76 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the DOM panel\n# which is available from the Web Developer sub-menu -> 'DOM'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (dom.label):\n# This string is displayed in the title of the tab when the DOM panel is\n# displayed inside the developer tools window and in the Developer Tools Menu.\ndom.label=DOM\n\n# LOCALIZATION NOTE (dom.panelLabel):\n# This is used as the label for the toolbox panel.\ndom.panelLabel=DOM Panel\n\n# LOCALIZATION NOTE (dom.commandkey, dom.accesskey)\n# Used for the menuitem in the tool menu\ndom.commandkey=W\ndom.accesskey=D\n\n# LOCALIZATION NOTE (dom.tooltip):\n# This string is displayed in the tooltip of the tab when the DOM is\n# displayed inside the developer tools window.\n# Keyboard shortcut for DOM panel will be shown inside the brackets.\ndom.tooltip=DOM (%S)\n\n# LOCALIZATION NOTE (dom.filterDOMPanel): A placeholder text used for\n# DOM panel search box.\ndom.filterDOMPanel=Filter DOM Panel\n\n# LOCALIZATION NOTE (dom.refresh): A label for Refresh button in\n# DOM panel toolbar\ndom.refresh=Refresh"

/***/ },
/* 77 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the Eyedropper color tool.\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE  (colorValue.copied): This text is displayed when the user selects a\n# color with the eyedropper and it's copied to the clipboard.\ncolorValue.copied=copied\n"

/***/ },
/* 78 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the CSS Filter Editor Widget\n# which can be found in a tooltip that appears in the Rule View when clicking\n# on a filter swatch displayed next to CSS declarations like 'filter: blur(2px)'.\n\n# LOCALIZATION NOTE (emptyFilterList):\n# This string is displayed when filter's list is empty\n# (no filter specified / all removed)\nemptyFilterList=No filter specified\n\n# LOCALIZATION NOTE (emptyPresetList):\n# This string is displayed when preset's list is empty\nemptyPresetList=You don’t have any saved presets. \\\nYou can store filter presets by choosing a name and saving them. \\\nPresets are quickly accessible and you can re-use them with ease.\n\n# LOCALIZATION NOTE (addUsingList):\n# This string is displayed under [emptyFilterList] when filter's\n# list is empty, guiding user to add a filter using the list below it\naddUsingList=Add a filter using the list below\n\n# LOCALIZATION NOTE (dropShadowPlaceholder):\n# This string is used as a placeholder for drop-shadow's input\n# in the filter list (shown when <input> is empty)\ndropShadowPlaceholder=x y radius color\n\n# LOCALIZATION NOTE (dragHandleTooltipText):\n# This string is used as a tooltip text (shown on mouse hover) on the\n# drag handles of filters which are used to re-order filters\ndragHandleTooltipText=Drag up or down to re-order filter\n\n# LOCALIZATION NOTE (labelDragTooltipText):\n# This string is used as a tooltip text (shown on mouse hover) on the\n# filters' labels which can be dragged left/right to increase/decrease\n# the filter's value (like photoshop)\nlabelDragTooltipText=Drag left or right to decrease or increase the value\n\n# LOCALIZATION NOTE (filterListSelectPlaceholder):\n# This string is used as a preview option in the list of possible filters\n# <select>\nfilterListSelectPlaceholder=Select a Filter\n\n# LOCALIZATION NOTE (addNewFilterButton):\n# This string is displayed on a button used to add new filters\naddNewFilterButton=Add\n\n# LOCALIZATION NOTE (newPresetPlaceholder):\n# This string is used as a placeholder in the list of presets which is used to\n# save a new preset\nnewPresetPlaceholder=Preset Name\n\n# LOCALIZATION NOTE (savePresetButton):\n# This string is displayed on a button used to save a new preset\nsavePresetButton=Save\n\n# LOCALIZATION NOTE(presetsToggleButton):\n# This string is used in a button which toggles the presets list\npresetsToggleButton=Presets\n"

/***/ },
/* 79 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Performance Tools\n# which is available from the Web Developer sub-menu -> 'Performance'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web. These strings\n# are specifically for marker names in the performance tool.\n\n# LOCALIZATION NOTE (graphs.label.average):\n# This string is displayed on graphs when showing an average.\ngraphs.label.average=avg\n\n# LOCALIZATION NOTE (graphs.label.minimum):\n# This string is displayed on graphs when showing a minimum.\ngraphs.label.minimum=min\n\n# LOCALIZATION NOTE (graphs.label.maximum):\n# This string is displayed on graphs when showing a maximum.\ngraphs.label.maximum=max\n"

/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Network Monitor\n# which is available from the Web Developer sub-menu -> 'Network Monitor'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (har.responseBodyNotIncluded): A label used within\n# HAR file explaining that HTTP response bodies are not includes\n# in exported data.\nhar.responseBodyNotIncluded=Response bodies are not included.\n\n# LOCALIZATION NOTE (har.responseBodyNotIncluded): A label used within\n# HAR file explaining that HTTP request bodies are not includes\n# in exported data.\nhar.requestBodyNotIncluded=Request bodies are not included.\n\n"

/***/ },
/* 81 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Inspector\n# which is available from the Web Developer sub-menu -> 'Inspect'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (confirmNavigationAway): Used in the Inspector tool, when\n# the user tries to navigate away from a web page, to confirm the change of\n# page.\nconfirmNavigationAway.message2=If you leave this page, the changes you have made will be lost.\nconfirmNavigationAway.buttonLeave=Leave Page\nconfirmNavigationAway.buttonLeaveAccesskey=L\nconfirmNavigationAway.buttonStay=Stay on Page\nconfirmNavigationAway.buttonStayAccesskey=S\n\nbreadcrumbs.siblings=Siblings\n\n# LOCALIZATION NOTE (debuggerPausedWarning): Used in the Inspector tool, when\n# the user switch to the inspector when the debugger is paused.\ndebuggerPausedWarning.message=Debugger is paused. Some features like mouse selection will not work.\n\n# LOCALIZATION NOTE (nodeMenu.tooltiptext)\n# This menu appears in the Infobar (on top of the highlighted node) once\n# the node is selected.\nnodeMenu.tooltiptext=Node operations\n\n# LOCALIZATION NOTE (inspector.*)\n# Used for the menuitem in the tool menu\ninspector.label=Inspector\ninspector.commandkey=C\ninspector.accesskey=I\n\n# LOCALIZATION NOTE (inspector.panelLabel.*)\n# Labels applied to the panel and views within the panel in the toolbox\ninspector.panelLabel=Inspector Panel\ninspector.panelLabel.markupView=Markup View\n\n# LOCALIZATION NOTE (markupView.more.showing)\n# When there are too many nodes to load at once, we will offer to\n# show all the nodes.\nmarkupView.more.showing=Some nodes were hidden.\n\n# LOCALIZATION NOTE (markupView.more.showAll2): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\nmarkupView.more.showAll2=Show one more node;Show all #1 nodes\n\n# LOCALIZATION NOTE (inspector.tooltip2)\n# Keyboard shortcut for DOM and Style Inspector will be shown inside brackets.\ninspector.tooltip2=DOM and Style Inspector (%S)\n\n#LOCALIZATION NOTE: Used in the image preview tooltip when the image could not be loaded\npreviewTooltip.image.brokenImage=Could not load the image\n\n#LOCALIZATION NOTE: Used in the image preview tooltip when the image could not be loaded\neventsTooltip.openInDebugger=Open in Debugger\n\n# LOCALIZATION NOTE (docsTooltip.visitMDN): Shown in the tooltip that displays\n# help from MDN. This is a link to the complete MDN documentation page.\ndocsTooltip.visitMDN=Visit MDN page\n\n# LOCALIZATION NOTE (docsTooltip.visitMDN): Shown in the docs tooltip when the MDN page\n# could not be loaded (for example, because of a connectivity problem).\ndocsTooltip.loadDocsError=Could not load docs page.\n\n# LOCALIZATION NOTE (inspector.collapsePane): This is the tooltip for the button\n# that collapses the right panel (rules, computed, box-model, etc...) in the\n# inspector UI.\ninspector.collapsePane=Collapse pane\n\n# LOCALIZATION NOTE (inspector.expandPane): This is the tooltip for the button\n# that expands the right panel (rules, computed, box-model, etc...) in the\n# inspector UI.\ninspector.expandPane=Expand pane\n\n# LOCALIZATION NOTE (inspector.searchResultsCount): This is the label that\n# will show up next to the inspector search box. %1$S is the current result\n# index and %2$S is the total number of search results. For example: \"3 of 9\".\n# This won't be visible until the search box is updated in Bug 835896.\ninspector.searchResultsCount2=%1$S of %2$S\n\n# LOCALIZATION NOTE (inspector.searchResultsNone): This is the label that\n# will show up next to the inspector search box when no matches were found\n# for the given string.\n# This won't be visible until the search box is updated in Bug 835896.\ninspector.searchResultsNone=No matches\n\n# LOCALIZATION NOTE (inspector.menu.openUrlInNewTab.label): This is the label of\n# a menu item in the inspector contextual-menu that appears when the user right-\n# clicks on the attribute of a node in the inspector that is a URL, and that\n# allows to open that URL in a new tab.\ninspector.menu.openUrlInNewTab.label=Open Link in New Tab\n\n# LOCALIZATION NOTE (inspector.menu.copyUrlToClipboard.label): This is the label\n# of a menu item in the inspector contextual-menu that appears when the user\n# right-clicks on the attribute of a node in the inspector that is a URL, and\n# that allows to copy that URL in the clipboard.\ninspector.menu.copyUrlToClipboard.label=Copy Link Address\n\n# LOCALIZATION NOTE (inspector.menu.selectElement.label): This is the label of a\n# menu item in the inspector contextual-menu that appears when the user right-\n# clicks on the attribute of a node in the inspector that is the ID of another\n# element in the DOM (like with <label for=\"input-id\">), and that allows to\n# select that element in the inspector.\ninspector.menu.selectElement.label=Select Element #%S\n\n# LOCALIZATION NOTE (inspectorEditAttribute.label): This is the label of a\n# sub-menu \"Attribute\" in the inspector contextual-menu that appears\n# when the user right-clicks on the node in the inspector, and that allows\n# to edit an attribute on this node.\ninspectorEditAttribute.label=Edit Attribute %S\ninspectorEditAttribute.accesskey=E\n\n# LOCALIZATION NOTE (inspectorRemoveAttribute.label): This is the label of a\n# sub-menu \"Attribute\" in the inspector contextual-menu that appears\n# when the user right-clicks on the attribute of a node in the inspector,\n# and that allows to remove this attribute.\ninspectorRemoveAttribute.label=Remove Attribute %S\ninspectorRemoveAttribute.accesskey=R\n\n# LOCALIZATION NOTE (inspector.nodePreview.selectNodeLabel):\n# This string is displayed in a tooltip that is shown when hovering over a DOM\n# node preview (e.g. something like \"div#foo.bar\").\n# DOM node previews can be displayed in places like the animation-inspector, the\n# console or the object inspector.\n# The tooltip invites the user to click on the node in order to select it in the\n# inspector panel.\ninspector.nodePreview.selectNodeLabel=Click to select this node in the Inspector\n\n# LOCALIZATION NOTE (inspector.nodePreview.highlightNodeLabel):\n# This string is displayed in a tooltip that is shown when hovering over a the\n# inspector icon displayed next to a DOM node preview (e.g. next to something\n# like \"div#foo.bar\").\n# DOM node previews can be displayed in places like the animation-inspector, the\n# console or the object inspector.\n# The tooltip invites the user to click on the icon in order to highlight the\n# node in the page.\ninspector.nodePreview.highlightNodeLabel=Click to highlight this node in the page\n\n# LOCALIZATION NOTE (inspectorHTMLEdit.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users edit the\n# (outer) HTML of the current node\ninspectorHTMLEdit.label=Edit As HTML\ninspectorHTMLEdit.accesskey=E\n\n# LOCALIZATION NOTE (inspectorCopyInnerHTML.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users copy the\n# inner HTML of the current node\ninspectorCopyInnerHTML.label=Inner HTML\ninspectorCopyInnerHTML.accesskey=I\n\n# LOCALIZATION NOTE (inspectorCopyOuterHTML.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users copy the\n# outer HTML of the current node\ninspectorCopyOuterHTML.label=Outer HTML\ninspectorCopyOuterHTML.accesskey=O\n\n# LOCALIZATION NOTE (inspectorCopyCSSSelector.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users copy\n# the CSS Selector of the current node\ninspectorCopyCSSSelector.label=CSS Selector\ninspectorCopyCSSSelector.accesskey=S\n\n# LOCALIZATION NOTE (inspectorPasteOuterHTML.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users paste outer\n# HTML in the current node\ninspectorPasteOuterHTML.label=Outer HTML\ninspectorPasteOuterHTML.accesskey=O\n\n# LOCALIZATION NOTE (inspectorPasteInnerHTML.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users paste inner\n# HTML in the current node\ninspectorPasteInnerHTML.label=Inner HTML\ninspectorPasteInnerHTML.accesskey=I\n\n# LOCALIZATION NOTE (inspectorHTMLPasteBefore.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users paste\n# the HTML before the current node\ninspectorHTMLPasteBefore.label=Before\ninspectorHTMLPasteBefore.accesskey=B\n\n# LOCALIZATION NOTE (inspectorHTMLPasteAfter.label): This is the label shown\n# in the inspector contextual-menu for the item that lets users paste\n# the HTML after the current node\ninspectorHTMLPasteAfter.label=After\ninspectorHTMLPasteAfter.accesskey=A\n\n# LOCALIZATION NOTE (inspectorHTMLPasteFirstChild.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users paste\n# the HTML as the first child the current node\ninspectorHTMLPasteFirstChild.label=As First Child\ninspectorHTMLPasteFirstChild.accesskey=F\n\n# LOCALIZATION NOTE (inspectorHTMLPasteLastChild.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users paste\n# the HTML as the last child the current node\ninspectorHTMLPasteLastChild.label=As Last Child\ninspectorHTMLPasteLastChild.accesskey=L\n\n# LOCALIZATION NOTE (inspectorScrollNodeIntoView.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users scroll\n# the current node into view\ninspectorScrollNodeIntoView.label=Scroll Into View\ninspectorScrollNodeIntoView.accesskey=S\n\n# LOCALIZATION NOTE (inspectorHTMLDelete.label): This is the label shown in\n# the inspector contextual-menu for the item that lets users delete the\n# current node\ninspectorHTMLDelete.label=Delete Node\ninspectorHTMLDelete.accesskey=D\n\n# LOCALIZATION NOTE (inspectorAttributesSubmenu.label): This is the label\n# shown in the inspector contextual-menu for the sub-menu of the other\n# attribute items, which allow to:\n# - add new attribute\n# - edit attribute\n# - remove attribute\ninspectorAttributesSubmenu.label=Attributes\ninspectorAttributesSubmenu.accesskey=A\n\n# LOCALIZATION NOTE (inspectorAddAttribute.label): This is the label shown in\n# the inspector contextual-menu for the item that lets users add attribute\n# to current node\ninspectorAddAttribute.label=Add Attribute\ninspectorAddAttribute.accesskey=A\n\n# LOCALIZATION NOTE (inspectorSearchHTML.label3): This is the label that is\n# shown as the placeholder for the markup view search in the inspector.\ninspectorSearchHTML.label3=Search HTML\n\n# LOCALIZATION NOTE (inspectorImageDataUri.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users copy\n# the URL embedding the image data encoded in Base 64 (what we name\n# here Image Data URL). For more information:\n# https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs\ninspectorImageDataUri.label=Image Data-URL\n\n# LOCALIZATION NOTE (inspectorShowDOMProperties.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users see\n# the DOM properties of the current node. When triggered, this item\n# opens the split Console and displays the properties in its side panel.\ninspectorShowDOMProperties.label=Show DOM Properties\n\n# LOCALIZATION NOTE (inspectorUseInConsole.label): This is the label\n# shown in the inspector contextual-menu for the item that outputs a\n# variable for the current node to the console. When triggered,\n# this item opens the split Console.\ninspectorUseInConsole.label=Use in Console\n\n# LOCALIZATION NOTE (inspectorExpandNode.label): This is the label\n# shown in the inspector contextual-menu for recursively expanding\n# mark-up elements\ninspectorExpandNode.label=Expand All\n\n# LOCALIZATION NOTE (inspectorCollapseNode.label): This is the label\n# shown in the inspector contextual-menu for recursively collapsing\n# mark-up elements\ninspectorCollapseNode.label=Collapse\n\n# LOCALIZATION NOTE (inspectorScreenshotNode.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users take\n# a screenshot of the currently selected node.\ninspectorScreenshotNode.label=Screenshot Node\n\n# LOCALIZATION NOTE (inspectorDuplicateNode.label): This is the label\n# shown in the inspector contextual-menu for the item that lets users\n# duplicate the currently selected node.\ninspectorDuplicateNode.label=Duplicate Node\n\n# LOCALIZATION NOTE (inspectorAddNode.label): This is the label shown in\n# the inspector toolbar for the button that lets users add elements to the\n# DOM (as children of the currently selected element).\ninspectorAddNode.label=Create New Node\ninspectorAddNode.accesskey=C\n\n# LOCALIZATION NOTE (inspectorCopyHTMLSubmenu.label): This is the label\n# shown in the inspector contextual-menu for the sub-menu of the other\n# copy items, which allow to:\n# - Copy Inner HTML\n# - Copy Outer HTML\n# - Copy Unique selector\n# - Copy Image data URI\ninspectorCopyHTMLSubmenu.label=Copy\n\n# LOCALIZATION NOTE (inspectorPasteHTMLSubmenu.label): This is the label\n# shown in the inspector contextual-menu for the sub-menu of the other\n# paste items, which allow to:\n# - Paste Inner HTML\n# - Paste Outer HTML\n# - Before\n# - After\n# - As First Child\n# - As Last Child\ninspectorPasteHTMLSubmenu.label=Paste\n\n\n# LOCALIZATION NOTE (inspector.searchHTML.key):\n# Key shortcut used to focus the DOM element search box on top-right corner of\n# the markup view\ninspector.searchHTML.key=CmdOrCtrl+F\n\n# LOCALIZATION NOTE (markupView.hide.key):\n# Key shortcut used to hide the selected node in the markup view.\nmarkupView.hide.key=h\n\n# LOCALIZATION NOTE (markupView.edit.key):\n# Key shortcut used to hide the selected node in the markup view.\nmarkupView.edit.key=F2\n\n# LOCALIZATION NOTE (markupView.scrollInto.key):\n# Key shortcut used to scroll the webpage in order to ensure the selected node\n# is visible\nmarkupView.scrollInto.key=s\n\n# LOCALIZATION NOTE (inspector.sidebar.fontInspectorTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying the list of fonts used in the page.\ninspector.sidebar.fontInspectorTitle=Fonts\n\n# LOCALIZATION NOTE (inspector.sidebar.ruleViewTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying the list of CSS rules used\n# in the page.\ninspector.sidebar.ruleViewTitle=Rules\n\n# LOCALIZATION NOTE (inspector.sidebar.computedViewTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying the list of computed CSS values\n# used in the page.\ninspector.sidebar.computedViewTitle=Computed\n\n# LOCALIZATION NOTE (inspector.sidebar.layoutViewTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying box model of the selected element.\ninspector.sidebar.layoutViewTitle=Box Model\n\n# LOCALIZATION NOTE (inspector.sidebar.animationInspectorTitle):\n# This is the title shown in a tab in the side panel of the Inspector panel\n# that corresponds to the tool displaying animations defined in the page.\ninspector.sidebar.animationInspectorTitle=Animations\n"

/***/ },
/* 82 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used within the JIT tools\n# in the Performance Tools which is available from the Web Developer\n# sub-menu -> 'Performance' The correct localization of this file might\n# be to keep it in English, or another language commonly spoken among\n# web developers. You want to make that choice consistent across the\n# developer tools. A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (jit.title):\n# This string is displayed in the header of the JIT Optimizations view.\njit.title=JIT Optimizations\n\n# LOCALIZATION NOTE (jit.optimizationFailure):\n# This string is displayed in a tooltip when no JIT optimizations were detected.\njit.optimizationFailure=Optimization failed\n\n# LOCALIZATION NOTE (jit.samples):\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This string is displayed for the unit representing the number of times a\n# frame is sampled.\n# \"#1\" represents the number of samples\n# example: 30 samples\njit.samples=#1 sample;#1 samples\n\n# LOCALIZATION NOTE (jit.types):\n# This string is displayed for the group of Ion Types in the optimizations view.\njit.types=Types\n\n# LOCALIZATION NOTE (jit.attempts):\n# This string is displayed for the group of optimization attempts in the optimizations view.\njit.attempts=Attempts\n"

/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used in the JSON View tool\n# that is used to inspect application/json document types loaded\n# in the browser.\n\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE (jsonViewer.tab.JSON, jsonViewer.tab.RawData,\n# jsonViewer.tab.Headers): Label for a panel tab.\njsonViewer.tab.JSON=JSON\njsonViewer.tab.RawData=Raw Data\njsonViewer.tab.Headers=Headers\n\n# LOCALIZATION NOTE (jsonViewer.responseHeaders, jsonViewer.requestHeaders):\n# Label for header groups within the 'Headers' panel.\njsonViewer.responseHeaders=Response Headers\njsonViewer.requestHeaders=Request Headers\n\n# LOCALIZATION NOTE (jsonViewer.Save): Label for save command\njsonViewer.Save=Save\n\n# LOCALIZATION NOTE (jsonViewer.Copy): Label for clipboard copy command\njsonViewer.Copy=Copy\n\n# LOCALIZATION NOTE (jsonViewer.ExpandAll): Label for expanding all nodes\njsonViewer.ExpandAll=Expand All\n\n# LOCALIZATION NOTE (jsonViewer.PrettyPrint): Label for JSON\n# pretty print action button.\njsonViewer.PrettyPrint=Pretty Print\n\n# LOCALIZATION NOTE (jsonViewer.reps.more): Label used in arrays\n# that have more items than displayed.\njsonViewer.reps.more=more…\n\n# LOCALIZATION NOTE (jsonViewer.filterJSON): Label used in search box\n# at the top right cornder of the JSON Viewer.\njsonViewer.filterJSON=Filter JSON\n\n# LOCALIZATION NOTE (jsonViewer.reps.reference): Label used for cycle\n# references in an array.\njsonViewer.reps.reference=Cycle Reference\n"

/***/ },
/* 84 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Performance Tools\n# which is available from the Web Developer sub-menu -> 'Performance'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web. These strings\n# are specifically for marker names in the performance tool.\n\n# LOCALIZATION NOTE (marker.label.*):\n# These strings are displayed in the Performance Tool waterfall, identifying markers.\n# We want to use the same wording as Google Chrome when appropriate.\nmarker.label.styles=Recalculate Style\nmarker.label.reflow=Layout\nmarker.label.paint=Paint\nmarker.label.composite=Composite Layers\nmarker.label.compositeForwardTransaction=Composite Request Sent\nmarker.label.javascript=Function Call\nmarker.label.parseHTML=Parse HTML\nmarker.label.parseXML=Parse XML\nmarker.label.domevent=DOM Event\nmarker.label.consoleTime=Console\nmarker.label.garbageCollection2=Garbage Collection\nmarker.label.garbageCollection.incremental=Incremental GC\nmarker.label.garbageCollection.nonIncremental=Non-incremental GC\nmarker.label.minorGC=Minor GC\nmarker.label.cycleCollection=Cycle Collection\nmarker.label.cycleCollection.forgetSkippable=CC Graph Reduction\nmarker.label.timestamp=Timestamp\nmarker.label.worker=Worker\nmarker.label.messagePort=MessagePort\nmarker.label.unknown=Unknown\n\n# LOCALIZATION NOTE (marker.label.javascript.*):\n# These strings are displayed as JavaScript markers that have special\n# reasons that can be translated.\nmarker.label.javascript.scriptElement=Script Tag\nmarker.label.javascript.promiseCallback=Promise Callback\nmarker.label.javascript.promiseInit=Promise Init\nmarker.label.javascript.workerRunnable=Worker\nmarker.label.javascript.jsURI=JavaScript URI\nmarker.label.javascript.eventHandler=Event Handler\n\n# LOCALIZATION NOTE (marker.field.*):\n# Strings used in the waterfall sidebar as property names.\n\n# General marker fields\nmarker.field.start=Start:\nmarker.field.end=End:\nmarker.field.duration=Duration:\n\n# General \"reason\" for a marker (JavaScript, Garbage Collection)\nmarker.field.causeName=Cause:\n# General \"type\" for a marker (Cycle Collection, Garbage Collection)\nmarker.field.type=Type:\n# General \"label\" for a marker (user defined)\nmarker.field.label=Label:\n\n# Field names for stack values\nmarker.field.stack=Stack:\nmarker.field.startStack=Stack at start:\nmarker.field.endStack=Stack at end:\n\n# %S is the \"Async Cause\" of a marker, and this signifies that the cause\n# was an asynchronous one in a displayed stack.\nmarker.field.asyncStack=(Async: %S)\n\n# For console.time markers\nmarker.field.consoleTimerName=Timer Name:\n\n# For DOM Event markers\nmarker.field.DOMEventType=Event Type:\nmarker.field.DOMEventPhase=Phase:\n\n# Non-incremental cause for a Garbage Collection marker\nmarker.field.nonIncrementalCause=Non-incremental Cause:\n\n# For \"Recalculate Style\" markers\nmarker.field.restyleHint=Restyle Hint:\n\n# The type of operation performed by a Worker.\nmarker.worker.serializeDataOffMainThread=Serialize data in Worker\nmarker.worker.serializeDataOnMainThread=Serialize data on the main thread\nmarker.worker.deserializeDataOffMainThread=Deserialize data in Worker\nmarker.worker.deserializeDataOnMainThread=Deserialize data on the main thread\n\n# The type of operation performed by a MessagePort\nmarker.messagePort.serializeData=Serialize data\nmarker.messagePort.deserializeData=Deserialize data\n\n# Strings used in the waterfall sidebar as values.\nmarker.value.unknownFrame=<unknown location>\nmarker.value.DOMEventTargetPhase=Target\nmarker.value.DOMEventCapturingPhase=Capture\nmarker.value.DOMEventBubblingPhase=Bubbling\n\n# LOCALIZATION NOTE (marker.gcreason.label.*):\n# These strings are used to give a concise but readable description of a GC reason.\nmarker.gcreason.label.API=API Call\nmarker.gcreason.label.EAGER_ALLOC_TRIGGER=Eager Allocation Trigger\nmarker.gcreason.label.DESTROY_RUNTIME=Shutdown\nmarker.gcreason.label.LAST_DITCH=Out of Memory\nmarker.gcreason.label.TOO_MUCH_MALLOC=Too Many Bytes Allocated\nmarker.gcreason.label.ALLOC_TRIGGER=Too Many Allocations\nmarker.gcreason.label.DEBUG_GC=Debug GC\nmarker.gcreason.label.COMPARTMENT_REVIVED=Dead Global Revived\nmarker.gcreason.label.RESET=Finish Incremental Cycle\nmarker.gcreason.label.OUT_OF_NURSERY=Nursery is Full\nmarker.gcreason.label.EVICT_NURSERY=Nursery Eviction\nmarker.gcreason.label.FULL_STORE_BUFFER=Nursery Objects Too Active\nmarker.gcreason.label.SHARED_MEMORY_LIMIT=Large Allocation Failed\nmarker.gcreason.label.PERIODIC_FULL_GC=Periodic Full GC\nmarker.gcreason.label.INCREMENTAL_TOO_SLOW=Allocations Rate Too Fast\nmarker.gcreason.label.COMPONENT_UTILS=Cu.forceGC\nmarker.gcreason.label.MEM_PRESSURE=Low Memory\nmarker.gcreason.label.CC_WAITING=Forced by Cycle Collection\nmarker.gcreason.label.CC_FORCED=Forced by Cycle Collection\nmarker.gcreason.label.LOAD_END=Page Load Finished\nmarker.gcreason.label.PAGE_HIDE=Moved to Background\nmarker.gcreason.label.NSJSCONTEXT_DESTROY=Destroy JS Context\nmarker.gcreason.label.SET_NEW_DOCUMENT=New Document\nmarker.gcreason.label.SET_DOC_SHELL=New Document\nmarker.gcreason.label.DOM_UTILS=API Call\nmarker.gcreason.label.DOM_IPC=IPC\nmarker.gcreason.label.DOM_WORKER=Periodic Worker GC\nmarker.gcreason.label.INTER_SLICE_GC=Periodic Incremental GC Slice\nmarker.gcreason.label.FULL_GC_TIMER=Periodic Full GC\nmarker.gcreason.label.SHUTDOWN_CC=Shutdown\nmarker.gcreason.label.FINISH_LARGE_EVALUATE=Large Eval\nmarker.gcreason.label.DOM_WINDOW_UTILS=User Inactive\nmarker.gcreason.label.USER_INACTIVE=User Inactive\n\n# The name of a nursery collection.\nmarker.nurseryCollection=Nursery Collection\n\n# LOCALIZATION NOTE (marker.gcreason.description.*):\n# These strings are used to give an expanded description of why a GC occurred.\nmarker.gcreason.description.API=There was an API call to force garbage collection.\nmarker.gcreason.description.EAGER_ALLOC_TRIGGER=JavaScript returned to the event loop and there were enough bytes allocated since the last GC that a new GC cycle was triggered.\nmarker.gcreason.description.DESTROY_RUNTIME=Firefox destroyed a JavaScript runtime or context, and this was the final garbage collection before shutting down.\nmarker.gcreason.description.LAST_DITCH=JavaScript attempted to allocate, but there was no memory available. Doing a full compacting garbage collection as an attempt to free up memory for the allocation.\nmarker.gcreason.description.TOO_MUCH_MALLOC=JavaScript allocated too many bytes, and forced a garbage collection.\nmarker.gcreason.description.ALLOC_TRIGGER=JavaScript allocated too many times, and forced a garbage collection.\nmarker.gcreason.description.DEBUG_GC=GC due to Zeal debug settings.\nmarker.gcreason.description.COMPARTMENT_REVIVED=A global object that was thought to be dead at the start of the GC cycle was revived by the end of the GC cycle.\nmarker.gcreason.description.RESET=The active incremental GC cycle was forced to finish immediately.\nmarker.gcreason.description.OUT_OF_NURSERY=JavaScript allocated enough new objects in the nursery that it became full and triggered a minor GC.\nmarker.gcreason.description.EVICT_NURSERY=Work needed to be done on the tenured heap, requiring the nursery to be empty.\nmarker.gcreason.description.FULL_STORE_BUFFER=There were too many properties on tenured objects whose value was an object in the nursery.\nmarker.gcreason.description.SHARED_MEMORY_LIMIT=A large allocation was requested, but there was not enough memory.\nmarker.gcreason.description.PERIODIC_FULL_GC=JavaScript returned to the event loop, and it has been a relatively long time since Firefox performed a garbage collection.\nmarker.gcreason.description.INCREMENTAL_TOO_SLOW=A full, non-incremental garbage collection was triggered because there was a faster rate of allocations than the existing incremental garbage collection cycle could keep up with.\nmarker.gcreason.description.COMPONENT_UTILS=Components.utils.forceGC() was called to force a garbage collection.\nmarker.gcreason.description.MEM_PRESSURE=There was very low memory available.\nmarker.gcreason.description.CC_WAITING=The cycle collector required a garbage collection.\nmarker.gcreason.description.CC_FORCED=The cycle collector required a garbage collection.\nmarker.gcreason.description.LOAD_END=The document finished loading.\nmarker.gcreason.description.PAGE_HIDE=The tab or window was moved to the background.\nmarker.gcreason.description.NSJSCONTEXT_DESTROY=Firefox destroyed a JavaScript runtime or context, and this was the final garbage collection before shutting down.\nmarker.gcreason.description.SET_NEW_DOCUMENT=The page has been navigated to a new document.\nmarker.gcreason.description.SET_DOC_SHELL=The page has been navigated to a new document.\nmarker.gcreason.description.DOM_UTILS=There was an API call to force garbage collection.\nmarker.gcreason.description.DOM_IPC=Received an inter-process message that requested a garbage collection.\nmarker.gcreason.description.DOM_WORKER=The worker was idle for a relatively long time.\nmarker.gcreason.description.INTER_SLICE_GC=There has been a relatively long time since the last incremental GC slice.\nmarker.gcreason.description.FULL_GC_TIMER=JavaScript returned to the event loop, and it has been a relatively long time since we performed a garbage collection.\nmarker.gcreason.description.SHUTDOWN_CC=Firefox destroyed a JavaScript runtime or context, and this was the final garbage collection before shutting down.\nmarker.gcreason.description.FINISH_LARGE_EVALUATE=Firefox finished evaluating a large script, and performed a GC because the script will never be run again.\nmarker.gcreason.description.DOM_WINDOW_UTILS=The user was inactive for a long time. Took the opportunity to perform GC when it was unlikely to be noticed.\nmarker.gcreason.description.USER_INACTIVE=The user was inactive for a long time. Firefox took the opportunity to perform GC when it was unlikely to be noticed.\n"

/***/ },
/* 85 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Memory Tools\n# which is available from the Web Developer sub-menu -> 'Memory'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (memory.label): This string is displayed in the title of the\n# tab when the memory tool is displayed inside the developer tools window and in\n# the Developer Tools Menu.\nmemory.label=Memory\n\n# LOCALIZATION NOTE (memory.panelLabel): This is used as the label for the\n# toolbox panel.\nmemory.panelLabel=Memory Panel\n\n# LOCALIZATION NOTE (memory.tooltip): This string is displayed in the tooltip of\n# the tab when the memory tool is displayed inside the developer tools window.\nmemory.tooltip=Memory\n\n# LOCALIZATION NOTE (snapshot.io.save): The label for the link that saves a\n# snapshot to disk.\nsnapshot.io.save=Save\n\n# LOCALIZATION NOTE (snapshot.io.delete): The label for the link that deletes\n# a snapshot\nsnapshot.io.delete=Delete\n\n# LOCALIZATION NOTE (snapshot.io.save.window): The title for the window\n# displayed when saving a snapshot to disk.\nsnapshot.io.save.window=Save Snapshot\n\n# LOCALIZATION NOTE (snapshot.io.import.window): The title for the window\n# displayed when importing a snapshot form disk.\nsnapshot.io.import.window=Import Snapshot\n\n# LOCALIZATION NOTE (snapshot.io.filter): The title for the filter used to\n# filter file types (*.fxsnapshot)\nsnapshot.io.filter=Firefox Snapshots\n\n# LOCALIZATION NOTE (aggregate.mb): The label annotating the number of bytes (in\n# megabytes) in a snapshot. %S represents the value, rounded to 2 decimal\n# points.\naggregate.mb=%S MB\n\n# LOCALIZATION NOTE (snapshot-title.loading): The title for a snapshot before\n# it has a creation time to display.\nsnapshot-title.loading=Processing…\n\n# LOCALIZATION NOTE (checkbox.recordAllocationStacks): The label describing the\n# boolean checkbox whether or not to record call stacks.\ncheckbox.recordAllocationStacks=Record call stacks\n\n# LOCALIZATION NOTE (checkbox.recordAllocationStacks.tooltip): The tooltip for\n# the label describing the boolean checkbox whether or not to record call\n# stacks.\ncheckbox.recordAllocationStacks.tooltip=Toggle the recording of the call stack of when an object was allocated. Subsequent snapshots will be able to group and label objects by call stacks, but only with those objects created after toggling this option. Recording call stacks has a performance overhead.\n\n# LOCALIZATION NOTE (toolbar.displayBy): The label describing the select menu\n# options of the display options.\ntoolbar.displayBy=Group by:\n\n# LOCALIZATION NOTE (toolbar.displayBy.tooltip): The tooltip for the label\n# describing the select menu options of the display options.\ntoolbar.displayBy.tooltip=Change how objects are grouped\n\n# LOCALIZATION NOTE (toolbar.pop-view): The text in the button to go back to the\n# previous view.\ntoolbar.pop-view=←\n\n# LOCALIZATION NOTE (toolbar.pop-view.label): The text for the label for the\n# button to go back to the previous view.\ntoolbar.pop-view.label=Go back to aggregates\n\n# LOCALIZATION NOTE (toolbar.viewing-individuals): The text letting the user\n# know that they are viewing individual nodes from a census group.\ntoolbar.viewing-individuals=⁂ Viewing individuals in group\n\n# LOCALIZATION NOTE (censusDisplays.coarseType.tooltip): The tooltip for the\n# \"coarse type\" display option.\ncensusDisplays.coarseType.tooltip=Group items by their type\n\n# LOCALIZATION NOTE (censusDisplays.allocationStack.tooltip): The tooltip for\n# the \"call stack\" display option.\ncensusDisplays.allocationStack.tooltip=Group items by the JavaScript stack recorded when the object was allocated\n\n# LOCALIZATION NOTE (censusDisplays.invertedAllocationStack.tooltip): The\n# tooltip for the \"inverted call stack\" display option.\ncensusDisplays.invertedAllocationStack.tooltip=Group items by the inverted JavaScript call stack recorded when the object was created\n\n# LOCALIZATION NOTE (censusDisplays.treeMap.tooltip): The tooltip for the\n# \"tree map\" display option.\ncensusDisplays.treeMap.tooltip=Visualize memory usage: larger blocks account for a larger percent of memory usage\n\n# LOCALIZATION NOTE (censusDisplays.objectClass.tooltip): The tooltip for the\n# \"object class\" display option.\ncensusDisplays.objectClass.tooltip=Group items by their JavaScript Object [[class]] name\n\n# LOCALIZATION NOTE (censusDisplays.internalType.tooltip): The tooltip for the\n# \"internal type\" display option.\ncensusDisplays.internalType.tooltip=Group items by their internal C++ type\n\n# LOCALIZATION NOTE (toolbar.labelBy): The label describing the select menu\n# options of the label options.\ntoolbar.labelBy=Label by:\n\n# LOCALIZATION NOTE (toolbar.labelBy): The tooltip for the label describing the\n# select menu options of the label options.\ntoolbar.labelBy.tooltip=Change how objects are labeled\n\n# LOCALIZATION NOTE (dominatorTreeDisplays.coarseType.tooltip): The tooltip for\n# the \"coarse type\" dominator tree display option.\ndominatorTreeDisplays.coarseType.tooltip=Label objects by the broad categories they fit in\n\n# LOCALIZATION NOTE (dominatorTreeDisplays.allocationStack.tooltip): The\n# tooltip for the \"call stack\" dominator tree display option.\ndominatorTreeDisplays.allocationStack.tooltip=Label objects by the JavaScript stack recorded when it was allocated\n\n# LOCALIZATION NOTE (dominatorTreeDisplays.internalType.tooltip): The\n# tooltip for the \"internal type\" dominator tree display option.\ndominatorTreeDisplays.internalType.tooltip=Label objects by their internal C++ type name\n\n# LOCALIZATION NOTE (treeMapDisplays.coarseType.tooltip): The tooltip for\n# the \"coarse type\" tree map display option.\ntreeMapDisplays.coarseType.tooltip=Label objects by the broad categories they fit in\n\n# LOCALIZATION NOTE (toolbar.view): The label for the view selector in the\n# toolbar.\ntoolbar.view=View:\n\n# LOCALIZATION NOTE (toolbar.view.tooltip): The tooltip for the label for the\n# view selector in the toolbar.\ntoolbar.view.tooltip=Change the view of the snapshot\n\n# LOCALIZATION NOTE (toolbar.view.census): The label for the census view option\n# in the toolbar.\ntoolbar.view.census=Aggregate\n\n# LOCALIZATION NOTE (toolbar.view.census.tooltip): The tooltip for the label for\n# the census view option in the toolbar.\ntoolbar.view.census.tooltip=View a summary of the snapshot’s contents by aggregating objects into groups\n\n# LOCALIZATION NOTE (toolbar.view.dominators): The label for the dominators view\n# option in the toolbar.\ntoolbar.view.dominators=Dominators\n\n# LOCALIZATION NOTE (toolbar.view.dominators.tooltip): The tooltip for the label\n# for the dominators view option in the toolbar.\ntoolbar.view.dominators.tooltip=View the dominator tree and surface the largest structures in the snapshot\n\n# LOCALIZATION NOTE (toolbar.view.treemap): The label for the tree map option\n# in the toolbar.\ntoolbar.view.treemap=Tree Map\n\n# LOCALIZATION NOTE (toolbar.view.treemap.tooltip): The tooltip for the label for\n# the tree map view option in the toolbar.\ntoolbar.view.treemap.tooltip=Visualize memory usage: larger blocks account for a larger percent of memory usage\n\n# LOCALIZATION NOTE (take-snapshot): The label describing the button that\n# initiates taking a snapshot, either as the main label, or a tooltip.\ntake-snapshot=Take snapshot\n\n# LOCALIZATION NOTE (import-snapshot): The label describing the button that\n# initiates importing a snapshot.\nimport-snapshot=Import…\n\n# LOCALIZATION NOTE (clear-snapshots.tooltip): The tooltip for the button that\n# deletes existing snapshot.\nclear-snapshots.tooltip=Delete all snapshots\n\n# LOCALIZATION NOTE (diff-snapshots.tooltip): The tooltip for the button that\n# initiates selecting two snapshots to diff with each other.\ndiff-snapshots.tooltip=Compare snapshots\n\n# LOCALIZATION NOTE (filter.placeholder): The placeholder text used for the\n# memory tool's filter search box.\nfilter.placeholder=Filter\n\n# LOCALIZATION NOTE (filter.tooltip): The tooltip text used for the memory\n# tool's filter search box.\nfilter.tooltip=Filter the contents of the snapshot\n\n# LOCALIZATION NOTE (tree-item.view-individuals.tooltip): The tooltip for the\n# button to view individuals in this group.\ntree-item.view-individuals.tooltip=View individual nodes in this group and their retaining paths\n\n# LOCALIZATION NOTE (tree-item.load-more): The label for the links to fetch the\n# lazily loaded sub trees in the dominator tree view.\ntree-item.load-more=Load more…\n\n# LOCALIZATION NOTE (tree-item.rootlist): The label for the root of the\n# dominator tree.\ntree-item.rootlist=GC Roots\n\n# LOCALIZATION NOTE (tree-item.nostack): The label describing the row in the heap tree\n# that represents a row broken down by call stack when no stack was available.\ntree-item.nostack=(no stack available)\n\n# LOCALIZATION NOTE (tree-item.nofilename): The label describing the row in the\n# heap tree that represents a row broken down by filename when no filename was\n# available.\ntree-item.nofilename=(no filename available)\n\n# LOCALIZATION NOTE (tree-item.root): The label describing the row in the heap tree\n# that represents the root of the tree when inverted.\ntree-item.root=(root)\n\n# LOCALIZATION NOTE (tree-item.percent2): A percent of bytes or count displayed in the tree view.\n# there are two \"%\" after %S to escape and display \"%\"\ntree-item.percent2=%S%%\n\n# LOCALIZATION NOTE (diffing.baseline): The name of the baseline snapshot in a\n# diffing comparison.\ndiffing.baseline=Baseline\n\n# LOCALIZATION NOTE (diffing.comparison): The name of the snapshot being\n# compared to the baseline in a diffing comparison.\ndiffing.comparison=Comparison\n\n# LOCALIZATION NOTE (diffing.prompt.selectBaseline): The prompt to select the\n# first snapshot when doing a diffing comparison.\ndiffing.prompt.selectBaseline=Select the baseline snapshot\n\n# LOCALIZATION NOTE (diffing.prompt.selectComparison): The prompt to select the\n# second snapshot when doing a diffing comparison.\ndiffing.prompt.selectComparison=Select the snapshot to compare to the baseline\n\n# LOCALIZATION NOTE (diffing.state.error): The label describing the diffing\n# state ERROR, used in the snapshot list when an error occurs while diffing two\n# snapshots.\ndiffing.state.error=Error\n\n# LOCALIZATION NOTE (diffing.state.error.full): The text describing the diffing\n# state ERROR, used in the main view when an error occurs while diffing two\n# snapshots.\ndiffing.state.error.full=There was an error while comparing snapshots.\n\n# LOCALIZATION NOTE (diffing.state.taking-diff): The label describing the diffin\n# state TAKING_DIFF, used in the snapshots list when computing the difference\n# between two snapshots.\ndiffing.state.taking-diff=Computing difference…\n\n# LOCALIZATION NOTE (diffing.state.taking-diff.full): The label describing the\n# diffing state TAKING_DIFF, used in the main view when computing the difference\n# between two snapshots.\ndiffing.state.taking-diff.full=Computing difference…\n\n# LOCALIZATION NOTE (diffing.state.selecting): The label describing the diffing\n# state SELECTING.\ndiffing.state.selecting=Select two snapshots to compare\n\n# LOCALIZATION NOTE (diffing.state.selecting.full): The label describing the\n# diffing state SELECTING, used in the main view when selecting snapshots to\n# diff.\ndiffing.state.selecting.full=Select two snapshots to compare\n\n# LOCALIZATION NOTE (dominatorTree.state.computing): The label describing the\n# dominator tree state COMPUTING.\ndominatorTree.state.computing=Generating dominators report…\n\n# LOCALIZATION NOTE (dominatorTree.state.computing): The label describing the\n# dominator tree state COMPUTING, used in the dominator tree view.\ndominatorTree.state.computing.full=Generating dominators report…\n\n# LOCALIZATION NOTE (dominatorTree.state.fetching): The label describing the\n# dominator tree state FETCHING.\ndominatorTree.state.fetching=Computing sizes…\n\n# LOCALIZATION NOTE (dominatorTree.state.fetching): The label describing the\n# dominator tree state FETCHING, used in the dominator tree view.\ndominatorTree.state.fetching.full=Computing dominator’s retained sizes…\n\n# LOCALIZATION NOTE (dominatorTree.state.incrementalFetching): The label\n# describing the dominator tree state INCREMENTAL_FETCHING.\ndominatorTree.state.incrementalFetching=Fetching…\n\n# LOCALIZATION NOTE (dominatorTree.state.incrementalFetching): The label describing the\n# dominator tree state INCREMENTAL_FETCHING, used in the dominator tree view.\ndominatorTree.state.incrementalFetching.full=Fetching more…\n\n# LOCALIZATION NOTE (dominatorTree.state.error): The label describing the\n# dominator tree state ERROR.\ndominatorTree.state.error=Error\n\n# LOCALIZATION NOTE (dominatorTree.state.error): The label describing the\n# dominator tree state ERROR, used in the dominator tree view.\ndominatorTree.state.error.full=There was an error while processing the dominator tree\n\n# LOCALIZATION NOTE (snapshot.state.saving.full): The label describing the\n# snapshot state SAVING, used in the main heap view.\nsnapshot.state.saving.full=Saving snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.importing.full): The label describing the\n# snapshot state IMPORTING, used in the main heap view.\nsnapshot.state.importing.full=Importing…\n\n# LOCALIZATION NOTE (snapshot.state.reading.full): The label describing the\n# snapshot state READING, and SAVED, due to these states being combined\n# visually, used in the main heap view.\nsnapshot.state.reading.full=Reading snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.saving-census.full): The label describing\n# the snapshot state SAVING, used in the main heap view.\nsnapshot.state.saving-census.full=Generating aggregate report…\n\n# LOCALIZATION NOTE (snapshot.state.saving-tree-map.full): The label describing\n# the snapshot state SAVING, used in the main heap view.\nsnapshot.state.saving-tree-map.full=Saving tree map…\n\n# LOCALIZATION NOTE (snapshot.state.error.full): The label describing the\n# snapshot state ERROR, used in the main heap view.\nsnapshot.state.error.full=There was an error processing this snapshot.\n\n# LOCALIZATION NOTE (individuals.state.error): The short message displayed when\n# there is an error fetching individuals from a group.\nindividuals.state.error=Error\n\n# LOCALIZATION NOTE (individuals.state.error.full): The longer message displayed\n# when there is an error fetching individuals from a group.\nindividuals.state.error.full=There was an error while fetching individuals in the group\n\n# LOCALIZATION NOTE (individuals.state.fetching): The short message displayed\n# while fetching individuals.\nindividuals.state.fetching=Fetching…\n\n# LOCALIZATION NOTE (individuals.state.fetching.full): The longer message\n# displayed while fetching individuals.\nindividuals.state.fetching.full=Fetching individuals in group…\n\n# LOCALIZATION NOTE (individuals.field.node): The header label for an individual\n# node.\nindividuals.field.node=Node\n\n# LOCALIZATION NOTE (individuals.field.node.tooltip): The tooltip for the header\n# label for an individual node.\nindividuals.field.node.tooltip=The individual node in the snapshot\n\n# LOCALIZATION NOTE (snapshot.state.saving): The label describing the snapshot\n# state SAVING, used in the snapshot list view\nsnapshot.state.saving=Saving snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.importing): The label describing the\n# snapshot state IMPORTING, used in the snapshot list view\nsnapshot.state.importing=Importing snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.reading): The label describing the snapshot\n# state READING, and SAVED, due to these states being combined visually, used in\n# the snapshot list view.\nsnapshot.state.reading=Reading snapshot…\n\n# LOCALIZATION NOTE (snapshot.state.saving-census): The label describing the\n# snapshot state SAVING, used in snapshot list view.\nsnapshot.state.saving-census=Saving report…\n\n# LOCALIZATION NOTE (snapshot.state.saving-census): The label describing the\n# snapshot state SAVING, used in snapshot list view.\nsnapshot.state.saving-tree-map=Saving tree map…\n\n# LOCALIZATION NOTE (snapshot.state.error): The label describing the snapshot\n# state ERROR, used in the snapshot list view.\nsnapshot.state.error=Error\n\n# LOCALIZATION NOTE (heapview.no-difference): Message displayed when there is no\n# difference between two snapshots.\nheapview.no-difference=No difference between the baseline and comparison.\n\n# LOCALIZATION NOTE (heapview.none-match): Message displayed when there are no\n# matches when filtering.\nheapview.none-match=No matches.\n\n# LOCALIZATION NOTE (heapview.none-match): Message displayed when there report\n# is empty.\nheapview.empty=Empty.\n\n# LOCALIZATION NOTE (heapview.noAllocationStacks): The message displayed to\n# users when selecting a display by \"call stack\" but no call stacks\n# were recorded in the heap snapshot.\nheapview.noAllocationStacks=No call stacks found. Record call stacks before taking a snapshot.\n\n# LOCALIZATION NOTE (heapview.field.retainedSize): The name of the column in the\n# dominator tree view for retained byte sizes.\nheapview.field.retainedSize=Retained Size (Bytes)\n\n# LOCALIZATION NOTE (heapview.field.retainedSize.tooltip): The tooltip for the\n# column header in the dominator tree view for retained byte sizes.\nheapview.field.retainedSize.tooltip=The sum of the size of the object itself, and the sizes of all the other objects kept alive by it\n\n# LOCALIZATION NOTE (heapview.field.shallowSize): The name of the column in the\n# dominator tree view for shallow byte sizes.\nheapview.field.shallowSize=Shallow Size (Bytes)\n\n# LOCALIZATION NOTE (heapview.field.shallowSize.tooltip): The tooltip for the\n# column header in the dominator tree view for shallow byte sizes.\nheapview.field.shallowSize.tooltip=The size of the object itself\n\n# LOCALIZATION NOTE (dominatortree.field.label): The name of the column in the\n# dominator tree for an object's label.\ndominatortree.field.label=Dominator\n\n# LOCALIZATION NOTE (dominatortree.field.label.tooltip): The tooltip for the column\n# header in the dominator tree view for an object's label.\ndominatortree.field.label.tooltip=The label for an object in memory\n\n# LOCALIZATION NOTE (heapview.field.bytes): The name of the column in the heap\n# view for bytes.\nheapview.field.bytes=Bytes\n\n# LOCALIZATION NOTE (heapview.field.bytes.tooltip): The tooltip for the column\n# header in the heap view for bytes.\nheapview.field.bytes.tooltip=The number of bytes taken up by this group, excluding subgroups\n\n# LOCALIZATION NOTE (heapview.field.count): The name of the column in the heap\n# view for count.\nheapview.field.count=Count\n\n# LOCALIZATION NOTE (heapview.field.count.tooltip): The tooltip for the column\n# header in the heap view for count.\nheapview.field.count.tooltip=The number of reachable objects in this group, excluding subgroups\n\n# LOCALIZATION NOTE (heapview.field.totalbytes): The name of the column in the\n# heap view for total bytes.\nheapview.field.totalbytes=Total Bytes\n\n# LOCALIZATION NOTE (heapview.field.totalbytes.tooltip): The tooltip for the\n# column header in the heap view for total bytes.\nheapview.field.totalbytes.tooltip=The number of bytes taken up by this group, including subgroups\n\n# LOCALIZATION NOTE (heapview.field.totalcount): The name of the column in the\n# heap view for total count.\nheapview.field.totalcount=Total Count\n\n# LOCALIZATION NOTE (heapview.field.totalcount.tooltip): The tooltip for the\n# column header in the heap view for total count.\nheapview.field.totalcount.tooltip=The number of reachable objects in this group, including subgroups\n\n# LOCALIZATION NOTE (heapview.field.name): The name of the column in the heap\n# view for name.\nheapview.field.name=Group\n\n# LOCALIZATION NOTE (heapview.field.name.tooltip): The tooltip for the column\n# header in the heap view for name.\nheapview.field.name.tooltip=The name of this group\n\n# LOCALIZATION NOTE (shortest-paths.header): The header label for the shortest\n# paths pane.\nshortest-paths.header=Retaining Paths (from Garbage Collector Roots)\n\n# LOCALIZATION NOTE (shortest-paths.select-node): The message displayed in the\n# shortest paths pane when a node is not yet selected.\nshortest-paths.select-node=Select an item to view its retaining paths\n\n# LOCALIZATION NOTE (tree-map.node-count): The label for the count value of a\n# node in the tree map\ntree-map.node-count=count\n"

/***/ },
/* 86 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ndevToolsCmd.key = VK_F12\ndevToolsCmd.keytext = F12\n\ndevtoolsServiceWorkers.label = Service Workers\ndevtoolsServiceWorkers.accesskey = k\n\ndevtoolsConnect.label = Connect…\ndevtoolsConnect.accesskey = C\n\nbrowserConsoleCmd.label = Browser Console\nbrowserConsoleCmd.accesskey = B\nbrowserConsoleCmd.key = j\n\nresponsiveDesignMode.label = Responsive Design Mode\nresponsiveDesignMode.accesskey = R\nresponsiveDesignMode.key = M\n\neyedropper.label = Eyedropper\neyedropper.accesskey = Y\n\n# LOCALIZATION NOTE (scratchpad.label): This menu item label appears\n# in the Tools menu. See bug 653093.\n# The Scratchpad is intended to provide a simple text editor for creating\n# and evaluating bits of JavaScript code for the purposes of function\n# prototyping, experimentation and convenient scripting.\n#\n# It's quite possible that you won't have a good analogue for the word\n# \"Scratchpad\" in your locale. You should feel free to find a close\n# approximation to it or choose a word (or words) that means\n# \"simple discardable text editor\".\nscratchpad.label = Scratchpad\nscratchpad.accesskey = s\nscratchpad.key = VK_F4\nscratchpad.keytext = F4\n\n# LOCALIZATION NOTE (browserToolboxMenu.label): This is the label for the\n# application menu item that opens the browser toolbox UI in the Tools menu.\nbrowserToolboxMenu.label = Browser Toolbox\nbrowserToolboxMenu.accesskey = e\nbrowserToolboxMenu.key = i\n\n# LOCALIZATION NOTE (browserContentToolboxMenu.label): This is the label for the\n# application menu item that opens the browser content toolbox UI in the Tools menu.\n# This toolbox allows to debug the chrome of the content process in multiprocess builds.\nbrowserContentToolboxMenu.label = Browser Content Toolbox\nbrowserContentToolboxMenu.accesskey = x\n\ndevToolbarMenu.label = Developer Toolbar\ndevToolbarMenu.accesskey = v\ndevToolbarMenu.key = VK_F2\ndevToolbarMenu.keytext = F2\n\nwebide.label = WebIDE\nwebide.accesskey = W\nwebide.key = VK_F8\nwebide.keytext = F8\n\ndevToolboxMenuItem.label = Toggle Tools\ndevToolboxMenuItem.accesskey = T\ndevToolboxMenuItem.key = I\n\ngetMoreDevtoolsCmd.label = Get More Tools\ngetMoreDevtoolsCmd.accesskey = M\n"

/***/ },
/* 87 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Network Monitor\n# which is available from the Web Developer sub-menu -> 'Network Monitor'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (netmonitor.label):\n# This string is displayed in the title of the tab when the Network Monitor is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nnetmonitor.label=Network\n\n# LOCALIZATION NOTE (netmonitor.panelLabel):\n# This is used as the label for the toolbox panel.\nnetmonitor.panelLabel=Network Panel\n\n# LOCALIZATION NOTE (netmonitor.commandkey, netmonitor.accesskey)\n# Used for the menuitem in the tool menu\nnetmonitor.commandkey=Q\nnetmonitor.accesskey=N\n\n# LOCALIZATION NOTE (netmonitor.tooltip2):\n# This string is displayed in the tooltip of the tab when the Network Monitor is\n# displayed inside the developer tools window.\n# Keyboard shortcut for Network Monitor will be shown inside the brackets.\nnetmonitor.tooltip2=Network Monitor (%S)\n\n# LOCALIZATION NOTE (netmonitor.security.state.secure)\n# This string is used as an tooltip for request that was performed over secure\n# channel i.e. the connection was encrypted.\nnetmonitor.security.state.secure=The connection used to fetch this resource was secure.\n\n# LOCALIZATION NOTE (netmonitor.security.state.insecure)\n# This string is used as an tooltip for request that was performed over insecure\n# channel i.e. the connection was not https\nnetmonitor.security.state.insecure=The connection used to fetch this resource was not secure.\n\n# LOCALIZATION NOTE (netmonitor.security.state.broken)\n# This string is used as an tooltip for request that failed due to security\n# issues.\nnetmonitor.security.state.broken=A security error prevented the resource from being loaded.\n\n# LOCALIZATION NOTE (netmonitor.security.state.weak)\n# This string is used as an tooltip for request that had minor security issues\nnetmonitor.security.state.weak=This resource was transferred over a connection that used weak encryption.\n\n# LOCALIZATION NOTE (netmonitor.security.enabled):\n# This string is used to indicate that a specific security feature is used by\n# a connection in the security details tab.\n# For example: \"HTTP Strict Transport Security: Enabled\"\nnetmonitor.security.enabled=Enabled\n\n# LOCALIZATION NOTE (netmonitor.security.disabled):\n# This string is used to indicate that a specific security feature is not used by\n# a connection in the security details tab.\n# For example: \"HTTP Strict Transport Security: Disabled\"\nnetmonitor.security.disabled=Disabled\n\n# LOCALIZATION NOTE (netmonitor.security.hostHeader):\n# This string is used as a header for section containing security information\n# related to the remote host. %S is replaced with the domain name of the remote\n# host. For example: Host example.com\nnetmonitor.security.hostHeader=Host %S:\n\n# LOCALIZATION NOTE (netmonitor.security.notAvailable):\n# This string is used to indicate that a certain piece of information is not\n# available to be displayed. For example a certificate that has no organization\n# defined:\n#   Organization: <Not Available>\nnetmonitor.security.notAvailable=<Not Available>\n\n# LOCALIZATION NOTE (collapseDetailsPane): This is the tooltip for the button\n# that collapses the network details pane in the UI.\ncollapseDetailsPane=Hide request details\n\n# LOCALIZATION NOTE (expandDetailsPane): This is the tooltip for the button\n# that expands the network details pane in the UI.\nexpandDetailsPane=Show request details\n\n# LOCALIZATION NOTE (headersEmptyText): This is the text displayed in the\n# headers tab of the network details pane when there are no headers available.\nheadersEmptyText=No headers for this request\n\n# LOCALIZATION NOTE (headersFilterText): This is the text displayed in the\n# headers tab of the network details pane for the filtering input.\nheadersFilterText=Filter headers\n\n# LOCALIZATION NOTE (cookiesEmptyText): This is the text displayed in the\n# cookies tab of the network details pane when there are no cookies available.\ncookiesEmptyText=No cookies for this request\n\n# LOCALIZATION NOTE (cookiesFilterText): This is the text displayed in the\n# cookies tab of the network details pane for the filtering input.\ncookiesFilterText=Filter cookies\n\n# LOCALIZATION NOTE (paramsEmptyText): This is the text displayed in the\n# params tab of the network details pane when there are no params available.\nparamsEmptyText=No parameters for this request\n\n# LOCALIZATION NOTE (paramsFilterText): This is the text displayed in the\n# params tab of the network details pane for the filtering input.\nparamsFilterText=Filter request parameters\n\n# LOCALIZATION NOTE (paramsQueryString): This is the label displayed\n# in the network details params tab identifying the query string.\nparamsQueryString=Query string\n\n# LOCALIZATION NOTE (paramsFormData): This is the label displayed\n# in the network details params tab identifying the form data.\nparamsFormData=Form data\n\n# LOCALIZATION NOTE (paramsPostPayload): This is the label displayed\n# in the network details params tab identifying the request payload.\nparamsPostPayload=Request payload\n\n# LOCALIZATION NOTE (requestHeaders): This is the label displayed\n# in the network details headers tab identifying the request headers.\nrequestHeaders=Request headers\n\n# LOCALIZATION NOTE (requestHeadersFromUpload): This is the label displayed\n# in the network details headers tab identifying the request headers from\n# the upload stream of a POST request's body.\nrequestHeadersFromUpload=Request headers from upload stream\n\n# LOCALIZATION NOTE (responseHeaders): This is the label displayed\n# in the network details headers tab identifying the response headers.\nresponseHeaders=Response headers\n\n# LOCALIZATION NOTE (requestCookies): This is the label displayed\n# in the network details params tab identifying the request cookies.\nrequestCookies=Request cookies\n\n# LOCALIZATION NOTE (responseCookies): This is the label displayed\n# in the network details params tab identifying the response cookies.\nresponseCookies=Response cookies\n\n# LOCALIZATION NOTE (jsonFilterText): This is the text displayed\n# in the response tab of the network details pane for the JSON filtering input.\njsonFilterText=Filter properties\n\n# LOCALIZATION NOTE (jsonScopeName): This is the text displayed\n# in the response tab of the network details pane for a JSON scope.\njsonScopeName=JSON\n\n# LOCALIZATION NOTE (jsonpScopeName): This is the text displayed\n# in the response tab of the network details pane for a JSONP scope.\njsonpScopeName=JSONP → callback %S()\n\n# LOCALIZATION NOTE (networkMenu.sortedAsc): This is the tooltip displayed\n# in the network table toolbar, for any column that is sorted ascending.\nnetworkMenu.sortedAsc=Sorted ascending\n\n# LOCALIZATION NOTE (networkMenu.sortedDesc): This is the tooltip displayed\n# in the network table toolbar, for any column that is sorted descending.\nnetworkMenu.sortedDesc=Sorted descending\n\n# LOCALIZATION NOTE (networkMenu.empty): This is the label displayed\n# in the network table footer when there are no requests available.\nnetworkMenu.empty=No requests\n\n# LOCALIZATION NOTE (networkMenu.summary): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This label is displayed in the network table footer providing concise\n# information about all requests. Parameters: #1 is the number of requests,\n# #2 is the size, #3 is the number of seconds.\nnetworkMenu.summary=One request, #2 KB, #3 s;#1 requests, #2 KB, #3 s\n\n# LOCALIZATION NOTE (networkMenu.sizeB): This is the label displayed\n# in the network menu specifying the size of a request (in bytes).\nnetworkMenu.sizeB=%S B\n\n# LOCALIZATION NOTE (networkMenu.sizeKB): This is the label displayed\n# in the network menu specifying the size of a request (in kilobytes).\nnetworkMenu.sizeKB=%S KB\n\n# LOCALIZATION NOTE (networkMenu.sizeMB): This is the label displayed\n# in the network menu specifying the size of a request (in megabytes).\nnetworkMenu.sizeMB=%S MB\n\n# LOCALIZATION NOTE (networkMenu.sizeGB): This is the label displayed\n# in the network menu specifying the size of a request (in gigabytes).\nnetworkMenu.sizeGB=%S GB\n\n# LOCALIZATION NOTE (networkMenu.sizeUnavailable): This is the label displayed\n# in the network menu specifying the transferred size of a request is\n# unavailable.\nnetworkMenu.sizeUnavailable=—\n\n# LOCALIZATION NOTE (networkMenu.sizeCached): This is the label displayed\n# in the network menu specifying the transferred of a request is\n# cached.\nnetworkMenu.sizeCached=cached\n\n# LOCALIZATION NOTE (networkMenu.sizeServiceWorker): This is the label displayed\n# in the network menu specifying the transferred of a request computed\n# by a service worker.\nnetworkMenu.sizeServiceWorker=service worker\n\n# LOCALIZATION NOTE (networkMenu.totalMS): This is the label displayed\n# in the network menu specifying the time for a request to finish (in milliseconds).\nnetworkMenu.totalMS=→ %S ms\n\n# LOCALIZATION NOTE (networkMenu.millisecond): This is the label displayed\n# in the network menu specifying timing interval divisions (in milliseconds).\nnetworkMenu.millisecond=%S ms\n\n# LOCALIZATION NOTE (networkMenu.second): This is the label displayed\n# in the network menu specifying timing interval divisions (in seconds).\nnetworkMenu.second=%S s\n\n# LOCALIZATION NOTE (networkMenu.minute): This is the label displayed\n# in the network menu specifying timing interval divisions (in minutes).\nnetworkMenu.minute=%S min\n\n# LOCALIZATION NOTE (pieChart.loading): This is the label displayed\n# for pie charts (e.g., in the performance analysis view) when there is\n# no data available yet.\npieChart.loading=Loading\n\n# LOCALIZATION NOTE (pieChart.unavailable): This is the label displayed\n# for pie charts (e.g., in the performance analysis view) when there is\n# no data available, even after loading it.\npieChart.unavailable=Empty\n\n# LOCALIZATION NOTE (tableChart.loading): This is the label displayed\n# for table charts (e.g., in the performance analysis view) when there is\n# no data available yet.\ntableChart.loading=Please wait…\n\n# LOCALIZATION NOTE (tableChart.unavailable): This is the label displayed\n# for table charts (e.g., in the performance analysis view) when there is\n# no data available, even after loading it.\ntableChart.unavailable=No data available\n\n# LOCALIZATION NOTE (charts.sizeKB): This is the label displayed\n# in pie or table charts specifying the size of a request (in kilobytes).\ncharts.sizeKB=%S KB\n\n# LOCALIZATION NOTE (charts.totalS): This is the label displayed\n# in pie or table charts specifying the time for a request to finish (in seconds).\ncharts.totalS=%S s\n\n# LOCALIZATION NOTE (charts.cacheEnabled): This is the label displayed\n# in the performance analysis view for \"cache enabled\" charts.\ncharts.cacheEnabled=Primed cache\n\n# LOCALIZATION NOTE (charts.cacheDisabled): This is the label displayed\n# in the performance analysis view for \"cache disabled\" charts.\ncharts.cacheDisabled=Empty cache\n\n# LOCALIZATION NOTE (charts.totalSize): This is the label displayed\n# in the performance analysis view for total requests size, in kilobytes.\ncharts.totalSize=Size: %S KB\n\n# LOCALIZATION NOTE (charts.totalSeconds): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This is the label displayed in the performance analysis view for the\n# total requests time, in seconds.\ncharts.totalSeconds=Time: #1 second;Time: #1 seconds\n\n# LOCALIZATION NOTE (charts.totalCached): This is the label displayed\n# in the performance analysis view for total cached responses.\ncharts.totalCached=Cached responses: %S\n\n# LOCALIZATION NOTE (charts.totalCount): This is the label displayed\n# in the performance analysis view for total requests.\ncharts.totalCount=Total requests: %S\n\n# LOCALIZATION NOTE (netRequest.headers): A label used for Headers tab\n# This tab displays list of HTTP headers\nnetRequest.headers=Headers\n\n# LOCALIZATION NOTE (netRequest.response): A label used for Response tab\n# This tab displays HTTP response body\nnetRequest.response=Response\n\n# LOCALIZATION NOTE (netRequest.rawData): A label used for a section\n# in Response tab. This section displays raw response body as it's\n# been received from the backend (debugger server)\nnetRequest.rawData=Raw Data\n\n# LOCALIZATION NOTE (netRequest.xml): A label used for a section\n# in Response tab. This section displays parsed XML response body.\nnetRequest.xml=XML\n\n# LOCALIZATION NOTE (netRequest.image): A label used for a section\n# in Response tab. This section displays images returned in response body.\nnetRequest.image=Image\n\n# LOCALIZATION NOTE (netRequest.sizeLimitMessage): A label used\n# in Response and Post tabs in case the body is bigger than given limit.\n# It allows the user to click and fetch more from the backend.\n# The {{link}} will be replace at run-time by an active link.\n# String with ID 'netRequest.sizeLimitMessageLink' will be used as text\n# for this link.\nnetRequest.sizeLimitMessage=Size limit has been reached. Click {{link}} to load more.\nnetRequest.sizeLimitMessageLink=here\n\n# LOCALIZATION NOTE (netRequest.responseBodyDiscarded): A label used\n# in Response tab if the response body is not available.\nnetRequest.responseBodyDiscarded=Response body was not stored.\n\n# LOCALIZATION NOTE (netRequest.requestBodyDiscarded): A label used\n# in Post tab if the post body is not available.\nnetRequest.requestBodyDiscarded=Request POST body was not stored.\n\n# LOCALIZATION NOTE (netRequest.post): A label used for Post tab\n# This tab displays HTTP post body\nnetRequest.post=POST\n\n# LOCALIZATION NOTE (netRequest.cookies): A label used for Cookies tab\n# This tab displays request and response cookies.\nnetRequest.cookies=Cookies\n\n# LOCALIZATION NOTE (netRequest.params): A label used for URL parameters tab\n# This tab displays data parsed from URL query string.\nnetRequest.params=Params\n\n# LOCALIZATION NOTE (netRequest.callstack): A label used for request stacktrace tab\n# This tab displays the request's JavaScript stack trace. Should be identical to\n# debuggerUI.tabs.callstack\nnetRequest.callstack=Call Stack\n"

/***/ },
/* 88 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Performance Tools\n# which is available from the Web Developer sub-menu -> 'Performance'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (performance.label):\n# This string is displayed in the title of the tab when the profiler is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nperformance.label=Performance\n\n# LOCALIZATION NOTE (performance.panelLabel):\n# This is used as the label for the toolbox panel.\nperformance.panelLabel=Performance Panel\n\n# LOCALIZATION NOTE (performance.commandkey, performance.accesskey)\n# Used for the menuitem in the tool menu\nperformance.commandkey=VK_F5\nperformance.accesskey=P\n\n# LOCALIZATION NOTE (performance.tooltip):\n# This string is displayed in the tooltip of the tab when the profiler is\n# displayed inside the developer tools window.\n# Keyboard shortcut for Performance Tools will be shown inside brackets.\nperformance.tooltip=Performance (%S)\n\n# LOCALIZATION NOTE (noRecordingsText): The text to display in the\n# recordings menu when there are no recorded profiles yet.\nnoRecordingsText=There are no profiles yet.\n\n# LOCALIZATION NOTE (recordingsList.itemLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# identifying a set of function calls. %S represents the number of recording,\n# iterating for every new recording, resulting in \"Recording #1\", \"Recording #2\", etc.\nrecordingsList.itemLabel=Recording #%S\n\n# LOCALIZATION NOTE (recordingsList.recordingLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# for an item that has not finished recording.\nrecordingsList.recordingLabel=In progress…\n\n# LOCALIZATION NOTE (recordingsList.loadingLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# for an item that is finished and is loading.\nrecordingsList.loadingLabel=Loading…\n\n# LOCALIZATION NOTE (recordingsList.durationLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# for an item that has finished recording.\nrecordingsList.durationLabel=%S ms\n\n# LOCALIZATION NOTE (recordingsList.saveLabel):\n# This string is displayed in the recordings list of the Performance Tools,\n# for saving an item to disk.\nrecordingsList.saveLabel=Save\n\n# LOCALIZATION NOTE (graphs.fps):\n# This string is displayed in the framerate graph of the Performance Tools,\n# as the unit used to measure frames per second. This label should be kept\n# AS SHORT AS POSSIBLE so it doesn't obstruct important parts of the graph.\ngraphs.fps=fps\n\n# LOCALIZATION NOTE (graphs.ms):\n# This string is displayed in the flamegraph of the Performance Tools,\n# as the unit used to measure time (in milliseconds). This label should be kept\n# AS SHORT AS POSSIBLE so it doesn't obstruct important parts of the graph.\ngraphs.ms=ms\n\n# LOCALIZATION NOTE (graphs.memory):\n# This string is displayed in the memory graph of the Performance tool,\n# as the unit used to memory consumption. This label should be kept\n# AS SHORT AS POSSIBLE so it doesn't obstruct important parts of the graph.\ngraphs.memory=MB\n\n# LOCALIZATION NOTE (category.*):\n# These strings are displayed in the categories graph of the Performance Tools,\n# as the legend for each block in every bar. These labels should be kept\n# AS SHORT AS POSSIBLE so they don't obstruct important parts of the graph.\ncategory.other=Gecko\ncategory.css=Styles\ncategory.js=JIT\ncategory.gc=GC\ncategory.network=Network\ncategory.graphics=Graphics\ncategory.storage=Storage\ncategory.events=Input & Events\ncategory.tools=Tools\n\n# LOCALIZATION NOTE (table.bytes):\n# This string is displayed in the call tree after bytesize units.\n# %S represents the value in bytes.\ntable.bytes=%S B\n\n# LOCALIZATION NOTE (table.ms2):\n# This string is displayed in the call tree after units of time in milliseconds.\n# %S represents the value in milliseconds.\ntable.ms2=%S ms\n\n# LOCALIZATION NOTE (table.percentage3):\n# This string is displayed in the call tree after units representing percentages.\n# %S represents the value in percentage with two decimal points, localized.\n# there are two \"%\" after %S to escape and display \"%\"\ntable.percentage3=%S%%\n\n# LOCALIZATION NOTE (table.root):\n# This string is displayed in the call tree for the root node.\ntable.root=(root)\n\n# LOCALIZATION NOTE (table.idle):\n# This string is displayed in the call tree for the idle blocks.\ntable.idle=(idle)\n\n# LOCALIZATION NOTE (table.url.tooltiptext):\n# This string is displayed in the call tree as the tooltip text for the url\n# labels which, when clicked, jump to the debugger.\ntable.url.tooltiptext=View source in Debugger\n\n# LOCALIZATION NOTE (table.view-optimizations.tooltiptext2):\n# This string is displayed in the icon displayed next to frames that\n# have optimization data\ntable.view-optimizations.tooltiptext2=Frame contains JIT optimization data\n\n# LOCALIZATION NOTE (recordingsList.importDialogTitle):\n# This string is displayed as a title for importing a recoring from disk.\nrecordingsList.importDialogTitle=Import recording…\n\n# LOCALIZATION NOTE (recordingsList.saveDialogTitle):\n# This string is displayed as a title for saving a recording to disk.\nrecordingsList.saveDialogTitle=Save recording…\n\n# LOCALIZATION NOTE (recordingsList.saveDialogJSONFilter):\n# This string is displayed as a filter for saving a recording to disk.\nrecordingsList.saveDialogJSONFilter=JSON Files\n\n# LOCALIZATION NOTE (recordingsList.saveDialogAllFilter):\n# This string is displayed as a filter for saving a recording to disk.\nrecordingsList.saveDialogAllFilter=All Files\n\n# LOCALIZATION NOTE (timeline.tick):\n# This string is displayed in the timeline overview, for delimiting ticks\n# by time, in milliseconds.\ntimeline.tick=%S ms\n\n# LOCALIZATION NOTE (timeline.records):\n# This string is displayed in the timeline waterfall, as a title for the menu.\ntimeline.records=RECORDS\n\n# LOCALIZATION NOTE (profiler.bufferFull):\n# This string is displayed when recording, indicating how much of the\n# buffer is currently be used.\n# %S is the percentage of the buffer used -- there are two \"%\"s after to escape\n# the % that is actually displayed.\n# Example: \"Buffer 54% full\"\nprofiler.bufferFull=Buffer %S%% full\n"

/***/ },
/* 89 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the ProjectEditor component\n# which is used for editing files in a directory and is used inside the\n# App Manager.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (projecteditor.confirmUnsavedTitle):\n# This string is displayed as as the title of the confirm prompt that checks\n# to make sure if the project can be closed/switched without saving changes\nprojecteditor.confirmUnsavedTitle=Unsaved Changes\n\n# LOCALIZATION NOTE (projecteditor.confirmUnsavedLabel2):\n# This string is displayed as the message of the confirm prompt that checks\n# to make sure if the project can be closed/switched without saving changes\nprojecteditor.confirmUnsavedLabel2=You have unsaved changes that will be lost. Are you sure you want to continue?\n\n# LOCALIZATION NOTE (projecteditor.deleteLabel):\n# This string is displayed as a context menu item for allowing the selected\n# file / folder to be deleted.\nprojecteditor.deleteLabel=Delete\n\n# LOCALIZATION NOTE (projecteditor.deletePromptTitle):\n# This string is displayed as as the title of the confirm prompt that checks\n# to make sure if a file or folder should be removed.\nprojecteditor.deletePromptTitle=Delete\n\n# LOCALIZATION NOTE (projecteditor.deleteFolderPromptMessage):\n# This string is displayed as as the message of the confirm prompt that checks\n# to make sure if a folder should be removed.\nprojecteditor.deleteFolderPromptMessage=Are you sure you want to delete this folder?\n\n# LOCALIZATION NOTE (projecteditor.deleteFilePromptMessage):\n# This string is displayed as as the message of the confirm prompt that checks\n# to make sure if a file should be removed.\nprojecteditor.deleteFilePromptMessage=Are you sure you want to delete this file?\n\n# LOCALIZATION NOTE (projecteditor.newLabel):\n# This string is displayed as a menu item for adding a new file to\n# the directory.\nprojecteditor.newLabel=New…\n\n# LOCALIZATION NOTE (projecteditor.renameLabel):\n# This string is displayed as a menu item for renaming a file in\n# the directory.\nprojecteditor.renameLabel=Rename\n\n# LOCALIZATION NOTE (projecteditor.saveLabel):\n# This string is displayed as a menu item for saving the current file.\nprojecteditor.saveLabel=Save\n\n# LOCALIZATION NOTE (projecteditor.saveAsLabel):\n# This string is displayed as a menu item for saving the current file\n# with a new name.\nprojecteditor.saveAsLabel=Save As…\n\n# LOCALIZATION NOTE (projecteditor.selectFileLabel):\n# This string is displayed as the title on the file picker when saving a file.\nprojecteditor.selectFileLabel=Select a File\n\n# LOCALIZATION NOTE (projecteditor.openFolderLabel):\n# This string is displayed as the title on the file picker when opening a folder.\nprojecteditor.openFolderLabel=Select a Folder\n\n# LOCALIZATION NOTE (projecteditor.openFileLabel):\n# This string is displayed as the title on the file picker when opening a file.\nprojecteditor.openFileLabel=Open a File\n\n# LOCALIZATION NOTE  (projecteditor.find.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to search\n# text in the files.\nprojecteditor.find.commandkey=F\n\n# LOCALIZATION NOTE  (projecteditor.save.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to\n# save the file.  It is used with accel+shift to \"save as\".\nprojecteditor.save.commandkey=S\n\n# LOCALIZATION NOTE  (projecteditor.new.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to\n# create a new file.\nprojecteditor.new.commandkey=N\n"

/***/ },
/* 90 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Promise debugger\n# which is available as a panel in the Debugger.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n"

/***/ },
/* 91 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Responsive Design Mode,\n# available from the Web Developer sub-menu -> 'Responsive Design Mode'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (responsive.editDeviceList): option displayed in the device\n# selector\nresponsive.editDeviceList=Edit list…\n\n# LOCALIZATION NOTE (responsive.exit): tooltip text of the exit button.\nresponsive.exit=Close Responsive Design Mode\n\n# LOCALIZATION NOTE (responsive.deviceListLoading): placeholder text for\n# device selector when it's still fetching devices\nresponsive.deviceListLoading=Loading…\n\n# LOCALIZATION NOTE (responsive.deviceListError): placeholder text for\n# device selector when an error occurred\nresponsive.deviceListError=No list available\n\n# LOCALIZATION NOTE (responsive.done): button text in the device list modal\nresponsive.done=Done\n\n# LOCALIZATION NOTE (responsive.noDeviceSelected): placeholder text for the\n# device selector\nresponsive.noDeviceSelected=no device selected\n\n# LOCALIZATION NOTE  (responsive.title): the title displayed in the global\n# toolbar\nresponsive.title=Responsive Design Mode\n\n# LOCALIZATION NOTE (responsive.enableTouch): tooltip text for the touch\n# simulation button when it's disabled\nresponsive.enableTouch=Enable touch simulation\n\n# LOCALIZATION NOTE (responsive.disableTouch): tooltip text for the touch\n# simulation button when it's enabled\nresponsive.disableTouch=Disable touch simulation\n\n# LOCALIZATION NOTE  (responsive.screenshot): tooltip of the screenshot button.\nresponsive.screenshot=Take a screenshot of the viewport\n\n# LOCALIZATION NOTE (responsive.screenshotGeneratedFilename): The auto generated\n# filename.\n# The first argument (%1$S) is the date string in yyyy-mm-dd format and the\n# second argument (%2$S) is the time string in HH.MM.SS format.\nresponsive.screenshotGeneratedFilename=Screen Shot %1$S at %2$S\n\n# LOCALIZATION NOTE (responsive.remoteOnly): Message displayed in the tab's\n# notification box if a user tries to open Responsive Design Mode in a\n# non-remote tab.\nresponsive.remoteOnly=Responsive Design Mode is only available for remote browser tabs, such as those used for web content in multi-process Firefox.\n"

/***/ },
/* 92 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Responsive Mode\n# which is available from the Web Developer sub-menu -> 'Responsive Mode'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n\n# LOCALIZATION NOTE  (responsiveUI.rotate2): tooltip of the rotate button.\nresponsiveUI.rotate2=Rotate\n\n# LOCALIZATION NOTE  (responsiveUI.screenshot): tooltip of the screenshot button.\nresponsiveUI.screenshot=Screenshot\n\n# LOCALIZATION NOTE  (responsiveUI.userAgentPlaceholder): placeholder for the user agent input.\nresponsiveUI.userAgentPlaceholder=Custom User Agent\n\n# LOCALIZATION NOTE (responsiveUI.screenshotGeneratedFilename): The auto generated filename.\n# The first argument (%1$S) is the date string in yyyy-mm-dd format and the second\n# argument (%2$S) is the time string in HH.MM.SS format.\nresponsiveUI.screenshotGeneratedFilename=Screen Shot %1$S at %2$S\n\n# LOCALIZATION NOTE  (responsiveUI.touch): tooltip of the touch button.\nresponsiveUI.touch=Simulate touch events (page reload might be needed)\n\n# LOCALIZATION NOTE  (responsiveUI.addPreset): label of the add preset button.\nresponsiveUI.addPreset=Add Preset\n\n# LOCALIZATION NOTE  (responsiveUI.removePreset): label of the remove preset button.\nresponsiveUI.removePreset=Remove Preset\n\n# LOCALIZATION NOTE  (responsiveUI.customResolution): label of the first item\n# in the menulist at the beginning of the toolbar. For %S is replace with the\n# current size of the page. For example: \"400x600\".\nresponsiveUI.customResolution=%S (custom)\n\n# LOCALIZATION NOTE  (responsiveUI.namedResolution): label of custom items with a name\n# in the menulist of the toolbar.\n# For example: \"320x480 (phone)\".\nresponsiveUI.namedResolution=%S (%S)\n\n# LOCALIZATION NOTE  (responsiveUI.customNamePromptTitle1): prompt title when asking\n# the user to specify a name for a new custom preset.\nresponsiveUI.customNamePromptTitle1=Responsive Design Mode\n\n# LOCALIZATION NOTE (responsiveUI.close1): tooltip text of the close button.\nresponsiveUI.close1=Leave Responsive Design Mode\n\n# LOCALIZATION NOTE  (responsiveUI.customNamePromptMsg): prompt message when asking\n# the user to specify a name for a new custom preset.\nresponsiveUI.customNamePromptMsg=Give a name to the %Sx%S preset\n\n# LOCALIZATION NOTE (responsiveUI.resizer): tooltip showed when\n# overring the resizers.\nresponsiveUI.resizerTooltip=Use the Control key for more precision. Use Shift key for rounded sizes.\n\n# LOCALIZATION NOTE (responsiveUI.needReload): notification that appears\n# when touch events are enabled\nresponsiveUI.needReload=If touch event listeners have been added earlier, the page needs to be reloaded.\nresponsiveUI.notificationReload=Reload\nresponsiveUI.notificationReload_accesskey=R\nresponsiveUI.dontShowReloadNotification=Never show again\nresponsiveUI.dontShowReloadNotification_accesskey=N\n"

/***/ },
/* 93 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the JavaScript scratchpad\n# which is available from the Web Developer sub-menu -> 'Scratchpad'.\n#\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE  (export.fileOverwriteConfirmation): This is displayed when\n# the user attempts to save to an already existing file.\nexport.fileOverwriteConfirmation=File exists. Overwrite?\n\n# LOCALIZATION NOTE  (browserWindow.unavailable): This error message is shown\n# when Scratchpad does not find any recently active main browser window.\nbrowserWindow.unavailable=Scratchpad cannot find any browser window to execute the code in.\n\n# LOCALIZATION NOTE  (scratchpadContext.invalid): This error message is shown\n# when user tries to run an operation in Scratchpad in an unsupported context.\nscratchpadContext.invalid=Scratchpad cannot run this operation in the current mode.\n\n# LOCALIZATION NOTE  (openFile.title): This is the file picker title, when you\n# open a file from Scratchpad.\nopenFile.title=Open File\n\n# LOCALIZATION NOTE  (openFile.failed): This is the message displayed when file\n# open fails.\nopenFile.failed=Failed to read the file.\n\n# LOCALIZATION NOTE  (importFromFile.convert.failed): This is the message\n# displayed when file conversion from some charset to Unicode fails.\n# %1 is the name of the charset from which the conversion failed.\nimportFromFile.convert.failed=Failed to convert file to Unicode from %1$S.\n\n# LOCALIZATION NOTE (clearRecentMenuItems.label): This is the label for the\n# menuitem in the 'Open Recent'-menu which clears all recent files.\nclearRecentMenuItems.label=Clear Items\n\n# LOCALIZATION NOTE  (saveFileAs): This is the file picker title, when you save\n# a file in Scratchpad.\nsaveFileAs=Save File As\n\n# LOCALIZATION NOTE  (saveFile.failed): This is the message displayed when file\n# save fails.\nsaveFile.failed=The file save operation failed.\n\n# LOCALIZATION NOTE  (confirmClose): This is message in the prompt dialog when\n# you try to close a scratchpad with unsaved changes.\nconfirmClose=Do you want to save the changes you made to this scratchpad?\n\n# LOCALIZATION NOTE  (confirmClose.title): This is title of the prompt dialog when\n# you try to close a scratchpad with unsaved changes.\nconfirmClose.title=Unsaved Changes\n\n# LOCALIZATION NOTE  (confirmRevert): This is message in the prompt dialog when\n# you try to revert unsaved content of scratchpad.\nconfirmRevert=Do you want to revert the changes you made to this scratchpad?\n\n# LOCALIZATION NOTE  (confirmRevert.title): This is title of the prompt dialog when\n# you try to revert unsaved content of scratchpad.\nconfirmRevert.title=Revert Changes\n\n# LOCALIZATION NOTE  (scratchpadIntro): This is a multi-line comment explaining\n# how to use the Scratchpad. Note that this should be a valid JavaScript\n# comment inside /* and */.\nscratchpadIntro1=/*\\n * This is a JavaScript Scratchpad.\\n *\\n * Enter some JavaScript, then Right Click or choose from the Execute Menu:\\n * 1. Run to evaluate the selected text (%1$S),\\n * 2. Inspect to bring up an Object Inspector on the result (%2$S), or,\\n * 3. Display to insert the result in a comment after the selection. (%3$S)\\n */\\n\\n\n\n# LOCALIZATION NOTE  (scratchpad.noargs): This error message is shown when\n# Scratchpad instance is created without any arguments. Scratchpad window\n# expects to receive its unique identifier as the first window argument.\nscratchpad.noargs=Scratchpad was created without any arguments.\n\n# LOCALIZATION NOTE  (notification.browserContext): This is the message displayed\n# over the top of the editor when the user has switched to browser context.\nbrowserContext.notification=This scratchpad executes in the Browser context.\n\n# LOCALIZATION NOTE (help.openDocumentationPage): This returns a localized link with\n# documentation for Scratchpad on MDN.\nhelp.openDocumentationPage=https://developer.mozilla.org/en/Tools/Scratchpad\n\n# LOCALIZATION NOTE (scratchpad.statusBarLineCol): Line, Column\n# information displayed in statusbar when selection is made in\n# Scratchpad.\nscratchpad.statusBarLineCol  = Line %1$S, Col %2$S\n\n# LOCALIZATION NOTE (fileExists.notification): This is the message displayed\n# over the top of the the editor when a file does not exist.\nfileNoLongerExists.notification=This file no longer exists.\n\n# LOCALIZATION NOTE (propertiesFilterPlaceholder): this is the text that\n# appears in the filter text box for the properties view container.\npropertiesFilterPlaceholder=Filter properties\n\n# LOCALIZATION NOTE (connectionTimeout): message displayed when the Remote Scratchpad\n# fails to connect to the server due to a timeout.\nconnectionTimeout=Connection timeout. Check the Error Console on both ends for potential error messages. Reopen the Scratchpad to try again.\n\n# LOCALIZATION NOTE (scratchpad.label): this string is displayed in the title of\n# the tab when the Scratchpad is displayed inside the developer tools window and\n# in the Developer Tools Menu.\nscratchpad.label=Scratchpad\n\n# LOCALIZATION NOTE (scratchpad.panelLabel): this is used as the\n# label for the toolbox panel.\nscratchpad.panelLabel=Scratchpad Panel\n\n# LOCALIZATION NOTE (scratchpad.tooltip):  This string is displayed in the\n# tooltip of the tab when the Scratchpad is displayed inside the developer tools\n# window.\nscratchpad.tooltip=Scratchpad\n\n# LOCALIZATION NOTE (selfxss.msg): the text that is displayed when\n# a new user of the developer tools pastes code into the console\n# %1 is the text of selfxss.okstring\nselfxss.msg=Scam Warning: Take care when pasting things you don’t understand. This could allow attackers to steal your identity or take control of your computer. Please type ‘%S’ in the scratchpad below to allow pasting.\n\n# LOCALIZATION NOTE (selfxss.msg): the string to be typed\n# in by a new user of the developer tools when they receive the sefxss.msg prompt.\n# Please avoid using non-keyboard characters here\nselfxss.okstring=allow pasting\n"

/***/ },
/* 94 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Debugger\n# which is available from the Web Developer sub-menu -> 'Debugger'.\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (ToolboxShaderEditor.label):\n# This string is displayed in the title of the tab when the Shader Editor is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxShaderEditor.label=Shader Editor\n\n# LOCALIZATION NOTE (ToolboxShaderEditor.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxShaderEditor.panelLabel=Shader Editor Panel\n\n# LOCALIZATION NOTE (ToolboxShaderEditor.tooltip):\n# This string is displayed in the tooltip of the tab when the Shader Editor is\n# displayed inside the developer tools window.\nToolboxShaderEditor.tooltip=Live GLSL shader language editor for WebGL\n\n# LOCALIZATION NOTE (shadersList.programLabel):\n# This string is displayed in the programs list of the Shader Editor,\n# identifying a set of linked GLSL shaders.\nshadersList.programLabel=Program %S\n\n# LOCALIZATION NOTE (shadersList.blackboxLabel):\n# This string is displayed in the programs list of the Shader Editor, while\n# the user hovers over the checkbox used to toggle blackboxing of a program's\n# associated fragment shader.\nshadersList.blackboxLabel=Toggle geometry visibility\n"

/***/ },
/* 95 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (dimensions): This is used to display the dimensions\n# of a node or image, like 100×200.\ndimensions=%S\\u00D7%S\n\n# LOCALIZATION NOTE (groupCheckbox.tooltip): This is used in the SideMenuWidget\n# as the default tooltip of a group checkbox\nsideMenu.groupCheckbox.tooltip=Toggle all checkboxes in this group"

/***/ },
/* 96 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Source Editor component.\n# This component is used whenever source code is displayed for the purpose of\n# being edited, inside the Firefox developer tools - current examples are the\n# Scratchpad and the Style Editor tools.\n\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE  (findCmd.promptTitle): This is the dialog title used\n# when the user wants to search for a string in the code. You can\n# access this feature by pressing Ctrl-F on Windows/Linux or Cmd-F on Mac.\nfindCmd.promptTitle=Find…\n\n# LOCALIZATION NOTE  (findCmd.promptMessage): This is the message shown when\n# the user wants to search for a string in the code. You can\n# access this feature by pressing Ctrl-F on Windows/Linux or Cmd-F on Mac.\nfindCmd.promptMessage=Search for:\n\n# LOCALIZATION NOTE  (gotoLineCmd.promptTitle): This is the dialog title used\n# when the user wants to jump to a specific line number in the code. You can\n# access this feature by pressing Ctrl-J on Windows/Linux or Cmd-J on Mac.\ngotoLineCmd.promptTitle=Go to line…\n\n# LOCALIZATION NOTE  (gotoLineCmd.promptMessage): This is the message shown when\n# the user wants to jump to a specific line number in the code. You can\n# access this feature by pressing Ctrl-J on Windows/Linux or Cmd-J on Mac.\ngotoLineCmd.promptMessage=Jump to line number:\n\n# LOCALIZATION NOTE  (annotation.breakpoint.title): This is the text shown in\n# front of any breakpoint annotation when it is displayed as a tooltip in one of\n# the editor gutters. This feature is used in the JavaScript Debugger.\nannotation.breakpoint.title=Breakpoint: %S\n\n# LOCALIZATION NOTE  (annotation.currentLine): This is the text shown in\n# a tooltip displayed in any of the editor gutters when the user hovers the\n# current line.\nannotation.currentLine=Current line\n\n# LOCALIZATION NOTE  (annotation.debugLocation.title): This is the text shown in\n# a tooltip displayed in any of the editor gutters when the user hovers the\n# current debugger location. The debugger can pause the JavaScript execution at\n# user-defined lines.\nannotation.debugLocation.title=Current step: %S\n\n# LOCALIZATION NOTE  (autocompletion.docsLink): This is the text shown on\n# the link inside of the documentation popup.  If you type 'document' in Scratchpad\n# then press Shift+Space you can see the popup.\nautocompletion.docsLink=docs\n\n# LOCALIZATION NOTE  (autocompletion.notFound): This is the text shown in\n# the documentation popup if Tern fails to find a type for the object.\nautocompletion.notFound=not found\n\n# LOCALIZATION NOTE  (jumpToLine.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to jump to\n# a specific line in the editor.\njumpToLine.commandkey=J\n\n# LOCALIZATION NOTE  (toggleComment.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to either\n# comment or uncomment selected lines in the editor.\ntoggleComment.commandkey=/\n\n# LOCALIZATION NOTE  (indentLess.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to reduce\n# indentation level in CodeMirror. However, its default value also used by\n# the Toolbox to switch between tools so we disable it.\n#\n# DO NOT translate this key without proper synchronization with toolbox.dtd.\nindentLess.commandkey=[\n\n# LOCALIZATION NOTE  (indentMore.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to increase\n# indentation level in CodeMirror. However, its default value also used by\n# the Toolbox to switch between tools\n#\n# DO NOT translate this key without proper synchronization with toolbox.dtd.\nindentMore.commandkey=]\n\n# LOCALIZATION NOTE  (moveLineUp.commandkey): This is the combination of keys\n# used to move the current line up.\n# Do not localize \"Alt\", \"Up\", or change the format of the string. These are key\n# identifiers, not messages displayed to the user.\nmoveLineUp.commandkey=Alt-Up\n\n# LOCALIZATION NOTE  (moveLineDown.commandkey): This is the combination of keys\n# used to move the current line up.\n# Do not localize \"Alt\", \"Down\", or change the format of the string. These are\n# key identifiers, not messages displayed to the user.\nmoveLineDown.commandkey=Alt-Down\n\n# LOCALIZATION NOTE  (autocompletion.commandkey): This is the key, used with\n# Ctrl, for code autocompletion.\n# Do not localize \"Space\", it's the key identifier, not a message displayed to\n# the user.\nautocompletion.commandkey=Space\n\n# LOCALIZATION NOTE  (showInformation2.commandkey): This is the combination of\n# keys used to display more information, like type inference.\n# Do not localize \"Shift\", \"Ctrl\", \"Space\", or change the format of the string.\n# These are key identifiers, not messages displayed to the user.\nshowInformation2.commandkey=Shift-Ctrl-Space\n\n# LOCALIZATION NOTE  (find.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to find\n# the typed search\nfind.commandkey=F\n\n# LOCALIZATION NOTE  (findAgain.commandkey): This is the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to find\n# again the typed search\nfindAgain.commandkey=G\n"

/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Storage Editor tool.\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE  (storage.commandkey): This the key to use in\n# conjunction with shift to open the storage editor\nstorage.commandkey=VK_F9\n\n# LOCALIZATION NOTE (storage.accesskey): The access key used to open the storage\n# editor.\nstorage.accesskey=a\n\n# LOCALIZATION NOTE (storage.label):\n# This string is displayed as the label of the tab in the developer tools window\nstorage.label=Storage\n\n# LOCALIZATION NOTE (storage.menuLabel):\n# This string is displayed in the Tools menu as a shortcut to open the devtools\n# with the Storage Inspector tab selected.\nstorage.menuLabel=Storage Inspector\n\n# LOCALIZATION NOTE (storage.panelLabel):\n# This string is used as the aria-label for the iframe of the Storage Inspector\n# tool in developer tools toolbox.\nstorage.panelLabel=Storage Panel\n\n# LOCALIZATION NOTE (storage.tooltip3):\n# This string is displayed in the tooltip of the tab when the storage editor is\n# displayed inside the developer tools window.\n# A keyboard shortcut for Storage Inspector will be shown inside the brackets.\nstorage.tooltip3=Storage Inspector (Cookies, Local Storage, …) (%S)\n\n# LOCALIZATION NOTE (storage.filter.key):\n# Key shortcut used to focus the filter box on top of the data view\nstorage.filter.key=CmdOrCtrl+F\n\n# LOCALIZATION NOTE (tree.emptyText):\n# This string is displayed when the Storage Tree is empty. This can happen when\n# there are no websites on the current page (about:blank)\ntree.emptyText=No hosts on the page\n\n# LOCALIZATION NOTE (table.emptyText):\n# This string is displayed when there are no rows in the Storage Table for the\n# selected host.\ntable.emptyText=No data present for selected host\n\n# LOCALIZATION NOTE (tree.labels.*):\n# These strings are the labels for Storage type groups present in the Storage\n# Tree, like cookies, local storage etc.\ntree.labels.cookies=Cookies\ntree.labels.localStorage=Local Storage\ntree.labels.sessionStorage=Session Storage\ntree.labels.indexedDB=Indexed DB\ntree.labels.Cache=Cache Storage\n\n# LOCALIZATION NOTE (table.headers.*.*):\n# These strings are the header names of the columns in the Storage Table for\n# each type of storage available through the Storage Tree to the side.\ntable.headers.cookies.name=Name\ntable.headers.cookies.path=Path\ntable.headers.cookies.host=Domain\ntable.headers.cookies.expires=Expires on\ntable.headers.cookies.value=Value\ntable.headers.cookies.lastAccessed=Last accessed on\ntable.headers.cookies.creationTime=Created on\n# LOCALIZATION NOTE (table.headers.cookies.isHttpOnly):\n# This string is used in the header for the column which denotes whether a\n# cookie is HTTP only or not.\ntable.headers.cookies.isHttpOnly=isHttpOnly\n# LOCALIZATION NOTE (table.headers.cookies.isSecure):\n# This string is used in the header for the column which denotes whether a\n# cookie can be accessed via a secure channel only or not.\ntable.headers.cookies.isSecure=isSecure\n# LOCALIZATION NOTE (table.headers.cookies.isDomain):\n# This string is used in the header for the column which denotes whether a\n# cookie is a domain cookie only or not.\ntable.headers.cookies.isDomain=isDomain\n\ntable.headers.localStorage.name=Key\ntable.headers.localStorage.value=Value\n\ntable.headers.sessionStorage.name=Key\ntable.headers.sessionStorage.value=Value\n\ntable.headers.Cache.url=URL\ntable.headers.Cache.status=Status\n\ntable.headers.indexedDB.name=Key\ntable.headers.indexedDB.db=Database Name\ntable.headers.indexedDB.objectStore=Object Store Name\ntable.headers.indexedDB.value=Value\ntable.headers.indexedDB.origin=Origin\ntable.headers.indexedDB.version=Version\ntable.headers.indexedDB.objectStores=Object Stores\ntable.headers.indexedDB.keyPath=Key\ntable.headers.indexedDB.autoIncrement=Auto Increment\ntable.headers.indexedDB.indexes=Indexes\n\n# LOCALIZATION NOTE (label.expires.session):\n# This string is displayed in the expires column when the cookie is Session\n# Cookie\nlabel.expires.session=Session\n\n# LOCALIZATION NOTE (storage.search.placeholder):\n# This is the placeholder text in the sidebar search box\nstorage.search.placeholder=Filter values\n\n# LOCALIZATION NOTE (storage.data.label):\n# This is the heading displayed over the item value in the sidebar\nstorage.data.label=Data\n\n# LOCALIZATION NOTE (storage.parsedValue.label):\n# This is the heading displayed over the item parsed value in the sidebar\nstorage.parsedValue.label=Parsed Value\n\n# LOCALIZATION NOTE (storage.popupMenu.deleteLabel):\n# Label of popup menu action to delete storage item.\nstorage.popupMenu.deleteLabel=Delete “%S”\n\n# LOCALIZATION NOTE (storage.popupMenu.deleteAllLabel):\n# Label of popup menu action to delete all storage items.\nstorage.popupMenu.deleteAllFromLabel=Delete All From “%S”\n\n# LOCALIZATION NOTE (storage.idb.deleteBlocked):\n# Warning notification when IndexedDB database could not be deleted immediately.\nstorage.idb.deleteBlocked=Database “%S” will be deleted after all connections are closed.\n\n# LOCALIZATION NOTE (storage.idb.deleteError):\n# Error notification when IndexedDB database could not be deleted.\nstorage.idb.deleteError=Database “%S” could not be deleted.\n"

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Style Editor.\n# LOCALIZATION NOTE The correct localization of this file might be to keep it\n# in English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best documentation\n# on web development on the web.\n\n# LOCALIZATION NOTE  (chromeWindowTitle): This is the title of the Style Editor\n# 'chrome' window. That is, the main window with the stylesheets list.\n# The argument is either the content document's title or its href if no title\n# is available.\nchromeWindowTitle=Style Editor [%S]\n\n# LOCALIZATION NOTE  (inlineStyleSheet): This is the name used for an style sheet\n# that is declared inline in the <style> element. Shown in the stylesheets list.\n# the argument is the index (order) of the containing <style> element in the\n# document.\ninlineStyleSheet=<inline style sheet #%S>\n\n# LOCALIZATION NOTE  (newStyleSheet): This is the default name for a new\n# user-created style sheet.\nnewStyleSheet=New style sheet #%S\n\n# LOCALIZATION NOTE  (ruleCount.label): Semicolon-separated list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# This is shown in the style sheets list.\n# #1 rule.\n# example: 111 rules.\nruleCount.label=#1 rule.;#1 rules.\n\n# LOCALIZATION NOTE  (error-load): This is shown when loading fails.\nerror-load=Style sheet could not be loaded.\n\n# LOCALIZATION NOTE  (error-save): This is shown when saving fails.\nerror-save=Style sheet could not be saved.\n\n# LOCALIZATION NOTE  (error-compressed): This is shown when we can't show\n# coverage information because the css source is compressed.\nerror-compressed=Can’t show coverage information for compressed stylesheets\n\n# LOCALIZATION NOTE  (importStyleSheet.title): This is the file picker title,\n# when you import a style sheet into the Style Editor.\nimportStyleSheet.title=Import style sheet\n\n# LOCALIZATION NOTE  (importStyleSheet.filter): This is the *.css filter title\nimportStyleSheet.filter=CSS files\n\n# LOCALIZATION NOTE  (saveStyleSheet.title): This is the file picker title,\n# when you save a style sheet from the Style Editor.\nsaveStyleSheet.title=Save style sheet\n\n# LOCALIZATION NOTE  (saveStyleSheet.filter): This is the *.css filter title\nsaveStyleSheet.filter=CSS files\n\n# LOCALIZATION NOTE  (open.commandkey): This the key to use in\n# conjunction with shift to open the style editor\nopen.commandkey=VK_F7\n\n# LOCALIZATION NOTE (open.accesskey): The access key used to open the style\n# editor.\nopen.accesskey=l\n\n# LOCALIZATION NOTE  (saveStyleSheet.commandkey): This the key to use in\n# conjunction with accel (Command on Mac or Ctrl on other platforms) to Save\nsaveStyleSheet.commandkey=S\n\n# LOCALIZATION NOTE (ToolboxStyleEditor.label):\n# This string is displayed in the title of the tab when the style editor is\n# displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxStyleEditor.label=Style Editor\n\n# LOCALIZATION NOTE (ToolboxStyleEditor.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxStyleEditor.panelLabel=Style Editor Panel\n\n# LOCALIZATION NOTE (ToolboxStyleEditor.tooltip3):\n# This string is displayed in the tooltip of the tab when the style editor is\n# displayed inside the developer tools window.\n# A keyboard shortcut for Stylesheet Editor will be shown inside the latter pair of brackets.\nToolboxStyleEditor.tooltip3=Stylesheet Editor (CSS) (%S)\n\n# LOCALIZATION NOTE (confirmNavigationAway): Shown in a notification box when\n# the user tries to navigate away from a web page.\nconfirmNavigationAway.message=If you leave this page, unsaved changes in the Style Editor will be lost.\nconfirmNavigationAway.buttonLeave=Leave Page\nconfirmNavigationAway.buttonLeaveAccesskey=L\nconfirmNavigationAway.buttonStay=Stay on Page\nconfirmNavigationAway.buttonStayAccesskey=S\n"

/***/ },
/* 99 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ntoolboxDockButtons.bottom.tooltip=Dock to bottom of browser window\ntoolboxDockButtons.side.tooltip=Dock to side of browser window\ntoolboxDockButtons.window.tooltip=Show in separate window\n\n# LOCALIZATION NOTE (toolboxDockButtons.bottom.minimize): This string is shown\n# as a tooltip that appears in the toolbox when it is in \"bottom host\" mode and\n# when hovering over the minimize button in the toolbar. When clicked, the\n# button minimizes the toolbox so that just the toolbar is visible at the\n# bottom.\ntoolboxDockButtons.bottom.minimize=Minimize the toolbox\n\n# LOCALIZATION NOTE (toolboxDockButtons.bottom.maximize): This string is shown\n# as a tooltip that appears in the toolbox when it is in \"bottom host\" mode and\n# when hovering over the maximize button in the toolbar. When clicked, the\n# button maximizes the toolbox again (if it had been minimized before) so that\n# the whole toolbox is visible again.\ntoolboxDockButtons.bottom.maximize=Maximize the toolbox\n\n# LOCALIZATION NOTE (toolboxToggleButton.errors): Semi-colon list of plural\n# forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of errors in the current web page\ntoolboxToggleButton.errors=#1 error;#1 errors\n\n# LOCALIZATION NOTE (toolboxToggleButton.warnings): Semi-colon list of plural\n# forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of warnings in the current web page\ntoolboxToggleButton.warnings=#1 warning;#1 warnings\n\n# LOCALIZATION NOTE (toolboxToggleButton.tooltip): This string is shown\n# as tooltip in the developer toolbar to open/close the developer tools.\n# It's using toolboxToggleButton.errors as first and\n# toolboxToggleButton.warnings as second argument to show the number of errors\n# and warnings.\ntoolboxToggleButton.tooltip=%1$S, %2$S\\nClick to toggle the developer tools.\n\n# LOCALIZATION NOTE (toolbar.closeButton.tooltip)\n# Used as a message in tooltip when overing the close button of the Developer\n# Toolbar.\ntoolbar.closeButton.tooltip=Close Developer Toolbar\n\n# LOCALIZATION NOTE (toolbar.toolsButton.tooltip)\n# Used as a message in tooltip when overing the wrench icon of the Developer\n# Toolbar, which toggle the developer toolbox.\ntoolbar.toolsButton.tooltip=Toggle developer tools\n\n# LOCALIZATION NOTE (toolbox.titleTemplate1): This is the template\n# used to format the title of the toolbox.\n# The URL of the page being targeted: %1$S.\ntoolbox.titleTemplate1=Developer Tools - %1$S\n\n# LOCALIZATION NOTE (toolbox.titleTemplate2): This is the template\n# used to format the title of the toolbox.\n# The page title or other name for the thing being targeted: %1$S\n# The URL of the page being targeted: %2$S.\ntoolbox.titleTemplate2=Developer Tools - %1$S - %2$S\n\n# LOCALIZATION NOTE (toolbox.defaultTitle): This is used as the tool\n# name when no tool is selected.\ntoolbox.defaultTitle=Developer Tools\n\n# LOCALIZATION NOTE (toolbox.label): This is used as the label for the\n# toolbox as a whole\ntoolbox.label=Developer Tools\n\n# LOCALIZATION NOTE (optionsButton.tooltip): This is used as the tooltip\n# for the options panel tab.\noptionsButton.tooltip=Toolbox Options\n\n# LOCALIZATION NOTE (options.label): This is used as the label of the tab in\n# the devtools window.\noptions.label=Options\n\n# LOCALIZATION NOTE (options.panelLabel): This is used as the label for the\n# toolbox panel.\noptions.panelLabel=Toolbox Options Panel\n\n# LOCALIZATION NOTE (options.toolNotSupported): This is the template\n# used to add a * marker to the label for the Options Panel tool checkbox for the\n# tool which is not supported for the current toolbox target.\n# The name of the tool: %1$S.\noptions.toolNotSupportedMarker=%1$S *\n\n# LOCALIZATION NOTE (scratchpad.keycode)\n# Used for opening scratchpad from the detached toolbox window\n# Needs to match scratchpad.keycode from browser.dtd\nscratchpad.keycode=VK_F4\n\n# LOCALIZATION NOTE (browserConsoleCmd.commandkey)\n# Used for toggling the browser console from the detached toolbox window\n# Needs to match browserConsoleCmd.commandkey from browser.dtd\nbrowserConsoleCmd.commandkey=j\n\n# LOCALIZATION NOTE (pickButton.tooltip)\n# This is the tooltip of the pick button in the toolbox toolbar\npickButton.tooltip=Pick an element from the page\n\n# LOCALIZATION NOTE (sidebar.showAllTabs.tooltip)\n# This is the tooltip shown when hover over the '…' button in the tabbed side\n# bar, when there's no enough space to show all tabs at once\nsidebar.showAllTabs.tooltip=All tabs\n\n# LOCALIZATION NOTE (options.darkTheme.label2)\n# Used as a label for dark theme\noptions.darkTheme.label2=Dark\n\n# LOCALIZATION NOTE (options.lightTheme.label2)\n# Used as a label for light theme\noptions.lightTheme.label2=Light\n\n# LOCALIZATION NOTE (options.firebugTheme.label2)\n# Used as a label for Firebug theme\noptions.firebugTheme.label2=Firebug\n\n# LOCALIZATION NOTE (toolbox.noContentProcess.message)\n# Used as a message in the alert displayed when trying to open a browser\n# content toolbox and there is no content process running\ntoolbox.noContentProcess.message=No content process running.\n\n# LOCALIZATION NOTE (toolbox.viewCssSourceInStyleEditor.label)\n# Used as a message in either tooltips or contextual menu items to open the\n# corresponding URL as a css file in the Style-Editor tool.\n# DEV NOTE: Mostly used wherever toolbox.viewSourceInStyleEditor is used.\ntoolbox.viewCssSourceInStyleEditor.label=Open File in Style-Editor\n\n# LOCALIZATION NOTE (toolbox.viewJsSourceInDebugger.label)\n# Used as a message in either tooltips or contextual menu items to open the\n# corresponding URL as a js file in the Debugger tool.\n# DEV NOTE: Mostly used wherever toolbox.viewSourceInDebugger is used.\ntoolbox.viewJsSourceInDebugger.label=Open File in Debugger\n\ntoolbox.resumeOrderWarning=Page did not resume after the debugger was attached. To fix this, please close and re-open the toolbox.\n\n# LOCALIZATION NOTE (toolbox.options.key)\n# Key shortcut used to open the options panel\ntoolbox.options.key=CmdOrCtrl+Shift+O\n\n# LOCALIZATION NOTE (toolbox.help.key)\n# Key shortcut used to open the options panel\ntoolbox.help.key=F1\n\n# LOCALIZATION NOTE (toolbox.nextTool.key)\n# Key shortcut used to select the next tool\ntoolbox.nextTool.key=CmdOrCtrl+]\n\n# LOCALIZATION NOTE (toolbox.previousTool.key)\n# Key shortcut used to select the previous tool\ntoolbox.previousTool.key=CmdOrCtrl+[\n\n# LOCALIZATION NOTE (toolbox.zoom*.key)\n# Key shortcuts used to zomm in/out or reset the toolbox\n# Should match fullZoom*Cmd.commandkey values from browser.dtd\ntoolbox.zoomIn.key=CmdOrCtrl+Plus\ntoolbox.zoomIn2.key=CmdOrCtrl+=\ntoolbox.zoomIn3.key=\n\ntoolbox.zoomOut.key=CmdOrCtrl+-\ntoolbox.zoomOut2.key=\n\ntoolbox.zoomReset.key=CmdOrCtrl+0\ntoolbox.zoomReset2.key=\n\n# LOCALIZATION NOTE (toolbox.reload*.key)\n# Key shortcuts used to reload the page\ntoolbox.reload.key=CmdOrCtrl+R\ntoolbox.reload2.key=F5\n\n# LOCALIZATION NOTE (toolbox.forceReload*.key)\n# Key shortcuts used to force reload of the page by bypassing caches\ntoolbox.forceReload.key=CmdOrCtrl+Shift+R\ntoolbox.forceReload2.key=CmdOrCtrl+F5\n\n# LOCALIZATION NOTE (toolbox.minimize.key)\n# Key shortcut used to minimize the toolbox\ntoolbox.minimize.key=CmdOrCtrl+Shift+U\n\n# LOCALIZATION NOTE (toolbox.toggleHost.key)\n# Key shortcut used to move the toolbox in bottom or side of the browser window\ntoolbox.toggleHost.key=CmdOrCtrl+Shift+D\n"

/***/ },
/* 100 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE These strings are used inside the Web Audio tool\n# which is available in the developer tools' toolbox, once\n# enabled in the developer tools' preference \"Web Audio\".\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\n# LOCALIZATION NOTE (ToolboxWebAudioEditor1.label):\n# This string is displayed in the title of the tab when the Web Audio Editor\n# is displayed inside the developer tools window and in the Developer Tools Menu.\nToolboxWebAudioEditor1.label=Web Audio\n\n# LOCALIZATION NOTE (ToolboxWebAudioEditor1.panelLabel):\n# This is used as the label for the toolbox panel.\nToolboxWebAudioEditor1.panelLabel=Web Audio Panel\n\n# LOCALIZATION NOTE (ToolboxWebAudioEditor1.tooltip):\n# This string is displayed in the tooltip of the tab when the Web Audio Editor is\n# displayed inside the developer tools window.\nToolboxWebAudioEditor1.tooltip=Web Audio context visualizer and audio node inspector\n\n# LOCALIZATION NOTE (collapseInspector): This is the tooltip for the button\n# that collapses the inspector in the web audio tool UI.\ncollapseInspector=Collapse inspector\n\n# LOCALIZATION NOTE (expandInspector): This is the tooltip for the button\n# that expands the inspector in the web audio tool UI.\nexpandInspector=Expand inspector\n\n# LOCALIZATION NOTE (webAudioEditorTooltipBypass): This is the tooltip for the\n# button that bypasses an AudioNode\nwebAudioEditorTooltipBypass=Bypass AudioNode\n\n"

/***/ },
/* 101 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE\n# The correct localization of this file might be to keep it in\n# English, or another language commonly spoken among web developers.\n# You want to make that choice consistent across the developer tools.\n# A good criteria is the language in which you'd find the best\n# documentation on web development on the web.\n\ntypeError=Error:\ntypeWarning=Warning:\ntypeNetwork=Network:\ntypeException=Exception:\ntypeCssParser=CSS Parser:\ntypeStrict=Strict Warning:\nmsgCategory=Category:\nerrLine=Line: %S\nbtnHide=Hide\nbtnPrefs=Preferences\ncategoryPage=Page:\ncategoryConsole=Console:\nbtnMutation=DOM Mutation\ntipMutation=Toggle DOM Mutation event logging\nbtnGlobal=Global Messages\ntipGlobal=Toggle Global Message logging\nlocalConsole=Local Console\nclearConsoleCmd.label=Clear Console\nclearConsoleCmd.accesskey=e\nclose.button=Close\nclose.accesskey=C\nupdate.button=Update\nupdate.accesskey=U\ncmd.commandkey=K\nwebConsoleCmd.accesskey=W\n\n# LOCALIZATION NOTE (timestampFormat): %1$02S = hours (24-hour clock),\n# %2$02S = minutes, %3$02S = seconds, %4$03S = milliseconds.\ntimestampFormat=%02S:%02S:%02S.%03S\n\nhelperFuncUnsupportedTypeError=Can’t call pprint on this type of object.\n\n# LOCALIZATION NOTE (NetworkPanel.deltaDurationMS): this string is used to\n# show the duration between two network events (e.g request and response\n# header or response header and response body). Parameters: %S is the duration.\nNetworkPanel.durationMS=%Sms\n\nConsoleAPIDisabled=The Web Console logging API (console.log, console.info, console.warn, console.error) has been disabled by a script on this page.\n\n# LOCALIZATION NOTE (webConsoleWindowTitleAndURL): the Web Console floating\n# panel title. For RTL languages you need to set the LRM in the string to give\n# the URL the correct direction. Parameters: %S is the web page URL.\nwebConsoleWindowTitleAndURL=Web Console - %S\n\n# LOCALIZATION NOTE (webConsoleXhrIndicator): the indicator displayed before\n# a URL in the Web Console that was requested using an XMLHttpRequest.\n# Should probably be the same as &btnConsoleXhr; in webConsole.dtd\nwebConsoleXhrIndicator=XHR\n\n# LOCALIZATION NOTE (webConsoleMixedContentWarning): the message displayed\n# after a URL in the Web Console that has been flagged for Mixed Content (i.e.\n# http content in an https page).\nwebConsoleMixedContentWarning=Mixed Content\n\n# LOCALIZATION NOTE (webConsoleMoreInfoLabel): the more info tag displayed\n# after security related web console messages.\nwebConsoleMoreInfoLabel=Learn More\n\n# LOCALIZATION NOTE (scratchpad.linkText): the text used in the right hand\n# side of the Web Console command line when JavaScript is being entered, to\n# indicate how to jump into scratchpad mode.\nscratchpad.linkText=Shift+RETURN - Open in Scratchpad\n\n# LOCALIZATION NOTE (gcliterm.instanceLabel): the console displays objects\n# using their type (from the constructor function) in this descriptive string.\n# Parameters: %S is the object type.\ngcliterm.instanceLabel=Instance of %S\n\n# LOCALIZATION NOTE (reflow.*): the console displays reflow activity.\n# We can get 2 kind of lines: with JS link or without JS link. It looks like\n# that:\n# reflow: 12ms\n# reflow: 12ms function foobar, file.js line 42\n# The 2nd line, from \"function\" to the end of the line, is a link to the\n# JavaScript debugger.\nreflow.messageWithNoLink=reflow: %Sms\nreflow.messageWithLink=reflow: %Sms\\u0020\nreflow.messageLinkText=function %1$S, %2$S line %3$S\n\n# LOCALIZATION NOTE (stacktrace.anonymousFunction): this string is used to\n# display JavaScript functions that have no given name - they are said to be\n# anonymous. Test console.trace() in the webconsole.\nstacktrace.anonymousFunction=<anonymous>\n\n# LOCALIZATION NOTE (stacktrace.asyncStack): this string is used to\n# indicate that a given stack frame has an async parent.\n# %S is the \"Async Cause\" of the frame.\nstacktrace.asyncStack=(Async: %S)\n\n# LOCALIZATION NOTE (timerStarted): this string is used to display the result\n# of the console.time() call. Parameters: %S is the name of the timer.\ntimerStarted=%S: timer started\n\n# LOCALIZATION NOTE (timeEnd): this string is used to display the result of\n# the console.timeEnd() call. Parameters: %1$S is the name of the timer, %2$S\n# is the number of milliseconds.\ntimeEnd=%1$S: %2$Sms\n\n# LOCALIZATION NOTE (consoleCleared): this string is displayed when receiving a\n# call to console.clear() to let the user know the previous messages of the\n# console have been removed programmatically.\nconsoleCleared=Console was cleared.\n\n# LOCALIZATION NOTE (noCounterLabel): this string is used to display\n# count-messages with no label provided.\nnoCounterLabel=<no label>\n\n# LOCALIZATION NOTE (Autocomplete.blank): this string is used when inputnode\n# string containing anchor doesn't matches to any property in the content.\nAutocomplete.blank=  <- no result\n\nmaxTimersExceeded=The maximum allowed number of timers in this page was exceeded.\n\n# LOCALIZATION NOTE (maxCountersExceeded): Error message shown when the maximum\n# number of console.count()-counters was exceeded.\nmaxCountersExceeded=The maximum allowed number of counters in this page was exceeded.\n\n# LOCALIZATION NOTE (JSTerm.updateNotInspectable): this string is used when\n# the user inspects an evaluation result in the Web Console and tries the\n# Update button, but the new result no longer returns an object that can be\n# inspected.\nJSTerm.updateNotInspectable=After your input has been re-evaluated the result is no longer inspectable.\n\n# LOCALIZATION NOTE (remoteWebConsolePromptTitle): the title displayed on the\n# Web Console prompt asking for the remote host and port to connect to.\nremoteWebConsolePromptTitle=Remote Connection\n\n# LOCALIZATION NOTE (remoteWebConsolePromptMessage): the message displayed on\n# the Web Console prompt asking for the remote host and port to connect to.\nremoteWebConsolePromptMessage=Enter hostname and port number (host:port)\n\n# LOCALIZATION NOTE (remoteWebConsoleSelectTabTitle): the title displayed on\n# the Web Console prompt asking the user to pick a tab to attach to.\nremoteWebConsoleSelectTabTitle=Tab list - Remote Connection\n\n# LOCALIZATION NOTE (remoteWebConsoleSelectTabMessage): the message displayed\n# on the Web Console prompt asking the user to pick a tab to attach to.\nremoteWebConsoleSelectTabMessage=Select one of the tabs you want to attach to, or select the global console.\n\n# LOCALIZATION NOTE (listTabs.globalConsoleActor): the string displayed for\n# the global console in the tabs selection.\nlistTabs.globalConsoleActor=*Global Console*\n\n# LOCALIZATION NOTE (MenuWebconsole.label): the string displayed in the Tools\n# menu as a shortcut to open the devtools with the Web Console tab selected.\nMenuWebconsole.label=Web Console\n\n# LOCALIZATION NOTE (ToolboxTabWebconsole.label): the string displayed as the\n# label of the tab in the devtools window.\nToolboxTabWebconsole.label=Console\n\n# LOCALIZATION NOTE (ToolboxWebConsole.panelLabel): the string used as the\n# label for the toolbox panel.\nToolboxWebConsole.panelLabel=Console Panel\n\n# LOCALIZATION NOTE (ToolboxWebconsole.tooltip2): the string displayed in the\n# tooltip of the tab when the Web Console is displayed inside the developer\n# tools window.\n# Keyboard shortcut for Console will be shown inside the brackets.\nToolboxWebconsole.tooltip2=Web Console (%S)\n\n# LOCALIZATION NOTE (longStringEllipsis): the string displayed after a long\n# string. This string is clickable such that the rest of the string is\n# retrieved from the server.\nlongStringEllipsis=[…]\n\n# LOCALIZATION NOTE (longStringTooLong): the string displayed after the user\n# tries to expand a long string.\nlongStringTooLong=The string you are trying to view is too long to be displayed by the Web Console.\n\n# LOCALIZATION NOTE (NetworkPanel.fetchRemainingResponseContentLink): the\n# string  displayed in the network panel when the response body is only\n# partially available. Parameters: %S is the amount of bytes that need to be\n# fetched.\nNetworkPanel.fetchRemainingResponseContentLink=Fetch the remaining %S bytes\n\n# LOCALIZATION NOTE (NetworkPanel.fetchRemainingRequestContentLink): the\n# string displayed in the network panel when the request body is only\n# partially available. Parameters: %S is the amount of bytes that need to be\n# fetched.\nNetworkPanel.fetchRemainingRequestContentLink=Fetch the request body (%S bytes)\n\n# LOCALIZATION NOTE (connectionTimeout): message displayed when the Remote Web\n# Console fails to connect to the server due to a timeout.\nconnectionTimeout=Connection timeout. Check the Error Console on both ends for potential error messages. Reopen the Web Console to try again.\n\n# LOCALIZATION NOTE (propertiesFilterPlaceholder): this is the text that\n# appears in the filter text box for the properties view container.\npropertiesFilterPlaceholder=Filter properties\n\n# LOCALIZATION NOTE (emptyPropertiesList): the text that is displayed in the\n# properties pane when there are no properties to display.\nemptyPropertiesList=No properties to display\n\n# LOCALIZATION NOTE (messageRepeats.tooltip2): the tooltip text that is displayed\n# when you hover the red bubble that shows how many times a message is repeated\n# in the web console output.\n# This is a semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of message repeats\n# example: 3 repeats\nmessageRepeats.tooltip2=#1 repeat;#1 repeats\n\n# LOCALIZATION NOTE (openNodeInInspector): the text that is displayed in a\n# tooltip when hovering over the inspector icon next to a DOM Node in the console\n# output\nopenNodeInInspector=Click to select the node in the inspector\n\n# LOCALIZATION NOTE (cdFunctionInvalidArgument): the text that is displayed when\n# cd() is invoked with an invalid argument.\ncdFunctionInvalidArgument=Cannot cd() to the given window. Invalid argument.\n\n# LOCALIZATION NOTE (selfxss.msg): the text that is displayed when\n# a new user of the developer tools pastes code into the console\n# %1 is the text of selfxss.okstring\nselfxss.msg=Scam Warning: Take care when pasting things you don’t understand. This could allow attackers to steal your identity or take control of your computer. Please type ‘%S’ below (no need to press enter) to allow pasting.\n\n# LOCALIZATION NOTE (selfxss.msg): the string to be typed\n# in by a new user of the developer tools when they receive the sefxss.msg prompt.\n# Please avoid using non-keyboard characters here\nselfxss.okstring=allow pasting\n\n# LOCALIZATION NOTE (messageToggleDetails): the text that is displayed when\n# you hover the arrow for expanding/collapsing the message details. For\n# console.error() and other messages we show the stacktrace.\nmessageToggleDetails=Show/hide message details.\n\n# LOCALIZATION NOTE (emptySlotLabel): the text is displayed when an Array\n# with empty slots is printed to the console.\n# This is a semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of empty slots\n# example: 1 empty slot\n# example: 5 empty slots\nemptySlotLabel=#1 empty slot;#1 empty slots\n\n# LOCALIZATION NOTE (table.index, table.iterationIndex, table.key, table.value):\n# the column header displayed in the console table widget.\ntable.index=(index)\ntable.iterationIndex=(iteration index)\ntable.key=Key\ntable.value=Values\n\n# LOCALIZATION NOTE (severity.error, severity.warn, severity.info, severity.log):\n# tooltip for icons next to console output\nseverity.error=Error\nseverity.warn=Warning\nseverity.info=Info\nseverity.log=Log\n\n# LOCALIZATION NOTE (level.error, level.warn, level.info, level.log, level.debug):\n# tooltip for icons next to console output\nlevel.error=Error\nlevel.warn=Warning\nlevel.info=Info\nlevel.log=Log\nlevel.debug=Debug\n\n# LOCALIZATION NOTE (webconsole.find.key)\n# Key shortcut used to focus the search box on upper right of the console\nwebconsole.find.key=CmdOrCtrl+F\n\n# LOCALIZATION NOTE (webconsole.close.key)\n# Key shortcut used to close the Browser console (doesn't work in regular web console)\nwebconsole.close.key=CmdOrCtrl+W\n\n# LOCALIZATION NOTE (webconsole.clear.key*)\n# Key shortcut used to clear the console output\nwebconsole.clear.key=Ctrl+Shift+L\nwebconsole.clear.keyOSX=Ctrl+L\n"

/***/ },
/* 102 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ntitle_noApp=Firefox WebIDE\ntitle_app=Firefox WebIDE: %S\n\nruntimeButton_label=Select Runtime\nprojectButton_label=Open App\n\nmainProcess_label=Main Process\n\nlocal_runtime=Local Runtime\nremote_runtime=Remote Runtime\nremote_runtime_promptTitle=Remote Runtime\nremote_runtime_promptMessage=hostname:port\n\nimportPackagedApp_title=Select Directory\nimportHostedApp_title=Open Hosted App\nimportHostedApp_header=Enter Manifest URL\n\nselectCustomBinary_title=Select custom B2G binary\nselectCustomProfile_title=Select custom Gaia profile\n\nnotification_showTroubleShooting_label=Troubleshooting\nnotification_showTroubleShooting_accesskey=T\n\n# LOCALIZATION NOTE (project_tab_loading): This is shown as a temporary tab\n# title for browser tab projects when the tab is still loading.\nproject_tab_loading=Loading…\n\n# These messages appear in a notification box when an error occur.\n\nerror_cantInstallNotFullyConnected=Can’t install project. Not fully connected.\nerror_cantInstallValidationErrors=Can’t install project. Validation errors.\nerror_listRunningApps=Can’t get app list from device\n\n# Variable: name of the operation (in english)\nerror_operationTimeout=Operation timed out: %1$S\nerror_operationFail=Operation failed: %1$S\n\n# Variable: app name\nerror_cantConnectToApp=Can’t connect to app: %1$S\n\n# Variable: error message (in english)\nerror_cantFetchAddonsJSON=Can’t fetch the add-on list: %S\n\nerror_appProjectsLoadFailed=Unable to load project list. This can occur if you’ve used this profile with a newer version of Firefox.\nerror_folderCreationFailed=Unable to create project folder in the selected directory.\n\n# Variable: runtime app build ID (looks like this %Y%M%D format) and firefox build ID (same format)\nerror_runtimeVersionTooRecent=The connected runtime has a more recent build date (%1$S) than your desktop Firefox (%2$S) does. This is an unsupported setup and may cause DevTools to fail. Please update Firefox.\n\naddons_stable=stable\naddons_unstable=unstable\n# LOCALIZATION NOTE (addons_simulator_label): This label is shown as the name of\n# a given simulator version in the \"Manage Simulators\" pane.  %1$S: Firefox OS\n# version in the simulator, ex. 1.3.  %2$S: Simulator stability label, ex.\n# \"stable\" or \"unstable\".\naddons_simulator_label=Firefox OS %1$S Simulator (%2$S)\naddons_install_button=install\naddons_uninstall_button=uninstall\naddons_adb_label=ADB Helper Add-on\naddons_adapters_label=Tools Adapters Add-on\naddons_adb_warning=USB devices won’t be detected without this add-on\naddons_status_unknown=?\naddons_status_installed=Installed\naddons_status_uninstalled=Not Installed\naddons_status_preparing=preparing\naddons_status_downloading=downloading\naddons_status_installing=installing\n\nruntimedetails_checkno=no\nruntimedetails_checkyes=yes\nruntimedetails_checkunknown=unknown (requires ADB Helper 0.4.0 or later)\nruntimedetails_notUSBDevice=Not a USB device\n\n# Validation status\nstatus_tooltip=Validation status: %1$S\nstatus_valid=VALID\nstatus_warning=WARNINGS\nstatus_error=ERRORS\nstatus_unknown=UNKNOWN\n\n# Device preferences and settings\ndevice_reset_default=Reset to default\n\n# Simulator options\nsimulator_custom_device=Custom\nsimulator_custom_binary=Custom B2G binary…\nsimulator_custom_profile=Custom Gaia profile…\nsimulator_default_profile=Use default\n"

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./aboutProfiles.properties": 104,
		"./aboutReader.properties": 105,
		"./aboutServiceWorkers.properties": 106,
		"./aboutSupport.properties": 107,
		"./aboutTelemetry.properties": 108,
		"./aboutWebrtc.properties": 109,
		"./autocomplete.properties": 110,
		"./browser.properties": 111,
		"./charsetMenu.properties": 112,
		"./commonDialogs.properties": 113,
		"./config.properties": 114,
		"./console.properties": 115,
		"./contentAreaCommands.properties": 116,
		"./customizeToolbar.properties": 117,
		"./dateFormat.properties": 118,
		"./dialog.properties": 119,
		"./extensions.properties": 120,
		"./fallbackMenubar.properties": 121,
		"./filefield.properties": 122,
		"./filepicker.properties": 123,
		"./findbar.properties": 124,
		"./finddialog.properties": 125,
		"./headsUpDisplay.properties": 126,
		"./intl.properties": 127,
		"./keys.properties": 128,
		"./languageNames.properties": 129,
		"./narrate.properties": 130,
		"./nsTreeSorting.properties": 131,
		"./printdialog.properties": 132,
		"./regionNames.properties": 133,
		"./resetProfile.properties": 134,
		"./viewSource.properties": 135,
		"./wizard.properties": 136
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 103;


/***/ },
/* 104 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nname = Profile: %S\nisDefault = Default Profile\nrootDir = Root Directory\n# LOCALIZATION NOTE: localDir is used to show the directory corresponding to\n# the main profile directory that exists for the purpose of storing data on the\n# local filesystem, including cache files or other data files that may not\n# represent critical user data. (e.g., this directory may not be included as\n# part of a backup scheme.)\n# In case localDIr and rootDir are equal, localDir is not shown.\nlocalDir = Local Directory\ncurrentProfile = This is the profile in use and it cannot be deleted.\n\nrename = Rename\nremove = Remove\nsetAsDefault = Set as default profile\nlaunchProfile = Launch profile in new browser\n\nyes = yes\nno = no\n\nrenameProfileTitle = Rename Profile\nrenameProfile = Rename profile %S\n\ninvalidProfileNameTitle = Invalid profile name\ninvalidProfileName = The profile name “%S” is not allowed.\n\ndeleteProfileTitle = Delete Profile\ndeleteProfileConfirm = Deleting a profile will remove the profile from the list of available profiles and cannot be undone.\\nYou may also choose to delete the profile data files, including your settings, certificates and other user-related data. This option will delete the folder “%S” and cannot be undone.\\nWould you like to delete the profile data files?\ndeleteFiles = Delete Files\ndontDeleteFiles = Don’t Delete Files\n\nopenDir = Open Directory\n# LOCALIZATION NOTE (macOpenDir): This is the Mac-specific variant of openDir.\n# This allows us to use the preferred\"Finder\" terminology on Mac.\nmacOpenDir = Show in Finder\n# LOCALIZATION NOTE (winOpenDir): This is the Windows-specific variant of\n# openDir.\nwinOpenDir = Show Folder\n"

/***/ },
/* 105 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#LOCALIZATION NOTE (aboutReader.loading2):\n# Use the unicode ellipsis char, \\u2026,\n# or use \"...\" if \\u2026 doesn't suit traditions in your locale.\naboutReader.loading2=Loading…\naboutReader.loadError=Failed to load article from page\n\naboutReader.colorScheme.light=Light\naboutReader.colorScheme.dark=Dark\naboutReader.colorScheme.sepia=Sepia\naboutReader.colorScheme.auto=Auto\n\n# LOCALIZATION NOTE (aboutReader.fontType.serif, aboutReader.fontType.sans-serif):\n# These are the styles of typeface that are options in the reader view controls.\naboutReader.fontType.serif=Serif\naboutReader.fontType.sans-serif=Sans-serif\n\n# LOCALIZATION NOTE (aboutReader.fontTypeSample): String used to sample font types.\naboutReader.fontTypeSample=Aa\n\naboutReader.toolbar.close=Close Reader View\naboutReader.toolbar.typeControls=Type controls\n\n# These are used for the Reader View toolbar button and the menuitem within the\n# View menu.\nreaderView.enter=Enter Reader View\nreaderView.enter.accesskey=R\nreaderView.close=Close Reader View\nreaderView.close.accesskey=R\n"

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ntitle = Origin: %S\n\n# LOCALIZATION NOTE: %1$S is brandShortName, %2$2 is the application ID, and $%$3 is true/false value.\n# LOCALIZATION NOTE: the term \"InBrowserElement\" should not be translated\nb2gtitle = %1$S Application ID %2$S - InBrowserElement %3$S\n\nscope = Scope:\n\nscriptSpec = Script Spec:\n\n# LOCALIZATION NOTE: the term \"Worker\" should not be translated.\ncurrentWorkerURL = Current Worker URL:\n\nactiveCacheName = Active Cache Name:\n\nwaitingCacheName = Waiting Cache Name:\n\ntrue = true\n\nfalse = false\n\n# LOCALIZATION NOTE this term is used as a button label (verb, not noun).\nupdate = Update\n\nunregister = Unregister\n\nwaiting = Waiting…\n\n# LOCALIZATION NOTE: the term \"Service Worker\" should not translated.\nunregisterError = Failed to unregister this Service Worker.\n\npushEndpoint = Push Endpoint:\n"

/***/ },
/* 107 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (downloadsTitleFiles): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of relevant days with crash reports\ncrashesTitle=Crash Reports for the Last #1 Day;Crash Reports for the Last #1 Days\n\n# LOCALIZATION NOTE (crashesTimeMinutes): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of minutes (between 1 and 59) which have passed since the crash\ncrashesTimeMinutes=#1 minute ago;#1 minutes ago\n\n# LOCALIZATION NOTE (crashesTimeHours): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of hours (between 1 and 23) which have passed since the crash\ncrashesTimeHours=#1 hour ago;#1 hours ago\n\n# LOCALIZATION NOTE (crashesTimeDays): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of days (1 or more) which have passed since the crash\ncrashesTimeDays=#1 day ago;#1 days ago\n\n# LOCALIZATION NOTE (downloadsTitleFiles): Semi-colon list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 number of pending crash reports\npendingReports=All Crash Reports (including #1 pending crash in the given time range);All Crash Reports (including #1 pending crashes in the given time range)\n\n# LOCALIZATION NOTE (rawDataCopied) Text displayed in a mobile \"Toast\" to user when the\n# raw data is successfully copied to the clipboard via button press.\nrawDataCopied=Raw data copied to clipboard\n\n# LOCALIZATION NOTE (textCopied) Text displayed in a mobile \"Toast\" to user when the\n# text is successfully copied to the clipboard via button press.\ntextCopied=Text copied to clipboard\n\n# LOCALIZATION NOTE The verb \"blocked\" here refers to a graphics feature such as \"Direct2D\" or \"OpenGL layers\".\nblockedDriver = Blocked for your graphics driver version.\n\n# LOCALIZATION NOTE The %S here is a placeholder, leave unchanged, it will get replaced by the driver version string.\ntryNewerDriver = Blocked for your graphics driver version. Try updating your graphics driver to version %S or newer.\n\n# LOCALIZATION NOTE The verb \"blocked\" here refers to a graphics feature such as \"Direct2D\" or \"OpenGL layers\".\nblockedGfxCard = Blocked for your graphics card because of unresolved driver issues.\n\n# LOCALIZATION NOTE The verb \"blocked\" here refers to a graphics feature such as \"Direct2D\" or \"OpenGL layers\".\nblockedOSVersion = Blocked for your operating system version.\n\n# LOCALIZATION NOTE The verb \"blocked\" here refers to a graphics feature such as \"Direct2D\" or \"OpenGL layers\".\nblockedMismatchedVersion = Blocked for your graphics driver version mismatch between registry and DLL.\n\n# LOCALIZATION NOTE In the following strings, \"Direct2D\", \"DirectWrite\" and \"ClearType\"\n# are proper nouns and should not be translated. Feel free to leave english strings if\n# there are no good translations, these are only used in about:support\nclearTypeParameters = ClearType Parameters\n\ncompositing = Compositing\nhardwareH264 = Hardware H264 Decoding\naudioBackend = Audio Backend\nmainThreadNoOMTC = main thread, no OMTC\nyes = Yes\nno = No\n\ngpuDescription = Description\ngpuVendorID = Vendor ID\ngpuDeviceID = Device ID\ngpuSubsysID = Subsys ID\ngpuDrivers = Drivers\ngpuRAM = RAM\ngpuDriverVersion = Driver Version\ngpuDriverDate = Driver Date\ngpuActive = Active\nwebglRenderer = WebGL Renderer\nwebgl2Renderer = WebGL2 Renderer\nGPU1 = GPU #1\nGPU2 = GPU #2\nblocklistedBug = Blocklisted due to known issues\n# LOCALIZATION NOTE %1$S will be replaced with a bug number string.\nbugLink = bug %1$S\n# LOCALIZATION NOTE %1$S will be replaced with an arbitrary identifier\n# string that can be searched on DXR/MXR or grepped in the source tree.\nunknownFailure = Blocklisted; failure code %1$S\nd3d11layersCrashGuard = D3D11 Compositor\nd3d11videoCrashGuard = D3D11 Video Decoder\nd3d9videoCrashGuard = D3D9 Video Decoder\nglcontextCrashGuard = OpenGL\nresetOnNextRestart = Reset on Next Restart\n\nminLibVersions = Expected minimum version\nloadedLibVersions = Version in use\n\nhasSeccompBPF = Seccomp-BPF (System Call Filtering)\nhasSeccompTSync = Seccomp Thread Synchronization\nhasUserNamespaces = User Namespaces\nhasPrivilegedUserNamespaces = User Namespaces for privileged processes\ncanSandboxContent = Content Process Sandboxing\ncanSandboxMedia = Media Plugin Sandboxing\ncontentSandboxLevel = Content Process Sandbox Level\n\n# LOCALIZATION NOTE %1$S and %2$S will be replaced with the number of remote and the total number\n# of windows, respectively, while %3$S will be replaced with one of the status strings below,\n# which contains a description of the multi-process preference and status.\n# Note: multiProcessStatus.3 doesn't exist because status=3 was deprecated.\nmultiProcessWindows = %1$S/%2$S (%3$S)\nmultiProcessStatus.0 = Enabled by user\nmultiProcessStatus.1 = Enabled by default\nmultiProcessStatus.2 = Disabled\nmultiProcessStatus.4 = Disabled by accessibility tools\nmultiProcessStatus.5 = Disabled by lack of graphics hardware acceleration on Mac OS X\nmultiProcessStatus.6 = Disabled by unsupported text input\nmultiProcessStatus.7 = Disabled by add-ons\nmultiProcessStatus.8 = Disabled forcibly\nmultiProcessStatus.9 = Disabled by graphics hardware acceleration on Windows XP\nmultiProcessStatus.unknown = Unknown status\n\nasyncPanZoom = Asynchronous Pan/Zoom\napzNone = none\nwheelEnabled = wheel input enabled\ntouchEnabled = touch input enabled\ndragEnabled = scrollbar drag enabled\n\n# LOCALIZATION NOTE %1 will be replaced with the key of a preference.\nwheelWarning = async wheel input disabled due to unsupported pref: %S\ntouchWarning = async touch input disabled due to unsupported pref: %S\n"

/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# Note to translators:\n# - %1$S will be replaced by brandFullName\n# - %2$S will be replaced with the value of the toolkit.telemetry.server_owner preference\npageSubtitle = This page shows the information about performance, hardware, usage and customizations collected by Telemetry. This information is submitted to %1$S to help improve %2$S.\n\ngeneralDataTitle = General Data\n\ngeneralDataHeadingName = Name\n\ngeneralDataHeadingValue = Value\n\nenvironmentDataHeadingName = Name\n\nenvironmentDataHeadingValue = Value\n\nenvironmentDataSubsectionToggle = Click to toggle section\n\nenvironmentDataSubsectionEmpty = (No data collected)\n\ntelemetryLogTitle = Telemetry Log\n\ntelemetryLogHeadingId = Id\n\ntelemetryLogHeadingTimestamp = Timestamp\n\ntelemetryLogHeadingData = Data\n\nslowSqlMain = Slow SQL Statements on Main Thread\n\nslowSqlOther = Slow SQL Statements on Helper Threads\n\nslowSqlHits = Hits\n\nslowSqlAverage = Avg. Time (ms)\n\nslowSqlStatement = Statement\n\n# Note to translators:\n# - The %1$S will be replaced with the number of the hang\n# - The %2$S will be replaced with the duration of the hang\nchrome-hangs-title = Hang Report #%1$S (%2$S seconds)\n\n# Note to translators:\n# - The %1$S will be replaced with the number of the late write\nlate-writes-title = Late Write #%1$S\n\nstackTitle = Stack:\n\nmemoryMapTitle = Memory map:\n\nerrorFetchingSymbols = An error occurred while fetching symbols. Check that you are connected to the Internet and try again.\n\nhistogramSamples = samples\n\nhistogramAverage = average\n\nhistogramSum = sum\n\nhistogramCopy = Copy\n\nkeysHeader = Property\n\nnamesHeader = Name\n\nvaluesHeader = Value\n\naddonTableID = Add-on ID\n\naddonTableDetails = Details\n\n# Note to translators:\n# - The %1$S will be replaced with the name of an Add-on Provider (e.g. \"XPI\", \"Plugin\")\naddonProvider = %1$S Provider\n\nparentPayload = Parent Payload\n\n# Note to translators:\n# - The %1$S will be replaced with the number of the child payload (e.g. \"1\", \"2\")\nchildPayloadN = Child Payload %1$S\n"

/***/ },
/* 109 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (document_title, cannot_retrieve_log):\n# The text \"WebRTC\" is a proper noun and should not be translated.\n# It is the general label for the standards based technology. see http://www.webrtc.org\ndocument_title = WebRTC Internals\ncannot_retrieve_log = Cannot retrieve WebRTC log data\n\n# LOCALIZATION NOTE (save_page_msg):\n# %1$S will be replaced by a full path file name: the target of the SavePage operation.\nsave_page_msg = page saved to: %1$S\n\n# LOCALIZATION NOTE (save_page_dialog_title): \"about:webrtc\" is a internal browser URL and should not be\n# translated. This string is used as a title for a file save dialog box.\nsave_page_dialog_title = save about:webrtc as\n\n# LOCALIZATION NOTE (debug_mode_off_state_msg):\n# %1$S will be replaced by the full path file name of the debug log.\ndebug_mode_off_state_msg = trace log can be found at: %1$S\n\n# LOCALIZATION NOTE (debug_mode_on_state_msg):\n# %1$S will be replaced by the full path file name of the debug log.\ndebug_mode_on_state_msg = debug mode active, trace log at: %1$S\n\n# LOCALIZATION NOTE (aec_logging_msg_label, aec_logging_off_state_label,\n# aec_logging_on_state_label, aec_logging_on_state_msg):\n# AEC is an abbreviation for Acoustic Echo Cancellation.\naec_logging_msg_label = AEC Logging\naec_logging_off_state_label = Start AEC Logging\naec_logging_on_state_label = Stop AEC Logging\naec_logging_on_state_msg = AEC logging active (speak with the caller for a few minutes and then stop the capture)\n\n# LOCALIZATION NOTE (aec_logging_off_state_msg):\n# %1$S will be replaced by the full path to the directory containing the captured log files.\n# AEC is an abbreviation for Acoustic Echo Cancellation.\naec_logging_off_state_msg = captured log files can be found in: %1$S\n\n# LOCALIZATION NOTE (peer_connection_id_label): \"PeerConnection\" is a proper noun\n# associated with the WebRTC module. \"ID\" is an abbreviation for Identifier. This string\n# should not normally be translated and is used as a data label.\npeer_connection_id_label = PeerConnection ID\n\n# LOCALIZATION NOTE (sdp_heading, local_sdp_heading, remote_sdp_heading):\n# \"SDP\" is an abbreviation for Session Description Protocol, an IETF standard.\n# See http://wikipedia.org/wiki/Session_Description_Protocol\nsdp_heading = SDP\nlocal_sdp_heading = Local SDP\nremote_sdp_heading = Remote SDP\n\n# LOCALIZATION NOTE (rtp_stats_heading): \"RTP\" is an abbreviation for the\n# Real-time Transport Protocol, an IETF specification, and should not\n# normally be translated. \"Stats\" is an abbreviation for Statistics.\nrtp_stats_heading = RTP Stats\n\n# LOCALIZATION NOTE (ice_state, ice_stats_heading): \"ICE\" is an abbreviation\n# for Interactive Connectivity Establishment, which is an IETF protocol,\n# and should not normally be translated. \"Stats\" is an abbreviation for\n# Statistics.\nice_state = ICE State\nice_stats_heading = ICE Stats\n\n# LOCALIZATION NOTE (av_sync_label): \"A/V\" stands for Audio/Video.\n# \"sync\" is an abbreviation for sychronization. This is used as\n# a data label.\nav_sync_label = A/V sync\n\n# LOCALIZATION NOTE (jitter_buffer_delay_label): A jitter buffer is an\n# element in the processing chain, see http://wikipedia.org/wiki/Jitter\n# This is used as a data label.\njitter_buffer_delay_label = Jitter-buffer delay\n\n# LOCALIZATION NOTE (avg_bitrate_label, avg_framerate_label): \"Avg.\" is an abbreviation\n# for Average. These are used as data labels.\navg_bitrate_label = Avg. bitrate\navg_framerate_label = Avg. framerate\n\n# LOCALIZATION NOTE (typeLocal, typeRemote): These adjectives are used to label a\n# line of statistics collected for a peer connection. The data represents\n# either the local or remote end of the connection.\ntypeLocal = Local\ntypeRemote = Remote\n\n# LOCALIZATION NOTE (nominated): This adjective is used to label a table column.\n# Cells in this column contain the localized javascript string representation of \"true\"\n# or are left blank.\nnominated = Nominated\n\n# LOCALIZATION NOTE (selected): This adjective is used to label a table column.\n# Cells in this column contain the localized javascript string representation of \"true\"\n# or are left blank. This represents an attribute of an ICE candidate.\nselected = Selected\n\nsave_page_label = Save Page\ndebug_mode_msg_label = Debug Mode\ndebug_mode_off_state_label = Start Debug Mode\ndebug_mode_on_state_label = Stop Debug Mode\nstats_heading = Session Statistics\nlog_heading = Connection Log\nlog_show_msg = show log\nlog_hide_msg = hide log\nconnection_closed = closed\nlocal_candidate = Local Candidate\nremote_candidate = Remote Candidate\npriority = Priority\nfold_show_msg = show details\nfold_show_hint = click to expand this section\nfold_hide_msg = hide details\nfold_hide_hint = click to collapse this section\ndropped_frames_label = Dropped frames\ndiscarded_packets_label = Discarded packets\ndecoder_label = Decoder\nencoder_label = Encoder\nreceived_label = Received\npackets = packets\nlost_label = Lost\njitter_label = Jitter\nsent_label = Sent\n\n"

/***/ },
/* 110 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (searchWithEngine): %S will be replaced with\n# the search engine provider's name. This format was chosen because\n# the provider can also end with \"Search\" (e.g.: MSN Search).\nsearchWithEngine = Search with %S\n\n# LOCALIZATION NOTE (switchToTab2): This is the same as the older switchToTab\n# string that it's replacing, except it uses title case, so \"Switch\" and \"Tab\"\n# are capitalized.\nswitchToTab2 = Switch to Tab\n\n# LOCALIZATION NOTE (visit): This is shown next to autocomplete entries that are\n# simple URLs or sites, which will be visited when the user selects them.\nvisit = Visit\n\n# LOCALIZATION NOTE (bookmarkKeywordSearch): This is the title of autocomplete\n# entries that are bookmark keyword searches.  %1$S will be replaced with the\n# domain name of the bookmark, and %2$S will be replaced with the keyword\n# search text that the user is typing.  %2$S will not be empty.\nbookmarkKeywordSearch = %1$S: %2$S\n"

/***/ },
/* 111 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nbrowsewithcaret.checkMsg=Do not show me this dialog box again.\nbrowsewithcaret.checkWindowTitle=Caret Browsing\nbrowsewithcaret.checkLabel=Pressing F7 turns Caret Browsing on or off. This feature places a moveable cursor in web pages, allowing you to select text with the keyboard. Do you want to turn Caret Browsing on?\nbrowsewithcaret.checkButtonLabel=Yes\n\nplainText.wordWrap=Wrap Long Lines\n\nformPostSecureToInsecureWarning.title = Security Warning\nformPostSecureToInsecureWarning.message = The information you have entered on this page will be sent over an insecure connection and could be read by a third party.\\n\\nAre you sure you want to send this information?\nformPostSecureToInsecureWarning.continue = Continue\n"

/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE: The property keys ending with \".key\" are for access keys.\n# Localizations may add or delete properties where the property key ends with\n# \".key\" as appropriate for the localization. The code that uses this data can\n# deal with the absence of an access key for an item.\n#\n# For gbk, gbk.bis and gbk.bis.key are used to trigger string changes in\n# localizations.\n#\n# In the en-US version of this file, access keys are given to the following:\n# * UTF-8\n# * All encodings that are the fallback encoding for some locale in Firefox\n# * All encodings that are the fallback encoding for some locale in IE\n# * All Japanese encodings\n#\n# For the items whose property key does not end in \".key\" and whose value\n# includes \"(\" U+0028 LEFT PARENTHESIS, the \"(\" character is significant for\n# processing by CharsetMenu.jsm. If your localization does not use ASCII\n# parentheses where en-US does in this file, please file a bug to make\n# CharsetMenu.jsm also recognize the delimiter your localization uses.\n# (When this code was developed, all localizations appeared to use\n# U+0028 LEFT PARENTHESIS for this purpose.)\n\n# Auto-Detect (sub)menu\ncharsetMenuCharsets = Character Encoding\ncharsetMenuAutodet = Auto-Detect\n# 'A' is reserved for Arabic:\ncharsetMenuAutodet.key = D\ncharsetMenuAutodet.off = (off)\ncharsetMenuAutodet.off.key = o\ncharsetMenuAutodet.ja = Japanese\ncharsetMenuAutodet.ja.key = J\ncharsetMenuAutodet.ru = Russian\ncharsetMenuAutodet.ru.key = R\ncharsetMenuAutodet.uk = Ukrainian\ncharsetMenuAutodet.uk.key = U\n\n# Globally-relevant\nUTF-8.key        = U\nUTF-8            = Unicode\nwindows-1252.key = W\nwindows-1252     = Western\n\n# Arabic\nwindows-1256.key = A\nwindows-1256     = Arabic (Windows)\nISO-8859-6       = Arabic (ISO)\n\n# Baltic\nwindows-1257.key = B\nwindows-1257     = Baltic (Windows)\nISO-8859-4       = Baltic (ISO)\n\n# Central European\nwindows-1250.key =         E\nwindows-1250     = Central European (Windows)\nISO-8859-2.key   =       l\nISO-8859-2       = Central European (ISO)\n\n# Chinese, Simplified\ngbk.bis.key      =          S\ngbk.bis          = Chinese, Simplified\n\n# Chinese, Traditional\nBig5.key         =          T\nBig5             = Chinese, Traditional\n\n# Cyrillic\nwindows-1251.key = C\nwindows-1251     = Cyrillic (Windows)\nISO-8859-5       = Cyrillic (ISO)\nKOI8-R           = Cyrillic (KOI8-R)\nKOI8-U           = Cyrillic (KOI8-U)\nIBM866           = Cyrillic (DOS)\n\n# Greek\nwindows-1253.key = G\nwindows-1253     = Greek (Windows)\nISO-8859-7.key   =          O\nISO-8859-7       = Greek (ISO)\n\n# Hebrew\nwindows-1255.key = H\nwindows-1255     = Hebrew\n# LOCALIZATION NOTE (ISO-8859-8): The value for this item should begin with\n# the same word for Hebrew as the value for windows-1255 so that this item \n# sorts right after that one in the collation order for your locale.\nISO-8859-8       = Hebrew, Visual\n\n# Japanese\nShift_JIS.key    = J\nShift_JIS        = Japanese (Shift_JIS)\nEUC-JP.key       =   p\nEUC-JP           = Japanese (EUC-JP)\nISO-2022-JP.key  =     n\nISO-2022-JP      = Japanese (ISO-2022-JP)\n\n# Korean\nEUC-KR.key       = K\nEUC-KR           = Korean\n\n# Thai\nwindows-874.key  =    i\nwindows-874      = Thai\n\n# Turkish\nwindows-1254.key =   r\nwindows-1254     = Turkish\n\n# Vietnamese\nwindows-1258.key = V\nwindows-1258     = Vietnamese\n\n"

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nAlert=Alert\nConfirm=Confirm\nConfirmCheck=Confirm\nPrompt=Prompt\nPromptUsernameAndPassword2=Authentication Required\nPromptPassword2=Password Required\nSelect=Select\nOK=OK\nCancel=Cancel\nYes=&Yes\nNo=&No\nSave=&Save\nRevert=&Revert\nDontSave=Do&n’t Save\nScriptDlgGenericHeading=[JavaScript Application]\nScriptDlgHeading=The page at %S says:\nScriptDialogLabel=Prevent this page from creating additional dialogs\nScriptDialogPreventTitle=Confirm Dialog Preference\n# LOCALIZATION NOTE (EnterLoginForRealm2, EnterLoginForProxy2):\n# %1 is an untrusted string provided by a remote server. It could try to\n# take advantage of sentence structure in order to mislead the user (see\n# bug 244273). %1 should be integrated into the translated sentences as\n# little as possible. %2 is the url of the site being accessed.\nEnterLoginForRealm2=%2$S is requesting your username and password.\\n\\nThe site says: “%1$S”\nEnterLoginForProxy2=The proxy %2$S is requesting a username and password.\\n\\nThe site says: “%1$S”\nEnterUserPasswordFor2=%1$S is requesting your username and password.\nEnterUserPasswordForCrossOrigin=%1$S is requesting your username and password.\\n\\nWARNING: Your password will not be sent to the website you are currently visiting!\nEnterPasswordFor=Enter password for %1$S on %2$S\n"

/***/ },
/* 114 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# Lock column values\ndefault=default\nuser=user set\nlocked=locked\n\n# Type column values\nstring=string\nint=integer\nbool=boolean\n\n# Preference prompts\n# %S is replaced by one of the type column values above\nnew_title=New %S value\nnew_prompt=Enter the preference name\nmodify_title=Enter %S value\n\nnan_title=Invalid value\nnan_text=The text you entered is not a number.\n"

/***/ },
/* 115 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ntypeError=Error:\ntypeWarning=Warning:\ntypeMessage=Message:\nerrFile=Source File: %S\nerrLine=Line: %S\nerrLineCol=Line: %S, Column: %S\nerrCode=Source Code:\nerrTime=Timestamp: %S\n\n# LOCALIZATION NOTE (evaluationContextChanged): The message displayed when the\n# browser console's evaluation context (window against which input is evaluated)\n# changes.\nevaluationContextChanged=The console’s evaluation context changed, probably because the target window was closed or because you opened a main window from the browser console’s window.\n"

/***/ },
/* 116 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# context menu strings\n\nSaveImageTitle=Save Image\nSaveVideoTitle=Save Video\nSaveAudioTitle=Save Audio\nSaveLinkTitle=Save As\nDefaultSaveFileName=index\nWebPageCompleteFilter=Web Page, complete\nWebPageHTMLOnlyFilter=Web Page, HTML only\nWebPageXHTMLOnlyFilter=Web Page, XHTML only\nWebPageSVGOnlyFilter=Web Page, SVG only\nWebPageXMLOnlyFilter=Web Page, XML only\n\n# LOCALIZATION NOTE (filesFolder):\n#    This is the name of the folder that is created parallel to a HTML file \n#    when it is saved \"With Images\". The %S section is replaced with the\n#    leaf name of the file being saved (minus extension).\nfilesFolder=%S_files\n"

/***/ },
/* 117 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nenterToolbarTitle=New Toolbar\nenterToolbarName=Enter a name for this toolbar:\nenterToolbarDup=There is already a toolbar with the name “%S”. Please enter a different name.\nenterToolbarBlank=You must enter a name to create a new toolbar.\nseparatorTitle=Separator\nspringTitle=Flexible Space\nspacerTitle=Space\n"

/***/ },
/* 118 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nmonth.1.Mmm=Jan\nmonth.2.Mmm=Feb\nmonth.3.Mmm=Mar\nmonth.4.Mmm=Apr\nmonth.5.Mmm=May\nmonth.6.Mmm=Jun\nmonth.7.Mmm=Jul\nmonth.8.Mmm=Aug\nmonth.9.Mmm=Sep\nmonth.10.Mmm=Oct\nmonth.11.Mmm=Nov\nmonth.12.Mmm=Dec\n\nmonth.1.name=January\nmonth.2.name=February\nmonth.3.name=March\nmonth.4.name=April\nmonth.5.name=May\nmonth.6.name=June\nmonth.7.name=July\nmonth.8.name=August\nmonth.9.name=September\nmonth.10.name=October\nmonth.11.name=November\nmonth.12.name=December\n\nday.1.name=Sunday\nday.2.name=Monday\nday.3.name=Tuesday\nday.4.name=Wednesday\nday.5.name=Thursday\nday.6.name=Friday\nday.7.name=Saturday\n\nday.1.Mmm=Sun\nday.2.Mmm=Mon\nday.3.Mmm=Tue\nday.4.Mmm=Wed\nday.5.Mmm=Thu\nday.6.Mmm=Fri\nday.7.Mmm=Sat\n\nday.1.short=Su\nday.2.short=Mo\nday.3.short=Tu\nday.4.short=We\nday.5.short=Th\nday.6.short=Fr\nday.7.short=Sa\n\nnoon=Noon\nmidnight=Midnight\n\nAllDay=All Day\n"

/***/ },
/* 119 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nbutton-accept=OK\nbutton-cancel=Cancel\nbutton-help=Help\nbutton-disclosure=More Info\naccesskey-accept=\naccesskey-cancel=\naccesskey-help=H\naccesskey-disclosure=I\n"

/***/ },
/* 120 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ncsp.error.missing-directive = Policy is missing a required ‘%S’ directive\n\n#LOCALIZATION NOTE (csp.error.illegal-keyword) %1$S is the name of a CSP directive, such as \"script-src\". %2$S is the name of a CSP keyword, usually 'unsafe-inline'.\ncsp.error.illegal-keyword = ‘%1$S’ directive contains a forbidden %2$S keyword\n\n#LOCALIZATION NOTE (csp.error.illegal-protocol) %2$S a protocol name, such as \"http\", which appears as \"http:\", as it would in a URL.\ncsp.error.illegal-protocol = ‘%1$S’ directive contains a forbidden %2$S: protocol source\n\n#LOCALIZATION NOTE (csp.error.missing-host) %2$S a protocol name, such as \"http\", which appears as \"http:\", as it would in a URL.\ncsp.error.missing-host = %2$S: protocol requires a host in ‘%1$S’ directives\n\n#LOCALIZATION NOTE (csp.error.missing-source) %1$S is the name of a CSP directive, such as \"script-src\". %2$S is the name of a CSP source, usually 'self'.\ncsp.error.missing-source = ‘%1$S’ must include the source %2$S\n\n#LOCALIZATION NOTE (csp.error.illegal-host-wildcard) %2$S a protocol name, such as \"http\", which appears as \"http:\", as it would in a URL.\ncsp.error.illegal-host-wildcard = %2$S: wildcard sources in ‘%1$S’ directives must include at least one non-generic sub-domain (e.g., *.example.com rather than *.com)\n"

/***/ },
/* 121 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# OSX only. Default menu label when there is no xul menubar.\n\nquitMenuitem.label=Quit\nquitMenuitem.key=q\n"

/***/ },
/* 122 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n#### Change Action\n\ndownloadHelperNoneSelected=None Selected\n"

/***/ },
/* 123 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE: The extensions to which these descriptions refer\n#                    now live in toolkit/content/filepicker.properties\nallTitle=All Files\nhtmlTitle=HTML Files\ntextTitle=Text Files\nimageTitle=Image Files\nxmlTitle=XML Files\nxulTitle=XUL Files\nappsTitle=Applications\naudioTitle=Audio Files\nvideoTitle=Video Files\n\ndirTextInputLabel=Directory name:\ndirTextInputAccesskey=n\n\nconfirmTitle=Confirm\nconfirmFileReplacing=%S already exists.\\nDo you want to replace it?\nopenButtonLabel=Open\nsaveButtonLabel=Save\nselectFolderButtonLabel=Select\nnoButtonLabel=No\nformatLabel=Format:\n\nerrorOpenFileDoesntExistTitle=Error opening %S\nerrorOpenFileDoesntExistMessage=File %S doesn’t exist\nerrorDirDoesntExistTitle=Error accessing %S\nerrorDirDoesntExistMessage=Directory %S doesn’t exist\n\nerrorOpeningFileTitle=Error opening %S\nopenWithoutPermissionMessage_file=File %S is not readable\n\nerrorSavingFileTitle=Error saving %S\nsaveParentIsFileMessage=%S is a file, can’t save %S\nsaveParentDoesntExistMessage=Path %S doesn’t exist, can’t save %S\n\nsaveWithoutPermissionMessage_file=File %S is not writable.\nsaveWithoutPermissionMessage_dir=Cannot create file. Directory %S is not writable.\n\nerrorNewDirDoesExistTitle=Error creating %S\nerrorNewDirDoesExistMessage=A file named %S already exists, directory cannot be created.\n\nerrorCreateNewDirTitle=Error creating %S\nerrorCreateNewDirMessage=Directory %S could not be created\nerrorCreateNewDirIsFileMessage=Directory cannot be created, %S is a file\nerrorCreateNewDirPermissionMessage=Directory cannot be created, %S not writable\n\npromptNewDirTitle=Create new directory\npromptNewDirMessage=Directory name:\n\nerrorPathProblemTitle=Unknown Error\nerrorPathProblemMessage=An unknown error occurred (path %S)\n"

/***/ },
/* 124 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# strings used by the Find bar, split from browser.properties\nNotFound=Phrase not found\nWrappedToTop=Reached end of page, continued from top\nWrappedToBottom=Reached top of page, continued from bottom\nNormalFind=Find in page\nFastFind=Quick find\nFastFindLinks=Quick find (links only)\nCaseSensitive=(Case sensitive)\nEntireWord=(Whole words only)\n# LOCALIZATION NOTE (FoundMatches): Semicolon-separated list of plural forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 is currently selected match and #2 the total amount of matches.\nFoundMatches=#1 of #2 match;#1 of #2 matches\n# LOCALIZATION NOTE (FoundMatchesCountLimit): Semicolon-separated list of plural\n# forms.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\n# #1 is the total amount of matches allowed before counting stops.\nFoundMatchesCountLimit=More than #1 match;More than #1 matches\n"

/***/ },
/* 125 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nnotFoundWarning=The text you entered was not found.\nnotFoundTitle=Find"

/***/ },
/* 126 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n\n# LOCALIZATION NOTE (stacktrace.anonymousFunction):\n# This string is used to display JavaScript functions that have no given name -\n# they are said to be anonymous. See stacktrace.outputMessage.\nstacktrace.anonymousFunction=<anonymous>\n\n# LOCALIZATION NOTE (stacktrace.outputMessage):\n# This string is used in the Web Console output to identify a web developer call\n# to console.trace(). The stack trace of JavaScript function calls is displayed.\n# In this minimal message we only show the last call.\nstacktrace.outputMessage=Stack trace from %S, function %S, line %S.\n"

/***/ },
/* 127 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE (general.useragent.locale):\n# This is the valid BCP 47 language tag representing your locale.\n#\n# In most cases, this will simply be your locale code. However, in rare cases\n# (such as 'jp-JP-mac'), you may need to modify your locale code in order to\n# make it a valid BCP 47 language tag. (If your locale code does not include a\n# region subtag, do not include one in the language tag representing your\n# locale.)\ngeneral.useragent.locale=en-US\n\n# LOCALIZATION NOTE (intl.accept_languages):\n# This is a comma-separated list of valid BCP 47 language tags.\n#\n# Begin with the value of 'general.useragent.locale'. Next, include language\n# tags for other languages that you expect most users of your locale to be\n# able to speak, so that their browsing experience degrades gracefully if\n# content is not available in their primary language.\n#\n# It is recommended that you include \"en-US, en\" at the end of the list as a\n# last resort. However, if you know that users of your locale would prefer a\n# different variety of English, or if they are not likely to understand\n# English at all, you may opt to include a different English language tag, or\n# to exclude English altogether.\n#\n# For example, the Breton [br] locale might consider including French and\n# British English in their list, since those languages are commonly spoken in\n# the same area as Breton:\n# intl.accept_languages=br, fr-FR, fr, en-GB, en\nintl.accept_languages=en-US, en\n\n# LOCALIZATION NOTE (font.language.group):\n# This preference controls the initial setting of the language drop-down menu\n# in the Content > Fonts & Colors > Advanced preference panel.\n#\n# Set it to the value of one of the menuitems in the \"selectLangs\" menulist in\n# http://dxr.mozilla.org/mozilla-central/source/browser/components/preferences/fonts.xul\nfont.language.group=x-western\n\n# LOCALIZATION NOTE (intl.charset.detector):\n# This preference controls the initial setting for the character encoding\n# detector. Valid values are ja_parallel_state_machine for Japanese, ruprob\n# for Russian and ukprob for Ukrainian and the empty string to turn detection\n# off. The value must be empty for locales other than Japanese, Russian and\n# Ukrainian.\nintl.charset.detector=\n\n# LOCALIZATION NOTE (pluralRule): Pick the appropriate plural rule for your\n# language. This will determine how many plural forms of a word you will need\n# to provide and in what order.\n# See: http://developer.mozilla.org/en/docs/Localization_and_Plurals\npluralRule=1\n\n# LOCALIZATION NOTE (intl.menuitems.alwaysappendaccesskeys, intl.menuitems.insertseparatorbeforeaccesskeys):\n# Valid values are: true, false, <empty string>\n# Missing preference or empty value equals false.\nintl.menuitems.alwaysappendaccesskeys=\nintl.menuitems.insertseparatorbeforeaccesskeys=true\n"

/***/ },
/* 128 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE : FILE This file contains the application's labels for keys on the keyboard.\n#                     If you decide to translate this file, you should translate it based on\n#                     the prevelant kind of keyboard for your target user.\n# LOCALIZATION NOTE : There are two types of keys, those w/ text on their labels\n#                     and those w/ glyphs.\n# LOCALIZATION NOTE : VK_<…> represents a key on the keyboard.\n#\n# For more information please see bugzilla bug 90888.\n\n# F1..F10 should probably not be translated unless there are keyboards that actually have other labels\n# F11..F20 might be something else, but are really keyboard specific and not region/language specific\n# there are actually two different F11/F12 keys, I don't know which one these labels represent.\n# eg, F13..F20 on a sparc keyboard are labeled Props, Again .. Find, Cut\n# sparc also has Stop, Again and F11/F12. VK_F11/VK_F12 probably map to Stop/Again\n# LOCALIZATION NOTE : BLOCK Do not translate the next block\nVK_F1=F1\nVK_F2=F2\nVK_F3=F3\nVK_F4=F4\nVK_F5=F5\nVK_F6=F6\nVK_F7=F7\nVK_F8=F8\nVK_F9=F9\nVK_F10=F10\n\nVK_F11=F11\nVK_F12=F12\nVK_F13=F13\nVK_F14=F14\nVK_F15=F15\nVK_F16=F16\nVK_F17=F17\nVK_F18=F18\nVK_F19=F19\nVK_F20=F20\n# LOCALIZATION NOTE : BLOCK end do not translate block\n\n# LOCALIZATION NOTE : BLOCK GLYPHS, DO translate this block\nVK_UP=Up Arrow\nVK_DOWN=Down Arrow\nVK_LEFT=Left Arrow\nVK_RIGHT=Right Arrow\nVK_PAGE_UP=Page Up\nVK_PAGE_DOWN=Page Down\n# LOCALIZATION NOTE : BLOCK end GLYPHS\n\n# Enter, backspace, and Tab might have both glyphs and text\n# if the keyboards usually have a glyph,\n# if there is a meaningful translation,\n# or if keyboards are localized\n# then translate them or insert the appropriate glyph\n# otherwise you should probably just translate the glyph regions\n\n# LOCALIZATION NOTE : BLOCK maybe GLYPHS\nVK_RETURN=Return\nVK_TAB=Tab\nVK_BACK=Backspace\nVK_DELETE=Del\n# LOCALIZATION NOTE : BLOCK end maybe GLYPHS\n# LOCALIZATION NOTE : BLOCK typing state keys\nVK_HOME=Home\nVK_END=End\n\nVK_ESCAPE=Esc\nVK_INSERT=Ins\n# LOCALIZATION NOTE : BLOCK end\n"

/***/ },
/* 129 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\naa = Afar\nab = Abkhazian\nae = Avestan\naf = Afrikaans\nak = Akan\nam = Amharic\nan = Aragonese\nar = Arabic\nas = Assamese\nast = Asturian\nav = Avaric\nay = Aymara\naz = Azerbaijani\nba = Bashkir\nbe = Belarusian\nbg = Bulgarian\nbh = Bihari\nbi = Bislama\nbm = Bambara\nbn = Bengali\nbo = Tibetan\nbr = Breton\nbs = Bosnian\nca = Catalan\nce = Chechen\nch = Chamorro\nco = Corsican\ncr = Cree\ncs = Czech\ncsb = Kashubian\ncu = Church Slavic\ncv = Chuvash\ncy = Welsh\nda = Danish\nde = German\ndsb = Lower Sorbian\ndv = Divehi\ndz = Dzongkha\nee = Ewe\nel = Greek\nen = English\neo = Esperanto\nes = Spanish\net = Estonian\neu = Basque\nfa = Persian\nff = Fulah\nfi = Finnish\nfj = Fijian\nfo = Faroese\nfr = French\nfur = Friulian\nfy = Frisian\nga = Irish\ngd = Scottish Gaelic\ngl = Galician\ngn = Guarani\ngu = Gujarati\ngv = Manx\nha = Hausa\nhaw = Hawaiian\nhe = Hebrew\nhi = Hindi\nhil = Hiligaynon\nho = Hiri Motu\nhr = Croatian\nhsb = Upper Sorbian\nht = Haitian\nhu = Hungarian\nhy = Armenian\nhz = Herero\nia = Interlingua\nid = Indonesian\nie = Interlingue\nig = Igbo\nii = Sichuan Yi\nik = Inupiaq\nio = Ido\nis = Icelandic\nit = Italian\niu = Inuktitut\nja = Japanese\njv = Javanese\nka = Georgian\nkg = Kongo\nki = Kikuyu\nkj = Kuanyama\nkk = Kazakh\nkl = Greenlandic\nkm = Khmer\nkn = Kannada\nko = Korean\nkok = Konkani\nkr = Kanuri\nks = Kashmiri\nku = Kurdish\nkv = Komi\nkw = Cornish\nky = Kirghiz\nla = Latin\nlb = Luxembourgish\nlg = Ganda\nli = Limburgan\nln = Lingala\nlo = Lao\nlt = Lithuanian\nlu = Luba-Katanga\nlv = Latvian\nmg = Malagasy\nmh = Marshallese\nmi = Maori\nmk = Macedonian\nml = Malayalam\nmn = Mongolian\nmr = Marathi\nms = Malay\nmt = Maltese\nmy = Burmese\nna = Nauru\nnb = Norwegian Bokm\\u00e5l\nnd = Ndebele, North\nne = Nepali\nng = Ndonga\nnl = Dutch\nnn = Norwegian Nynorsk\nno = Norwegian\nnr = Ndebele, South\nnso = Sotho, Northern\nnv = Navajo\nny = Chichewa\noc = Occitan\noj = Ojibwa\nom = Oromo\nor = Odia\nos = Ossetian\npa = Punjabi\npi = Pali\npl = Polish\nps = Pashto\npt = Portuguese\nqu = Quechua\nrm = Rhaeto-Romanic\nrn = Kirundi\nro = Romanian\nru = Russian\nrw = Kinyarwanda\nsa = Sanskrit\nsc = Sardinian\nsd = Sindhi\nse = Northern Sami\nsg = Sango\nsi = Singhalese\nsk = Slovak\nsl = Slovenian\nsm = Samoan\nsn = Shona\nso = Somali\nson = Songhay\nsq = Albanian\nsr = Serbian\nss = Siswati\nst = Sotho, Southern\nsu = Sundanese\nsv = Swedish\nsw = Swahili\nta = Tamil\nte = Telugu\ntg = Tajik\nth = Thai\nti = Tigrinya\ntig = Tigre\ntk = Turkmen\ntl = Tagalog\ntlh = Klingon\ntn = Tswana\nto = Tonga\ntr = Turkish\nts = Tsonga\ntt = Tatar\ntw = Twi\nty = Tahitian\nug = Uighur\nuk = Ukrainian\nur = Urdu\nuz = Uzbek\nve = Venda\nvi = Vietnamese\nvo = Volap\\u00fck\nwa = Walloon\nwen = Sorbian\nwo = Wolof\nxh = Xhosa\nyi = Yiddish\nyo = Yoruba\nza = Zhuang\nzh = Chinese\nzu = Zulu\n"

/***/ },
/* 130 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# Narrate, meaning \"read the page out loud\". This is the name of the feature\n# and it is the label for the popup button.\nnarrate = Narrate\nback = Back\nstart = Start\nstop = Stop\nforward = Forward\nspeed = Speed\nselectvoicelabel = Voice:\n# Default voice is determined by the language of the document.\ndefaultvoice = Default\n\n# Voice name and language.\n# eg. David (English)\nvoiceLabel = %S (%S)"

/***/ },
/* 131 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nSortMenuItems=Sorted by %COLNAME%\n"

/***/ },
/* 132 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# These strings are used in the native GTK, Mac and Windows print dialogs.\n\n# GTK titles:\nprintTitleGTK=Print\noptionsTabLabelGTK=Options\nprintFramesTitleGTK=Print Frames\n\n# Mac titles:\noptionsTitleMac=Options:\nappearanceTitleMac=Appearance:\nframesTitleMac=Frames:\npageHeadersTitleMac=Page Headers:\npageFootersTitleMac=Page Footers:\n\n# Windows titles:\noptionsTitleWindows=Options\nprintFramesTitleWindows=Print Frames\n\n# TRANSLATOR NOTE: For radio button labels and check button labels, an underscore _\n# before a character will turn that character into an accesskey in the GTK dialog.\n# e.g. \"_As laid out\" will make A the accesskey.\n# In the Windows labels, use an ampersand (&).\n# On Mac, underscores will be stripped.\n\nasLaidOut=_As Laid Out on the Screen\nasLaidOutWindows=As &laid out on the screen\nselectedFrame=The _Selected Frame\nselectedFrameWindows=The selected &frame\nseparateFrames=Each Frame on Separate _Pages\nseparateFramesWindows=&Each frame separately\nshrinkToFit=Ignore Scaling and S_hrink To Fit Page Width\nselectionOnly=Print Selection _Only\nprintBGOptions=Print Backgrounds\nprintBGColors=Print Background _Colors\nprintBGImages=Print Background I_mages\nheaderFooter=Header and Footer\nleft=Left\ncenter=Center\nright=Right\nheaderFooterBlank=--blank--\nheaderFooterTitle=Title\nheaderFooterURL=URL\nheaderFooterDate=Date/Time\nheaderFooterPage=Page #\nheaderFooterPageTotal=Page # of #\nheaderFooterCustom=Custom…\ncustomHeaderFooterPrompt=Please enter your custom header/footer text\n\n# These are for the summary view in the Mac dialog:\nsummaryFramesTitle=Print Frames\nsummarySelectionOnlyTitle=Print Selection\nsummaryShrinkToFitTitle=Shrink To Fit\nsummaryPrintBGColorsTitle=Print BG Colors\nsummaryPrintBGImagesTitle=Print BG Images\nsummaryHeaderTitle=Page Headers\nsummaryFooterTitle=Page Footers\nsummaryNAValue=N/A\nsummaryOnValue=On\nsummaryOffValue=Off\n"

/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nad\t=\tAndorra\nae\t=\tUnited Arab Emirates\naf\t=\tAfghanistan\nag\t=\tAntigua and Barbuda\nai\t=\tAnguilla\nal\t=\tAlbania\nam\t=\tArmenia\nao\t=\tAngola\naq\t=\tAntarctica\nar\t=\tArgentina\nas\t=\tAmerican Samoa\nat\t=\tAustria\nau\t=\tAustralia\naw\t=\tAruba\naz\t=\tAzerbaijan\nba\t=\tBosnia and Herzegovina\nbb\t=\tBarbados\nbd\t=\tBangladesh\nbe\t=\tBelgium\nbf\t=\tBurkina Faso\nbg\t=\tBulgaria\nbh\t=\tBahrain\nbi\t=\tBurundi\nbj\t=\tBenin\nbl\t=\tSaint Barthelemy\nbm\t=\tBermuda\nbn\t=\tBrunei\nbo\t=\tBolivia\nbq\t=\tBonaire, Sint Eustatius, and Saba\nbr\t=\tBrazil\nbs\t=\tBahamas, The\nbt\t=\tBhutan\nbv\t=\tBouvet Island\nbw\t=\tBotswana\nby\t=\tBelarus\nbz\t=\tBelize\nca\t=\tCanada\ncc\t=\tCocos (Keeling) Islands\ncd\t=\tCongo (Kinshasa)\ncf\t=\tCentral African Republic\ncg\t=\tCongo (Brazzaville)\nch\t=\tSwitzerland\nci\t=\tCôte d’Ivoire\nck\t=\tCook Islands\ncl\t=\tChile\ncm\t=\tCameroon\ncn\t=\tChina\nco\t=\tColombia\ncp\t=\tClipperton Island\ncr\t=\tCosta Rica\ncu\t=\tCuba\ncv\t=\tCabo Verde\ncw\t=\tCuraçao\ncx\t=\tChristmas Island\ncy\t=\tCyprus\ncz\t=\tCzech Republic\nde\t=\tGermany\ndg\t=\tDiego Garcia\ndj\t=\tDjibouti\ndk\t=\tDenmark\ndm\t=\tDominica\ndo\t=\tDominican Republic\ndz\t=\tAlgeria\nec\t=\tEcuador\nee\t=\tEstonia\neg\t=\tEgypt\neh\t=\tWestern Sahara\ner\t=\tEritrea\nes\t=\tSpain\net\t=\tEthiopia\nfi\t=\tFinland\nfj\t=\tFiji\nfk\t=\tFalkland Islands (Islas Malvinas)\nfm\t=\tMicronesia, Federated States of\nfo\t=\tFaroe Islands\nfr\t=\tFrance\nga\t=\tGabon\ngb\t=\tUnited Kingdom\ngd\t=\tGrenada\nge\t=\tGeorgia\ngf\t=\tFrench Guiana\ngg\t=\tGuernsey\ngh\t=\tGhana\ngi\t=\tGibraltar\ngl\t=\tGreenland\ngm\t=\tGambia, The\ngn\t=\tGuinea\ngp\t=\tGuadeloupe\ngq\t=\tEquatorial Guinea\ngr\t=\tGreece\ngs\t=\tSouth Georgia and South Sandwich Islands\ngt\t=\tGuatemala\ngu\t=\tGuam\ngw\t=\tGuinea-Bissau\ngy\t=\tGuyana\nhk\t=\tHong Kong\nhm\t=\tHeard Island and McDonald Islands\nhn\t=\tHonduras\nhr\t=\tCroatia\nht\t=\tHaiti\nhu\t=\tHungary\nid\t=\tIndonesia\nie\t=\tIreland\nil\t=\tIsrael\nim\t=\tIsle of Man\nin\t=\tIndia\nio\t=\tBritish Indian Ocean Territory\niq\t=\tIraq\nir\t=\tIran\nis\t=\tIceland\nit\t=\tItaly\nje\t=\tJersey\njm\t=\tJamaica\njo\t=\tJordan\njp\t=\tJapan\nke\t=\tKenya\nkg\t=\tKyrgyzstan\nkh\t=\tCambodia\nki\t=\tKiribati\nkm\t=\tComoros\nkn\t=\tSaint Kitts and Nevis\nkp\t=\tKorea, North\nkr\t=\tKorea, South\nkw\t=\tKuwait\nky\t=\tCayman Islands\nkz\t=\tKazakhstan\nla\t=\tLaos\nlb\t=\tLebanon\nlc\t=\tSaint Lucia\nli\t=\tLiechtenstein\nlk\t=\tSri Lanka\nlr\t=\tLiberia\nls\t=\tLesotho\nlt\t=\tLithuania\nlu\t=\tLuxembourg\nlv\t=\tLatvia\nly\t=\tLibya\nma\t=\tMorocco\nmc\t=\tMonaco\nmd\t=\tMoldova\nme\t=\tMontenegro\nmf\t=\tSaint Martin\nmg\t=\tMadagascar\nmh\t=\tMarshall Islands\nmk\t=\tMacedonia\nml\t=\tMali\nmm\t=\tBurma\nmn\t=\tMongolia\nmo\t=\tMacau\nmp\t=\tNorthern Mariana Islands\nmq\t=\tMartinique\nmr\t=\tMauritania\nms\t=\tMontserrat\nmt\t=\tMalta\nmu\t=\tMauritius\nmv\t=\tMaldives\nmw\t=\tMalawi\nmx\t=\tMexico\nmy\t=\tMalaysia\nmz\t=\tMozambique\nna\t=\tNamibia\nnc\t=\tNew Caledonia\nne\t=\tNiger\nnf\t=\tNorfolk Island\nng\t=\tNigeria\nni\t=\tNicaragua\nnl\t=\tNetherlands\nno\t=\tNorway\nnp\t=\tNepal\nnr\t=\tNauru\nnu\t=\tNiue\nnz\t=\tNew Zealand\nom\t=\tOman\npa\t=\tPanama\npe\t=\tPeru\npf\t=\tFrench Polynesia\npg\t=\tPapua New Guinea\nph\t=\tPhilippines\npk\t=\tPakistan\npl\t=\tPoland\npm\t=\tSaint Pierre and Miquelon\npn\t=\tPitcairn Islands\npr\t=\tPuerto Rico\npt\t=\tPortugal\npw\t=\tPalau\npy\t=\tParaguay\nqa\t=\tQatar\nqm\t=\tMidway Islands\nqs\t=\tBassas da India\nqu\t=\tJuan de Nova Island\nqw\t=\tWake Island\nqx\t=\tGlorioso Islands\nqz\t=\tAkrotiri\nre\t=\tReunion\nro\t=\tRomania\nrs\t=\tSerbia\nru\t=\tRussia\nrw\t=\tRwanda\nsa\t=\tSaudi Arabia\nsb\t=\tSolomon Islands\nsc\t=\tSeychelles\nsd\t=\tSudan\nse\t=\tSweden\nsg\t=\tSingapore\nsh\t=\tSaint Helena, Ascension, and Tristan da Cunha\nsi\t=\tSlovenia\nsk\t=\tSlovakia\nsl\t=\tSierra Leone\nsm\t=\tSan Marino\nsn\t=\tSenegal\nso\t=\tSomalia\nsr\t=\tSuriname\nss\t=\tSouth Sudan\nst\t=\tSao Tome and Principe\nsv\t=\tEl Salvador\nsx\t=\tSint Maarten\nsy\t=\tSyria\nsz\t=\tSwaziland\ntc\t=\tTurks and Caicos Islands\ntd\t=\tChad\ntf\t=\tFrench Southern and Antarctic Lands\ntg\t=\tTogo\nth\t=\tThailand\ntj\t=\tTajikistan\ntk\t=\tTokelau\ntl\t=\tTimor-Leste\ntm\t=\tTurkmenistan\ntn\t=\tTunisia\nto\t=\tTonga\ntr\t=\tTurkey\ntt\t=\tTrinidad and Tobago\ntv\t=\tTuvalu\ntw\t=\tTaiwan\ntz\t=\tTanzania\nua\t=\tUkraine\nug\t=\tUganda\nus\t=\tUnited States\nuy\t=\tUruguay\nuz\t=\tUzbekistan\nva\t=\tVatican City\nvc\t=\tSaint Vincent and the Grenadines\nve\t=\tVenezuela\nvg\t=\tVirgin Islands, British\nvi\t=\tVirgin Islands, U.S.\nvn\t=\tVietnam\nvu\t=\tVanuatu\nwf\t=\tWallis and Futuna\nws\t=\tSamoa\nxa\t=\tAshmore and Cartier Islands\nxb\t=\tBaker Island\nxc\t=\tCoral Sea Islands\nxd\t=\tDhekelia\nxe\t=\tEuropa Island\nxg\t=\tGaza Strip\nxh\t=\tHowland Island\nxj\t=\tJan Mayen\nxk\t=\tKosovo\nxl\t=\tPalmyra Atoll\nxm\t=\tKingman Reef\nxp\t=\tParacel Islands\nxq\t=\tJarvis Island\nxr\t=\tSvalbard\nxs\t=\tSpratly Islands\nxt\t=\tTromelin Island\nxu\t=\tJohnston Atoll\nxv\t=\tNavassa Island\nxw\t=\tWest Bank\nye\t=\tYemen\nyt\t=\tMayotte\nza\t=\tSouth Africa\nzm\t=\tZambia\nzw\t=\tZimbabwe\n"

/***/ },
/* 134 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n# LOCALIZATION NOTE: These strings are used for profile reset.\n\n# LOCALIZATION NOTE (resetUnusedProfile.message): %S is brandShortName.\nresetUnusedProfile.message=It looks like you haven’t started %S in a while. Do you want to clean it up for a fresh, like-new experience? And by the way, welcome back!\n# LOCALIZATION NOTE (resetUninstalled.message): %S is brandShortName.\nresetUninstalled.message=Looks like you’ve reinstalled %S. Want us to clean it up for a fresh, like-new experience?\n\n# LOCALIZATION NOTE (refreshProfile.resetButton.label): %S is brandShortName.\nrefreshProfile.resetButton.label=Refresh %S…\nrefreshProfile.resetButton.accesskey=e\n"

/***/ },
/* 135 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ngoToLineTitle     = Go to line\ngoToLineText      = Enter line number\ninvalidInputTitle = Invalid input\ninvalidInputText  = The line number entered is invalid.\noutOfRangeTitle   = Line not found\noutOfRangeText    = The specified line was not found.\nstatusBarLineCol  = Line %1$S, Col %2$S\nviewSelectionSourceTitle = DOM Source of Selection\nviewMathMLSourceTitle    = DOM Source of MathML\n\ncontext_goToLine_label        = Go to Line…\ncontext_goToLine_accesskey    = L\ncontext_wrapLongLines_label   = Wrap Long Lines\ncontext_highlightSyntax_label = Syntax Highlighting\n"

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = "# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\ndefault-first-title=Welcome to the %S\ndefault-last-title=Completing the %S\ndefault-first-title-mac=Introduction\ndefault-last-title-mac=Conclusion\n"

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft= javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);

	({ lazyRequireGetter: () => {} }).lazyGetter(this, "HUDService", () => __webpack_require__(138));
	({ lazyRequireGetter: () => {} }).lazyGetter(this, "EventEmitter", () => __webpack_require__(6));

	/**
	 * A DevToolPanel that controls the Web Console.
	 */
	function WebConsolePanel(iframeWindow, toolbox) {
	  this._frameWindow = iframeWindow;
	  this._toolbox = toolbox;
	  EventEmitter.decorate(this);
	}

	exports.WebConsolePanel = WebConsolePanel;

	WebConsolePanel.prototype = {
	  hud: null,

	  /**
	   * Called by the WebConsole's onkey command handler.
	   * If the WebConsole is opened, check if the JSTerm's input line has focus.
	   * If not, focus it.
	   */
	  focusInput: function () {
	    this.hud.jsterm.focus();
	  },

	  /**
	   * Open is effectively an asynchronous constructor.
	   *
	   * @return object
	   *         A promise that is resolved when the Web Console completes opening.
	   */
	  open: function () {
	    let parentDoc = this._toolbox.doc;
	    let iframe = parentDoc.getElementById("toolbox-panel-iframe-webconsole");

	    // Make sure the iframe content window is ready.
	    let deferredIframe = promise.defer();
	    let win, doc;
	    if ((win = iframe.contentWindow) &&
	        (doc = win.document) &&
	        doc.readyState == "complete") {
	      deferredIframe.resolve(null);
	    } else {
	      iframe.addEventListener("load", function onIframeLoad() {
	        iframe.removeEventListener("load", onIframeLoad, true);
	        deferredIframe.resolve(null);
	      }, true);
	    }

	    // Local debugging needs to make the target remote.
	    let promiseTarget;
	    if (!this.target.isRemote) {
	      promiseTarget = this.target.makeRemote();
	    } else {
	      promiseTarget = promise.resolve(this.target);
	    }

	    // 1. Wait for the iframe to load.
	    // 2. Wait for the remote target.
	    // 3. Open the Web Console.
	    return deferredIframe.promise
	      .then(() => promiseTarget)
	      .then((target) => {
	        this._frameWindow._remoteTarget = target;

	        let webConsoleUIWindow = iframe.contentWindow.wrappedJSObject;
	        let chromeWindow = iframe.ownerDocument.defaultView;
	        return HUDService.openWebConsole(this.target, webConsoleUIWindow,
	                                         chromeWindow);
	      })
	      .then((webConsole) => {
	        this.hud = webConsole;
	        this._isReady = true;
	        this.emit("ready");
	        return this;
	      }, (reason) => {
	        let msg = "WebConsolePanel open failed. " +
	                  reason.error + ": " + reason.message;
	        (console.log)(msg + "\n");
	        console.error(msg);
	      });
	  },

	  get target() {
	    return this._toolbox.target;
	  },

	  _isReady: false,
	  get isReady() {
	    return this._isReady;
	  },

	  destroy: function () {
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    this._destroyer = this.hud.destroy();
	    this._destroyer.then(() => this.emit("destroyed"));

	    return this._destroyer;
	  },
	};


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {Cc, Ci, Cu} = __webpack_require__(9);

	var WebConsoleUtils = __webpack_require__(139).Utils;
	var { extend } = __webpack_require__(18);
	var {TargetFactory} = __webpack_require__(140);
	var {Tools} = __webpack_require__(36);
	const { Task } = __webpack_require__(15);
	var promise = __webpack_require__(4);
	var Services = __webpack_require__(1);

	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "Telemetry", "devtools/client/shared/telemetry");
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "WebConsoleFrame", "devtools/client/webconsole/webconsole", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "gDevTools", "devtools/client/framework/devtools", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "DebuggerServer", "devtools/server/main", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "DebuggerClient", "devtools/shared/client/main", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "showDoorhanger", "devtools/client/shared/doorhanger", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "viewSource", "devtools/client/shared/view-source");

	const STRINGS_URI = "devtools/locale/webconsole.properties";
	var l10n = new WebConsoleUtils.L10n(STRINGS_URI);

	const BROWSER_CONSOLE_WINDOW_FEATURES = "chrome,titlebar,toolbar,centerscreen,resizable,dialog=no";

	// The preference prefix for all of the Browser Console filters.
	const BROWSER_CONSOLE_FILTER_PREFS_PREFIX = "devtools.browserconsole.filter.";

	var gHudId = 0;

	// The HUD service

	function HUD_SERVICE()
	{
	  this.consoles = new Map();
	  this.lastFinishedRequest = { callback: null };
	}

	HUD_SERVICE.prototype =
	{
	  _browserConsoleID: null,
	  _browserConsoleDefer: null,

	  /**
	   * Keeps a reference for each Web Console / Browser Console that is created.
	   * @type Map
	   */
	  consoles: null,

	  /**
	   * Assign a function to this property to listen for every request that
	   * completes. Used by unit tests. The callback takes one argument: the HTTP
	   * activity object as received from the remote Web Console.
	   *
	   * @type object
	   *       Includes a property named |callback|. Assign the function to the
	   *       |callback| property of this object.
	   */
	  lastFinishedRequest: null,

	  /**
	   * Get the current context, which is the main application window.
	   *
	   * @returns nsIDOMWindow
	   */
	  currentContext: function HS_currentContext() {
	    return Services.wm.getMostRecentWindow(gDevTools.chromeWindowType);
	  },

	  /**
	   * Open a Web Console for the given target.
	   *
	   * @see devtools/framework/target.js for details about targets.
	   *
	   * @param object aTarget
	   *        The target that the web console will connect to.
	   * @param nsIDOMWindow aIframeWindow
	   *        The window where the web console UI is already loaded.
	   * @param nsIDOMWindow aChromeWindow
	   *        The window of the web console owner.
	   * @return object
	   *         A promise object for the opening of the new WebConsole instance.
	   */
	  openWebConsole:
	  function HS_openWebConsole(aTarget, aIframeWindow, aChromeWindow)
	  {
	    let hud = new WebConsole(aTarget, aIframeWindow, aChromeWindow);
	    this.consoles.set(hud.hudId, hud);
	    return hud.init();
	  },

	  /**
	   * Open a Browser Console for the given target.
	   *
	   * @see devtools/framework/target.js for details about targets.
	   *
	   * @param object aTarget
	   *        The target that the browser console will connect to.
	   * @param nsIDOMWindow aIframeWindow
	   *        The window where the browser console UI is already loaded.
	   * @param nsIDOMWindow aChromeWindow
	   *        The window of the browser console owner.
	   * @return object
	   *         A promise object for the opening of the new BrowserConsole instance.
	   */
	  openBrowserConsole:
	  function HS_openBrowserConsole(aTarget, aIframeWindow, aChromeWindow)
	  {
	    let hud = new BrowserConsole(aTarget, aIframeWindow, aChromeWindow);
	    this._browserConsoleID = hud.hudId;
	    this.consoles.set(hud.hudId, hud);
	    return hud.init();
	  },

	  /**
	   * Returns the Web Console object associated to a content window.
	   *
	   * @param nsIDOMWindow aContentWindow
	   * @returns object
	   */
	  getHudByWindow: function HS_getHudByWindow(aContentWindow)
	  {
	    for (let [hudId, hud] of this.consoles) {
	      let target = hud.target;
	      if (target && target.tab && target.window === aContentWindow) {
	        return hud;
	      }
	    }
	    return null;
	  },

	  /**
	   * Returns the console instance for a given id.
	   *
	   * @param string aId
	   * @returns Object
	   */
	  getHudReferenceById: function HS_getHudReferenceById(aId)
	  {
	    return this.consoles.get(aId);
	  },

	  /**
	   * Find if there is a Web Console open for the current tab and return the
	   * instance.
	   * @return object|null
	   *         The WebConsole object or null if the active tab has no open Web
	   *         Console.
	   */
	  getOpenWebConsole: function HS_getOpenWebConsole()
	  {
	    let tab = this.currentContext().gBrowser.selectedTab;
	    if (!tab || !TargetFactory.isKnownTab(tab)) {
	      return null;
	    }
	    let target = TargetFactory.forTab(tab);
	    let toolbox = gDevTools.getToolbox(target);
	    let panel = toolbox ? toolbox.getPanel("webconsole") : null;
	    return panel ? panel.hud : null;
	  },

	  /**
	   * Toggle the Browser Console.
	   */
	  toggleBrowserConsole: function HS_toggleBrowserConsole()
	  {
	    if (this._browserConsoleID) {
	      let hud = this.getHudReferenceById(this._browserConsoleID);
	      return hud.destroy();
	    }

	    if (this._browserConsoleDefer) {
	      return this._browserConsoleDefer.promise;
	    }

	    this._browserConsoleDefer = promise.defer();

	    function connect()
	    {
	      let deferred = promise.defer();

	      if (!DebuggerServer.initialized) {
	        DebuggerServer.init();
	        DebuggerServer.addBrowserActors();
	      }
	      DebuggerServer.allowChromeProcess = true;

	      let client = new DebuggerClient(DebuggerServer.connectPipe());
	      return client.connect()
	        .then(() => client.getProcess())
	        .then(aResponse => {
	          // Set chrome:false in order to attach to the target
	          // (i.e. send an `attach` request to the chrome actor)
	          return { form: aResponse.form, client: client, chrome: false };
	        });
	    }

	    let target;
	    function getTarget(aConnection)
	    {
	      return TargetFactory.forRemoteTab(aConnection);
	    }

	    function openWindow(aTarget)
	    {
	      target = aTarget;

	      let deferred = promise.defer();

	      let win = Services.ww.openWindow(null, Tools.webConsole.url, "_blank",
	                                       BROWSER_CONSOLE_WINDOW_FEATURES, null);
	      win.addEventListener("DOMContentLoaded", function onLoad() {
	        win.removeEventListener("DOMContentLoaded", onLoad);

	        // Set the correct Browser Console title.
	        let root = win.document.documentElement;
	        root.setAttribute("title", root.getAttribute("browserConsoleTitle"));

	        deferred.resolve(win);
	      });

	      return deferred.promise;
	    }

	    connect().then(getTarget).then(openWindow).then((aWindow) => {
	      return this.openBrowserConsole(target, aWindow, aWindow)
	        .then((aBrowserConsole) => {
	          this._browserConsoleDefer.resolve(aBrowserConsole);
	          this._browserConsoleDefer = null;
	        });
	    }, console.error.bind(console));

	    return this._browserConsoleDefer.promise;
	  },

	  /**
	   * Opens or focuses the Browser Console.
	   */
	  openBrowserConsoleOrFocus: function HS_openBrowserConsoleOrFocus()
	  {
	    let hud = this.getBrowserConsole();
	    if (hud) {
	      hud.iframeWindow.focus();
	      return promise.resolve(hud);
	    }
	    else {
	      return this.toggleBrowserConsole();
	    }
	  },

	  /**
	   * Get the Browser Console instance, if open.
	   *
	   * @return object|null
	   *         A BrowserConsole instance or null if the Browser Console is not
	   *         open.
	   */
	  getBrowserConsole: function HS_getBrowserConsole()
	  {
	    return this.getHudReferenceById(this._browserConsoleID);
	  },
	};


	/**
	 * A WebConsole instance is an interactive console initialized *per target*
	 * that displays console log data as well as provides an interactive terminal to
	 * manipulate the target's document content.
	 *
	 * This object only wraps the iframe that holds the Web Console UI. This is
	 * meant to be an integration point between the Firefox UI and the Web Console
	 * UI and features.
	 *
	 * @constructor
	 * @param object aTarget
	 *        The target that the web console will connect to.
	 * @param nsIDOMWindow aIframeWindow
	 *        The window where the web console UI is already loaded.
	 * @param nsIDOMWindow aChromeWindow
	 *        The window of the web console owner.
	 */
	function WebConsole(aTarget, aIframeWindow, aChromeWindow)
	{
	  this.iframeWindow = aIframeWindow;
	  this.chromeWindow = aChromeWindow;
	  this.hudId = "hud_" + ++gHudId;
	  this.target = aTarget;

	  this.browserWindow = this.chromeWindow.top;

	  let element = this.browserWindow.document.documentElement;
	  if (element.getAttribute("windowtype") != gDevTools.chromeWindowType) {
	    this.browserWindow = HUDService.currentContext();
	  }

	  this.ui = new WebConsoleFrame(this);
	}

	WebConsole.prototype = {
	  iframeWindow: null,
	  chromeWindow: null,
	  browserWindow: null,
	  hudId: null,
	  target: null,
	  ui: null,
	  _browserConsole: false,
	  _destroyer: null,

	  /**
	   * Getter for a function to to listen for every request that completes. Used
	   * by unit tests. The callback takes one argument: the HTTP activity object as
	   * received from the remote Web Console.
	   *
	   * @type function
	   */
	  get lastFinishedRequestCallback()
	  {
	    return HUDService.lastFinishedRequest.callback;
	  },

	  /**
	   * Getter for the window that can provide various utilities that the web
	   * console makes use of, like opening links, managing popups, etc.  In
	   * most cases, this will be |this.browserWindow|, but in some uses (such as
	   * the Browser Toolbox), there is no browser window, so an alternative window
	   * hosts the utilities there.
	   * @type nsIDOMWindow
	   */
	  get chromeUtilsWindow()
	  {
	    if (this.browserWindow) {
	      return this.browserWindow;
	    }
	    return this.chromeWindow.top;
	  },

	  /**
	   * Getter for the xul:popupset that holds any popups we open.
	   * @type nsIDOMElement
	   */
	  get mainPopupSet()
	  {
	    return this.chromeUtilsWindow.document.getElementById("mainPopupSet");
	  },

	  /**
	   * Getter for the output element that holds messages we display.
	   * @type nsIDOMElement
	   */
	  get outputNode()
	  {
	    return this.ui ? this.ui.outputNode : null;
	  },

	  get gViewSourceUtils()
	  {
	    return this.chromeUtilsWindow.gViewSourceUtils;
	  },

	  /**
	   * Initialize the Web Console instance.
	   *
	   * @return object
	   *         A promise for the initialization.
	   */
	  init: function WC_init()
	  {
	    return this.ui.init().then(() => this);
	  },

	  /**
	   * Retrieve the Web Console panel title.
	   *
	   * @return string
	   *         The Web Console panel title.
	   */
	  getPanelTitle: function WC_getPanelTitle()
	  {
	    let url = this.ui ? this.ui.contentLocation : "";
	    return l10n.getFormatStr("webConsoleWindowTitleAndURL", [url]);
	  },

	  /**
	   * The JSTerm object that manages the console's input.
	   * @see webconsole.js::JSTerm
	   * @type object
	   */
	  get jsterm()
	  {
	    return this.ui ? this.ui.jsterm : null;
	  },

	  /**
	   * The clear output button handler.
	   * @private
	   */
	  _onClearButton: function WC__onClearButton()
	  {
	    if (this.target.isLocalTab) {
	      this.browserWindow.DeveloperToolbar.resetErrorsCount(this.target.tab);
	    }
	  },

	  /**
	   * Alias for the WebConsoleFrame.setFilterState() method.
	   * @see webconsole.js::WebConsoleFrame.setFilterState()
	   */
	  setFilterState: function WC_setFilterState()
	  {
	    this.ui && this.ui.setFilterState.apply(this.ui, arguments);
	  },

	  /**
	   * Open a link in a new tab.
	   *
	   * @param string aLink
	   *        The URL you want to open in a new tab.
	   */
	  openLink: function WC_openLink(aLink)
	  {
	    this.chromeUtilsWindow.openUILinkIn(aLink, "tab");
	  },

	  /**
	   * Open a link in Firefox's view source.
	   *
	   * @param string aSourceURL
	   *        The URL of the file.
	   * @param integer aSourceLine
	   *        The line number which should be highlighted.
	   */
	  viewSource: function WC_viewSource(aSourceURL, aSourceLine) {
	    // Attempt to access view source via a browser first, which may display it in
	    // a tab, if enabled.
	    let browserWin = Services.wm.getMostRecentWindow(gDevTools.chromeWindowType);
	    if (browserWin && browserWin.BrowserViewSourceOfDocument) {
	      return browserWin.BrowserViewSourceOfDocument({
	        URL: aSourceURL,
	        lineNumber: aSourceLine
	      });
	    }
	    this.gViewSourceUtils.viewSource(aSourceURL, null, this.iframeWindow.document, aSourceLine || 0);
	  },

	  /**
	   * Tries to open a Stylesheet file related to the web page for the web console
	   * instance in the Style Editor. If the file is not found, it is opened in
	   * source view instead.
	   *
	   * Manually handle the case where toolbox does not exist (Browser Console).
	   *
	   * @param string aSourceURL
	   *        The URL of the file.
	   * @param integer aSourceLine
	   *        The line number which you want to place the caret.
	   */
	  viewSourceInStyleEditor: function WC_viewSourceInStyleEditor(aSourceURL, aSourceLine) {
	    let toolbox = gDevTools.getToolbox(this.target);
	    if (!toolbox) {
	      this.viewSource(aSourceURL, aSourceLine);
	      return;
	    }
	    toolbox.viewSourceInStyleEditor(aSourceURL, aSourceLine);
	  },

	  /**
	   * Tries to open a JavaScript file related to the web page for the web console
	   * instance in the Script Debugger. If the file is not found, it is opened in
	   * source view instead.
	   *
	   * Manually handle the case where toolbox does not exist (Browser Console).
	   *
	   * @param string aSourceURL
	   *        The URL of the file.
	   * @param integer aSourceLine
	   *        The line number which you want to place the caret.
	   */
	  viewSourceInDebugger: function WC_viewSourceInDebugger(aSourceURL, aSourceLine) {
	    let toolbox = gDevTools.getToolbox(this.target);
	    if (!toolbox) {
	      this.viewSource(aSourceURL, aSourceLine);
	      return;
	    }
	    toolbox.viewSourceInDebugger(aSourceURL, aSourceLine).then(() => {
	      this.ui.emit("source-in-debugger-opened");
	    });
	  },

	  /**
	   * Tries to open a JavaScript file related to the web page for the web console
	   * instance in the corresponding Scratchpad.
	   *
	   * @param string aSourceURL
	   *        The URL of the file which corresponds to a Scratchpad id.
	   */
	  viewSourceInScratchpad: function WC_viewSourceInScratchpad(aSourceURL, aSourceLine) {
	    viewSource.viewSourceInScratchpad(aSourceURL, aSourceLine);
	  },

	  /**
	   * Retrieve information about the JavaScript debugger's stackframes list. This
	   * is used to allow the Web Console to evaluate code in the selected
	   * stackframe.
	   *
	   * @return object|null
	   *         An object which holds:
	   *         - frames: the active ThreadClient.cachedFrames array.
	   *         - selected: depth/index of the selected stackframe in the debugger
	   *         UI.
	   *         If the debugger is not open or if it's not paused, then |null| is
	   *         returned.
	   */
	  getDebuggerFrames: function WC_getDebuggerFrames()
	  {
	    let toolbox = gDevTools.getToolbox(this.target);
	    if (!toolbox) {
	      return null;
	    }
	    let panel = toolbox.getPanel("jsdebugger");
	    if (!panel) {
	      return null;
	    }
	    let framesController = panel.panelWin.DebuggerController.StackFrames;
	    let thread = framesController.activeThread;
	    if (thread && thread.paused) {
	      return {
	        frames: thread.cachedFrames,
	        selected: framesController.currentFrameDepth,
	      };
	    }
	    return null;
	  },

	  /**
	   * Retrieves the current selection from the Inspector, if such a selection
	   * exists. This is used to pass the ID of the selected actor to the Web
	   * Console server for the $0 helper.
	   *
	   * @return object|null
	   *         A Selection referring to the currently selected node in the
	   *         Inspector.
	   *         If the inspector was never opened, or no node was ever selected,
	   *         then |null| is returned.
	   */
	  getInspectorSelection: function WC_getInspectorSelection()
	  {
	    let toolbox = gDevTools.getToolbox(this.target);
	    if (!toolbox) {
	      return null;
	    }
	    let panel = toolbox.getPanel("inspector");
	    if (!panel || !panel.selection) {
	      return null;
	    }
	    return panel.selection;
	  },

	  /**
	   * Destroy the object. Call this method to avoid memory leaks when the Web
	   * Console is closed.
	   *
	   * @return object
	   *         A promise object that is resolved once the Web Console is closed.
	   */
	  destroy: function WC_destroy()
	  {
	    if (this._destroyer) {
	      return this._destroyer.promise;
	    }

	    HUDService.consoles.delete(this.hudId);

	    this._destroyer = promise.defer();

	    // The document may already be removed
	    if (this.chromeUtilsWindow && this.mainPopupSet) {
	      let popupset = this.mainPopupSet;
	      let panels = popupset.querySelectorAll("panel[hudId=" + this.hudId + "]");
	      for (let panel of panels) {
	        panel.hidePopup();
	      }
	    }

	    let onDestroy = Task.async(function* () {
	      if (!this._browserConsole) {
	        try {
	          yield this.target.activeTab.focus();
	        }
	        catch (ex) {
	          // Tab focus can fail if the tab or target is closed.
	        }
	      }

	      let id = WebConsoleUtils.supportsString(this.hudId);
	      Services.obs.notifyObservers(id, "web-console-destroyed", null);
	      this._destroyer.resolve(null);
	    }.bind(this));

	    if (this.ui) {
	      this.ui.destroy().then(onDestroy);
	    }
	    else {
	      onDestroy();
	    }

	    return this._destroyer.promise;
	  },
	};

	/**
	 * A BrowserConsole instance is an interactive console initialized *per target*
	 * that displays console log data as well as provides an interactive terminal to
	 * manipulate the target's document content.
	 *
	 * This object only wraps the iframe that holds the Browser Console UI. This is
	 * meant to be an integration point between the Firefox UI and the Browser Console
	 * UI and features.
	 *
	 * @constructor
	 * @param object aTarget
	 *        The target that the browser console will connect to.
	 * @param nsIDOMWindow aIframeWindow
	 *        The window where the browser console UI is already loaded.
	 * @param nsIDOMWindow aChromeWindow
	 *        The window of the browser console owner.
	 */
	function BrowserConsole()
	{
	  WebConsole.apply(this, arguments);
	  this._telemetry = new Telemetry();
	}

	BrowserConsole.prototype = extend(WebConsole.prototype, {
	  _browserConsole: true,
	  _bc_init: null,
	  _bc_destroyer: null,

	  $init: WebConsole.prototype.init,

	  /**
	   * Initialize the Browser Console instance.
	   *
	   * @return object
	   *         A promise for the initialization.
	   */
	  init: function BC_init()
	  {
	    if (this._bc_init) {
	      return this._bc_init;
	    }

	    this.ui._filterPrefsPrefix = BROWSER_CONSOLE_FILTER_PREFS_PREFIX;

	    let window = this.iframeWindow;

	    // Make sure that the closing of the Browser Console window destroys this
	    // instance.
	    let onClose = () => {
	      window.removeEventListener("unload", onClose);
	      window.removeEventListener("focus", onFocus);
	      this.destroy();
	    };
	    window.addEventListener("unload", onClose);

	    this._telemetry.toolOpened("browserconsole");

	    // Create an onFocus handler just to display the dev edition promo.
	    // This is to prevent race conditions in some environments.
	    // Hook to display promotional Developer Edition doorhanger. Only displayed once.
	    let onFocus = () => showDoorhanger({ window, type: "deveditionpromo" });
	    window.addEventListener("focus", onFocus);

	    this._bc_init = this.$init();
	    return this._bc_init;
	  },

	  $destroy: WebConsole.prototype.destroy,

	  /**
	   * Destroy the object.
	   *
	   * @return object
	   *         A promise object that is resolved once the Browser Console is closed.
	   */
	  destroy: function BC_destroy()
	  {
	    if (this._bc_destroyer) {
	      return this._bc_destroyer.promise;
	    }

	    this._telemetry.toolClosed("browserconsole");

	    this._bc_destroyer = promise.defer();

	    let chromeWindow = this.chromeWindow;
	    this.$destroy().then(() =>
	      this.target.client.close(() => {
	        HUDService._browserConsoleID = null;
	        chromeWindow.close();
	        this._bc_destroyer.resolve(null);
	      }));

	    return this._bc_destroyer.promise;
	  },
	});

	const HUDService = new HUD_SERVICE();

	(() => {
	  let methods = ["openWebConsole", "openBrowserConsole",
	                 "toggleBrowserConsole", "getOpenWebConsole",
	                 "getBrowserConsole", "getHudByWindow",
	                 "openBrowserConsoleOrFocus", "getHudReferenceById"];
	  for (let method of methods) {
	    exports[method] = HUDService[method].bind(HUDService);
	  }

	  exports.consoles = HUDService.consoles;
	  exports.lastFinishedRequest = HUDService.lastFinishedRequest;
	})();


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft= javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {Cc, Ci, Cu, components} = __webpack_require__(9);
	const Services = __webpack_require__(1);
	const {LocalizationHelper} = __webpack_require__(56);

	// Match the function name from the result of toString() or toSource().
	//
	// Examples:
	// (function foobar(a, b) { ...
	// function foobar2(a) { ...
	// function() { ...
	const REGEX_MATCH_FUNCTION_NAME = /^\(?function\s+([^(\s]+)\s*\(/;

	// Number of terminal entries for the self-xss prevention to go away
	const CONSOLE_ENTRY_THRESHOLD = 5;

	const CONSOLE_WORKER_IDS = exports.CONSOLE_WORKER_IDS = [
	  "SharedWorker",
	  "ServiceWorker",
	  "Worker"
	];

	var WebConsoleUtils = {

	  /**
	   * Wrap a string in an nsISupportsString object.
	   *
	   * @param string string
	   * @return nsISupportsString
	   */
	  supportsString: function (string) {
	    let str = Cc["@mozilla.org/supports-string;1"]
	              .createInstance(Ci.nsISupportsString);
	    str.data = string;
	    return str;
	  },

	  /**
	   * Clone an object.
	   *
	   * @param object object
	   *        The object you want cloned.
	   * @param boolean recursive
	   *        Tells if you want to dig deeper into the object, to clone
	   *        recursively.
	   * @param function [filter]
	   *        Optional, filter function, called for every property. Three
	   *        arguments are passed: key, value and object. Return true if the
	   *        property should be added to the cloned object. Return false to skip
	   *        the property.
	   * @return object
	   *         The cloned object.
	   */
	  cloneObject: function (object, recursive, filter) {
	    if (typeof object != "object") {
	      return object;
	    }

	    let temp;

	    if (Array.isArray(object)) {
	      temp = [];
	      Array.forEach(object, function (value, index) {
	        if (!filter || filter(index, value, object)) {
	          temp.push(recursive ? WebConsoleUtils.cloneObject(value) : value);
	        }
	      });
	    } else {
	      temp = {};
	      for (let key in object) {
	        let value = object[key];
	        if (object.hasOwnProperty(key) &&
	            (!filter || filter(key, value, object))) {
	          temp[key] = recursive ? WebConsoleUtils.cloneObject(value) : value;
	        }
	      }
	    }

	    return temp;
	  },

	  /**
	   * Copies certain style attributes from one element to another.
	   *
	   * @param nsIDOMNode from
	   *        The target node.
	   * @param nsIDOMNode to
	   *        The destination node.
	   */
	  copyTextStyles: function (from, to) {
	    let win = from.ownerDocument.defaultView;
	    let style = win.getComputedStyle(from);
	    to.style.fontFamily = style.getPropertyCSSValue("font-family").cssText;
	    to.style.fontSize = style.getPropertyCSSValue("font-size").cssText;
	    to.style.fontWeight = style.getPropertyCSSValue("font-weight").cssText;
	    to.style.fontStyle = style.getPropertyCSSValue("font-style").cssText;
	  },

	  /**
	   * Create a grip for the given value. If the value is an object,
	   * an object wrapper will be created.
	   *
	   * @param mixed value
	   *        The value you want to create a grip for, before sending it to the
	   *        client.
	   * @param function objectWrapper
	   *        If the value is an object then the objectWrapper function is
	   *        invoked to give us an object grip. See this.getObjectGrip().
	   * @return mixed
	   *         The value grip.
	   */
	  createValueGrip: function (value, objectWrapper) {
	    switch (typeof value) {
	      case "boolean":
	        return value;
	      case "string":
	        return objectWrapper(value);
	      case "number":
	        if (value === Infinity) {
	          return { type: "Infinity" };
	        } else if (value === -Infinity) {
	          return { type: "-Infinity" };
	        } else if (Number.isNaN(value)) {
	          return { type: "NaN" };
	        } else if (!value && 1 / value === -Infinity) {
	          return { type: "-0" };
	        }
	        return value;
	      case "undefined":
	        return { type: "undefined" };
	      case "object":
	        if (value === null) {
	          return { type: "null" };
	        }
	        // Fall through.
	      case "function":
	        return objectWrapper(value);
	      default:
	        console.error("Failed to provide a grip for value of " + typeof value
	                      + ": " + value);
	        return null;
	    }
	  },

	  /**
	   * Determine if the given request mixes HTTP with HTTPS content.
	   *
	   * @param string request
	   *        Location of the requested content.
	   * @param string location
	   *        Location of the current page.
	   * @return boolean
	   *         True if the content is mixed, false if not.
	   */
	  isMixedHTTPSRequest: function (request, location) {
	    try {
	      let requestURI = Services.io.newURI(request, null, null);
	      let contentURI = Services.io.newURI(location, null, null);
	      return (contentURI.scheme == "https" && requestURI.scheme != "https");
	    } catch (ex) {
	      return false;
	    }
	  },

	  /**
	   * Helper function to deduce the name of the provided function.
	   *
	   * @param funtion function
	   *        The function whose name will be returned.
	   * @return string
	   *         Function name.
	   */
	  getFunctionName: function (func) {
	    let name = null;
	    if (func.name) {
	      name = func.name;
	    } else {
	      let desc;
	      try {
	        desc = func.getOwnPropertyDescriptor("displayName");
	      } catch (ex) {
	        // Ignore.
	      }
	      if (desc && typeof desc.value == "string") {
	        name = desc.value;
	      }
	    }
	    if (!name) {
	      try {
	        let str = (func.toString() || func.toSource()) + "";
	        name = (str.match(REGEX_MATCH_FUNCTION_NAME) || [])[1];
	      } catch (ex) {
	        // Ignore.
	      }
	    }
	    return name;
	  },

	  /**
	   * Get the object class name. For example, the |window| object has the Window
	   * class name (based on [object Window]).
	   *
	   * @param object object
	   *        The object you want to get the class name for.
	   * @return string
	   *         The object class name.
	   */
	  getObjectClassName: function (object) {
	    if (object === null) {
	      return "null";
	    }
	    if (object === undefined) {
	      return "undefined";
	    }

	    let type = typeof object;
	    if (type != "object") {
	      // Grip class names should start with an uppercase letter.
	      return type.charAt(0).toUpperCase() + type.substr(1);
	    }

	    let className;

	    try {
	      className = ((object + "").match(/^\[object (\S+)\]$/) || [])[1];
	      if (!className) {
	        className = ((object.constructor + "")
	                     .match(/^\[object (\S+)\]$/) || [])[1];
	      }
	      if (!className && typeof object.constructor == "function") {
	        className = this.getFunctionName(object.constructor);
	      }
	    } catch (ex) {
	      // Ignore.
	    }

	    return className;
	  },

	  /**
	   * Check if the given value is a grip with an actor.
	   *
	   * @param mixed grip
	   *        Value you want to check if it is a grip with an actor.
	   * @return boolean
	   *         True if the given value is a grip with an actor.
	   */
	  isActorGrip: function (grip) {
	    return grip && typeof (grip) == "object" && grip.actor;
	  },

	  /**
	   * Value of devtools.selfxss.count preference
	   *
	   * @type number
	   * @private
	   */
	  _usageCount: 0,
	  get usageCount() {
	    if (WebConsoleUtils._usageCount < CONSOLE_ENTRY_THRESHOLD) {
	      WebConsoleUtils._usageCount =
	        Services.prefs.getIntPref("devtools.selfxss.count");
	      if (Services.prefs.getBoolPref("devtools.chrome.enabled")) {
	        WebConsoleUtils.usageCount = CONSOLE_ENTRY_THRESHOLD;
	      }
	    }
	    return WebConsoleUtils._usageCount;
	  },
	  set usageCount(newUC) {
	    if (newUC <= CONSOLE_ENTRY_THRESHOLD) {
	      WebConsoleUtils._usageCount = newUC;
	      Services.prefs.setIntPref("devtools.selfxss.count", newUC);
	    }
	  },
	  /**
	   * The inputNode "paste" event handler generator. Helps prevent
	   * self-xss attacks
	   *
	   * @param nsIDOMElement inputField
	   * @param nsIDOMElement notificationBox
	   * @returns A function to be added as a handler to 'paste' and
	   *'drop' events on the input field
	   */
	  pasteHandlerGen: function (inputField, notificationBox, msg, okstring) {
	    let handler = function (event) {
	      if (WebConsoleUtils.usageCount >= CONSOLE_ENTRY_THRESHOLD) {
	        inputField.removeEventListener("paste", handler);
	        inputField.removeEventListener("drop", handler);
	        return true;
	      }
	      if (notificationBox.getNotificationWithValue("selfxss-notification")) {
	        event.preventDefault();
	        event.stopPropagation();
	        return false;
	      }

	      let notification = notificationBox.appendNotification(msg,
	        "selfxss-notification", null,
	        notificationBox.PRIORITY_WARNING_HIGH, null,
	        function (eventType) {
	          // Cleanup function if notification is dismissed
	          if (eventType == "removed") {
	            inputField.removeEventListener("keyup", pasteKeyUpHandler);
	          }
	        });

	      function pasteKeyUpHandler(event2) {
	        let value = inputField.value || inputField.textContent;
	        if (value.includes(okstring)) {
	          notificationBox.removeNotification(notification);
	          inputField.removeEventListener("keyup", pasteKeyUpHandler);
	          WebConsoleUtils.usageCount = CONSOLE_ENTRY_THRESHOLD;
	        }
	      }
	      inputField.addEventListener("keyup", pasteKeyUpHandler);

	      event.preventDefault();
	      event.stopPropagation();
	      return false;
	    };
	    return handler;
	  },
	};

	exports.Utils = WebConsoleUtils;

	// ////////////////////////////////////////////////////////////////////////
	// Localization
	// ////////////////////////////////////////////////////////////////////////

	WebConsoleUtils.L10n = function (bundleURI) {
	  this._helper = new LocalizationHelper(bundleURI);
	};

	WebConsoleUtils.L10n.prototype = {
	  /**
	   * Generates a formatted timestamp string for displaying in console messages.
	   *
	   * @param integer [milliseconds]
	   *        Optional, allows you to specify the timestamp in milliseconds since
	   *        the UNIX epoch.
	   * @return string
	   *         The timestamp formatted for display.
	   */
	  timestampString: function (milliseconds) {
	    let d = new Date(milliseconds ? milliseconds : null);
	    let hours = d.getHours(), minutes = d.getMinutes();
	    let seconds = d.getSeconds();
	    milliseconds = d.getMilliseconds();
	    let parameters = [hours, minutes, seconds, milliseconds];
	    return this.getFormatStr("timestampFormat", parameters);
	  },

	  /**
	   * Retrieve a localized string.
	   *
	   * @param string name
	   *        The string name you want from the Web Console string bundle.
	   * @return string
	   *         The localized string.
	   */
	  getStr: function (name) {
	    try {
	      return this._helper.getStr(name);
	    } catch (ex) {
	      console.error("Failed to get string: " + name);
	      throw ex;
	    }
	  },

	  /**
	   * Retrieve a localized string formatted with values coming from the given
	   * array.
	   *
	   * @param string name
	   *        The string name you want from the Web Console string bundle.
	   * @param array array
	   *        The array of values you want in the formatted string.
	   * @return string
	   *         The formatted local string.
	   */
	  getFormatStr: function (name, array) {
	    try {
	      return this._helper.getFormatStr(name, ...array);
	    } catch (ex) {
	      console.error("Failed to format string: " + name);
	      throw ex;
	    }
	  },
	};


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const { Ci } = __webpack_require__(9);
	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);
	const EventEmitter = __webpack_require__(6);
	const Services = __webpack_require__(1);
	const { XPCOMUtils } = __webpack_require__(9);

	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "DebuggerServer", "devtools/server/main", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "DebuggerClient",
	  "devtools/shared/client/main", true);

	const targets = new WeakMap();
	const promiseTargets = new WeakMap();

	/**
	 * Functions for creating Targets
	 */
	exports.TargetFactory = {
	  /**
	   * Construct a Target
	   * @param {XULTab} tab
	   *        The tab to use in creating a new target.
	   *
	   * @return A target object
	   */
	  forTab: function (tab) {
	    let target = targets.get(tab);
	    if (target == null) {
	      target = new TabTarget(tab);
	      targets.set(tab, target);
	    }
	    return target;
	  },

	  /**
	   * Return a promise of a Target for a remote tab.
	   * @param {Object} options
	   *        The options object has the following properties:
	   *        {
	   *          form: the remote protocol form of a tab,
	   *          client: a DebuggerClient instance
	   *                  (caller owns this and is responsible for closing),
	   *          chrome: true if the remote target is the whole process
	   *        }
	   *
	   * @return A promise of a target object
	   */
	  forRemoteTab: function (options) {
	    let targetPromise = promiseTargets.get(options);
	    if (targetPromise == null) {
	      let target = new TabTarget(options);
	      targetPromise = target.makeRemote().then(() => target);
	      promiseTargets.set(options, targetPromise);
	    }
	    return targetPromise;
	  },

	  forWorker: function (workerClient) {
	    let target = targets.get(workerClient);
	    if (target == null) {
	      target = new WorkerTarget(workerClient);
	      targets.set(workerClient, target);
	    }
	    return target;
	  },

	  /**
	   * Creating a target for a tab that is being closed is a problem because it
	   * allows a leak as a result of coming after the close event which normally
	   * clears things up. This function allows us to ask if there is a known
	   * target for a tab without creating a target
	   * @return true/false
	   */
	  isKnownTab: function (tab) {
	    return targets.has(tab);
	  },
	};

	/**
	 * A Target represents something that we can debug. Targets are generally
	 * read-only. Any changes that you wish to make to a target should be done via
	 * a Tool that attaches to the target. i.e. a Target is just a pointer saying
	 * "the thing to debug is over there".
	 *
	 * Providing a generalized abstraction of a web-page or web-browser (available
	 * either locally or remotely) is beyond the scope of this class (and maybe
	 * also beyond the scope of this universe) However Target does attempt to
	 * abstract some common events and read-only properties common to many Tools.
	 *
	 * Supported read-only properties:
	 * - name, isRemote, url
	 *
	 * Target extends EventEmitter and provides support for the following events:
	 * - close: The target window has been closed. All tools attached to this
	 *          target should close. This event is not currently cancelable.
	 * - navigate: The target window has navigated to a different URL
	 *
	 * Optional events:
	 * - will-navigate: The target window will navigate to a different URL
	 * - hidden: The target is not visible anymore (for TargetTab, another tab is
	 *           selected)
	 * - visible: The target is visible (for TargetTab, tab is selected)
	 *
	 * Comparing Targets: 2 instances of a Target object can point at the same
	 * thing, so t1 !== t2 and t1 != t2 even when they represent the same object.
	 * To compare to targets use 't1.equals(t2)'.
	 */

	/**
	 * A TabTarget represents a page living in a browser tab. Generally these will
	 * be web pages served over http(s), but they don't have to be.
	 */
	function TabTarget(tab) {
	  EventEmitter.decorate(this);
	  this.destroy = this.destroy.bind(this);
	  this.activeTab = this.activeConsole = null;
	  // Only real tabs need initialization here. Placeholder objects for remote
	  // targets will be initialized after a makeRemote method call.
	  if (tab && !["client", "form", "chrome"].every(tab.hasOwnProperty, tab)) {
	    this._tab = tab;
	    this._setupListeners();
	  } else {
	    this._form = tab.form;
	    this._url = this._form.url;
	    this._title = this._form.title;

	    this._client = tab.client;
	    this._chrome = tab.chrome;
	  }
	  // Default isTabActor to true if not explicitly specified
	  if (typeof tab.isTabActor == "boolean") {
	    this._isTabActor = tab.isTabActor;
	  } else {
	    this._isTabActor = true;
	  }
	}

	TabTarget.prototype = {
	  _webProgressListener: null,

	  /**
	   * Returns a promise for the protocol description from the root actor. Used
	   * internally with `target.actorHasMethod`. Takes advantage of caching if
	   * definition was fetched previously with the corresponding actor information.
	   * Actors are lazily loaded, so not only must the tool using a specific actor
	   * be in use, the actors are only registered after invoking a method (for
	   * performance reasons, added in bug 988237), so to use these actor detection
	   * methods, one must already be communicating with a specific actor of that
	   * type.
	   *
	   * Must be a remote target.
	   *
	   * @return {Promise}
	   * {
	   *   "category": "actor",
	   *   "typeName": "longstractor",
	   *   "methods": [{
	   *     "name": "substring",
	   *     "request": {
	   *       "type": "substring",
	   *       "start": {
	   *         "_arg": 0,
	   *         "type": "primitive"
	   *       },
	   *       "end": {
	   *         "_arg": 1,
	   *         "type": "primitive"
	   *       }
	   *     },
	   *     "response": {
	   *       "substring": {
	   *         "_retval": "primitive"
	   *       }
	   *     }
	   *   }],
	   *  "events": {}
	   * }
	   */
	  getActorDescription: function (actorName) {
	    if (!this.client) {
	      throw new Error("TabTarget#getActorDescription() can only be called on " +
	                      "remote tabs.");
	    }

	    let deferred = defer();

	    if (this._protocolDescription &&
	        this._protocolDescription.types[actorName]) {
	      deferred.resolve(this._protocolDescription.types[actorName]);
	    } else {
	      this.client.mainRoot.protocolDescription(description => {
	        this._protocolDescription = description;
	        deferred.resolve(description.types[actorName]);
	      });
	    }

	    return deferred.promise;
	  },

	  /**
	   * Returns a boolean indicating whether or not the specific actor
	   * type exists. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @return {Boolean}
	   */
	  hasActor: function (actorName) {
	    if (!this.client) {
	      throw new Error("TabTarget#hasActor() can only be called on remote " +
	                      "tabs.");
	    }
	    if (this.form) {
	      return !!this.form[actorName + "Actor"];
	    }
	    return false;
	  },

	  /**
	   * Queries the protocol description to see if an actor has
	   * an available method. The actor must already be lazily-loaded (read
	   * the restrictions in the `getActorDescription` comments),
	   * so this is for use inside of tool. Returns a promise that
	   * resolves to a boolean. Must be a remote target.
	   *
	   * @param {String} actorName
	   * @param {String} methodName
	   * @return {Promise}
	   */
	  actorHasMethod: function (actorName, methodName) {
	    if (!this.client) {
	      throw new Error("TabTarget#actorHasMethod() can only be called on " +
	                      "remote tabs.");
	    }
	    return this.getActorDescription(actorName).then(desc => {
	      if (desc && desc.methods) {
	        return !!desc.methods.find(method => method.name === methodName);
	      }
	      return false;
	    });
	  },

	  /**
	   * Returns a trait from the root actor.
	   *
	   * @param {String} traitName
	   * @return {Mixed}
	   */
	  getTrait: function (traitName) {
	    if (!this.client) {
	      throw new Error("TabTarget#getTrait() can only be called on remote " +
	                      "tabs.");
	    }

	    // If the targeted actor exposes traits and has a defined value for this
	    // traits, override the root actor traits
	    if (this.form.traits && traitName in this.form.traits) {
	      return this.form.traits[traitName];
	    }

	    return this.client.traits[traitName];
	  },

	  get tab() {
	    return this._tab;
	  },

	  get form() {
	    return this._form;
	  },

	  // Get a promise of the root form returned by a listTabs request. This promise
	  // is cached.
	  get root() {
	    if (!this._root) {
	      this._root = this._getRoot();
	    }
	    return this._root;
	  },

	  _getRoot: function () {
	    return new Promise((resolve, reject) => {
	      this.client.listTabs(response => {
	        if (response.error) {
	          reject(new Error(response.error + ": " + response.message));
	          return;
	        }

	        resolve(response);
	      });
	    });
	  },

	  get client() {
	    return this._client;
	  },

	  // Tells us if we are debugging content document
	  // or if we are debugging chrome stuff.
	  // Allows to controls which features are available against
	  // a chrome or a content document.
	  get chrome() {
	    return this._chrome;
	  },

	  // Tells us if the related actor implements TabActor interface
	  // and requires to call `attach` request before being used
	  // and `detach` during cleanup
	  get isTabActor() {
	    return this._isTabActor;
	  },

	  get window() {
	    // XXX - this is a footgun for e10s - there .contentWindow will be null,
	    // and even though .contentWindowAsCPOW *might* work, it will not work
	    // in all contexts.  Consumers of .window need to be refactored to not
	    // rely on this.
	    if (Services.appinfo.processType != Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT) {
	      console.error("The .window getter on devtools' |target| object isn't " +
	                    "e10s friendly!\n" + Error().stack);
	    }
	    // Be extra careful here, since this may be called by HS_getHudByWindow
	    // during shutdown.
	    if (this._tab && this._tab.linkedBrowser) {
	      return this._tab.linkedBrowser.contentWindow;
	    }
	    return null;
	  },

	  get name() {
	    if (this.isAddon) {
	      return this._form.name;
	    }
	    return this._title;
	  },

	  get url() {
	    return this._url;
	  },

	  get isRemote() {
	    return !this.isLocalTab;
	  },

	  get isAddon() {
	    return !!(this._form && this._form.actor && (
	      this._form.actor.match(/conn\d+\.addon\d+/) ||
	      this._form.actor.match(/conn\d+\.webExtension\d+/)
	    ));
	  },

	  get isWebExtension() {
	    return !!(this._form && this._form.actor &&
	              this._form.actor.match(/conn\d+\.webExtension\d+/));
	  },

	  get isLocalTab() {
	    return !!this._tab;
	  },

	  get isMultiProcess() {
	    return !this.window;
	  },

	  /**
	   * Adds remote protocol capabilities to the target, so that it can be used
	   * for tools that support the Remote Debugging Protocol even for local
	   * connections.
	   */
	  makeRemote: function () {
	    if (this._remote) {
	      return this._remote.promise;
	    }

	    this._remote = defer();

	    if (this.isLocalTab) {
	      // Since a remote protocol connection will be made, let's start the
	      // DebuggerServer here, once and for all tools.
	      if (!DebuggerServer.initialized) {
	        DebuggerServer.init();
	        DebuggerServer.addBrowserActors();
	      }

	      this._client = new DebuggerClient(DebuggerServer.connectPipe());
	      // A local TabTarget will never perform chrome debugging.
	      this._chrome = false;
	    }

	    this._setupRemoteListeners();

	    let attachTab = () => {
	      this._client.attachTab(this._form.actor, (response, tabClient) => {
	        if (!tabClient) {
	          this._remote.reject("Unable to attach to the tab");
	          return;
	        }
	        this.activeTab = tabClient;
	        this.threadActor = response.threadActor;

	        attachConsole();
	      });
	    };

	    let onConsoleAttached = (response, consoleClient) => {
	      if (!consoleClient) {
	        this._remote.reject("Unable to attach to the console");
	        return;
	      }
	      this.activeConsole = consoleClient;
	      this._remote.resolve(null);
	    };

	    let attachConsole = () => {
	      this._client.attachConsole(this._form.consoleActor,
	                                 [ "NetworkActivity" ],
	                                 onConsoleAttached);
	    };

	    if (this.isLocalTab) {
	      this._client.connect()
	        .then(() => this._client.getTab({ tab: this.tab }))
	        .then(response => {
	          this._form = response.tab;
	          this._url = this._form.url;
	          this._title = this._form.title;

	          attachTab();
	        }, e => this._remote.reject(e));
	    } else if (this.isTabActor) {
	      // In the remote debugging case, the protocol connection will have been
	      // already initialized in the connection screen code.
	      attachTab();
	    } else {
	      // AddonActor and chrome debugging on RootActor doesn't inherits from
	      // TabActor and doesn't need to be attached.
	      attachConsole();
	    }

	    return this._remote.promise;
	  },

	  /**
	   * Listen to the different events.
	   */
	  _setupListeners: function () {
	    this._webProgressListener = new TabWebProgressListener(this);
	    this.tab.linkedBrowser.addProgressListener(this._webProgressListener);
	    this.tab.addEventListener("TabClose", this);
	    this.tab.parentNode.addEventListener("TabSelect", this);
	    this.tab.ownerDocument.defaultView.addEventListener("unload", this);
	  },

	  /**
	   * Teardown event listeners.
	   */
	  _teardownListeners: function () {
	    if (this._webProgressListener) {
	      this._webProgressListener.destroy();
	    }

	    this._tab.ownerDocument.defaultView.removeEventListener("unload", this);
	    this._tab.removeEventListener("TabClose", this);
	    this._tab.parentNode.removeEventListener("TabSelect", this);
	  },

	  /**
	   * Setup listeners for remote debugging, updating existing ones as necessary.
	   */
	  _setupRemoteListeners: function () {
	    this.client.addListener("closed", this.destroy);

	    this._onTabDetached = (aType, aPacket) => {
	      // We have to filter message to ensure that this detach is for this tab
	      if (aPacket.from == this._form.actor) {
	        this.destroy();
	      }
	    };
	    this.client.addListener("tabDetached", this._onTabDetached);

	    this._onTabNavigated = (aType, aPacket) => {
	      let event = Object.create(null);
	      event.url = aPacket.url;
	      event.title = aPacket.title;
	      event.nativeConsoleAPI = aPacket.nativeConsoleAPI;
	      event.isFrameSwitching = aPacket.isFrameSwitching;

	      if (!aPacket.isFrameSwitching) {
	        // Update the title and url unless this is a frame switch.
	        this._url = aPacket.url;
	        this._title = aPacket.title;
	      }

	      // Send any stored event payload (DOMWindow or nsIRequest) for backwards
	      // compatibility with non-remotable tools.
	      if (aPacket.state == "start") {
	        event._navPayload = this._navRequest;
	        this.emit("will-navigate", event);
	        this._navRequest = null;
	      } else {
	        event._navPayload = this._navWindow;
	        this.emit("navigate", event);
	        this._navWindow = null;
	      }
	    };
	    this.client.addListener("tabNavigated", this._onTabNavigated);

	    this._onFrameUpdate = (aType, aPacket) => {
	      this.emit("frame-update", aPacket);
	    };
	    this.client.addListener("frameUpdate", this._onFrameUpdate);

	    this._onSourceUpdated = (event, packet) => this.emit("source-updated", packet);
	    this.client.addListener("newSource", this._onSourceUpdated);
	    this.client.addListener("updatedSource", this._onSourceUpdated);
	  },

	  /**
	   * Teardown listeners for remote debugging.
	   */
	  _teardownRemoteListeners: function () {
	    this.client.removeListener("closed", this.destroy);
	    this.client.removeListener("tabNavigated", this._onTabNavigated);
	    this.client.removeListener("tabDetached", this._onTabDetached);
	    this.client.removeListener("frameUpdate", this._onFrameUpdate);
	    this.client.removeListener("newSource", this._onSourceUpdated);
	    this.client.removeListener("updatedSource", this._onSourceUpdated);
	  },

	  /**
	   * Handle tabs events.
	   */
	  handleEvent: function (event) {
	    switch (event.type) {
	      case "TabClose":
	      case "unload":
	        this.destroy();
	        break;
	      case "TabSelect":
	        if (this.tab.selected) {
	          this.emit("visible", event);
	        } else {
	          this.emit("hidden", event);
	        }
	        break;
	    }
	  },

	  /**
	   * Target is not alive anymore.
	   */
	  destroy: function () {
	    // If several things call destroy then we give them all the same
	    // destruction promise so we're sure to destroy only once
	    if (this._destroyer) {
	      return this._destroyer.promise;
	    }

	    this._destroyer = defer();

	    // Before taking any action, notify listeners that destruction is imminent.
	    this.emit("close");

	    if (this._tab) {
	      this._teardownListeners();
	    }

	    let cleanupAndResolve = () => {
	      this._cleanup();
	      this._destroyer.resolve(null);
	    };
	    // If this target was not remoted, the promise will be resolved before the
	    // function returns.
	    if (this._tab && !this._client) {
	      cleanupAndResolve();
	    } else if (this._client) {
	      // If, on the other hand, this target was remoted, the promise will be
	      // resolved after the remote connection is closed.
	      this._teardownRemoteListeners();

	      if (this.isLocalTab) {
	        // We started with a local tab and created the client ourselves, so we
	        // should close it.
	        this._client.close(cleanupAndResolve);
	      } else if (this.activeTab) {
	        // The client was handed to us, so we are not responsible for closing
	        // it. We just need to detach from the tab, if already attached.
	        // |detach| may fail if the connection is already dead, so proceed with
	        // cleanup directly after this.
	        this.activeTab.detach();
	        cleanupAndResolve();
	      } else {
	        cleanupAndResolve();
	      }
	    }

	    return this._destroyer.promise;
	  },

	  /**
	   * Clean up references to what this target points to.
	   */
	  _cleanup: function () {
	    if (this._tab) {
	      targets.delete(this._tab);
	    } else {
	      promiseTargets.delete(this._form);
	    }

	    this.activeTab = null;
	    this.activeConsole = null;
	    this._client = null;
	    this._tab = null;
	    this._form = null;
	    this._remote = null;
	    this._root = null;
	  },

	  toString: function () {
	    let id = this._tab ? this._tab : (this._form && this._form.actor);
	    return `TabTarget:${id}`;
	  },

	  /**
	   * @see TabActor.prototype.onResolveLocation
	   */
	  resolveLocation(loc) {
	    let deferred = defer();

	    this.client.request(Object.assign({
	      to: this._form.actor,
	      type: "resolveLocation",
	    }, loc), deferred.resolve);

	    return deferred.promise;
	  },
	};

	/**
	 * WebProgressListener for TabTarget.
	 *
	 * @param object aTarget
	 *        The TabTarget instance to work with.
	 */
	function TabWebProgressListener(aTarget) {
	  this.target = aTarget;
	}

	TabWebProgressListener.prototype = {
	  target: null,

	  QueryInterface: XPCOMUtils.generateQI([Ci.nsIWebProgressListener,
	                                         Ci.nsISupportsWeakReference]),

	  onStateChange: function (progress, request, flag) {
	    let isStart = flag & Ci.nsIWebProgressListener.STATE_START;
	    let isDocument = flag & Ci.nsIWebProgressListener.STATE_IS_DOCUMENT;
	    let isNetwork = flag & Ci.nsIWebProgressListener.STATE_IS_NETWORK;
	    let isRequest = flag & Ci.nsIWebProgressListener.STATE_IS_REQUEST;

	    // Skip non-interesting states.
	    if (!isStart || !isDocument || !isRequest || !isNetwork) {
	      return;
	    }

	    // emit event if the top frame is navigating
	    if (progress.isTopLevel) {
	      // Emit the event if the target is not remoted or store the payload for
	      // later emission otherwise.
	      if (this.target._client) {
	        this.target._navRequest = request;
	      } else {
	        this.target.emit("will-navigate", request);
	      }
	    }
	  },

	  onProgressChange: function () {},
	  onSecurityChange: function () {},
	  onStatusChange: function () {},

	  onLocationChange: function (webProgress, request, URI, flags) {
	    if (this.target &&
	        !(flags & Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT)) {
	      let window = webProgress.DOMWindow;
	      // Emit the event if the target is not remoted or store the payload for
	      // later emission otherwise.
	      if (this.target._client) {
	        this.target._navWindow = window;
	      } else {
	        this.target.emit("navigate", window);
	      }
	    }
	  },

	  /**
	   * Destroy the progress listener instance.
	   */
	  destroy: function () {
	    if (this.target.tab) {
	      try {
	        this.target.tab.linkedBrowser.removeProgressListener(this);
	      } catch (ex) {
	        // This can throw when a tab crashes in e10s.
	      }
	    }
	    this.target._webProgressListener = null;
	    this.target._navRequest = null;
	    this.target._navWindow = null;
	    this.target = null;
	  }
	};

	function WorkerTarget(workerClient) {
	  EventEmitter.decorate(this);
	  this._workerClient = workerClient;
	}

	/**
	 * A WorkerTarget represents a worker. Unlike TabTarget, which can represent
	 * either a local or remote tab, WorkerTarget always represents a remote worker.
	 * Moreover, unlike TabTarget, which is constructed with a placeholder object
	 * for remote tabs (from which a TabClient can then be lazily obtained),
	 * WorkerTarget is constructed with a WorkerClient directly.
	 *
	 * WorkerClient is designed to mimic the interface of TabClient as closely as
	 * possible. This allows us to debug workers as if they were ordinary tabs,
	 * requiring only minimal changes to the rest of the frontend.
	 */
	WorkerTarget.prototype = {
	  get isRemote() {
	    return true;
	  },

	  get isTabActor() {
	    return true;
	  },

	  get name() {
	    return "Worker";
	  },

	  get url() {
	    return this._workerClient.url;
	  },

	  get isWorkerTarget() {
	    return true;
	  },

	  get form() {
	    return {
	      consoleActor: this._workerClient.consoleActor
	    };
	  },

	  get activeTab() {
	    return this._workerClient;
	  },

	  get client() {
	    return this._workerClient.client;
	  },

	  destroy: function () {
	    this._workerClient.detach();
	  },

	  hasActor: function (name) {
	    // console is the only one actor implemented by WorkerActor
	    if (name == "console") {
	      return true;
	    }
	    return false;
	  },

	  getTrait: function () {
	    return undefined;
	  },

	  makeRemote: function () {
	    return Promise.resolve();
	  }
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Cc, Ci, Cu, Cr } = __webpack_require__(9);
	const promise = __webpack_require__(4);
	const EventEmitter = __webpack_require__(6);
	const DevToolsUtils = __webpack_require__(8);

	function DebuggerPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this._toolbox = toolbox;
	  this._destroyer = null;

	  this._view = this.panelWin.DebuggerView;
	  this._controller = this.panelWin.DebuggerController;
	  this._view._hostType = this._toolbox.hostType;
	  this._controller._target = this.target;
	  this._controller._toolbox = this._toolbox;

	  this.handleHostChanged = this.handleHostChanged.bind(this);
	  EventEmitter.decorate(this);
	}

	exports.DebuggerPanel = DebuggerPanel;

	DebuggerPanel.prototype = {
	  /**
	   * Open is effectively an asynchronous constructor.
	   *
	   * @return object
	   *         A promise that is resolved when the Debugger completes opening.
	   */
	  open: function () {
	    let targetPromise;

	    // Local debugging needs to make the target remote.
	    if (!this.target.isRemote) {
	      targetPromise = this.target.makeRemote();
	      // Listen for tab switching events to manage focus when the content window
	      // is paused and events suppressed.
	      this.target.tab.addEventListener("TabSelect", this);
	    } else {
	      targetPromise = promise.resolve(this.target);
	    }

	    return targetPromise
	      .then(() => this._controller.startupDebugger())
	      .then(() => this._controller.connect())
	      .then(() => {
	        this._toolbox.on("host-changed", this.handleHostChanged);
	        // Add keys from this document's keyset to the toolbox, so they
	        // can work when the split console is focused.
	        let keysToClone = ["resumeKey", "resumeKey2", "stepOverKey",
	                          "stepOverKey2", "stepInKey", "stepInKey2",
	                          "stepOutKey", "stepOutKey2"];
	        for (let key of keysToClone) {
	          let elm = this.panelWin.document.getElementById(key);
	          this._toolbox.useKeyWithSplitConsole(elm, "jsdebugger");
	        }
	        this.isReady = true;
	        this.emit("ready");
	        return this;
	      })
	      .then(null, function onError(aReason) {
	        DevToolsUtils.reportException("DebuggerPanel.prototype.open", aReason);
	      });
	  },

	  // DevToolPanel API

	  get target() {
	    return this._toolbox.target;
	  },

	  destroy: function () {
	    // Make sure this panel is not already destroyed.
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    if (!this.target.isRemote) {
	      this.target.tab.removeEventListener("TabSelect", this);
	    }

	    return this._destroyer = this._controller.shutdownDebugger().then(() => {
	      this.emit("destroyed");
	    });
	  },

	  // DebuggerPanel API

	  addBreakpoint: function (location) {
	    const { actions } = this.panelWin;
	    const { dispatch } = this._controller;

	    return dispatch(actions.addBreakpoint(location));
	  },

	  removeBreakpoint: function (location) {
	    const { actions } = this.panelWin;
	    const { dispatch } = this._controller;

	    return dispatch(actions.removeBreakpoint(location));
	  },

	  blackbox: function (source, flag) {
	    const { actions } = this.panelWin;
	    const { dispatch } = this._controller;
	    return dispatch(actions.blackbox(source, flag));
	  },

	  handleHostChanged: function () {
	    this._view.handleHostChanged(this._toolbox.hostType);
	  },

	  // nsIDOMEventListener API

	  handleEvent: function (aEvent) {
	    if (aEvent.target == this.target.tab &&
	        this._controller.activeThread.state == "paused") {
	      // Wait a tick for the content focus event to be delivered.
	      DevToolsUtils.executeSoon(() => this._toolbox.focusTool("jsdebugger"));
	    }
	  }
	};


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var Services = __webpack_require__(1);
	var promise = __webpack_require__(4);
	var {Task} = __webpack_require__(15);
	var {XPCOMUtils} = __webpack_require__(9);
	var EventEmitter = __webpack_require__(6);

	var {StyleEditorUI} = __webpack_require__(9);
	var {getString} = __webpack_require__(9);
	var {initCssProperties} = __webpack_require__(16);

	({ lazyRequireGetter: () => {} }).lazyGetter(this, "StyleSheetsFront",
	  () => __webpack_require__(143).StyleSheetsFront);

	({ lazyRequireGetter: () => {} }).lazyGetter(this, "StyleEditorFront",
	  () => __webpack_require__(146).StyleEditorFront);

	var StyleEditorPanel = function StyleEditorPanel(panelWin, toolbox) {
	  EventEmitter.decorate(this);

	  this._toolbox = toolbox;
	  this._target = toolbox.target;
	  this._panelWin = panelWin;
	  this._panelDoc = panelWin.document;

	  this.destroy = this.destroy.bind(this);
	  this._showError = this._showError.bind(this);
	};

	exports.StyleEditorPanel = StyleEditorPanel;

	StyleEditorPanel.prototype = {
	  get target() {
	    return this._toolbox.target;
	  },

	  get panelWindow() {
	    return this._panelWin;
	  },

	  /**
	   * open is effectively an asynchronous constructor
	   */
	  open: Task.async(function* () {
	    // We always interact with the target as if it were remote
	    if (!this.target.isRemote) {
	      yield this.target.makeRemote();
	    }

	    this.target.on("close", this.destroy);

	    if (this.target.form.styleSheetsActor) {
	      this._debuggee = StyleSheetsFront(this.target.client, this.target.form);
	    } else {
	      /* We're talking to a pre-Firefox 29 server-side */
	      this._debuggee = StyleEditorFront(this.target.client, this.target.form);
	    }

	    // Initialize the CSS properties database.
	    const {cssProperties} = yield initCssProperties(this._toolbox);

	    // Initialize the UI
	    this.UI = new StyleEditorUI(this._debuggee, this.target, this._panelDoc,
	                                cssProperties);
	    this.UI.on("error", this._showError);
	    yield this.UI.initialize();

	    this.isReady = true;

	    return this;
	  }),

	  /**
	   * Show an error message from the style editor in the toolbox
	   * notification box.
	   *
	   * @param  {string} event
	   *         Type of event
	   * @param  {string} data
	   *         The parameters to customize the error message
	   */
	  _showError: function (event, data) {
	    if (!this._toolbox) {
	      // could get an async error after we've been destroyed
	      return;
	    }

	    let errorMessage = getString(data.key);
	    if (data.append) {
	      errorMessage += " " + data.append;
	    }

	    let notificationBox = this._toolbox.getNotificationBox();
	    let notification =
	        notificationBox.getNotificationWithValue("styleeditor-error");
	    let level = (data.level === "info") ?
	                notificationBox.PRIORITY_INFO_LOW :
	                notificationBox.PRIORITY_CRITICAL_LOW;

	    if (!notification) {
	      notificationBox.appendNotification(errorMessage, "styleeditor-error",
	                                         "", level);
	    }
	  },

	  /**
	   * Select a stylesheet.
	   *
	   * @param {string} href
	   *        Url of stylesheet to find and select in editor
	   * @param {number} line
	   *        Line number to jump to after selecting. One-indexed
	   * @param {number} col
	   *        Column number to jump to after selecting. One-indexed
	   * @return {Promise}
	   *         Promise that will resolve when the editor is selected and ready
	   *         to be used.
	   */
	  selectStyleSheet: function (href, line, col) {
	    if (!this._debuggee || !this.UI) {
	      return null;
	    }
	    return this.UI.selectStyleSheet(href, line - 1, col ? col - 1 : 0);
	  },

	  /**
	   * Destroy the style editor.
	   */
	  destroy: function () {
	    if (!this._destroyed) {
	      this._destroyed = true;

	      this._target.off("close", this.destroy);
	      this._target = null;
	      this._toolbox = null;
	      this._panelWin = null;
	      this._panelDoc = null;
	      this._debuggee.destroy();
	      this._debuggee = null;

	      this.UI.destroy();
	      this.UI = null;
	    }

	    return promise.resolve(null);
	  },
	};

	XPCOMUtils.defineLazyGetter(StyleEditorPanel.prototype, "strings",
	  function () {
	    return Services.strings.createBundle(
	            "chrome://devtools/locale/styleeditor.properties");
	  });


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Front, FrontClassWithSpec } = __webpack_require__(17);
	const {
	  getIndentationFromPrefs,
	  getIndentationFromString
	} = __webpack_require__(144);
	const {
	  originalSourceSpec,
	  mediaRuleSpec,
	  styleSheetSpec,
	  styleSheetsSpec
	} = __webpack_require__(145);
	const promise = __webpack_require__(4);
	const { Task } = __webpack_require__(15);
	const events = __webpack_require__(21);

	/**
	 * The client-side counterpart for an OriginalSourceActor.
	 */
	const OriginalSourceFront = FrontClassWithSpec(originalSourceSpec, {
	  initialize: function (client, form) {
	    Front.prototype.initialize.call(this, client, form);

	    this.isOriginalSource = true;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  get href() {
	    return this._form.url;
	  },
	  get url() {
	    return this._form.url;
	  }
	});

	exports.OriginalSourceFront = OriginalSourceFront;

	/**
	 * Corresponding client-side front for a MediaRuleActor.
	 */
	const MediaRuleFront = FrontClassWithSpec(mediaRuleSpec, {
	  initialize: function (client, form) {
	    Front.prototype.initialize.call(this, client, form);

	    this._onMatchesChange = this._onMatchesChange.bind(this);
	    events.on(this, "matches-change", this._onMatchesChange);
	  },

	  _onMatchesChange: function (matches) {
	    this._form.matches = matches;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  get mediaText() {
	    return this._form.mediaText;
	  },
	  get conditionText() {
	    return this._form.conditionText;
	  },
	  get matches() {
	    return this._form.matches;
	  },
	  get line() {
	    return this._form.line || -1;
	  },
	  get column() {
	    return this._form.column || -1;
	  },
	  get parentStyleSheet() {
	    return this.conn.getActor(this._form.parentStyleSheet);
	  }
	});

	exports.MediaRuleFront = MediaRuleFront;

	/**
	 * StyleSheetFront is the client-side counterpart to a StyleSheetActor.
	 */
	const StyleSheetFront = FrontClassWithSpec(styleSheetSpec, {
	  initialize: function (conn, form) {
	    Front.prototype.initialize.call(this, conn, form);

	    this._onPropertyChange = this._onPropertyChange.bind(this);
	    events.on(this, "property-change", this._onPropertyChange);
	  },

	  destroy: function () {
	    events.off(this, "property-change", this._onPropertyChange);
	    Front.prototype.destroy.call(this);
	  },

	  _onPropertyChange: function (property, value) {
	    this._form[property] = value;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  get href() {
	    return this._form.href;
	  },
	  get nodeHref() {
	    return this._form.nodeHref;
	  },
	  get disabled() {
	    return !!this._form.disabled;
	  },
	  get title() {
	    return this._form.title;
	  },
	  get isSystem() {
	    return this._form.system;
	  },
	  get styleSheetIndex() {
	    return this._form.styleSheetIndex;
	  },
	  get ruleCount() {
	    return this._form.ruleCount;
	  },

	  /**
	   * Get the indentation to use for edits to this style sheet.
	   *
	   * @return {Promise} A promise that will resolve to a string that
	   * should be used to indent a block in this style sheet.
	   */
	  guessIndentation: function () {
	    let prefIndent = getIndentationFromPrefs();
	    if (prefIndent) {
	      let {indentUnit, indentWithTabs} = prefIndent;
	      return promise.resolve(indentWithTabs ? "\t" : " ".repeat(indentUnit));
	    }

	    return Task.spawn(function* () {
	      let longStr = yield this.getText();
	      let source = yield longStr.string();

	      let {indentUnit, indentWithTabs} = getIndentationFromString(source);

	      return indentWithTabs ? "\t" : " ".repeat(indentUnit);
	    }.bind(this));
	  }
	});

	exports.StyleSheetFront = StyleSheetFront;

	/**
	 * The corresponding Front object for the StyleSheetsActor.
	 */
	const StyleSheetsFront = FrontClassWithSpec(styleSheetsSpec, {
	  initialize: function (client, tabForm) {
	    Front.prototype.initialize.call(this, client);
	    this.actorID = tabForm.styleSheetsActor;
	    this.manage(this);
	  }
	});

	exports.StyleSheetsFront = StyleSheetsFront;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2; fill-column: 80 -*- */
	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);

	const EXPAND_TAB = "devtools.editor.expandtab";
	const TAB_SIZE = "devtools.editor.tabsize";
	const DETECT_INDENT = "devtools.editor.detectindentation";
	const DETECT_INDENT_MAX_LINES = 500;

	/**
	 * Get the indentation to use in an editor, or return false if the user has
	 * asked for the indentation to be guessed from some text.
	 *
	 * @return {false | Object}
	 *        Returns false if the "detect indentation" pref is set.
	 *        an object of the form {indentUnit, indentWithTabs}.
	 *        |indentUnit| is the number of indentation units to use
	 *        to indent a "block".
	 *        |indentWithTabs| is a boolean which is true if indentation
	 *        should be done using tabs.
	 */
	function getIndentationFromPrefs() {
	  let shouldDetect = Services.prefs.getBoolPref(DETECT_INDENT);
	  if (shouldDetect) {
	    return false;
	  }

	  let indentWithTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
	  let indentUnit = Services.prefs.getIntPref(TAB_SIZE);
	  return {indentUnit, indentWithTabs};
	}

	/**
	 * Given a function that can iterate over some text, compute the indentation to
	 * use.  This consults various prefs to arrive at a decision.
	 *
	 * @param {Function} iterFunc A function of three arguments:
	 *        (start, end, callback); where |start| and |end| describe
	 *        the range of text lines to examine, and |callback| is a function
	 *        to be called with the text of each line.
	 *
	 * @return {Object} an object of the form {indentUnit, indentWithTabs}.
	 *        |indentUnit| is the number of indentation units to use
	 *        to indent a "block".
	 *        |indentWithTabs| is a boolean which is true if indentation
	 *        should be done using tabs.
	 */
	function getIndentationFromIteration(iterFunc) {
	  let indentWithTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
	  let indentUnit = Services.prefs.getIntPref(TAB_SIZE);
	  let shouldDetect = Services.prefs.getBoolPref(DETECT_INDENT);

	  if (shouldDetect) {
	    let indent = detectIndentation(iterFunc);
	    if (indent != null) {
	      indentWithTabs = indent.tabs;
	      indentUnit = indent.spaces ? indent.spaces : indentUnit;
	    }
	  }

	  return {indentUnit, indentWithTabs};
	}

	/**
	 * A wrapper for @see getIndentationFromIteration which computes the
	 * indentation of a given string.
	 *
	 * @param {String} string the input text
	 * @return {Object} an object of the same form as returned by
	 *                  getIndentationFromIteration
	 */
	function getIndentationFromString(string) {
	  let iteratorFn = function (start, end, callback) {
	    let split = string.split(/\r\n|\r|\n|\f/);
	    split.slice(start, end).forEach(callback);
	  };
	  return getIndentationFromIteration(iteratorFn);
	}

	/**
	 * Detect the indentation used in an editor. Returns an object
	 * with 'tabs' - whether this is tab-indented and 'spaces' - the
	 * width of one indent in spaces. Or `null` if it's inconclusive.
	 */
	function detectIndentation(textIteratorFn) {
	  // # spaces indent -> # lines with that indent
	  let spaces = {};
	  // indentation width of the last line we saw
	  let last = 0;
	  // # of lines that start with a tab
	  let tabs = 0;
	  // # of indented lines (non-zero indent)
	  let total = 0;

	  textIteratorFn(0, DETECT_INDENT_MAX_LINES, (text) => {
	    if (text.startsWith("\t")) {
	      tabs++;
	      total++;
	      return;
	    }
	    let width = 0;
	    while (text[width] === " ") {
	      width++;
	    }
	    // don't count lines that are all spaces
	    if (width == text.length) {
	      last = 0;
	      return;
	    }
	    if (width > 1) {
	      total++;
	    }

	    // see how much this line is offset from the line above it
	    let indent = Math.abs(width - last);
	    if (indent > 1 && indent <= 8) {
	      spaces[indent] = (spaces[indent] || 0) + 1;
	    }
	    last = width;
	  });

	  // this file is not indented at all
	  if (total == 0) {
	    return null;
	  }

	  // mark as tabs if they start more than half the lines
	  if (tabs >= total / 2) {
	    return { tabs: true };
	  }

	  // find most frequent non-zero width difference between adjacent lines
	  let freqIndent = null, max = 1;
	  for (let width in spaces) {
	    width = parseInt(width, 10);
	    let tally = spaces[width];
	    if (tally > max) {
	      max = tally;
	      freqIndent = width;
	    }
	  }
	  if (!freqIndent) {
	    return null;
	  }

	  return { tabs: false, spaces: freqIndent };
	}

	exports.EXPAND_TAB = EXPAND_TAB;
	exports.TAB_SIZE = TAB_SIZE;
	exports.DETECT_INDENT = DETECT_INDENT;
	exports.getIndentationFromPrefs = getIndentationFromPrefs;
	exports.getIndentationFromIteration = getIndentationFromIteration;
	exports.getIndentationFromString = getIndentationFromString;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  RetVal,
	  generateActorSpec,
	  types
	} = __webpack_require__(17);

	const originalSourceSpec = generateActorSpec({
	  typeName: "originalsource",

	  methods: {
	    getText: {
	      response: {
	        text: RetVal("longstring")
	      }
	    }
	  }
	});

	exports.originalSourceSpec = originalSourceSpec;

	const mediaRuleSpec = generateActorSpec({
	  typeName: "mediarule",

	  events: {
	    "matches-change": {
	      type: "matchesChange",
	      matches: Arg(0, "boolean"),
	    }
	  }
	});

	exports.mediaRuleSpec = mediaRuleSpec;

	types.addActorType("stylesheet");

	const styleSheetSpec = generateActorSpec({
	  typeName: "stylesheet",

	  events: {
	    "property-change": {
	      type: "propertyChange",
	      property: Arg(0, "string"),
	      value: Arg(1, "json")
	    },
	    "style-applied": {
	      type: "styleApplied",
	      kind: Arg(0, "number"),
	      styleSheet: Arg(1, "stylesheet")
	    },
	    "media-rules-changed": {
	      type: "mediaRulesChanged",
	      rules: Arg(0, "array:mediarule")
	    }
	  },

	  methods: {
	    toggleDisabled: {
	      response: { disabled: RetVal("boolean")}
	    },
	    getText: {
	      response: {
	        text: RetVal("longstring")
	      }
	    },
	    getOriginalSources: {
	      request: {},
	      response: {
	        originalSources: RetVal("nullable:array:originalsource")
	      }
	    },
	    getOriginalLocation: {
	      request: {
	        line: Arg(0, "number"),
	        column: Arg(1, "number")
	      },
	      response: RetVal(types.addDictType("originallocationresponse", {
	        source: "string",
	        line: "number",
	        column: "number"
	      }))
	    },
	    getMediaRules: {
	      request: {},
	      response: {
	        mediaRules: RetVal("nullable:array:mediarule")
	      }
	    },
	    update: {
	      request: {
	        text: Arg(0, "string"),
	        transition: Arg(1, "boolean")
	      }
	    }
	  }
	});

	exports.styleSheetSpec = styleSheetSpec;

	const styleSheetsSpec = generateActorSpec({
	  typeName: "stylesheets",

	  methods: {
	    getStyleSheets: {
	      request: {},
	      response: { styleSheets: RetVal("array:stylesheet") }
	    },
	    addStyleSheet: {
	      request: { text: Arg(0, "string") },
	      response: { styleSheet: RetVal("stylesheet") }
	    }
	  }
	});

	exports.styleSheetsSpec = styleSheetsSpec;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { SimpleStringFront } = __webpack_require__(147);
	const { Front, FrontClassWithSpec } = __webpack_require__(17);
	const {
	  oldStyleSheetSpec,
	  styleEditorSpec
	} = __webpack_require__(149);
	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);
	const events = __webpack_require__(21);

	/**
	 * StyleSheetFront is the client-side counterpart to a StyleSheetActor.
	 */
	const OldStyleSheetFront = FrontClassWithSpec(oldStyleSheetSpec, {
	  initialize: function (conn, form, ctx, detail) {
	    Front.prototype.initialize.call(this, conn, form, ctx, detail);

	    this._onPropertyChange = this._onPropertyChange.bind(this);
	    events.on(this, "property-change", this._onPropertyChange);
	  },

	  destroy: function () {
	    events.off(this, "property-change", this._onPropertyChange);

	    Front.prototype.destroy.call(this);
	  },

	  _onPropertyChange: function (property, value) {
	    this._form[property] = value;
	  },

	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }
	    this.actorID = form.actor;
	    this._form = form;
	  },

	  getText: function () {
	    let deferred = defer();

	    events.once(this, "source-load", (source) => {
	      let longStr = new SimpleStringFront(source);
	      deferred.resolve(longStr);
	    });
	    this.fetchSource();

	    return deferred.promise;
	  },

	  getOriginalSources: function () {
	    return promise.resolve([]);
	  },

	  get href() {
	    return this._form.href;
	  },
	  get nodeHref() {
	    return this._form.nodeHref;
	  },
	  get disabled() {
	    return !!this._form.disabled;
	  },
	  get title() {
	    return this._form.title;
	  },
	  get isSystem() {
	    return this._form.system;
	  },
	  get styleSheetIndex() {
	    return this._form.styleSheetIndex;
	  },
	  get ruleCount() {
	    return this._form.ruleCount;
	  }
	});

	exports.OldStyleSheetFront = OldStyleSheetFront;

	/**
	 * The corresponding Front object for the StyleEditorActor.
	 */
	const StyleEditorFront = FrontClassWithSpec(styleEditorSpec, {
	  initialize: function (client, tabForm) {
	    Front.prototype.initialize.call(this, client);
	    this.actorID = tabForm.styleEditorActor;
	    this.manage(this);
	  },

	  getStyleSheets: function () {
	    let deferred = defer();

	    events.once(this, "document-load", (styleSheets) => {
	      deferred.resolve(styleSheets);
	    });
	    this.newDocument();

	    return deferred.promise;
	  },

	  addStyleSheet: function (text) {
	    return this.newStyleSheet(text);
	  }
	});

	exports.StyleEditorFront = StyleEditorFront;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {DebuggerServer} = __webpack_require__(148);
	const promise = __webpack_require__(4);
	const {longStringSpec, SimpleStringFront} = __webpack_require__(27);
	const protocol = __webpack_require__(17);

	const LongStringFront = protocol.FrontClassWithSpec(longStringSpec, {
	  initialize: function (client) {
	    protocol.Front.prototype.initialize.call(this, client);
	  },

	  destroy: function () {
	    this.initial = null;
	    this.length = null;
	    this.strPromise = null;
	    protocol.Front.prototype.destroy.call(this);
	  },

	  form: function (form) {
	    this.actorID = form.actor;
	    this.initial = form.initial;
	    this.length = form.length;
	  },

	  string: function () {
	    if (!this.strPromise) {
	      let promiseRest = (thusFar) => {
	        if (thusFar.length === this.length) {
	          return promise.resolve(thusFar);
	        }
	        return this.substring(thusFar.length,
	                              thusFar.length + DebuggerServer.LONG_STRING_READ_LENGTH)
	          .then((next) => promiseRest(thusFar + next));
	      };

	      this.strPromise = promiseRest(this.initial);
	    }
	    return this.strPromise;
	  }
	});

	exports.LongStringFront = LongStringFront;
	exports.SimpleStringFront = SimpleStringFront;


/***/ },
/* 148 */
/***/ function(module, exports) {

	module.exports = devtools/server/main;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Arg, RetVal, generateActorSpec } = __webpack_require__(17);

	const oldStyleSheetSpec = generateActorSpec({
	  typeName: "old-stylesheet",

	  events: {
	    "property-change": {
	      type: "propertyChange",
	      property: Arg(0, "string"),
	      value: Arg(1, "json")
	    },
	    "source-load": {
	      type: "sourceLoad",
	      source: Arg(0, "string")
	    },
	    "style-applied": {
	      type: "styleApplied"
	    }
	  },

	  methods: {
	    toggleDisabled: {
	      response: { disabled: RetVal("boolean")}
	    },
	    fetchSource: {},
	    update: {
	      request: {
	        text: Arg(0, "string"),
	        transition: Arg(1, "boolean")
	      }
	    }
	  }
	});

	exports.oldStyleSheetSpec = oldStyleSheetSpec;

	const styleEditorSpec = generateActorSpec({
	  typeName: "styleeditor",

	  events: {
	    "document-load": {
	      type: "documentLoad",
	      styleSheets: Arg(0, "array:old-stylesheet")
	    }
	  },

	  method: {
	    newDocument: {},
	    newStyleSheet: {
	      request: { text: Arg(0, "string") },
	      response: { styleSheet: RetVal("old-stylesheet") }
	    }
	  }
	});

	exports.styleEditorSpec = styleEditorSpec;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Cc, Ci, Cu, Cr } = __webpack_require__(9);
	const promise = __webpack_require__(4);
	const EventEmitter = __webpack_require__(6);
	const { WebGLFront } = __webpack_require__(151);
	const DevToolsUtils = __webpack_require__(8);

	function ShaderEditorPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this._toolbox = toolbox;
	  this._destroyer = null;

	  EventEmitter.decorate(this);
	}

	exports.ShaderEditorPanel = ShaderEditorPanel;

	ShaderEditorPanel.prototype = {
	  /**
	   * Open is effectively an asynchronous constructor.
	   *
	   * @return object
	   *         A promise that is resolved when the Shader Editor completes opening.
	   */
	  open: function () {
	    let targetPromise;

	    // Local debugging needs to make the target remote.
	    if (!this.target.isRemote) {
	      targetPromise = this.target.makeRemote();
	    } else {
	      targetPromise = promise.resolve(this.target);
	    }

	    return targetPromise
	      .then(() => {
	        this.panelWin.gToolbox = this._toolbox;
	        this.panelWin.gTarget = this.target;
	        this.panelWin.gFront = new WebGLFront(this.target.client, this.target.form);
	        return this.panelWin.startupShaderEditor();
	      })
	      .then(() => {
	        this.isReady = true;
	        this.emit("ready");
	        return this;
	      })
	      .then(null, function onError(aReason) {
	        DevToolsUtils.reportException("ShaderEditorPanel.prototype.open", aReason);
	      });
	  },

	  // DevToolPanel API

	  get target() {
	    return this._toolbox.target;
	  },

	  destroy: function () {
	    // Make sure this panel is not already destroyed.
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    return this._destroyer = this.panelWin.shutdownShaderEditor().then(() => {
	      // Destroy front to ensure packet handler is removed from client
	      this.panelWin.gFront.destroy();
	      this.emit("destroyed");
	    });
	  }
	};


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  shaderSpec,
	  programSpec,
	  webGLSpec,
	} = __webpack_require__(152);
	const protocol = __webpack_require__(17);

	/**
	 * The corresponding Front object for the ShaderActor.
	 */
	const ShaderFront = protocol.FrontClassWithSpec(shaderSpec, {
	  initialize: function (client, form) {
	    protocol.Front.prototype.initialize.call(this, client, form);
	  }
	});

	exports.ShaderFront = ShaderFront;

	/**
	 * The corresponding Front object for the ProgramActor.
	 */
	const ProgramFront = protocol.FrontClassWithSpec(programSpec, {
	  initialize: function (client, form) {
	    protocol.Front.prototype.initialize.call(this, client, form);
	  }
	});

	exports.ProgramFront = ProgramFront;

	/**
	 * The corresponding Front object for the WebGLActor.
	 */
	const WebGLFront = protocol.FrontClassWithSpec(webGLSpec, {
	  initialize: function (client, { webglActor }) {
	    protocol.Front.prototype.initialize.call(this, client, { actor: webglActor });
	    this.manage(this);
	  }
	});

	exports.WebGLFront = WebGLFront;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {Arg, Option, RetVal, generateActorSpec} = __webpack_require__(17);

	const shaderSpec = generateActorSpec({
	  typeName: "gl-shader",

	  methods: {
	    getText: {
	      response: { text: RetVal("string") }
	    },
	    compile: {
	      request: { text: Arg(0, "string") },
	      response: { error: RetVal("nullable:json") }
	    },
	  },
	});

	exports.shaderSpec = shaderSpec;

	const programSpec = generateActorSpec({
	  typeName: "gl-program",

	  methods: {
	    getVertexShader: {
	      response: { shader: RetVal("gl-shader") }
	    },
	    getFragmentShader: {
	      response: { shader: RetVal("gl-shader") }
	    },
	    highlight: {
	      request: { tint: Arg(0, "array:number") },
	      oneway: true
	    },
	    unhighlight: {
	      oneway: true
	    },
	    blackbox: {
	      oneway: true
	    },
	    unblackbox: {
	      oneway: true
	    },
	  }
	});

	exports.programSpec = programSpec;

	const webGLSpec = generateActorSpec({
	  typeName: "webgl",

	  /**
	   * Events emitted by this actor. The "program-linked" event is fired every
	   * time a WebGL program was linked with its respective two shaders.
	   */
	  events: {
	    "program-linked": {
	      type: "programLinked",
	      program: Arg(0, "gl-program")
	    },
	    "global-destroyed": {
	      type: "globalDestroyed",
	      program: Arg(0, "number")
	    },
	    "global-created": {
	      type: "globalCreated",
	      program: Arg(0, "number")
	    }
	  },

	  methods: {
	    setup: {
	      request: { reload: Option(0, "boolean") },
	      oneway: true
	    },
	    finalize: {
	      oneway: true
	    },
	    getPrograms: {
	      response: { programs: RetVal("array:gl-program") }
	    },
	    waitForFrame: {
	      response: { success: RetVal("nullable:json") }
	    },
	    getPixel: {
	      request: {
	        selector: Option(0, "string"),
	        position: Option(0, "json")
	      },
	      response: { pixels: RetVal("json") }
	    },
	    _getAllPrograms: {
	      response: { programs: RetVal("array:gl-program") }
	    }
	  }
	});

	exports.webGLSpec = webGLSpec;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Cc, Ci, Cu, Cr } = __webpack_require__(9);
	const promise = __webpack_require__(4);
	const EventEmitter = __webpack_require__(6);
	const { CanvasFront } = __webpack_require__(154);
	const DevToolsUtils = __webpack_require__(8);

	function CanvasDebuggerPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this._toolbox = toolbox;
	  this._destroyer = null;

	  EventEmitter.decorate(this);
	}

	exports.CanvasDebuggerPanel = CanvasDebuggerPanel;

	CanvasDebuggerPanel.prototype = {
	  /**
	   * Open is effectively an asynchronous constructor.
	   *
	   * @return object
	   *         A promise that is resolved when the Canvas Debugger completes opening.
	   */
	  open: function () {
	    let targetPromise;

	    // Local debugging needs to make the target remote.
	    if (!this.target.isRemote) {
	      targetPromise = this.target.makeRemote();
	    } else {
	      targetPromise = promise.resolve(this.target);
	    }

	    return targetPromise
	      .then(() => {
	        this.panelWin.gToolbox = this._toolbox;
	        this.panelWin.gTarget = this.target;
	        this.panelWin.gFront = new CanvasFront(this.target.client, this.target.form);
	        return this.panelWin.startupCanvasDebugger();
	      })
	      .then(() => {
	        this.isReady = true;
	        this.emit("ready");
	        return this;
	      })
	      .then(null, function onError(aReason) {
	        DevToolsUtils.reportException("CanvasDebuggerPanel.prototype.open", aReason);
	      });
	  },

	  // DevToolPanel API

	  get target() {
	    return this._toolbox.target;
	  },

	  destroy: function () {
	    // Make sure this panel is not already destroyed.
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    return this._destroyer = this.panelWin.shutdownCanvasDebugger().then(() => {
	      // Destroy front to ensure packet handler is removed from client
	      this.panelWin.gFront.destroy();
	      this.emit("destroyed");
	    });
	  }
	};


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  frameSnapshotSpec,
	  canvasSpec,
	  CANVAS_CONTEXTS,
	  ANIMATION_GENERATORS,
	  LOOP_GENERATORS,
	  DRAW_CALLS,
	  INTERESTING_CALLS,
	} = __webpack_require__(155);
	const protocol = __webpack_require__(17);
	const promise = __webpack_require__(4);

	/**
	 * The corresponding Front object for the FrameSnapshotActor.
	 */
	const FrameSnapshotFront = protocol.FrontClassWithSpec(frameSnapshotSpec, {
	  initialize: function (client, form) {
	    protocol.Front.prototype.initialize.call(this, client, form);
	    this._animationFrameEndScreenshot = null;
	    this._cachedScreenshots = new WeakMap();
	  },

	  /**
	   * This implementation caches the animation frame end screenshot to optimize
	   * frontend requests to `generateScreenshotFor`.
	   */
	  getOverview: protocol.custom(function () {
	    return this._getOverview().then(data => {
	      this._animationFrameEndScreenshot = data.screenshot;
	      return data;
	    });
	  }, {
	    impl: "_getOverview"
	  }),

	  /**
	   * This implementation saves a roundtrip to the backend if the screenshot
	   * was already generated and retrieved once.
	   */
	  generateScreenshotFor: protocol.custom(function (functionCall) {
	    if (CanvasFront.ANIMATION_GENERATORS.has(functionCall.name) ||
	        CanvasFront.LOOP_GENERATORS.has(functionCall.name)) {
	      return promise.resolve(this._animationFrameEndScreenshot);
	    }
	    let cachedScreenshot = this._cachedScreenshots.get(functionCall);
	    if (cachedScreenshot) {
	      return cachedScreenshot;
	    }
	    let screenshot = this._generateScreenshotFor(functionCall);
	    this._cachedScreenshots.set(functionCall, screenshot);
	    return screenshot;
	  }, {
	    impl: "_generateScreenshotFor"
	  })
	});

	exports.FrameSnapshotFront = FrameSnapshotFront;

	/**
	 * The corresponding Front object for the CanvasActor.
	 */
	const CanvasFront = protocol.FrontClassWithSpec(canvasSpec, {
	  initialize: function (client, { canvasActor }) {
	    protocol.Front.prototype.initialize.call(this, client, { actor: canvasActor });
	    this.manage(this);
	  }
	});

	/**
	 * Constants.
	 */
	CanvasFront.CANVAS_CONTEXTS = new Set(CANVAS_CONTEXTS);
	CanvasFront.ANIMATION_GENERATORS = new Set(ANIMATION_GENERATORS);
	CanvasFront.LOOP_GENERATORS = new Set(LOOP_GENERATORS);
	CanvasFront.DRAW_CALLS = new Set(DRAW_CALLS);
	CanvasFront.INTERESTING_CALLS = new Set(INTERESTING_CALLS);
	CanvasFront.THUMBNAIL_SIZE = 50;
	CanvasFront.WEBGL_SCREENSHOT_MAX_HEIGHT = 256;
	CanvasFront.INVALID_SNAPSHOT_IMAGE = {
	  index: -1,
	  width: 0,
	  height: 0,
	  pixels: []
	};

	exports.CanvasFront = CanvasFront;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const protocol = __webpack_require__(17);
	const {Arg, Option, RetVal, generateActorSpec} = protocol;

	/**
	 * Type representing an ArrayBufferView, serialized fast(er).
	 *
	 * Don't create a new array buffer view from the parsed array on the frontend.
	 * Consumers may copy the data into an existing buffer, or create a new one if
	 * necesasry. For example, this avoids the need for a redundant copy when
	 * populating ImageData objects, at the expense of transferring char views
	 * of a pixel buffer over the protocol instead of a packed int view.
	 *
	 * XXX: It would be nice if on local connections (only), we could just *give*
	 * the buffer directly to the front, instead of going through all this
	 * serialization redundancy.
	 */
	protocol.types.addType("array-buffer-view", {
	  write: (v) => "[" + Array.join(v, ",") + "]",
	  read: (v) => JSON.parse(v)
	});

	/**
	 * Type describing a thumbnail or screenshot in a recorded animation frame.
	 */
	protocol.types.addDictType("snapshot-image", {
	  index: "number",
	  width: "number",
	  height: "number",
	  scaling: "number",
	  flipped: "boolean",
	  pixels: "array-buffer-view"
	});

	/**
	 * Type describing an overview of a recorded animation frame.
	 */
	protocol.types.addDictType("snapshot-overview", {
	  calls: "array:function-call",
	  thumbnails: "array:snapshot-image",
	  screenshot: "snapshot-image"
	});

	exports.CANVAS_CONTEXTS = [
	  "CanvasRenderingContext2D",
	  "WebGLRenderingContext"
	];

	exports.ANIMATION_GENERATORS = [
	  "requestAnimationFrame"
	];

	exports.LOOP_GENERATORS = [
	  "setTimeout"
	];

	exports.DRAW_CALLS = [
	  // 2D canvas
	  "fill",
	  "stroke",
	  "clearRect",
	  "fillRect",
	  "strokeRect",
	  "fillText",
	  "strokeText",
	  "drawImage",

	  // WebGL
	  "clear",
	  "drawArrays",
	  "drawElements",
	  "finish",
	  "flush"
	];

	exports.INTERESTING_CALLS = [
	  // 2D canvas
	  "save",
	  "restore",

	  // WebGL
	  "useProgram"
	];

	const frameSnapshotSpec = generateActorSpec({
	  typeName: "frame-snapshot",

	  methods: {
	    getOverview: {
	      response: { overview: RetVal("snapshot-overview") }
	    },
	    generateScreenshotFor: {
	      request: { call: Arg(0, "function-call") },
	      response: { screenshot: RetVal("snapshot-image") }
	    },
	  },
	});

	exports.frameSnapshotSpec = frameSnapshotSpec;

	const canvasSpec = generateActorSpec({
	  typeName: "canvas",

	  methods: {
	    setup: {
	      request: { reload: Option(0, "boolean") },
	      oneway: true
	    },
	    finalize: {
	      oneway: true
	    },
	    isInitialized: {
	      response: { initialized: RetVal("boolean") }
	    },
	    isRecording: {
	      response: { recording: RetVal("boolean") }
	    },
	    recordAnimationFrame: {
	      response: { snapshot: RetVal("nullable:frame-snapshot") }
	    },
	    stopRecordingAnimationFrame: {
	      oneway: true
	    },
	  }
	});

	exports.canvasSpec = canvasSpec;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Cc, Ci, Cu, Cr } = __webpack_require__(9);
	const EventEmitter = __webpack_require__(6);
	const { WebAudioFront } = __webpack_require__(157);
	var Promise = __webpack_require__(4);

	function WebAudioEditorPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this._toolbox = toolbox;
	  this._destroyer = null;

	  EventEmitter.decorate(this);
	}

	exports.WebAudioEditorPanel = WebAudioEditorPanel;

	WebAudioEditorPanel.prototype = {
	  open: function () {
	    let targetPromise;

	    // Local debugging needs to make the target remote.
	    if (!this.target.isRemote) {
	      targetPromise = this.target.makeRemote();
	    } else {
	      targetPromise = Promise.resolve(this.target);
	    }

	    return targetPromise
	      .then(() => {
	        this.panelWin.gToolbox = this._toolbox;
	        this.panelWin.gTarget = this.target;

	        this.panelWin.gFront = new WebAudioFront(this.target.client, this.target.form);
	        return this.panelWin.startupWebAudioEditor();
	      })
	      .then(() => {
	        this.isReady = true;
	        this.emit("ready");
	        return this;
	      })
	      .then(null, function onError(aReason) {
	        console.error("WebAudioEditorPanel open failed. " +
	                      aReason.error + ": " + aReason.message);
	      });
	  },

	  // DevToolPanel API

	  get target() {
	    return this._toolbox.target;
	  },

	  destroy: function () {
	    // Make sure this panel is not already destroyed.
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    return this._destroyer = this.panelWin.shutdownWebAudioEditor().then(() => {
	      // Destroy front to ensure packet handler is removed from client
	      this.panelWin.gFront.destroy();
	      this.emit("destroyed");
	    });
	  }
	};


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  audionodeSpec,
	  webAudioSpec,
	  AUTOMATION_METHODS,
	  NODE_CREATION_METHODS,
	  NODE_ROUTING_METHODS,
	} = __webpack_require__(158);
	const protocol = __webpack_require__(17);
	const AUDIO_NODE_DEFINITION = __webpack_require__(159);

	/**
	 * The corresponding Front object for the AudioNodeActor.
	 *
	 * @attribute {String} type
	 *            The type of audio node, like "OscillatorNode", "MediaElementAudioSourceNode"
	 * @attribute {Boolean} source
	 *            Boolean indicating if the node is a source node, like BufferSourceNode,
	 *            MediaElementAudioSourceNode, OscillatorNode, etc.
	 * @attribute {Boolean} bypassable
	 *            Boolean indicating if the audio node is bypassable (splitter,
	 *            merger and destination nodes, for example, are not)
	 */
	const AudioNodeFront = protocol.FrontClassWithSpec(audionodeSpec, {
	  form: function (form, detail) {
	    if (detail === "actorid") {
	      this.actorID = form;
	      return;
	    }

	    this.actorID = form.actor;
	    this.type = form.type;
	    this.source = form.source;
	    this.bypassable = form.bypassable;
	  },

	  initialize: function (client, form) {
	    protocol.Front.prototype.initialize.call(this, client, form);
	    // if we were manually passed a form, this was created manually and
	    // needs to own itself for now.
	    if (form) {
	      this.manage(this);
	    }
	  }
	});

	exports.AudioNodeFront = AudioNodeFront;

	/**
	 * The corresponding Front object for the WebAudioActor.
	 */
	const WebAudioFront = protocol.FrontClassWithSpec(webAudioSpec, {
	  initialize: function (client, { webaudioActor }) {
	    protocol.Front.prototype.initialize.call(this, client, { actor: webaudioActor });
	    this.manage(this);
	  },

	  /**
	   * If connecting to older geckos (<Fx43), where audio node actor's do not
	   * contain `type`, `source` and `bypassable` properties, fetch
	   * them manually here.
	   */
	  _onCreateNode: protocol.preEvent("create-node", function (audionode) {
	    if (!audionode.type) {
	      return audionode.getType().then(type => {
	        audionode.type = type;
	        audionode.source = !!AUDIO_NODE_DEFINITION[type].source;
	        audionode.bypassable = !AUDIO_NODE_DEFINITION[type].unbypassable;
	      });
	    }
	    return null;
	  }),
	});

	WebAudioFront.AUTOMATION_METHODS = new Set(AUTOMATION_METHODS);
	WebAudioFront.NODE_CREATION_METHODS = new Set(NODE_CREATION_METHODS);
	WebAudioFront.NODE_ROUTING_METHODS = new Set(NODE_ROUTING_METHODS);

	exports.WebAudioFront = WebAudioFront;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  Option,
	  RetVal,
	  generateActorSpec,
	  types,
	} = __webpack_require__(17);

	exports.NODE_CREATION_METHODS = [
	  "createBufferSource", "createMediaElementSource", "createMediaStreamSource",
	  "createMediaStreamDestination", "createScriptProcessor", "createAnalyser",
	  "createGain", "createDelay", "createBiquadFilter", "createWaveShaper",
	  "createPanner", "createConvolver", "createChannelSplitter", "createChannelMerger",
	  "createDynamicsCompressor", "createOscillator", "createStereoPanner"
	];

	exports.AUTOMATION_METHODS = [
	  "setValueAtTime", "linearRampToValueAtTime", "exponentialRampToValueAtTime",
	  "setTargetAtTime", "setValueCurveAtTime", "cancelScheduledValues"
	];

	exports.NODE_ROUTING_METHODS = [
	  "connect", "disconnect"
	];

	types.addActorType("audionode");
	const audionodeSpec = generateActorSpec({
	  typeName: "audionode",

	  methods: {
	    getType: { response: { type: RetVal("string") }},
	    isBypassed: {
	      response: { bypassed: RetVal("boolean") }
	    },
	    bypass: {
	      request: { enable: Arg(0, "boolean") },
	      response: { bypassed: RetVal("boolean") }
	    },
	    setParam: {
	      request: {
	        param: Arg(0, "string"),
	        value: Arg(1, "nullable:primitive")
	      },
	      response: { error: RetVal("nullable:json") }
	    },
	    getParam: {
	      request: {
	        param: Arg(0, "string")
	      },
	      response: { text: RetVal("nullable:primitive") }
	    },
	    getParamFlags: {
	      request: { param: Arg(0, "string") },
	      response: { flags: RetVal("nullable:primitive") }
	    },
	    getParams: {
	      response: { params: RetVal("json") }
	    },
	    connectParam: {
	      request: {
	        destActor: Arg(0, "audionode"),
	        paramName: Arg(1, "string"),
	        output: Arg(2, "nullable:number")
	      },
	      response: { error: RetVal("nullable:json") }
	    },
	    connectNode: {
	      request: {
	        destActor: Arg(0, "audionode"),
	        output: Arg(1, "nullable:number"),
	        input: Arg(2, "nullable:number")
	      },
	      response: { error: RetVal("nullable:json") }
	    },
	    disconnect: {
	      request: { output: Arg(0, "nullable:number") },
	      response: { error: RetVal("nullable:json") }
	    },
	    getAutomationData: {
	      request: { paramName: Arg(0, "string") },
	      response: { values: RetVal("nullable:json") }
	    },
	    addAutomationEvent: {
	      request: {
	        paramName: Arg(0, "string"),
	        eventName: Arg(1, "string"),
	        args: Arg(2, "nullable:json")
	      },
	      response: { error: RetVal("nullable:json") }
	    },
	  }
	});

	exports.audionodeSpec = audionodeSpec;

	const webAudioSpec = generateActorSpec({
	  typeName: "webaudio",

	  /**
	   * Events emitted by this actor.
	   */
	  events: {
	    "start-context": {
	      type: "startContext"
	    },
	    "connect-node": {
	      type: "connectNode",
	      source: Option(0, "audionode"),
	      dest: Option(0, "audionode")
	    },
	    "disconnect-node": {
	      type: "disconnectNode",
	      source: Arg(0, "audionode")
	    },
	    "connect-param": {
	      type: "connectParam",
	      source: Option(0, "audionode"),
	      dest: Option(0, "audionode"),
	      param: Option(0, "string")
	    },
	    "change-param": {
	      type: "changeParam",
	      source: Option(0, "audionode"),
	      param: Option(0, "string"),
	      value: Option(0, "string")
	    },
	    "create-node": {
	      type: "createNode",
	      source: Arg(0, "audionode")
	    },
	    "destroy-node": {
	      type: "destroyNode",
	      source: Arg(0, "audionode")
	    },
	    "automation-event": {
	      type: "automationEvent",
	      node: Option(0, "audionode"),
	      paramName: Option(0, "string"),
	      eventName: Option(0, "string"),
	      args: Option(0, "json")
	    }
	  },

	  methods: {
	    getDefinition: {
	      response: { definition: RetVal("json") }
	    },
	    setup: {
	      request: { reload: Option(0, "boolean") },
	      oneway: true
	    },
	    finalize: {
	      oneway: true
	    }
	  }
	});

	exports.webAudioSpec = webAudioSpec;


/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = devtools/server/actors/utils/audionodes.json;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const { Cc, Ci, Cu, Cr } = __webpack_require__(9);
	const { Task } = __webpack_require__(15);
	const EventEmitter = __webpack_require__(6);
	const { MemoryFront } = __webpack_require__(161);
	const HeapAnalysesClient = __webpack_require__(163);
	const promise = __webpack_require__(4);

	function MemoryPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this._toolbox = toolbox;

	  EventEmitter.decorate(this);
	}

	MemoryPanel.prototype = {
	  open: Task.async(function* () {
	    if (this._opening) {
	      return this._opening;
	    }

	    this.panelWin.gToolbox = this._toolbox;
	    this.panelWin.gTarget = this.target;

	    const rootForm = yield this.target.root;
	    this.panelWin.gFront = new MemoryFront(this.target.client,
	                                           this.target.form,
	                                           rootForm);
	    this.panelWin.gHeapAnalysesClient = new HeapAnalysesClient();

	    yield this.panelWin.gFront.attach();

	    this._opening = this.panelWin.initialize().then(() => {
	      this.isReady = true;
	      this.emit("ready");
	      return this;
	    });

	    return this._opening;
	  }),

	  // DevToolPanel API

	  get target() {
	    return this._toolbox.target;
	  },

	  destroy: Task.async(function* () {
	    // Make sure this panel is not already destroyed.
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    yield this.panelWin.gFront.detach();

	    this._destroyer = this.panelWin.destroy().then(() => {
	      // Destroy front to ensure packet handler is removed from client
	      this.panelWin.gFront.destroy();
	      this.panelWin.gHeapAnalysesClient.destroy();
	      this.panelWin = null;
	      this._opening = null;
	      this.isReady = false;
	      this.emit("destroyed");
	    });

	    return this._destroyer;
	  })
	};

	exports.MemoryPanel = MemoryPanel;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { memorySpec } = __webpack_require__(162);
	const { Task } = __webpack_require__(15);
	const protocol = __webpack_require__(17);

	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "FileUtils",
	                         "resource://gre/modules/FileUtils.jsm", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "HeapSnapshotFileUtils",
	                         "devtools/shared/heapsnapshot/HeapSnapshotFileUtils");

	const MemoryFront = protocol.FrontClassWithSpec(memorySpec, {
	  initialize: function (client, form, rootForm = null) {
	    protocol.Front.prototype.initialize.call(this, client, form);
	    this._client = client;
	    this.actorID = form.memoryActor;
	    this.heapSnapshotFileActorID = rootForm
	      ? rootForm.heapSnapshotFileActor
	      : null;
	    this.manage(this);
	  },

	  /**
	   * Save a heap snapshot, transfer it from the server to the client if the
	   * server and client do not share a file system, and return the local file
	   * path to the heap snapshot.
	   *
	   * Note that this is safe to call for actors inside sandoxed child processes,
	   * as we jump through the correct IPDL hoops.
	   *
	   * @params Boolean options.forceCopy
	   *         Always force a bulk data copy of the saved heap snapshot, even when
	   *         the server and client share a file system.
	   *
	   * @params {Object|undefined} options.boundaries
	   *         The boundaries for the heap snapshot. See
	   *         ThreadSafeChromeUtils.webidl for more details.
	   *
	   * @returns Promise<String>
	   */
	  saveHeapSnapshot: protocol.custom(Task.async(function* (options = {}) {
	    const snapshotId = yield this._saveHeapSnapshotImpl(options.boundaries);

	    if (!options.forceCopy &&
	        (yield HeapSnapshotFileUtils.haveHeapSnapshotTempFile(snapshotId))) {
	      return HeapSnapshotFileUtils.getHeapSnapshotTempFilePath(snapshotId);
	    }

	    return yield this.transferHeapSnapshot(snapshotId);
	  }), {
	    impl: "_saveHeapSnapshotImpl"
	  }),

	  /**
	   * Given that we have taken a heap snapshot with the given id, transfer the
	   * heap snapshot file to the client. The path to the client's local file is
	   * returned.
	   *
	   * @param {String} snapshotId
	   *
	   * @returns Promise<String>
	   */
	  transferHeapSnapshot: protocol.custom(function (snapshotId) {
	    if (!this.heapSnapshotFileActorID) {
	      throw new Error("MemoryFront initialized without a rootForm");
	    }

	    const request = this._client.request({
	      to: this.heapSnapshotFileActorID,
	      type: "transferHeapSnapshot",
	      snapshotId
	    });

	    return new Promise((resolve, reject) => {
	      const outFilePath =
	        HeapSnapshotFileUtils.getNewUniqueHeapSnapshotTempFilePath();
	      const outFile = new FileUtils.File(outFilePath);

	      const outFileStream = FileUtils.openSafeFileOutputStream(outFile);
	      request.on("bulk-reply", Task.async(function* ({ copyTo }) {
	        yield copyTo(outFileStream);
	        FileUtils.closeSafeFileOutputStream(outFileStream);
	        resolve(outFilePath);
	      }));
	    });
	  })
	});

	exports.MemoryFront = MemoryFront;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  RetVal,
	  types,
	  generateActorSpec,
	} = __webpack_require__(17);

	types.addDictType("AllocationsRecordingOptions", {
	  // The probability we sample any given allocation when recording
	  // allocations. Must be between 0.0 and 1.0. Defaults to 1.0, or sampling
	  // every allocation.
	  probability: "number",

	  // The maximum number of of allocation events to keep in the allocations
	  // log. If new allocations arrive, when we are already at capacity, the oldest
	  // allocation event is lost. This number must fit in a 32 bit signed integer.
	  maxLogLength: "number"
	});

	const memorySpec = generateActorSpec({
	  typeName: "memory",

	  /**
	   * The set of unsolicited events the MemoryActor emits that will be sent over
	   * the RDP (by protocol.js).
	   */
	  events: {
	    // Same format as the data passed to the
	    // `Debugger.Memory.prototype.onGarbageCollection` hook. See
	    // `js/src/doc/Debugger/Debugger.Memory.md` for documentation.
	    "garbage-collection": {
	      type: "garbage-collection",
	      data: Arg(0, "json"),
	    },

	    // Same data as the data from `getAllocations` -- only fired if
	    // `autoDrain` set during `startRecordingAllocations`.
	    "allocations": {
	      type: "allocations",
	      data: Arg(0, "json"),
	    },
	  },

	  methods: {
	    attach: {
	      request: {},
	      response: {
	        type: "attached"
	      }
	    },
	    detach: {
	      request: {},
	      response: {
	        type: "detached"
	      }
	    },
	    getState: {
	      response: {
	        state: RetVal(0, "string")
	      }
	    },
	    takeCensus: {
	      request: {},
	      response: RetVal("json")
	    },
	    startRecordingAllocations: {
	      request: {
	        options: Arg(0, "nullable:AllocationsRecordingOptions")
	      },
	      response: {
	        // Accept `nullable` in the case of server Gecko <= 37, handled on the front
	        value: RetVal(0, "nullable:number")
	      }
	    },
	    stopRecordingAllocations: {
	      request: {},
	      response: {
	        // Accept `nullable` in the case of server Gecko <= 37, handled on the front
	        value: RetVal(0, "nullable:number")
	      }
	    },
	    getAllocationsSettings: {
	      request: {},
	      response: {
	        options: RetVal(0, "json")
	      }
	    },
	    getAllocations: {
	      request: {},
	      response: RetVal("json")
	    },
	    forceGarbageCollection: {
	      request: {},
	      response: {}
	    },
	    forceCycleCollection: {
	      request: {},
	      response: {}
	    },
	    measure: {
	      request: {},
	      response: RetVal("json"),
	    },
	    residentUnique: {
	      request: {},
	      response: { value: RetVal("number") }
	    },
	    saveHeapSnapshot: {
	      request: {
	        boundaries: Arg(0, "nullable:json")
	      },
	      response: {
	        snapshotId: RetVal("string")
	      }
	    },
	  },
	});

	exports.memorySpec = memorySpec;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const DevToolsUtils = __webpack_require__(8);
	const { DevToolsWorker } = __webpack_require__(164);

	const WORKER_URL =
	  "resource://devtools/shared/heapsnapshot/HeapAnalysesWorker.js";
	var workerCounter = 0;

	/**
	 * A HeapAnalysesClient instance provides a developer-friendly interface for
	 * interacting with a HeapAnalysesWorker. This enables users to be ignorant of
	 * the message passing protocol used to communicate with the worker. The
	 * HeapAnalysesClient owns the worker, and terminating the worker is done by
	 * terminating the client (see the `destroy` method).
	 */
	const HeapAnalysesClient = module.exports = function () {
	  this._worker = new DevToolsWorker(WORKER_URL, {
	    name: `HeapAnalyses-${workerCounter++}`,
	    verbose: DevToolsUtils.dumpv.wantVerbose
	  });
	};

	/**
	 * Destroy the worker, causing it to release its resources (such as heap
	 * snapshots it has deserialized and read into memory). The client is no longer
	 * usable after calling this method.
	 */
	HeapAnalysesClient.prototype.destroy = function () {
	  this._worker.destroy();
	  this._worker = null;
	};

	/**
	 * Tell the worker to read into memory the heap snapshot at the given file
	 * path. This is a prerequisite for asking the worker to perform various
	 * analyses on a heap snapshot.
	 *
	 * @param {String} snapshotFilePath
	 *
	 * @returns Promise
	 *          The promise is fulfilled if the heap snapshot is successfully
	 *          deserialized and read into memory. The promise is rejected if that
	 *          does not happen, eg due to a bad file path or malformed heap
	 *          snapshot file.
	 */
	HeapAnalysesClient.prototype.readHeapSnapshot = function (snapshotFilePath) {
	  return this._worker.performTask("readHeapSnapshot", { snapshotFilePath });
	};

	/**
	 * Tell the worker to delete all references to the snapshot and dominator trees
	 * linked to the provided snapshot file path.
	 *
	 * @param {String} snapshotFilePath
	 * @return Promise<undefined>
	 */
	HeapAnalysesClient.prototype.deleteHeapSnapshot = function (snapshotFilePath) {
	  return this._worker.performTask("deleteHeapSnapshot", { snapshotFilePath });
	};

	/**
	 * Request the creation time given a snapshot file path. Returns `null`
	 * if snapshot does not exist.
	 *
	 * @param {String} snapshotFilePath
	 *        The path to the snapshot.
	 * @return {Number?}
	 *        The unix timestamp of the creation time of the snapshot, or null if
	 *        snapshot does not exist.
	 */
	HeapAnalysesClient.prototype.getCreationTime = function (snapshotFilePath) {
	  return this._worker.performTask("getCreationTime", snapshotFilePath);
	};

	/** * Censuses *****************************************************************/

	/**
	 * Ask the worker to perform a census analysis on the heap snapshot with the
	 * given path. The heap snapshot at the given path must have already been read
	 * into memory by the worker (see `readHeapSnapshot`).
	 *
	 * @param {String} snapshotFilePath
	 *
	 * @param {Object} censusOptions
	 *        A structured-cloneable object specifying the requested census's
	 *        breakdown. See the "takeCensus" section of
	 *        `js/src/doc/Debugger/Debugger.Memory.md` for detailed documentation.
	 *
	 * @param {Object} requestOptions
	 *        An object specifying options of this worker request.
	 *        - {Boolean} asTreeNode
	 *          Whether or not the census is returned as a CensusTreeNode,
	 *          or just a breakdown report. Defaults to false.
	 *          @see `devtools/shared/heapsnapshot/census-tree-node.js`
	 *        - {Boolean} asInvertedTreeNode
	 *          Whether or not the census is returned as an inverted
	 *          CensusTreeNode. Defaults to false.
	 *        - {String} filter
	 *          A filter string to prune the resulting tree with. Only applies if
	 *          either asTreeNode or asInvertedTreeNode is true.
	 *
	 * @returns Promise<Object>
	 *          An object with the following properties:
	 *          - report:
	 *            The report generated by the given census breakdown, or a
	 *            CensusTreeNode generated by the given census breakdown if
	 *            `asTreeNode` is true.
	 *          - parentMap:
	 *            The result of calling CensusUtils.createParentMap on the generated
	 *            report. Only exists if asTreeNode or asInvertedTreeNode are set.
	 */
	HeapAnalysesClient.prototype.takeCensus = function (snapshotFilePath,
	                                                    censusOptions,
	                                                    requestOptions = {}) {
	  return this._worker.performTask("takeCensus", {
	    snapshotFilePath,
	    censusOptions,
	    requestOptions,
	  });
	};

	/**
	 * Get the individual nodes that correspond to the given census report leaf
	 * indices.
	 *
	 * @param {Object} opts
	 *        An object with the following properties:
	 *        - {DominatorTreeId} dominatorTreeId: The id of the dominator tree.
	 *        - {Set<Number>} indices: The indices of the census report leaves we
	 *          would like to get the individuals for.
	 *        - {Object} censusBreakdown: The breakdown used to generate the census.
	 *        - {Object} labelBreakdown: The breakdown we would like to use when
	 *          labeling the resulting nodes.
	 *        - {Number} maxRetainingPaths: The maximum number of retaining paths to
	 *          compute for each node.
	 *        - {Number} maxIndividuals: The maximum number of individual nodes to
	 *          return.
	 *
	 * @returns {Promise<Object>}
	 *          A promise of an object with the following properties:
	 *          - {Array<DominatorTreeNode>} nodes: An array of `DominatorTreeNode`s
	 *            with their shortest paths attached, and without any dominator tree
	 *            child/parent information attached. The results are sorted by
	 *            retained size.
	 *
	 */
	HeapAnalysesClient.prototype.getCensusIndividuals = function (opts) {
	  return this._worker.performTask("getCensusIndividuals", opts);
	};

	/**
	 * Request that the worker take a census on the heap snapshots with the given
	 * paths and then return the difference between them. Both heap snapshots must
	 * have already been read into memory by the worker (see `readHeapSnapshot`).
	 *
	 * @param {String} firstSnapshotFilePath
	 *        The first snapshot file path.
	 *
	 * @param {String} secondSnapshotFilePath
	 *        The second snapshot file path.
	 *
	 * @param {Object} censusOptions
	 *        A structured-cloneable object specifying the requested census's
	 *        breakdown. See the "takeCensus" section of
	 *        `js/src/doc/Debugger/Debugger.Memory.md` for detailed documentation.
	 *
	 * @param {Object} requestOptions
	 *        An object specifying options for this request.
	 *        - {Boolean} asTreeNode
	 *          Whether the resulting delta report should be converted to a census
	 *          tree node before returned. Defaults to false.
	 *        - {Boolean} asInvertedTreeNode
	 *          Whether or not the census is returned as an inverted
	 *          CensusTreeNode. Defaults to false.
	 *        - {String} filter
	 *          A filter string to prune the resulting tree with. Only applies if
	 *          either asTreeNode or asInvertedTreeNode is true.
	 *
	 * @returns Promise<Object>
	 *          - delta:
	 *            The delta report generated by diffing the two census reports, or a
	 *            CensusTreeNode generated from the delta report if
	 *            `requestOptions.asTreeNode` was true.
	 *          - parentMap:
	 *            The result of calling CensusUtils.createParentMap on the generated
	 *            delta. Only exists if asTreeNode or asInvertedTreeNode are set.
	 */
	HeapAnalysesClient.prototype.takeCensusDiff = function (firstSnapshotFilePath,
	                                                        secondSnapshotFilePath,
	                                                        censusOptions,
	                                                        requestOptions = {}) {
	  return this._worker.performTask("takeCensusDiff", {
	    firstSnapshotFilePath,
	    secondSnapshotFilePath,
	    censusOptions,
	    requestOptions
	  });
	};

	/** * Dominator Trees **********************************************************/

	/**
	 * Compute the dominator tree of the heap snapshot loaded from the given file
	 * path. Returns the id of the computed dominator tree.
	 *
	 * @param {String} snapshotFilePath
	 *
	 * @returns {Promise<DominatorTreeId>}
	 */
	HeapAnalysesClient.prototype.computeDominatorTree = function (snapshotFilePath) {
	  return this._worker.performTask("computeDominatorTree", snapshotFilePath);
	};

	/**
	 * Get the initial, partial view of the dominator tree with the given id.
	 *
	 * @param {Object} opts
	 *        An object specifying options for this request.
	 *        - {DominatorTreeId} dominatorTreeId
	 *          The id of the dominator tree.
	 *        - {Object} breakdown
	 *          The breakdown used to generate node labels.
	 *        - {Number} maxDepth
	 *          The maximum depth to traverse down the tree to create this initial
	 *          view.
	 *        - {Number} maxSiblings
	 *          The maximum number of siblings to visit within each traversed node's
	 *          children.
	 *        - {Number} maxRetainingPaths
	 *          The maximum number of retaining paths to find for each node.
	 *
	 * @returns {Promise<DominatorTreeNode>}
	 */
	HeapAnalysesClient.prototype.getDominatorTree = function (opts) {
	  return this._worker.performTask("getDominatorTree", opts);
	};

	/**
	 * Get a subset of a nodes children in the dominator tree.
	 *
	 * @param {Object} opts
	 *        An object specifying options for this request.
	 *        - {DominatorTreeId} dominatorTreeId
	 *          The id of the dominator tree.
	 *        - {NodeId} nodeId
	 *          The id of the node whose children are being found.
	 *        - {Object} breakdown
	 *          The breakdown used to generate node labels.
	 *        - {Number} startIndex
	 *          The starting index within the full set of immediately dominated
	 *          children of the children being requested. Children are always sorted
	 *          by greatest to least retained size.
	 *        - {Number} maxCount
	 *          The maximum number of children to return.
	 *        - {Number} maxRetainingPaths
	 *          The maximum number of retaining paths to find for each node.
	 *
	 * @returns {Promise<Object>}
	 *          A promise of an object with the following properties:
	 *          - {Array<DominatorTreeNode>} nodes
	 *            The requested nodes that are immediately dominated by the node
	 *            identified by `opts.nodeId`.
	 *          - {Boolean} moreChildrenAvailable
	 *            True iff there are more children available after the returned
	 *            nodes.
	 *          - {Array<NodeId>} path
	 *            The path through the tree from the root to these node's parent, eg
	 *            [root's id, child of root's id, child of child of root's id, ..., `nodeId`].
	 */
	HeapAnalysesClient.prototype.getImmediatelyDominated = function (opts) {
	  return this._worker.performTask("getImmediatelyDominated", opts);
	};


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* global ChromeWorker */

	(function (factory) {
	  if (this.module && module.id.indexOf("worker") >= 0) {
	    // require
	    const { Cc, Ci, Cu, ChromeWorker } = __webpack_require__(9);
	    const dumpn = __webpack_require__(8).dumpn;
	    factory.call(this, !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()), exports, module, { Cc, Ci, Cu }, ChromeWorker, dumpn);
	  } else {
	    // Cu.import
	    const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
	    const { require } = Cu.import("resource://devtools/shared/Loader.jsm", {});
	    this.isWorker = false;
	    this.Promise = Cu.import("resource://gre/modules/Promise.jsm", {}).Promise;
	    this.console = Cu.import("resource://gre/modules/Console.jsm", {}).console;
	    factory.call(
	      this, !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()), this, { exports: this },
	      { Cc, Ci, Cu }, ChromeWorker, null
	    );
	    this.EXPORTED_SYMBOLS = ["DevToolsWorker"];
	  }
	}).call(this, function (require, exports, module, { Ci, Cc }, ChromeWorker, dumpn) {
	  let MESSAGE_COUNTER = 0;

	  /**
	   * Creates a wrapper around a ChromeWorker, providing easy
	   * communication to offload demanding tasks. The corresponding URL
	   * must implement the interface provided by `devtools/shared/worker/helper`.
	   *
	   * @see `./devtools/client/shared/widgets/GraphsWorker.js`
	   *
	   * @param {string} url
	   *        The URL of the worker.
	   * @param Object opts
	   *        An option with the following optional fields:
	   *        - name: a name that will be printed with logs
	   *        - verbose: log incoming and outgoing messages
	   */
	  function DevToolsWorker(url, opts) {
	    opts = opts || {};
	    this._worker = new ChromeWorker(url);
	    this._verbose = opts.verbose;
	    this._name = opts.name;

	    this._worker.addEventListener("error", this.onError, false);
	  }
	  exports.DevToolsWorker = DevToolsWorker;

	  /**
	   * Performs the given task in a chrome worker, passing in data.
	   * Returns a promise that resolves when the task is completed, resulting in
	   * the return value of the task.
	   *
	   * @param {string} task
	   *        The name of the task to execute in the worker.
	   * @param {any} data
	   *        Data to be passed into the task implemented by the worker.
	   * @return {Promise}
	   */
	  DevToolsWorker.prototype.performTask = function (task, data) {
	    if (this._destroyed) {
	      return Promise.reject("Cannot call performTask on a destroyed DevToolsWorker");
	    }
	    let worker = this._worker;
	    let id = ++MESSAGE_COUNTER;
	    let payload = { task, id, data };

	    if (this._verbose && dumpn) {
	      dumpn("Sending message to worker" +
	            (this._name ? (" (" + this._name + ")") : "") +
	            ": " +
	            JSON.stringify(payload, null, 2));
	    }
	    worker.postMessage(payload);

	    return new Promise((resolve, reject) => {
	      let listener = ({ data: result }) => {
	        if (this._verbose && dumpn) {
	          dumpn("Received message from worker" +
	                (this._name ? (" (" + this._name + ")") : "") +
	                ": " +
	                JSON.stringify(result, null, 2));
	        }

	        if (result.id !== id) {
	          return;
	        }
	        worker.removeEventListener("message", listener);
	        if (result.error) {
	          reject(result.error);
	        } else {
	          resolve(result.response);
	        }
	      };

	      worker.addEventListener("message", listener);
	    });
	  };

	  /**
	   * Terminates the underlying worker. Use when no longer needing the worker.
	   */
	  DevToolsWorker.prototype.destroy = function () {
	    this._worker.terminate();
	    this._worker = null;
	    this._destroyed = true;
	  };

	  DevToolsWorker.prototype.onError = function ({ message, filename, lineno }) {
	    (console.log)(new Error(message + " @ " + filename + ":" + lineno) + "\n");
	  };

	  /**
	   * Takes a function and returns a Worker-wrapped version of the same function.
	   * Returns a promise upon resolution.
	   * @see `./devtools/shared/shared/tests/browser/browser_devtools-worker-03.js
	   *
	   * ⚠ This should only be used for tests or A/B testing performance ⚠
	   *
	   * The original function must:
	   *
	   * Be a pure function, that is, not use any variables not declared within the
	   * function, or its arguments.
	   *
	   * Return a value or a promise.
	   *
	   * Note any state change in the worker will not affect the callee's context.
	   *
	   * @param {function} fn
	   * @return {function}
	   */
	  function workerify(fn) {
	    console.warn("`workerify` should only be used in tests or measuring performance. " +
	                 "This creates an object URL on the browser window, and should not be " +
	                 "used in production.");
	    // Fetch via window/utils here as we don't want to include
	    // this module normally.
	    let { getMostRecentBrowserWindow } = require("sdk/window/utils");
	    let { URL, Blob } = getMostRecentBrowserWindow();
	    let stringifiedFn = createWorkerString(fn);
	    let blob = new Blob([stringifiedFn]);
	    let url = URL.createObjectURL(blob);
	    let worker = new DevToolsWorker(url);

	    let wrapperFn = data => worker.performTask("workerifiedTask", data);

	    wrapperFn.destroy = function () {
	      URL.revokeObjectURL(url);
	      worker.destroy();
	    };

	    return wrapperFn;
	  }
	  exports.workerify = workerify;

	  /**
	   * Takes a function, and stringifies it, attaching the worker-helper.js
	   * boilerplate hooks.
	   */
	  function createWorkerString(fn) {
	    return `importScripts("resource://gre/modules/workers/require.js");
	            const { createTask } = require("resource://devtools/shared/worker/helper.js");
	            createTask(self, "workerifiedTask", ${fn.toString()});`;
	  }
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 165 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 165;


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Task } = __webpack_require__(15);

	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "promise");
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "EventEmitter",
	  "devtools/shared/event-emitter");

	function PerformancePanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this.toolbox = toolbox;

	  EventEmitter.decorate(this);
	}

	exports.PerformancePanel = PerformancePanel;

	PerformancePanel.prototype = {
	  /**
	   * Open is effectively an asynchronous constructor.
	   *
	   * @return object
	   *         A promise that is resolved when the Performance tool
	   *         completes opening.
	   */
	  open: Task.async(function* () {
	    if (this._opening) {
	      return this._opening;
	    }
	    let deferred = promise.defer();
	    this._opening = deferred.promise;

	    this.panelWin.gToolbox = this.toolbox;
	    this.panelWin.gTarget = this.target;
	    this._checkRecordingStatus = this._checkRecordingStatus.bind(this);

	    // Actor is already created in the toolbox; reuse
	    // the same front, and the toolbox will also initialize the front,
	    // but redo it here so we can hook into the same event to prevent race conditions
	    // in the case of the front still being in the process of opening.
	    let front = yield this.panelWin.gToolbox.initPerformance();

	    // This should only happen if this is completely unsupported (when profiler
	    // does not exist), and in that case, the tool shouldn't be available,
	    // so let's ensure this assertion.
	    if (!front) {
	      console.error("No PerformanceFront found in toolbox.");
	    }

	    this.panelWin.gFront = front;
	    let { PerformanceController, EVENTS } = this.panelWin;
	    PerformanceController.on(EVENTS.RECORDING_ADDED, this._checkRecordingStatus);
	    PerformanceController.on(EVENTS.RECORDING_STATE_CHANGE, this._checkRecordingStatus);
	    yield this.panelWin.startupPerformance();

	    // Fire this once incase we have an in-progress recording (console profile)
	    // that caused this start up, and no state change yet, so we can highlight the
	    // tab if we need.
	    this._checkRecordingStatus();

	    this.isReady = true;
	    this.emit("ready");

	    deferred.resolve(this);
	    return this._opening;
	  }),

	  // DevToolPanel API

	  get target() {
	    return this.toolbox.target;
	  },

	  destroy: Task.async(function* () {
	    // Make sure this panel is not already destroyed.
	    if (this._destroyed) {
	      return;
	    }

	    let { PerformanceController, EVENTS } = this.panelWin;
	    PerformanceController.off(EVENTS.RECORDING_ADDED, this._checkRecordingStatus);
	    PerformanceController.off(EVENTS.RECORDING_STATE_CHANGE, this._checkRecordingStatus);
	    yield this.panelWin.shutdownPerformance();
	    this.emit("destroyed");
	    this._destroyed = true;
	  }),

	  _checkRecordingStatus: function () {
	    if (this.panelWin.PerformanceController.isRecording()) {
	      this.toolbox.highlightTool("performance");
	    } else {
	      this.toolbox.unhighlightTool("performance");
	    }
	  }
	};


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const promise = __webpack_require__(4);
	const EventEmitter = __webpack_require__(6);
	const { Task } = __webpack_require__(15);

	function NetMonitorPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this._toolbox = toolbox;

	  this._view = this.panelWin.NetMonitorView;
	  this._controller = this.panelWin.NetMonitorController;
	  this._controller._target = this.target;
	  this._controller._toolbox = this._toolbox;

	  EventEmitter.decorate(this);
	}

	exports.NetMonitorPanel = NetMonitorPanel;

	NetMonitorPanel.prototype = {
	  /**
	   * Open is effectively an asynchronous constructor.
	   *
	   * @return object
	   *         A promise that is resolved when the NetMonitor completes opening.
	   */
	  open: Task.async(function* () {
	    if (this._opening) {
	      return this._opening;
	    }
	    let deferred = promise.defer();
	    this._opening = deferred.promise;

	    // Local monitoring needs to make the target remote.
	    if (!this.target.isRemote) {
	      yield this.target.makeRemote();
	    }

	    yield this._controller.startupNetMonitor();
	    this.isReady = true;
	    this.emit("ready");

	    deferred.resolve(this);
	    return this._opening;
	  }),

	  // DevToolPanel API

	  get target() {
	    return this._toolbox.target;
	  },

	  destroy: Task.async(function* () {
	    if (this._destroying) {
	      return this._destroying;
	    }
	    let deferred = promise.defer();
	    this._destroying = deferred.promise;

	    yield this._controller.shutdownNetMonitor();
	    this.emit("destroyed");

	    deferred.resolve();
	    return this._destroying;
	  })
	};


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const EventEmitter = __webpack_require__(6);

	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "StorageFront",
	                         "devtools/shared/fronts/storage", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "StorageUI",
	                         "devtools/client/storage/ui", true);

	var StoragePanel = this.StoragePanel =
	function StoragePanel(panelWin, toolbox) {
	  EventEmitter.decorate(this);

	  this._toolbox = toolbox;
	  this._target = toolbox.target;
	  this._panelWin = panelWin;

	  this.destroy = this.destroy.bind(this);
	};

	exports.StoragePanel = StoragePanel;

	StoragePanel.prototype = {
	  get target() {
	    return this._toolbox.target;
	  },

	  get panelWindow() {
	    return this._panelWin;
	  },

	  /**
	   * open is effectively an asynchronous constructor
	   */
	  open: function () {
	    let targetPromise;
	    // We always interact with the target as if it were remote
	    if (!this.target.isRemote) {
	      targetPromise = this.target.makeRemote();
	    } else {
	      targetPromise = Promise.resolve(this.target);
	    }

	    return targetPromise.then(() => {
	      this.target.on("close", this.destroy);
	      this._front = new StorageFront(this.target.client, this.target.form);

	      this.UI = new StorageUI(this._front, this._target,
	                              this._panelWin, this._toolbox);
	      this.isReady = true;
	      this.emit("ready");

	      return this;
	    }).catch(e => {
	      console.log("error while opening storage panel", e);
	      this.destroy();
	    });
	  },

	  /**
	   * Destroy the storage inspector.
	   */
	  destroy: function () {
	    if (!this._destroyed) {
	      this.UI.destroy();
	      this.UI = null;

	      // Destroy front to ensure packet handler is removed from client
	      this._front.destroy();
	      this._front = null;
	      this._destroyed = true;

	      this._target.off("close", this.destroy);
	      this._target = null;
	      this._toolbox = null;
	      this._panelWin = null;
	    }

	    return Promise.resolve(null);
	  },
	};


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {Cu} = __webpack_require__(9);
	const EventEmitter = __webpack_require__(6);
	const promise = __webpack_require__(4);


	function ScratchpadPanel(iframeWindow, toolbox) {
	  let { Scratchpad } = iframeWindow;
	  this._toolbox = toolbox;
	  this.panelWin = iframeWindow;
	  this.scratchpad = Scratchpad;

	  Scratchpad.target = this.target;
	  Scratchpad.hideMenu();

	  let deferred = promise.defer();
	  this._readyObserver = deferred.promise;
	  Scratchpad.addObserver({
	    onReady: function () {
	      Scratchpad.removeObserver(this);
	      deferred.resolve();
	    }
	  });

	  EventEmitter.decorate(this);
	}
	exports.ScratchpadPanel = ScratchpadPanel;

	ScratchpadPanel.prototype = {
	  /**
	   * Open is effectively an asynchronous constructor. For the ScratchpadPanel,
	   * by the time this is called, the Scratchpad will already be ready.
	   */
	  open: function () {
	    return this._readyObserver.then(() => {
	      this.isReady = true;
	      this.emit("ready");
	      return this;
	    });
	  },

	  get target() {
	    return this._toolbox.target;
	  },

	  destroy: function () {
	    this.emit("destroyed");
	    return promise.resolve();
	  }
	};


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const { Cu } = __webpack_require__(9);
	const defer = __webpack_require__(5);
	const { ObjectClient } = __webpack_require__(171);

	const promise = __webpack_require__(4);
	const EventEmitter = __webpack_require__(6);
	const { Task } = __webpack_require__(15);

	/**
	 * This object represents DOM panel. It's responsibility is to
	 * render Document Object Model of the current debugger target.
	 */
	function DomPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this._toolbox = toolbox;

	  this.onTabNavigated = this.onTabNavigated.bind(this);
	  this.onContentMessage = this.onContentMessage.bind(this);
	  this.onPanelVisibilityChange = this.onPanelVisibilityChange.bind(this);

	  this.pendingRequests = new Map();

	  EventEmitter.decorate(this);
	}

	DomPanel.prototype = {
	  /**
	   * Open is effectively an asynchronous constructor.
	   *
	   * @return object
	   *         A promise that is resolved when the DOM panel completes opening.
	   */
	  open: Task.async(function* () {
	    if (this._opening) {
	      return this._opening;
	    }

	    let deferred = promise.defer();
	    this._opening = deferred.promise;

	    // Local monitoring needs to make the target remote.
	    if (!this.target.isRemote) {
	      yield this.target.makeRemote();
	    }

	    this.initialize();

	    this.isReady = true;
	    this.emit("ready");
	    deferred.resolve(this);

	    return this._opening;
	  }),

	  // Initialization

	  initialize: function () {
	    this.panelWin.addEventListener("devtools/content/message",
	      this.onContentMessage, true);

	    this.target.on("navigate", this.onTabNavigated);
	    this._toolbox.on("select", this.onPanelVisibilityChange);

	    let provider = {
	      getPrototypeAndProperties: this.getPrototypeAndProperties.bind(this)
	    };

	    exportIntoContentScope(this.panelWin, provider, "DomProvider");

	    this.shouldRefresh = true;
	  },

	  destroy: Task.async(function* () {
	    if (this._destroying) {
	      return this._destroying;
	    }

	    let deferred = promise.defer();
	    this._destroying = deferred.promise;

	    this.target.off("navigate", this.onTabNavigated);
	    this._toolbox.off("select", this.onPanelVisibilityChange);

	    this.emit("destroyed");

	    deferred.resolve();
	    return this._destroying;
	  }),

	  // Events

	  refresh: function () {
	    // Do not refresh if the panel isn't visible.
	    if (!this.isPanelVisible()) {
	      return;
	    }

	    // Do not refresh if it isn't necessary.
	    if (!this.shouldRefresh) {
	      return;
	    }

	    // Alright reset the flag we are about to refresh the panel.
	    this.shouldRefresh = false;

	    this.getRootGrip().then(rootGrip => {
	      this.postContentMessage("initialize", rootGrip);
	    });
	  },

	  /**
	   * Make sure the panel is refreshed when the page is reloaded.
	   * The panel is refreshed immediatelly if it's currently selected
	   * or lazily  when the user actually selects it.
	   */
	  onTabNavigated: function () {
	    this.shouldRefresh = true;
	    this.refresh();
	  },

	  /**
	   * Make sure the panel is refreshed (if needed) when it's selected.
	   */
	  onPanelVisibilityChange: function () {
	    this.refresh();
	  },

	  // Helpers

	  /**
	   * Return true if the DOM panel is currently selected.
	   */
	  isPanelVisible: function () {
	    return this._toolbox.currentToolId === "dom";
	  },

	  getPrototypeAndProperties: function (grip) {
	    let deferred = defer();

	    if (!grip.actor) {
	      console.error("No actor!", grip);
	      deferred.reject(new Error("Failed to get actor from grip."));
	      return deferred.promise;
	    }

	    // Bail out if target doesn't exist (toolbox maybe closed already).
	    if (!this.target) {
	      return deferred.promise;
	    }

	    // If a request for the grips is already in progress
	    // use the same promise.
	    let request = this.pendingRequests.get(grip.actor);
	    if (request) {
	      return request;
	    }

	    let client = new ObjectClient(this.target.client, grip);
	    client.getPrototypeAndProperties(response => {
	      this.pendingRequests.delete(grip.actor, deferred.promise);
	      deferred.resolve(response);

	      // Fire an event about not having any pending requests.
	      if (!this.pendingRequests.size) {
	        this.emit("no-pending-requests");
	      }
	    });

	    this.pendingRequests.set(grip.actor, deferred.promise);

	    return deferred.promise;
	  },

	  getRootGrip: function () {
	    let deferred = defer();

	    // Attach Console. It might involve RDP communication, so wait
	    // asynchronously for the result
	    this.target.activeConsole.evaluateJSAsync("window", res => {
	      deferred.resolve(res.result);
	    });

	    return deferred.promise;
	  },

	  postContentMessage: function (type, args) {
	    let data = {
	      type: type,
	      args: args,
	    };

	    let event = new this.panelWin.MessageEvent("devtools/chrome/message", {
	      bubbles: true,
	      cancelable: true,
	      data: data,
	    });

	    this.panelWin.dispatchEvent(event);
	  },

	  onContentMessage: function (event) {
	    let data = event.data;
	    let method = data.type;
	    if (typeof this[method] == "function") {
	      this[method](data.args);
	    }
	  },

	  get target() {
	    return this._toolbox.target;
	  },
	};

	// Helpers

	function exportIntoContentScope(win, obj, defineAs) {
	  let clone = Cu.createObjectIn(win, {
	    defineAs: defineAs
	  });

	  let props = Object.getOwnPropertyNames(obj);
	  for (let i = 0; i < props.length; i++) {
	    let propName = props[i];
	    let propValue = obj[propName];
	    if (typeof propValue == "function") {
	      Cu.exportFunction(propValue, clone, {
	        defineAs: propName
	      });
	    }
	  }
	}

	// Exports from this module
	exports.DomPanel = DomPanel;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const { Ci, Cu } = __webpack_require__(9);
	const Services = __webpack_require__(1);
	const DevToolsUtils = __webpack_require__(8);
	const { getStack, callFunctionWithAsyncStack } = __webpack_require__(7);

	const promise = Cu.import("resource://devtools/shared/deprecated-sync-thenables.js", {}).Promise;

	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "events", "sdk/event/core");
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "WebConsoleClient", "devtools/shared/webconsole/client", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "DebuggerSocket", "devtools/shared/security/socket", true);
	({ lazyRequireGetter: () => {} }).lazyRequireGetter(this, "Authentication", "devtools/shared/security/auth");

	const noop = () => {};

	/**
	 * TODO: Get rid of this API in favor of EventTarget (bug 1042642)
	 *
	 * Add simple event notification to a prototype object. Any object that has
	 * some use for event notifications or the observer pattern in general can be
	 * augmented with the necessary facilities by passing its prototype to this
	 * function.
	 *
	 * @param aProto object
	 *        The prototype object that will be modified.
	 */
	function eventSource(aProto) {
	  /**
	   * Add a listener to the event source for a given event.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired. If the same listener
	   *        is added more than once, it will be called once per
	   *        addListener call.
	   */
	  aProto.addListener = function (aName, aListener) {
	    if (typeof aListener != "function") {
	      throw TypeError("Listeners must be functions.");
	    }

	    if (!this._listeners) {
	      this._listeners = {};
	    }

	    this._getListeners(aName).push(aListener);
	  };

	  /**
	   * Add a listener to the event source for a given event. The
	   * listener will be removed after it is called for the first time.
	   *
	   * @param aName string
	   *        The event to listen for.
	   * @param aListener function
	   *        Called when the event is fired.
	   */
	  aProto.addOneTimeListener = function (aName, aListener) {
	    let l = (...args) => {
	      this.removeListener(aName, l);
	      aListener.apply(null, args);
	    };
	    this.addListener(aName, l);
	  };

	  /**
	   * Remove a listener from the event source previously added with
	   * addListener().
	   *
	   * @param aName string
	   *        The event name used during addListener to add the listener.
	   * @param aListener function
	   *        The callback to remove. If addListener was called multiple
	   *        times, all instances will be removed.
	   */
	  aProto.removeListener = function (aName, aListener) {
	    if (!this._listeners || (aListener && !this._listeners[aName])) {
	      return;
	    }

	    if (!aListener) {
	      this._listeners[aName] = [];
	    }
	    else {
	      this._listeners[aName] =
	        this._listeners[aName].filter(function (l) { return l != aListener; });
	    }
	  };

	  /**
	   * Returns the listeners for the specified event name. If none are defined it
	   * initializes an empty list and returns that.
	   *
	   * @param aName string
	   *        The event name.
	   */
	  aProto._getListeners = function (aName) {
	    if (aName in this._listeners) {
	      return this._listeners[aName];
	    }
	    this._listeners[aName] = [];
	    return this._listeners[aName];
	  };

	  /**
	   * Notify listeners of an event.
	   *
	   * @param aName string
	   *        The event to fire.
	   * @param arguments
	   *        All arguments will be passed along to the listeners,
	   *        including the name argument.
	   */
	  aProto.emit = function () {
	    if (!this._listeners) {
	      return;
	    }

	    let name = arguments[0];
	    let listeners = this._getListeners(name).slice(0);

	    for (let listener of listeners) {
	      try {
	        listener.apply(null, arguments);
	      } catch (e) {
	        // Prevent a bad listener from interfering with the others.
	        DevToolsUtils.reportException("notify event '" + name + "'", e);
	      }
	    }
	  };
	}

	/**
	 * Set of protocol messages that affect thread state, and the
	 * state the actor is in after each message.
	 */
	const ThreadStateTypes = {
	  "paused": "paused",
	  "resumed": "attached",
	  "detached": "detached"
	};

	/**
	 * Set of protocol messages that are sent by the server without a prior request
	 * by the client.
	 */
	const UnsolicitedNotifications = {
	  "consoleAPICall": "consoleAPICall",
	  "eventNotification": "eventNotification",
	  "fileActivity": "fileActivity",
	  "lastPrivateContextExited": "lastPrivateContextExited",
	  "logMessage": "logMessage",
	  "networkEvent": "networkEvent",
	  "networkEventUpdate": "networkEventUpdate",
	  "newGlobal": "newGlobal",
	  "newScript": "newScript",
	  "tabDetached": "tabDetached",
	  "tabListChanged": "tabListChanged",
	  "reflowActivity": "reflowActivity",
	  "addonListChanged": "addonListChanged",
	  "workerListChanged": "workerListChanged",
	  "serviceWorkerRegistrationListChanged": "serviceWorkerRegistrationList",
	  "tabNavigated": "tabNavigated",
	  "frameUpdate": "frameUpdate",
	  "pageError": "pageError",
	  "documentLoad": "documentLoad",
	  "enteredFrame": "enteredFrame",
	  "exitedFrame": "exitedFrame",
	  "appOpen": "appOpen",
	  "appClose": "appClose",
	  "appInstall": "appInstall",
	  "appUninstall": "appUninstall",
	  "evaluationResult": "evaluationResult",
	  "newSource": "newSource",
	  "updatedSource": "updatedSource",
	};

	/**
	 * Set of pause types that are sent by the server and not as an immediate
	 * response to a client request.
	 */
	const UnsolicitedPauses = {
	  "resumeLimit": "resumeLimit",
	  "debuggerStatement": "debuggerStatement",
	  "breakpoint": "breakpoint",
	  "DOMEvent": "DOMEvent",
	  "watchpoint": "watchpoint",
	  "exception": "exception"
	};

	/**
	 * Creates a client for the remote debugging protocol server. This client
	 * provides the means to communicate with the server and exchange the messages
	 * required by the protocol in a traditional JavaScript API.
	 */
	const DebuggerClient = exports.DebuggerClient = function (aTransport)
	{
	  this._transport = aTransport;
	  this._transport.hooks = this;

	  // Map actor ID to client instance for each actor type.
	  this._clients = new Map();

	  this._pendingRequests = new Map();
	  this._activeRequests = new Map();
	  this._eventsEnabled = true;

	  this.traits = {};

	  this.request = this.request.bind(this);
	  this.localTransport = this._transport.onOutputStreamReady === undefined;

	  /*
	   * As the first thing on the connection, expect a greeting packet from
	   * the connection's root actor.
	   */
	  this.mainRoot = null;
	  this.expectReply("root", (aPacket) => {
	    this.mainRoot = new RootClient(this, aPacket);
	    this.emit("connected", aPacket.applicationType, aPacket.traits);
	  });
	};

	/**
	 * A declarative helper for defining methods that send requests to the server.
	 *
	 * @param aPacketSkeleton
	 *        The form of the packet to send. Can specify fields to be filled from
	 *        the parameters by using the |args| function.
	 * @param before
	 *        The function to call before sending the packet. Is passed the packet,
	 *        and the return value is used as the new packet. The |this| context is
	 *        the instance of the client object we are defining a method for.
	 * @param after
	 *        The function to call after the response is received. It is passed the
	 *        response, and the return value is considered the new response that
	 *        will be passed to the callback. The |this| context is the instance of
	 *        the client object we are defining a method for.
	 * @return Request
	 *         The `Request` object that is a Promise object and resolves once
	 *         we receive the response. (See request method for more details)
	 */
	DebuggerClient.requester = function (aPacketSkeleton, config = {}) {
	  let { before, after } = config;
	  return DevToolsUtils.makeInfallible(function (...args) {
	    let outgoingPacket = {
	      to: aPacketSkeleton.to || this.actor
	    };

	    let maxPosition = -1;
	    for (let k of Object.keys(aPacketSkeleton)) {
	      if (aPacketSkeleton[k] instanceof DebuggerClient.Argument) {
	        let { position } = aPacketSkeleton[k];
	        outgoingPacket[k] = aPacketSkeleton[k].getArgument(args);
	        maxPosition = Math.max(position, maxPosition);
	      } else {
	        outgoingPacket[k] = aPacketSkeleton[k];
	      }
	    }

	    if (before) {
	      outgoingPacket = before.call(this, outgoingPacket);
	    }

	    return this.request(outgoingPacket, DevToolsUtils.makeInfallible((aResponse) => {
	      if (after) {
	        let { from } = aResponse;
	        aResponse = after.call(this, aResponse);
	        if (!aResponse.from) {
	          aResponse.from = from;
	        }
	      }

	      // The callback is always the last parameter.
	      let thisCallback = args[maxPosition + 1];
	      if (thisCallback) {
	        thisCallback(aResponse);
	      }
	    }, "DebuggerClient.requester request callback"));
	  }, "DebuggerClient.requester");
	};

	function args(aPos) {
	  return new DebuggerClient.Argument(aPos);
	}

	DebuggerClient.Argument = function (aPosition) {
	  this.position = aPosition;
	};

	DebuggerClient.Argument.prototype.getArgument = function (aParams) {
	  if (!(this.position in aParams)) {
	    throw new Error("Bad index into params: " + this.position);
	  }
	  return aParams[this.position];
	};

	// Expose these to save callers the trouble of importing DebuggerSocket
	DebuggerClient.socketConnect = function (options) {
	  // Defined here instead of just copying the function to allow lazy-load
	  return DebuggerSocket.connect(options);
	};
	DevToolsUtils.defineLazyGetter(DebuggerClient, "Authenticators", () => {
	  return Authentication.Authenticators;
	});
	DevToolsUtils.defineLazyGetter(DebuggerClient, "AuthenticationResult", () => {
	  return Authentication.AuthenticationResult;
	});

	DebuggerClient.prototype = {
	  /**
	   * Connect to the server and start exchanging protocol messages.
	   *
	   * @param aOnConnected function
	   *        If specified, will be called when the greeting packet is
	   *        received from the debugging server.
	   *
	   * @return Promise
	   *         Resolves once connected with an array whose first element
	   *         is the application type, by default "browser", and the second
	   *         element is the traits object (help figure out the features
	   *         and behaviors of the server we connect to. See RootActor).
	   */
	  connect: function (aOnConnected) {
	    let deferred = promise.defer();
	    this.emit("connect");

	    // Also emit the event on the |DebuggerClient| object (not on the instance),
	    // so it's possible to track all instances.
	    events.emit(DebuggerClient, "connect", this);

	    this.addOneTimeListener("connected", (aName, aApplicationType, aTraits) => {
	      this.traits = aTraits;
	      if (aOnConnected) {
	        aOnConnected(aApplicationType, aTraits);
	      }
	      deferred.resolve([aApplicationType, aTraits]);
	    });

	    this._transport.ready();
	    return deferred.promise;
	  },

	  /**
	   * Shut down communication with the debugging server.
	   *
	   * @param aOnClosed function
	   *        If specified, will be called when the debugging connection
	   *        has been closed.
	   */
	  close: function (aOnClosed) {
	    // Disable detach event notifications, because event handlers will be in a
	    // cleared scope by the time they run.
	    this._eventsEnabled = false;

	    let cleanup = () => {
	      this._transport.close();
	      this._transport = null;
	    };

	    // If the connection is already closed,
	    // there is no need to detach client
	    // as we won't be able to send any message.
	    if (this._closed) {
	      cleanup();
	      if (aOnClosed) {
	        aOnClosed();
	      }
	      return;
	    }

	    if (aOnClosed) {
	      this.addOneTimeListener("closed", function (aEvent) {
	        aOnClosed();
	      });
	    }

	    // Call each client's `detach` method by calling
	    // lastly registered ones first to give a chance
	    // to detach child clients first.
	    let clients = [...this._clients.values()];
	    this._clients.clear();
	    const detachClients = () => {
	      let client = clients.pop();
	      if (!client) {
	        // All clients detached.
	        cleanup();
	        return;
	      }
	      if (client.detach) {
	        client.detach(detachClients);
	        return;
	      }
	      detachClients();
	    };
	    detachClients();
	  },

	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listTabs()'.
	   */
	  listTabs: function (aOnResponse) { return this.mainRoot.listTabs(aOnResponse); },

	  /*
	   * This function exists only to preserve DebuggerClient's interface;
	   * new code should say 'client.mainRoot.listAddons()'.
	   */
	  listAddons: function (aOnResponse) { return this.mainRoot.listAddons(aOnResponse); },

	  getTab: function (aFilter) { return this.mainRoot.getTab(aFilter); },

	  /**
	   * Attach to a tab actor.
	   *
	   * @param string aTabActor
	   *        The actor ID for the tab to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TabClient
	   *        (which will be undefined on error).
	   */
	  attachTab: function (aTabActor, aOnResponse = noop) {
	    if (this._clients.has(aTabActor)) {
	      let cachedTab = this._clients.get(aTabActor);
	      let cachedResponse = {
	        cacheDisabled: cachedTab.cacheDisabled,
	        javascriptEnabled: cachedTab.javascriptEnabled,
	        traits: cachedTab.traits,
	      };
	      DevToolsUtils.executeSoon(() => aOnResponse(cachedResponse, cachedTab));
	      return promise.resolve([cachedResponse, cachedTab]);
	    }

	    let packet = {
	      to: aTabActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      let tabClient;
	      if (!aResponse.error) {
	        tabClient = new TabClient(this, aResponse);
	        this.registerClient(tabClient);
	      }
	      aOnResponse(aResponse, tabClient);
	      return [aResponse, tabClient];
	    });
	  },

	  attachWorker: function DC_attachWorker(aWorkerActor, aOnResponse = noop) {
	    let workerClient = this._clients.get(aWorkerActor);
	    if (workerClient !== undefined) {
	      let response = {
	        from: workerClient.actor,
	        type: "attached",
	        url: workerClient.url
	      };
	      DevToolsUtils.executeSoon(() => aOnResponse(response, workerClient));
	      return promise.resolve([response, workerClient]);
	    }

	    return this.request({ to: aWorkerActor, type: "attach" }).then(aResponse => {
	      if (aResponse.error) {
	        aOnResponse(aResponse, null);
	        return [aResponse, null];
	      }

	      let workerClient = new WorkerClient(this, aResponse);
	      this.registerClient(workerClient);
	      aOnResponse(aResponse, workerClient);
	      return [aResponse, workerClient];
	    });
	  },

	  /**
	   * Attach to an addon actor.
	   *
	   * @param string aAddonActor
	   *        The actor ID for the addon to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a AddonClient
	   *        (which will be undefined on error).
	   */
	  attachAddon: function DC_attachAddon(aAddonActor, aOnResponse = noop) {
	    let packet = {
	      to: aAddonActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      let addonClient;
	      if (!aResponse.error) {
	        addonClient = new AddonClient(this, aAddonActor);
	        this.registerClient(addonClient);
	        this.activeAddon = addonClient;
	      }
	      aOnResponse(aResponse, addonClient);
	      return [aResponse, addonClient];
	    });
	  },

	  /**
	   * Attach to a Web Console actor.
	   *
	   * @param string aConsoleActor
	   *        The ID for the console actor to attach to.
	   * @param array aListeners
	   *        The console listeners you want to start.
	   * @param function aOnResponse
	   *        Called with the response packet and a WebConsoleClient
	   *        instance (which will be undefined on error).
	   */
	  attachConsole:
	  function (aConsoleActor, aListeners, aOnResponse = noop) {
	    let packet = {
	      to: aConsoleActor,
	      type: "startListeners",
	      listeners: aListeners,
	    };

	    return this.request(packet).then(aResponse => {
	      let consoleClient;
	      if (!aResponse.error) {
	        if (this._clients.has(aConsoleActor)) {
	          consoleClient = this._clients.get(aConsoleActor);
	        } else {
	          consoleClient = new WebConsoleClient(this, aResponse);
	          this.registerClient(consoleClient);
	        }
	      }
	      aOnResponse(aResponse, consoleClient);
	      return [aResponse, consoleClient];
	    });
	  },

	  /**
	   * Attach to a global-scoped thread actor for chrome debugging.
	   *
	   * @param string aThreadActor
	   *        The actor ID for the thread to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   */
	  attachThread: function (aThreadActor, aOnResponse = noop, aOptions = {}) {
	    if (this._clients.has(aThreadActor)) {
	      let client = this._clients.get(aThreadActor);
	      DevToolsUtils.executeSoon(() => aOnResponse({}, client));
	      return promise.resolve([{}, client]);
	    }

	    let packet = {
	      to: aThreadActor,
	      type: "attach",
	      options: aOptions
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        var threadClient = new ThreadClient(this, aThreadActor);
	        this.registerClient(threadClient);
	      }
	      aOnResponse(aResponse, threadClient);
	      return [aResponse, threadClient];
	    });
	  },

	  /**
	   * Attach to a trace actor.
	   *
	   * @param string aTraceActor
	   *        The actor ID for the tracer to attach.
	   * @param function aOnResponse
	   *        Called with the response packet and a TraceClient
	   *        (which will be undefined on error).
	   */
	  attachTracer: function (aTraceActor, aOnResponse = noop) {
	    if (this._clients.has(aTraceActor)) {
	      let client = this._clients.get(aTraceActor);
	      DevToolsUtils.executeSoon(() => aOnResponse({}, client));
	      return promise.resolve([{}, client]);
	    }

	    let packet = {
	      to: aTraceActor,
	      type: "attach"
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        var traceClient = new TraceClient(this, aTraceActor);
	        this.registerClient(traceClient);
	      }
	      aOnResponse(aResponse, traceClient);
	      return [aResponse, traceClient];
	    });
	  },

	  /**
	   * Fetch the ChromeActor for the main process or ChildProcessActor for a
	   * a given child process ID.
	   *
	   * @param number aId
	   *        The ID for the process to attach (returned by `listProcesses`).
	   *        Connected to the main process if omitted, or is 0.
	   */
	  getProcess: function (aId) {
	    let packet = {
	      to: "root",
	      type: "getProcess"
	    };
	    if (typeof (aId) == "number") {
	      packet.id = aId;
	    }
	    return this.request(packet);
	  },

	  /**
	   * Release an object actor.
	   *
	   * @param string aActor
	   *        The actor ID to send the request to.
	   * @param aOnResponse function
	   *        If specified, will be called with the response packet when
	   *        debugging server responds.
	   */
	  release: DebuggerClient.requester({
	    to: args(0),
	    type: "release"
	  }),

	  /**
	   * Send a request to the debugging server.
	   *
	   * @param aRequest object
	   *        A JSON packet to send to the debugging server.
	   * @param aOnResponse function
	   *        If specified, will be called with the JSON response packet when
	   *        debugging server responds.
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *         It is also a Promise object, with a `then` method, that is resolved
	   *         whenever a JSON or a Bulk response is received; and is rejected
	   *         if the response is an error.
	   *         Note: This return value can be ignored if you are using JSON alone,
	   *         because the callback provided in |aOnResponse| will be bound to the
	   *         "json-reply" event automatically.
	   *
	   *         Events emitted:
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  request: function (aRequest, aOnResponse) {
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    let type = aRequest.type || "";
	    if (!aRequest.to) {
	      throw Error("'" + type + "' request packet has no destination.");
	    }
	    if (this._closed) {
	      let msg = "'" + type + "' request packet to " +
	                "'" + aRequest.to + "' " +
	               "can't be sent as the connection is closed.";
	      let resp = { error: "connectionClosed", message: msg };
	      if (aOnResponse) {
	        aOnResponse(resp);
	      }
	      return promise.reject(resp);
	    }

	    let request = new Request(aRequest);
	    request.format = "json";
	    request.stack = getStack();
	    if (aOnResponse) {
	      request.on("json-reply", aOnResponse);
	    }

	    this._sendOrQueueRequest(request);

	    // Implement a Promise like API on the returned object
	    // that resolves/rejects on request response
	    let deferred = promise.defer();
	    function listenerJson(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      if (resp.error) {
	        deferred.reject(resp);
	      } else {
	        deferred.resolve(resp);
	      }
	    }
	    function listenerBulk(resp) {
	      request.off("json-reply", listenerJson);
	      request.off("bulk-reply", listenerBulk);
	      deferred.resolve(resp);
	    }
	    request.on("json-reply", listenerJson);
	    request.on("bulk-reply", listenerBulk);
	    request.then = deferred.promise.then.bind(deferred.promise);

	    return request;
	  },

	  /**
	   * Transmit streaming data via a bulk request.
	   *
	   * This method initiates the bulk send process by queuing up the header data.
	   * The caller receives eventual access to a stream for writing.
	   *
	   * Since this opens up more options for how the server might respond (it could
	   * send back either JSON or bulk data), and the returned Request object emits
	   * events for different stages of the request process that you may want to
	   * react to.
	   *
	   * @param request Object
	   *        This is modeled after the format of JSON packets above, but does not
	   *        actually contain the data, but is instead just a routing header:
	   *          * actor:  Name of actor that will receive the packet
	   *          * type:   Name of actor's method that should be called on receipt
	   *          * length: Size of the data to be sent
	   * @return Request
	   *         This object emits a number of events to allow you to respond to
	   *         different parts of the request lifecycle.
	   *
	   *         Events emitted:
	   *         * bulk-send-ready: Ready to send bulk data to the server, using the
	   *           event data object containing:
	   *           * stream:   This output stream should only be used directly if
	   *                       you can ensure that you will write exactly |length|
	   *                       bytes and will not close the stream when writing is
	   *                       complete
	   *           * done:     If you use the stream directly (instead of |copyFrom|
	   *                       below), you must signal completion by resolving /
	   *                       rejecting this deferred.  If it's rejected, the
	   *                       transport will be closed.  If an Error is supplied as
	   *                       a rejection value, it will be logged via |dumpn|.  If
	   *                       you do use |copyFrom|, resolving is taken care of for
	   *                       you when copying completes.
	   *           * copyFrom: A helper function for getting your data onto the
	   *                       stream that meets the stream handling requirements
	   *                       above, and has the following signature:
	   *             @param  input nsIAsyncInputStream
	   *                     The stream to copy from.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   *         * json-reply: The server replied with a JSON packet, which is
	   *           passed as event data.
	   *         * bulk-reply: The server replied with bulk data, which you can read
	   *           using the event data object containing:
	   *           * actor:  Name of actor that received the packet
	   *           * type:   Name of actor's method that was called on receipt
	   *           * length: Size of the data to be read
	   *           * stream: This input stream should only be used directly if you
	   *                     can ensure that you will read exactly |length| bytes
	   *                     and will not close the stream when reading is complete
	   *           * done:   If you use the stream directly (instead of |copyTo|
	   *                     below), you must signal completion by resolving /
	   *                     rejecting this deferred.  If it's rejected, the
	   *                     transport will be closed.  If an Error is supplied as a
	   *                     rejection value, it will be logged via |dumpn|.  If you
	   *                     do use |copyTo|, resolving is taken care of for you
	   *                     when copying completes.
	   *           * copyTo: A helper function for getting your data out of the
	   *                     stream that meets the stream handling requirements
	   *                     above, and has the following signature:
	   *             @param  output nsIAsyncOutputStream
	   *                     The stream to copy to.
	   *             @return Promise
	   *                     The promise is resolved when copying completes or
	   *                     rejected if any (unexpected) errors occur.
	   *                     This object also emits "progress" events for each chunk
	   *                     that is copied.  See stream-utils.js.
	   */
	  startBulkRequest: function (request) {
	    if (!this.traits.bulk) {
	      throw Error("Server doesn't support bulk transfers");
	    }
	    if (!this.mainRoot) {
	      throw Error("Have not yet received a hello packet from the server.");
	    }
	    if (!request.type) {
	      throw Error("Bulk packet is missing the required 'type' field.");
	    }
	    if (!request.actor) {
	      throw Error("'" + request.type + "' bulk packet has no destination.");
	    }
	    if (!request.length) {
	      throw Error("'" + request.type + "' bulk packet has no length.");
	    }

	    request = new Request(request);
	    request.format = "bulk";

	    this._sendOrQueueRequest(request);

	    return request;
	  },

	  /**
	   * If a new request can be sent immediately, do so.  Otherwise, queue it.
	   */
	  _sendOrQueueRequest(request) {
	    let actor = request.actor;
	    if (!this._activeRequests.has(actor)) {
	      this._sendRequest(request);
	    } else {
	      this._queueRequest(request);
	    }
	  },

	  /**
	   * Send a request.
	   * @throws Error if there is already an active request in flight for the same
	   *         actor.
	   */
	  _sendRequest(request) {
	    let actor = request.actor;
	    this.expectReply(actor, request);

	    if (request.format === "json") {
	      this._transport.send(request.request);
	      return false;
	    }

	    this._transport.startBulkSend(request.request).then((...args) => {
	      request.emit("bulk-send-ready", ...args);
	    });
	  },

	  /**
	   * Queue a request to be sent later.  Queues are only drained when an in
	   * flight request to a given actor completes.
	   */
	  _queueRequest(request) {
	    let actor = request.actor;
	    let queue = this._pendingRequests.get(actor) || [];
	    queue.push(request);
	    this._pendingRequests.set(actor, queue);
	  },

	  /**
	   * Attempt the next request to a given actor (if any).
	   */
	  _attemptNextRequest(actor) {
	    if (this._activeRequests.has(actor)) {
	      return;
	    }
	    let queue = this._pendingRequests.get(actor);
	    if (!queue) {
	      return;
	    }
	    let request = queue.shift();
	    if (queue.length === 0) {
	      this._pendingRequests.delete(actor);
	    }
	    this._sendRequest(request);
	  },

	  /**
	   * Arrange to hand the next reply from |aActor| to the handler bound to
	   * |aRequest|.
	   *
	   * DebuggerClient.prototype.request / startBulkRequest usually takes care of
	   * establishing the handler for a given request, but in rare cases (well,
	   * greetings from new root actors, is the only case at the moment) we must be
	   * prepared for a "reply" that doesn't correspond to any request we sent.
	   */
	  expectReply: function (aActor, aRequest) {
	    if (this._activeRequests.has(aActor)) {
	      throw Error("clashing handlers for next reply from " + uneval(aActor));
	    }

	    // If a handler is passed directly (as it is with the handler for the root
	    // actor greeting), create a dummy request to bind this to.
	    if (typeof aRequest === "function") {
	      let handler = aRequest;
	      aRequest = new Request();
	      aRequest.on("json-reply", handler);
	    }

	    this._activeRequests.set(aActor, aRequest);
	  },

	  // Transport hooks.

	  /**
	   * Called by DebuggerTransport to dispatch incoming packets as appropriate.
	   *
	   * @param aPacket object
	   *        The incoming packet.
	   */
	  onPacket: function (aPacket) {
	    if (!aPacket.from) {
	      DevToolsUtils.reportException(
	        "onPacket",
	        new Error("Server did not specify an actor, dropping packet: " +
	                  JSON.stringify(aPacket)));
	      return;
	    }

	    // If we have a registered Front for this actor, let it handle the packet
	    // and skip all the rest of this unpleasantness.
	    let front = this.getActor(aPacket.from);
	    if (front) {
	      front.onPacket(aPacket);
	      return;
	    }

	    // Check for "forwardingCancelled" here instead of using a client to handle it.
	    // This is necessary because we might receive this event while the client is closing,
	    // and the clients have already been removed by that point.
	    if (this.mainRoot &&
	        aPacket.from == this.mainRoot.actor &&
	        aPacket.type == "forwardingCancelled") {
	      this.purgeRequests(aPacket.prefix);
	      return;
	    }

	    if (this._clients.has(aPacket.from) && aPacket.type) {
	      let client = this._clients.get(aPacket.from);
	      let type = aPacket.type;
	      if (client.events.indexOf(type) != -1) {
	        client.emit(type, aPacket);
	        // we ignore the rest, as the client is expected to handle this packet.
	        return;
	      }
	    }

	    let activeRequest;
	    // See if we have a handler function waiting for a reply from this
	    // actor. (Don't count unsolicited notifications or pauses as
	    // replies.)
	    if (this._activeRequests.has(aPacket.from) &&
	        !(aPacket.type in UnsolicitedNotifications) &&
	        !(aPacket.type == ThreadStateTypes.paused &&
	          aPacket.why.type in UnsolicitedPauses)) {
	      activeRequest = this._activeRequests.get(aPacket.from);
	      this._activeRequests.delete(aPacket.from);
	    }

	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(aPacket.from);

	    // Packets that indicate thread state changes get special treatment.
	    if (aPacket.type in ThreadStateTypes &&
	        this._clients.has(aPacket.from) &&
	        typeof this._clients.get(aPacket.from)._onThreadState == "function") {
	      this._clients.get(aPacket.from)._onThreadState(aPacket);
	    }

	    // TODO: Bug 1151156 - Remove once Gecko 40 is on b2g-stable.
	    if (!this.traits.noNeedToFakeResumptionOnNavigation) {
	      // On navigation the server resumes, so the client must resume as well.
	      // We achieve that by generating a fake resumption packet that triggers
	      // the client's thread state change listeners.
	      if (aPacket.type == UnsolicitedNotifications.tabNavigated &&
	          this._clients.has(aPacket.from) &&
	          this._clients.get(aPacket.from).thread) {
	        let thread = this._clients.get(aPacket.from).thread;
	        let resumption = { from: thread._actor, type: "resumed" };
	        thread._onThreadState(resumption);
	      }
	    }

	    // Only try to notify listeners on events, not responses to requests
	    // that lack a packet type.
	    if (aPacket.type) {
	      this.emit(aPacket.type, aPacket);
	    }

	    if (activeRequest) {
	      let emitReply = () => activeRequest.emit("json-reply", aPacket);
	      if (activeRequest.stack) {
	        callFunctionWithAsyncStack(emitReply, activeRequest.stack,
	                                   "DevTools RDP");
	      } else {
	        emitReply();
	      }
	    }
	  },

	  /**
	   * Called by the DebuggerTransport to dispatch incoming bulk packets as
	   * appropriate.
	   *
	   * @param packet object
	   *        The incoming packet, which contains:
	   *        * actor:  Name of actor that will receive the packet
	   *        * type:   Name of actor's method that should be called on receipt
	   *        * length: Size of the data to be read
	   *        * stream: This input stream should only be used directly if you can
	   *                  ensure that you will read exactly |length| bytes and will
	   *                  not close the stream when reading is complete
	   *        * done:   If you use the stream directly (instead of |copyTo|
	   *                  below), you must signal completion by resolving /
	   *                  rejecting this deferred.  If it's rejected, the transport
	   *                  will be closed.  If an Error is supplied as a rejection
	   *                  value, it will be logged via |dumpn|.  If you do use
	   *                  |copyTo|, resolving is taken care of for you when copying
	   *                  completes.
	   *        * copyTo: A helper function for getting your data out of the stream
	   *                  that meets the stream handling requirements above, and has
	   *                  the following signature:
	   *          @param  output nsIAsyncOutputStream
	   *                  The stream to copy to.
	   *          @return Promise
	   *                  The promise is resolved when copying completes or rejected
	   *                  if any (unexpected) errors occur.
	   *                  This object also emits "progress" events for each chunk
	   *                  that is copied.  See stream-utils.js.
	   */
	  onBulkPacket: function (packet) {
	    let { actor, type, length } = packet;

	    if (!actor) {
	      DevToolsUtils.reportException(
	        "onBulkPacket",
	        new Error("Server did not specify an actor, dropping bulk packet: " +
	                  JSON.stringify(packet)));
	      return;
	    }

	    // See if we have a handler function waiting for a reply from this
	    // actor.
	    if (!this._activeRequests.has(actor)) {
	      return;
	    }

	    let activeRequest = this._activeRequests.get(actor);
	    this._activeRequests.delete(actor);

	    // If there is a subsequent request for the same actor, hand it off to the
	    // transport.  Delivery of packets on the other end is always async, even
	    // in the local transport case.
	    this._attemptNextRequest(actor);

	    activeRequest.emit("bulk-reply", packet);
	  },

	  /**
	   * Called by DebuggerTransport when the underlying stream is closed.
	   *
	   * @param aStatus nsresult
	   *        The status code that corresponds to the reason for closing
	   *        the stream.
	   */
	  onClosed: function () {
	    this._closed = true;
	    this.emit("closed");

	    this.purgeRequests();

	    // The |_pools| array on the client-side currently is used only by
	    // protocol.js to store active fronts, mirroring the actor pools found in
	    // the server.  So, read all usages of "pool" as "protocol.js front".
	    //
	    // In the normal case where we shutdown cleanly, the toolbox tells each tool
	    // to close, and they each call |destroy| on any fronts they were using.
	    // When |destroy| or |cleanup| is called on a protocol.js front, it also
	    // removes itself from the |_pools| array.  Once the toolbox has shutdown,
	    // the connection is closed, and we reach here.  All fronts (should have
	    // been) |destroy|ed, so |_pools| should empty.
	    //
	    // If the connection instead aborts unexpectedly, we may end up here with
	    // all fronts used during the life of the connection.  So, we call |cleanup|
	    // on them clear their state, reject pending requests, and remove themselves
	    // from |_pools|.  This saves the toolbox from hanging indefinitely, in case
	    // it waits for some server response before shutdown that will now never
	    // arrive.
	    for (let pool of this._pools) {
	      pool.cleanup();
	    }
	  },

	  /**
	   * Purge pending and active requests in this client.
	   *
	   * @param prefix string (optional)
	   *        If a prefix is given, only requests for actor IDs that start with the prefix
	   *        will be cleaned up.  This is useful when forwarding of a portion of requests
	   *        is cancelled on the server.
	   */
	  purgeRequests(prefix = "") {
	    let reject = function (type, request) {
	      // Server can send packets on its own and client only pass a callback
	      // to expectReply, so that there is no request object.
	      let msg;
	      if (request.request) {
	        msg = "'" + request.request.type + "' " + type + " request packet" +
	              " to '" + request.actor + "' " +
	              "can't be sent as the connection just closed.";
	      } else {
	        msg = "server side packet can't be received as the connection just closed.";
	      }
	      let packet = { error: "connectionClosed", message: msg };
	      request.emit("json-reply", packet);
	    };

	    let pendingRequestsToReject = [];
	    this._pendingRequests.forEach((requests, actor) => {
	      if (!actor.startsWith(prefix)) {
	        return;
	      }
	      this._pendingRequests.delete(actor);
	      pendingRequestsToReject = pendingRequestsToReject.concat(requests);
	    });
	    pendingRequestsToReject.forEach(request => reject("pending", request));

	    let activeRequestsToReject = [];
	    this._activeRequests.forEach((request, actor) => {
	      if (!actor.startsWith(prefix)) {
	        return;
	      }
	      this._activeRequests.delete(actor);
	      activeRequestsToReject = activeRequestsToReject.concat(request);
	    });
	    activeRequestsToReject.forEach(request => reject("active", request));
	  },

	  registerClient: function (client) {
	    let actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.registerClient expects " +
	                      "a client instance with an `actor` attribute.");
	    }
	    if (!Array.isArray(client.events)) {
	      throw new Error("DebuggerServer.registerClient expects " +
	                      "a client instance with an `events` attribute " +
	                      "that is an array.");
	    }
	    if (client.events.length > 0 && typeof (client.emit) != "function") {
	      throw new Error("DebuggerServer.registerClient expects " +
	                      "a client instance with non-empty `events` array to" +
	                      "have an `emit` function.");
	    }
	    if (this._clients.has(actorID)) {
	      throw new Error("DebuggerServer.registerClient already registered " +
	                      "a client for this actor.");
	    }
	    this._clients.set(actorID, client);
	  },

	  unregisterClient: function (client) {
	    let actorID = client.actor;
	    if (!actorID) {
	      throw new Error("DebuggerServer.unregisterClient expects " +
	                      "a Client instance with a `actor` attribute.");
	    }
	    this._clients.delete(actorID);
	  },

	  /**
	   * Actor lifetime management, echos the server's actor pools.
	   */
	  __pools: null,
	  get _pools() {
	    if (this.__pools) {
	      return this.__pools;
	    }
	    this.__pools = new Set();
	    return this.__pools;
	  },

	  addActorPool: function (pool) {
	    this._pools.add(pool);
	  },
	  removeActorPool: function (pool) {
	    this._pools.delete(pool);
	  },
	  getActor: function (actorID) {
	    let pool = this.poolFor(actorID);
	    return pool ? pool.get(actorID) : null;
	  },

	  poolFor: function (actorID) {
	    for (let pool of this._pools) {
	      if (pool.has(actorID)) return pool;
	    }
	    return null;
	  },

	  /**
	   * Currently attached addon.
	   */
	  activeAddon: null
	};

	eventSource(DebuggerClient.prototype);

	function Request(request) {
	  this.request = request;
	}

	Request.prototype = {

	  on: function (type, listener) {
	    events.on(this, type, listener);
	  },

	  off: function (type, listener) {
	    events.off(this, type, listener);
	  },

	  once: function (type, listener) {
	    events.once(this, type, listener);
	  },

	  emit: function (type, ...args) {
	    events.emit(this, type, ...args);
	  },

	  get actor() { return this.request.to || this.request.actor; }

	};

	/**
	 * Creates a tab client for the remote debugging protocol server. This client
	 * is a front to the tab actor created in the server side, hiding the protocol
	 * details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm object
	 *        The protocol form for this tab.
	 */
	function TabClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._threadActor = aForm.threadActor;
	  this.javascriptEnabled = aForm.javascriptEnabled;
	  this.cacheDisabled = aForm.cacheDisabled;
	  this.thread = null;
	  this.request = this.client.request;
	  this.traits = aForm.traits || {};
	  this.events = ["workerListChanged"];
	}

	TabClient.prototype = {
	  get actor() { return this._actor; },
	  get _transport() { return this.client._transport; },

	  /**
	   * Attach to a thread actor.
	   *
	   * @param object aOptions
	   *        Configuration options.
	   *        - useSourceMaps: whether to use source maps or not.
	   * @param function aOnResponse
	   *        Called with the response packet and a ThreadClient
	   *        (which will be undefined on error).
	   */
	  attachThread: function (aOptions = {}, aOnResponse = noop) {
	    if (this.thread) {
	      DevToolsUtils.executeSoon(() => aOnResponse({}, this.thread));
	      return promise.resolve([{}, this.thread]);
	    }

	    let packet = {
	      to: this._threadActor,
	      type: "attach",
	      options: aOptions
	    };
	    return this.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this.thread = new ThreadClient(this, this._threadActor);
	        this.client.registerClient(this.thread);
	      }
	      aOnResponse(aResponse, this.thread);
	      return [aResponse, this.thread];
	    });
	  },

	  /**
	   * Detach the client from the tab actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    before: function (aPacket) {
	      if (this.thread) {
	        this.thread.detach();
	      }
	      return aPacket;
	    },
	    after: function (aResponse) {
	      this.client.unregisterClient(this);
	      return aResponse;
	    },
	  }),

	  /**
	   * Bring the window to the front.
	   */
	  focus: DebuggerClient.requester({
	    type: "focus"
	  }, {}),

	  /**
	   * Reload the page in this tab.
	   *
	   * @param [optional] object options
	   *        An object with a `force` property indicating whether or not
	   *        this reload should skip the cache
	   */
	  reload: function (options = { force: false }) {
	    return this._reload(options);
	  },
	  _reload: DebuggerClient.requester({
	    type: "reload",
	    options: args(0)
	  }),

	  /**
	   * Navigate to another URL.
	   *
	   * @param string url
	   *        The URL to navigate to.
	   */
	  navigateTo: DebuggerClient.requester({
	    type: "navigateTo",
	    url: args(0)
	  }),

	  /**
	   * Reconfigure the tab actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the tab actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }),

	  listWorkers: DebuggerClient.requester({
	    type: "listWorkers"
	  }),

	  attachWorker: function (aWorkerActor, aOnResponse) {
	    this.client.attachWorker(aWorkerActor, aOnResponse);
	  },

	  /**
	   * Resolve a location ({ url, line, column }) to its current
	   * source mapping location.
	   *
	   * @param {String} arg[0].url
	   * @param {Number} arg[0].line
	   * @param {Number?} arg[0].column
	   */
	  resolveLocation: DebuggerClient.requester({
	    type: "resolveLocation",
	    location: args(0)
	  }),
	};

	eventSource(TabClient.prototype);

	function WorkerClient(aClient, aForm) {
	  this.client = aClient;
	  this._actor = aForm.from;
	  this._isClosed = false;
	  this._url = aForm.url;

	  this._onClose = this._onClose.bind(this);

	  this.addListener("close", this._onClose);

	  this.traits = {};
	}

	WorkerClient.prototype = {
	  get _transport() {
	    return this.client._transport;
	  },

	  get request() {
	    return this.client.request;
	  },

	  get actor() {
	    return this._actor;
	  },

	  get url() {
	    return this._url;
	  },

	  get isClosed() {
	    return this._isClosed;
	  },

	  detach: DebuggerClient.requester({ type: "detach" }, {
	    after: function (aResponse) {
	      if (this.thread) {
	        this.client.unregisterClient(this.thread);
	      }
	      this.client.unregisterClient(this);
	      return aResponse;
	    },
	  }),

	  attachThread: function (aOptions = {}, aOnResponse = noop) {
	    if (this.thread) {
	      let response = [{
	        type: "connected",
	        threadActor: this.thread._actor,
	        consoleActor: this.consoleActor,
	      }, this.thread];
	      DevToolsUtils.executeSoon(() => aOnResponse(response));
	      return response;
	    }

	    // The connect call on server doesn't attach the thread as of version 44.
	    return this.request({
	      to: this._actor,
	      type: "connect",
	      options: aOptions,
	    }).then(connectReponse => {
	      if (connectReponse.error) {
	        aOnResponse(connectReponse, null);
	        return [connectResponse, null];
	      }

	      return this.request({
	        to: connectReponse.threadActor,
	        type: "attach",
	        options: aOptions
	      }).then(attachResponse => {
	        if (attachResponse.error) {
	          aOnResponse(attachResponse, null);
	        }

	        this.thread = new ThreadClient(this, connectReponse.threadActor);
	        this.consoleActor = connectReponse.consoleActor;
	        this.client.registerClient(this.thread);

	        aOnResponse(connectReponse, this.thread);
	        return [connectResponse, this.thread];
	      });
	    }, error => {
	      aOnResponse(error, null);
	    });
	  },

	  _onClose: function () {
	    this.removeListener("close", this._onClose);

	    if (this.thread) {
	      this.client.unregisterClient(this.thread);
	    }
	    this.client.unregisterClient(this);
	    this._isClosed = true;
	  },

	  reconfigure: function () {
	    return Promise.resolve();
	  },

	  events: ["close"]
	};

	eventSource(WorkerClient.prototype);

	function AddonClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.request = this._client.request;
	  this.events = [];
	}

	AddonClient.prototype = {
	  get actor() { return this._actor; },
	  get _transport() { return this._client._transport; },

	  /**
	   * Detach the client from the addon actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function (aResponse) {
	      if (this._client.activeAddon === this) {
	        this._client.activeAddon = null;
	      }
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	  })
	};

	/**
	 * A RootClient object represents a root actor on the server. Each
	 * DebuggerClient keeps a RootClient instance representing the root actor
	 * for the initial connection; DebuggerClient's 'listTabs' and
	 * 'listChildProcesses' methods forward to that root actor.
	 *
	 * @param aClient object
	 *      The client connection to which this actor belongs.
	 * @param aGreeting string
	 *      The greeting packet from the root actor we're to represent.
	 *
	 * Properties of a RootClient instance:
	 *
	 * @property actor string
	 *      The name of this child's root actor.
	 * @property applicationType string
	 *      The application type, as given in the root actor's greeting packet.
	 * @property traits object
	 *      The traits object, as given in the root actor's greeting packet.
	 */
	function RootClient(aClient, aGreeting) {
	  this._client = aClient;
	  this.actor = aGreeting.from;
	  this.applicationType = aGreeting.applicationType;
	  this.traits = aGreeting.traits;
	}
	exports.RootClient = RootClient;

	RootClient.prototype = {
	  constructor: RootClient,

	  /**
	   * List the open tabs.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listTabs: DebuggerClient.requester({ type: "listTabs" }),

	  /**
	   * List the installed addons.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listAddons: DebuggerClient.requester({ type: "listAddons" }),

	  /**
	   * List the registered workers.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listWorkers: DebuggerClient.requester({ type: "listWorkers" }),

	  /**
	   * List the registered service workers.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listServiceWorkerRegistrations: DebuggerClient.requester({
	    type: "listServiceWorkerRegistrations"
	  }),

	  /**
	   * List the running processes.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  listProcesses: DebuggerClient.requester({ type: "listProcesses" }),

	  /**
	   * Fetch the TabActor for the currently selected tab, or for a specific
	   * tab given as first parameter.
	   *
	   * @param [optional] object aFilter
	   *        A dictionary object with following optional attributes:
	   *         - outerWindowID: used to match tabs in parent process
	   *         - tabId: used to match tabs in child processes
	   *         - tab: a reference to xul:tab element
	   *        If nothing is specified, returns the actor for the currently
	   *        selected tab.
	   */
	  getTab: function (aFilter) {
	    let packet = {
	      to: this.actor,
	      type: "getTab"
	    };

	    if (aFilter) {
	      if (typeof (aFilter.outerWindowID) == "number") {
	        packet.outerWindowID = aFilter.outerWindowID;
	      } else if (typeof (aFilter.tabId) == "number") {
	        packet.tabId = aFilter.tabId;
	      } else if ("tab" in aFilter) {
	        let browser = aFilter.tab.linkedBrowser;
	        if (browser.frameLoader.tabParent) {
	          // Tabs in child process
	          packet.tabId = browser.frameLoader.tabParent.tabId;
	        } else if (browser.outerWindowID) {
	          // <xul:browser> tabs in parent process
	          packet.outerWindowID = browser.outerWindowID;
	        } else {
	          // <iframe mozbrowser> tabs in parent process
	          let windowUtils = browser.contentWindow
	                                   .QueryInterface(Ci.nsIInterfaceRequestor)
	                                   .getInterface(Ci.nsIDOMWindowUtils);
	          packet.outerWindowID = windowUtils.outerWindowID;
	        }
	      } else {
	        // Throw if a filter object have been passed but without
	        // any clearly idenfified filter.
	        throw new Error("Unsupported argument given to getTab request");
	      }
	    }

	    return this.request(packet);
	  },

	  /**
	   * Description of protocol's actors and methods.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  protocolDescription: DebuggerClient.requester({ type: "protocolDescription" }),

	  /*
	   * Methods constructed by DebuggerClient.requester require these forwards
	   * on their 'this'.
	   */
	  get _transport() { return this._client._transport; },
	  get request() { return this._client.request; }
	};

	/**
	 * Creates a thread client for the remote debugging protocol server. This client
	 * is a front to the thread actor created in the server side, hiding the
	 * protocol details in a traditional JavaScript API.
	 *
	 * @param aClient DebuggerClient|TabClient
	 *        The parent of the thread (tab for tab-scoped debuggers, DebuggerClient
	 *        for chrome debuggers).
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function ThreadClient(aClient, aActor) {
	  this._parent = aClient;
	  this.client = aClient instanceof DebuggerClient ? aClient : aClient.client;
	  this._actor = aActor;
	  this._frameCache = [];
	  this._scriptCache = {};
	  this._pauseGrips = {};
	  this._threadGrips = {};
	  this.request = this.client.request;
	}

	ThreadClient.prototype = {
	  _state: "paused",
	  get state() { return this._state; },
	  get paused() { return this._state === "paused"; },

	  _pauseOnExceptions: false,
	  _ignoreCaughtExceptions: false,
	  _pauseOnDOMEvents: null,

	  _actor: null,
	  get actor() { return this._actor; },

	  get _transport() { return this.client._transport; },

	  _assertPaused: function (aCommand) {
	    if (!this.paused) {
	      throw Error(aCommand + " command sent while not paused. Currently " + this._state);
	    }
	  },

	  /**
	   * Resume a paused thread. If the optional aLimit parameter is present, then
	   * the thread will also pause when that limit is reached.
	   *
	   * @param [optional] object aLimit
	   *        An object with a type property set to the appropriate limit (next,
	   *        step, or finish) per the remote debugging protocol specification.
	   *        Use null to specify no limit.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doResume: DebuggerClient.requester({
	    type: "resume",
	    resumeLimit: args(0)
	  }, {
	    before: function (aPacket) {
	      this._assertPaused("resume");

	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";

	      if (this._pauseOnExceptions) {
	        aPacket.pauseOnExceptions = this._pauseOnExceptions;
	      }
	      if (this._ignoreCaughtExceptions) {
	        aPacket.ignoreCaughtExceptions = this._ignoreCaughtExceptions;
	      }
	      if (this._pauseOnDOMEvents) {
	        aPacket.pauseOnDOMEvents = this._pauseOnDOMEvents;
	      }
	      return aPacket;
	    },
	    after: function (aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	  }),

	  /**
	   * Reconfigure the thread actor.
	   *
	   * @param object aOptions
	   *        A dictionary object of the new options to use in the thread actor.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  reconfigure: DebuggerClient.requester({
	    type: "reconfigure",
	    options: args(0)
	  }),

	  /**
	   * Resume a paused thread.
	   */
	  resume: function (aOnResponse) {
	    return this._doResume(null, aOnResponse);
	  },

	  /**
	   * Resume then pause without stepping.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  resumeThenPause: function (aOnResponse) {
	    return this._doResume({ type: "break" }, aOnResponse);
	  },

	  /**
	   * Step over a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOver: function (aOnResponse) {
	    return this._doResume({ type: "next" }, aOnResponse);
	  },

	  /**
	   * Step into a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepIn: function (aOnResponse) {
	    return this._doResume({ type: "step" }, aOnResponse);
	  },

	  /**
	   * Step out of a function call.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  stepOut: function (aOnResponse) {
	    return this._doResume({ type: "finish" }, aOnResponse);
	  },

	  /**
	   * Immediately interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  interrupt: function (aOnResponse) {
	    return this._doInterrupt(null, aOnResponse);
	  },

	  /**
	   * Pause execution right before the next JavaScript bytecode is executed.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  breakOnNext: function (aOnResponse) {
	    return this._doInterrupt("onNext", aOnResponse);
	  },

	  /**
	   * Interrupt a running thread.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  _doInterrupt: DebuggerClient.requester({
	    type: "interrupt",
	    when: args(0)
	  }),

	  /**
	   * Enable or disable pausing when an exception is thrown.
	   *
	   * @param boolean aFlag
	   *        Enables pausing if true, disables otherwise.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  pauseOnExceptions: function (aPauseOnExceptions,
	                               aIgnoreCaughtExceptions,
	                               aOnResponse = noop) {
	    this._pauseOnExceptions = aPauseOnExceptions;
	    this._ignoreCaughtExceptions = aIgnoreCaughtExceptions;

	    // Otherwise send the flag using a standard resume request.
	    if (!this.paused) {
	      return this.interrupt(aResponse => {
	        if (aResponse.error) {
	          // Can't continue if pausing failed.
	          aOnResponse(aResponse);
	          return aResponse;
	        }
	        return this.resume(aOnResponse);
	      });
	    }

	    aOnResponse();
	    return promise.resolve();
	  },

	  /**
	   * Enable pausing when the specified DOM events are triggered. Disabling
	   * pausing on an event can be realized by calling this method with the updated
	   * array of events that doesn't contain it.
	   *
	   * @param array|string events
	   *        An array of strings, representing the DOM event types to pause on,
	   *        or "*" to pause on all DOM events. Pass an empty array to
	   *        completely disable pausing on DOM events.
	   * @param function onResponse
	   *        Called with the response packet in a future turn of the event loop.
	   */
	  pauseOnDOMEvents: function (events, onResponse = noop) {
	    this._pauseOnDOMEvents = events;
	    // If the debuggee is paused, the value of the array will be communicated in
	    // the next resumption. Otherwise we have to force a pause in order to send
	    // the array.
	    if (this.paused) {
	      DevToolsUtils.executeSoon(() => onResponse({}));
	      return {};
	    }
	    return this.interrupt(response => {
	      // Can't continue if pausing failed.
	      if (response.error) {
	        onResponse(response);
	        return response;
	      }
	      return this.resume(onResponse);
	    });
	  },

	  /**
	   * Send a clientEvaluate packet to the debuggee. Response
	   * will be a resume packet.
	   *
	   * @param string aFrame
	   *        The actor ID of the frame where the evaluation should take place.
	   * @param string aExpression
	   *        The expression that will be evaluated in the scope of the frame
	   *        above.
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  eval: DebuggerClient.requester({
	    type: "clientEvaluate",
	    frame: args(0),
	    expression: args(1)
	  }, {
	    before: function (aPacket) {
	      this._assertPaused("eval");
	      // Put the client in a tentative "resuming" state so we can prevent
	      // further requests that should only be sent in the paused state.
	      this._state = "resuming";
	      return aPacket;
	    },
	    after: function (aResponse) {
	      if (aResponse.error) {
	        // There was an error resuming, back to paused state.
	        this._state = "paused";
	      }
	      return aResponse;
	    },
	  }),

	  /**
	   * Detach from the thread actor.
	   *
	   * @param function aOnResponse
	   *        Called with the response packet.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function (aResponse) {
	      this.client.unregisterClient(this);
	      this._parent.thread = null;
	      return aResponse;
	    },
	  }),

	  /**
	   * Release multiple thread-lifetime object actors. If any pause-lifetime
	   * actors are included in the request, a |notReleasable| error will return,
	   * but all the thread-lifetime ones will have been released.
	   *
	   * @param array actors
	   *        An array with actor IDs to release.
	   */
	  releaseMany: DebuggerClient.requester({
	    type: "releaseMany",
	    actors: args(0),
	  }),

	  /**
	   * Promote multiple pause-lifetime object actors to thread-lifetime ones.
	   *
	   * @param array actors
	   *        An array with actor IDs to promote.
	   */
	  threadGrips: DebuggerClient.requester({
	    type: "threadGrips",
	    actors: args(0)
	  }),

	  /**
	   * Return the event listeners defined on the page.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  eventListeners: DebuggerClient.requester({
	    type: "eventListeners"
	  }),

	  /**
	   * Request the loaded sources for the current thread.
	   *
	   * @param aOnResponse Function
	   *        Called with the thread's response.
	   */
	  getSources: DebuggerClient.requester({
	    type: "sources"
	  }),

	  /**
	   * Clear the thread's source script cache. A scriptscleared event
	   * will be sent.
	   */
	  _clearScripts: function () {
	    if (Object.keys(this._scriptCache).length > 0) {
	      this._scriptCache = {};
	      this.emit("scriptscleared");
	    }
	  },

	  /**
	   * Request frames from the callstack for the current thread.
	   *
	   * @param aStart integer
	   *        The number of the youngest stack frame to return (the youngest
	   *        frame is 0).
	   * @param aCount integer
	   *        The maximum number of frames to return, or null to return all
	   *        frames.
	   * @param aOnResponse function
	   *        Called with the thread's response.
	   */
	  getFrames: DebuggerClient.requester({
	    type: "frames",
	    start: args(0),
	    count: args(1)
	  }),

	  /**
	   * An array of cached frames. Clients can observe the framesadded and
	   * framescleared event to keep up to date on changes to this cache,
	   * and can fill it using the fillFrames method.
	   */
	  get cachedFrames() { return this._frameCache; },

	  /**
	   * true if there are more stack frames available on the server.
	   */
	  get moreFrames() {
	    return this.paused && (!this._frameCache || this._frameCache.length == 0
	          || !this._frameCache[this._frameCache.length - 1].oldest);
	  },

	  /**
	   * Ensure that at least aTotal stack frames have been loaded in the
	   * ThreadClient's stack frame cache. A framesadded event will be
	   * sent when the stack frame cache is updated.
	   *
	   * @param aTotal number
	   *        The minimum number of stack frames to be included.
	   * @param aCallback function
	   *        Optional callback function called when frames have been loaded
	   * @returns true if a framesadded notification should be expected.
	   */
	  fillFrames: function (aTotal, aCallback = noop) {
	    this._assertPaused("fillFrames");
	    if (this._frameCache.length >= aTotal) {
	      return false;
	    }

	    let numFrames = this._frameCache.length;

	    this.getFrames(numFrames, aTotal - numFrames, (aResponse) => {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return;
	      }

	      let threadGrips = DevToolsUtils.values(this._threadGrips);

	      for (let i in aResponse.frames) {
	        let frame = aResponse.frames[i];
	        if (!frame.where.source) {
	          // Older servers use urls instead, so we need to resolve
	          // them to source actors
	          for (let grip of threadGrips) {
	            if (grip instanceof SourceClient && grip.url === frame.url) {
	              frame.where.source = grip._form;
	            }
	          }
	        }

	        this._frameCache[frame.depth] = frame;
	      }

	      // If we got as many frames as we asked for, there might be more
	      // frames available.
	      this.emit("framesadded");

	      aCallback(aResponse);
	    });

	    return true;
	  },

	  /**
	   * Clear the thread's stack frame cache. A framescleared event
	   * will be sent.
	   */
	  _clearFrames: function () {
	    if (this._frameCache.length > 0) {
	      this._frameCache = [];
	      this.emit("framescleared");
	    }
	  },

	  /**
	   * Return a ObjectClient object for the given object grip.
	   *
	   * @param aGrip object
	   *        A pause-lifetime object grip returned by the protocol.
	   */
	  pauseGrip: function (aGrip) {
	    if (aGrip.actor in this._pauseGrips) {
	      return this._pauseGrips[aGrip.actor];
	    }

	    let client = new ObjectClient(this.client, aGrip);
	    this._pauseGrips[aGrip.actor] = client;
	    return client;
	  },

	  /**
	   * Get or create a long string client, checking the grip client cache if it
	   * already exists.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   * @param aGripCacheName String
	   *        The property name of the grip client cache to check for existing
	   *        clients in.
	   */
	  _longString: function (aGrip, aGripCacheName) {
	    if (aGrip.actor in this[aGripCacheName]) {
	      return this[aGripCacheName][aGrip.actor];
	    }

	    let client = new LongStringClient(this.client, aGrip);
	    this[aGripCacheName][aGrip.actor] = client;
	    return client;
	  },

	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the current pause.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  pauseLongString: function (aGrip) {
	    return this._longString(aGrip, "_pauseGrips");
	  },

	  /**
	   * Return an instance of LongStringClient for the given long string grip that
	   * is scoped to the thread lifetime.
	   *
	   * @param aGrip Object
	   *        The long string grip returned by the protocol.
	   */
	  threadLongString: function (aGrip) {
	    return this._longString(aGrip, "_threadGrips");
	  },

	  /**
	   * Clear and invalidate all the grip clients from the given cache.
	   *
	   * @param aGripCacheName
	   *        The property name of the grip cache we want to clear.
	   */
	  _clearObjectClients: function (aGripCacheName) {
	    for (let id in this[aGripCacheName]) {
	      this[aGripCacheName][id].valid = false;
	    }
	    this[aGripCacheName] = {};
	  },

	  /**
	   * Invalidate pause-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearPauseGrips: function () {
	    this._clearObjectClients("_pauseGrips");
	  },

	  /**
	   * Invalidate thread-lifetime grip clients and clear the list of current grip
	   * clients.
	   */
	  _clearThreadGrips: function () {
	    this._clearObjectClients("_threadGrips");
	  },

	  /**
	   * Handle thread state change by doing necessary cleanup and notifying all
	   * registered listeners.
	   */
	  _onThreadState: function (aPacket) {
	    this._state = ThreadStateTypes[aPacket.type];
	    // The debugger UI may not be initialized yet so we want to keep
	    // the packet around so it knows what to pause state to display
	    // when it's initialized
	    this._lastPausePacket = aPacket.type === "resumed" ? null : aPacket;
	    this._clearFrames();
	    this._clearPauseGrips();
	    aPacket.type === ThreadStateTypes.detached && this._clearThreadGrips();
	    this.client._eventsEnabled && this.emit(aPacket.type, aPacket);
	  },

	  getLastPausePacket: function () {
	    return this._lastPausePacket;
	  },

	  /**
	   * Return an EnvironmentClient instance for the given environment actor form.
	   */
	  environment: function (aForm) {
	    return new EnvironmentClient(this.client, aForm);
	  },

	  /**
	   * Return an instance of SourceClient for the given source actor form.
	   */
	  source: function (aForm) {
	    if (aForm.actor in this._threadGrips) {
	      return this._threadGrips[aForm.actor];
	    }

	    return this._threadGrips[aForm.actor] = new SourceClient(this, aForm);
	  },

	  /**
	   * Request the prototype and own properties of mutlipleObjects.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   * @param actors [string]
	   *        List of actor ID of the queried objects.
	   */
	  getPrototypesAndProperties: DebuggerClient.requester({
	    type: "prototypesAndProperties",
	    actors: args(0)
	  }),

	  events: ["newSource"]
	};

	eventSource(ThreadClient.prototype);

	/**
	 * Creates a tracing profiler client for the remote debugging protocol
	 * server. This client is a front to the trace actor created on the
	 * server side, hiding the protocol details in a traditional
	 * JavaScript API.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aActor string
	 *        The actor ID for this thread.
	 */
	function TraceClient(aClient, aActor) {
	  this._client = aClient;
	  this._actor = aActor;
	  this._activeTraces = new Set();
	  this._waitingPackets = new Map();
	  this._expectedPacket = 0;
	  this.request = this._client.request;
	  this.events = [];
	}

	TraceClient.prototype = {
	  get actor() { return this._actor; },
	  get tracing() { return this._activeTraces.size > 0; },

	  get _transport() { return this._client._transport; },

	  /**
	   * Detach from the trace actor.
	   */
	  detach: DebuggerClient.requester({
	    type: "detach"
	  }, {
	    after: function (aResponse) {
	      this._client.unregisterClient(this);
	      return aResponse;
	    },
	  }),

	  /**
	   * Start a new trace.
	   *
	   * @param aTrace [string]
	   *        An array of trace types to be recorded by the new trace.
	   *
	   * @param aName string
	   *        The name of the new trace.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  startTrace: DebuggerClient.requester({
	    type: "startTrace",
	    name: args(1),
	    trace: args(0)
	  }, {
	    after: function (aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }

	      if (!this.tracing) {
	        this._waitingPackets.clear();
	        this._expectedPacket = 0;
	      }
	      this._activeTraces.add(aResponse.name);

	      return aResponse;
	    },
	  }),

	  /**
	   * End a trace. If a name is provided, stop the named
	   * trace. Otherwise, stop the most recently started trace.
	   *
	   * @param aName string
	   *        The name of the trace to stop.
	   *
	   * @param aOnResponse function
	   *        Called with the request's response.
	   */
	  stopTrace: DebuggerClient.requester({
	    type: "stopTrace",
	    name: args(0)
	  }, {
	    after: function (aResponse) {
	      if (aResponse.error) {
	        return aResponse;
	      }

	      this._activeTraces.delete(aResponse.name);

	      return aResponse;
	    },
	  })
	};

	/**
	 * Grip clients are used to retrieve information about the relevant object.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip object
	 *        A pause-lifetime object grip returned by the protocol.
	 */
	function ObjectClient(aClient, aGrip)
	{
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.ObjectClient = ObjectClient;

	ObjectClient.prototype = {
	  get actor() { return this._grip.actor; },
	  get _transport() { return this._client._transport; },

	  valid: true,

	  get isFrozen() {
	    return this._grip.frozen;
	  },
	  get isSealed() {
	    return this._grip.sealed;
	  },
	  get isExtensible() {
	    return this._grip.extensible;
	  },

	  getDefinitionSite: DebuggerClient.requester({
	    type: "definitionSite"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class != "Function") {
	        throw new Error("getDefinitionSite is only valid for function grips.");
	      }
	      return aPacket;
	    }
	  }),

	  /**
	   * Request the names of a function's formal parameters.
	   *
	   * @param aOnResponse function
	   *        Called with an object of the form:
	   *        { parameterNames:[<parameterName>, ...] }
	   *        where each <parameterName> is the name of a parameter.
	   */
	  getParameterNames: DebuggerClient.requester({
	    type: "parameterNames"
	  }, {
	    before: function (aPacket) {
	      if (this._grip["class"] !== "Function") {
	        throw new Error("getParameterNames is only valid for function grips.");
	      }
	      return aPacket;
	    },
	  }),

	  /**
	   * Request the names of the properties defined on the object and not its
	   * prototype.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getOwnPropertyNames: DebuggerClient.requester({
	    type: "ownPropertyNames"
	  }),

	  /**
	   * Request the prototype and own properties of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototypeAndProperties: DebuggerClient.requester({
	    type: "prototypeAndProperties"
	  }),

	  /**
	   * Request a PropertyIteratorClient instance to ease listing
	   * properties for this object.
	   *
	   * @param options Object
	   *        A dictionary object with various boolean attributes:
	   *        - ignoreIndexedProperties Boolean
	   *          If true, filters out Array items.
	   *          e.g. properties names between `0` and `object.length`.
	   *        - ignoreNonIndexedProperties Boolean
	   *          If true, filters out items that aren't array items
	   *          e.g. properties names that are not a number between `0`
	   *          and `object.length`.
	   *        - sort Boolean
	   *          If true, the iterator will sort the properties by name
	   *          before dispatching them.
	   * @param aOnResponse function Called with the client instance.
	   */
	  enumProperties: DebuggerClient.requester({
	    type: "enumProperties",
	    options: args(0)
	  }, {
	    after: function (aResponse) {
	      if (aResponse.iterator) {
	        return { iterator: new PropertyIteratorClient(this._client, aResponse.iterator) };
	      }
	      return aResponse;
	    },
	  }),

	  /**
	   * Request a PropertyIteratorClient instance to enumerate entries in a
	   * Map/Set-like object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  enumEntries: DebuggerClient.requester({
	    type: "enumEntries"
	  }, {
	    before: function (packet) {
	      if (!["Map", "WeakMap", "Set", "WeakSet"].includes(this._grip.class)) {
	        throw new Error("enumEntries is only valid for Map/Set-like grips.");
	      }
	      return packet;
	    },
	    after: function (response) {
	      if (response.iterator) {
	        return {
	          iterator: new PropertyIteratorClient(this._client, response.iterator)
	        };
	      }
	      return response;
	    }
	  }),

	  /**
	   * Request the property descriptor of the object's specified property.
	   *
	   * @param aName string The name of the requested property.
	   * @param aOnResponse function Called with the request's response.
	   */
	  getProperty: DebuggerClient.requester({
	    type: "property",
	    name: args(0)
	  }),

	  /**
	   * Request the prototype of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getPrototype: DebuggerClient.requester({
	    type: "prototype"
	  }),

	  /**
	   * Request the display string of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getDisplayString: DebuggerClient.requester({
	    type: "displayString"
	  }),

	  /**
	   * Request the scope of the object.
	   *
	   * @param aOnResponse function Called with the request's response.
	   */
	  getScope: DebuggerClient.requester({
	    type: "scope"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Function") {
	        throw new Error("scope is only valid for function grips.");
	      }
	      return aPacket;
	    },
	  }),

	  /**
	   * Request the promises directly depending on the current promise.
	   */
	  getDependentPromises: DebuggerClient.requester({
	    type: "dependentPromises"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getDependentPromises is only valid for promise " +
	          "grips.");
	      }
	      return aPacket;
	    }
	  }),

	  /**
	   * Request the stack to the promise's allocation point.
	   */
	  getPromiseAllocationStack: DebuggerClient.requester({
	    type: "allocationStack"
	  }, {
	    before: function (aPacket) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getAllocationStack is only valid for promise grips.");
	      }
	      return aPacket;
	    }
	  }),

	  /**
	   * Request the stack to the promise's fulfillment point.
	   */
	  getPromiseFulfillmentStack: DebuggerClient.requester({
	    type: "fulfillmentStack"
	  }, {
	    before: function (packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseFulfillmentStack is only valid for " +
	          "promise grips.");
	      }
	      return packet;
	    }
	  }),

	  /**
	   * Request the stack to the promise's rejection point.
	   */
	  getPromiseRejectionStack: DebuggerClient.requester({
	    type: "rejectionStack"
	  }, {
	    before: function (packet) {
	      if (this._grip.class !== "Promise") {
	        throw new Error("getPromiseRejectionStack is only valid for " +
	          "promise grips.");
	      }
	      return packet;
	    }
	  })
	};

	/**
	 * A PropertyIteratorClient provides a way to access to property names and
	 * values of an object efficiently, slice by slice.
	 * Note that the properties can be sorted in the backend,
	 * this is controled while creating the PropertyIteratorClient
	 * from ObjectClient.enumProperties.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A PropertyIteratorActor grip returned by the protocol via
	 *        TabActor.enumProperties request.
	 */
	function PropertyIteratorClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}

	PropertyIteratorClient.prototype = {
	  get actor() { return this._grip.actor; },

	  /**
	   * Get the total number of properties available in the iterator.
	   */
	  get count() { return this._grip.count; },

	  /**
	   * Get one or more property names that correspond to the positions in the
	   * indexes parameter.
	   *
	   * @param indexes Array
	   *        An array of property indexes.
	   * @param aCallback Function
	   *        The function called when we receive the property names.
	   */
	  names: DebuggerClient.requester({
	    type: "names",
	    indexes: args(0)
	  }, {}),

	  /**
	   * Get a set of following property value(s).
	   *
	   * @param start Number
	   *        The index of the first property to fetch.
	   * @param count Number
	   *        The number of properties to fetch.
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  slice: DebuggerClient.requester({
	    type: "slice",
	    start: args(0),
	    count: args(1)
	  }, {}),

	  /**
	   * Get all the property values.
	   *
	   * @param aCallback Function
	   *        The function called when we receive the property values.
	   */
	  all: DebuggerClient.requester({
	    type: "all"
	  }, {}),
	};

	/**
	 * A LongStringClient provides a way to access "very long" strings from the
	 * debugger server.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aGrip Object
	 *        A pause-lifetime long string grip returned by the protocol.
	 */
	function LongStringClient(aClient, aGrip) {
	  this._grip = aGrip;
	  this._client = aClient;
	  this.request = this._client.request;
	}
	exports.LongStringClient = LongStringClient;

	LongStringClient.prototype = {
	  get actor() { return this._grip.actor; },
	  get length() { return this._grip.length; },
	  get initial() { return this._grip.initial; },
	  get _transport() { return this._client._transport; },

	  valid: true,

	  /**
	   * Get the substring of this LongString from aStart to aEnd.
	   *
	   * @param aStart Number
	   *        The starting index.
	   * @param aEnd Number
	   *        The ending index.
	   * @param aCallback Function
	   *        The function called when we receive the substring.
	   */
	  substring: DebuggerClient.requester({
	    type: "substring",
	    start: args(0),
	    end: args(1)
	  }),
	};

	/**
	 * A SourceClient provides a way to access the source text of a script.
	 *
	 * @param aClient ThreadClient
	 *        The thread client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function SourceClient(aClient, aForm) {
	  this._form = aForm;
	  this._isBlackBoxed = aForm.isBlackBoxed;
	  this._isPrettyPrinted = aForm.isPrettyPrinted;
	  this._activeThread = aClient;
	  this._client = aClient.client;
	}

	SourceClient.prototype = {
	  get _transport() {
	    return this._client._transport;
	  },
	  get isBlackBoxed() {
	    return this._isBlackBoxed;
	  },
	  get isPrettyPrinted() {
	    return this._isPrettyPrinted;
	  },
	  get actor() {
	    return this._form.actor;
	  },
	  get request() {
	    return this._client.request;
	  },
	  get url() {
	    return this._form.url;
	  },

	  /**
	   * Black box this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  blackBox: DebuggerClient.requester({
	    type: "blackbox"
	  }, {
	    after: function (aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = true;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),

	  /**
	   * Un-black box this SourceClient's source.
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  unblackBox: DebuggerClient.requester({
	    type: "unblackbox"
	  }, {
	    after: function (aResponse) {
	      if (!aResponse.error) {
	        this._isBlackBoxed = false;
	        if (this._activeThread) {
	          this._activeThread.emit("blackboxchange", this);
	        }
	      }
	      return aResponse;
	    }
	  }),

	  /**
	   * Get Executable Lines from a source
	   *
	   * @param aCallback Function
	   *        The callback function called when we receive the response from the server.
	   */
	  getExecutableLines: function (cb = noop) {
	    let packet = {
	      to: this._form.actor,
	      type: "getExecutableLines"
	    };

	    return this._client.request(packet).then(res => {
	      cb(res.lines);
	      return res.lines;
	    });
	  },

	  /**
	   * Get a long string grip for this SourceClient's source.
	   */
	  source: function (aCallback = noop) {
	    let packet = {
	      to: this._form.actor,
	      type: "source"
	    };
	    return this._client.request(packet).then(aResponse => {
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },

	  /**
	   * Pretty print this source's text.
	   */
	  prettyPrint: function (aIndent, aCallback = noop) {
	    const packet = {
	      to: this._form.actor,
	      type: "prettyPrint",
	      indent: aIndent
	    };
	    return this._client.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this._isPrettyPrinted = true;
	        this._activeThread._clearFrames();
	        this._activeThread.emit("prettyprintchange", this);
	      }
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },

	  /**
	   * Stop pretty printing this source's text.
	   */
	  disablePrettyPrint: function (aCallback = noop) {
	    const packet = {
	      to: this._form.actor,
	      type: "disablePrettyPrint"
	    };
	    return this._client.request(packet).then(aResponse => {
	      if (!aResponse.error) {
	        this._isPrettyPrinted = false;
	        this._activeThread._clearFrames();
	        this._activeThread.emit("prettyprintchange", this);
	      }
	      return this._onSourceResponse(aResponse, aCallback);
	    });
	  },

	  _onSourceResponse: function (aResponse, aCallback) {
	    if (aResponse.error) {
	      aCallback(aResponse);
	      return aResponse;
	    }

	    if (typeof aResponse.source === "string") {
	      aCallback(aResponse);
	      return aResponse;
	    }

	    let { contentType, source } = aResponse;
	    let longString = this._activeThread.threadLongString(source);
	    return longString.substring(0, longString.length).then(function (aResponse) {
	      if (aResponse.error) {
	        aCallback(aResponse);
	        return aReponse;
	      }

	      let response = {
	        source: aResponse.substring,
	        contentType: contentType
	      };
	      aCallback(response);
	      return response;
	    });
	  },

	  /**
	   * Request to set a breakpoint in the specified location.
	   *
	   * @param object aLocation
	   *        The location and condition of the breakpoint in
	   *        the form of { line[, column, condition] }.
	   * @param function aOnResponse
	   *        Called with the thread's response.
	   */
	  setBreakpoint: function ({ line, column, condition }, aOnResponse = noop) {
	    // A helper function that sets the breakpoint.
	    let doSetBreakpoint = aCallback => {
	      let root = this._client.mainRoot;
	      let location = {
	        line: line,
	        column: column
	      };

	      let packet = {
	        to: this.actor,
	        type: "setBreakpoint",
	        location: location,
	        condition: condition
	      };

	      // Backwards compatibility: send the breakpoint request to the
	      // thread if the server doesn't support Debugger.Source actors.
	      if (!root.traits.debuggerSourceActors) {
	        packet.to = this._activeThread.actor;
	        packet.location.url = this.url;
	      }

	      return this._client.request(packet).then(aResponse => {
	        // Ignoring errors, since the user may be setting a breakpoint in a
	        // dead script that will reappear on a page reload.
	        let bpClient;
	        if (aResponse.actor) {
	          bpClient = new BreakpointClient(
	            this._client,
	            this,
	            aResponse.actor,
	            location,
	            root.traits.conditionalBreakpoints ? condition : undefined
	          );
	        }
	        aOnResponse(aResponse, bpClient);
	        if (aCallback) {
	          aCallback();
	        }
	        return [aResponse, bpClient];
	      });
	    };

	    // If the debuggee is paused, just set the breakpoint.
	    if (this._activeThread.paused) {
	      return doSetBreakpoint();
	    }
	    // Otherwise, force a pause in order to set the breakpoint.
	    return this._activeThread.interrupt().then(aResponse => {
	      if (aResponse.error) {
	        // Can't set the breakpoint if pausing failed.
	        aOnResponse(aResponse);
	        return aResponse;
	      }

	      const { type, why } = aResponse;
	      const cleanUp = type == "paused" && why.type == "interrupted"
	            ? () => this._activeThread.resume()
	            : noop;

	      return doSetBreakpoint(cleanUp);
	    });
	  }
	};

	/**
	 * Breakpoint clients are used to remove breakpoints that are no longer used.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aSourceClient SourceClient
	 *        The source where this breakpoint exists
	 * @param aActor string
	 *        The actor ID for this breakpoint.
	 * @param aLocation object
	 *        The location of the breakpoint. This is an object with two properties:
	 *        url and line.
	 * @param aCondition string
	 *        The conditional expression of the breakpoint
	 */
	function BreakpointClient(aClient, aSourceClient, aActor, aLocation, aCondition) {
	  this._client = aClient;
	  this._actor = aActor;
	  this.location = aLocation;
	  this.location.actor = aSourceClient.actor;
	  this.location.url = aSourceClient.url;
	  this.source = aSourceClient;
	  this.request = this._client.request;

	  // The condition property should only exist if it's a truthy value
	  if (aCondition) {
	    this.condition = aCondition;
	  }
	}

	BreakpointClient.prototype = {

	  _actor: null,
	  get actor() { return this._actor; },
	  get _transport() { return this._client._transport; },

	  /**
	   * Remove the breakpoint from the server.
	   */
	  remove: DebuggerClient.requester({
	    type: "delete"
	  }),

	  /**
	   * Determines if this breakpoint has a condition
	   */
	  hasCondition: function () {
	    let root = this._client.mainRoot;
	    // XXX bug 990137: We will remove support for client-side handling of
	    // conditional breakpoints
	    if (root.traits.conditionalBreakpoints) {
	      return "condition" in this;
	    } else {
	      return "conditionalExpression" in this;
	    }
	  },

	  /**
	   * Get the condition of this breakpoint. Currently we have to
	   * support locally emulated conditional breakpoints until the
	   * debugger servers are updated (see bug 990137). We used a
	   * different property when moving it server-side to ensure that we
	   * are testing the right code.
	   */
	  getCondition: function () {
	    let root = this._client.mainRoot;
	    if (root.traits.conditionalBreakpoints) {
	      return this.condition;
	    } else {
	      return this.conditionalExpression;
	    }
	  },

	  /**
	   * Set the condition of this breakpoint
	   */
	  setCondition: function (gThreadClient, aCondition) {
	    let root = this._client.mainRoot;
	    let deferred = promise.defer();

	    if (root.traits.conditionalBreakpoints) {
	      let info = {
	        line: this.location.line,
	        column: this.location.column,
	        condition: aCondition
	      };

	      // Remove the current breakpoint and add a new one with the
	      // condition.
	      this.remove(aResponse => {
	        if (aResponse && aResponse.error) {
	          deferred.reject(aResponse);
	          return;
	        }

	        this.source.setBreakpoint(info, (aResponse, aNewBreakpoint) => {
	          if (aResponse && aResponse.error) {
	            deferred.reject(aResponse);
	          } else {
	            deferred.resolve(aNewBreakpoint);
	          }
	        });
	      });
	    } else {
	      // The property shouldn't even exist if the condition is blank
	      if (aCondition === "") {
	        delete this.conditionalExpression;
	      }
	      else {
	        this.conditionalExpression = aCondition;
	      }
	      deferred.resolve(this);
	    }

	    return deferred.promise;
	  }
	};

	eventSource(BreakpointClient.prototype);

	/**
	 * Environment clients are used to manipulate the lexical environment actors.
	 *
	 * @param aClient DebuggerClient
	 *        The debugger client parent.
	 * @param aForm Object
	 *        The form sent across the remote debugging protocol.
	 */
	function EnvironmentClient(aClient, aForm) {
	  this._client = aClient;
	  this._form = aForm;
	  this.request = this._client.request;
	}
	exports.EnvironmentClient = EnvironmentClient;

	EnvironmentClient.prototype = {

	  get actor() {
	    return this._form.actor;
	  },
	  get _transport() { return this._client._transport; },

	  /**
	   * Fetches the bindings introduced by this lexical environment.
	   */
	  getBindings: DebuggerClient.requester({
	    type: "bindings"
	  }),

	  /**
	   * Changes the value of the identifier whose name is name (a string) to that
	   * represented by value (a grip).
	   */
	  assign: DebuggerClient.requester({
	    type: "assign",
	    name: args(0),
	    value: args(1)
	  })
	};

	eventSource(EnvironmentClient.prototype);


/***/ },
/* 172 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	function DebuggerPanel(iframeWindow, toolbox) {
	  this.panelWin = iframeWindow;
	  this.toolbox = toolbox;
	}

	DebuggerPanel.prototype = {
	  open: function() {
	    let targetPromise;
	    if (!this.toolbox.target.isRemote) {
	      targetPromise = this.toolbox.target.makeRemote();
	    } else {
	      targetPromise = promise.resolve(this.toolbox.target);
	    }

	    return targetPromise.then(() => {
	      const dbg = this.panelWin.Debugger;
	      dbg.setThreadClient(this.toolbox.threadClient);
	      dbg.setTabTarget(this.toolbox.target);
	      dbg.initPage(dbg.getActions());
	      dbg.renderApp();
	      return this;
	    });
	  },

	  destroy: function() {
	  }
	};

	exports.DebuggerPanel = DebuggerPanel;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/*
	 * About the objects defined in this file:
	 * - CssLogic contains style information about a view context. It provides
	 *   access to 2 sets of objects: Css[Sheet|Rule|Selector] provide access to
	 *   information that does not change when the selected element changes while
	 *   Css[Property|Selector]Info provide information that is dependent on the
	 *   selected element.
	 *   Its key methods are highlight(), getPropertyInfo() and forEachSheet(), etc
	 *   It also contains a number of static methods for l10n, naming, etc
	 *
	 * - CssSheet provides a more useful API to a DOM CSSSheet for our purposes,
	 *   including shortSource and href.
	 * - CssRule a more useful API to a nsIDOMCSSRule including access to the group
	 *   of CssSelectors that the rule provides properties for
	 * - CssSelector A single selector - i.e. not a selector group. In other words
	 *   a CssSelector does not contain ','. This terminology is different from the
	 *   standard DOM API, but more inline with the definition in the spec.
	 *
	 * - CssPropertyInfo contains style information for a single property for the
	 *   highlighted element.
	 * - CssSelectorInfo is a wrapper around CssSelector, which adds sorting with
	 *   reference to the selected element.
	 */

	"use strict";

	/**
	 * Provide access to the style information in a page.
	 * CssLogic uses the standard DOM API, and the Gecko inIDOMUtils API to access
	 * styling information in the page, and present this to the user in a way that
	 * helps them understand:
	 * - why their expectations may not have been fulfilled
	 * - how browsers process CSS
	 * @constructor
	 */

	const Services = __webpack_require__(1);
	const CSSLexer = __webpack_require__(174);
	const {LocalizationHelper} = __webpack_require__(56);
	const styleInspectorL10N =
	  new LocalizationHelper("devtools-shared/locale/styleinspector.properties");

	/**
	 * Special values for filter, in addition to an href these values can be used
	 */
	exports.FILTER = {
	  // show properties for all user style sheets.
	  USER: "user",
	  // USER, plus user-agent (i.e. browser) style sheets
	  UA: "ua",
	};

	/**
	 * Each rule has a status, the bigger the number, the better placed it is to
	 * provide styling information.
	 *
	 * These statuses are localized inside the styleinspector.properties
	 * string bundle.
	 * @see csshtmltree.js RuleView._cacheStatusNames()
	 */
	exports.STATUS = {
	  BEST: 3,
	  MATCHED: 2,
	  PARENT_MATCH: 1,
	  UNMATCHED: 0,
	  UNKNOWN: -1,
	};

	/**
	 * Lookup a l10n string in the shared styleinspector string bundle.
	 *
	 * @param {String} name
	 *        The key to lookup.
	 * @returns {String} A localized version of the given key.
	 */
	exports.l10n = name => styleInspectorL10N.getStr(name);

	/**
	 * Is the given property sheet a content stylesheet?
	 *
	 * @param {CSSStyleSheet} sheet a stylesheet
	 * @return {boolean} true if the given stylesheet is a content stylesheet,
	 * false otherwise.
	 */
	exports.isContentStylesheet = function (sheet) {
	  return sheet.parsingMode !== "agent";
	};

	/**
	 * Return a shortened version of a style sheet's source.
	 *
	 * @param {CSSStyleSheet} sheet the DOM object for the style sheet.
	 */
	exports.shortSource = function (sheet) {
	  // Use a string like "inline" if there is no source href
	  if (!sheet || !sheet.href) {
	    return exports.l10n("rule.sourceInline");
	  }

	  // We try, in turn, the filename, filePath, query string, whole thing
	  let url = {};
	  try {
	    url = new URL(sheet.href);
	  } catch (ex) {
	    // Some UA-provided stylesheets are not valid URLs.
	  }

	  if (url.pathname) {
	    let index = url.pathname.lastIndexOf("/");
	    if (index !== -1 && index < url.pathname.length) {
	      return url.pathname.slice(index + 1);
	    }
	    return url.pathname;
	  }

	  if (url.query) {
	    return url.query;
	  }

	  let dataUrl = sheet.href.match(/^(data:[^,]*),/);
	  return dataUrl ? dataUrl[1] : sheet.href;
	};

	const TAB_CHARS = "\t";

	/**
	 * Prettify minified CSS text.
	 * This prettifies CSS code where there is no indentation in usual places while
	 * keeping original indentation as-is elsewhere.
	 * @param string text The CSS source to prettify.
	 * @return string Prettified CSS source
	 */
	function prettifyCSS(text, ruleCount) {
	  if (prettifyCSS.LINE_SEPARATOR == null) {
	    let os = Services.appinfo.OS;
	    prettifyCSS.LINE_SEPARATOR = (os === "WINNT" ? "\r\n" : "\n");
	  }

	  // remove initial and terminating HTML comments and surrounding whitespace
	  text = text.replace(/(?:^\s*<!--[\r\n]*)|(?:\s*-->\s*$)/g, "");
	  let originalText = text;
	  text = text.trim();

	  // don't attempt to prettify if there's more than one line per rule.
	  let lineCount = text.split("\n").length - 1;
	  if (ruleCount !== null && lineCount >= ruleCount) {
	    return originalText;
	  }

	  // We reformat the text using a simple state machine.  The
	  // reformatting preserves most of the input text, changing only
	  // whitespace.  The rules are:
	  //
	  // * After a "{" or ";" symbol, ensure there is a newline and
	  //   indentation before the next non-comment, non-whitespace token.
	  // * Additionally after a "{" symbol, increase the indentation.
	  // * A "}" symbol ensures there is a preceding newline, and
	  //   decreases the indentation level.
	  // * Ensure there is whitespace before a "{".
	  //
	  // This approach can be confused sometimes, but should do ok on a
	  // minified file.
	  let indent = "";
	  let indentLevel = 0;
	  let tokens = CSSLexer.getCSSLexer(text);
	  let result = "";
	  let pushbackToken = undefined;

	  // A helper function that reads tokens, looking for the next
	  // non-comment, non-whitespace token.  Comment and whitespace tokens
	  // are appended to |result|.  If this encounters EOF, it returns
	  // null.  Otherwise it returns the last whitespace token that was
	  // seen.  This function also updates |pushbackToken|.
	  let readUntilSignificantToken = () => {
	    while (true) {
	      let token = tokens.nextToken();
	      if (!token || token.tokenType !== "whitespace") {
	        pushbackToken = token;
	        return token;
	      }
	      // Saw whitespace.  Before committing to it, check the next
	      // token.
	      let nextToken = tokens.nextToken();
	      if (!nextToken || nextToken.tokenType !== "comment") {
	        pushbackToken = nextToken;
	        return token;
	      }
	      // Saw whitespace + comment.  Update the result and continue.
	      result = result + text.substring(token.startOffset, nextToken.endOffset);
	    }
	  };

	  // State variables for readUntilNewlineNeeded.
	  //
	  // Starting index of the accumulated tokens.
	  let startIndex;
	  // Ending index of the accumulated tokens.
	  let endIndex;
	  // True if any non-whitespace token was seen.
	  let anyNonWS;
	  // True if the terminating token is "}".
	  let isCloseBrace;
	  // True if the token just before the terminating token was
	  // whitespace.
	  let lastWasWS;

	  // A helper function that reads tokens until there is a reason to
	  // insert a newline.  This updates the state variables as needed.
	  // If this encounters EOF, it returns null.  Otherwise it returns
	  // the final token read.  Note that if the returned token is "{",
	  // then it will not be included in the computed start/end token
	  // range.  This is used to handle whitespace insertion before a "{".
	  let readUntilNewlineNeeded = () => {
	    let token;
	    while (true) {
	      if (pushbackToken) {
	        token = pushbackToken;
	        pushbackToken = undefined;
	      } else {
	        token = tokens.nextToken();
	      }
	      if (!token) {
	        endIndex = text.length;
	        break;
	      }

	      // A "}" symbol must be inserted later, to deal with indentation
	      // and newline.
	      if (token.tokenType === "symbol" && token.text === "}") {
	        isCloseBrace = true;
	        break;
	      } else if (token.tokenType === "symbol" && token.text === "{") {
	        break;
	      }

	      if (token.tokenType !== "whitespace") {
	        anyNonWS = true;
	      }

	      if (startIndex === undefined) {
	        startIndex = token.startOffset;
	      }
	      endIndex = token.endOffset;

	      if (token.tokenType === "symbol" && token.text === ";") {
	        break;
	      }

	      lastWasWS = token.tokenType === "whitespace";
	    }
	    return token;
	  };

	  while (true) {
	    // Set the initial state.
	    startIndex = undefined;
	    endIndex = undefined;
	    anyNonWS = false;
	    isCloseBrace = false;
	    lastWasWS = false;

	    // Read tokens until we see a reason to insert a newline.
	    let token = readUntilNewlineNeeded();

	    // Append any saved up text to the result, applying indentation.
	    if (startIndex !== undefined) {
	      if (isCloseBrace && !anyNonWS) {
	        // If we saw only whitespace followed by a "}", then we don't
	        // need anything here.
	      } else {
	        result = result + indent + text.substring(startIndex, endIndex);
	        if (isCloseBrace) {
	          result += prettifyCSS.LINE_SEPARATOR;
	        }
	      }
	    }

	    if (isCloseBrace) {
	      indent = TAB_CHARS.repeat(--indentLevel);
	      result = result + indent + "}";
	    }

	    if (!token) {
	      break;
	    }

	    if (token.tokenType === "symbol" && token.text === "{") {
	      if (!lastWasWS) {
	        result += " ";
	      }
	      result += "{";
	      indent = TAB_CHARS.repeat(++indentLevel);
	    }

	    // Now it is time to insert a newline.  However first we want to
	    // deal with any trailing comments.
	    token = readUntilSignificantToken();

	    // "Early" bail-out if the text does not appear to be minified.
	    // Here we ignore the case where whitespace appears at the end of
	    // the text.
	    if (pushbackToken && token && token.tokenType === "whitespace" &&
	        /\n/g.test(text.substring(token.startOffset, token.endOffset))) {
	      return originalText;
	    }

	    // Finally time for that newline.
	    result = result + prettifyCSS.LINE_SEPARATOR;

	    // Maybe we hit EOF.
	    if (!pushbackToken) {
	      break;
	    }
	  }

	  return result;
	}

	exports.prettifyCSS = prettifyCSS;


/***/ },
/* 174 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// A CSS Lexer.  This file is a bit unusual -- it is a more or less
	// direct translation of layout/style/nsCSSScanner.cpp and
	// layout/style/CSSLexer.cpp into JS.  This implements the
	// CSSLexer.webidl interface, and the intent is to try to keep it in
	// sync with changes to the platform CSS lexer.  Due to this goal,
	// this file violates some naming conventions and consequently locally
	// disables some eslint rules.

	/* eslint-disable camelcase, no-inline-comments, mozilla/no-aArgs */
	/* eslint-disable no-else-return */

	"use strict";

	// White space of any kind.  No value fields are used.  Note that
	// comments do *not* count as white space; comments separate tokens
	// but are not themselves tokens.
	const eCSSToken_Whitespace = "whitespace";     //
	// A comment.
	const eCSSToken_Comment = "comment";        // /*...*/

	// Identifier-like tokens.  mIdent is the text of the identifier.
	// The difference between ID and Hash is: if the text after the #
	// would have been a valid Ident if the # hadn't been there, the
	// scanner produces an ID token.  Otherwise it produces a Hash token.
	// (This distinction is required by css3-selectors.)
	const eCSSToken_Ident = "ident";          // word
	const eCSSToken_Function = "function";       // word(
	const eCSSToken_AtKeyword = "at";      // @word
	const eCSSToken_ID = "id";             // #word
	const eCSSToken_Hash = "hash";           // #0word

	// Numeric tokens.  mNumber is the floating-point value of the
	// number, and mHasSign indicates whether there was an explicit sign
	// (+ or -) in front of the number.  If mIntegerValid is true, the
	// number had the lexical form of an integer, and mInteger is its
	// integer value.  Lexically integer values outside the range of a
	// 32-bit signed number are clamped to the maximum values; mNumber
	// will indicate a 'truer' value in that case.  Percentage tokens
	// are always considered not to be integers, even if their numeric
	// value is integral (100% => mNumber = 1.0).  For Dimension
	// tokens, mIdent holds the text of the unit.
	const eCSSToken_Number = "number";         // 1 -5 +2e3 3.14159 7.297352e-3
	const eCSSToken_Dimension = "dimension";      // 24px 8.5in
	const eCSSToken_Percentage = "percentage";     // 85% 1280.4%

	// String-like tokens.  In all cases, mIdent holds the text
	// belonging to the string, and mSymbol holds the delimiter
	// character, which may be ', ", or zero (only for unquoted URLs).
	// Bad_String and Bad_URL tokens are emitted when the closing
	// delimiter or parenthesis was missing.
	const eCSSToken_String = "string";         // 'foo bar' "foo bar"
	const eCSSToken_Bad_String = "bad_string";     // 'foo bar
	const eCSSToken_URL = "url";            // url(foobar) url("foo bar")
	const eCSSToken_Bad_URL = "bad_url";        // url(foo

	// Any one-character symbol.  mSymbol holds the character.
	const eCSSToken_Symbol = "symbol";         // . ; { } ! *

	// Match operators.  These are single tokens rather than pairs of
	// Symbol tokens because css3-selectors forbids the presence of
	// comments between the two characters.  No value fields are used;
	// the token type indicates which operator.
	const eCSSToken_Includes = "includes";       // ~=
	const eCSSToken_Dashmatch = "dashmatch";      // |=
	const eCSSToken_Beginsmatch = "beginsmatch";    // ^=
	const eCSSToken_Endsmatch = "endsmatch";      // $=
	const eCSSToken_Containsmatch = "containsmatch";  // *=

	// Unicode-range token: currently used only in @font-face.
	// The lexical rule for this token includes several forms that are
	// semantically invalid.  Therefore, mIdent always holds the
	// complete original text of the token (so we can print it
	// accurately in diagnostics), and mIntegerValid is true iff the
	// token is semantically valid.  In that case, mInteger holds the
	// lowest value included in the range, and mInteger2 holds the
	// highest value included in the range.
	const eCSSToken_URange = "urange";         // U+007e U+01?? U+2000-206F

	// HTML comment delimiters, ignored as a unit when they appear at
	// the top level of a style sheet, for compatibility with websites
	// written for compatibility with pre-CSS browsers.  This token type
	// subsumes the css2.1 CDO and CDC tokens, which are always treated
	// the same by the parser.  mIdent holds the text of the token, for
	// diagnostics.
	const eCSSToken_HTMLComment = "htmlcomment";    // <!-- -->

	const eEOFCharacters_None = 0x0000;

	// to handle \<EOF> inside strings
	const eEOFCharacters_DropBackslash = 0x0001;

	// to handle \<EOF> outside strings
	const eEOFCharacters_ReplacementChar = 0x0002;

	// to close comments
	const eEOFCharacters_Asterisk = 0x0004;
	const eEOFCharacters_Slash = 0x0008;

	// to close double-quoted strings
	const eEOFCharacters_DoubleQuote = 0x0010;

	// to close single-quoted strings
	const eEOFCharacters_SingleQuote = 0x0020;

	// to close URLs
	const eEOFCharacters_CloseParen = 0x0040;

	// Bridge the char/string divide.
	const APOSTROPHE = "'".charCodeAt(0);
	const ASTERISK = "*".charCodeAt(0);
	const CARRIAGE_RETURN = "\r".charCodeAt(0);
	const CIRCUMFLEX_ACCENT = "^".charCodeAt(0);
	const COMMERCIAL_AT = "@".charCodeAt(0);
	const DIGIT_NINE = "9".charCodeAt(0);
	const DIGIT_ZERO = "0".charCodeAt(0);
	const DOLLAR_SIGN = "$".charCodeAt(0);
	const EQUALS_SIGN = "=".charCodeAt(0);
	const EXCLAMATION_MARK = "!".charCodeAt(0);
	const FULL_STOP = ".".charCodeAt(0);
	const GREATER_THAN_SIGN = ">".charCodeAt(0);
	const HYPHEN_MINUS = "-".charCodeAt(0);
	const LATIN_CAPITAL_LETTER_E = "E".charCodeAt(0);
	const LATIN_CAPITAL_LETTER_U = "U".charCodeAt(0);
	const LATIN_SMALL_LETTER_E = "e".charCodeAt(0);
	const LATIN_SMALL_LETTER_U = "u".charCodeAt(0);
	const LEFT_PARENTHESIS = "(".charCodeAt(0);
	const LESS_THAN_SIGN = "<".charCodeAt(0);
	const LINE_FEED = "\n".charCodeAt(0);
	const NUMBER_SIGN = "#".charCodeAt(0);
	const PERCENT_SIGN = "%".charCodeAt(0);
	const PLUS_SIGN = "+".charCodeAt(0);
	const QUESTION_MARK = "?".charCodeAt(0);
	const QUOTATION_MARK = "\"".charCodeAt(0);
	const REVERSE_SOLIDUS = "\\".charCodeAt(0);
	const RIGHT_PARENTHESIS = ")".charCodeAt(0);
	const SOLIDUS = "/".charCodeAt(0);
	const TILDE = "~".charCodeAt(0);
	const VERTICAL_LINE = "|".charCodeAt(0);

	const UCS2_REPLACEMENT_CHAR = 0xFFFD;

	const kImpliedEOFCharacters = [
	  UCS2_REPLACEMENT_CHAR,
	  ASTERISK,
	  SOLIDUS,
	  QUOTATION_MARK,
	  APOSTROPHE,
	  RIGHT_PARENTHESIS,
	  0
	];

	/**
	 * Ensure that the character is valid.  If it is valid, return it;
	 * otherwise, return the replacement character.
	 *
	 * @param {Number} c the character to check
	 * @return {Number} the character or its replacement
	 */
	function ensureValidChar(c) {
	  if (c >= 0x00110000 || (c & 0xFFF800) == 0xD800) {
	    // Out of range or a surrogate.
	    return UCS2_REPLACEMENT_CHAR;
	  }
	  return c;
	}

	/**
	 * Turn a string into an array of character codes.
	 *
	 * @param {String} str the input string
	 * @return {Array} an array of character codes, one per character in
	 *         the input string.
	 */
	function stringToCodes(str) {
	  return Array.prototype.map.call(str, (c) => c.charCodeAt(0));
	}

	const IS_HEX_DIGIT = 0x01;
	const IS_IDSTART = 0x02;
	const IS_IDCHAR = 0x04;
	const IS_URL_CHAR = 0x08;
	const IS_HSPACE = 0x10;
	const IS_VSPACE = 0x20;
	const IS_SPACE = IS_HSPACE | IS_VSPACE;
	const IS_STRING = 0x40;

	const H = IS_HSPACE;
	const V = IS_VSPACE;
	const I = IS_IDCHAR;
	const J = IS_IDSTART;
	const U = IS_URL_CHAR;
	const S = IS_STRING;
	const X = IS_HEX_DIGIT;

	const SH = S | H;
	const SU = S | U;
	const SUI = S | U | I;
	const SUIJ = S | U | I | J;
	const SUIX = S | U | I | X;
	const SUIJX = S | U | I | J | X;

	/* eslint-disable indent, no-multi-spaces, comma-spacing, spaced-comment */
	const gLexTable = [
	// 00    01    02    03    04    05    06    07
	    0,    S,    S,    S,    S,    S,    S,    S,
	// 08   TAB    LF    0B    FF    CR    0E    0F
	    S,   SH,    V,    S,    V,    V,    S,    S,
	// 10    11    12    13    14    15    16    17
	    S,    S,    S,    S,    S,    S,    S,    S,
	// 18    19    1A    1B    1C    1D    1E    1F
	    S,    S,    S,    S,    S,    S,    S,    S,
	//SPC     !     "     #     $     %     &     '
	   SH,   SU,    0,   SU,   SU,   SU,   SU,    0,
	//  (     )     *     +     ,     -     .     /
	    S,    S,   SU,   SU,   SU,  SUI,   SU,   SU,
	//  0     1     2     3     4     5     6     7
	 SUIX, SUIX, SUIX, SUIX, SUIX, SUIX, SUIX, SUIX,
	//  8     9     :     ;     <     =     >     ?
	 SUIX, SUIX,   SU,   SU,   SU,   SU,   SU,   SU,
	//  @     A     B     C     D     E     F     G
	   SU,SUIJX,SUIJX,SUIJX,SUIJX,SUIJX,SUIJX, SUIJ,
	//  H     I     J     K     L     M     N     O
	 SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ,
	//  P     Q     R     S     T     U     V     W
	 SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ,
	//  X     Y     Z     [     \     ]     ^     _
	 SUIJ, SUIJ, SUIJ,   SU,    J,   SU,   SU, SUIJ,
	//  `     a     b     c     d     e     f     g
	   SU,SUIJX,SUIJX,SUIJX,SUIJX,SUIJX,SUIJX, SUIJ,
	//  h     i     j     k     l     m     n     o
	 SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ,
	//  p     q     r     s     t     u     v     w
	 SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ, SUIJ,
	//  x     y     z     {     |     }     ~    7F
	 SUIJ, SUIJ, SUIJ,   SU,   SU,   SU,   SU,    S,
	];
	/* eslint-enable indent, no-multi-spaces, comma-spacing, spaced-comment */

	/**
	 * True if 'ch' is in character class 'cls', which should be one of
	 * the constants above or some combination of them.  All characters
	 * above U+007F are considered to be in 'cls'.  EOF is never in 'cls'.
	 */
	function IsOpenCharClass(ch, cls) {
	  return ch >= 0 && (ch >= 128 || (gLexTable[ch] & cls) != 0);
	}

	/**
	 * True if 'ch' is in character class 'cls', which should be one of
	 * the constants above or some combination of them.  No characters
	 * above U+007F are considered to be in 'cls'. EOF is never in 'cls'.
	 */
	function IsClosedCharClass(ch, cls) {
	  return ch >= 0 && ch < 128 && (gLexTable[ch] & cls) != 0;
	}

	/**
	 * True if 'ch' is CSS whitespace, i.e. any of the ASCII characters
	 * TAB, LF, FF, CR, or SPC.
	 */
	function IsWhitespace(ch) {
	  return IsClosedCharClass(ch, IS_SPACE);
	}

	/**
	 * True if 'ch' is horizontal whitespace, i.e. TAB or SPC.
	 */
	function IsHorzSpace(ch) {
	  return IsClosedCharClass(ch, IS_HSPACE);
	}

	/**
	 * True if 'ch' is vertical whitespace, i.e. LF, FF, or CR.  Vertical
	 * whitespace requires special handling when consumed, see AdvanceLine.
	 */
	function IsVertSpace(ch) {
	  return IsClosedCharClass(ch, IS_VSPACE);
	}

	/**
	 * True if 'ch' is a character that can appear in the middle of an identifier.
	 * This includes U+0000 since it is handled as U+FFFD, but for purposes of
	 * GatherText it should not be included in IsOpenCharClass.
	 */
	function IsIdentChar(ch) {
	  return IsOpenCharClass(ch, IS_IDCHAR) || ch == 0;
	}

	/**
	 * True if 'ch' is a character that by itself begins an identifier.
	 * This includes U+0000 since it is handled as U+FFFD, but for purposes of
	 * GatherText it should not be included in IsOpenCharClass.
	 * (This is a subset of IsIdentChar.)
	 */
	function IsIdentStart(ch) {
	  return IsOpenCharClass(ch, IS_IDSTART) || ch == 0;
	}

	/**
	 * True if the two-character sequence aFirstChar+aSecondChar begins an
	 * identifier.
	 */
	function StartsIdent(aFirstChar, aSecondChar) {
	  return IsIdentStart(aFirstChar) ||
	    (aFirstChar == HYPHEN_MINUS && (aSecondChar == HYPHEN_MINUS ||
	                                    IsIdentStart(aSecondChar)));
	}

	/**
	 * True if 'ch' is a decimal digit.
	 */
	function IsDigit(ch) {
	  return (ch >= DIGIT_ZERO) && (ch <= DIGIT_NINE);
	}

	/**
	 * True if 'ch' is a hexadecimal digit.
	 */
	function IsHexDigit(ch) {
	  return IsClosedCharClass(ch, IS_HEX_DIGIT);
	}

	/**
	 * Assuming that 'ch' is a decimal digit, return its numeric value.
	 */
	function DecimalDigitValue(ch) {
	  return ch - DIGIT_ZERO;
	}

	/**
	 * Assuming that 'ch' is a hexadecimal digit, return its numeric value.
	 */
	function HexDigitValue(ch) {
	  if (IsDigit(ch)) {
	    return DecimalDigitValue(ch);
	  } else {
	    // Note: c&7 just keeps the low three bits which causes
	    // upper and lower case alphabetics to both yield their
	    // "relative to 10" value for computing the hex value.
	    return (ch & 0x7) + 9;
	  }
	}

	/**
	 * If 'ch' can be the first character of a two-character match operator
	 * token, return the token type code for that token, otherwise return
	 * eCSSToken_Symbol to indicate that it can't.
	 */
	function MatchOperatorType(ch) {
	  switch (ch) {
	    case TILDE: return eCSSToken_Includes;
	    case VERTICAL_LINE: return eCSSToken_Dashmatch;
	    case CIRCUMFLEX_ACCENT: return eCSSToken_Beginsmatch;
	    case DOLLAR_SIGN: return eCSSToken_Endsmatch;
	    case ASTERISK: return eCSSToken_Containsmatch;
	    default: return eCSSToken_Symbol;
	  }
	}

	function Scanner(buffer) {
	  this.mBuffer = buffer || "";
	  this.mOffset = 0;
	  this.mCount = this.mBuffer.length;
	  this.mLineNumber = 1;
	  this.mLineOffset = 0;
	  this.mTokenLineOffset = 0;
	  this.mTokenOffset = 0;
	  this.mTokenLineNumber = 1;
	  this.mEOFCharacters = eEOFCharacters_None;
	}

	Scanner.prototype = {
	  /**
	   * @see CSSLexer.lineNumber
	   */
	  get lineNumber() {
	    return this.mTokenLineNumber - 1;
	  },

	  /**
	   * @see CSSLexer.columnNumber
	   */
	  get columnNumber() {
	    return this.mTokenOffset - this.mTokenLineOffset;
	  },

	  /**
	   * @see CSSLexer.performEOFFixup
	   */
	  performEOFFixup: function (aInputString, aPreserveBackslash) {
	    let result = aInputString;

	    let eofChars = this.mEOFCharacters;

	    if (aPreserveBackslash &&
	        (eofChars & (eEOFCharacters_DropBackslash |
	                     eEOFCharacters_ReplacementChar)) != 0) {
	      eofChars &= ~(eEOFCharacters_DropBackslash |
	                    eEOFCharacters_ReplacementChar);
	      result += "\\";
	    }

	    if ((eofChars & eEOFCharacters_DropBackslash) != 0 &&
	        result.length > 0 && result.endsWith("\\")) {
	      result = result.slice(0, -1);
	    }

	    let extra = [];
	    this.AppendImpliedEOFCharacters(eofChars, extra);
	    let asString = String.fromCharCode.apply(null, extra);

	    return result + asString;
	  },

	  /**
	   * @see CSSLexer.nextToken
	   */
	  nextToken: function () {
	    let token = {};
	    if (!this.Next(token)) {
	      return null;
	    }

	    let resultToken = {};
	    resultToken.tokenType = token.mType;
	    resultToken.startOffset = this.mTokenOffset;
	    resultToken.endOffset = this.mOffset;

	    let constructText = () => {
	      return String.fromCharCode.apply(null, token.mIdent);
	    };

	    switch (token.mType) {
	      case eCSSToken_Whitespace:
	        break;

	      case eCSSToken_Ident:
	      case eCSSToken_Function:
	      case eCSSToken_AtKeyword:
	      case eCSSToken_ID:
	      case eCSSToken_Hash:
	        resultToken.text = constructText();
	        break;

	      case eCSSToken_Dimension:
	        resultToken.text = constructText();
	        /* Fall through.  */
	      case eCSSToken_Number:
	      case eCSSToken_Percentage:
	        resultToken.number = token.mNumber;
	        resultToken.hasSign = token.mHasSign;
	        resultToken.isInteger = token.mIntegerValid;
	        break;

	      case eCSSToken_String:
	      case eCSSToken_Bad_String:
	      case eCSSToken_URL:
	      case eCSSToken_Bad_URL:
	        resultToken.text = constructText();
	        /* Don't bother emitting the delimiter, as it is readily extracted
	           from the source string when needed.  */
	        break;

	      case eCSSToken_Symbol:
	        resultToken.text = String.fromCharCode(token.mSymbol);
	        break;

	      case eCSSToken_Includes:
	      case eCSSToken_Dashmatch:
	      case eCSSToken_Beginsmatch:
	      case eCSSToken_Endsmatch:
	      case eCSSToken_Containsmatch:
	      case eCSSToken_URange:
	        break;

	      case eCSSToken_Comment:
	      case eCSSToken_HTMLComment:
	        /* The comment text is easily extracted from the source string,
	           and is rarely useful.  */
	        break;
	    }

	    return resultToken;
	  },

	  /**
	   * Return the raw UTF-16 code unit at position |this.mOffset + n| within
	   * the read buffer.  If that is beyond the end of the buffer, returns
	   * -1 to indicate end of input.
	   */
	  Peek: function (n = 0) {
	    if (this.mOffset + n >= this.mCount) {
	      return -1;
	    }
	    return this.mBuffer.charCodeAt(this.mOffset + n);
	  },

	  /**
	   * Advance |this.mOffset| over |n| code units.  Advance(0) is a no-op.
	   * If |n| is greater than the distance to end of input, will silently
	   * stop at the end.  May not be used to advance over a line boundary;
	   * AdvanceLine() must be used instead.
	   */
	  Advance: function (n = 1) {
	    if (this.mOffset + n >= this.mCount || this.mOffset + n < this.mOffset) {
	      this.mOffset = this.mCount;
	    } else {
	      this.mOffset += n;
	    }
	  },

	  /**
	   * Advance |this.mOffset| over a line boundary.
	   */
	  AdvanceLine: function () {
	    // Advance over \r\n as a unit.
	    if (this.mBuffer.charCodeAt(this.mOffset) == CARRIAGE_RETURN &&
	        this.mOffset + 1 < this.mCount &&
	        this.mBuffer.charCodeAt(this.mOffset + 1) == LINE_FEED) {
	      this.mOffset += 2;
	    } else {
	      this.mOffset += 1;
	    }
	    // 0 is a magical line number meaning that we don't know (i.e., script)
	    if (this.mLineNumber != 0) {
	      this.mLineNumber++;
	    }
	    this.mLineOffset = this.mOffset;
	  },

	  /**
	   * Skip over a sequence of whitespace characters (vertical or
	   * horizontal) starting at the current read position.
	   */
	  SkipWhitespace: function () {
	    for (;;) {
	      let ch = this.Peek();
	      if (!IsWhitespace(ch)) { // EOF counts as non-whitespace
	        break;
	      }
	      if (IsVertSpace(ch)) {
	        this.AdvanceLine();
	      } else {
	        this.Advance();
	      }
	    }
	  },

	  /**
	   * Skip over one CSS comment starting at the current read position.
	   */
	  SkipComment: function () {
	    this.Advance(2);
	    for (;;) {
	      let ch = this.Peek();
	      if (ch < 0) {
	        this.SetEOFCharacters(eEOFCharacters_Asterisk | eEOFCharacters_Slash);
	        return;
	      }
	      if (ch == ASTERISK) {
	        this.Advance();
	        ch = this.Peek();
	        if (ch < 0) {
	          this.SetEOFCharacters(eEOFCharacters_Slash);
	          return;
	        }
	        if (ch == SOLIDUS) {
	          this.Advance();
	          return;
	        }
	      } else if (IsVertSpace(ch)) {
	        this.AdvanceLine();
	      } else {
	        this.Advance();
	      }
	    }
	  },

	  /**
	   * If there is a valid escape sequence starting at the current read
	   * position, consume it, decode it, append the result to |aOutput|,
	   * and return true.  Otherwise, consume nothing, leave |aOutput|
	   * unmodified, and return false.  If |aInString| is true, accept the
	   * additional form of escape sequence allowed within string-like tokens.
	   */
	  GatherEscape: function (aOutput, aInString) {
	    let ch = this.Peek(1);
	    if (ch < 0) {
	      // If we are in a string (or a url() containing a string), we want to drop
	      // the backslash on the floor.  Otherwise, we want to treat it as a U+FFFD
	      // character.
	      this.Advance();
	      if (aInString) {
	        this.SetEOFCharacters(eEOFCharacters_DropBackslash);
	      } else {
	        aOutput.push(UCS2_REPLACEMENT_CHAR);
	        this.SetEOFCharacters(eEOFCharacters_ReplacementChar);
	      }
	      return true;
	    }
	    if (IsVertSpace(ch)) {
	      if (aInString) {
	        // In strings (and in url() containing a string), escaped
	        // newlines are completely removed, to allow splitting over
	        // multiple lines.
	        this.Advance();
	        this.AdvanceLine();
	        return true;
	      }
	      // Outside of strings, backslash followed by a newline is not an escape.
	      return false;
	    }

	    if (!IsHexDigit(ch)) {
	      // "Any character (except a hexadecimal digit, linefeed, carriage
	      // return, or form feed) can be escaped with a backslash to remove
	      // its special meaning." -- CSS2.1 section 4.1.3
	      this.Advance(2);
	      if (ch == 0) {
	        aOutput.push(UCS2_REPLACEMENT_CHAR);
	      } else {
	        aOutput.push(ch);
	      }
	      return true;
	    }

	    // "[at most six hexadecimal digits following a backslash] stand
	    // for the ISO 10646 character with that number, which must not be
	    // zero. (It is undefined in CSS 2.1 what happens if a style sheet
	    // does contain a character with Unicode codepoint zero.)"
	    //   -- CSS2.1 section 4.1.3

	    // At this point we know we have \ followed by at least one
	    // hexadecimal digit, therefore the escape sequence is valid and we
	    // can go ahead and consume the backslash.
	    this.Advance();
	    let val = 0;
	    let i = 0;
	    do {
	      val = val * 16 + HexDigitValue(ch);
	      i++;
	      this.Advance();
	      ch = this.Peek();
	    } while (i < 6 && IsHexDigit(ch));

	    // "Interpret the hex digits as a hexadecimal number. If this
	    // number is zero, or is greater than the maximum allowed
	    // codepoint, return U+FFFD REPLACEMENT CHARACTER" -- CSS Syntax
	    // Level 3
	    if (val == 0) {
	      aOutput.push(UCS2_REPLACEMENT_CHAR);
	    } else {
	      aOutput.push(ensureValidChar(val));
	    }

	    // Consume exactly one whitespace character after a
	    // hexadecimal escape sequence.
	    if (IsVertSpace(ch)) {
	      this.AdvanceLine();
	    } else if (IsHorzSpace(ch)) {
	      this.Advance();
	    }
	    return true;
	  },

	  /**
	   * Consume a run of "text" beginning with the current read position,
	   * consisting of characters in the class |aClass| (which must be a
	   * suitable argument to IsOpenCharClass) plus escape sequences.
	   * Append the text to |aText|, after decoding escape sequences.
	   *
	   * Returns true if at least one character was appended to |aText|,
	   * false otherwise.
	   */
	  GatherText: function (aClass, aText) {
	    let start = this.mOffset;
	    let inString = aClass == IS_STRING;

	    for (;;) {
	      // Consume runs of unescaped characters in one go.
	      let n = this.mOffset;
	      while (n < this.mCount && IsOpenCharClass(this.mBuffer.charCodeAt(n),
	                                                aClass)) {
	        n++;
	      }
	      if (n > this.mOffset) {
	        let substr = this.mBuffer.slice(this.mOffset, n);
	        Array.prototype.push.apply(aText, stringToCodes(substr));
	        this.mOffset = n;
	      }
	      if (n == this.mCount) {
	        break;
	      }

	      let ch = this.Peek();
	      if (ch == 0) {
	        this.Advance();
	        aText.push(UCS2_REPLACEMENT_CHAR);
	        continue;
	      }

	      if (ch != REVERSE_SOLIDUS) {
	        break;
	      }
	      if (!this.GatherEscape(aText, inString)) {
	        break;
	      }
	    }

	    return this.mOffset > start;
	  },

	  /**
	   * Scan an Ident token.  This also handles Function and URL tokens,
	   * both of which begin indistinguishably from an identifier.  It can
	   * produce a Symbol token when an apparent identifier actually led
	   * into an invalid escape sequence.
	   */
	  ScanIdent: function (aToken) {
	    if (!this.GatherText(IS_IDCHAR, aToken.mIdent)) {
	      aToken.mSymbol = this.Peek();
	      this.Advance();
	      return true;
	    }

	    if (this.Peek() != LEFT_PARENTHESIS) {
	      aToken.mType = eCSSToken_Ident;
	      return true;
	    }

	    this.Advance();
	    aToken.mType = eCSSToken_Function;

	    let asString = String.fromCharCode.apply(null, aToken.mIdent);
	    if (asString.toLowerCase() === "url") {
	      this.NextURL(aToken);
	    }
	    return true;
	  },

	  /**
	   * Scan an AtKeyword token.  Also handles production of Symbol when
	   * an '@' is not followed by an identifier.
	   */
	  ScanAtKeyword: function (aToken) {
	    // Fall back for when '@' isn't followed by an identifier.
	    aToken.mSymbol = COMMERCIAL_AT;
	    this.Advance();

	    let ch = this.Peek();
	    if (StartsIdent(ch, this.Peek(1))) {
	      if (this.GatherText(IS_IDCHAR, aToken.mIdent)) {
	        aToken.mType = eCSSToken_AtKeyword;
	      }
	    }
	    return true;
	  },

	  /**
	   * Scan a Hash token.  Handles the distinction between eCSSToken_ID
	   * and eCSSToken_Hash, and handles production of Symbol when a '#'
	   * is not followed by identifier characters.
	   */
	  ScanHash: function (aToken) {
	    // Fall back for when '#' isn't followed by identifier characters.
	    aToken.mSymbol = NUMBER_SIGN;
	    this.Advance();

	    let ch = this.Peek();
	    if (IsIdentChar(ch) || ch == REVERSE_SOLIDUS) {
	      let type =
	          StartsIdent(ch, this.Peek(1)) ? eCSSToken_ID : eCSSToken_Hash;
	      aToken.mIdent.length = 0;
	      if (this.GatherText(IS_IDCHAR, aToken.mIdent)) {
	        aToken.mType = type;
	      }
	    }

	    return true;
	  },

	  /**
	   * Scan a Number, Percentage, or Dimension token (all of which begin
	   * like a Number).  Can produce a Symbol when a '.' is not followed by
	   * digits, or when '+' or '-' are not followed by either a digit or a
	   * '.' and then a digit.  Can also produce a HTMLComment when it
	   * encounters '-->'.
	   */
	  ScanNumber: function (aToken) {
	    let c = this.Peek();

	    // Sign of the mantissa (-1 or 1).
	    let sign = c == HYPHEN_MINUS ? -1 : 1;
	    // Absolute value of the integer part of the mantissa.  This is a double so
	    // we don't run into overflow issues for consumers that only care about our
	    // floating-point value while still being able to express the full int32_t
	    // range for consumers who want integers.
	    let intPart = 0;
	    // Fractional part of the mantissa.  This is a double so that when
	    // we convert to float at the end we'll end up rounding to nearest
	    // float instead of truncating down (as we would if fracPart were
	    // a float and we just effectively lost the last several digits).
	    let fracPart = 0;
	    // Absolute value of the power of 10 that we should multiply by
	    // (only relevant for numbers in scientific notation).  Has to be
	    // a signed integer, because multiplication of signed by unsigned
	    // converts the unsigned to signed, so if we plan to actually
	    // multiply by expSign...
	    let exponent = 0;
	    // Sign of the exponent.
	    let expSign = 1;

	    aToken.mHasSign = (c == PLUS_SIGN || c == HYPHEN_MINUS);
	    if (aToken.mHasSign) {
	      this.Advance();
	      c = this.Peek();
	    }

	    let gotDot = (c == FULL_STOP);

	    if (!gotDot) {
	      // Scan the integer part of the mantissa.
	      do {
	        intPart = 10 * intPart + DecimalDigitValue(c);
	        this.Advance();
	        c = this.Peek();
	      } while (IsDigit(c));

	      gotDot = (c == FULL_STOP) && IsDigit(this.Peek(1));
	    }

	    if (gotDot) {
	      // Scan the fractional part of the mantissa.
	      this.Advance();
	      c = this.Peek();
	      // Power of ten by which we need to divide our next digit
	      let divisor = 10;
	      do {
	        fracPart += DecimalDigitValue(c) / divisor;
	        divisor *= 10;
	        this.Advance();
	        c = this.Peek();
	      } while (IsDigit(c));
	    }

	    let gotE = false;
	    if (c == LATIN_SMALL_LETTER_E || c == LATIN_CAPITAL_LETTER_E) {
	      let expSignChar = this.Peek(1);
	      let nextChar = this.Peek(2);
	      if (IsDigit(expSignChar) ||
	          ((expSignChar == HYPHEN_MINUS || expSignChar == PLUS_SIGN) &&
	           IsDigit(nextChar))) {
	        gotE = true;
	        if (expSignChar == HYPHEN_MINUS) {
	          expSign = -1;
	        }
	        this.Advance(); // consumes the E
	        if (expSignChar == HYPHEN_MINUS || expSignChar == PLUS_SIGN) {
	          this.Advance();
	          c = nextChar;
	        } else {
	          c = expSignChar;
	        }
	        do {
	          exponent = 10 * exponent + DecimalDigitValue(c);
	          this.Advance();
	          c = this.Peek();
	        } while (IsDigit(c));
	      }
	    }

	    let type = eCSSToken_Number;

	    // Set mIntegerValid for all cases (except %, below) because we need
	    // it for the "2n" in :nth-child(2n).
	    aToken.mIntegerValid = false;

	    // Time to reassemble our number.
	    // Do all the math in double precision so it's truncated only once.
	    let value = sign * (intPart + fracPart);
	    if (gotE) {
	      // Explicitly cast expSign*exponent to double to avoid issues with
	      // overloaded pow() on Windows.
	      value *= Math.pow(10.0, expSign * exponent);
	    } else if (!gotDot) {
	      // Clamp values outside of integer range.
	      if (sign > 0) {
	        aToken.mInteger = Math.min(intPart, Number.MAX_SAFE_INTEGER);
	      } else {
	        aToken.mInteger = Math.max(-intPart, Number.MIN_SAFE_INTEGER);
	      }
	      aToken.mIntegerValid = true;
	    }

	    let ident = aToken.mIdent;

	    // Check for Dimension and Percentage tokens.
	    if (c >= 0) {
	      if (StartsIdent(c, this.Peek(1))) {
	        if (this.GatherText(IS_IDCHAR, ident)) {
	          type = eCSSToken_Dimension;
	        }
	      } else if (c == PERCENT_SIGN) {
	        this.Advance();
	        type = eCSSToken_Percentage;
	        value = value / 100.0;
	        aToken.mIntegerValid = false;
	      }
	    }
	    aToken.mNumber = value;
	    aToken.mType = type;
	    return true;
	  },

	  /**
	   * Scan a string constant ('foo' or "foo").  Will always produce
	   * either a String or a Bad_String token; the latter occurs when the
	   * close quote is missing.  Always returns true (for convenience in Next()).
	   */
	  ScanString: function (aToken) {
	    let aStop = this.Peek();
	    aToken.mType = eCSSToken_String;
	    aToken.mSymbol = aStop; // Remember how it's quoted.
	    this.Advance();

	    for (;;) {
	      this.GatherText(IS_STRING, aToken.mIdent);

	      let ch = this.Peek();
	      if (ch == -1) {
	        this.AddEOFCharacters(aStop == QUOTATION_MARK ?
	                              eEOFCharacters_DoubleQuote :
	                              eEOFCharacters_SingleQuote);
	        break; // EOF ends a string token with no error.
	      }
	      if (ch == aStop) {
	        this.Advance();
	        break;
	      }
	      // Both " and ' are excluded from IS_STRING.
	      if (ch == QUOTATION_MARK || ch == APOSTROPHE) {
	        aToken.mIdent.push(ch);
	        this.Advance();
	        continue;
	      }

	      aToken.mType = eCSSToken_Bad_String;
	      break;
	    }
	    return true;
	  },

	  /**
	   * Scan a unicode-range token.  These match the regular expression
	   *
	   *     u\+[0-9a-f?]{1,6}(-[0-9a-f]{1,6})?
	   *
	   * However, some such tokens are "invalid".  There are three valid forms:
	   *
	   *     u+[0-9a-f]{x}              1 <= x <= 6
	   *     u+[0-9a-f]{x}\?{y}         1 <= x+y <= 6
	   *     u+[0-9a-f]{x}-[0-9a-f]{y}  1 <= x <= 6, 1 <= y <= 6
	   *
	   * All unicode-range tokens have their text recorded in mIdent; valid ones
	   * are also decoded into mInteger and mInteger2, and mIntegerValid is set.
	   * Note that this does not validate the numeric range, only the syntactic
	   * form.
	   */
	  ScanURange: function (aResult) {
	    let intro1 = this.Peek();
	    let intro2 = this.Peek(1);
	    let ch = this.Peek(2);

	    aResult.mIdent.push(intro1);
	    aResult.mIdent.push(intro2);
	    this.Advance(2);

	    let valid = true;
	    let haveQues = false;
	    let low = 0;
	    let high = 0;
	    let i = 0;

	    do {
	      aResult.mIdent.push(ch);
	      if (IsHexDigit(ch)) {
	        if (haveQues) {
	          valid = false; // All question marks should be at the end.
	        }
	        low = low * 16 + HexDigitValue(ch);
	        high = high * 16 + HexDigitValue(ch);
	      } else {
	        haveQues = true;
	        low = low * 16 + 0x0;
	        high = high * 16 + 0xF;
	      }

	      i++;
	      this.Advance();
	      ch = this.Peek();
	    } while (i < 6 && (IsHexDigit(ch) || ch == QUESTION_MARK));

	    if (ch == HYPHEN_MINUS && IsHexDigit(this.Peek(1))) {
	      if (haveQues) {
	        valid = false;
	      }

	      aResult.mIdent.push(ch);
	      this.Advance();
	      ch = this.Peek();
	      high = 0;
	      i = 0;
	      do {
	        aResult.mIdent.push(ch);
	        high = high * 16 + HexDigitValue(ch);

	        i++;
	        this.Advance();
	        ch = this.Peek();
	      } while (i < 6 && IsHexDigit(ch));
	    }

	    aResult.mInteger = low;
	    aResult.mInteger2 = high;
	    aResult.mIntegerValid = valid;
	    aResult.mType = eCSSToken_URange;
	    return true;
	  },

	  SetEOFCharacters: function (aEOFCharacters) {
	    this.mEOFCharacters = aEOFCharacters;
	  },

	  AddEOFCharacters: function (aEOFCharacters) {
	    this.mEOFCharacters = this.mEOFCharacters | aEOFCharacters;
	  },

	  AppendImpliedEOFCharacters: function (aEOFCharacters, aResult) {
	    // First, ignore eEOFCharacters_DropBackslash.
	    let c = aEOFCharacters >> 1;

	    // All of the remaining EOFCharacters bits represent appended characters,
	    // and the bits are in the order that they need appending.
	    for (let p of kImpliedEOFCharacters) {
	      if (c & 1) {
	        aResult.push(p);
	      }
	      c >>= 1;
	    }
	  },

	  /**
	   * Consume the part of an URL token after the initial 'url('.  Caller
	   * is assumed to have consumed 'url(' already.  Will always produce
	   * either an URL or a Bad_URL token.
	   *
	   * Exposed for use by nsCSSParser::ParseMozDocumentRule, which applies
	   * the special lexical rules for URL tokens in a nonstandard context.
	   */
	  NextURL: function (aToken) {
	    this.SkipWhitespace();

	    // aToken.mIdent may be "url" at this point; clear that out
	    aToken.mIdent.length = 0;

	    let ch = this.Peek();
	    // Do we have a string?
	    if (ch == QUOTATION_MARK || ch == APOSTROPHE) {
	      this.ScanString(aToken);
	      if (aToken.mType == eCSSToken_Bad_String) {
	        aToken.mType = eCSSToken_Bad_URL;
	        // Flag us as having been a Bad_String.
	        aToken.mInteger2 = 1;
	        this.ConsumeBadURLRemnants(aToken);
	        return;
	      }
	    } else {
	      // Otherwise, this is the start of a non-quoted url (which may be empty).
	      aToken.mSymbol = 0;
	      this.GatherText(IS_URL_CHAR, aToken.mIdent);
	    }

	    // Consume trailing whitespace and then look for a close parenthesis.
	    this.SkipWhitespace();
	    ch = this.Peek();
	    // ch can be less than zero indicating EOF
	    if (ch < 0 || ch == RIGHT_PARENTHESIS) {
	      this.Advance();
	      aToken.mType = eCSSToken_URL;
	      if (ch < 0) {
	        this.AddEOFCharacters(eEOFCharacters_CloseParen);
	      }
	    } else {
	      aToken.mType = eCSSToken_Bad_URL;
	      if (aToken.mSymbol != 0) {
	        // Flag us as having been a String, not a Bad_String.
	        aToken.mInteger2 = 0;
	      }
	      this.ConsumeBadURLRemnants(aToken);
	    }
	  },

	  ConsumeBadURLRemnants: function (aToken) {
	    aToken.mInteger = aToken.mIdent.length;
	    let ch = this.Peek();
	    do {
	      if (ch < 0) {
	        this.AddEOFCharacters(eEOFCharacters_CloseParen);
	        break;
	      }

	      if (ch == REVERSE_SOLIDUS && this.GatherEscape(aToken.mIdent, false)) {
	        // Nothing else needs to be done here for the moment; we've consumed the
	        // backslash and following escape.
	      } else {
	        // We always want to consume this character.
	        if (IsVertSpace(ch)) {
	          this.AdvanceLine();
	        } else {
	          this.Advance();
	        }
	        if (ch == 0) {
	          aToken.mIdent.push(UCS2_REPLACEMENT_CHAR);
	        } else {
	          aToken.mIdent.push(ch);
	        }
	      }

	      ch = this.Peek();
	    } while (ch != RIGHT_PARENTHESIS);
	  },

	  /**
	   * Primary scanner entry point.  Consume one token and fill in
	   * |aToken| accordingly.  Will skip over any number of comments first,
	   * and will also skip over rather than return whitespace and comment
	   * tokens, depending on the value of |aSkip|.
	   *
	   * Returns true if it successfully consumed a token, false if EOF has
	   * been reached.  Will always advance the current read position by at
	   * least one character unless called when already at EOF.
	   */
	  Next: function (aToken, aSkip) {
	    let ch;

	    // do this here so we don't have to do it in dozens of other places
	    aToken.mIdent = [];
	    aToken.mType = eCSSToken_Symbol;

	    this.mTokenOffset = this.mOffset;
	    this.mTokenLineOffset = this.mLineOffset;
	    this.mTokenLineNumber = this.mLineNumber;

	    ch = this.Peek();
	    if (IsWhitespace(ch)) {
	      this.SkipWhitespace();
	      aToken.mType = eCSSToken_Whitespace;
	      return true;
	    }
	    if (ch == SOLIDUS && // !IsSVGMode() &&
	        this.Peek(1) == ASTERISK) {
	      this.SkipComment();
	      aToken.mType = eCSSToken_Comment;
	      return true;
	    }

	    // EOF
	    if (ch < 0) {
	      return false;
	    }

	    // 'u' could be UNICODE-RANGE or an identifier-family token
	    if (ch == LATIN_SMALL_LETTER_U || ch == LATIN_CAPITAL_LETTER_U) {
	      let c2 = this.Peek(1);
	      let c3 = this.Peek(2);
	      if (c2 == PLUS_SIGN && (IsHexDigit(c3) || c3 == QUESTION_MARK)) {
	        return this.ScanURange(aToken);
	      }
	      return this.ScanIdent(aToken);
	    }

	    // identifier family
	    if (IsIdentStart(ch)) {
	      return this.ScanIdent(aToken);
	    }

	    // number family
	    if (IsDigit(ch)) {
	      return this.ScanNumber(aToken);
	    }

	    if (ch == FULL_STOP && IsDigit(this.Peek(1))) {
	      return this.ScanNumber(aToken);
	    }

	    if (ch == PLUS_SIGN) {
	      let c2 = this.Peek(1);
	      if (IsDigit(c2) || (c2 == FULL_STOP && IsDigit(this.Peek(2)))) {
	        return this.ScanNumber(aToken);
	      }
	    }

	    // HYPHEN_MINUS can start an identifier-family token, a number-family token,
	    // or an HTML-comment
	    if (ch == HYPHEN_MINUS) {
	      let c2 = this.Peek(1);
	      let c3 = this.Peek(2);
	      if (IsIdentStart(c2) || (c2 == HYPHEN_MINUS && c3 != GREATER_THAN_SIGN)) {
	        return this.ScanIdent(aToken);
	      }
	      if (IsDigit(c2) || (c2 == FULL_STOP && IsDigit(c3))) {
	        return this.ScanNumber(aToken);
	      }
	      if (c2 == HYPHEN_MINUS && c3 == GREATER_THAN_SIGN) {
	        this.Advance(3);
	        aToken.mType = eCSSToken_HTMLComment;
	        aToken.mIdent = stringToCodes("-->");
	        return true;
	      }
	    }

	    // the other HTML-comment token
	    if (ch == LESS_THAN_SIGN &&
	        this.Peek(1) == EXCLAMATION_MARK &&
	        this.Peek(2) == HYPHEN_MINUS &&
	        this.Peek(3) == HYPHEN_MINUS) {
	      this.Advance(4);
	      aToken.mType = eCSSToken_HTMLComment;
	      aToken.mIdent = stringToCodes("<!--");
	      return true;
	    }

	    // AT_KEYWORD
	    if (ch == COMMERCIAL_AT) {
	      return this.ScanAtKeyword(aToken);
	    }

	    // HASH
	    if (ch == NUMBER_SIGN) {
	      return this.ScanHash(aToken);
	    }

	    // STRING
	    if (ch == QUOTATION_MARK || ch == APOSTROPHE) {
	      return this.ScanString(aToken);
	    }

	    // Match operators: ~= |= ^= $= *=
	    let opType = MatchOperatorType(ch);
	    if (opType != eCSSToken_Symbol && this.Peek(1) == EQUALS_SIGN) {
	      aToken.mType = opType;
	      this.Advance(2);
	      return true;
	    }

	    // Otherwise, a symbol (DELIM).
	    aToken.mSymbol = ch;
	    this.Advance();
	    return true;
	  },
	};

	/**
	 * Create and return a new CSS lexer, conforming to the @see CSSLexer
	 * webidl interface.
	 *
	 * @param {String} input the CSS text to lex
	 * @return {CSSLexer} the new lexer
	 */
	function getCSSLexer(input) {
	  return new Scanner(input);
	}

	exports.getCSSLexer = getCSSLexer;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  Option,
	  RetVal,
	  generateActorSpec,
	  types
	} = __webpack_require__(17);
	__webpack_require__(176);
	__webpack_require__(145);

	// Predeclare the domstylerule actor type
	types.addActorType("domstylerule");

	/**
	 * DOM Nodes returned by the style actor will be owned by the DOM walker
	 * for the connection.
	  */
	types.addLifetime("walker", "walker");

	/**
	 * When asking for the styles applied to a node, we return a list of
	 * appliedstyle json objects that lists the rules that apply to the node
	 * and which element they were inherited from (if any).
	 *
	 * Note appliedstyle only sends the list of actorIDs and is not a valid return
	 * value on its own. appliedstyle should be returned with the actual list of
	 * StyleRuleActor and StyleSheetActor. See appliedStylesReturn.
	 */
	types.addDictType("appliedstyle", {
	  rule: "domstylerule#actorid",
	  inherited: "nullable:domnode#actorid",
	  keyframes: "nullable:domstylerule#actorid"
	});

	types.addDictType("matchedselector", {
	  rule: "domstylerule#actorid",
	  selector: "string",
	  value: "string",
	  status: "number"
	});

	types.addDictType("appliedStylesReturn", {
	  entries: "array:appliedstyle",
	  rules: "array:domstylerule",
	  sheets: "array:stylesheet"
	});

	types.addDictType("modifiedStylesReturn", {
	  isMatching: RetVal("boolean"),
	  ruleProps: RetVal("nullable:appliedStylesReturn")
	});

	types.addDictType("fontpreview", {
	  data: "nullable:longstring",
	  size: "json"
	});

	types.addDictType("fontface", {
	  name: "string",
	  CSSFamilyName: "string",
	  rule: "nullable:domstylerule",
	  srcIndex: "number",
	  URI: "string",
	  format: "string",
	  preview: "nullable:fontpreview",
	  localName: "string",
	  metadata: "string"
	});

	const pageStyleSpec = generateActorSpec({
	  typeName: "pagestyle",

	  events: {
	    "stylesheet-updated": {
	      type: "styleSheetUpdated",
	      styleSheet: Arg(0, "stylesheet")
	    }
	  },

	  methods: {
	    getComputed: {
	      request: {
	        node: Arg(0, "domnode"),
	        markMatched: Option(1, "boolean"),
	        onlyMatched: Option(1, "boolean"),
	        filter: Option(1, "string"),
	      },
	      response: {
	        computed: RetVal("json")
	      }
	    },
	    getAllUsedFontFaces: {
	      request: {
	        includePreviews: Option(0, "boolean"),
	        previewText: Option(0, "string"),
	        previewFontSize: Option(0, "string"),
	        previewFillStyle: Option(0, "string")
	      },
	      response: {
	        fontFaces: RetVal("array:fontface")
	      }
	    },
	    getUsedFontFaces: {
	      request: {
	        node: Arg(0, "domnode"),
	        includePreviews: Option(1, "boolean"),
	        previewText: Option(1, "string"),
	        previewFontSize: Option(1, "string"),
	        previewFillStyle: Option(1, "string")
	      },
	      response: {
	        fontFaces: RetVal("array:fontface")
	      }
	    },
	    getMatchedSelectors: {
	      request: {
	        node: Arg(0, "domnode"),
	        property: Arg(1, "string"),
	        filter: Option(2, "string")
	      },
	      response: RetVal(types.addDictType("matchedselectorresponse", {
	        rules: "array:domstylerule",
	        sheets: "array:stylesheet",
	        matched: "array:matchedselector"
	      }))
	    },
	    getApplied: {
	      request: {
	        node: Arg(0, "domnode"),
	        inherited: Option(1, "boolean"),
	        matchedSelectors: Option(1, "boolean"),
	        filter: Option(1, "string")
	      },
	      response: RetVal("appliedStylesReturn")
	    },
	    isPositionEditable: {
	      request: { node: Arg(0, "domnode")},
	      response: { value: RetVal("boolean") }
	    },
	    getLayout: {
	      request: {
	        node: Arg(0, "domnode"),
	        autoMargins: Option(1, "boolean")
	      },
	      response: RetVal("json")
	    },
	    addNewRule: {
	      request: {
	        node: Arg(0, "domnode"),
	        pseudoClasses: Arg(1, "nullable:array:string"),
	        editAuthored: Arg(2, "boolean")
	      },
	      response: RetVal("appliedStylesReturn")
	    }
	  }
	});

	exports.pageStyleSpec = pageStyleSpec;

	const styleRuleSpec = generateActorSpec({
	  typeName: "domstylerule",

	  events: {
	    "location-changed": {
	      type: "locationChanged",
	      line: Arg(0, "number"),
	      column: Arg(1, "number")
	    },
	  },

	  methods: {
	    setRuleText: {
	      request: { modification: Arg(0, "string") },
	      response: { rule: RetVal("domstylerule") }
	    },
	    modifyProperties: {
	      request: { modifications: Arg(0, "array:json") },
	      response: { rule: RetVal("domstylerule") }
	    },
	    modifySelector: {
	      request: { selector: Arg(0, "string") },
	      response: { isModified: RetVal("boolean") },
	    },
	    modifySelector2: {
	      request: {
	        node: Arg(0, "domnode"),
	        value: Arg(1, "string"),
	        editAuthored: Arg(2, "boolean")
	      },
	      response: RetVal("modifiedStylesReturn")
	    }
	  }
	});

	exports.styleRuleSpec = styleRuleSpec;

	// The PageStyle actor flattens the DOM CSS objects a little bit, merging
	// Rules and their Styles into one actor.  For elements (which have a style
	// but no associated rule) we fake a rule with the following style id.
	const ELEMENT_STYLE = 100;
	exports.ELEMENT_STYLE = ELEMENT_STYLE;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {
	  Arg,
	  RetVal,
	  generateActorSpec,
	  types
	} = __webpack_require__(17);

	types.addDictType("imageData", {
	  // The image data
	  data: "nullable:longstring",
	  // The original image dimensions
	  size: "json"
	});

	const nodeSpec = generateActorSpec({
	  typeName: "domnode",

	  methods: {
	    getNodeValue: {
	      request: {},
	      response: {
	        value: RetVal("longstring")
	      }
	    },
	    setNodeValue: {
	      request: { value: Arg(0) },
	      response: {}
	    },
	    getUniqueSelector: {
	      request: {},
	      response: {
	        value: RetVal("string")
	      }
	    },
	    scrollIntoView: {
	      request: {},
	      response: {}
	    },
	    getImageData: {
	      request: {maxDim: Arg(0, "nullable:number")},
	      response: RetVal("imageData")
	    },
	    getEventListenerInfo: {
	      request: {},
	      response: {
	        events: RetVal("json")
	      }
	    },
	    modifyAttributes: {
	      request: {
	        modifications: Arg(0, "array:json")
	      },
	      response: {}
	    },
	    getFontFamilyDataURL: {
	      request: {font: Arg(0, "string"), fillStyle: Arg(1, "nullable:string")},
	      response: RetVal("imageData")
	    }
	  }
	});

	exports.nodeSpec = nodeSpec;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {Cc, Ci} = __webpack_require__(9);
	const {angleUtils} = __webpack_require__(178);
	const {colorUtils} = __webpack_require__(179);
	const {getCSSLexer} = __webpack_require__(174);
	const EventEmitter = __webpack_require__(6);
	const {
	  ANGLE_TAKING_FUNCTIONS,
	  BEZIER_KEYWORDS,
	  COLOR_TAKING_FUNCTIONS,
	  CSS_TYPES
	} = __webpack_require__(29);

	const HTML_NS = "http://www.w3.org/1999/xhtml";

	({ lazyRequireGetter: () => {} }).lazyGetter(this, "DOMUtils", function () {
	  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	});

	/**
	 * This module is used to process text for output by developer tools. This means
	 * linking JS files with the debugger, CSS files with the style editor, JS
	 * functions with the debugger, placing color swatches next to colors and
	 * adding doorhanger previews where possible (images, angles, lengths,
	 * border radius, cubic-bezier etc.).
	 *
	 * Usage:
	 *   const {OutputParser} = require("devtools/client/shared/output-parser");
	 *
	 *   let parser = new OutputParser(document, supportsType);
	 *
	 *   parser.parseCssProperty("color", "red"); // Returns document fragment.
	 *
	 * @param {Document} document Used to create DOM nodes.
	 * @param {Function} supportsTypes A function that returns a boolean when asked if a css
	 * property name supports a given css type.
	 * The function is executed like supportsType("color", CSS_TYPES.COLOR) where CSS_TYPES is
	 * defined in devtools/shared/css-properties-db.js
	 */
	function OutputParser(document, supportsType) {
	  this.parsed = [];
	  this.doc = document;
	  this.supportsType = supportsType;
	  this.colorSwatches = new WeakMap();
	  this.angleSwatches = new WeakMap();
	  this._onColorSwatchMouseDown = this._onColorSwatchMouseDown.bind(this);
	  this._onAngleSwatchMouseDown = this._onAngleSwatchMouseDown.bind(this);
	}

	exports.OutputParser = OutputParser;

	OutputParser.prototype = {
	  /**
	   * Parse a CSS property value given a property name.
	   *
	   * @param  {String} name
	   *         CSS Property Name
	   * @param  {String} value
	   *         CSS Property value
	   * @param  {Object} [options]
	   *         Options object. For valid options and default values see
	   *         _mergeOptions().
	   * @return {DocumentFragment}
	   *         A document fragment containing color swatches etc.
	   */
	  parseCssProperty: function (name, value, options = {}) {
	    options = this._mergeOptions(options);

	    options.expectCubicBezier = this.supportsType(name, CSS_TYPES.TIMING_FUNCTION);
	    options.expectFilter = name === "filter";
	    options.supportsColor = this.supportsType(name, CSS_TYPES.COLOR) ||
	                            this.supportsType(name, CSS_TYPES.GRADIENT);

	    // The filter property is special in that we want to show the
	    // swatch even if the value is invalid, because this way the user
	    // can easily use the editor to fix it.
	    if (options.expectFilter || this._cssPropertySupportsValue(name, value)) {
	      return this._parse(value, options);
	    }
	    this._appendTextNode(value);

	    return this._toDOM();
	  },

	  /**
	   * Given an initial FUNCTION token, read tokens from |tokenStream|
	   * and collect all the (non-comment) text.  Return the collected
	   * text.  The function token and the close paren are included in the
	   * result.
	   *
	   * @param  {CSSToken} initialToken
	   *         The FUNCTION token.
	   * @param  {String} text
	   *         The original CSS text.
	   * @param  {CSSLexer} tokenStream
	   *         The token stream from which to read.
	   * @return {String}
	   *         The text of body of the function call.
	   */
	  _collectFunctionText: function (initialToken, text, tokenStream) {
	    let result = text.substring(initialToken.startOffset,
	                                initialToken.endOffset);
	    let depth = 1;
	    while (depth > 0) {
	      let token = tokenStream.nextToken();
	      if (!token) {
	        break;
	      }
	      if (token.tokenType === "comment") {
	        continue;
	      }
	      result += text.substring(token.startOffset, token.endOffset);
	      if (token.tokenType === "symbol") {
	        if (token.text === "(") {
	          ++depth;
	        } else if (token.text === ")") {
	          --depth;
	        }
	      } else if (token.tokenType === "function") {
	        ++depth;
	      }
	    }
	    return result;
	  },

	  /**
	   * Parse a string.
	   *
	   * @param  {String} text
	   *         Text to parse.
	   * @param  {Object} [options]
	   *         Options object. For valid options and default values see
	   *         _mergeOptions().
	   * @return {DocumentFragment}
	   *         A document fragment.
	   */
	  _parse: function (text, options = {}) {
	    text = text.trim();
	    this.parsed.length = 0;

	    let tokenStream = getCSSLexer(text);
	    let parenDepth = 0;
	    let outerMostFunctionTakesColor = false;

	    let colorOK = function () {
	      return options.supportsColor ||
	        (options.expectFilter && parenDepth === 1 &&
	         outerMostFunctionTakesColor);
	    };

	    let angleOK = function (angle) {
	      return (new angleUtils.CssAngle(angle)).valid;
	    };

	    while (true) {
	      let token = tokenStream.nextToken();
	      if (!token) {
	        break;
	      }
	      if (token.tokenType === "comment") {
	        continue;
	      }

	      switch (token.tokenType) {
	        case "function": {
	          if (COLOR_TAKING_FUNCTIONS.includes(token.text) ||
	              ANGLE_TAKING_FUNCTIONS.includes(token.text)) {
	            // The function can accept a color or an angle argument, and we know
	            // it isn't special in some other way. So, we let it
	            // through to the ordinary parsing loop so that the value
	            // can be handled in a single place.
	            this._appendTextNode(text.substring(token.startOffset,
	                                                token.endOffset));
	            if (parenDepth === 0) {
	              outerMostFunctionTakesColor = COLOR_TAKING_FUNCTIONS.includes(
	                token.text);
	            }
	            ++parenDepth;
	          } else {
	            let functionText = this._collectFunctionText(token, text,
	                                                         tokenStream);

	            if (options.expectCubicBezier && token.text === "cubic-bezier") {
	              this._appendCubicBezier(functionText, options);
	            } else if (colorOK() && colorUtils.isValidCSSColor(functionText)) {
	              this._appendColor(functionText, options);
	            } else {
	              this._appendTextNode(functionText);
	            }
	          }
	          break;
	        }

	        case "ident":
	          if (options.expectCubicBezier &&
	              BEZIER_KEYWORDS.indexOf(token.text) >= 0) {
	            this._appendCubicBezier(token.text, options);
	          } else if (colorOK() && colorUtils.isValidCSSColor(token.text)) {
	            this._appendColor(token.text, options);
	          } else if (angleOK(token.text)) {
	            this._appendAngle(token.text, options);
	          } else {
	            this._appendTextNode(text.substring(token.startOffset,
	                                                token.endOffset));
	          }
	          break;

	        case "id":
	        case "hash": {
	          let original = text.substring(token.startOffset, token.endOffset);
	          if (colorOK() && colorUtils.isValidCSSColor(original)) {
	            this._appendColor(original, options);
	          } else {
	            this._appendTextNode(original);
	          }
	          break;
	        }
	        case "dimension":
	          let value = text.substring(token.startOffset, token.endOffset);
	          if (angleOK(value)) {
	            this._appendAngle(value, options);
	          } else {
	            this._appendTextNode(value);
	          }
	          break;
	        case "url":
	        case "bad_url":
	          this._appendURL(text.substring(token.startOffset, token.endOffset),
	                          token.text, options);
	          break;

	        case "symbol":
	          if (token.text === "(") {
	            ++parenDepth;
	          } else if (token.text === ")") {
	            --parenDepth;
	            if (parenDepth === 0) {
	              outerMostFunctionTakesColor = false;
	            }
	          }
	          // falls through
	        default:
	          this._appendTextNode(
	            text.substring(token.startOffset, token.endOffset));
	          break;
	      }
	    }

	    let result = this._toDOM();

	    if (options.expectFilter && !options.filterSwatch) {
	      result = this._wrapFilter(text, options, result);
	    }

	    return result;
	  },

	  /**
	   * Append a cubic-bezier timing function value to the output
	   *
	   * @param {String} bezier
	   *        The cubic-bezier timing function
	   * @param {Object} options
	   *        Options object. For valid options and default values see
	   *        _mergeOptions()
	   */
	  _appendCubicBezier: function (bezier, options) {
	    let container = this._createNode("span", {
	      "data-bezier": bezier
	    });

	    if (options.bezierSwatchClass) {
	      let swatch = this._createNode("span", {
	        class: options.bezierSwatchClass
	      });
	      container.appendChild(swatch);
	    }

	    let value = this._createNode("span", {
	      class: options.bezierClass
	    }, bezier);

	    container.appendChild(value);
	    this.parsed.push(container);
	  },

	  /**
	   * Append a angle value to the output
	   *
	   * @param {String} angle
	   *        angle to append
	   * @param {Object} options
	   *        Options object. For valid options and default values see
	   *        _mergeOptions()
	   */
	  _appendAngle: function (angle, options) {
	    let angleObj = new angleUtils.CssAngle(angle);
	    let container = this._createNode("span", {
	      "data-angle": angle
	    });

	    if (options.angleSwatchClass) {
	      let swatch = this._createNode("span", {
	        class: options.angleSwatchClass
	      });
	      this.angleSwatches.set(swatch, angleObj);
	      swatch.addEventListener("mousedown", this._onAngleSwatchMouseDown, false);

	      // Add click listener to stop event propagation when shift key is pressed
	      // in order to prevent the value input to be focused.
	      // Bug 711942 will add a tooltip to edit angle values and we should
	      // be able to move this listener to Tooltip.js when it'll be implemented.
	      swatch.addEventListener("click", function (event) {
	        if (event.shiftKey) {
	          event.stopPropagation();
	        }
	      }, false);
	      EventEmitter.decorate(swatch);
	      container.appendChild(swatch);
	    }

	    let value = this._createNode("span", {
	      class: options.angleClass
	    }, angle);

	    container.appendChild(value);
	    this.parsed.push(container);
	  },

	  /**
	   * Check if a CSS property supports a specific value.
	   *
	   * @param  {String} name
	   *         CSS Property name to check
	   * @param  {String} value
	   *         CSS Property value to check
	   */
	  _cssPropertySupportsValue: function (name, value) {
	    return DOMUtils.cssPropertyIsValid(name, value);
	  },

	  /**
	   * Tests if a given colorObject output by CssColor is valid for parsing.
	   * Valid means it's really a color, not any of the CssColor SPECIAL_VALUES
	   * except transparent
	   */
	  _isValidColor: function (colorObj) {
	    return colorObj.valid &&
	      (!colorObj.specialValue || colorObj.specialValue === "transparent");
	  },

	  /**
	   * Append a color to the output.
	   *
	   * @param  {String} color
	   *         Color to append
	   * @param  {Object} [options]
	   *         Options object. For valid options and default values see
	   *         _mergeOptions().
	   */
	  _appendColor: function (color, options = {}) {
	    let colorObj = new colorUtils.CssColor(color);

	    if (this._isValidColor(colorObj)) {
	      let container = this._createNode("span", {
	        "data-color": color
	      });

	      if (options.colorSwatchClass) {
	        let swatch = this._createNode("span", {
	          class: options.colorSwatchClass,
	          style: "background-color:" + color
	        });
	        this.colorSwatches.set(swatch, colorObj);
	        swatch.addEventListener("mousedown", this._onColorSwatchMouseDown,
	                                false);
	        EventEmitter.decorate(swatch);
	        container.appendChild(swatch);
	      }

	      if (options.defaultColorType) {
	        color = colorObj.toString();
	        container.dataset.color = color;
	      }

	      let value = this._createNode("span", {
	        class: options.colorClass
	      }, color);

	      container.appendChild(value);
	      this.parsed.push(container);
	    } else {
	      this._appendTextNode(color);
	    }
	  },

	  /**
	   * Wrap some existing nodes in a filter editor.
	   *
	   * @param {String} filters
	   *        The full text of the "filter" property.
	   * @param {object} options
	   *        The options object passed to parseCssProperty().
	   * @param {object} nodes
	   *        Nodes created by _toDOM().
	   *
	   * @returns {object}
	   *        A new node that supplies a filter swatch and that wraps |nodes|.
	   */
	  _wrapFilter: function (filters, options, nodes) {
	    let container = this._createNode("span", {
	      "data-filters": filters
	    });

	    if (options.filterSwatchClass) {
	      let swatch = this._createNode("span", {
	        class: options.filterSwatchClass
	      });
	      container.appendChild(swatch);
	    }

	    let value = this._createNode("span", {
	      class: options.filterClass
	    });
	    value.appendChild(nodes);
	    container.appendChild(value);

	    return container;
	  },

	  _onColorSwatchMouseDown: function (event) {
	    if (!event.shiftKey) {
	      return;
	    }

	    // Prevent click event to be fired to not show the tooltip
	    event.stopPropagation();

	    let swatch = event.target;
	    let color = this.colorSwatches.get(swatch);
	    let val = color.nextColorUnit();

	    swatch.nextElementSibling.textContent = val;
	    swatch.emit("unit-change", val);
	  },

	  _onAngleSwatchMouseDown: function (event) {
	    if (!event.shiftKey) {
	      return;
	    }

	    event.stopPropagation();

	    let swatch = event.target;
	    let angle = this.angleSwatches.get(swatch);
	    let val = angle.nextAngleUnit();

	    swatch.nextElementSibling.textContent = val;
	    swatch.emit("unit-change", val);
	  },

	  /**
	   * A helper function that sanitizes a possibly-unterminated URL.
	   */
	  _sanitizeURL: function (url) {
	    // Re-lex the URL and add any needed termination characters.
	    let urlTokenizer = getCSSLexer(url);
	    // Just read until EOF; there will only be a single token.
	    while (urlTokenizer.nextToken()) {
	      // Nothing.
	    }

	    return urlTokenizer.performEOFFixup(url, true);
	  },

	  /**
	   * Append a URL to the output.
	   *
	   * @param  {String} match
	   *         Complete match that may include "url(xxx)"
	   * @param  {String} url
	   *         Actual URL
	   * @param  {Object} [options]
	   *         Options object. For valid options and default values see
	   *         _mergeOptions().
	   */
	  _appendURL: function (match, url, options) {
	    if (options.urlClass) {
	      // Sanitize the URL.  Note that if we modify the URL, we just
	      // leave the termination characters.  This isn't strictly
	      // "as-authored", but it makes a bit more sense.
	      match = this._sanitizeURL(match);
	      // This regexp matches a URL token.  It puts the "url(", any
	      // leading whitespace, and any opening quote into |leader|; the
	      // URL text itself into |body|, and any trailing quote, trailing
	      // whitespace, and the ")" into |trailer|.  We considered adding
	      // functionality for this to CSSLexer, in some way, but this
	      // seemed simpler on the whole.
	      let [, leader, , body, trailer] =
	        /^(url\([ \t\r\n\f]*(["']?))(.*?)(\2[ \t\r\n\f]*\))$/i.exec(match);

	      this._appendTextNode(leader);

	      let href = url;
	      if (options.baseURI) {
	        try {
	          href = new URL(url, options.baseURI).href;
	        } catch (e) {
	          // Ignore.
	        }
	      }

	      this._appendNode("a", {
	        target: "_blank",
	        class: options.urlClass,
	        href: href
	      }, body);

	      this._appendTextNode(trailer);
	    } else {
	      this._appendTextNode(match);
	    }
	  },

	  /**
	   * Create a node.
	   *
	   * @param  {String} tagName
	   *         Tag type e.g. "div"
	   * @param  {Object} attributes
	   *         e.g. {class: "someClass", style: "cursor:pointer"};
	   * @param  {String} [value]
	   *         If a value is included it will be appended as a text node inside
	   *         the tag. This is useful e.g. for span tags.
	   * @return {Node} Newly created Node.
	   */
	  _createNode: function (tagName, attributes, value = "") {
	    let node = this.doc.createElementNS(HTML_NS, tagName);
	    let attrs = Object.getOwnPropertyNames(attributes);

	    for (let attr of attrs) {
	      if (attributes[attr]) {
	        node.setAttribute(attr, attributes[attr]);
	      }
	    }

	    if (value) {
	      let textNode = this.doc.createTextNode(value);
	      node.appendChild(textNode);
	    }

	    return node;
	  },

	  /**
	   * Append a node to the output.
	   *
	   * @param  {String} tagName
	   *         Tag type e.g. "div"
	   * @param  {Object} attributes
	   *         e.g. {class: "someClass", style: "cursor:pointer"};
	   * @param  {String} [value]
	   *         If a value is included it will be appended as a text node inside
	   *         the tag. This is useful e.g. for span tags.
	   */
	  _appendNode: function (tagName, attributes, value = "") {
	    let node = this._createNode(tagName, attributes, value);
	    this.parsed.push(node);
	  },

	  /**
	   * Append a text node to the output. If the previously output item was a text
	   * node then we append the text to that node.
	   *
	   * @param  {String} text
	   *         Text to append
	   */
	  _appendTextNode: function (text) {
	    let lastItem = this.parsed[this.parsed.length - 1];
	    if (typeof lastItem === "string") {
	      this.parsed[this.parsed.length - 1] = lastItem + text;
	    } else {
	      this.parsed.push(text);
	    }
	  },

	  /**
	   * Take all output and append it into a single DocumentFragment.
	   *
	   * @return {DocumentFragment}
	   *         Document Fragment
	   */
	  _toDOM: function () {
	    let frag = this.doc.createDocumentFragment();

	    for (let item of this.parsed) {
	      if (typeof item === "string") {
	        frag.appendChild(this.doc.createTextNode(item));
	      } else {
	        frag.appendChild(item);
	      }
	    }

	    this.parsed.length = 0;
	    return frag;
	  },

	  /**
	   * Merges options objects. Default values are set here.
	   *
	   * @param  {Object} overrides
	   *         The option values to override e.g. _mergeOptions({colors: false})
	   *
	   *         Valid options are:
	   *           - defaultColorType: true // Convert colors to the default type
	   *                                    // selected in the options panel.
	   *           - colorSwatchClass: ""   // The class to use for color swatches.
	   *           - colorClass: ""         // The class to use for the color value
	   *                                    // that follows the swatch.
	   *           - bezierSwatchClass: ""  // The class to use for bezier swatches.
	   *           - bezierClass: ""        // The class to use for the bezier value
	   *                                    // that follows the swatch.
	   *           - angleSwatchClass: ""   // The class to use for angle swatches.
	   *           - angleClass: ""         // The class to use for the angle value
	   *                                    // that follows the swatch.
	   *           - supportsColor: false   // Does the CSS property support colors?
	   *           - urlClass: ""           // The class to be used for url() links.
	   *           - baseURI: undefined     // A string used to resolve
	   *                                    // relative links.
	   *           - filterSwatch: false    // A special case for parsing a
	   *                                    // "filter" property, causing the
	   *                                    // parser to skip the call to
	   *                                    // _wrapFilter.  Used only for
	   *                                    // previewing with the filter swatch.
	   * @return {Object}
	   *         Overridden options object
	   */
	  _mergeOptions: function (overrides) {
	    let defaults = {
	      defaultColorType: true,
	      colorSwatchClass: "",
	      colorClass: "",
	      bezierSwatchClass: "",
	      bezierClass: "",
	      angleSwatchClass: "",
	      angleClass: "",
	      supportsColor: false,
	      urlClass: "",
	      baseURI: undefined,
	      filterSwatch: false
	    };

	    for (let item in overrides) {
	      defaults[item] = overrides[item];
	    }
	    return defaults;
	  }
	};


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const SPECIALVALUES = new Set([
	  "initial",
	  "inherit",
	  "unset"
	]);

	const {getCSSLexer} = __webpack_require__(174);

	/**
	 * This module is used to convert between various angle units.
	 *
	 * Usage:
	 *   let {angleUtils} = require("devtools/client/shared/css-angle");
	 *   let angle = new angleUtils.CssAngle("180deg");
	 *
	 *   angle.authored === "180deg"
	 *   angle.valid === true
	 *   angle.rad === "3,14rad"
	 *   angle.grad === "200grad"
	 *   angle.turn === "0.5turn"
	 *
	 *   angle.toString() === "180deg"; // Outputs the angle value and its unit
	 *   // Angle objects can be reused
	 *   angle.newAngle("-1TURN") === "-1TURN"; // true
	 */

	function CssAngle(angleValue) {
	  this.newAngle(angleValue);
	}

	module.exports.angleUtils = {
	  CssAngle: CssAngle,
	  classifyAngle: classifyAngle
	};

	CssAngle.ANGLEUNIT = {
	  "deg": "deg",
	  "rad": "rad",
	  "grad": "grad",
	  "turn": "turn"
	};

	CssAngle.prototype = {
	  _angleUnit: null,
	  _angleUnitUppercase: false,

	  // The value as-authored.
	  authored: null,
	  // A lower-cased copy of |authored|.
	  lowerCased: null,

	  get angleUnit() {
	    if (this._angleUnit === null) {
	      this._angleUnit = classifyAngle(this.authored);
	    }
	    return this._angleUnit;
	  },

	  set angleUnit(unit) {
	    this._angleUnit = unit;
	  },

	  get valid() {
	    let token = getCSSLexer(this.authored).nextToken();
	    if (!token) {
	      return false;
	    }
	    return (token.tokenType === "dimension"
	      && token.text.toLowerCase() in CssAngle.ANGLEUNIT);
	  },

	  get specialValue() {
	    return SPECIALVALUES.has(this.lowerCased) ? this.authored : null;
	  },

	  get deg() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let angleUnit = classifyAngle(this.authored);
	    if (angleUnit === CssAngle.ANGLEUNIT.deg) {
	      // The angle is valid and is in degree.
	      return this.authored;
	    }

	    let degValue;
	    if (angleUnit === CssAngle.ANGLEUNIT.rad) {
	      // The angle is valid and is in radian.
	      degValue = this.authoredAngleValue / (Math.PI / 180);
	    }

	    if (angleUnit === CssAngle.ANGLEUNIT.grad) {
	      // The angle is valid and is in gradian.
	      degValue = this.authoredAngleValue * 0.9;
	    }

	    if (angleUnit === CssAngle.ANGLEUNIT.turn) {
	      // The angle is valid and is in turn.
	      degValue = this.authoredAngleValue * 360;
	    }

	    let unitStr = CssAngle.ANGLEUNIT.deg;
	    if (this._angleUnitUppercase === true) {
	      unitStr = unitStr.toUpperCase();
	    }
	    return `${Math.round(degValue * 100) / 100}${unitStr}`;
	  },

	  get rad() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let unit = classifyAngle(this.authored);
	    if (unit === CssAngle.ANGLEUNIT.rad) {
	      // The angle is valid and is in radian.
	      return this.authored;
	    }

	    let radValue;
	    if (unit === CssAngle.ANGLEUNIT.deg) {
	      // The angle is valid and is in degree.
	      radValue = this.authoredAngleValue * (Math.PI / 180);
	    }

	    if (unit === CssAngle.ANGLEUNIT.grad) {
	      // The angle is valid and is in gradian.
	      radValue = this.authoredAngleValue * 0.9 * (Math.PI / 180);
	    }

	    if (unit === CssAngle.ANGLEUNIT.turn) {
	      // The angle is valid and is in turn.
	      radValue = this.authoredAngleValue * 360 * (Math.PI / 180);
	    }

	    let unitStr = CssAngle.ANGLEUNIT.rad;
	    if (this._angleUnitUppercase === true) {
	      unitStr = unitStr.toUpperCase();
	    }
	    return `${Math.round(radValue * 10000) / 10000}${unitStr}`;
	  },

	  get grad() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let unit = classifyAngle(this.authored);
	    if (unit === CssAngle.ANGLEUNIT.grad) {
	      // The angle is valid and is in gradian
	      return this.authored;
	    }

	    let gradValue;
	    if (unit === CssAngle.ANGLEUNIT.deg) {
	      // The angle is valid and is in degree
	      gradValue = this.authoredAngleValue / 0.9;
	    }

	    if (unit === CssAngle.ANGLEUNIT.rad) {
	      // The angle is valid and is in radian
	      gradValue = this.authoredAngleValue / 0.9 / (Math.PI / 180);
	    }

	    if (unit === CssAngle.ANGLEUNIT.turn) {
	      // The angle is valid and is in turn
	      gradValue = this.authoredAngleValue * 400;
	    }

	    let unitStr = CssAngle.ANGLEUNIT.grad;
	    if (this._angleUnitUppercase === true) {
	      unitStr = unitStr.toUpperCase();
	    }
	    return `${Math.round(gradValue * 100) / 100}${unitStr}`;
	  },

	  get turn() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let unit = classifyAngle(this.authored);
	    if (unit === CssAngle.ANGLEUNIT.turn) {
	      // The angle is valid and is in turn
	      return this.authored;
	    }

	    let turnValue;
	    if (unit === CssAngle.ANGLEUNIT.deg) {
	      // The angle is valid and is in degree
	      turnValue = this.authoredAngleValue / 360;
	    }

	    if (unit === CssAngle.ANGLEUNIT.rad) {
	      // The angle is valid and is in radian
	      turnValue = (this.authoredAngleValue / (Math.PI / 180)) / 360;
	    }

	    if (unit === CssAngle.ANGLEUNIT.grad) {
	      // The angle is valid and is in gradian
	      turnValue = this.authoredAngleValue / 400;
	    }

	    let unitStr = CssAngle.ANGLEUNIT.turn;
	    if (this._angleUnitUppercase === true) {
	      unitStr = unitStr.toUpperCase();
	    }
	    return `${Math.round(turnValue * 100) / 100}${unitStr}`;
	  },

	  /**
	   * Check whether the angle value is in the special list e.g.
	   * inherit or invalid.
	   *
	   * @return {String|Boolean}
	   *         - If the current angle is a special value e.g. "inherit" then
	   *           return the angle.
	   *         - If the angle is invalid return an empty string.
	   *         - If the angle is a regular angle e.g. 90deg so we return false
	   *           to indicate that the angle is neither invalid nor special.
	   */
	  _getInvalidOrSpecialValue: function () {
	    if (this.specialValue) {
	      return this.specialValue;
	    }
	    if (!this.valid) {
	      return "";
	    }
	    return false;
	  },

	  /**
	   * Change angle
	   *
	   * @param  {String} angle
	   *         Any valid angle value + unit string
	   */
	  newAngle: function (angle) {
	    // Store a lower-cased version of the angle to help with format
	    // testing.  The original text is kept as well so it can be
	    // returned when needed.
	    this.lowerCased = angle.toLowerCase();
	    this._angleUnitUppercase = (angle === angle.toUpperCase());
	    this.authored = angle;

	    let reg = new RegExp(
	      `(${Object.keys(CssAngle.ANGLEUNIT).join("|")})$`, "i");
	    let unitStartIdx = angle.search(reg);
	    this.authoredAngleValue = angle.substring(0, unitStartIdx);
	    this.authoredAngleUnit = angle.substring(unitStartIdx, angle.length);

	    return this;
	  },

	  nextAngleUnit: function () {
	    // Get a reordered array from the formats object
	    // to have the current format at the front so we can cycle through.
	    let formats = Object.keys(CssAngle.ANGLEUNIT);
	    let putOnEnd = formats.splice(0, formats.indexOf(this.angleUnit));
	    formats = formats.concat(putOnEnd);
	    let currentDisplayedValue = this[formats[0]];

	    for (let format of formats) {
	      if (this[format].toLowerCase() !== currentDisplayedValue.toLowerCase()) {
	        this.angleUnit = CssAngle.ANGLEUNIT[format];
	        break;
	      }
	    }
	    return this.toString();
	  },

	  /**
	   * Return a string representing a angle
	   */
	  toString: function () {
	    let angle;

	    switch (this.angleUnit) {
	      case CssAngle.ANGLEUNIT.deg:
	        angle = this.deg;
	        break;
	      case CssAngle.ANGLEUNIT.rad:
	        angle = this.rad;
	        break;
	      case CssAngle.ANGLEUNIT.grad:
	        angle = this.grad;
	        break;
	      case CssAngle.ANGLEUNIT.turn:
	        angle = this.turn;
	        break;
	      default:
	        angle = this.deg;
	    }

	    if (this._angleUnitUppercase &&
	        this.angleUnit != CssAngle.ANGLEUNIT.authored) {
	      angle = angle.toUpperCase();
	    }
	    return angle;
	  },

	  /**
	   * This method allows comparison of CssAngle objects using ===.
	   */
	  valueOf: function () {
	    return this.deg;
	  },
	};

	/**
	 * Given a color, classify its type as one of the possible angle
	 * units, as known by |CssAngle.angleUnit|.
	 *
	 * @param  {String} value
	 *         The angle, in any form accepted by CSS.
	 * @return {String}
	 *         The angle classification, one of "deg", "rad", "grad", or "turn".
	 */
	function classifyAngle(value) {
	  value = value.toLowerCase();
	  if (value.endsWith("deg")) {
	    return CssAngle.ANGLEUNIT.deg;
	  }

	  if (value.endsWith("grad")) {
	    return CssAngle.ANGLEUNIT.grad;
	  }

	  if (value.endsWith("rad")) {
	    return CssAngle.ANGLEUNIT.rad;
	  }
	  if (value.endsWith("turn")) {
	    return CssAngle.ANGLEUNIT.turn;
	  }

	  return CssAngle.ANGLEUNIT.deg;
	}


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);

	const {getCSSLexer} = __webpack_require__(174);
	const {cssColors} = __webpack_require__(30);

	const COLOR_UNIT_PREF = "devtools.defaultColorUnit";

	const SPECIALVALUES = new Set([
	  "currentcolor",
	  "initial",
	  "inherit",
	  "transparent",
	  "unset"
	]);

	/**
	 * This module is used to convert between various color types.
	 *
	 * Usage:
	 *   let {colorUtils} = require("devtools/shared/css-color");
	 *   let color = new colorUtils.CssColor("red");
	 *
	 *   color.authored === "red"
	 *   color.hasAlpha === false
	 *   color.valid === true
	 *   color.transparent === false // transparent has a special status.
	 *   color.name === "red"        // returns hex when no name available.
	 *   color.hex === "#f00"        // returns shortHex when available else returns
	 *                                  longHex. If alpha channel is present then we
	 *                                  return this.alphaHex if available,
	 *                                  or this.longAlphaHex if not.
	 *   color.alphaHex === "#f00f"  // returns short alpha hex when available
	 *                                  else returns longAlphaHex.
	 *   color.longHex === "#ff0000" // If alpha channel is present then we return
	 *                                  this.longAlphaHex.
	 *   color.longAlphaHex === "#ff0000ff"
	 *   color.rgb === "rgb(255, 0, 0)" // If alpha channel is present
	 *                                  // then we return this.rgba.
	 *   color.rgba === "rgba(255, 0, 0, 1)"
	 *   color.hsl === "hsl(0, 100%, 50%)"
	 *   color.hsla === "hsla(0, 100%, 50%, 1)" // If alpha channel is present
	 *                                             then we return this.rgba.
	 *
	 *   color.toString() === "#f00"; // Outputs the color type determined in the
	 *                                   COLOR_UNIT_PREF constant (above).
	 *   // Color objects can be reused
	 *   color.newColor("green") === "#0f0"; // true
	 *
	 *   Valid values for COLOR_UNIT_PREF are contained in CssColor.COLORUNIT.
	 */

	function CssColor(colorValue) {
	  this.newColor(colorValue);
	}

	module.exports.colorUtils = {
	  CssColor: CssColor,
	  rgbToHsl: rgbToHsl,
	  setAlpha: setAlpha,
	  classifyColor: classifyColor,
	  rgbToColorName: rgbToColorName,
	  colorToRGBA: colorToRGBA,
	  isValidCSSColor: isValidCSSColor,
	};

	/**
	 * Values used in COLOR_UNIT_PREF
	 */
	CssColor.COLORUNIT = {
	  "authored": "authored",
	  "hex": "hex",
	  "name": "name",
	  "rgb": "rgb",
	  "hsl": "hsl"
	};

	CssColor.prototype = {
	  _colorUnit: null,
	  _colorUnitUppercase: false,

	  // The value as-authored.
	  authored: null,
	  // A lower-cased copy of |authored|.
	  lowerCased: null,

	  get colorUnit() {
	    if (this._colorUnit === null) {
	      let defaultUnit = Services.prefs.getCharPref(COLOR_UNIT_PREF);
	      this._colorUnit = CssColor.COLORUNIT[defaultUnit];
	      this._colorUnitUppercase =
	        (this.authored === this.authored.toUpperCase());
	    }
	    return this._colorUnit;
	  },

	  set colorUnit(unit) {
	    this._colorUnit = unit;
	  },

	  /**
	   * If the current color unit pref is "authored", then set the
	   * default color unit from the given color.  Otherwise, leave the
	   * color unit untouched.
	   *
	   * @param {String} color The color to use
	   */
	  setAuthoredUnitFromColor: function (color) {
	    if (Services.prefs.getCharPref(COLOR_UNIT_PREF) ===
	        CssColor.COLORUNIT.authored) {
	      this._colorUnit = classifyColor(color);
	      this._colorUnitUppercase = (color === color.toUpperCase());
	    }
	  },

	  get hasAlpha() {
	    if (!this.valid) {
	      return false;
	    }
	    return this._getRGBATuple().a !== 1;
	  },

	  get valid() {
	    return isValidCSSColor(this.authored);
	  },

	  /**
	   * Return true for all transparent values e.g. rgba(0, 0, 0, 0).
	   */
	  get transparent() {
	    try {
	      let tuple = this._getRGBATuple();
	      return !(tuple.r || tuple.g || tuple.b || tuple.a);
	    } catch (e) {
	      return false;
	    }
	  },

	  get specialValue() {
	    return SPECIALVALUES.has(this.lowerCased) ? this.authored : null;
	  },

	  get name() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    try {
	      let tuple = this._getRGBATuple();

	      if (tuple.a !== 1) {
	        return this.hex;
	      }
	      let {r, g, b} = tuple;
	      return rgbToColorName(r, g, b);
	    } catch (e) {
	      return this.hex;
	    }
	  },

	  get hex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.hasAlpha) {
	      return this.alphaHex;
	    }

	    let hex = this.longHex;
	    if (hex.charAt(1) == hex.charAt(2) &&
	        hex.charAt(3) == hex.charAt(4) &&
	        hex.charAt(5) == hex.charAt(6)) {
	      hex = "#" + hex.charAt(1) + hex.charAt(3) + hex.charAt(5);
	    }
	    return hex;
	  },

	  get alphaHex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let alphaHex = this.longAlphaHex;
	    if (alphaHex.charAt(1) == alphaHex.charAt(2) &&
	        alphaHex.charAt(3) == alphaHex.charAt(4) &&
	        alphaHex.charAt(5) == alphaHex.charAt(6) &&
	        alphaHex.charAt(7) == alphaHex.charAt(8)) {
	      alphaHex = "#" + alphaHex.charAt(1) + alphaHex.charAt(3) +
	        alphaHex.charAt(5) + alphaHex.charAt(7);
	    }
	    return alphaHex;
	  },

	  get longHex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.hasAlpha) {
	      return this.longAlphaHex;
	    }

	    let tuple = this._getRGBATuple();
	    return "#" + ((1 << 24) + (tuple.r << 16) + (tuple.g << 8) +
	                  (tuple.b << 0)).toString(16).substr(-6);
	  },

	  get longAlphaHex() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }

	    let tuple = this._getRGBATuple();
	    return "#" + ((1 << 24) + (tuple.r << 16) + (tuple.g << 8) +
	                  (tuple.b << 0)).toString(16).substr(-6) +
	                  Math.round(tuple.a * 255).toString(16).padEnd(2, "0");
	  },

	  get rgb() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (!this.hasAlpha) {
	      if (this.lowerCased.startsWith("rgb(")) {
	        // The color is valid and begins with rgb(.
	        return this.authored;
	      }
	      let tuple = this._getRGBATuple();
	      return "rgb(" + tuple.r + ", " + tuple.g + ", " + tuple.b + ")";
	    }
	    return this.rgba;
	  },

	  get rgba() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.lowerCased.startsWith("rgba(")) {
	      // The color is valid and begins with rgba(.
	      return this.authored;
	    }
	    let components = this._getRGBATuple();
	    return "rgba(" + components.r + ", " +
	                     components.g + ", " +
	                     components.b + ", " +
	                     components.a + ")";
	  },

	  get hsl() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.lowerCased.startsWith("hsl(")) {
	      // The color is valid and begins with hsl(.
	      return this.authored;
	    }
	    if (this.hasAlpha) {
	      return this.hsla;
	    }
	    return this._hsl();
	  },

	  get hsla() {
	    let invalidOrSpecialValue = this._getInvalidOrSpecialValue();
	    if (invalidOrSpecialValue !== false) {
	      return invalidOrSpecialValue;
	    }
	    if (this.lowerCased.startsWith("hsla(")) {
	      // The color is valid and begins with hsla(.
	      return this.authored;
	    }
	    if (this.hasAlpha) {
	      let a = this._getRGBATuple().a;
	      return this._hsl(a);
	    }
	    return this._hsl(1);
	  },

	  /**
	   * Check whether the current color value is in the special list e.g.
	   * transparent or invalid.
	   *
	   * @return {String|Boolean}
	   *         - If the current color is a special value e.g. "transparent" then
	   *           return the color.
	   *         - If the color is invalid return an empty string.
	   *         - If the color is a regular color e.g. #F06 so we return false
	   *           to indicate that the color is neither invalid or special.
	   */
	  _getInvalidOrSpecialValue: function () {
	    if (this.specialValue) {
	      return this.specialValue;
	    }
	    if (!this.valid) {
	      return "";
	    }
	    return false;
	  },

	  /**
	   * Change color
	   *
	   * @param  {String} color
	   *         Any valid color string
	   */
	  newColor: function (color) {
	    // Store a lower-cased version of the color to help with format
	    // testing.  The original text is kept as well so it can be
	    // returned when needed.
	    this.lowerCased = color.toLowerCase();
	    this.authored = color;
	    return this;
	  },

	  nextColorUnit: function () {
	    // Reorder the formats array to have the current format at the
	    // front so we can cycle through.
	    let formats = ["hex", "hsl", "rgb", "name"];
	    let currentFormat = classifyColor(this.toString());
	    let putOnEnd = formats.splice(0, formats.indexOf(currentFormat));
	    formats = formats.concat(putOnEnd);
	    let currentDisplayedColor = this[formats[0]];

	    for (let format of formats) {
	      if (this[format].toLowerCase() !== currentDisplayedColor.toLowerCase()) {
	        this.colorUnit = CssColor.COLORUNIT[format];
	        break;
	      }
	    }

	    return this.toString();
	  },

	  /**
	   * Return a string representing a color of type defined in COLOR_UNIT_PREF.
	   */
	  toString: function () {
	    let color;

	    switch (this.colorUnit) {
	      case CssColor.COLORUNIT.authored:
	        color = this.authored;
	        break;
	      case CssColor.COLORUNIT.hex:
	        color = this.hex;
	        break;
	      case CssColor.COLORUNIT.hsl:
	        color = this.hsl;
	        break;
	      case CssColor.COLORUNIT.name:
	        color = this.name;
	        break;
	      case CssColor.COLORUNIT.rgb:
	        color = this.rgb;
	        break;
	      default:
	        color = this.rgb;
	    }

	    if (this._colorUnitUppercase &&
	        this.colorUnit != CssColor.COLORUNIT.authored) {
	      color = color.toUpperCase();
	    }

	    return color;
	  },

	  /**
	   * Returns a RGBA 4-Tuple representation of a color or transparent as
	   * appropriate.
	   */
	  _getRGBATuple: function () {
	    let tuple = colorToRGBA(this.authored);

	    tuple.a = parseFloat(tuple.a.toFixed(1));

	    return tuple;
	  },

	  _hsl: function (maybeAlpha) {
	    if (this.lowerCased.startsWith("hsl(") && maybeAlpha === undefined) {
	      // We can use it as-is.
	      return this.authored;
	    }

	    let {r, g, b} = this._getRGBATuple();
	    let [h, s, l] = rgbToHsl([r, g, b]);
	    if (maybeAlpha !== undefined) {
	      return "hsla(" + h + ", " + s + "%, " + l + "%, " + maybeAlpha + ")";
	    }
	    return "hsl(" + h + ", " + s + "%, " + l + "%)";
	  },

	  /**
	   * This method allows comparison of CssColor objects using ===.
	   */
	  valueOf: function () {
	    return this.rgba;
	  },
	};

	/**
	 * Convert rgb value to hsl
	 *
	 * @param {array} rgb
	 *         Array of rgb values
	 * @return {array}
	 *         Array of hsl values.
	 */
	function rgbToHsl([r, g, b]) {
	  r = r / 255;
	  g = g / 255;
	  b = b / 255;

	  let max = Math.max(r, g, b);
	  let min = Math.min(r, g, b);
	  let h;
	  let s;
	  let l = (max + min) / 2;

	  if (max == min) {
	    h = s = 0;
	  } else {
	    let d = max - min;
	    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

	    switch (max) {
	      case r:
	        h = ((g - b) / d) % 6;
	        break;
	      case g:
	        h = (b - r) / d + 2;
	        break;
	      case b:
	        h = (r - g) / d + 4;
	        break;
	    }
	    h *= 60;
	    if (h < 0) {
	      h += 360;
	    }
	  }

	  return [Math.round(h), Math.round(s * 100), Math.round(l * 100)];
	}

	/**
	 * Takes a color value of any type (hex, hsl, hsla, rgb, rgba)
	 * and an alpha value to generate an rgba string with the correct
	 * alpha value.
	 *
	 * @param  {String} colorValue
	 *         Color in the form of hex, hsl, hsla, rgb, rgba.
	 * @param  {Number} alpha
	 *         Alpha value for the color, between 0 and 1.
	 * @return {String}
	 *         Converted color with `alpha` value in rgba form.
	 */
	function setAlpha(colorValue, alpha) {
	  let color = new CssColor(colorValue);

	  // Throw if the color supplied is not valid.
	  if (!color.valid) {
	    throw new Error("Invalid color.");
	  }

	  // If an invalid alpha valid, just set to 1.
	  if (!(alpha >= 0 && alpha <= 1)) {
	    alpha = 1;
	  }

	  let { r, g, b } = color._getRGBATuple();
	  return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
	}

	/**
	 * Given a color, classify its type as one of the possible color
	 * units, as known by |CssColor.colorUnit|.
	 *
	 * @param  {String} value
	 *         The color, in any form accepted by CSS.
	 * @return {String}
	 *         The color classification, one of "rgb", "hsl", "hex", or "name".
	 */
	function classifyColor(value) {
	  value = value.toLowerCase();
	  if (value.startsWith("rgb(") || value.startsWith("rgba(")) {
	    return CssColor.COLORUNIT.rgb;
	  } else if (value.startsWith("hsl(") || value.startsWith("hsla(")) {
	    return CssColor.COLORUNIT.hsl;
	  } else if (/^#[0-9a-f]+$/.exec(value)) {
	    return CssColor.COLORUNIT.hex;
	  }
	  return CssColor.COLORUNIT.name;
	}

	// This holds a map from colors back to color names for use by
	// rgbToColorName.
	var cssRGBMap;

	/**
	 * Given a color, return its name, if it has one.  Throws an exception
	 * if the color does not have a name.
	 *
	 * @param {Number} r, g, b  The color components.
	 * @return {String} the name of the color
	 */
	function rgbToColorName(r, g, b) {
	  if (!cssRGBMap) {
	    cssRGBMap = {};
	    for (let name in cssColors) {
	      let key = JSON.stringify(cssColors[name]);
	      if (!(key in cssRGBMap)) {
	        cssRGBMap[key] = name;
	      }
	    }
	  }
	  let value = cssRGBMap[JSON.stringify([r, g, b, 1])];
	  if (!value) {
	    throw new Error("no such color");
	  }
	  return value;
	}

	// Translated from nsColor.cpp.
	function _hslValue(m1, m2, h) {
	  if (h < 0.0) {
	    h += 1.0;
	  }
	  if (h > 1.0) {
	    h -= 1.0;
	  }
	  if (h < 1.0 / 6.0) {
	    return m1 + (m2 - m1) * h * 6.0;
	  }
	  if (h < 1.0 / 2.0) {
	    return m2;
	  }
	  if (h < 2.0 / 3.0) {
	    return m1 + (m2 - m1) * (2.0 / 3.0 - h) * 6.0;
	  }
	  return m1;
	}

	// Translated from nsColor.cpp.  All three values are expected to be
	// in the range 0-1.
	function hslToRGB([h, s, l]) {
	  let r, g, b;
	  let m1, m2;
	  if (l <= 0.5) {
	    m2 = l * (s + 1);
	  } else {
	    m2 = l + s - l * s;
	  }
	  m1 = l * 2 - m2;
	  r = Math.floor(255 * _hslValue(m1, m2, h + 1.0 / 3.0));
	  g = Math.floor(255 * _hslValue(m1, m2, h));
	  b = Math.floor(255 * _hslValue(m1, m2, h - 1.0 / 3.0));
	  return [r, g, b];
	}

	/**
	 * A helper function to convert a hex string like "F0C" or "F0C8" to a color.
	 *
	 * @param {String} name the color string
	 * @return {Object} an object of the form {r, g, b, a}; or null if the
	 *         name was not a valid color
	 */
	function hexToRGBA(name) {
	  let r, g, b, a = 1;

	  if (name.length === 3) {
	    // short hex string (e.g. F0C)
	    r = parseInt(name.charAt(0) + name.charAt(0), 16);
	    g = parseInt(name.charAt(1) + name.charAt(1), 16);
	    b = parseInt(name.charAt(2) + name.charAt(2), 16);
	  } else if (name.length === 4) {
	    // short alpha hex string (e.g. F0CA)
	    r = parseInt(name.charAt(0) + name.charAt(0), 16);
	    g = parseInt(name.charAt(1) + name.charAt(1), 16);
	    b = parseInt(name.charAt(2) + name.charAt(2), 16);
	    a = parseInt(name.charAt(3) + name.charAt(3), 16) / 255;
	  } else if (name.length === 6) {
	    // hex string (e.g. FD01CD)
	    r = parseInt(name.charAt(0) + name.charAt(1), 16);
	    g = parseInt(name.charAt(2) + name.charAt(3), 16);
	    b = parseInt(name.charAt(4) + name.charAt(5), 16);
	  } else if (name.length === 8) {
	    // alpha hex string (e.g. FD01CDAB)
	    r = parseInt(name.charAt(0) + name.charAt(1), 16);
	    g = parseInt(name.charAt(2) + name.charAt(3), 16);
	    b = parseInt(name.charAt(4) + name.charAt(5), 16);
	    a = parseInt(name.charAt(6) + name.charAt(7), 16) / 255;
	  } else {
	    return null;
	  }
	  a = Math.round(a * 10) / 10;
	  return {r, g, b, a};
	}

	/**
	 * A helper function to clamp a value.
	 *
	 * @param {Number} value The value to clamp
	 * @param {Number} min The minimum value
	 * @param {Number} max The maximum value
	 * @return {Number} A value between min and max
	 */
	function clamp(value, min, max) {
	  if (value < min) {
	    value = min;
	  }
	  if (value > max) {
	    value = max;
	  }
	  return value;
	}

	/**
	 * A helper function to get a token from a lexer, skipping comments
	 * and whitespace.
	 *
	 * @param {CSSLexer} lexer The lexer
	 * @return {CSSToken} The next non-whitespace, non-comment token; or
	 * null at EOF.
	 */
	function getToken(lexer) {
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token || (token.tokenType !== "comment" &&
	                   token.tokenType !== "whitespace")) {
	      return token;
	    }
	  }
	}

	/**
	 * A helper function to examine a token and ensure it is a comma.
	 * Then fetch and return the next token.  Returns null if the
	 * token was not a comma, or at EOF.
	 *
	 * @param {CSSLexer} lexer The lexer
	 * @param {CSSToken} token A token to be examined
	 * @return {CSSToken} The next non-whitespace, non-comment token; or
	 * null if token was not a comma, or at EOF.
	 */
	function requireComma(lexer, token) {
	  if (!token || token.tokenType !== "symbol" || token.text !== ",") {
	    return null;
	  }
	  return getToken(lexer);
	}

	/**
	 * A helper function to parse the first three arguments to hsl()
	 * or hsla().
	 *
	 * @param {CSSLexer} lexer The lexer
	 * @return {Array} An array of the form [r,g,b]; or null on error.
	 */
	function parseHsl(lexer) {
	  let vals = [];

	  let token = getToken(lexer);
	  if (!token || token.tokenType !== "number") {
	    return null;
	  }

	  let val = token.number / 360.0;
	  vals.push(val - Math.floor(val));

	  for (let i = 0; i < 2; ++i) {
	    token = requireComma(lexer, getToken(lexer));
	    if (!token || token.tokenType !== "percentage") {
	      return null;
	    }
	    vals.push(clamp(token.number, 0, 1));
	  }

	  return hslToRGB(vals);
	}

	/**
	 * A helper function to parse the first three arguments to rgb()
	 * or rgba().
	 *
	 * @param {CSSLexer} lexer The lexer
	 * @return {Array} An array of the form [r,g,b]; or null on error.
	 */
	function parseRgb(lexer) {
	  let isPercentage = false;
	  let vals = [];
	  for (let i = 0; i < 3; ++i) {
	    let token = getToken(lexer);
	    if (i > 0) {
	      token = requireComma(lexer, token);
	    }
	    if (!token) {
	      return null;
	    }

	    /* Either all parameters are integers, or all are percentages, so
	       check the first one to see.  */
	    if (i === 0 && token.tokenType === "percentage") {
	      isPercentage = true;
	    }

	    if (isPercentage) {
	      if (token.tokenType !== "percentage") {
	        return null;
	      }
	      vals.push(Math.round(255 * clamp(token.number, 0, 1)));
	    } else {
	      if (token.tokenType !== "number" || !token.isInteger) {
	        return null;
	      }
	      vals.push(clamp(token.number, 0, 255));
	    }
	  }
	  return vals;
	}

	/**
	 * Convert a string representing a color to an object holding the
	 * color's components.  Any valid CSS color form can be passed in.
	 *
	 * @param {String} name the color
	 * @return {Object} an object of the form {r, g, b, a}; or null if the
	 *         name was not a valid color
	 */
	function colorToRGBA(name) {
	  name = name.trim().toLowerCase();

	  if (name in cssColors) {
	    let result = cssColors[name];
	    return {r: result[0], g: result[1], b: result[2], a: result[3]};
	  } else if (name === "transparent") {
	    return {r: 0, g: 0, b: 0, a: 0};
	  } else if (name === "currentcolor") {
	    return {r: 0, g: 0, b: 0, a: 1};
	  }

	  let lexer = getCSSLexer(name);

	  let func = getToken(lexer);
	  if (!func) {
	    return null;
	  }

	  if (func.tokenType === "id" || func.tokenType === "hash") {
	    if (getToken(lexer) !== null) {
	      return null;
	    }
	    return hexToRGBA(func.text);
	  }

	  const expectedFunctions = ["rgba", "rgb", "hsla", "hsl"];
	  if (!func || func.tokenType !== "function" ||
	      !expectedFunctions.includes(func.text)) {
	    return null;
	  }

	  let hsl = func.text === "hsl" || func.text === "hsla";
	  let alpha = func.text === "rgba" || func.text === "hsla";

	  let vals = hsl ? parseHsl(lexer) : parseRgb(lexer);
	  if (!vals) {
	    return null;
	  }

	  if (alpha) {
	    let token = requireComma(lexer, getToken(lexer));
	    if (!token || token.tokenType !== "number") {
	      return null;
	    }
	    vals.push(clamp(token.number, 0, 1));
	  } else {
	    vals.push(1);
	  }

	  let parenToken = getToken(lexer);
	  if (!parenToken || parenToken.tokenType !== "symbol" ||
	      parenToken.text !== ")") {
	    return null;
	  }
	  if (getToken(lexer) !== null) {
	    return null;
	  }

	  return {r: vals[0], g: vals[1], b: vals[2], a: vals[3]};
	}

	/**
	 * Check whether a string names a valid CSS color.
	 *
	 * @param {String} name The string to check
	 * @return {Boolean} True if the string is a CSS color name.
	 */
	function isValidCSSColor(name) {
	  return colorToRGBA(name) !== null;
	}


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const Services = __webpack_require__(1);
	const EventEmitter = __webpack_require__(6);

	exports.PREF_ORIG_SOURCES = "devtools.styleeditor.source-maps-enabled";

	/**
	 * A PreferenceObserver observes a pref branch for pref changes.
	 * It emits an event for each preference change.
	 */
	function PrefObserver(branchName) {
	  this.branchName = branchName;
	  this.branch = Services.prefs.getBranch(branchName);
	  this.branch.addObserver("", this, false);

	  EventEmitter.decorate(this);
	}

	exports.PrefObserver = PrefObserver;

	PrefObserver.prototype = {
	  observe: function (subject, topic, data) {
	    if (topic == "nsPref:changed") {
	      this.emit(this.branchName + data);
	    }
	  },

	  destroy: function () {
	    if (this.branch) {
	      this.branch.removeObserver("", this);
	    }
	  }
	};


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {parseDeclarations} = __webpack_require__(182);
	const promise = __webpack_require__(4);
	const {getCSSLexer} = __webpack_require__(174);
	const {KeyCodes} = __webpack_require__(14);

	const HTML_NS = "http://www.w3.org/1999/xhtml";

	/**
	 * Create a child element with a set of attributes.
	 *
	 * @param {Element} parent
	 *        The parent node.
	 * @param {string} tagName
	 *        The tag name.
	 * @param {object} attributes
	 *        A set of attributes to set on the node.
	 */
	function createChild(parent, tagName, attributes = {}) {
	  let elt = parent.ownerDocument.createElementNS(HTML_NS, tagName);
	  for (let attr in attributes) {
	    if (attributes.hasOwnProperty(attr)) {
	      if (attr === "textContent") {
	        elt.textContent = attributes[attr];
	      } else if (attr === "child") {
	        elt.appendChild(attributes[attr]);
	      } else {
	        elt.setAttribute(attr, attributes[attr]);
	      }
	    }
	  }
	  parent.appendChild(elt);
	  return elt;
	}

	exports.createChild = createChild;

	/**
	 * Append a text node to an element.
	 *
	 * @param {Element} parent
	 *        The parent node.
	 * @param {string} text
	 *        The text content for the text node.
	 */
	function appendText(parent, text) {
	  parent.appendChild(parent.ownerDocument.createTextNode(text));
	}

	exports.appendText = appendText;

	/**
	 * Called when a character is typed in a value editor.  This decides
	 * whether to advance or not, first by checking to see if ";" was
	 * typed, and then by lexing the input and seeing whether the ";"
	 * would be a terminator at this point.
	 *
	 * @param {number} keyCode
	 *        Key code to be checked.
	 * @param {string} aValue
	 *        Current text editor value.
	 * @param {number} insertionPoint
	 *        The index of the insertion point.
	 * @return {Boolean} True if the focus should advance; false if
	 *        the character should be inserted.
	 */
	function advanceValidate(keyCode, value, insertionPoint) {
	  // Only ";" has special handling here.
	  if (keyCode !== KeyCodes.DOM_VK_SEMICOLON) {
	    return false;
	  }

	  // Insert the character provisionally and see what happens.  If we
	  // end up with a ";" symbol token, then the semicolon terminates the
	  // value.  Otherwise it's been inserted in some spot where it has a
	  // valid meaning, like a comment or string.
	  value = value.slice(0, insertionPoint) + ";" + value.slice(insertionPoint);
	  let lexer = getCSSLexer(value);
	  while (true) {
	    let token = lexer.nextToken();
	    if (token.endOffset > insertionPoint) {
	      if (token.tokenType === "symbol" && token.text === ";") {
	        // The ";" is a terminator.
	        return true;
	      }
	      // The ";" is not a terminator in this context.
	      break;
	    }
	  }
	  return false;
	}

	exports.advanceValidate = advanceValidate;

	/**
	 * Create a throttling function wrapper to regulate its frequency.
	 *
	 * @param {Function} func
	 *         The function to throttle
	 * @param {number} wait
	 *         The throttling period
	 * @param {Object} scope
	 *         The scope to use for func
	 * @return {Function} The throttled function
	 */
	function throttle(func, wait, scope) {
	  let timer = null;

	  return function () {
	    if (timer) {
	      clearTimeout(timer);
	    }

	    let args = arguments;
	    timer = setTimeout(function () {
	      timer = null;
	      func.apply(scope, args);
	    }, wait);
	  };
	}

	exports.throttle = throttle;

	/**
	 * Event handler that causes a blur on the target if the input has
	 * multiple CSS properties as the value.
	 */
	function blurOnMultipleProperties(cssProperties) {
	  return (e) => {
	    setTimeout(() => {
	      let props = parseDeclarations(cssProperties.isKnown, e.target.value);
	      if (props.length > 1) {
	        e.target.blur();
	      }
	    }, 0);
	  };
	}

	exports.blurOnMultipleProperties = blurOnMultipleProperties;

	/**
	 * Log the provided error to the console and return a rejected Promise for
	 * this error.
	 *
	 * @param {Error} error
	 *         The error to log
	 * @return {Promise} A rejected promise
	 */
	function promiseWarn(error) {
	  console.error(error);
	  return promise.reject(error);
	}

	exports.promiseWarn = promiseWarn;


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// This file holds various CSS parsing and rewriting utilities.
	// Some entry points of note are:
	// parseDeclarations - parse a CSS rule into declarations
	// RuleRewriter - rewrite CSS rule text
	// parsePseudoClassesAndAttributes - parse selector and extract
	//     pseudo-classes
	// parseSingleValue - parse a single CSS property value

	"use strict";

	const promise = __webpack_require__(4);
	const {getCSSLexer} = __webpack_require__(174);
	const {Task} = __webpack_require__(15);

	const SELECTOR_ATTRIBUTE = exports.SELECTOR_ATTRIBUTE = 1;
	const SELECTOR_ELEMENT = exports.SELECTOR_ELEMENT = 2;
	const SELECTOR_PSEUDO_CLASS = exports.SELECTOR_PSEUDO_CLASS = 3;

	// Used to test whether a newline appears anywhere in some text.
	const NEWLINE_RX = /[\r\n]/;
	// Used to test whether a bit of text starts an empty comment, either
	// an "ordinary" /* ... */ comment, or a "heuristic bypass" comment
	// like /*! ... */.
	const EMPTY_COMMENT_START_RX = /^\/\*!?[ \r\n\t\f]*$/;
	// Used to test whether a bit of text ends an empty comment.
	const EMPTY_COMMENT_END_RX = /^[ \r\n\t\f]*\*\//;
	// Used to test whether a string starts with a blank line.
	const BLANK_LINE_RX = /^[ \t]*(?:\r\n|\n|\r|\f|$)/;

	// When commenting out a declaration, we put this character into the
	// comment opener so that future parses of the commented text know to
	// bypass the property name validity heuristic.
	const COMMENT_PARSING_HEURISTIC_BYPASS_CHAR = "!";

	/**
	 * A generator function that lexes a CSS source string, yielding the
	 * CSS tokens.  Comment tokens are dropped.
	 *
	 * @param {String} CSS source string
	 * @yield {CSSToken} The next CSSToken that is lexed
	 * @see CSSToken for details about the returned tokens
	 */
	function* cssTokenizer(string) {
	  let lexer = getCSSLexer(string);
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token) {
	      break;
	    }
	    // None of the existing consumers want comments.
	    if (token.tokenType !== "comment") {
	      yield token;
	    }
	  }
	}

	/**
	 * Pass |string| to the CSS lexer and return an array of all the
	 * returned tokens.  Comment tokens are not included.  In addition to
	 * the usual information, each token will have starting and ending
	 * line and column information attached.  Specifically, each token
	 * has an additional "loc" attribute.  This attribute is an object
	 * of the form {line: L, column: C}.  Lines and columns are both zero
	 * based.
	 *
	 * It's best not to add new uses of this function.  In general it is
	 * simpler and better to use the CSSToken offsets, rather than line
	 * and column.  Also, this function lexes the entire input string at
	 * once, rather than lazily yielding a token stream.  Use
	 * |cssTokenizer| or |getCSSLexer| instead.
	 *
	 * @param{String} string The input string.
	 * @return {Array} An array of tokens (@see CSSToken) that have
	 *        line and column information.
	 */
	function cssTokenizerWithLineColumn(string) {
	  let lexer = getCSSLexer(string);
	  let result = [];
	  let prevToken = undefined;
	  while (true) {
	    let token = lexer.nextToken();
	    let lineNumber = lexer.lineNumber;
	    let columnNumber = lexer.columnNumber;

	    if (prevToken) {
	      prevToken.loc.end = {
	        line: lineNumber,
	        column: columnNumber
	      };
	    }

	    if (!token) {
	      break;
	    }

	    if (token.tokenType === "comment") {
	      // We've already dealt with the previous token's location.
	      prevToken = undefined;
	    } else {
	      let startLoc = {
	        line: lineNumber,
	        column: columnNumber
	      };
	      token.loc = {start: startLoc};

	      result.push(token);
	      prevToken = token;
	    }
	  }

	  return result;
	}

	/**
	 * Escape a comment body.  Find the comment start and end strings in a
	 * string and inserts backslashes so that the resulting text can
	 * itself be put inside a comment.
	 *
	 * @param {String} inputString
	 *                 input string
	 * @return {String} the escaped result
	 */
	function escapeCSSComment(inputString) {
	  let result = inputString.replace(/\/(\\*)\*/g, "/\\$1*");
	  return result.replace(/\*(\\*)\//g, "*\\$1/");
	}

	/**
	 * Un-escape a comment body.  This undoes any comment escaping that
	 * was done by escapeCSSComment.  That is, given input like "/\*
	 * comment *\/", it will strip the backslashes.
	 *
	 * @param {String} inputString
	 *                 input string
	 * @return {String} the un-escaped result
	 */
	function unescapeCSSComment(inputString) {
	  let result = inputString.replace(/\/\\(\\*)\*/g, "/$1*");
	  return result.replace(/\*\\(\\*)\//g, "*$1/");
	}

	/**
	 * A helper function for @see parseDeclarations that handles parsing
	 * of comment text.  This wraps a recursive call to parseDeclarations
	 * with the processing needed to ensure that offsets in the result
	 * refer back to the original, unescaped, input string.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        A function to check if the CSS property is known. This is either an
	 *        internal server function or from the CssPropertiesFront.
	 * @param {String} commentText The text of the comment, without the
	 *                             delimiters.
	 * @param {Number} startOffset The offset of the comment opener
	 *                             in the original text.
	 * @param {Number} endOffset The offset of the comment closer
	 *                           in the original text.
	 * @return {array} Array of declarations of the same form as returned
	 *                 by parseDeclarations.
	 */
	function parseCommentDeclarations(isCssPropertyKnown, commentText, startOffset,
	                                  endOffset) {
	  let commentOverride = false;
	  if (commentText === "") {
	    return [];
	  } else if (commentText[0] === COMMENT_PARSING_HEURISTIC_BYPASS_CHAR) {
	    // This is the special sign that the comment was written by
	    // rewriteDeclarations and so we should bypass the usual
	    // heuristic.
	    commentOverride = true;
	    commentText = commentText.substring(1);
	  }

	  let rewrittenText = unescapeCSSComment(commentText);

	  // We might have rewritten an embedded comment.  For example
	  // /\* ... *\/ would turn into /* ... */.
	  // This rewriting is necessary for proper lexing, but it means
	  // that the offsets we get back can be off.  So now we compute
	  // a map so that we can rewrite offsets later.  The map is the same
	  // length as |rewrittenText| and tells us how to map an index
	  // into |rewrittenText| to an index into |commentText|.
	  //
	  // First, we find the location of each comment starter or closer in
	  // |rewrittenText|.  At these spots we put a 1 into |rewrites|.
	  // Then we walk the array again, using the elements to compute a
	  // delta, which we use to make the final mapping.
	  //
	  // Note we allocate one extra entry because we can see an ending
	  // offset that is equal to the length.
	  let rewrites = new Array(rewrittenText.length + 1).fill(0);

	  let commentRe = /\/\\*\*|\*\\*\//g;
	  while (true) {
	    let matchData = commentRe.exec(rewrittenText);
	    if (!matchData) {
	      break;
	    }
	    rewrites[matchData.index] = 1;
	  }

	  let delta = 0;
	  for (let i = 0; i <= rewrittenText.length; ++i) {
	    delta += rewrites[i];
	    // |startOffset| to add the offset from the comment starter, |+2|
	    // for the length of the "/*", then |i| and |delta| as described
	    // above.
	    rewrites[i] = startOffset + 2 + i + delta;
	    if (commentOverride) {
	      ++rewrites[i];
	    }
	  }

	  // Note that we pass "false" for parseComments here.  It doesn't
	  // seem worthwhile to support declarations in comments-in-comments
	  // here, as there's no way to generate those using the tools, and
	  // users would be crazy to write such things.
	  let newDecls = parseDeclarationsInternal(isCssPropertyKnown, rewrittenText,
	                                           false, true, commentOverride);
	  for (let decl of newDecls) {
	    decl.offsets[0] = rewrites[decl.offsets[0]];
	    decl.offsets[1] = rewrites[decl.offsets[1]];
	    decl.colonOffsets[0] = rewrites[decl.colonOffsets[0]];
	    decl.colonOffsets[1] = rewrites[decl.colonOffsets[1]];
	    decl.commentOffsets = [startOffset, endOffset];
	  }
	  return newDecls;
	}

	/**
	 * A helper function for parseDeclarationsInternal that creates a new
	 * empty declaration.
	 *
	 * @return {object} an empty declaration of the form returned by
	 *                  parseDeclarations
	 */
	function getEmptyDeclaration() {
	  return {name: "", value: "", priority: "",
	          terminator: "",
	          offsets: [undefined, undefined],
	          colonOffsets: false};
	}

	/**
	 * A helper function that does all the parsing work for
	 * parseDeclarations.  This is separate because it has some arguments
	 * that don't make sense in isolation.
	 *
	 * The return value and arguments are like parseDeclarations, with
	 * these additional arguments.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        Function to check if the CSS property is known.
	 * @param {Boolean} inComment
	 *        If true, assume that this call is parsing some text
	 *        which came from a comment in another declaration.
	 *        In this case some heuristics are used to avoid parsing
	 *        text which isn't obviously a series of declarations.
	 * @param {Boolean} commentOverride
	 *        This only makes sense when inComment=true.
	 *        When true, assume that the comment was generated by
	 *        rewriteDeclarations, and skip the usual name-checking
	 *        heuristic.
	 */
	function parseDeclarationsInternal(isCssPropertyKnown, inputString,
	                                   parseComments, inComment, commentOverride) {
	  if (inputString === null || inputString === undefined) {
	    throw new Error("empty input string");
	  }

	  let lexer = getCSSLexer(inputString);

	  let declarations = [getEmptyDeclaration()];
	  let lastProp = declarations[0];

	  let current = "", hasBang = false;
	  while (true) {
	    let token = lexer.nextToken();
	    if (!token) {
	      break;
	    }

	    // Ignore HTML comment tokens (but parse anything they might
	    // happen to surround).
	    if (token.tokenType === "htmlcomment") {
	      continue;
	    }

	    // Update the start and end offsets of the declaration, but only
	    // when we see a significant token.
	    if (token.tokenType !== "whitespace" && token.tokenType !== "comment") {
	      if (lastProp.offsets[0] === undefined) {
	        lastProp.offsets[0] = token.startOffset;
	      }
	      lastProp.offsets[1] = token.endOffset;
	    } else if (lastProp.name && !current && !hasBang &&
	               !lastProp.priority && lastProp.colonOffsets[1]) {
	      // Whitespace appearing after the ":" is attributed to it.
	      lastProp.colonOffsets[1] = token.endOffset;
	    }

	    if (token.tokenType === "symbol" && token.text === ":") {
	      if (!lastProp.name) {
	        // Set the current declaration name if there's no name yet
	        lastProp.name = current.trim();
	        lastProp.colonOffsets = [token.startOffset, token.endOffset];
	        current = "";
	        hasBang = false;

	        // When parsing a comment body, if the left-hand-side is not a
	        // valid property name, then drop it and stop parsing.
	        if (inComment && !commentOverride &&
	            !isCssPropertyKnown(lastProp.name)) {
	          lastProp.name = null;
	          break;
	        }
	      } else {
	        // Otherwise, just append ':' to the current value (declaration value
	        // with colons)
	        current += ":";
	      }
	    } else if (token.tokenType === "symbol" && token.text === ";") {
	      lastProp.terminator = "";
	      // When parsing a comment, if the name hasn't been set, then we
	      // have probably just seen an ordinary semicolon used in text,
	      // so drop this and stop parsing.
	      if (inComment && !lastProp.name) {
	        current = "";
	        break;
	      }
	      lastProp.value = current.trim();
	      current = "";
	      hasBang = false;
	      declarations.push(getEmptyDeclaration());
	      lastProp = declarations[declarations.length - 1];
	    } else if (token.tokenType === "ident") {
	      if (token.text === "important" && hasBang) {
	        lastProp.priority = "important";
	        hasBang = false;
	      } else {
	        if (hasBang) {
	          current += "!";
	        }
	        // Re-escape the token to avoid dequoting problems.
	        // See bug 1287620.
	        current += CSS.escape(token.text);
	      }
	    } else if (token.tokenType === "symbol" && token.text === "!") {
	      hasBang = true;
	    } else if (token.tokenType === "whitespace") {
	      if (current !== "") {
	        current += " ";
	      }
	    } else if (token.tokenType === "comment") {
	      if (parseComments && !lastProp.name && !lastProp.value) {
	        let commentText = inputString.substring(token.startOffset + 2,
	                                                token.endOffset - 2);
	        let newDecls = parseCommentDeclarations(isCssPropertyKnown, commentText,
	                                                token.startOffset,
	                                                token.endOffset);

	        // Insert the new declarations just before the final element.
	        let lastDecl = declarations.pop();
	        declarations = [...declarations, ...newDecls, lastDecl];
	      } else {
	        current += " ";
	      }
	    } else {
	      current += inputString.substring(token.startOffset, token.endOffset);
	    }
	  }

	  // Handle whatever trailing properties or values might still be there
	  if (current) {
	    if (!lastProp.name) {
	      // Ignore this case in comments.
	      if (!inComment) {
	        // Trailing property found, e.g. p1:v1;p2:v2;p3
	        lastProp.name = current.trim();
	      }
	    } else {
	      // Trailing value found, i.e. value without an ending ;
	      lastProp.value = current.trim();
	      let terminator = lexer.performEOFFixup("", true);
	      lastProp.terminator = terminator + ";";
	      // If the input was unterminated, attribute the remainder to
	      // this property.  This avoids some bad behavior when rewriting
	      // an unterminated comment.
	      if (terminator) {
	        lastProp.offsets[1] = inputString.length;
	      }
	    }
	  }

	  // Remove declarations that have neither a name nor a value
	  declarations = declarations.filter(prop => prop.name || prop.value);

	  return declarations;
	}

	/**
	 * Returns an array of CSS declarations given a string.
	 * For example, parseDeclarations(isCssPropertyKnown, "width: 1px; height: 1px")
	 * would return:
	 * [{name:"width", value: "1px"}, {name: "height", "value": "1px"}]
	 *
	 * The input string is assumed to only contain declarations so { and }
	 * characters will be treated as part of either the property or value,
	 * depending where it's found.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        A function to check if the CSS property is known. This is either an
	 *        internal server function or from the CssPropertiesFront.
	 *        that are supported by the server.
	 * @param {String} inputString
	 *        An input string of CSS
	 * @param {Boolean} parseComments
	 *        If true, try to parse the contents of comments as well.
	 *        A comment will only be parsed if it occurs outside of
	 *        the body of some other declaration.
	 * @return {Array} an array of objects with the following signature:
	 *         [{"name": string, "value": string, "priority": string,
	 *           "terminator": string,
	 *           "offsets": [start, end], "colonOffsets": [start, end]},
	 *          ...]
	 *         Here, "offsets" holds the offsets of the start and end
	 *         of the declaration text, in a form suitable for use with
	 *         String.substring.
	 *         "terminator" is a string to use to terminate the declaration,
	 *         usually "" to mean no additional termination is needed.
	 *         "colonOffsets" holds the start and end locations of the
	 *         ":" that separates the property name from the value.
	 *         If the declaration appears in a comment, then there will
	 *         be an additional {"commentOffsets": [start, end] property
	 *         on the object, which will hold the offsets of the start
	 *         and end of the enclosing comment.
	 */
	function parseDeclarations(isCssPropertyKnown, inputString,
	                           parseComments = false) {
	  return parseDeclarationsInternal(isCssPropertyKnown, inputString,
	                                   parseComments, false, false);
	}

	/**
	 * Return an object that can be used to rewrite declarations in some
	 * source text.  The source text and parsing are handled in the same
	 * way as @see parseDeclarations, with |parseComments| being true.
	 * Rewriting is done by calling one of the modification functions like
	 * setPropertyEnabled.  The returned object has the same interface
	 * as @see RuleModificationList.
	 *
	 * An example showing how to disable the 3rd property in a rule:
	 *
	 *    let rewriter = new RuleRewriter(isCssPropertyKnown, ruleActor,
	 *                                    ruleActor.authoredText);
	 *    rewriter.setPropertyEnabled(3, "color", false);
	 *    rewriter.apply().then(() => { ... the change is made ... });
	 *
	 * The exported rewriting methods are |renameProperty|, |setPropertyEnabled|,
	 * |createProperty|, |setProperty|, and |removeProperty|.  The |apply|
	 * method can be used to send the edited text to the StyleRuleActor;
	 * |getDefaultIndentation| is useful for the methods requiring a
	 * default indentation value; and |getResult| is useful for testing.
	 *
	 * Additionally, editing will set the |changedDeclarations| property
	 * on this object.  This property has the same form as the |changed|
	 * property of the object returned by |getResult|.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        A function to check if the CSS property is known. This is either an
	 *        internal server function or from the CssPropertiesFront.
	 *        that are supported by the server. Note that if Bug 1222047
	 *        is completed then isCssPropertyKnown will not need to be passed in.
	 *        The CssProperty front will be able to obtained directly from the
	 *        RuleRewriter.
	 * @param {StyleRuleFront} rule The style rule to use.  Note that this
	 *        is only needed by the |apply| and |getDefaultIndentation| methods;
	 *        and in particular for testing it can be |null|.
	 * @param {String} inputString The CSS source text to parse and modify.
	 * @return {Object} an object that can be used to rewrite the input text.
	 */
	function RuleRewriter(isCssPropertyKnown, rule, inputString) {
	  this.rule = rule;
	  this.inputString = inputString;
	  // Whether there are any newlines in the input text.
	  this.hasNewLine = /[\r\n]/.test(this.inputString);
	  // Keep track of which any declarations we had to rewrite while
	  // performing the requested action.
	  this.changedDeclarations = {};
	  // The declarations.
	  this.declarations = parseDeclarations(isCssPropertyKnown, this.inputString,
	                                        true);

	  this.decl = null;
	  this.result = null;
	  // If not null, a promise that must be wait upon before |apply| can
	  // do its work.
	  this.editPromise = null;

	  // If the |defaultIndentation| property is set, then it is used;
	  // otherwise the RuleRewriter will try to compute the default
	  // indentation based on the style sheet's text.  This override
	  // facility is for testing.
	  this.defaultIndentation = null;
	}

	RuleRewriter.prototype = {
	  /**
	   * An internal function to complete initialization and set some
	   * properties for further processing.
	   *
	   * @param {Number} index The index of the property to modify
	   */
	  completeInitialization: function (index) {
	    if (index < 0) {
	      throw new Error("Invalid index " + index + ". Expected positive integer");
	    }
	    // |decl| is the declaration to be rewritten, or null if there is no
	    // declaration corresponding to |index|.
	    // |result| is used to accumulate the result text.
	    if (index < this.declarations.length) {
	      this.decl = this.declarations[index];
	      this.result = this.inputString.substring(0, this.decl.offsets[0]);
	    } else {
	      this.decl = null;
	      this.result = this.inputString;
	    }
	  },

	  /**
	   * A helper function to compute the indentation of some text.  This
	   * examines the rule's existing text to guess the indentation to use;
	   * unlike |getDefaultIndentation|, which examines the entire style
	   * sheet.
	   *
	   * @param {String} string the input text
	   * @param {Number} offset the offset at which to compute the indentation
	   * @return {String} the indentation at the indicated position
	   */
	  getIndentation: function (string, offset) {
	    let originalOffset = offset;
	    for (--offset; offset >= 0; --offset) {
	      let c = string[offset];
	      if (c === "\r" || c === "\n" || c === "\f") {
	        return string.substring(offset + 1, originalOffset);
	      }
	      if (c !== " " && c !== "\t") {
	        // Found some non-whitespace character before we found a newline
	        // -- let's reset the starting point and keep going, as we saw
	        // something on the line before the declaration.
	        originalOffset = offset;
	      }
	    }
	    // Ran off the end.
	    return "";
	  },

	  /**
	   * Modify a property value to ensure it is "lexically safe" for
	   * insertion into a style sheet.  This function doesn't attempt to
	   * ensure that the resulting text is a valid value for the given
	   * property; but rather just that inserting the text into the style
	   * sheet will not cause unwanted changes to other rules or
	   * declarations.
	   *
	   * @param {String} text The input text.  This should include the trailing ";".
	   * @return {Array} An array of the form [anySanitized, text], where
	   *                 |anySanitized| is a boolean that indicates
	   *                  whether anything substantive has changed; and
	   *                  where |text| is the text that has been rewritten
	   *                  to be "lexically safe".
	   */
	  sanitizePropertyValue: function (text) {
	    let lexer = getCSSLexer(text);

	    let result = "";
	    let previousOffset = 0;
	    let braceDepth = 0;
	    let anySanitized = false;
	    while (true) {
	      let token = lexer.nextToken();
	      if (!token) {
	        break;
	      }

	      if (token.tokenType === "symbol") {
	        switch (token.text) {
	          case ";":
	            // We simply drop the ";" here.  This lets us cope with
	            // declarations that don't have a ";" and also other
	            // termination.  The caller handles adding the ";" again.
	            result += text.substring(previousOffset, token.startOffset);
	            previousOffset = token.endOffset;
	            break;

	          case "{":
	            ++braceDepth;
	            break;

	          case "}":
	            --braceDepth;
	            if (braceDepth < 0) {
	              // Found an unmatched close bracket.
	              braceDepth = 0;
	              // Copy out text from |previousOffset|.
	              result += text.substring(previousOffset, token.startOffset);
	              // Quote the offending symbol.
	              result += "\\" + token.text;
	              previousOffset = token.endOffset;
	              anySanitized = true;
	            }
	            break;
	        }
	      }
	    }

	    // Copy out any remaining text, then any needed terminators.
	    result += text.substring(previousOffset, text.length);
	    let eofFixup = lexer.performEOFFixup("", true);
	    if (eofFixup) {
	      anySanitized = true;
	      result += eofFixup;
	    }
	    return [anySanitized, result];
	  },

	  /**
	   * Start at |index| and skip whitespace
	   * backward in |string|.  Return the index of the first
	   * non-whitespace character, or -1 if the entire string was
	   * whitespace.
	   * @param {String} string the input string
	   * @param {Number} index the index at which to start
	   * @return {Number} index of the first non-whitespace character, or -1
	   */
	  skipWhitespaceBackward: function (string, index) {
	    for (--index;
	         index >= 0 && (string[index] === " " || string[index] === "\t");
	         --index) {
	      // Nothing.
	    }
	    return index;
	  },

	  /**
	   * Terminate a given declaration, if needed.
	   *
	   * @param {Number} index The index of the rule to possibly
	   *                       terminate.  It might be invalid, so this
	   *                       function must check for that.
	   */
	  maybeTerminateDecl: function (index) {
	    if (index < 0 || index >= this.declarations.length
	        // No need to rewrite declarations in comments.
	        || ("commentOffsets" in this.declarations[index])) {
	      return;
	    }

	    let termDecl = this.declarations[index];
	    let endIndex = termDecl.offsets[1];
	    // Due to an oddity of the lexer, we might have gotten a bit of
	    // extra whitespace in a trailing bad_url token -- so be sure to
	    // skip that as well.
	    endIndex = this.skipWhitespaceBackward(this.result, endIndex) + 1;

	    let trailingText = this.result.substring(endIndex);
	    if (termDecl.terminator) {
	      // Insert the terminator just at the end of the declaration,
	      // before any trailing whitespace.
	      this.result = this.result.substring(0, endIndex) + termDecl.terminator +
	        trailingText;
	      // In a couple of cases, we may have had to add something to
	      // terminate the declaration, but the termination did not
	      // actually affect the property's value -- and at this spot, we
	      // only care about reporting value changes.  In particular, we
	      // might have added a plain ";", or we might have terminated a
	      // comment with "*/;".  Neither of these affect the value.
	      if (termDecl.terminator !== ";" && termDecl.terminator !== "*/;") {
	        this.changedDeclarations[index] =
	          termDecl.value + termDecl.terminator.slice(0, -1);
	      }
	    }
	    // If the rule generally has newlines, but this particular
	    // declaration doesn't have a trailing newline, insert one now.
	    // Maybe this style is too weird to bother with.
	    if (this.hasNewLine && !NEWLINE_RX.test(trailingText)) {
	      this.result += "\n";
	    }
	  },

	  /**
	   * Sanitize the given property value and return the sanitized form.
	   * If the property is rewritten during sanitization, make a note in
	   * |changedDeclarations|.
	   *
	   * @param {String} text The property text.
	   * @param {Number} index The index of the property.
	   * @return {String} The sanitized text.
	   */
	  sanitizeText: function (text, index) {
	    let [anySanitized, sanitizedText] = this.sanitizePropertyValue(text);
	    if (anySanitized) {
	      this.changedDeclarations[index] = sanitizedText;
	    }
	    return sanitizedText;
	  },

	  /**
	   * Rename a declaration.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name current name of the property
	   * @param {String} newName new name of the property
	   */
	  renameProperty: function (index, name, newName) {
	    this.completeInitialization(index);
	    this.result += CSS.escape(newName);
	    // We could conceivably compute the name offsets instead so we
	    // could preserve white space and comments on the LHS of the ":".
	    this.completeCopying(this.decl.colonOffsets[0]);
	  },

	  /**
	   * Enable or disable a declaration
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name current name of the property
	   * @param {Boolean} isEnabled true if the property should be enabled;
	   *                        false if it should be disabled
	   */
	  setPropertyEnabled: function (index, name, isEnabled) {
	    this.completeInitialization(index);
	    const decl = this.decl;
	    let copyOffset = decl.offsets[1];
	    if (isEnabled) {
	      // Enable it.  First see if the comment start can be deleted.
	      let commentStart = decl.commentOffsets[0];
	      if (EMPTY_COMMENT_START_RX.test(this.result.substring(commentStart))) {
	        this.result = this.result.substring(0, commentStart);
	      } else {
	        this.result += "*/ ";
	      }

	      // Insert the name and value separately, so we can report
	      // sanitization changes properly.
	      let commentNamePart =
	          this.inputString.substring(decl.offsets[0],
	                                     decl.colonOffsets[1]);
	      this.result += unescapeCSSComment(commentNamePart);

	      // When uncommenting, we must be sure to sanitize the text, to
	      // avoid things like /* decl: }; */, which will be accepted as
	      // a property but which would break the entire style sheet.
	      let newText = this.inputString.substring(decl.colonOffsets[1],
	                                               decl.offsets[1]);
	      newText = unescapeCSSComment(newText).trimRight();
	      this.result += this.sanitizeText(newText, index) + ";";

	      // See if the comment end can be deleted.
	      let trailingText = this.inputString.substring(decl.offsets[1]);
	      if (EMPTY_COMMENT_END_RX.test(trailingText)) {
	        copyOffset = decl.commentOffsets[1];
	      } else {
	        this.result += " /*";
	      }
	    } else {
	      // Disable it.  Note that we use our special comment syntax
	      // here.
	      let declText = this.inputString.substring(decl.offsets[0],
	                                                decl.offsets[1]);
	      this.result += "/*" + COMMENT_PARSING_HEURISTIC_BYPASS_CHAR +
	        " " + escapeCSSComment(declText) + " */";
	    }
	    this.completeCopying(copyOffset);
	  },

	  /**
	   * Return a promise that will be resolved to the default indentation
	   * of the rule.  This is a helper for internalCreateProperty.
	   *
	   * @return {Promise} a promise that will be resolved to a string
	   *         that holds the default indentation that should be used
	   *         for edits to the rule.
	   */
	  getDefaultIndentation: function () {
	    return this.rule.parentStyleSheet.guessIndentation();
	  },

	  /**
	   * An internal function to create a new declaration.  This does all
	   * the work of |createProperty|.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name name of the new property
	   * @param {String} value value of the new property
	   * @param {String} priority priority of the new property; either
	   *                          the empty string or "important"
	   * @return {Promise} a promise that is resolved when the edit has
	   *                   completed
	   */
	  internalCreateProperty: Task.async(function* (index, name, value, priority) {
	    this.completeInitialization(index);
	    let newIndentation = "";
	    if (this.hasNewLine) {
	      if (this.declarations.length > 0) {
	        newIndentation = this.getIndentation(this.inputString,
	                                             this.declarations[0].offsets[0]);
	      } else if (this.defaultIndentation) {
	        newIndentation = this.defaultIndentation;
	      } else {
	        newIndentation = yield this.getDefaultIndentation();
	      }
	    }

	    this.maybeTerminateDecl(index - 1);

	    // If we generally have newlines, and if skipping whitespace
	    // backward stops at a newline, then insert our text before that
	    // whitespace.  This ensures the indentation we computed is what
	    // is actually used.
	    let savedWhitespace = "";
	    if (this.hasNewLine) {
	      let wsOffset = this.skipWhitespaceBackward(this.result,
	                                                 this.result.length);
	      if (this.result[wsOffset] === "\r" || this.result[wsOffset] === "\n") {
	        savedWhitespace = this.result.substring(wsOffset + 1);
	        this.result = this.result.substring(0, wsOffset + 1);
	      }
	    }

	    this.result += newIndentation + CSS.escape(name) + ": " +
	      this.sanitizeText(value, index);

	    if (priority === "important") {
	      this.result += " !important";
	    }
	    this.result += ";";
	    if (this.hasNewLine) {
	      this.result += "\n";
	    }
	    this.result += savedWhitespace;

	    if (this.decl) {
	      // Still want to copy in the declaration previously at this
	      // index.
	      this.completeCopying(this.decl.offsets[0]);
	    }
	  }),

	  /**
	   * Create a new declaration.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name name of the new property
	   * @param {String} value value of the new property
	   * @param {String} priority priority of the new property; either
	   *                          the empty string or "important"
	   */
	  createProperty: function (index, name, value, priority) {
	    this.editPromise = this.internalCreateProperty(index, name, value,
	                                                   priority);
	  },

	  /**
	   * Set a declaration's value.
	   *
	   * @param {Number} index index of the property in the rule.
	   *                       This can be -1 in the case where
	   *                       the rule does not support setRuleText;
	   *                       generally for setting properties
	   *                       on an element's style.
	   * @param {String} name the property's name
	   * @param {String} value the property's value
	   * @param {String} priority the property's priority, either the empty
	   *                          string or "important"
	   */
	  setProperty: function (index, name, value, priority) {
	    this.completeInitialization(index);
	    // We might see a "set" on a previously non-existent property; in
	    // that case, act like "create".
	    if (!this.decl) {
	      this.createProperty(index, name, value, priority);
	      return;
	    }

	    // Note that this assumes that "set" never operates on disabled
	    // properties.
	    this.result += this.inputString.substring(this.decl.offsets[0],
	                                              this.decl.colonOffsets[1]) +
	      this.sanitizeText(value, index);

	    if (priority === "important") {
	      this.result += " !important";
	    }
	    this.result += ";";
	    this.completeCopying(this.decl.offsets[1]);
	  },

	  /**
	   * Remove a declaration.
	   *
	   * @param {Number} index index of the property in the rule.
	   * @param {String} name the name of the property to remove
	   */
	  removeProperty: function (index, name) {
	    this.completeInitialization(index);

	    // If asked to remove a property that does not exist, bail out.
	    if (!this.decl) {
	      return;
	    }

	    let copyOffset = this.decl.offsets[1];
	    // Maybe removing this rule left us with a completely blank
	    // line.  In this case, we'll delete the whole thing.  We only
	    // bother with this if we're looking at sources that already
	    // have a newline somewhere.
	    if (this.hasNewLine) {
	      let nlOffset = this.skipWhitespaceBackward(this.result,
	                                                 this.decl.offsets[0]);
	      if (nlOffset < 0 || this.result[nlOffset] === "\r" ||
	          this.result[nlOffset] === "\n") {
	        let trailingText = this.inputString.substring(copyOffset);
	        let match = BLANK_LINE_RX.exec(trailingText);
	        if (match) {
	          this.result = this.result.substring(0, nlOffset + 1);
	          copyOffset += match[0].length;
	        }
	      }
	    }
	    this.completeCopying(copyOffset);
	  },

	  /**
	   * An internal function to copy any trailing text to the output
	   * string.
	   *
	   * @param {Number} copyOffset Offset into |inputString| of the
	   *        final text to copy to the output string.
	   */
	  completeCopying: function (copyOffset) {
	    // Add the trailing text.
	    this.result += this.inputString.substring(copyOffset);
	  },

	  /**
	   * Apply the modifications in this object to the associated rule.
	   *
	   * @return {Promise} A promise which will be resolved when the modifications
	   *         are complete.
	   */
	  apply: function () {
	    return promise.resolve(this.editPromise).then(() => {
	      return this.rule.setRuleText(this.result);
	    });
	  },

	  /**
	   * Get the result of the rewriting.  This is used for testing.
	   *
	   * @return {object} an object of the form {changed: object, text: string}
	   *                  |changed| is an object where each key is
	   *                  the index of a property whose value had to be
	   *                  rewritten during the sanitization process, and
	   *                  whose value is the new text of the property.
	   *                  |text| is the rewritten text of the rule.
	   */
	  getResult: function () {
	    return {changed: this.changedDeclarations, text: this.result};
	  },
	};

	/**
	 * Returns an array of the parsed CSS selector value and type given a string.
	 *
	 * The components making up the CSS selector can be extracted into 3 different
	 * types: element, attribute and pseudoclass. The object that is appended to
	 * the returned array contains the value related to one of the 3 types described
	 * along with the actual type.
	 *
	 * The following are the 3 types that can be returned in the object signature:
	 * (1) SELECTOR_ATTRIBUTE
	 * (2) SELECTOR_ELEMENT
	 * (3) SELECTOR_PSEUDO_CLASS
	 *
	 * @param {String} value
	 *        The CSS selector text.
	 * @return {Array} an array of objects with the following signature:
	 *         [{ "value": string, "type": integer }, ...]
	 */
	function parsePseudoClassesAndAttributes(value) {
	  if (!value) {
	    throw new Error("empty input string");
	  }

	  let tokens = cssTokenizer(value);
	  let result = [];
	  let current = "";
	  let functionCount = 0;
	  let hasAttribute = false;
	  let hasColon = false;

	  for (let token of tokens) {
	    if (token.tokenType === "ident") {
	      current += value.substring(token.startOffset, token.endOffset);

	      if (hasColon && !functionCount) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
	        }

	        current = "";
	        hasColon = false;
	      }
	    } else if (token.tokenType === "symbol" && token.text === ":") {
	      if (!hasColon) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_ELEMENT });
	        }

	        current = "";
	        hasColon = true;
	      }

	      current += token.text;
	    } else if (token.tokenType === "function") {
	      current += value.substring(token.startOffset, token.endOffset);
	      functionCount++;
	    } else if (token.tokenType === "symbol" && token.text === ")") {
	      current += token.text;

	      if (hasColon && functionCount == 1) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_PSEUDO_CLASS });
	        }

	        current = "";
	        functionCount--;
	        hasColon = false;
	      } else {
	        functionCount--;
	      }
	    } else if (token.tokenType === "symbol" && token.text === "[") {
	      if (!hasAttribute && !functionCount) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_ELEMENT });
	        }

	        current = "";
	        hasAttribute = true;
	      }

	      current += token.text;
	    } else if (token.tokenType === "symbol" && token.text === "]") {
	      current += token.text;

	      if (hasAttribute && !functionCount) {
	        if (current) {
	          result.push({ value: current, type: SELECTOR_ATTRIBUTE });
	        }

	        current = "";
	        hasAttribute = false;
	      }
	    } else {
	      current += value.substring(token.startOffset, token.endOffset);
	    }
	  }

	  if (current) {
	    result.push({ value: current, type: SELECTOR_ELEMENT });
	  }

	  return result;
	}

	/**
	 * Expects a single CSS value to be passed as the input and parses the value
	 * and priority.
	 *
	 * @param {Function} isCssPropertyKnown
	 *        A function to check if the CSS property is known. This is either an
	 *        internal server function or from the CssPropertiesFront.
	 *        that are supported by the server.
	 * @param {String} value
	 *        The value from the text editor.
	 * @return {Object} an object with 'value' and 'priority' properties.
	 */
	function parseSingleValue(isCssPropertyKnown, value) {
	  let declaration = parseDeclarations(isCssPropertyKnown,
	                                      "a: " + value + ";")[0];
	  return {
	    value: declaration ? declaration.value : "",
	    priority: declaration ? declaration.priority : ""
	  };
	}

	exports.cssTokenizer = cssTokenizer;
	exports.cssTokenizerWithLineColumn = cssTokenizerWithLineColumn;
	exports.escapeCSSComment = escapeCSSComment;
	// unescapeCSSComment is exported for testing.
	exports._unescapeCSSComment = unescapeCSSComment;
	exports.parseDeclarations = parseDeclarations;
	// parseCommentDeclarations is exported for testing.
	exports._parseCommentDeclarations = parseCommentDeclarations;
	exports.RuleRewriter = RuleRewriter;
	exports.parsePseudoClassesAndAttributes = parsePseudoClassesAndAttributes;
	exports.parseSingleValue = parseSingleValue;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	// The style-inspector overlays are:
	// - tooltips that appear when hovering over property values
	// - editor tooltips that appear when clicking color swatches, etc.
	// - in-content highlighters that appear when hovering over property values
	// - etc.

	const {getColor} = __webpack_require__(184);
	const {HTMLTooltip} = __webpack_require__(186);
	const {
	  getImageDimensions,
	  setImageTooltip,
	  setBrokenImageTooltip,
	} = __webpack_require__(189);
	const {
	  CssDocsTooltip,
	} = __webpack_require__(190);
	const {
	  SwatchColorPickerTooltip,
	  SwatchCubicBezierTooltip,
	  SwatchFilterTooltip
	} = __webpack_require__(192);
	const EventEmitter = __webpack_require__(6);
	const promise = __webpack_require__(4);
	const {Task} = __webpack_require__(15);
	const Services = __webpack_require__(1);

	const PREF_IMAGE_TOOLTIP_SIZE = "devtools.inspector.imagePreviewTooltipSize";

	// Types of existing tooltips
	const TOOLTIP_IMAGE_TYPE = "image";
	const TOOLTIP_FONTFAMILY_TYPE = "font-family";

	// Types of nodes in the rule/computed-view
	const VIEW_NODE_SELECTOR_TYPE = 1;
	exports.VIEW_NODE_SELECTOR_TYPE = VIEW_NODE_SELECTOR_TYPE;
	const VIEW_NODE_PROPERTY_TYPE = 2;
	exports.VIEW_NODE_PROPERTY_TYPE = VIEW_NODE_PROPERTY_TYPE;
	const VIEW_NODE_VALUE_TYPE = 3;
	exports.VIEW_NODE_VALUE_TYPE = VIEW_NODE_VALUE_TYPE;
	const VIEW_NODE_IMAGE_URL_TYPE = 4;
	exports.VIEW_NODE_IMAGE_URL_TYPE = VIEW_NODE_IMAGE_URL_TYPE;
	const VIEW_NODE_LOCATION_TYPE = 5;
	exports.VIEW_NODE_LOCATION_TYPE = VIEW_NODE_LOCATION_TYPE;

	/**
	 * Manages all highlighters in the style-inspector.
	 *
	 * @param {CssRuleView|CssComputedView} view
	 *        Either the rule-view or computed-view panel
	 */
	function HighlightersOverlay(view) {
	  this.view = view;

	  let {CssRuleView} = __webpack_require__(198);
	  this.isRuleView = view instanceof CssRuleView;

	  this.highlighterUtils = this.view.inspector.toolbox.highlighterUtils;

	  this._onMouseMove = this._onMouseMove.bind(this);
	  this._onMouseOut = this._onMouseOut.bind(this);

	  this.highlighters = {};

	  // Only initialize the overlay if at least one of the highlighter types is
	  // supported
	  this.supportsHighlighters =
	    this.highlighterUtils.supportsCustomHighlighters();

	  EventEmitter.decorate(this);
	}

	exports.HighlightersOverlay = HighlightersOverlay;

	HighlightersOverlay.prototype = {
	  /**
	   * Add the highlighters overlay to the view. This will start tracking mouse
	   * movements and display highlighters when needed
	   */
	  addToView: function () {
	    if (!this.supportsHighlighters || this._isStarted || this._isDestroyed) {
	      return;
	    }

	    let el = this.view.element;
	    el.addEventListener("mousemove", this._onMouseMove, false);
	    el.addEventListener("mouseout", this._onMouseOut, false);
	    el.ownerDocument.defaultView.addEventListener("mouseout", this._onMouseOut, false);

	    this._isStarted = true;
	  },

	  /**
	   * Remove the overlay from the current view. This will stop tracking mouse
	   * movement and showing highlighters
	   */
	  removeFromView: function () {
	    if (!this.supportsHighlighters || !this._isStarted || this._isDestroyed) {
	      return;
	    }

	    this._hideCurrent();

	    let el = this.view.element;
	    el.removeEventListener("mousemove", this._onMouseMove, false);
	    el.removeEventListener("mouseout", this._onMouseOut, false);

	    this._isStarted = false;
	  },

	  _onMouseMove: function (event) {
	    // Bail out if the target is the same as for the last mousemove
	    if (event.target === this._lastHovered) {
	      return;
	    }

	    // Only one highlighter can be displayed at a time, hide the currently shown
	    this._hideCurrent();

	    this._lastHovered = event.target;

	    let nodeInfo = this.view.getNodeInfo(event.target);
	    if (!nodeInfo) {
	      return;
	    }

	    // Choose the type of highlighter required for the hovered node
	    let type;
	    if (this._isRuleViewTransform(nodeInfo) ||
	        this._isComputedViewTransform(nodeInfo)) {
	      type = "CssTransformHighlighter";
	    }

	    if (type) {
	      this.highlighterShown = type;
	      let node = this.view.inspector.selection.nodeFront;
	      this._getHighlighter(type)
	          .then(highlighter => highlighter.show(node))
	          .then(shown => {
	            if (shown) {
	              this.emit("highlighter-shown");
	            }
	          });
	    }
	  },

	  _onMouseOut: function (event) {
	    // Only hide the highlighter if the mouse leaves the currently hovered node.
	    if (!this._lastHovered ||
	        (event && this._lastHovered.contains(event.relatedTarget))) {
	      return;
	    }

	    // Otherwise, hide the highlighter.
	    this._lastHovered = null;
	    this._hideCurrent();
	  },

	  /**
	   * Is the current hovered node a css transform property value in the rule-view
	   *
	   * @param {Object} nodeInfo
	   * @return {Boolean}
	   */
	  _isRuleViewTransform: function (nodeInfo) {
	    let isTransform = nodeInfo.type === VIEW_NODE_VALUE_TYPE &&
	                      nodeInfo.value.property === "transform";
	    let isEnabled = nodeInfo.value.enabled &&
	                    !nodeInfo.value.overridden &&
	                    !nodeInfo.value.pseudoElement;
	    return this.isRuleView && isTransform && isEnabled;
	  },

	  /**
	   * Is the current hovered node a css transform property value in the
	   * computed-view
	   *
	   * @param {Object} nodeInfo
	   * @return {Boolean}
	   */
	  _isComputedViewTransform: function (nodeInfo) {
	    let isTransform = nodeInfo.type === VIEW_NODE_VALUE_TYPE &&
	                      nodeInfo.value.property === "transform";
	    return !this.isRuleView && isTransform;
	  },

	  /**
	   * Hide the currently shown highlighter
	   */
	  _hideCurrent: function () {
	    if (!this.highlighterShown || !this.highlighters[this.highlighterShown]) {
	      return;
	    }

	    // For some reason, the call to highlighter.hide doesn't always return a
	    // promise. This causes some tests to fail when trying to install a
	    // rejection handler on the result of the call. To avoid this, check
	    // whether the result is truthy before installing the handler.
	    let onHidden = this.highlighters[this.highlighterShown].hide();
	    if (onHidden) {
	      onHidden.then(null, e => console.error(e));
	    }

	    this.highlighterShown = null;
	    this.emit("highlighter-hidden");
	  },

	  /**
	   * Get a highlighter front given a type. It will only be initialized once
	   * @param {String} type The highlighter type. One of this.highlighters
	   * @return a promise that resolves to the highlighter
	   */
	  _getHighlighter: function (type) {
	    let utils = this.highlighterUtils;

	    if (this.highlighters[type]) {
	      return promise.resolve(this.highlighters[type]);
	    }

	    return utils.getHighlighterByType(type).then(highlighter => {
	      this.highlighters[type] = highlighter;
	      return highlighter;
	    });
	  },

	  /**
	   * Destroy this overlay instance, removing it from the view and destroying
	   * all initialized highlighters
	   */
	  destroy: function () {
	    this.removeFromView();

	    for (let type in this.highlighters) {
	      if (this.highlighters[type]) {
	        this.highlighters[type].finalize();
	        this.highlighters[type] = null;
	      }
	    }

	    this.view = null;
	    this.highlighterUtils = null;

	    this._isDestroyed = true;
	  }
	};

	/**
	 * Manages all tooltips in the style-inspector.
	 *
	 * @param {CssRuleView|CssComputedView} view
	 *        Either the rule-view or computed-view panel
	 */
	function TooltipsOverlay(view) {
	  this.view = view;

	  let {CssRuleView} = __webpack_require__(198);
	  this.isRuleView = view instanceof CssRuleView;

	  this._onNewSelection = this._onNewSelection.bind(this);
	  this.view.inspector.selection.on("new-node-front", this._onNewSelection);
	}

	exports.TooltipsOverlay = TooltipsOverlay;

	TooltipsOverlay.prototype = {
	  get isEditing() {
	    return this.colorPicker.tooltip.isVisible() ||
	           this.colorPicker.eyedropperOpen ||
	           this.cubicBezier.tooltip.isVisible() ||
	           this.filterEditor.tooltip.isVisible();
	  },

	  /**
	   * Add the tooltips overlay to the view. This will start tracking mouse
	   * movements and display tooltips when needed
	   */
	  addToView: function () {
	    if (this._isStarted || this._isDestroyed) {
	      return;
	    }

	    let { toolbox } = this.view.inspector;

	    // Image, fonts, ... preview tooltip
	    this.previewTooltip = new HTMLTooltip(toolbox, {
	      type: "arrow",
	      useXulWrapper: true
	    });
	    this.previewTooltip.startTogglingOnHover(this.view.element,
	      this._onPreviewTooltipTargetHover.bind(this));

	    // MDN CSS help tooltip
	    this.cssDocs = new CssDocsTooltip(toolbox);

	    if (this.isRuleView) {
	      // Color picker tooltip
	      this.colorPicker = new SwatchColorPickerTooltip(toolbox, this.view.inspector);
	      // Cubic bezier tooltip
	      this.cubicBezier = new SwatchCubicBezierTooltip(toolbox);
	      // Filter editor tooltip
	      this.filterEditor = new SwatchFilterTooltip(toolbox);
	    }

	    this._isStarted = true;
	  },

	  /**
	   * Remove the tooltips overlay from the view. This will stop tracking mouse
	   * movements and displaying tooltips
	   */
	  removeFromView: function () {
	    if (!this._isStarted || this._isDestroyed) {
	      return;
	    }

	    this.previewTooltip.stopTogglingOnHover(this.view.element);
	    this.previewTooltip.destroy();

	    if (this.colorPicker) {
	      this.colorPicker.destroy();
	    }

	    if (this.cubicBezier) {
	      this.cubicBezier.destroy();
	    }

	    if (this.cssDocs) {
	      this.cssDocs.destroy();
	    }

	    if (this.filterEditor) {
	      this.filterEditor.destroy();
	    }

	    this._isStarted = false;
	  },

	  /**
	   * Given a hovered node info, find out which type of tooltip should be shown,
	   * if any
	   *
	   * @param {Object} nodeInfo
	   * @return {String} The tooltip type to be shown, or null
	   */
	  _getTooltipType: function ({type, value: prop}) {
	    let tooltipType = null;
	    let inspector = this.view.inspector;

	    // Image preview tooltip
	    if (type === VIEW_NODE_IMAGE_URL_TYPE &&
	        inspector.hasUrlToImageDataResolver) {
	      tooltipType = TOOLTIP_IMAGE_TYPE;
	    }

	    // Font preview tooltip
	    if (type === VIEW_NODE_VALUE_TYPE && prop.property === "font-family") {
	      let value = prop.value.toLowerCase();
	      if (value !== "inherit" && value !== "unset" && value !== "initial") {
	        tooltipType = TOOLTIP_FONTFAMILY_TYPE;
	      }
	    }

	    return tooltipType;
	  },

	  /**
	   * Executed by the tooltip when the pointer hovers over an element of the
	   * view. Used to decide whether the tooltip should be shown or not and to
	   * actually put content in it.
	   * Checks if the hovered target is a css value we support tooltips for.
	   *
	   * @param {DOMNode} target The currently hovered node
	   * @return {Promise}
	   */
	  _onPreviewTooltipTargetHover: Task.async(function* (target) {
	    let nodeInfo = this.view.getNodeInfo(target);
	    if (!nodeInfo) {
	      // The hovered node isn't something we care about
	      return false;
	    }

	    let type = this._getTooltipType(nodeInfo);
	    if (!type) {
	      // There is no tooltip type defined for the hovered node
	      return false;
	    }

	    if (this.isRuleView && this.colorPicker.tooltip.isVisible()) {
	      this.colorPicker.revert();
	      this.colorPicker.hide();
	    }

	    if (this.isRuleView && this.cubicBezier.tooltip.isVisible()) {
	      this.cubicBezier.revert();
	      this.cubicBezier.hide();
	    }

	    if (this.isRuleView && this.cssDocs.tooltip.isVisible()) {
	      this.cssDocs.hide();
	    }

	    if (this.isRuleView && this.filterEditor.tooltip.isVisible()) {
	      this.filterEditor.revert();
	      this.filterEdtior.hide();
	    }

	    let inspector = this.view.inspector;

	    if (type === TOOLTIP_IMAGE_TYPE) {
	      try {
	        yield this._setImagePreviewTooltip(nodeInfo.value.url);
	      } catch (e) {
	        yield setBrokenImageTooltip(this.previewTooltip, this.view.inspector.panelDoc);
	      }
	      return true;
	    }

	    if (type === TOOLTIP_FONTFAMILY_TYPE) {
	      let font = nodeInfo.value.value;
	      let nodeFront = inspector.selection.nodeFront;
	      yield this._setFontPreviewTooltip(font, nodeFront);
	      return true;
	    }

	    return false;
	  }),

	  /**
	   * Set the content of the preview tooltip to display an image preview. The image URL can
	   * be relative, a call will be made to the debuggee to retrieve the image content as an
	   * imageData URI.
	   *
	   * @param {String} imageUrl
	   *        The image url value (may be relative or absolute).
	   * @return {Promise} A promise that resolves when the preview tooltip content is ready
	   */
	  _setImagePreviewTooltip: Task.async(function* (imageUrl) {
	    let doc = this.view.inspector.panelDoc;
	    let maxDim = Services.prefs.getIntPref(PREF_IMAGE_TOOLTIP_SIZE);

	    let naturalWidth, naturalHeight;
	    if (imageUrl.startsWith("data:")) {
	      // If the imageUrl already is a data-url, save ourselves a round-trip
	      let size = yield getImageDimensions(doc, imageUrl);
	      naturalWidth = size.naturalWidth;
	      naturalHeight = size.naturalHeight;
	    } else {
	      let inspectorFront = this.view.inspector.inspector;
	      let {data, size} = yield inspectorFront.getImageDataFromURL(imageUrl, maxDim);
	      imageUrl = yield data.string();
	      naturalWidth = size.naturalWidth;
	      naturalHeight = size.naturalHeight;
	    }

	    yield setImageTooltip(this.previewTooltip, doc, imageUrl,
	      {maxDim, naturalWidth, naturalHeight});
	  }),

	  /**
	   * Set the content of the preview tooltip to display a font family preview.
	   *
	   * @param {String} font
	   *        The font family value.
	   * @param {object} nodeFront
	   *        The NodeActor that will used to retrieve the dataURL for the font
	   *        family tooltip contents.
	   * @return {Promise} A promise that resolves when the preview tooltip content is ready
	   */
	  _setFontPreviewTooltip: Task.async(function* (font, nodeFront) {
	    if (!font || !nodeFront || typeof nodeFront.getFontFamilyDataURL !== "function") {
	      throw new Error("Unable to create font preview tooltip content.");
	    }

	    font = font.replace(/"/g, "'");
	    font = font.replace("!important", "");
	    font = font.trim();

	    let fillStyle = getColor("body-color");
	    let {data, size: maxDim} = yield nodeFront.getFontFamilyDataURL(font, fillStyle);

	    let imageUrl = yield data.string();
	    let doc = this.view.inspector.panelDoc;
	    let {naturalWidth, naturalHeight} = yield getImageDimensions(doc, imageUrl);

	    yield setImageTooltip(this.previewTooltip, doc, imageUrl,
	      {hideDimensionLabel: true, maxDim, naturalWidth, naturalHeight});
	  }),

	  _onNewSelection: function () {
	    if (this.previewTooltip) {
	      this.previewTooltip.hide();
	    }

	    if (this.colorPicker) {
	      this.colorPicker.hide();
	    }

	    if (this.cubicBezier) {
	      this.cubicBezier.hide();
	    }

	    if (this.cssDocs) {
	      this.cssDocs.hide();
	    }

	    if (this.filterEditor) {
	      this.filterEditor.hide();
	    }
	  },

	  /**
	   * Destroy this overlay instance, removing it from the view
	   */
	  destroy: function () {
	    this.removeFromView();

	    this.view.inspector.selection.off("new-node-front", this._onNewSelection);
	    this.view = null;

	    this._isDestroyed = true;
	  }
	};


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Colors for themes taken from:
	 * https://developer.mozilla.org/en-US/docs/Tools/DevToolsColors
	 */

	const Services = __webpack_require__(1);
	const { gDevTools } = __webpack_require__(38);

	const variableFileContents = __webpack_require__(185);

	const THEME_SELECTOR_STRINGS = {
	  light: ":root.theme-light {",
	  dark: ":root.theme-dark {"
	};

	/**
	 * Takes a theme name and returns the contents of its variable rule block.
	 * The first time this runs fetches the variables CSS file and caches it.
	 */
	function getThemeFile(name) {
	  // If there's no theme expected for this name, use `light` as default.
	  let selector = THEME_SELECTOR_STRINGS[name] ||
	                 THEME_SELECTOR_STRINGS.light;

	  // This is a pretty naive way to find the contents between:
	  // selector {
	  //   name: val;
	  // }
	  // There is test coverage for this feature (browser_theme.js)
	  // so if an } is introduced in the variables file it will catch that.
	  let theme = variableFileContents;
	  theme = theme.substring(theme.indexOf(selector));
	  theme = theme.substring(0, theme.indexOf("}"));

	  return theme;
	}

	/**
	 * Returns the string value of the current theme,
	 * like "dark" or "light".
	 */
	const getTheme = exports.getTheme = () => {
	  return Services.prefs.getCharPref("devtools.theme");
	};

	/**
	 * Returns a color indicated by `type` (like "toolbar-background", or
	 * "highlight-red"), with the ability to specify a theme, or use whatever the
	 * current theme is if left unset. If theme not found, falls back to "light"
	 * theme. Returns null if the type cannot be found for the theme given.
	 */
	/* eslint-disable no-unused-vars */
	const getColor = exports.getColor = (type, theme) => {
	  let themeName = theme || getTheme();
	  let themeFile = getThemeFile(themeName);
	  let match = themeFile.match(new RegExp("--theme-" + type + ": (.*);"));

	  // Return the appropriate variable in the theme, or otherwise, null.
	  return match ? match[1] : null;
	};

	/**
	 * Mimics selecting the theme selector in the toolbox;
	 * sets the preference and emits an event on gDevTools to trigger
	 * the themeing.
	 */
	const setTheme = exports.setTheme = (newTheme) => {
	  let oldTheme = getTheme();

	  Services.prefs.setCharPref("devtools.theme", newTheme);
	  gDevTools.emit("pref-changed", {
	    pref: "devtools.theme",
	    newValue: newTheme,
	    oldValue: oldTheme
	  });
	};
	/* eslint-enable */


/***/ },
/* 185 */
/***/ function(module, exports) {

	module.exports = "/* vim:set ts=2 sw=2 sts=2 et: */\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n/* Variable declarations for light and dark devtools themes.\n * Colors are taken from:\n * https://developer.mozilla.org/en-US/docs/Tools/DevToolsColors.\n * Changes should be kept in sync with commandline.css and commandline.inc.css.\n */\n\n/* IMPORTANT NOTE:\n * This file is parsed in js (see client/shared/theme.js)\n * so the formatting should be consistent (i.e. no '}' inside a rule).\n */\n\n:root.theme-light {\n  --theme-body-background: white;\n  --theme-sidebar-background: white;\n  --theme-contrast-background: #e6b064;\n\n  --theme-tab-toolbar-background: #fcfcfc;\n  --theme-toolbar-background: #fcfcfc;\n  --theme-selection-background: #4c9ed9;\n  --theme-selection-background-semitransparent: rgba(76, 158, 217, 0.15);\n  --theme-selection-color: #f5f7fa;\n  --theme-splitter-color: #dde1e4;\n  --theme-comment: #696969;\n\n  --theme-body-color: #393f4c;\n  --theme-body-color-alt: #585959;\n  --theme-body-color-inactive: #999797;\n  --theme-content-color1: #292e33;\n  --theme-content-color2: #8fa1b2;\n  --theme-content-color3: #667380;\n\n  --theme-highlight-green: #2cbb0f;\n  --theme-highlight-blue: #0088cc;\n  --theme-highlight-bluegrey: #0072ab;\n  --theme-highlight-purple: #5b5fff;\n  --theme-highlight-lightorange: #d97e00;\n  --theme-highlight-orange: #f13c00;\n  --theme-highlight-red: #ed2655;\n  --theme-highlight-pink: #b82ee5;\n  --theme-highlight-gray: #dde1e4;\n\n  /* For accessibility purposes we want to enhance the focus styling. This\n   * should improve keyboard navigation usability. */\n  --theme-focus-outline-color: #000000;\n\n  /* Colors used in Graphs, like performance tools. Similar colors to Chrome's timeline. */\n  --theme-graphs-green: #85d175;\n  --theme-graphs-blue: #83b7f6;\n  --theme-graphs-bluegrey: #0072ab;\n  --theme-graphs-purple: #b693eb;\n  --theme-graphs-yellow: #efc052;\n  --theme-graphs-orange: #d97e00;\n  --theme-graphs-red: #e57180;\n  --theme-graphs-grey: #cccccc;\n  --theme-graphs-full-red: #f00;\n  --theme-graphs-full-blue: #00f;\n\n  /* Images */\n  --theme-pane-collapse-image: url(chrome://devtools/skin/images/pane-collapse.svg);\n  --theme-pane-expand-image: url(chrome://devtools/skin/images/pane-expand.svg);\n\n  /* Tooltips */\n  --theme-tooltip-border: #d9e1e8;\n  --theme-tooltip-background: rgba(255, 255, 255, .9);\n  --theme-tooltip-shadow: rgba(155, 155, 155, 0.26);\n\n  /* Command line */\n  --theme-command-line-image: url(chrome://devtools/skin/images/commandline-icon.svg#light-theme);\n  --theme-command-line-image-focus: url(chrome://devtools/skin/images/commandline-icon.svg#light-theme-focus);\n}\n\n:root.theme-dark {\n  --theme-body-background: #393f4c;\n  --theme-sidebar-background: #393f4c;\n  --theme-contrast-background: #ffb35b;\n\n  --theme-tab-toolbar-background: #272b35;\n  --theme-toolbar-background: #272b35;\n  --theme-selection-background: #5675B9;\n  --theme-selection-background-semitransparent: rgba(86, 117, 185, 0.5);\n  --theme-selection-color: #f5f7fa;\n  --theme-splitter-color: #454d5d;\n  --theme-comment: #757873;\n\n  --theme-body-color: #8fa1b2;\n  --theme-body-color-alt: #b6babf;\n  --theme-body-color-inactive: #8fa1b2;\n  --theme-content-color1: #a9bacb;\n  --theme-content-color2: #8fa1b2;\n  --theme-content-color3: #5f7387;\n\n  --theme-highlight-green: #00ff7f;\n  --theme-highlight-blue: #46afe3;\n  --theme-highlight-bluegrey: #5e88b0;\n  --theme-highlight-purple: #bcb8db;\n  --theme-highlight-lightorange: #d99b28;\n  --theme-highlight-orange: #d96629;\n  --theme-highlight-red: #eb5368;\n  --theme-highlight-pink: #df80ff;\n  --theme-highlight-gray: #e9f4fe;\n\n  /* For accessibility purposes we want to enhance the focus styling. This\n   * should improve keyboard navigation usability. */\n  --theme-focus-outline-color: #ced3d9;\n\n  /* Colors used in Graphs, like performance tools. Mostly similar to some \"highlight-*\" colors. */\n  --theme-graphs-green: #70bf53;\n  --theme-graphs-blue: #46afe3;\n  --theme-graphs-bluegrey: #5e88b0;\n  --theme-graphs-purple: #df80ff;\n  --theme-graphs-yellow: #d99b28;\n  --theme-graphs-orange: #d96629;\n  --theme-graphs-red: #eb5368;\n  --theme-graphs-grey: #757873;\n  --theme-graphs-full-red: #f00;\n  --theme-graphs-full-blue: #00f;\n\n  /* Images */\n  --theme-pane-collapse-image: url(chrome://devtools/skin/images/pane-collapse.svg);\n  --theme-pane-expand-image: url(chrome://devtools/skin/images/pane-expand.svg);\n\n  /* Tooltips */\n  --theme-tooltip-border: #434850;\n  --theme-tooltip-background: rgba(19, 28, 38, .9);\n  --theme-tooltip-shadow: rgba(25, 25, 25, 0.76);\n\n  /* Command line */\n  --theme-command-line-image: url(chrome://devtools/skin/images/commandline-icon.svg#dark-theme);\n  --theme-command-line-image-focus: url(chrome://devtools/skin/images/commandline-icon.svg#dark-theme-focus);\n}\n\n:root.theme-firebug {\n  --theme-body-background: #fcfcfc;\n  --theme-sidebar-background: #fcfcfc;\n  --theme-contrast-background: #e6b064;\n\n  --theme-tab-toolbar-background: #ebeced;\n  --theme-toolbar-background: #f0f1f2;\n  --theme-selection-background: #3399ff;\n  --theme-selection-background-semitransparent: rgba(128,128,128,0.2);\n  --theme-selection-color: white;\n  --theme-splitter-color: #aabccf;\n  --theme-comment: green;\n\n  --theme-body-color: #18191a;\n  --theme-body-color-alt: #585959;\n  --theme-content-color1: #292e33;\n  --theme-content-color2: #8fa1b2;\n  --theme-content-color3: #667380;\n\n  --theme-highlight-green: #2cbb0f;\n  --theme-highlight-blue: #3455db;\n  --theme-highlight-bluegrey: #0072ab;\n  --theme-highlight-purple: #887ce6;\n  --theme-highlight-lightorange: #d97e00;\n  --theme-highlight-orange: #f13c00;\n  --theme-highlight-red: #e22f6f;\n  --theme-highlight-pink: #b82ee5;\n  --theme-highlight-gray: #dde1e4;\n\n  /* Colors used in Graphs, like performance tools. Similar colors to Chrome's timeline. */\n  --theme-graphs-green: #85d175;\n  --theme-graphs-blue: #83b7f6;\n  --theme-graphs-bluegrey: #0072ab;\n  --theme-graphs-purple: #b693eb;\n  --theme-graphs-yellow: #efc052;\n  --theme-graphs-orange: #d97e00;\n  --theme-graphs-red: #e57180;\n  --theme-graphs-grey: #cccccc;\n  --theme-graphs-full-red: #f00;\n  --theme-graphs-full-blue: #00f;\n\n  /* Images */\n  --theme-pane-collapse-image: url(chrome://devtools/skin/images/firebug/pane-collapse.svg);\n  --theme-pane-expand-image: url(chrome://devtools/skin/images/firebug/pane-expand.svg);\n\n  /* Font size */\n  --theme-toolbar-font-size: 12px;\n\n  /* Header */\n  --theme-header-background: #F0F0F0 linear-gradient(to top,\n                                                     rgba(0, 0, 0, 0.1),\n                                                     transparent) repeat-x;\n\n  /* Command line */\n  --theme-command-line-image: url(chrome://devtools/skin/images/firebug/commandline-icon.svg);\n  --theme-command-line-image-focus: url(chrome://devtools/skin/images/firebug/commandline-icon.svg#focus);\n}\n\n:root {\n  --theme-focus-border-color-textbox: #0675d3;\n  --theme-textbox-box-shadow: rgba(97,181,255,.75);\n\n  /* For accessibility purposes we want to enhance the focus styling. This\n   * should improve keyboard navigation usability. */\n  --theme-focus-outline: 1px dotted var(--theme-focus-outline-color);\n  --theme-focus-box-shadow-textbox: 0 0 0 1px var(--theme-textbox-box-shadow);\n}\n"

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const EventEmitter = __webpack_require__(6);
	const {TooltipToggle} = __webpack_require__(187);
	const {listenOnce} = __webpack_require__(188);
	const {Task} = __webpack_require__(15);

	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	const POSITION = {
	  TOP: "top",
	  BOTTOM: "bottom",
	};

	module.exports.POSITION = POSITION;

	const TYPE = {
	  NORMAL: "normal",
	  ARROW: "arrow",
	};

	module.exports.TYPE = TYPE;

	const ARROW_WIDTH = 32;

	// Default offset between the tooltip's left edge and the tooltip arrow.
	const ARROW_OFFSET = 20;

	const EXTRA_HEIGHT = {
	  "normal": 0,
	  // The arrow is 16px tall, but merges on 3px with the panel border
	  "arrow": 13,
	};

	const EXTRA_BORDER = {
	  "normal": 0,
	  "arrow": 3,
	};

	/**
	 * Calculate the vertical position & offsets to use for the tooltip. Will attempt to
	 * respect the provided height and position preferences, unless the available height
	 * prevents this.
	 *
	 * @param {DOMRect} anchorRect
	 *        Bounding rectangle for the anchor, relative to the tooltip document.
	 * @param {DOMRect} viewportRect
	 *        Bounding rectangle for the viewport. top/left can be different from 0 if some
	 *        space should not be used by tooltips (for instance OS toolbars, taskbars etc.).
	 * @param {Number} height
	 *        Preferred height for the tooltip.
	 * @param {String} pos
	 *        Preferred position for the tooltip. Possible values: "top" or "bottom".
	 * @return {Object}
	 *         - {Number} top: the top offset for the tooltip.
	 *         - {Number} height: the height to use for the tooltip container.
	 *         - {String} computedPosition: Can differ from the preferred position depending
	 *           on the available height). "top" or "bottom"
	 */
	const calculateVerticalPosition =
	function (anchorRect, viewportRect, height, pos, offset) {
	  let {TOP, BOTTOM} = POSITION;

	  let {top: anchorTop, height: anchorHeight} = anchorRect;

	  // Translate to the available viewport space before calculating dimensions and position.
	  anchorTop -= viewportRect.top;

	  // Calculate available space for the tooltip.
	  let availableTop = anchorTop;
	  let availableBottom = viewportRect.height - (anchorTop + anchorHeight);

	  // Find POSITION
	  let keepPosition = false;
	  if (pos === TOP) {
	    keepPosition = availableTop >= height + offset;
	  } else if (pos === BOTTOM) {
	    keepPosition = availableBottom >= height + offset;
	  }
	  if (!keepPosition) {
	    pos = availableTop > availableBottom ? TOP : BOTTOM;
	  }

	  // Calculate HEIGHT.
	  let availableHeight = pos === TOP ? availableTop : availableBottom;
	  height = Math.min(height, availableHeight - offset);
	  height = Math.floor(height);

	  // Calculate TOP.
	  let top = pos === TOP ? anchorTop - height - offset : anchorTop + anchorHeight + offset;

	  // Translate back to absolute coordinates by re-including viewport top margin.
	  top += viewportRect.top;

	  return {top, height, computedPosition: pos};
	};

	/**
	 * Calculate the vertical position & offsets to use for the tooltip. Will attempt to
	 * respect the provided height and position preferences, unless the available height
	 * prevents this.
	 *
	 * @param {DOMRect} anchorRect
	 *        Bounding rectangle for the anchor, relative to the tooltip document.
	 * @param {DOMRect} viewportRect
	 *        Bounding rectangle for the viewport. top/left can be different from 0 if some
	 *        space should not be used by tooltips (for instance OS toolbars, taskbars etc.).
	 * @param {Number} width
	 *        Preferred width for the tooltip.
	 * @param {String} type
	 *        The tooltip type (e.g. "arrow").
	 * @param {Number} offset
	 *        Horizontal offset in pixels.
	 * @param {Boolean} isRtl
	 *        If the anchor is in RTL, the tooltip should be aligned to the right.
	 * @return {Object}
	 *         - {Number} left: the left offset for the tooltip.
	 *         - {Number} width: the width to use for the tooltip container.
	 *         - {Number} arrowLeft: the left offset to use for the arrow element.
	 */
	const calculateHorizontalPosition =
	function (anchorRect, viewportRect, width, type, offset, isRtl) {
	  let anchorWidth = anchorRect.width;
	  let anchorStart = isRtl ? anchorRect.right : anchorRect.left;

	  // Translate to the available viewport space before calculating dimensions and position.
	  anchorStart -= viewportRect.left;

	  // Calculate WIDTH.
	  width = Math.min(width, viewportRect.width);

	  // Calculate LEFT.
	  // By default the tooltip is aligned with the anchor left edge. Unless this
	  // makes it overflow the viewport, in which case is shifts to the left.
	  let left = anchorStart + offset - (isRtl ? width : 0);
	  left = Math.min(left, viewportRect.width - width);
	  left = Math.max(0, left);

	  // Calculate ARROW LEFT (tooltip's LEFT might be updated)
	  let arrowLeft;
	  // Arrow style tooltips may need to be shifted to the left
	  if (type === TYPE.ARROW) {
	    let arrowCenter = left + ARROW_OFFSET + ARROW_WIDTH / 2;
	    let anchorCenter = anchorStart + anchorWidth / 2;
	    // If the anchor is too narrow, align the arrow and the anchor center.
	    if (arrowCenter > anchorCenter) {
	      left = Math.max(0, left - (arrowCenter - anchorCenter));
	    }
	    // Arrow's left offset relative to the anchor.
	    arrowLeft = Math.min(ARROW_OFFSET, (anchorWidth - ARROW_WIDTH) / 2) | 0;
	    // Translate the coordinate to tooltip container
	    arrowLeft += anchorStart - left;
	    // Make sure the arrow remains in the tooltip container.
	    arrowLeft = Math.min(arrowLeft, width - ARROW_WIDTH);
	    arrowLeft = Math.max(arrowLeft, 0);
	  }

	  // Translate back to absolute coordinates by re-including viewport left margin.
	  left += viewportRect.left;

	  return {left, width, arrowLeft};
	};

	/**
	 * Get the bounding client rectangle for a given node, relative to a custom
	 * reference element (instead of the default for getBoundingClientRect which
	 * is always the element's ownerDocument).
	 */
	const getRelativeRect = function (node, relativeTo) {
	  // Width and Height can be taken from the rect.
	  let {width, height} = node.getBoundingClientRect();

	  let quads = node.getBoxQuads({relativeTo});
	  let top = quads[0].bounds.top;
	  let left = quads[0].bounds.left;

	  // Compute right and bottom coordinates using the rest of the data.
	  let right = left + width;
	  let bottom = top + height;

	  return {top, right, bottom, left, width, height};
	};

	/**
	 * The HTMLTooltip can display HTML content in a tooltip popup.
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 * @param {Object}
	 *        - {String} type
	 *          Display type of the tooltip. Possible values: "normal", "arrow"
	 *        - {Boolean} autofocus
	 *          Defaults to false. Should the tooltip be focused when opening it.
	 *        - {Boolean} consumeOutsideClicks
	 *          Defaults to true. The tooltip is closed when clicking outside.
	 *          Should this event be stopped and consumed or not.
	 *        - {Boolean} useXulWrapper
	 *          Defaults to false. If the tooltip is hosted in a XUL document, use a XUL panel
	 *          in order to use all the screen viewport available.
	 *        - {String} stylesheet
	 *          Style sheet URL to apply to the tooltip content.
	 */
	function HTMLTooltip(toolbox, {
	    type = "normal",
	    autofocus = false,
	    consumeOutsideClicks = true,
	    useXulWrapper = false,
	    stylesheet = "",
	  } = {}) {
	  EventEmitter.decorate(this);

	  this.doc = toolbox.doc;
	  this.type = type;
	  this.autofocus = autofocus;
	  this.consumeOutsideClicks = consumeOutsideClicks;
	  this.useXulWrapper = this._isXUL() && useXulWrapper;

	  // The top window is used to attach click event listeners to close the tooltip if the
	  // user clicks on the content page.
	  this.topWindow = this._getTopWindow();

	  this._position = null;

	  this._onClick = this._onClick.bind(this);

	  this._toggle = new TooltipToggle(this);
	  this.startTogglingOnHover = this._toggle.start.bind(this._toggle);
	  this.stopTogglingOnHover = this._toggle.stop.bind(this._toggle);

	  this.container = this._createContainer();

	  if (stylesheet) {
	    this._applyStylesheet(stylesheet);
	  }
	  if (this.useXulWrapper) {
	    // When using a XUL panel as the wrapper, the actual markup for the tooltip is as
	    // follows :
	    // <panel> <!-- XUL panel used to position the tooltip anywhere on screen -->
	    //   <div> <!-- div wrapper used to isolate the tooltip container -->
	    //     <div> <! the actual tooltip.container element -->
	    this.xulPanelWrapper = this._createXulPanelWrapper();
	    let inner = this.doc.createElementNS(XHTML_NS, "div");
	    inner.classList.add("tooltip-xul-wrapper-inner");

	    this.doc.documentElement.appendChild(this.xulPanelWrapper);
	    this.xulPanelWrapper.appendChild(inner);
	    inner.appendChild(this.container);
	  } else if (this._isXUL()) {
	    this.doc.documentElement.appendChild(this.container);
	  } else {
	    // In non-XUL context the container is ready to use as is.
	    this.doc.body.appendChild(this.container);
	  }
	}

	module.exports.HTMLTooltip = HTMLTooltip;

	HTMLTooltip.prototype = {
	  /**
	   * The tooltip panel is the parentNode of the tooltip content provided in
	   * setContent().
	   */
	  get panel() {
	    return this.container.querySelector(".tooltip-panel");
	  },

	  /**
	   * The arrow element. Might be null depending on the tooltip type.
	   */
	  get arrow() {
	    return this.container.querySelector(".tooltip-arrow");
	  },

	  /**
	   * Retrieve the displayed position used for the tooltip. Null if the tooltip is hidden.
	   */
	  get position() {
	    return this.isVisible() ? this._position : null;
	  },

	  /**
	   * Set the tooltip content element. The preferred width/height should also be
	   * specified here.
	   *
	   * @param {Element} content
	   *        The tooltip content, should be a HTML element.
	   * @param {Object}
	   *        - {Number} width: preferred width for the tooltip container. If not specified
	   *          the tooltip container will be measured before being displayed, and the
	   *          measured width will be used as preferred width.
	   *        - {Number} height: optional, preferred height for the tooltip container. If
	   *          not specified, the tooltip will be able to use all the height available.
	   */
	  setContent: function (content, {width = "auto", height = Infinity} = {}) {
	    this.preferredWidth = width;
	    this.preferredHeight = height;

	    this.panel.innerHTML = "";
	    this.panel.appendChild(content);
	  },

	  /**
	   * Show the tooltip next to the provided anchor element. A preferred position
	   * can be set. The event "shown" will be fired after the tooltip is displayed.
	   *
	   * @param {Element} anchor
	   *        The reference element with which the tooltip should be aligned
	   * @param {Object}
	   *        - {String} position: optional, possible values: top|bottom
	   *          If layout permits, the tooltip will be displayed on top/bottom
	   *          of the anchor. If ommitted, the tooltip will be displayed where
	   *          more space is available.
	   *        - {Number} x: optional, horizontal offset between the anchor and the tooltip
	   *        - {Number} y: optional, vertical offset between the anchor and the tooltip
	   */
	  show: Task.async(function* (anchor, {position, x = 0, y = 0} = {}) {
	    // Get anchor geometry
	    let anchorRect = getRelativeRect(anchor, this.doc);
	    if (this.useXulWrapper) {
	      anchorRect = this._convertToScreenRect(anchorRect);
	    }

	    // Get viewport size
	    let viewportRect = this._getViewportRect();

	    let themeHeight = EXTRA_HEIGHT[this.type] + 2 * EXTRA_BORDER[this.type];
	    let preferredHeight = this.preferredHeight + themeHeight;

	    let {top, height, computedPosition} =
	      calculateVerticalPosition(anchorRect, viewportRect, preferredHeight, position, y);

	    this._position = computedPosition;
	    // Apply height before measuring the content width (if width="auto").
	    let isTop = computedPosition === POSITION.TOP;
	    this.container.classList.toggle("tooltip-top", isTop);
	    this.container.classList.toggle("tooltip-bottom", !isTop);

	    // If the preferred height is set to Infinity, the tooltip container should grow based
	    // on its content's height and use as much height as possible.
	    this.container.classList.toggle("tooltip-flexible-height",
	      this.preferredHeight === Infinity);

	    this.container.style.height = height + "px";

	    let preferredWidth;
	    if (this.preferredWidth === "auto") {
	      preferredWidth = this._measureContainerWidth();
	    } else {
	      let themeWidth = 2 * EXTRA_BORDER[this.type];
	      preferredWidth = this.preferredWidth + themeWidth;
	    }

	    let anchorWin = anchor.ownerDocument.defaultView;
	    let isRtl = anchorWin.getComputedStyle(anchor).direction === "rtl";
	    let {left, width, arrowLeft} = calculateHorizontalPosition(
	      anchorRect, viewportRect, preferredWidth, this.type, x, isRtl);

	    this.container.style.width = width + "px";

	    if (this.type === TYPE.ARROW) {
	      this.arrow.style.left = arrowLeft + "px";
	    }

	    if (this.useXulWrapper) {
	      yield this._showXulWrapperAt(left, top);
	    } else {
	      this.container.style.left = left + "px";
	      this.container.style.top = top + "px";
	    }

	    this.container.classList.add("tooltip-visible");

	    // Keep a pointer on the focused element to refocus it when hiding the tooltip.
	    this._focusedElement = this.doc.activeElement;

	    this.doc.defaultView.clearTimeout(this.attachEventsTimer);
	    this.attachEventsTimer = this.doc.defaultView.setTimeout(() => {
	      this._maybeFocusTooltip();
	      // Updated the top window reference each time in case the host changes.
	      this.topWindow = this._getTopWindow();
	      this.topWindow.addEventListener("click", this._onClick, true);
	      this.emit("shown");
	    }, 0);
	  }),

	  /**
	   * Calculate the rect of the viewport that limits the tooltip dimensions. When using a
	   * XUL panel wrapper, the viewport will be able to use the whole screen (excluding space
	   * reserved by the OS for toolbars etc.). Otherwise, the viewport is limited to the
	   * tooltip's document.
	   *
	   * @return {Object} DOMRect-like object with the Number properties: top, right, bottom,
	   *         left, width, height
	   */
	  _getViewportRect: function () {
	    if (this.useXulWrapper) {
	      // availLeft/Top are the coordinates first pixel available on the screen for
	      // applications (excluding space dedicated for OS toolbars, menus etc...)
	      // availWidth/Height are the dimensions available to applications excluding all
	      // the OS reserved space
	      let {availLeft, availTop, availHeight, availWidth} = this.doc.defaultView.screen;
	      return {
	        top: availTop,
	        right: availLeft + availWidth,
	        bottom: availTop + availHeight,
	        left: availLeft,
	        width: availWidth,
	        height: availHeight,
	      };
	    }

	    return this.doc.documentElement.getBoundingClientRect();
	  },

	  _measureContainerWidth: function () {
	    let xulParent = this.container.parentNode;
	    if (this.useXulWrapper && !this.isVisible()) {
	      // Move the container out of the XUL Panel to measure it.
	      this.doc.documentElement.appendChild(this.container);
	    }

	    this.container.classList.add("tooltip-hidden");
	    this.container.style.width = "auto";
	    let width = this.container.getBoundingClientRect().width;
	    this.container.classList.remove("tooltip-hidden");

	    if (this.useXulWrapper && !this.isVisible()) {
	      xulParent.appendChild(this.container);
	    }

	    return width;
	  },

	  /**
	   * Hide the current tooltip. The event "hidden" will be fired when the tooltip
	   * is hidden.
	   */
	  hide: Task.async(function* () {
	    this.doc.defaultView.clearTimeout(this.attachEventsTimer);
	    if (!this.isVisible()) {
	      this.emit("hidden");
	      return;
	    }

	    this.topWindow.removeEventListener("click", this._onClick, true);
	    this.container.classList.remove("tooltip-visible");
	    if (this.useXulWrapper) {
	      yield this._hideXulWrapper();
	    }

	    this.emit("hidden");

	    let tooltipHasFocus = this.container.contains(this.doc.activeElement);
	    if (tooltipHasFocus && this._focusedElement) {
	      this._focusedElement.focus();
	      this._focusedElement = null;
	    }
	  }),

	  /**
	   * Check if the tooltip is currently displayed.
	   * @return {Boolean} true if the tooltip is visible
	   */
	  isVisible: function () {
	    return this.container.classList.contains("tooltip-visible");
	  },

	  /**
	   * Destroy the tooltip instance. Hide the tooltip if displayed, remove the
	   * tooltip container from the document.
	   */
	  destroy: function () {
	    this.hide();
	    this.container.remove();
	    if (this.xulPanelWrapper) {
	      this.xulPanelWrapper.remove();
	    }
	  },

	  _createContainer: function () {
	    let container = this.doc.createElementNS(XHTML_NS, "div");
	    container.setAttribute("type", this.type);
	    container.classList.add("tooltip-container");

	    let html = '<div class="tooltip-filler"></div>';
	    html += '<div class="tooltip-panel"></div>';

	    if (this.type === TYPE.ARROW) {
	      html += '<div class="tooltip-arrow"></div>';
	    }
	    container.innerHTML = html;
	    return container;
	  },

	  _onClick: function (e) {
	    if (this._isInTooltipContainer(e.target)) {
	      return;
	    }

	    this.hide();
	    if (this.consumeOutsideClicks && e.button === 0) {
	      // Consume only left click events (button === 0).
	      e.preventDefault();
	      e.stopPropagation();
	    }
	  },

	  _isInTooltipContainer: function (node) {
	    // Check if the target is the tooltip arrow.
	    if (this.arrow && this.arrow === node) {
	      return true;
	    }

	    let tooltipWindow = this.panel.ownerDocument.defaultView;
	    let win = node.ownerDocument.defaultView;

	    // Check if the tooltip panel contains the node if they live in the same document.
	    if (win === tooltipWindow) {
	      return this.panel.contains(node);
	    }

	    // Check if the node window is in the tooltip container.
	    while (win.parent && win.parent !== win) {
	      if (win.parent === tooltipWindow) {
	        // If the parent window is the tooltip window, check if the tooltip contains
	        // the current frame element.
	        return this.panel.contains(win.frameElement);
	      }
	      win = win.parent;
	    }

	    return false;
	  },

	  /**
	   * If the tootlip is configured to autofocus and a focusable element can be found,
	   * focus it.
	   */
	  _maybeFocusTooltip: function () {
	    // Simplied selector targetting elements that can receive the focus, full version at
	    // http://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus .
	    let focusableSelector = "a, button, iframe, input, select, textarea";
	    let focusableElement = this.panel.querySelector(focusableSelector);
	    if (this.autofocus && focusableElement) {
	      focusableElement.focus();
	    }
	  },

	  _getTopWindow: function () {
	    return this.doc.defaultView.top;
	  },

	  /**
	   * Check if the tooltip's owner document is a XUL document.
	   */
	  _isXUL: function () {
	    return this.doc.documentElement.namespaceURI === XUL_NS;
	  },

	  _createXulPanelWrapper: function () {
	    let panel = this.doc.createElementNS(XUL_NS, "panel");

	    // XUL panel is only a way to display DOM elements outside of the document viewport,
	    // so disable all features that impact the behavior.
	    panel.setAttribute("animate", false);
	    panel.setAttribute("consumeoutsideclicks", false);
	    panel.setAttribute("noautofocus", true);
	    panel.setAttribute("ignorekeys", true);

	    // Use type="arrow" to prevent side effects (see Bug 1285206)
	    panel.setAttribute("type", "arrow");

	    panel.setAttribute("level", "top");
	    panel.setAttribute("class", "tooltip-xul-wrapper");

	    return panel;
	  },

	  _showXulWrapperAt: function (left, top) {
	    let onPanelShown = listenOnce(this.xulPanelWrapper, "popupshown");
	    this.xulPanelWrapper.openPopupAtScreen(left, top, false);
	    return onPanelShown;
	  },

	  _hideXulWrapper: function () {
	    let onPanelHidden = listenOnce(this.xulPanelWrapper, "popuphidden");
	    this.xulPanelWrapper.hidePopup();
	    return onPanelHidden;
	  },

	  /**
	   * Convert from coordinates relative to the tooltip's document, to coordinates relative
	   * to the "available" screen. By "available" we mean the screen, excluding the OS bars
	   * display on screen edges.
	   */
	  _convertToScreenRect: function ({left, top, width, height}) {
	    // mozInnerScreenX/Y are the coordinates of the top left corner of the window's
	    // viewport, excluding chrome UI.
	    left += this.doc.defaultView.mozInnerScreenX;
	    top += this.doc.defaultView.mozInnerScreenY;
	    return {top, right: left + width, bottom: top + height, left, width, height};
	  },

	  /**
	   * Apply a scoped stylesheet to the container so that this css file only
	   * applies to it.
	   */
	  _applyStylesheet: function (url) {
	    let style = this.doc.createElementNS(XHTML_NS, "style");
	    style.setAttribute("scoped", "true");
	    url = url.replace(/"/g, "\\\"");
	    style.textContent = `@import url("${url}");`;
	    this.container.appendChild(style);
	  }
	};


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {Task} = __webpack_require__(15);

	const DEFAULT_TOGGLE_DELAY = 50;

	/**
	 * Tooltip helper designed to show/hide the tooltip when the mouse hovers over
	 * particular nodes.
	 *
	 * This works by tracking mouse movements on a base container node (baseNode)
	 * and showing the tooltip when the mouse stops moving. A callback can be
	 * provided to the start() method to know whether or not the node being
	 * hovered over should indeed receive the tooltip.
	 */
	function TooltipToggle(tooltip) {
	  this.tooltip = tooltip;
	  this.win = tooltip.doc.defaultView;

	  this._onMouseMove = this._onMouseMove.bind(this);
	  this._onMouseOut = this._onMouseOut.bind(this);

	  this._onTooltipMouseOver = this._onTooltipMouseOver.bind(this);
	  this._onTooltipMouseOut = this._onTooltipMouseOut.bind(this);
	}

	module.exports.TooltipToggle = TooltipToggle;

	TooltipToggle.prototype = {
	  /**
	   * Start tracking mouse movements on the provided baseNode to show the
	   * tooltip.
	   *
	   * 2 Ways to make this work:
	   * - Provide a single node to attach the tooltip to, as the baseNode, and
	   *   omit the second targetNodeCb argument
	   * - Provide a baseNode that is the container of possibly numerous children
	   *   elements that may receive a tooltip. In this case, provide the second
	   *   targetNodeCb argument to decide wether or not a child should receive
	   *   a tooltip.
	   *
	   * Note that if you call this function a second time, it will itself call
	   * stop() before adding mouse tracking listeners again.
	   *
	   * @param {node} baseNode
	   *        The container for all target nodes
	   * @param {Function} targetNodeCb
	   *        A function that accepts a node argument and that checks if a tooltip
	   *        should be displayed. Possible return values are:
	   *        - false (or a falsy value) if the tooltip should not be displayed
	   *        - true if the tooltip should be displayed
	   *        - a DOM node to display the tooltip on the returned anchor
	   *        The function can also return a promise that will resolve to one of
	   *        the values listed above.
	   *        If omitted, the tooltip will be shown everytime.
	   * @param {Object} options
	            Set of optional arguments:
	   *        - {Number} toggleDelay
	   *          An optional delay (in ms) that will be observed before showing
	   *          and before hiding the tooltip. Defaults to DEFAULT_TOGGLE_DELAY.
	   *        - {Boolean} interactive
	   *          If enabled, the tooltip is not hidden when mouse leaves the
	   *          target element and enters the tooltip. Allows the tooltip
	   *          content to be interactive.
	   */
	  start: function (baseNode, targetNodeCb,
	                   {toggleDelay = DEFAULT_TOGGLE_DELAY, interactive = false} = {}) {
	    this.stop();

	    if (!baseNode) {
	      // Calling tool is in the process of being destroyed.
	      return;
	    }

	    this._baseNode = baseNode;
	    this._targetNodeCb = targetNodeCb || (() => true);
	    this._toggleDelay = toggleDelay;
	    this._interactive = interactive;

	    baseNode.addEventListener("mousemove", this._onMouseMove);
	    baseNode.addEventListener("mouseout", this._onMouseOut);

	    if (this._interactive) {
	      this.tooltip.container.addEventListener("mouseover", this._onTooltipMouseOver);
	      this.tooltip.container.addEventListener("mouseout", this._onTooltipMouseOut);
	    }
	  },

	  /**
	   * If the start() function has been used previously, and you want to get rid
	   * of this behavior, then call this function to remove the mouse movement
	   * tracking
	   */
	  stop: function () {
	    this.win.clearTimeout(this.toggleTimer);

	    if (!this._baseNode) {
	      return;
	    }

	    this._baseNode.removeEventListener("mousemove", this._onMouseMove);
	    this._baseNode.removeEventListener("mouseout", this._onMouseOut);

	    if (this._interactive) {
	      this.tooltip.container.removeEventListener("mouseover", this._onTooltipMouseOver);
	      this.tooltip.container.removeEventListener("mouseout", this._onTooltipMouseOut);
	    }

	    this._baseNode = null;
	    this._targetNodeCb = null;
	    this._lastHovered = null;
	  },

	  _onMouseMove: function (event) {
	    if (event.target !== this._lastHovered) {
	      this._lastHovered = event.target;

	      this.win.clearTimeout(this.toggleTimer);
	      this.toggleTimer = this.win.setTimeout(() => {
	        this.tooltip.hide();
	        this.isValidHoverTarget(event.target).then(target => {
	          if (target === null) {
	            return;
	          }
	          this.tooltip.show(target);
	        }, reason => {
	          console.error("isValidHoverTarget rejected with unexpected reason:");
	          console.error(reason);
	        });
	      }, this._toggleDelay);
	    }
	  },

	  /**
	   * Is the given target DOMNode a valid node for toggling the tooltip on hover.
	   * This delegates to the user-defined _targetNodeCb callback.
	   * @return {Promise} a promise that will resolve the anchor to use for the
	   *         tooltip or null if no valid target was found.
	   */
	  isValidHoverTarget: Task.async(function* (target) {
	    let res = yield this._targetNodeCb(target, this.tooltip);
	    if (res) {
	      return res.nodeName ? res : target;
	    }

	    return null;
	  }),

	  _onMouseOut: function (event) {
	    // Only hide the tooltip if the mouse leaves baseNode.
	    if (event && this._baseNode && !this._baseNode.contains(event.relatedTarget)) {
	      return;
	    }

	    this._lastHovered = null;
	    this.win.clearTimeout(this.toggleTimer);
	    this.toggleTimer = this.win.setTimeout(() => {
	      this.tooltip.hide();
	    }, this._toggleDelay);
	  },

	  _onTooltipMouseOver() {
	    this.win.clearTimeout(this.toggleTimer);
	  },

	  _onTooltipMouseOut() {
	    this.win.clearTimeout(this.toggleTimer);
	    this.toggleTimer = this.win.setTimeout(() => {
	      this.tooltip.hide();
	    }, this._toggleDelay);
	  },

	  destroy: function () {
	    this.stop();
	  }
	};


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Helpers for async functions. Async functions are generator functions that are
	 * run by Tasks. An async function returns a Promise for the resolution of the
	 * function. When the function returns, the promise is resolved with the
	 * returned value. If it throws the promise rejects with the thrown error.
	 *
	 * See Task documentation at https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Task.jsm.
	 */

	var {Task} = __webpack_require__(15);
	var Promise = __webpack_require__(4);

	/**
	 * Create an async function that only executes once per instance of an object.
	 * Once called on a given object, the same promise will be returned for any
	 * future calls for that object.
	 *
	 * @param Function func
	 *        The generator function that to wrap as an async function.
	 * @return Function
	 *         The async function.
	 */
	exports.asyncOnce = function asyncOnce(func) {
	  const promises = new WeakMap();
	  return function (...args) {
	    let promise = promises.get(this);
	    if (!promise) {
	      promise = Task.spawn(func.apply(this, args));
	      promises.set(this, promise);
	    }
	    return promise;
	  };
	};

	/**
	 * Adds an event listener to the given element, and then removes its event
	 * listener once the event is called, returning the event object as a promise.
	 * @param  nsIDOMElement element
	 *         The DOM element to listen on
	 * @param  String event
	 *         The name of the event type to listen for
	 * @param  Boolean useCapture
	 *         Should we initiate the capture phase?
	 * @return Promise
	 *         The promise resolved with the event object when the event first
	 *         happens
	 */
	exports.listenOnce = function listenOnce(element, event, useCapture) {
	  return new Promise(function (resolve, reject) {
	    let onEvent = function (ev) {
	      element.removeEventListener(event, onEvent, useCapture);
	      resolve(ev);
	    };
	    element.addEventListener(event, onEvent, useCapture);
	  });
	};

	/**
	 * Call a function that expects a callback as the last argument and returns a
	 * promise for the result. This simplifies using callback APIs from tasks and
	 * async functions.
	 *
	 * @param Any obj
	 *        The |this| value to call the function on.
	 * @param Function func
	 *        The callback-expecting function to call.
	 * @param Array args
	 *        Additional arguments to pass to the method.
	 * @return Promise
	 *         The promise for the result. If the callback is called with only one
	 *         argument, it is used as the resolution value. If there's multiple
	 *         arguments, an array containing the arguments is the resolution value.
	 *         If the method throws, the promise is rejected with the thrown value.
	 */
	function promisify(obj, func, args) {
	  return new Promise(resolve => {
	    args.push((...results) => {
	      resolve(results.length > 1 ? results : results[0]);
	    });
	    func.apply(obj, args);
	  });
	}

	/**
	 * Call a method that expects a callback as the last argument and returns a
	 * promise for the result.
	 *
	 * @see promisify
	 */
	exports.promiseInvoke = function promiseInvoke(obj, func, ...args) {
	  return promisify(obj, func, args);
	};

	/**
	 * Call a function that expects a callback as the last argument.
	 *
	 * @see promisify
	 */
	exports.promiseCall = function promiseCall(func, ...args) {
	  return promisify(undefined, func, args);
	};


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {LocalizationHelper} = __webpack_require__(56);
	const L10N = new LocalizationHelper("devtools/locale/inspector.properties");

	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	// Default image tooltip max dimension
	const MAX_DIMENSION = 200;
	const CONTAINER_MIN_WIDTH = 100;
	const LABEL_HEIGHT = 20;
	const IMAGE_PADDING = 4;

	/**
	 * Image preview tooltips should be provided with the naturalHeight and
	 * naturalWidth value for the image to display. This helper loads the provided
	 * image URL in an image object in order to retrieve the image dimensions after
	 * the load.
	 *
	 * @param {Document} doc the document element to use to create the image object
	 * @param {String} imageUrl the url of the image to measure
	 * @return {Promise} returns a promise that will resolve after the iamge load:
	 *         - {Number} naturalWidth natural width of the loaded image
	 *         - {Number} naturalHeight natural height of the loaded image
	 */
	function getImageDimensions(doc, imageUrl) {
	  return new Promise(resolve => {
	    let imgObj = new doc.defaultView.Image();
	    imgObj.onload = () => {
	      imgObj.onload = null;
	      let { naturalWidth, naturalHeight } = imgObj;
	      resolve({ naturalWidth, naturalHeight });
	    };
	    imgObj.src = imageUrl;
	  });
	}

	/**
	 * Set the tooltip content of a provided HTMLTooltip instance to display an
	 * image preview matching the provided imageUrl.
	 *
	 * @param {HTMLTooltip} tooltip
	 *        The tooltip instance on which the image preview content should be set
	 * @param {Document} doc
	 *        A document element to create the HTML elements needed for the tooltip
	 * @param {String} imageUrl
	 *        Absolute URL of the image to display in the tooltip
	 * @param {Object} options
	 *        - {Number} naturalWidth mandatory, width of the image to display
	 *        - {Number} naturalHeight mandatory, height of the image to display
	 *        - {Number} maxDim optional, max width/height of the preview
	 *        - {Boolean} hideDimensionLabel optional, pass true to hide the label
	 */
	function setImageTooltip(tooltip, doc, imageUrl, options) {
	  let {naturalWidth, naturalHeight, hideDimensionLabel, maxDim} = options;
	  maxDim = maxDim || MAX_DIMENSION;

	  let imgHeight = naturalHeight;
	  let imgWidth = naturalWidth;
	  if (imgHeight > maxDim || imgWidth > maxDim) {
	    let scale = maxDim / Math.max(imgHeight, imgWidth);
	    // Only allow integer values to avoid rounding errors.
	    imgHeight = Math.floor(scale * naturalHeight);
	    imgWidth = Math.ceil(scale * naturalWidth);
	  }

	  // Create tooltip content
	  let div = doc.createElementNS(XHTML_NS, "div");
	  div.style.cssText = `
	    height: 100%;
	    min-width: 100px;
	    display: flex;
	    flex-direction: column;
	    text-align: center;`;
	  let html = `
	    <div style="flex: 1;
	                display: flex;
	                padding: ${IMAGE_PADDING}px;
	                align-items: center;
	                justify-content: center;
	                min-height: 1px;">
	      <img style="height: ${imgHeight}px; max-height: 100%;" src="${imageUrl}"/>
	    </div>`;

	  if (!hideDimensionLabel) {
	    let label = naturalWidth + " \u00D7 " + naturalHeight;
	    html += `
	      <div style="height: ${LABEL_HEIGHT}px;
	                  text-align: center;">
	        <span class="theme-comment devtools-tooltip-caption">${label}</span>
	      </div>`;
	  }
	  div.innerHTML = html;

	  // Calculate tooltip dimensions
	  let height = imgHeight + 2 * IMAGE_PADDING;
	  if (!hideDimensionLabel) {
	    height += LABEL_HEIGHT;
	  }
	  let width = Math.max(CONTAINER_MIN_WIDTH, imgWidth + 2 * IMAGE_PADDING);

	  tooltip.setContent(div, {width, height});
	}

	/*
	 * Set the tooltip content of a provided HTMLTooltip instance to display a
	 * fallback error message when an image preview tooltip can not be displayed.
	 *
	 * @param {HTMLTooltip} tooltip
	 *        The tooltip instance on which the image preview content should be set
	 * @param {Document} doc
	 *        A document element to create the HTML elements needed for the tooltip
	 */
	function setBrokenImageTooltip(tooltip, doc) {
	  let div = doc.createElementNS(XHTML_NS, "div");
	  div.style.cssText = `
	    box-sizing: border-box;
	    height: 100%;
	    text-align: center;
	    line-height: 30px;`;

	  let message = L10N.getStr("previewTooltip.image.brokenImage");
	  div.textContent = message;
	  tooltip.setContent(div, {width: 150, height: 30});
	}

	module.exports.getImageDimensions = getImageDimensions;
	module.exports.setImageTooltip = setImageTooltip;
	module.exports.setBrokenImageTooltip = setBrokenImageTooltip;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {HTMLTooltip} = __webpack_require__(186);
	const {MdnDocsWidget} = __webpack_require__(191);
	const {KeyShortcuts} = __webpack_require__(13);
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	const TOOLTIP_WIDTH = 418;
	const TOOLTIP_HEIGHT = 308;

	/**
	 * Tooltip for displaying docs for CSS properties from MDN.
	 *
	 * @param {Toolbox} toolbox
	 *        Toolbox used to create the tooltip.
	 */
	function CssDocsTooltip(toolbox) {
	  this.tooltip = new HTMLTooltip(toolbox, {
	    type: "arrow",
	    consumeOutsideClicks: true,
	    autofocus: true,
	    useXulWrapper: true,
	    stylesheet: "chrome://devtools/content/shared/widgets/mdn-docs.css",
	  });
	  this.widget = this.setMdnDocsContent();
	  this._onVisitLink = this._onVisitLink.bind(this);
	  this.widget.on("visitlink", this._onVisitLink);

	  // Initialize keyboard shortcuts
	  this.shortcuts = new KeyShortcuts({ window: toolbox.doc.defaultView });
	  this._onShortcut = this._onShortcut.bind(this);

	  this.shortcuts.on("Escape", this._onShortcut);
	}

	module.exports.CssDocsTooltip = CssDocsTooltip;

	CssDocsTooltip.prototype = {
	  /**
	   * Load CSS docs for the given property,
	   * then display the tooltip.
	   */
	  show: function (anchor, propertyName) {
	    this.tooltip.once("shown", () => {
	      this.widget.loadCssDocs(propertyName);
	    });
	    this.tooltip.show(anchor);
	  },

	  hide: function () {
	    this.tooltip.hide();
	  },

	  _onShortcut: function (shortcut, event) {
	    if (!this.tooltip.isVisible()) {
	      return;
	    }
	    event.stopPropagation();
	    event.preventDefault();
	    this.hide();
	  },

	  _onVisitLink: function () {
	    this.hide();
	  },

	  /**
	   * Set the content of this tooltip to the MDN docs widget. This is called when the
	   * tooltip is first constructed.
	   * The caller can use the MdnDocsWidget to update the tooltip's  UI with new content
	   * each time the tooltip is shown.
	   *
	   * @return {MdnDocsWidget} the created MdnDocsWidget instance.
	   */
	  setMdnDocsContent: function () {
	    let container = this.tooltip.doc.createElementNS(XHTML_NS, "div");
	    container.setAttribute("class", "mdn-container theme-body");
	    this.tooltip.setContent(container, {width: TOOLTIP_WIDTH, height: TOOLTIP_HEIGHT});
	    return new MdnDocsWidget(container);
	  },

	  destroy: function () {
	    this.widget.off("visitlink", this._onVisitLink);
	    this.widget.destroy();

	    this.shortcuts.destroy();
	    this.tooltip.destroy();
	  }
	};


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * This file contains functions to retrieve docs content from
	 * MDN (developer.mozilla.org) for particular items, and to display
	 * the content in a tooltip.
	 *
	 * At the moment it only supports fetching content for CSS properties,
	 * but it might support other types of content in the future
	 * (Web APIs, for example).
	 *
	 * It's split into two parts:
	 *
	 * - functions like getCssDocs that just fetch content from MDN,
	 * without any constraints on what to do with the content. If you
	 * want to embed the content in some custom way, use this.
	 *
	 * - the MdnDocsWidget class, that manages and updates a tooltip
	 * document whose content is taken from MDN. If you want to embed
	 * the content in a tooltip, use this in conjunction with Tooltip.js.
	 */

	"use strict";

	const Services = __webpack_require__(1);
	const defer = __webpack_require__(5);
	const {getCSSLexer} = __webpack_require__(174);
	const EventEmitter = __webpack_require__(6);
	const {gDevTools} = __webpack_require__(38);

	const {LocalizationHelper} = __webpack_require__(56);
	const L10N = new LocalizationHelper("devtools/locale/inspector.properties");

	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	// Parameters for the XHR request
	// see https://developer.mozilla.org/en-US/docs/MDN/Kuma/API#Document_parameters
	const XHR_PARAMS = "?raw&macros";
	// URL for the XHR request
	var XHR_CSS_URL = "https://developer.mozilla.org/en-US/docs/Web/CSS/";

	// Parameters for the link to MDN in the tooltip, so
	// so we know which MDN visits come from this feature
	const PAGE_LINK_PARAMS =
	  "?utm_source=mozilla&utm_medium=firefox-inspector&utm_campaign=default";
	// URL for the page link omits locale, so a locale-specific page will be loaded
	var PAGE_LINK_URL = "https://developer.mozilla.org/docs/Web/CSS/";
	exports.PAGE_LINK_URL = PAGE_LINK_URL;

	const PROPERTY_NAME_COLOR = "theme-fg-color5";
	const PROPERTY_VALUE_COLOR = "theme-fg-color1";
	const COMMENT_COLOR = "theme-comment";

	/**
	 * Turns a string containing a series of CSS declarations into
	 * a series of DOM nodes, with classes applied to provide syntax
	 * highlighting.
	 *
	 * It uses the CSS tokenizer to generate a stream of CSS tokens.
	 * https://dxr.mozilla.org/mozilla-central/source/dom/webidl/CSSLexer.webidl
	 * lists all the token types.
	 *
	 * - "whitespace", "comment", and "symbol" tokens are appended as TEXT nodes,
	 * and will inherit the default style for text.
	 *
	 * - "ident" tokens that we think are property names are considered to be
	 * a property name, and are appended as SPAN nodes with a distinct color class.
	 *
	 * - "ident" nodes which we do not think are property names, and nodes
	 * of all other types ("number", "url", "percentage", ...) are considered
	 * to be part of a property value, and are appended as SPAN nodes with
	 * a different color class.
	 *
	 * @param {Document} doc
	 * Used to create nodes.
	 *
	 * @param {String} syntaxText
	 * The CSS input. This is assumed to consist of a series of
	 * CSS declarations, with trailing semicolons.
	 *
	 * @param {DOM node} syntaxSection
	 * This is the parent for the output nodes. Generated nodes
	 * are appended to this as children.
	 */
	function appendSyntaxHighlightedCSS(cssText, parentElement) {
	  let doc = parentElement.ownerDocument;
	  let identClass = PROPERTY_NAME_COLOR;
	  let lexer = getCSSLexer(cssText);

	  /**
	   * Create a SPAN node with the given text content and class.
	   */
	  function createStyledNode(textContent, className) {
	    let newNode = doc.createElementNS(XHTML_NS, "span");
	    newNode.classList.add(className);
	    newNode.textContent = textContent;
	    return newNode;
	  }

	  /**
	   * If the symbol is ":", we will expect the next
	   * "ident" token to be part of a property value.
	   *
	   * If the symbol is ";", we will expect the next
	   * "ident" token to be a property name.
	   */
	  function updateIdentClass(tokenText) {
	    if (tokenText === ":") {
	      identClass = PROPERTY_VALUE_COLOR;
	    } else if (tokenText === ";") {
	      identClass = PROPERTY_NAME_COLOR;
	    }
	  }

	  /**
	   * Create the appropriate node for this token type.
	   *
	   * If this token is a symbol, also update our expectations
	   * for what the next "ident" token represents.
	   */
	  function tokenToNode(token, tokenText) {
	    switch (token.tokenType) {
	      case "ident":
	        return createStyledNode(tokenText, identClass);
	      case "symbol":
	        updateIdentClass(tokenText);
	        return doc.createTextNode(tokenText);
	      case "whitespace":
	        return doc.createTextNode(tokenText);
	      case "comment":
	        return createStyledNode(tokenText, COMMENT_COLOR);
	      default:
	        return createStyledNode(tokenText, PROPERTY_VALUE_COLOR);
	    }
	  }

	  let token = lexer.nextToken();
	  while (token) {
	    let tokenText = cssText.slice(token.startOffset, token.endOffset);
	    let newNode = tokenToNode(token, tokenText);
	    parentElement.appendChild(newNode);
	    token = lexer.nextToken();
	  }
	}

	exports.appendSyntaxHighlightedCSS = appendSyntaxHighlightedCSS;

	/**
	 * Fetch an MDN page.
	 *
	 * @param {string} pageUrl
	 * URL of the page to fetch.
	 *
	 * @return {promise}
	 * The promise is resolved with the page as an XML document.
	 *
	 * The promise is rejected with an error message if
	 * we could not load the page.
	 */
	function getMdnPage(pageUrl) {
	  let deferred = defer();

	  let xhr = new XMLHttpRequest();

	  xhr.addEventListener("load", onLoaded, false);
	  xhr.addEventListener("error", onError, false);

	  xhr.open("GET", pageUrl);
	  xhr.responseType = "document";
	  xhr.send();

	  function onLoaded(e) {
	    if (xhr.status != 200) {
	      deferred.reject({page: pageUrl, status: xhr.status});
	    } else {
	      deferred.resolve(xhr.responseXML);
	    }
	  }

	  function onError(e) {
	    deferred.reject({page: pageUrl, status: xhr.status});
	  }

	  return deferred.promise;
	}

	/**
	 * Gets some docs for the given CSS property.
	 * Loads an MDN page for the property and gets some
	 * information about the property.
	 *
	 * @param {string} cssProperty
	 * The property for which we want docs.
	 *
	 * @return {promise}
	 * The promise is resolved with an object containing:
	 * - summary: a short summary of the property
	 * - syntax: some example syntax
	 *
	 * The promise is rejected with an error message if
	 * we could not load the page.
	 */
	function getCssDocs(cssProperty) {
	  let deferred = defer();
	  let pageUrl = XHR_CSS_URL + cssProperty + XHR_PARAMS;

	  getMdnPage(pageUrl).then(parseDocsFromResponse, handleRejection);

	  function parseDocsFromResponse(responseDocument) {
	    let theDocs = {};
	    theDocs.summary = getSummary(responseDocument);
	    theDocs.syntax = getSyntax(responseDocument);
	    if (theDocs.summary || theDocs.syntax) {
	      deferred.resolve(theDocs);
	    } else {
	      deferred.reject("Couldn't find the docs in the page.");
	    }
	  }

	  function handleRejection(e) {
	    deferred.reject(e.status);
	  }

	  return deferred.promise;
	}

	exports.getCssDocs = getCssDocs;

	/**
	 * The MdnDocsWidget is used by tooltip code that needs to display docs
	 * from MDN in a tooltip.
	 *
	 * In the constructor, the widget does some general setup that's not
	 * dependent on the particular item we need docs for.
	 *
	 * After that, when the tooltip code needs to display docs for an item, it
	 * asks the widget to retrieve the docs and update the document with them.
	 *
	 * @param {Element} tooltipContainer
	 * A DOM element where the MdnDocs widget markup should be created.
	 */
	function MdnDocsWidget(tooltipContainer) {
	  EventEmitter.decorate(this);

	  tooltipContainer.innerHTML =
	    `<header>
	       <h1 class="mdn-property-name theme-fg-color5"></h1>
	     </header>
	     <div class="mdn-property-info">
	       <div class="mdn-summary"></div>
	       <pre class="mdn-syntax devtools-monospace"></pre>
	     </div>
	     <footer>
	       <a class="mdn-visit-page theme-link" href="#">Visit MDN (placeholder)</a>
	     </footer>`;

	  // fetch all the bits of the document that we will manipulate later
	  this.elements = {
	    heading: tooltipContainer.querySelector(".mdn-property-name"),
	    summary: tooltipContainer.querySelector(".mdn-summary"),
	    syntax: tooltipContainer.querySelector(".mdn-syntax"),
	    info: tooltipContainer.querySelector(".mdn-property-info"),
	    linkToMdn: tooltipContainer.querySelector(".mdn-visit-page")
	  };

	  // get the localized string for the link text
	  this.elements.linkToMdn.textContent = L10N.getStr("docsTooltip.visitMDN");

	  // listen for clicks and open in the browser window instead
	  let mainWindow = Services.wm.getMostRecentWindow(gDevTools.chromeWindowType);
	  this.elements.linkToMdn.addEventListener("click", (e) => {
	    e.stopPropagation();
	    e.preventDefault();
	    mainWindow.openUILinkIn(e.target.href, "tab");
	    this.emit("visitlink");
	  });
	}

	exports.MdnDocsWidget = MdnDocsWidget;

	MdnDocsWidget.prototype = {
	  /**
	   * This is called just before the tooltip is displayed, and is
	   * passed the CSS property for which we want to display help.
	   *
	   * Its job is to make sure the document contains the docs
	   * content for that CSS property.
	   *
	   * First, it initializes the document, setting the things it can
	   * set synchronously, resetting the things it needs to get
	   * asynchronously, and making sure the throbber is throbbing.
	   *
	   * Then it tries to get the content asynchronously, updating
	   * the document with the content or with an error message.
	   *
	   * It returns immediately, so the caller can display the tooltip
	   * without waiting for the asynch operation to complete.
	   *
	   * @param {string} propertyName
	   * The name of the CSS property for which we need to display help.
	   */
	  loadCssDocs: function (propertyName) {
	    /**
	     * Do all the setup we can do synchronously, and get the document in
	     * a state where it can be displayed while we are waiting for the
	     * MDN docs content to be retrieved.
	     */
	    function initializeDocument(propName) {
	      // set property name heading
	      elements.heading.textContent = propName;

	      // set link target
	      elements.linkToMdn.setAttribute("href",
	        PAGE_LINK_URL + propName + PAGE_LINK_PARAMS);

	      // clear docs summary and syntax
	      elements.summary.textContent = "";
	      while (elements.syntax.firstChild) {
	        elements.syntax.firstChild.remove();
	      }

	      // reset the scroll position
	      elements.info.scrollTop = 0;
	      elements.info.scrollLeft = 0;

	      // show the throbber
	      elements.info.classList.add("devtools-throbber");
	    }

	    /**
	     * This is called if we successfully got the docs content.
	     * Finishes setting up the tooltip content, and disables the throbber.
	     */
	    function finalizeDocument({summary, syntax}) {
	      // set docs summary and syntax
	      elements.summary.textContent = summary;
	      appendSyntaxHighlightedCSS(syntax, elements.syntax);

	      // hide the throbber
	      elements.info.classList.remove("devtools-throbber");

	      deferred.resolve(this);
	    }

	    /**
	     * This is called if we failed to get the docs content.
	     * Sets the content to contain an error message, and disables the throbber.
	     */
	    function gotError(error) {
	      // show error message
	      elements.summary.textContent = L10N.getStr("docsTooltip.loadDocsError");

	      // hide the throbber
	      elements.info.classList.remove("devtools-throbber");

	      // although gotError is called when there's an error, we have handled
	      // the error, so call resolve not reject.
	      deferred.resolve(this);
	    }

	    let deferred = defer();
	    let elements = this.elements;

	    initializeDocument(propertyName);
	    getCssDocs(propertyName).then(finalizeDocument, gotError);

	    return deferred.promise;
	  },

	  destroy: function () {
	    this.elements = null;
	  }
	};

	/**
	 * Test whether a node is all whitespace.
	 *
	 * @return {boolean}
	 * True if the node all whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
	  return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Test whether a node is a comment or whitespace node.
	 *
	 * @return {boolean}
	 * True if the node is a comment node or is all whitespace, otherwise false.
	 */
	function isIgnorable(node) {
	  // Comment nodes (8), text nodes (3) or whitespace
	  return (node.nodeType == 8) ||
	         ((node.nodeType == 3) && isAllWhitespace(node));
	}

	/**
	 * Get the next node, skipping comments and whitespace.
	 *
	 * @return {node}
	 * The next sibling node that is not a comment or whitespace, or null if
	 * there isn't one.
	 */
	function nodeAfter(sib) {
	  while ((sib = sib.nextSibling)) {
	    if (!isIgnorable(sib)) {
	      return sib;
	    }
	  }
	  return null;
	}

	/**
	 * Test whether the argument `node` is a node whose tag is `tagName`.
	 *
	 * @param {node} node
	 * The code to test. May be null.
	 *
	 * @param {string} tagName
	 * The tag name to test against.
	 *
	 * @return {boolean}
	 * True if the node is not null and has the tag name `tagName`,
	 * otherwise false.
	 */
	function hasTagName(node, tagName) {
	  return node && node.tagName &&
	         node.tagName.toLowerCase() == tagName.toLowerCase();
	}

	/**
	 * Given an MDN page, get the "summary" portion.
	 *
	 * This is the textContent of the first non-whitespace
	 * element in the #Summary section of the document.
	 *
	 * It's expected to be a <P> element.
	 *
	 * @param {Document} mdnDocument
	 * The document in which to look for the "summary" section.
	 *
	 * @return {string}
	 * The summary section as a string, or null if it could not be found.
	 */
	function getSummary(mdnDocument) {
	  let summary = mdnDocument.getElementById("Summary");
	  if (!hasTagName(summary, "H2")) {
	    return null;
	  }

	  let firstParagraph = nodeAfter(summary);
	  if (!hasTagName(firstParagraph, "P")) {
	    return null;
	  }

	  return firstParagraph.textContent;
	}

	/**
	 * Given an MDN page, get the "syntax" portion.
	 *
	 * First we get the #Syntax section of the document. The syntax
	 * section we want is somewhere inside there.
	 *
	 * If the page is in the old structure, then the *first two*
	 * non-whitespace elements in the #Syntax section will be <PRE>
	 * nodes, and the second of these will be the syntax section.
	 *
	 * If the page is in the new structure, then the only the *first*
	 * non-whitespace element in the #Syntax section will be a <PRE>
	 * node, and it will be the syntax section.
	 *
	 * @param {Document} mdnDocument
	 * The document in which to look for the "syntax" section.
	 *
	 * @return {string}
	 * The syntax section as a string, or null if it could not be found.
	 */
	function getSyntax(mdnDocument) {
	  let syntax = mdnDocument.getElementById("Syntax");
	  if (!hasTagName(syntax, "H2")) {
	    return null;
	  }

	  let firstParagraph = nodeAfter(syntax);
	  if (!hasTagName(firstParagraph, "PRE")) {
	    return null;
	  }

	  let secondParagraph = nodeAfter(firstParagraph);
	  if (hasTagName(secondParagraph, "PRE")) {
	    return secondParagraph.textContent;
	  }
	  return firstParagraph.textContent;
	}

	/**
	 * Use a different URL for CSS docs pages. Used only for testing.
	 *
	 * @param {string} baseUrl
	 * The baseURL to use.
	 */
	function setBaseCssDocsUrl(baseUrl) {
	  PAGE_LINK_URL = baseUrl;
	  XHR_CSS_URL = baseUrl;
	}

	exports.setBaseCssDocsUrl = setBaseCssDocsUrl;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const defer = __webpack_require__(5);
	const {Spectrum} = __webpack_require__(193);
	const {CubicBezierWidget} =
	      __webpack_require__(194);
	const {CSSFilterEditorWidget} = __webpack_require__(196);
	const {TooltipToggle} = __webpack_require__(187);
	const EventEmitter = __webpack_require__(6);
	const {colorUtils} = __webpack_require__(179);
	const Heritage = __webpack_require__(18);
	const {HTMLTooltip} = __webpack_require__(186);
	const {KeyShortcuts} = __webpack_require__(13);
	const {Task} = __webpack_require__(15);
	const {KeyCodes} = __webpack_require__(14);

	const XHTML_NS = "http://www.w3.org/1999/xhtml";
	const ESCAPE_KEYCODE = KeyCodes.DOM_VK_ESCAPE;
	const POPUP_EVENTS = ["shown", "hidden", "showing", "hiding"];

	/**
	 * Tooltip widget.
	 *
	 * This widget is intended at any tool that may need to show rich content in the
	 * form of floating panels.
	 * A common use case is image previewing in the CSS rule view, but more complex
	 * use cases may include color pickers, object inspection, etc...
	 *
	 * Tooltips are based on XUL (namely XUL arrow-type <panel>s), and therefore
	 * need a XUL Document to live in.
	 * This is pretty much the only requirement they have on their environment.
	 *
	 * The way to use a tooltip is simply by instantiating a tooltip yourself and
	 * attaching some content in it, or using one of the ready-made content types.
	 *
	 * A convenient `startTogglingOnHover` method may avoid having to register event
	 * handlers yourself if the tooltip has to be shown when hovering over a
	 * specific element or group of elements (which is usually the most common case)
	 */

	/**
	 * Container used for dealing with optional parameters.
	 *
	 * @param {Object} defaults
	 *        An object with all default options {p1: v1, p2: v2, ...}
	 * @param {Object} options
	 *        The actual values.
	 */
	function OptionsStore(defaults, options) {
	  this.defaults = defaults || {};
	  this.options = options || {};
	}

	OptionsStore.prototype = {
	  /**
	   * Get the value for a given option name.
	   * @return {Object} Returns the value for that option, coming either for the
	   *         actual values that have been set in the constructor, or from the
	   *         defaults if that options was not specified.
	   */
	  get: function (name) {
	    if (typeof this.options[name] !== "undefined") {
	      return this.options[name];
	    }
	    return this.defaults[name];
	  }
	};

	/**
	 * The low level structure of a tooltip is a XUL element (a <panel>).
	 */
	var PanelFactory = {
	  /**
	   * Get a new XUL panel instance.
	   * @param {XULDocument} doc
	   *        The XUL document to put that panel into
	   * @param {OptionsStore} options
	   *        An options store to get some configuration from
	   */
	  get: function (doc, options) {
	    // Create the tooltip
	    let panel = doc.createElement("panel");
	    panel.setAttribute("hidden", true);
	    panel.setAttribute("ignorekeys", true);
	    panel.setAttribute("animate", false);

	    panel.setAttribute("consumeoutsideclicks",
	                       options.get("consumeOutsideClick"));
	    panel.setAttribute("noautofocus", options.get("noAutoFocus"));
	    panel.setAttribute("type", "arrow");
	    panel.setAttribute("level", "top");

	    panel.setAttribute("class", "devtools-tooltip theme-tooltip-panel");
	    doc.querySelector("window").appendChild(panel);

	    return panel;
	  }
	};

	/**
	 * Tooltip class.
	 *
	 * Basic usage:
	 *   let t = new Tooltip(xulDoc);
	 *   t.content = someXulContent;
	 *   t.show();
	 *   t.hide();
	 *   t.destroy();
	 *
	 * Better usage:
	 *   let t = new Tooltip(xulDoc);
	 *   t.startTogglingOnHover(container, target => {
	 *     if (<condition based on target>) {
	 *       t.content = el;
	 *       return true;
	 *     }
	 *   });
	 *   t.destroy();
	 *
	 * @param {XULDocument} doc
	 *        The XUL document hosting this tooltip
	 * @param {Object} options
	 *        Optional options that give options to consumers:
	 *        - consumeOutsideClick {Boolean} Wether the first click outside of the
	 *        tooltip should close the tooltip and be consumed or not.
	 *        Defaults to false.
	 *        - closeOnKeys {Array} An array of key codes that should close the
	 *        tooltip. Defaults to [27] (escape key).
	 *        - closeOnEvents [{emitter: {Object}, event: {String},
	 *                          useCapture: {Boolean}}]
	 *        Provide an optional list of emitter objects and event names here to
	 *        trigger the closing of the tooltip when these events are fired by the
	 *        emitters. The emitter objects should either implement
	 *        on/off(event, cb) or addEventListener/removeEventListener(event, cb).
	 *        Defaults to [].
	 *        For instance, the following would close the tooltip whenever the
	 *        toolbox selects a new tool and when a DOM node gets scrolled:
	 *        new Tooltip(doc, {
	 *          closeOnEvents: [
	 *            {emitter: toolbox, event: "select"},
	 *            {emitter: myContainer, event: "scroll", useCapture: true}
	 *          ]
	 *        });
	 *        - noAutoFocus {Boolean} Should the focus automatically go to the panel
	 *        when it opens. Defaults to true.
	 *
	 * Fires these events:
	 * - showing : just before the tooltip shows
	 * - shown : when the tooltip is shown
	 * - hiding : just before the tooltip closes
	 * - hidden : when the tooltip gets hidden
	 * - keypress : when any key gets pressed, with keyCode
	 */
	function Tooltip(doc, options) {
	  EventEmitter.decorate(this);

	  this.doc = doc;
	  this.options = new OptionsStore({
	    consumeOutsideClick: false,
	    closeOnKeys: [ESCAPE_KEYCODE],
	    noAutoFocus: true,
	    closeOnEvents: []
	  }, options);
	  this.panel = PanelFactory.get(doc, this.options);

	  // Create tooltip toggle helper and decorate the Tooltip instance with
	  // shortcut methods.
	  this._toggle = new TooltipToggle(this);
	  this.startTogglingOnHover = this._toggle.start.bind(this._toggle);
	  this.stopTogglingOnHover = this._toggle.stop.bind(this._toggle);

	  // Emit show/hide events when the panel does.
	  for (let eventName of POPUP_EVENTS) {
	    this["_onPopup" + eventName] = (name => {
	      return e => {
	        if (e.target === this.panel) {
	          this.emit(name);
	        }
	      };
	    })(eventName);
	    this.panel.addEventListener("popup" + eventName,
	      this["_onPopup" + eventName], false);
	  }

	  // Listen to keypress events to close the tooltip if configured to do so
	  let win = this.doc.querySelector("window");
	  this._onKeyPress = event => {
	    if (this.panel.hidden) {
	      return;
	    }

	    this.emit("keypress", event.keyCode);
	    if (this.options.get("closeOnKeys").indexOf(event.keyCode) !== -1 &&
	        this.isShown()) {
	      event.stopPropagation();
	      this.hide();
	    }
	  };
	  win.addEventListener("keypress", this._onKeyPress, false);

	  // Listen to custom emitters' events to close the tooltip
	  this.hide = this.hide.bind(this);
	  let closeOnEvents = this.options.get("closeOnEvents");
	  for (let {emitter, event, useCapture} of closeOnEvents) {
	    for (let add of ["addEventListener", "on"]) {
	      if (add in emitter) {
	        emitter[add](event, this.hide, useCapture);
	        break;
	      }
	    }
	  }
	}

	module.exports.Tooltip = Tooltip;

	Tooltip.prototype = {
	  defaultPosition: "before_start",
	  // px
	  defaultOffsetX: 0,
	  // px
	  defaultOffsetY: 0,
	  // px

	  /**
	   * Show the tooltip. It might be wise to append some content first if you
	   * don't want the tooltip to be empty. You may access the content of the
	   * tooltip by setting a XUL node to t.content.
	   * @param {node} anchor
	   *        Which node should the tooltip be shown on
	   * @param {string} position [optional]
	   *        Optional tooltip position. Defaults to before_start
	   *        https://developer.mozilla.org/en-US/docs/XUL/PopupGuide/Positioning
	   * @param {number} x, y [optional]
	   *        The left and top offset coordinates, in pixels.
	   */
	  show: function (anchor,
	    position = this.defaultPosition,
	    x = this.defaultOffsetX,
	    y = this.defaultOffsetY) {
	    this.panel.hidden = false;
	    this.panel.openPopup(anchor, position, x, y);
	  },

	  /**
	   * Hide the tooltip
	   */
	  hide: function () {
	    this.panel.hidden = true;
	    this.panel.hidePopup();
	  },

	  isShown: function () {
	    return this.panel &&
	           this.panel.state !== "closed" &&
	           this.panel.state !== "hiding";
	  },

	  setSize: function (width, height) {
	    this.panel.sizeTo(width, height);
	  },

	  /**
	   * Empty the tooltip's content
	   */
	  empty: function () {
	    while (this.panel.hasChildNodes()) {
	      this.panel.removeChild(this.panel.firstChild);
	    }
	  },

	  /**
	   * Gets this panel's visibility state.
	   * @return boolean
	   */
	  isHidden: function () {
	    return this.panel.state == "closed" || this.panel.state == "hiding";
	  },

	  /**
	   * Gets if this panel has any child nodes.
	   * @return boolean
	   */
	  isEmpty: function () {
	    return !this.panel.hasChildNodes();
	  },

	  /**
	   * Get rid of references and event listeners
	   */
	  destroy: function () {
	    this.hide();

	    for (let eventName of POPUP_EVENTS) {
	      this.panel.removeEventListener("popup" + eventName,
	        this["_onPopup" + eventName], false);
	    }

	    let win = this.doc.querySelector("window");
	    win.removeEventListener("keypress", this._onKeyPress, false);

	    let closeOnEvents = this.options.get("closeOnEvents");
	    for (let {emitter, event, useCapture} of closeOnEvents) {
	      for (let remove of ["removeEventListener", "off"]) {
	        if (remove in emitter) {
	          emitter[remove](event, this.hide, useCapture);
	          break;
	        }
	      }
	    }

	    this.content = null;

	    this._toggle.destroy();

	    this.doc = null;

	    this.panel.remove();
	    this.panel = null;
	  },

	  /**
	   * Returns the outer container node (that includes the arrow etc.). Happens
	   * to be identical to this.panel here, can be different element in other
	   * Tooltip implementations.
	   */
	  get container() {
	    return this.panel;
	  },

	  /**
	   * Set the content of this tooltip. Will first empty the tooltip and then
	   * append the new content element.
	   * Consider using one of the set<type>Content() functions instead.
	   * @param {node} content
	   *        A node that can be appended in the tooltip XUL element
	   */
	  set content(content) {
	    if (this.content == content) {
	      return;
	    }

	    this.empty();
	    this.panel.removeAttribute("clamped-dimensions");
	    this.panel.removeAttribute("clamped-dimensions-no-min-height");
	    this.panel.removeAttribute("clamped-dimensions-no-max-or-min-height");
	    this.panel.removeAttribute("wide");

	    if (content) {
	      this.panel.appendChild(content);
	    }
	  },

	  get content() {
	    return this.panel.firstChild;
	  },

	  /**
	   * Sets some text as the content of this tooltip.
	   *
	   * @param {array} messages
	   *        A list of text messages.
	   * @param {string} messagesClass [optional]
	   *        A style class for the text messages.
	   * @param {string} containerClass [optional]
	   *        A style class for the text messages container.
	   * @param {boolean} isAlertTooltip [optional]
	   *        Pass true to add an alert image for your tooltip.
	   */
	  setTextContent: function (
	    {
	      messages,
	      messagesClass,
	      containerClass,
	      isAlertTooltip
	    },
	    extraButtons = []) {
	    messagesClass = messagesClass || "default-tooltip-simple-text-colors";
	    containerClass = containerClass || "default-tooltip-simple-text-colors";

	    let vbox = this.doc.createElement("vbox");
	    vbox.className = "devtools-tooltip-simple-text-container " + containerClass;
	    vbox.setAttribute("flex", "1");

	    for (let text of messages) {
	      let description = this.doc.createElement("description");
	      description.setAttribute("flex", "1");
	      description.className = "devtools-tooltip-simple-text " + messagesClass;
	      description.textContent = text;
	      vbox.appendChild(description);
	    }

	    for (let { label, className, command } of extraButtons) {
	      let button = this.doc.createElement("button");
	      button.className = className;
	      button.setAttribute("label", label);
	      button.addEventListener("command", command);
	      vbox.appendChild(button);
	    }

	    if (isAlertTooltip) {
	      let hbox = this.doc.createElement("hbox");
	      hbox.setAttribute("align", "start");

	      let alertImg = this.doc.createElement("image");
	      alertImg.className = "devtools-tooltip-alert-icon";
	      hbox.appendChild(alertImg);
	      hbox.appendChild(vbox);
	      this.content = hbox;
	    } else {
	      this.content = vbox;
	    }
	  },

	  /**
	   * Load a document into an iframe, and set the iframe
	   * to be the tooltip's content.
	   *
	   * Used by tooltips that want to load their interface
	   * into an iframe from a URL.
	   *
	   * @param {string} width
	   *        Width of the iframe.
	   * @param {string} height
	   *        Height of the iframe.
	   * @param {string} url
	   *        URL of the document to load into the iframe.
	   *
	   * @return {promise} A promise which is resolved with
	   * the iframe.
	   *
	   * This function creates an iframe, loads the specified document
	   * into it, sets the tooltip's content to the iframe, and returns
	   * a promise.
	   *
	   * When the document is loaded, the function gets the content window
	   * and resolves the promise with the content window.
	   */
	  setIFrameContent: function ({width, height}, url) {
	    let def = defer();

	    // Create an iframe
	    let iframe = this.doc.createElementNS(XHTML_NS, "iframe");
	    iframe.setAttribute("transparent", true);
	    iframe.setAttribute("width", width);
	    iframe.setAttribute("height", height);
	    iframe.setAttribute("flex", "1");
	    iframe.setAttribute("tooltip", "aHTMLTooltip");
	    iframe.setAttribute("class", "devtools-tooltip-iframe");

	    // Wait for the load to initialize the widget
	    function onLoad() {
	      iframe.removeEventListener("load", onLoad, true);
	      def.resolve(iframe);
	    }
	    iframe.addEventListener("load", onLoad, true);

	    // load the document from url into the iframe
	    iframe.setAttribute("src", url);

	    // Put the iframe in the tooltip
	    this.content = iframe;

	    return def.promise;
	  }
	};

	/**
	 * Base class for all (color, gradient, ...)-swatch based value editors inside
	 * tooltips
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 */
	function SwatchBasedEditorTooltip(toolbox, stylesheet) {
	  EventEmitter.decorate(this);
	  // Creating a tooltip instance
	  // This one will consume outside clicks as it makes more sense to let the user
	  // close the tooltip by clicking out
	  // It will also close on <escape> and <enter>
	  this.tooltip = new HTMLTooltip(toolbox, {
	    type: "arrow",
	    consumeOutsideClicks: true,
	    useXulWrapper: true,
	    stylesheet
	  });

	  // By default, swatch-based editor tooltips revert value change on <esc> and
	  // commit value change on <enter>
	  this.shortcuts = new KeyShortcuts({
	    window: this.tooltip.topWindow
	  });
	  this.shortcuts.on("Escape", (name, event) => {
	    if (!this.tooltip.isVisible()) {
	      return;
	    }
	    this.revert();
	    this.hide();
	    event.stopPropagation();
	    event.preventDefault();
	  });
	  this.shortcuts.on("Return", (name, event) => {
	    if (!this.tooltip.isVisible()) {
	      return;
	    }
	    this.commit();
	    this.hide();
	    event.stopPropagation();
	    event.preventDefault();
	  });

	  // All target swatches are kept in a map, indexed by swatch DOM elements
	  this.swatches = new Map();

	  // When a swatch is clicked, and for as long as the tooltip is shown, the
	  // activeSwatch property will hold the reference to the swatch DOM element
	  // that was clicked
	  this.activeSwatch = null;

	  this._onSwatchClick = this._onSwatchClick.bind(this);
	}

	SwatchBasedEditorTooltip.prototype = {
	  /**
	   * Show the editor tooltip for the currently active swatch.
	   *
	   * @return {Promise} a promise that resolves once the editor tooltip is displayed, or
	   *         immediately if there is no currently active swatch.
	   */
	  show: function () {
	    if (this.activeSwatch) {
	      let onShown = this.tooltip.once("shown");
	      this.tooltip.show(this.activeSwatch, "topcenter bottomleft");

	      // When the tooltip is closed by clicking outside the panel we want to
	      // commit any changes.
	      this.tooltip.once("hidden", () => {
	        if (!this._reverted && !this.eyedropperOpen) {
	          this.commit();
	        }
	        this._reverted = false;

	        // Once the tooltip is hidden we need to clean up any remaining objects.
	        if (!this.eyedropperOpen) {
	          this.activeSwatch = null;
	        }
	      });

	      return onShown;
	    }

	    return Promise.resolve();
	  },

	  hide: function () {
	    this.tooltip.hide();
	  },

	  /**
	   * Add a new swatch DOM element to the list of swatch elements this editor
	   * tooltip knows about. That means from now on, clicking on that swatch will
	   * toggle the editor.
	   *
	   * @param {node} swatchEl
	   *        The element to add
	   * @param {object} callbacks
	   *        Callbacks that will be executed when the editor wants to preview a
	   *        value change, or revert a change, or commit a change.
	   *        - onShow: will be called when one of the swatch tooltip is shown
	   *        - onPreview: will be called when one of the sub-classes calls
	   *        preview
	   *        - onRevert: will be called when the user ESCapes out of the tooltip
	   *        - onCommit: will be called when the user presses ENTER or clicks
	   *        outside the tooltip.
	   */
	  addSwatch: function (swatchEl, callbacks = {}) {
	    if (!callbacks.onShow) {
	      callbacks.onShow = function () {};
	    }
	    if (!callbacks.onPreview) {
	      callbacks.onPreview = function () {};
	    }
	    if (!callbacks.onRevert) {
	      callbacks.onRevert = function () {};
	    }
	    if (!callbacks.onCommit) {
	      callbacks.onCommit = function () {};
	    }

	    this.swatches.set(swatchEl, {
	      callbacks: callbacks
	    });
	    swatchEl.addEventListener("click", this._onSwatchClick, false);
	  },

	  removeSwatch: function (swatchEl) {
	    if (this.swatches.has(swatchEl)) {
	      if (this.activeSwatch === swatchEl) {
	        this.hide();
	        this.activeSwatch = null;
	      }
	      swatchEl.removeEventListener("click", this._onSwatchClick, false);
	      this.swatches.delete(swatchEl);
	    }
	  },

	  _onSwatchClick: function (event) {
	    let swatch = this.swatches.get(event.target);

	    if (event.shiftKey) {
	      event.stopPropagation();
	      return;
	    }
	    if (swatch) {
	      this.activeSwatch = event.target;
	      this.show();
	      swatch.callbacks.onShow();
	      event.stopPropagation();
	    }
	  },

	  /**
	   * Not called by this parent class, needs to be taken care of by sub-classes
	   */
	  preview: function (value) {
	    if (this.activeSwatch) {
	      let swatch = this.swatches.get(this.activeSwatch);
	      swatch.callbacks.onPreview(value);
	    }
	  },

	  /**
	   * This parent class only calls this on <esc> keypress
	   */
	  revert: function () {
	    if (this.activeSwatch) {
	      this._reverted = true;
	      let swatch = this.swatches.get(this.activeSwatch);
	      this.tooltip.once("hidden", () => {
	        swatch.callbacks.onRevert();
	      });
	    }
	  },

	  /**
	   * This parent class only calls this on <enter> keypress
	   */
	  commit: function () {
	    if (this.activeSwatch) {
	      let swatch = this.swatches.get(this.activeSwatch);
	      swatch.callbacks.onCommit();
	    }
	  },

	  destroy: function () {
	    this.swatches.clear();
	    this.activeSwatch = null;
	    this.tooltip.off("keypress", this._onTooltipKeypress);
	    this.tooltip.destroy();
	    this.shortcuts.destroy();
	  }
	};

	/**
	 * The swatch color picker tooltip class is a specific class meant to be used
	 * along with output-parser's generated color swatches.
	 * It extends the parent SwatchBasedEditorTooltip class.
	 * It just wraps a standard Tooltip and sets its content with an instance of a
	 * color picker.
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 * @param {InspectorPanel} inspector
	 *        The inspector panel, needed for the eyedropper.
	 */
	function SwatchColorPickerTooltip(toolbox, inspector) {
	  let stylesheet = "chrome://devtools/content/shared/widgets/spectrum.css";
	  SwatchBasedEditorTooltip.call(this, toolbox, stylesheet);

	  this.inspector = inspector;

	  // Creating a spectrum instance. this.spectrum will always be a promise that
	  // resolves to the spectrum instance
	  this.spectrum = this.setColorPickerContent([0, 0, 0, 1]);
	  this._onSpectrumColorChange = this._onSpectrumColorChange.bind(this);
	  this._openEyeDropper = this._openEyeDropper.bind(this);
	}

	module.exports.SwatchColorPickerTooltip = SwatchColorPickerTooltip;

	SwatchColorPickerTooltip.prototype =
	Heritage.extend(SwatchBasedEditorTooltip.prototype, {
	  /**
	   * Fill the tooltip with a new instance of the spectrum color picker widget
	   * initialized with the given color, and return the instance of spectrum
	   */
	  setColorPickerContent: function (color) {
	    let { doc } = this.tooltip;

	    let container = doc.createElementNS(XHTML_NS, "div");
	    container.id = "spectrum-tooltip";
	    let spectrumNode = doc.createElementNS(XHTML_NS, "div");
	    spectrumNode.id = "spectrum";
	    container.appendChild(spectrumNode);
	    let eyedropper = doc.createElementNS(XHTML_NS, "button");
	    eyedropper.id = "eyedropper-button";
	    eyedropper.className = "devtools-button";
	    container.appendChild(eyedropper);

	    this.tooltip.setContent(container, { width: 218, height: 224 });

	    let spectrum = new Spectrum(spectrumNode, color);

	    // Wait for the tooltip to be shown before calling spectrum.show
	    // as it expect to be visible in order to compute DOM element sizes.
	    this.tooltip.once("shown", () => {
	      spectrum.show();
	    });

	    return spectrum;
	  },

	  /**
	   * Overriding the SwatchBasedEditorTooltip.show function to set spectrum's
	   * color.
	   */
	  show: Task.async(function* () {
	    // Call then parent class' show function
	    yield SwatchBasedEditorTooltip.prototype.show.call(this);
	    // Then set spectrum's color and listen to color changes to preview them
	    if (this.activeSwatch) {
	      this.currentSwatchColor = this.activeSwatch.nextSibling;
	      this._originalColor = this.currentSwatchColor.textContent;
	      let color = this.activeSwatch.style.backgroundColor;
	      this.spectrum.off("changed", this._onSpectrumColorChange);
	      this.spectrum.rgb = this._colorToRgba(color);
	      this.spectrum.on("changed", this._onSpectrumColorChange);
	      this.spectrum.updateUI();
	    }

	    let {target} = this.inspector.toolbox;
	    target.actorHasMethod("inspector", "pickColorFromPage").then(value => {
	      let tooltipDoc = this.tooltip.doc;
	      let eyeButton = tooltipDoc.querySelector("#eyedropper-button");
	      if (value && this.inspector.selection.nodeFront.isInHTMLDocument) {
	        eyeButton.addEventListener("click", this._openEyeDropper);
	      } else {
	        eyeButton.style.display = "none";
	      }
	      this.emit("ready");
	    }, e => console.error(e));
	  }),

	  _onSpectrumColorChange: function (event, rgba, cssColor) {
	    this._selectColor(cssColor);
	  },

	  _selectColor: function (color) {
	    if (this.activeSwatch) {
	      this.activeSwatch.style.backgroundColor = color;
	      this.activeSwatch.parentNode.dataset.color = color;

	      color = this._toDefaultType(color);
	      this.currentSwatchColor.textContent = color;
	      this.preview(color);

	      if (this.eyedropperOpen) {
	        this.commit();
	      }
	    }
	  },

	  _openEyeDropper: function () {
	    let {inspector, toolbox, telemetry} = this.inspector;
	    telemetry.toolOpened("pickereyedropper");
	    inspector.pickColorFromPage(toolbox, {copyOnSelect: false}).then(() => {
	      this.eyedropperOpen = true;

	      // close the colorpicker tooltip so that only the eyedropper is open.
	      this.hide();

	      this.tooltip.emit("eyedropper-opened");
	    }, e => console.error(e));

	    inspector.once("color-picked", color => {
	      toolbox.win.focus();
	      this._selectColor(color);
	      this._onEyeDropperDone();
	    });

	    inspector.once("color-pick-canceled", () => {
	      this._onEyeDropperDone();
	    });
	  },

	  _onEyeDropperDone: function () {
	    this.eyedropperOpen = false;
	    this.activeSwatch = null;
	  },

	  _colorToRgba: function (color) {
	    color = new colorUtils.CssColor(color);
	    let rgba = color._getRGBATuple();
	    return [rgba.r, rgba.g, rgba.b, rgba.a];
	  },

	  _toDefaultType: function (color) {
	    let colorObj = new colorUtils.CssColor(color);
	    colorObj.setAuthoredUnitFromColor(this._originalColor);
	    return colorObj.toString();
	  },

	  destroy: function () {
	    SwatchBasedEditorTooltip.prototype.destroy.call(this);
	    this.inspector = null;
	    this.currentSwatchColor = null;
	    this.spectrum.off("changed", this._onSpectrumColorChange);
	    this.spectrum.destroy();
	  }
	});

	/**
	 * The swatch cubic-bezier tooltip class is a specific class meant to be used
	 * along with rule-view's generated cubic-bezier swatches.
	 * It extends the parent SwatchBasedEditorTooltip class.
	 * It just wraps a standard Tooltip and sets its content with an instance of a
	 * CubicBezierWidget.
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 */
	function SwatchCubicBezierTooltip(toolbox) {
	  let stylesheet = "chrome://devtools/content/shared/widgets/cubic-bezier.css";
	  SwatchBasedEditorTooltip.call(this, toolbox, stylesheet);

	  // Creating a cubic-bezier instance.
	  // this.widget will always be a promise that resolves to the widget instance
	  this.widget = this.setCubicBezierContent([0, 0, 1, 1]);
	  this._onUpdate = this._onUpdate.bind(this);
	}

	module.exports.SwatchCubicBezierTooltip = SwatchCubicBezierTooltip;

	SwatchCubicBezierTooltip.prototype =
	Heritage.extend(SwatchBasedEditorTooltip.prototype, {
	  /**
	   * Fill the tooltip with a new instance of the cubic-bezier widget
	   * initialized with the given value, and return a promise that resolves to
	   * the instance of the widget
	   */
	  setCubicBezierContent: function (bezier) {
	    let { doc } = this.tooltip;

	    let container = doc.createElementNS(XHTML_NS, "div");
	    container.className = "cubic-bezier-container";

	    this.tooltip.setContent(container, { width: 510, height: 370 });

	    let def = defer();

	    // Wait for the tooltip to be shown before calling instanciating the widget
	    // as it expect its DOM elements to be visible.
	    this.tooltip.once("shown", () => {
	      let widget = new CubicBezierWidget(container, bezier);
	      def.resolve(widget);
	    });

	    return def.promise;
	  },

	  /**
	   * Overriding the SwatchBasedEditorTooltip.show function to set the cubic
	   * bezier curve in the widget
	   */
	  show: Task.async(function* () {
	    // Call the parent class' show function
	    yield SwatchBasedEditorTooltip.prototype.show.call(this);
	    // Then set the curve and listen to changes to preview them
	    if (this.activeSwatch) {
	      this.currentBezierValue = this.activeSwatch.nextSibling;
	      this.widget.then(widget => {
	        widget.off("updated", this._onUpdate);
	        widget.cssCubicBezierValue = this.currentBezierValue.textContent;
	        widget.on("updated", this._onUpdate);
	        this.emit("ready");
	      });
	    }
	  }),

	  _onUpdate: function (event, bezier) {
	    if (!this.activeSwatch) {
	      return;
	    }

	    this.currentBezierValue.textContent = bezier + "";
	    this.preview(bezier + "");
	  },

	  destroy: function () {
	    SwatchBasedEditorTooltip.prototype.destroy.call(this);
	    this.currentBezierValue = null;
	    this.widget.then(widget => {
	      widget.off("updated", this._onUpdate);
	      widget.destroy();
	    });
	  }
	});

	/**
	 * The swatch-based css filter tooltip class is a specific class meant to be
	 * used along with rule-view's generated css filter swatches.
	 * It extends the parent SwatchBasedEditorTooltip class.
	 * It just wraps a standard Tooltip and sets its content with an instance of a
	 * CSSFilterEditorWidget.
	 *
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox, needed to get the devtools main window.
	 */
	function SwatchFilterTooltip(toolbox) {
	  let stylesheet = "chrome://devtools/content/shared/widgets/filter-widget.css";
	  SwatchBasedEditorTooltip.call(this, toolbox, stylesheet);

	  // Creating a filter editor instance.
	  this.widget = this.setFilterContent("none");
	  this._onUpdate = this._onUpdate.bind(this);
	}

	exports.SwatchFilterTooltip = SwatchFilterTooltip;

	SwatchFilterTooltip.prototype =
	Heritage.extend(SwatchBasedEditorTooltip.prototype, {
	  /**
	   * Fill the tooltip with a new instance of the CSSFilterEditorWidget
	   * widget initialized with the given filter value, and return a promise
	   * that resolves to the instance of the widget when ready.
	   */
	  setFilterContent: function (filter) {
	    let { doc } = this.tooltip;

	    let container = doc.createElementNS(XHTML_NS, "div");
	    container.id = "filter-container";

	    this.tooltip.setContent(container, { width: 510, height: 200 });

	    return new CSSFilterEditorWidget(container, filter);
	  },

	  show: Task.async(function* () {
	    // Call the parent class' show function
	    yield SwatchBasedEditorTooltip.prototype.show.call(this);
	    // Then set the filter value and listen to changes to preview them
	    if (this.activeSwatch) {
	      this.currentFilterValue = this.activeSwatch.nextSibling;
	      this.widget.off("updated", this._onUpdate);
	      this.widget.on("updated", this._onUpdate);
	      this.widget.setCssValue(this.currentFilterValue.textContent);
	      this.widget.render();
	      this.emit("ready");
	    }
	  }),

	  _onUpdate: function (event, filters) {
	    if (!this.activeSwatch) {
	      return;
	    }

	    // Remove the old children and reparse the property value to
	    // recompute them.
	    while (this.currentFilterValue.firstChild) {
	      this.currentFilterValue.firstChild.remove();
	    }
	    let node = this._parser.parseCssProperty("filter", filters, this._options);
	    this.currentFilterValue.appendChild(node);

	    this.preview();
	  },

	  destroy: function () {
	    SwatchBasedEditorTooltip.prototype.destroy.call(this);
	    this.currentFilterValue = null;
	    this.widget.off("updated", this._onUpdate);
	    this.widget.destroy();
	  },

	  /**
	   * Like SwatchBasedEditorTooltip.addSwatch, but accepts a parser object
	   * to use when previewing the updated property value.
	   *
	   * @param {node} swatchEl
	   *        @see SwatchBasedEditorTooltip.addSwatch
	   * @param {object} callbacks
	   *        @see SwatchBasedEditorTooltip.addSwatch
	   * @param {object} parser
	   *        A parser object; @see OutputParser object
	   * @param {object} options
	   *        options to pass to the output parser, with
	   *          the option |filterSwatch| set.
	   */
	  addSwatch: function (swatchEl, callbacks, parser, options) {
	    SwatchBasedEditorTooltip.prototype.addSwatch.call(this, swatchEl,
	                                                      callbacks);
	    this._parser = parser;
	    this._options = options;
	  }
	});


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const EventEmitter = __webpack_require__(6);
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	/**
	 * Spectrum creates a color picker widget in any container you give it.
	 *
	 * Simple usage example:
	 *
	 * const {Spectrum} = require("devtools/client/shared/widgets/Spectrum");
	 * let s = new Spectrum(containerElement, [255, 126, 255, 1]);
	 * s.on("changed", (event, rgba, color) => {
	 *   console.log("rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " +
	 *     rgba[3] + ")");
	 * });
	 * s.show();
	 * s.destroy();
	 *
	 * Note that the color picker is hidden by default and you need to call show to
	 * make it appear. This 2 stages initialization helps in cases you are creating
	 * the color picker in a parent element that hasn't been appended anywhere yet
	 * or that is hidden. Calling show() when the parent element is appended and
	 * visible will allow spectrum to correctly initialize its various parts.
	 *
	 * Fires the following events:
	 * - changed : When the user changes the current color
	 */
	function Spectrum(parentEl, rgb) {
	  EventEmitter.decorate(this);

	  this.element = parentEl.ownerDocument.createElementNS(XHTML_NS, "div");
	  this.parentEl = parentEl;

	  this.element.className = "spectrum-container";
	  this.element.innerHTML = `
	    <div class="spectrum-top">
	      <div class="spectrum-fill"></div>
	      <div class="spectrum-top-inner">
	        <div class="spectrum-color spectrum-box">
	          <div class="spectrum-sat">
	            <div class="spectrum-val">
	              <div class="spectrum-dragger"></div>
	            </div>
	          </div>
	        </div>
	        <div class="spectrum-hue spectrum-box">
	          <div class="spectrum-slider spectrum-slider-control"></div>
	        </div>
	      </div>
	    </div>
	    <div class="spectrum-alpha spectrum-checker spectrum-box">
	      <div class="spectrum-alpha-inner">
	        <div class="spectrum-alpha-handle spectrum-slider-control"></div>
	      </div>
	    </div>
	  `;

	  this.onElementClick = this.onElementClick.bind(this);
	  this.element.addEventListener("click", this.onElementClick, false);

	  this.parentEl.appendChild(this.element);

	  this.slider = this.element.querySelector(".spectrum-hue");
	  this.slideHelper = this.element.querySelector(".spectrum-slider");
	  Spectrum.draggable(this.slider, this.onSliderMove.bind(this));

	  this.dragger = this.element.querySelector(".spectrum-color");
	  this.dragHelper = this.element.querySelector(".spectrum-dragger");
	  Spectrum.draggable(this.dragger, this.onDraggerMove.bind(this));

	  this.alphaSlider = this.element.querySelector(".spectrum-alpha");
	  this.alphaSliderInner = this.element.querySelector(".spectrum-alpha-inner");
	  this.alphaSliderHelper = this.element.querySelector(".spectrum-alpha-handle");
	  Spectrum.draggable(this.alphaSliderInner, this.onAlphaSliderMove.bind(this));

	  if (rgb) {
	    this.rgb = rgb;
	    this.updateUI();
	  }
	}

	module.exports.Spectrum = Spectrum;

	Spectrum.hsvToRgb = function (h, s, v, a) {
	  let r, g, b;

	  let i = Math.floor(h * 6);
	  let f = h * 6 - i;
	  let p = v * (1 - s);
	  let q = v * (1 - f * s);
	  let t = v * (1 - (1 - f) * s);

	  switch (i % 6) {
	    case 0: r = v; g = t; b = p; break;
	    case 1: r = q; g = v; b = p; break;
	    case 2: r = p; g = v; b = t; break;
	    case 3: r = p; g = q; b = v; break;
	    case 4: r = t; g = p; b = v; break;
	    case 5: r = v; g = p; b = q; break;
	  }

	  return [r * 255, g * 255, b * 255, a];
	};

	Spectrum.rgbToHsv = function (r, g, b, a) {
	  r = r / 255;
	  g = g / 255;
	  b = b / 255;

	  let max = Math.max(r, g, b), min = Math.min(r, g, b);
	  let h, s, v = max;

	  let d = max - min;
	  s = max == 0 ? 0 : d / max;

	  if (max == min) {
	    // achromatic
	    h = 0;
	  } else {
	    switch (max) {
	      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
	      case g: h = (b - r) / d + 2; break;
	      case b: h = (r - g) / d + 4; break;
	    }
	    h /= 6;
	  }
	  return [h, s, v, a];
	};

	Spectrum.draggable = function (element, onmove, onstart, onstop) {
	  onmove = onmove || function () {};
	  onstart = onstart || function () {};
	  onstop = onstop || function () {};

	  let doc = element.ownerDocument;
	  let dragging = false;
	  let offset = {};
	  let maxHeight = 0;
	  let maxWidth = 0;

	  function prevent(e) {
	    e.stopPropagation();
	    e.preventDefault();
	  }

	  function move(e) {
	    if (dragging) {
	      if (e.buttons === 0) {
	        // The button is no longer pressed but we did not get a mouseup event.
	        stop();
	        return;
	      }
	      let pageX = e.pageX;
	      let pageY = e.pageY;

	      let dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
	      let dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

	      onmove.apply(element, [dragX, dragY]);
	    }
	  }

	  function start(e) {
	    let rightclick = e.which === 3;

	    if (!rightclick && !dragging) {
	      if (onstart.apply(element, arguments) !== false) {
	        dragging = true;
	        maxHeight = element.offsetHeight;
	        maxWidth = element.offsetWidth;

	        offset = element.getBoundingClientRect();

	        move(e);

	        doc.addEventListener("selectstart", prevent, false);
	        doc.addEventListener("dragstart", prevent, false);
	        doc.addEventListener("mousemove", move, false);
	        doc.addEventListener("mouseup", stop, false);

	        prevent(e);
	      }
	    }
	  }

	  function stop() {
	    if (dragging) {
	      doc.removeEventListener("selectstart", prevent, false);
	      doc.removeEventListener("dragstart", prevent, false);
	      doc.removeEventListener("mousemove", move, false);
	      doc.removeEventListener("mouseup", stop, false);
	      onstop.apply(element, arguments);
	    }
	    dragging = false;
	  }

	  element.addEventListener("mousedown", start, false);
	};

	Spectrum.prototype = {
	  set rgb(color) {
	    this.hsv = Spectrum.rgbToHsv(color[0], color[1], color[2], color[3]);
	  },

	  get rgb() {
	    let rgb = Spectrum.hsvToRgb(this.hsv[0], this.hsv[1], this.hsv[2],
	      this.hsv[3]);
	    return [Math.round(rgb[0]), Math.round(rgb[1]), Math.round(rgb[2]),
	      Math.round(rgb[3] * 100) / 100];
	  },

	  get rgbNoSatVal() {
	    let rgb = Spectrum.hsvToRgb(this.hsv[0], 1, 1);
	    return [Math.round(rgb[0]), Math.round(rgb[1]), Math.round(rgb[2]), rgb[3]];
	  },

	  get rgbCssString() {
	    let rgb = this.rgb;
	    return "rgba(" + rgb[0] + ", " + rgb[1] + ", " + rgb[2] + ", " +
	      rgb[3] + ")";
	  },

	  show: function () {
	    this.element.classList.add("spectrum-show");

	    this.slideHeight = this.slider.offsetHeight;
	    this.dragWidth = this.dragger.offsetWidth;
	    this.dragHeight = this.dragger.offsetHeight;
	    this.dragHelperHeight = this.dragHelper.offsetHeight;
	    this.slideHelperHeight = this.slideHelper.offsetHeight;
	    this.alphaSliderWidth = this.alphaSliderInner.offsetWidth;
	    this.alphaSliderHelperWidth = this.alphaSliderHelper.offsetWidth;

	    this.updateUI();
	  },

	  onElementClick: function (e) {
	    e.stopPropagation();
	  },

	  onSliderMove: function (dragX, dragY) {
	    this.hsv[0] = (dragY / this.slideHeight);
	    this.updateUI();
	    this.onChange();
	  },

	  onDraggerMove: function (dragX, dragY) {
	    this.hsv[1] = dragX / this.dragWidth;
	    this.hsv[2] = (this.dragHeight - dragY) / this.dragHeight;
	    this.updateUI();
	    this.onChange();
	  },

	  onAlphaSliderMove: function (dragX, dragY) {
	    this.hsv[3] = dragX / this.alphaSliderWidth;
	    this.updateUI();
	    this.onChange();
	  },

	  onChange: function () {
	    this.emit("changed", this.rgb, this.rgbCssString);
	  },

	  updateHelperLocations: function () {
	    // If the UI hasn't been shown yet then none of the dimensions will be
	    // correct
	    if (!this.element.classList.contains("spectrum-show")) {
	      return;
	    }

	    let h = this.hsv[0];
	    let s = this.hsv[1];
	    let v = this.hsv[2];

	    // Placing the color dragger
	    let dragX = s * this.dragWidth;
	    let dragY = this.dragHeight - (v * this.dragHeight);
	    let helperDim = this.dragHelperHeight / 2;

	    dragX = Math.max(
	      -helperDim,
	      Math.min(this.dragWidth - helperDim, dragX - helperDim)
	    );
	    dragY = Math.max(
	      -helperDim,
	      Math.min(this.dragHeight - helperDim, dragY - helperDim)
	    );

	    this.dragHelper.style.top = dragY + "px";
	    this.dragHelper.style.left = dragX + "px";

	    // Placing the hue slider
	    let slideY = (h * this.slideHeight) - this.slideHelperHeight / 2;
	    this.slideHelper.style.top = slideY + "px";

	    // Placing the alpha slider
	    let alphaSliderX = (this.hsv[3] * this.alphaSliderWidth) -
	      (this.alphaSliderHelperWidth / 2);
	    this.alphaSliderHelper.style.left = alphaSliderX + "px";
	  },

	  updateUI: function () {
	    this.updateHelperLocations();

	    let rgb = this.rgb;
	    let rgbNoSatVal = this.rgbNoSatVal;

	    let flatColor = "rgb(" + rgbNoSatVal[0] + ", " + rgbNoSatVal[1] + ", " +
	      rgbNoSatVal[2] + ")";

	    this.dragger.style.backgroundColor = flatColor;

	    let rgbNoAlpha = "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
	    let rgbAlpha0 = "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ", 0)";
	    let alphaGradient = "linear-gradient(to right, " + rgbAlpha0 + ", " +
	      rgbNoAlpha + ")";
	    this.alphaSliderInner.style.background = alphaGradient;
	  },

	  destroy: function () {
	    this.element.removeEventListener("click", this.onElementClick, false);

	    this.parentEl.removeChild(this.element);

	    this.slider = null;
	    this.dragger = null;
	    this.alphaSlider = this.alphaSliderInner = this.alphaSliderHelper = null;
	    this.parentEl = null;
	    this.element = null;
	  }
	};


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013 Lea Verou. All rights reserved.
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a
	 * copy of this software and associated documentation files (the "Software"),
	 * to deal in the Software without restriction, including without limitation
	 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
	 * and/or sell copies of the Software, and to permit persons to whom the
	 * Software is furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
	 * DEALINGS IN THE SOFTWARE.
	 */

	// Based on www.cubic-bezier.com by Lea Verou
	// See https://github.com/LeaVerou/cubic-bezier

	"use strict";

	const EventEmitter = __webpack_require__(6);
	const {
	  PREDEFINED,
	  PRESETS,
	  DEFAULT_PRESET_CATEGORY
	} = __webpack_require__(195);
	const {getCSSLexer} = __webpack_require__(174);
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	/**
	 * CubicBezier data structure helper
	 * Accepts an array of coordinates and exposes a few useful getters
	 * @param {Array} coordinates i.e. [.42, 0, .58, 1]
	 */
	function CubicBezier(coordinates) {
	  if (!coordinates) {
	    throw new Error("No offsets were defined");
	  }

	  this.coordinates = coordinates.map(n => +n);

	  for (let i = 4; i--;) {
	    let xy = this.coordinates[i];
	    if (isNaN(xy) || (!(i % 2) && (xy < 0 || xy > 1))) {
	      throw new Error(`Wrong coordinate at ${i}(${xy})`);
	    }
	  }

	  this.coordinates.toString = function () {
	    return this.map(n => {
	      return (Math.round(n * 100) / 100 + "").replace(/^0\./, ".");
	    }) + "";
	  };
	}

	exports.CubicBezier = CubicBezier;

	CubicBezier.prototype = {
	  get P1() {
	    return this.coordinates.slice(0, 2);
	  },

	  get P2() {
	    return this.coordinates.slice(2);
	  },

	  toString: function () {
	    // Check first if current coords are one of css predefined functions
	    let predefName = Object.keys(PREDEFINED)
	                           .find(key => coordsAreEqual(PREDEFINED[key],
	                                                       this.coordinates));

	    return predefName || "cubic-bezier(" + this.coordinates + ")";
	  }
	};

	/**
	 * Bezier curve canvas plotting class
	 * @param {DOMNode} canvas
	 * @param {CubicBezier} bezier
	 * @param {Array} padding Amount of horizontal,vertical padding around the graph
	 */
	function BezierCanvas(canvas, bezier, padding) {
	  this.canvas = canvas;
	  this.bezier = bezier;
	  this.padding = getPadding(padding);

	  // Convert to a cartesian coordinate system with axes from 0 to 1
	  this.ctx = this.canvas.getContext("2d");
	  let p = this.padding;

	  this.ctx.scale(canvas.width * (1 - p[1] - p[3]),
	                 -canvas.height * (1 - p[0] - p[2]));
	  this.ctx.translate(p[3] / (1 - p[1] - p[3]),
	                     -1 - p[0] / (1 - p[0] - p[2]));
	}

	exports.BezierCanvas = BezierCanvas;

	BezierCanvas.prototype = {
	  /**
	   * Get P1 and P2 current top/left offsets so they can be positioned
	   * @return {Array} Returns an array of 2 {top:String,left:String} objects
	   */
	  get offsets() {
	    let p = this.padding, w = this.canvas.width, h = this.canvas.height;

	    return [{
	      left: w * (this.bezier.coordinates[0] * (1 - p[3] - p[1]) - p[3]) + "px",
	      top: h * (1 - this.bezier.coordinates[1] * (1 - p[0] - p[2]) - p[0])
	           + "px"
	    }, {
	      left: w * (this.bezier.coordinates[2] * (1 - p[3] - p[1]) - p[3]) + "px",
	      top: h * (1 - this.bezier.coordinates[3] * (1 - p[0] - p[2]) - p[0])
	           + "px"
	    }];
	  },

	  /**
	   * Convert an element's left/top offsets into coordinates
	   */
	  offsetsToCoordinates: function (element) {
	    let p = this.padding, w = this.canvas.width, h = this.canvas.height;

	    // Convert padding percentage to actual padding
	    p = p.map((a, i) => a * (i % 2 ? w : h));

	    return [
	      (parseFloat(element.style.left) - p[3]) / (w + p[1] + p[3]),
	      (h - parseFloat(element.style.top) - p[2]) / (h - p[0] - p[2])
	    ];
	  },

	  /**
	   * Draw the cubic bezier curve for the current coordinates
	   */
	  plot: function (settings = {}) {
	    let xy = this.bezier.coordinates;

	    let defaultSettings = {
	      handleColor: "#666",
	      handleThickness: .008,
	      bezierColor: "#4C9ED9",
	      bezierThickness: .015,
	      drawHandles: true
	    };

	    for (let setting in settings) {
	      defaultSettings[setting] = settings[setting];
	    }

	    // Clear the canvas –making sure to clear the
	    // whole area by resetting the transform first.
	    this.ctx.save();
	    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
	    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
	    this.ctx.restore();

	    if (defaultSettings.drawHandles) {
	      // Draw control handles
	      this.ctx.beginPath();
	      this.ctx.fillStyle = defaultSettings.handleColor;
	      this.ctx.lineWidth = defaultSettings.handleThickness;
	      this.ctx.strokeStyle = defaultSettings.handleColor;

	      this.ctx.moveTo(0, 0);
	      this.ctx.lineTo(xy[0], xy[1]);
	      this.ctx.moveTo(1, 1);
	      this.ctx.lineTo(xy[2], xy[3]);

	      this.ctx.stroke();
	      this.ctx.closePath();

	      let circle = (ctx, cx, cy, r) => {
	        ctx.beginPath();
	        ctx.arc(cx, cy, r, 0, 2 * Math.PI, !1);
	        ctx.closePath();
	      };

	      circle(this.ctx, xy[0], xy[1], 1.5 * defaultSettings.handleThickness);
	      this.ctx.fill();
	      circle(this.ctx, xy[2], xy[3], 1.5 * defaultSettings.handleThickness);
	      this.ctx.fill();
	    }

	    // Draw bezier curve
	    this.ctx.beginPath();
	    this.ctx.lineWidth = defaultSettings.bezierThickness;
	    this.ctx.strokeStyle = defaultSettings.bezierColor;
	    this.ctx.moveTo(0, 0);
	    this.ctx.bezierCurveTo(xy[0], xy[1], xy[2], xy[3], 1, 1);
	    this.ctx.stroke();
	    this.ctx.closePath();
	  }
	};

	/**
	 * Cubic-bezier widget. Uses the BezierCanvas class to draw the curve and
	 * adds the control points and user interaction
	 * @param {DOMNode} parent The container where the graph should be created
	 * @param {Array} coordinates Coordinates of the curve to be drawn
	 *
	 * Emits "updated" events whenever the curve is changed. Along with the event is
	 * sent a CubicBezier object
	 */
	function CubicBezierWidget(parent,
	                           coordinates = PRESETS["ease-in"]["ease-in-sine"]) {
	  EventEmitter.decorate(this);

	  this.parent = parent;
	  let {curve, p1, p2} = this._initMarkup();

	  this.curveBoundingBox = curve.getBoundingClientRect();
	  this.curve = curve;
	  this.p1 = p1;
	  this.p2 = p2;

	  // Create and plot the bezier curve
	  this.bezierCanvas = new BezierCanvas(this.curve,
	    new CubicBezier(coordinates), [0.30, 0]);
	  this.bezierCanvas.plot();

	  // Place the control points
	  let offsets = this.bezierCanvas.offsets;
	  this.p1.style.left = offsets[0].left;
	  this.p1.style.top = offsets[0].top;
	  this.p2.style.left = offsets[1].left;
	  this.p2.style.top = offsets[1].top;

	  this._onPointMouseDown = this._onPointMouseDown.bind(this);
	  this._onPointKeyDown = this._onPointKeyDown.bind(this);
	  this._onCurveClick = this._onCurveClick.bind(this);
	  this._onNewCoordinates = this._onNewCoordinates.bind(this);

	  // Add preset preview menu
	  this.presets = new CubicBezierPresetWidget(parent);

	  // Add the timing function previewer
	  this.timingPreview = new TimingFunctionPreviewWidget(parent);

	  this._initEvents();
	}

	exports.CubicBezierWidget = CubicBezierWidget;

	CubicBezierWidget.prototype = {
	  _initMarkup: function () {
	    let doc = this.parent.ownerDocument;

	    let wrap = doc.createElementNS(XHTML_NS, "div");
	    wrap.className = "display-wrap";

	    let plane = doc.createElementNS(XHTML_NS, "div");
	    plane.className = "coordinate-plane";

	    let p1 = doc.createElementNS(XHTML_NS, "button");
	    p1.className = "control-point";
	    plane.appendChild(p1);

	    let p2 = doc.createElementNS(XHTML_NS, "button");
	    p2.className = "control-point";
	    plane.appendChild(p2);

	    let curve = doc.createElementNS(XHTML_NS, "canvas");
	    curve.setAttribute("width", 150);
	    curve.setAttribute("height", 370);
	    curve.className = "curve";

	    plane.appendChild(curve);
	    wrap.appendChild(plane);

	    this.parent.appendChild(wrap);

	    return {
	      p1,
	      p2,
	      curve
	    };
	  },

	  _removeMarkup: function () {
	    this.parent.querySelector(".display-wrap").remove();
	  },

	  _initEvents: function () {
	    this.p1.addEventListener("mousedown", this._onPointMouseDown);
	    this.p2.addEventListener("mousedown", this._onPointMouseDown);

	    this.p1.addEventListener("keydown", this._onPointKeyDown);
	    this.p2.addEventListener("keydown", this._onPointKeyDown);

	    this.curve.addEventListener("click", this._onCurveClick);

	    this.presets.on("new-coordinates", this._onNewCoordinates);
	  },

	  _removeEvents: function () {
	    this.p1.removeEventListener("mousedown", this._onPointMouseDown);
	    this.p2.removeEventListener("mousedown", this._onPointMouseDown);

	    this.p1.removeEventListener("keydown", this._onPointKeyDown);
	    this.p2.removeEventListener("keydown", this._onPointKeyDown);

	    this.curve.removeEventListener("click", this._onCurveClick);

	    this.presets.off("new-coordinates", this._onNewCoordinates);
	  },

	  _onPointMouseDown: function (event) {
	    // Updating the boundingbox in case it has changed
	    this.curveBoundingBox = this.curve.getBoundingClientRect();

	    let point = event.target;
	    let doc = point.ownerDocument;
	    let self = this;

	    doc.onmousemove = function drag(e) {
	      let x = e.pageX;
	      let y = e.pageY;
	      let left = self.curveBoundingBox.left;
	      let top = self.curveBoundingBox.top;

	      if (x === 0 && y == 0) {
	        return;
	      }

	      // Constrain x
	      x = Math.min(Math.max(left, x), left + self.curveBoundingBox.width);

	      point.style.left = x - left + "px";
	      point.style.top = y - top + "px";

	      self._updateFromPoints();
	    };

	    doc.onmouseup = function () {
	      point.focus();
	      doc.onmousemove = doc.onmouseup = null;
	    };
	  },

	  _onPointKeyDown: function (event) {
	    let point = event.target;
	    let code = event.keyCode;

	    if (code >= 37 && code <= 40) {
	      event.preventDefault();

	      // Arrow keys pressed
	      let left = parseInt(point.style.left, 10);
	      let top = parseInt(point.style.top, 10);
	      let offset = 3 * (event.shiftKey ? 10 : 1);

	      switch (code) {
	        case 37: point.style.left = left - offset + "px"; break;
	        case 38: point.style.top = top - offset + "px"; break;
	        case 39: point.style.left = left + offset + "px"; break;
	        case 40: point.style.top = top + offset + "px"; break;
	      }

	      this._updateFromPoints();
	    }
	  },

	  _onCurveClick: function (event) {
	    this.curveBoundingBox = this.curve.getBoundingClientRect();

	    let left = this.curveBoundingBox.left;
	    let top = this.curveBoundingBox.top;
	    let x = event.pageX - left;
	    let y = event.pageY - top;

	    // Find which point is closer
	    let distP1 = distance(x, y,
	      parseInt(this.p1.style.left, 10), parseInt(this.p1.style.top, 10));
	    let distP2 = distance(x, y,
	      parseInt(this.p2.style.left, 10), parseInt(this.p2.style.top, 10));

	    let point = distP1 < distP2 ? this.p1 : this.p2;
	    point.style.left = x + "px";
	    point.style.top = y + "px";

	    this._updateFromPoints();
	  },

	  _onNewCoordinates: function (event, coordinates) {
	    this.coordinates = coordinates;
	  },

	  /**
	   * Get the current point coordinates and redraw the curve to match
	   */
	  _updateFromPoints: function () {
	    // Get the new coordinates from the point's offsets
	    let coordinates = this.bezierCanvas.offsetsToCoordinates(this.p1);
	    coordinates = coordinates.concat(
	      this.bezierCanvas.offsetsToCoordinates(this.p2)
	    );

	    this.presets.refreshMenu(coordinates);
	    this._redraw(coordinates);
	  },

	  /**
	   * Redraw the curve
	   * @param {Array} coordinates The array of control point coordinates
	   */
	  _redraw: function (coordinates) {
	    // Provide a new CubicBezier to the canvas and plot the curve
	    this.bezierCanvas.bezier = new CubicBezier(coordinates);
	    this.bezierCanvas.plot();
	    this.emit("updated", this.bezierCanvas.bezier);

	    this.timingPreview.preview(this.bezierCanvas.bezier + "");
	  },

	  /**
	   * Set new coordinates for the control points and redraw the curve
	   * @param {Array} coordinates
	   */
	  set coordinates(coordinates) {
	    this._redraw(coordinates);

	    // Move the points
	    let offsets = this.bezierCanvas.offsets;
	    this.p1.style.left = offsets[0].left;
	    this.p1.style.top = offsets[0].top;
	    this.p2.style.left = offsets[1].left;
	    this.p2.style.top = offsets[1].top;
	  },

	  /**
	   * Set new coordinates for the control point and redraw the curve
	   * @param {String} value A string value. E.g. "linear",
	   * "cubic-bezier(0,0,1,1)"
	   */
	  set cssCubicBezierValue(value) {
	    if (!value) {
	      return;
	    }

	    value = value.trim();

	    // Try with one of the predefined values
	    let coordinates = parseTimingFunction(value);

	    this.presets.refreshMenu(coordinates);
	    this.coordinates = coordinates;
	  },

	  destroy: function () {
	    this._removeEvents();
	    this._removeMarkup();

	    this.timingPreview.destroy();
	    this.presets.destroy();

	    this.curve = this.p1 = this.p2 = null;
	  }
	};

	/**
	 * CubicBezierPreset widget.
	 * Builds a menu of presets from CubicBezierPresets
	 * @param {DOMNode} parent The container where the preset panel should be
	 * created
	 *
	 * Emits "new-coordinate" event along with the coordinates
	 * whenever a preset is selected.
	 */
	function CubicBezierPresetWidget(parent) {
	  this.parent = parent;

	  let {presetPane, presets, categories} = this._initMarkup();
	  this.presetPane = presetPane;
	  this.presets = presets;
	  this.categories = categories;

	  this._activeCategory = null;
	  this._activePresetList = null;
	  this._activePreset = null;

	  this._onCategoryClick = this._onCategoryClick.bind(this);
	  this._onPresetClick = this._onPresetClick.bind(this);

	  EventEmitter.decorate(this);
	  this._initEvents();
	}

	exports.CubicBezierPresetWidget = CubicBezierPresetWidget;

	CubicBezierPresetWidget.prototype = {
	  /*
	   * Constructs a list of all preset categories and a list
	   * of presets for each category.
	   *
	   * High level markup:
	   *  div .preset-pane
	   *    div .preset-categories
	   *      div .category
	   *      div .category
	   *      ...
	   *    div .preset-container
	   *      div .presetList
	   *        div .preset
	   *        ...
	   *      div .presetList
	   *        div .preset
	   *        ...
	   */
	  _initMarkup: function () {
	    let doc = this.parent.ownerDocument;

	    let presetPane = doc.createElementNS(XHTML_NS, "div");
	    presetPane.className = "preset-pane";

	    let categoryList = doc.createElementNS(XHTML_NS, "div");
	    categoryList.id = "preset-categories";

	    let presetContainer = doc.createElementNS(XHTML_NS, "div");
	    presetContainer.id = "preset-container";

	    Object.keys(PRESETS).forEach(categoryLabel => {
	      let category = this._createCategory(categoryLabel);
	      categoryList.appendChild(category);

	      let presetList = this._createPresetList(categoryLabel);
	      presetContainer.appendChild(presetList);
	    });

	    presetPane.appendChild(categoryList);
	    presetPane.appendChild(presetContainer);

	    this.parent.appendChild(presetPane);

	    let allCategories = presetPane.querySelectorAll(".category");
	    let allPresets = presetPane.querySelectorAll(".preset");

	    return {
	      presetPane: presetPane,
	      presets: allPresets,
	      categories: allCategories
	    };
	  },

	  _createCategory: function (categoryLabel) {
	    let doc = this.parent.ownerDocument;

	    let category = doc.createElementNS(XHTML_NS, "div");
	    category.id = categoryLabel;
	    category.classList.add("category");

	    let categoryDisplayLabel = this._normalizeCategoryLabel(categoryLabel);
	    category.textContent = categoryDisplayLabel;
	    category.setAttribute("title", categoryDisplayLabel);

	    return category;
	  },

	  _normalizeCategoryLabel: function (categoryLabel) {
	    return categoryLabel.replace("/-/g", " ");
	  },

	  _createPresetList: function (categoryLabel) {
	    let doc = this.parent.ownerDocument;

	    let presetList = doc.createElementNS(XHTML_NS, "div");
	    presetList.id = "preset-category-" + categoryLabel;
	    presetList.classList.add("preset-list");

	    Object.keys(PRESETS[categoryLabel]).forEach(presetLabel => {
	      let preset = this._createPreset(categoryLabel, presetLabel);
	      presetList.appendChild(preset);
	    });

	    return presetList;
	  },

	  _createPreset: function (categoryLabel, presetLabel) {
	    let doc = this.parent.ownerDocument;

	    let preset = doc.createElementNS(XHTML_NS, "div");
	    preset.classList.add("preset");
	    preset.id = presetLabel;
	    preset.coordinates = PRESETS[categoryLabel][presetLabel];
	    // Create preset preview
	    let curve = doc.createElementNS(XHTML_NS, "canvas");
	    let bezier = new CubicBezier(preset.coordinates);
	    curve.setAttribute("height", 50);
	    curve.setAttribute("width", 50);
	    preset.bezierCanvas = new BezierCanvas(curve, bezier, [0.15, 0]);
	    preset.bezierCanvas.plot({
	      drawHandles: false,
	      bezierThickness: 0.025
	    });
	    preset.appendChild(curve);

	    // Create preset label
	    let presetLabelElem = doc.createElementNS(XHTML_NS, "p");
	    let presetDisplayLabel = this._normalizePresetLabel(categoryLabel,
	                                                        presetLabel);
	    presetLabelElem.textContent = presetDisplayLabel;
	    preset.appendChild(presetLabelElem);
	    preset.setAttribute("title", presetDisplayLabel);

	    return preset;
	  },

	  _normalizePresetLabel: function (categoryLabel, presetLabel) {
	    return presetLabel.replace(categoryLabel + "-", "").replace("/-/g", " ");
	  },

	  _initEvents: function () {
	    for (let category of this.categories) {
	      category.addEventListener("click", this._onCategoryClick);
	    }

	    for (let preset of this.presets) {
	      preset.addEventListener("click", this._onPresetClick);
	    }
	  },

	  _removeEvents: function () {
	    for (let category of this.categories) {
	      category.removeEventListener("click", this._onCategoryClick);
	    }

	    for (let preset of this.presets) {
	      preset.removeEventListener("click", this._onPresetClick);
	    }
	  },

	  _onPresetClick: function (event) {
	    this.emit("new-coordinates", event.currentTarget.coordinates);
	    this.activePreset = event.currentTarget;
	  },

	  _onCategoryClick: function (event) {
	    this.activeCategory = event.target;
	  },

	  _setActivePresetList: function (presetListId) {
	    let presetList = this.presetPane.querySelector("#" + presetListId);
	    swapClassName("active-preset-list", this._activePresetList, presetList);
	    this._activePresetList = presetList;
	  },

	  set activeCategory(category) {
	    swapClassName("active-category", this._activeCategory, category);
	    this._activeCategory = category;
	    this._setActivePresetList("preset-category-" + category.id);
	  },

	  get activeCategory() {
	    return this._activeCategory;
	  },

	  set activePreset(preset) {
	    swapClassName("active-preset", this._activePreset, preset);
	    this._activePreset = preset;
	  },

	  get activePreset() {
	    return this._activePreset;
	  },

	  /**
	   * Called by CubicBezierWidget onload and when
	   * the curve is modified via the canvas.
	   * Attempts to match the new user setting with an
	   * existing preset.
	   * @param {Array} coordinates new coords [i, j, k, l]
	   */
	  refreshMenu: function (coordinates) {
	    // If we cannot find a matching preset, keep
	    // menu on last known preset category.
	    let category = this._activeCategory;

	    // If we cannot find a matching preset
	    // deselect any selected preset.
	    let preset = null;

	    // If a category has never been viewed before
	    // show the default category.
	    if (!category) {
	      category = this.parent.querySelector("#" + DEFAULT_PRESET_CATEGORY);
	    }

	    // If the new coordinates do match a preset,
	    // set its category and preset button as active.
	    Object.keys(PRESETS).forEach(categoryLabel => {
	      Object.keys(PRESETS[categoryLabel]).forEach(presetLabel => {
	        if (coordsAreEqual(PRESETS[categoryLabel][presetLabel], coordinates)) {
	          category = this.parent.querySelector("#" + categoryLabel);
	          preset = this.parent.querySelector("#" + presetLabel);
	        }
	      });
	    });

	    this.activeCategory = category;
	    this.activePreset = preset;
	  },

	  destroy: function () {
	    this._removeEvents();
	    this.parent.querySelector(".preset-pane").remove();
	  }
	};

	/**
	 * The TimingFunctionPreviewWidget animates a dot on a scale with a given
	 * timing-function
	 * @param {DOMNode} parent The container where this widget should go
	 */
	function TimingFunctionPreviewWidget(parent) {
	  this.previousValue = null;
	  this.autoRestartAnimation = null;

	  this.parent = parent;
	  this._initMarkup();
	}

	TimingFunctionPreviewWidget.prototype = {
	  PREVIEW_DURATION: 1000,

	  _initMarkup: function () {
	    let doc = this.parent.ownerDocument;

	    let container = doc.createElementNS(XHTML_NS, "div");
	    container.className = "timing-function-preview";

	    this.dot = doc.createElementNS(XHTML_NS, "div");
	    this.dot.className = "dot";
	    container.appendChild(this.dot);

	    let scale = doc.createElementNS(XHTML_NS, "div");
	    scale.className = "scale";
	    container.appendChild(scale);

	    this.parent.appendChild(container);
	  },

	  destroy: function () {
	    clearTimeout(this.autoRestartAnimation);
	    this.parent.querySelector(".timing-function-preview").remove();
	    this.parent = this.dot = null;
	  },

	  /**
	   * Preview a new timing function. The current preview will only be stopped if
	   * the supplied function value is different from the previous one. If the
	   * supplied function is invalid, the preview will stop.
	   * @param {String} value
	   */
	  preview: function (value) {
	    // Don't restart the preview animation if the value is the same
	    if (value === this.previousValue) {
	      return;
	    }

	    clearTimeout(this.autoRestartAnimation);

	    if (parseTimingFunction(value)) {
	      this.dot.style.animationTimingFunction = value;
	      this.restartAnimation();
	    }

	    this.previousValue = value;
	  },

	  /**
	   * Re-start the preview animation from the beginning
	   */
	  restartAnimation: function () {
	    // Just toggling the class won't do it unless there's a sync reflow
	    this.dot.animate([
	      { left: "-7px", offset: 0 },
	      { left: "143px", offset: 0.25 },
	      { left: "143px", offset: 0.5 },
	      { left: "-7px", offset: 0.75 },
	      { left: "-7px", offset: 1 }
	    ], {
	      duration: (this.PREVIEW_DURATION * 2),
	      fill: "forwards"
	    });

	    // Restart it again after a while
	    this.autoRestartAnimation = setTimeout(this.restartAnimation.bind(this),
	      this.PREVIEW_DURATION * 2);
	  }
	};

	// Helpers

	function getPadding(padding) {
	  let p = typeof padding === "number" ? [padding] : padding;

	  if (p.length === 1) {
	    p[1] = p[0];
	  }

	  if (p.length === 2) {
	    p[2] = p[0];
	  }

	  if (p.length === 3) {
	    p[3] = p[1];
	  }

	  return p;
	}

	function distance(x1, y1, x2, y2) {
	  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
	}

	/**
	 * Parse a string to see whether it is a valid timing function.
	 * If it is, return the coordinates as an array.
	 * Otherwise, return undefined.
	 * @param {String} value
	 * @return {Array} of coordinates, or undefined
	 */
	function parseTimingFunction(value) {
	  if (value in PREDEFINED) {
	    return PREDEFINED[value];
	  }

	  let tokenStream = getCSSLexer(value);
	  let getNextToken = () => {
	    while (true) {
	      let token = tokenStream.nextToken();
	      if (!token || (token.tokenType !== "whitespace" &&
	                     token.tokenType !== "comment")) {
	        return token;
	      }
	    }
	  };

	  let token = getNextToken();
	  if (token.tokenType !== "function" || token.text !== "cubic-bezier") {
	    return undefined;
	  }

	  let result = [];
	  for (let i = 0; i < 4; ++i) {
	    token = getNextToken();
	    if (!token || token.tokenType !== "number") {
	      return undefined;
	    }
	    result.push(token.number);

	    token = getNextToken();
	    if (!token || token.tokenType !== "symbol" ||
	        token.text !== (i == 3 ? ")" : ",")) {
	      return undefined;
	    }
	  }

	  return result;
	}

	// This is exported for testing.
	exports._parseTimingFunction = parseTimingFunction;

	/**
	 * Removes a class from a node and adds it to another.
	 * @param {String} className the class to swap
	 * @param {DOMNode} from the node to remove the class from
	 * @param {DOMNode} to the node to add the class to
	 */
	function swapClassName(className, from, to) {
	  if (from !== null) {
	    from.classList.remove(className);
	  }

	  if (to !== null) {
	    to.classList.add(className);
	  }
	}

	/**
	 * Compares two arrays of coordinates [i, j, k, l]
	 * @param {Array} c1 first coordinate array to compare
	 * @param {Array} c2 second coordinate array to compare
	 * @return {Boolean}
	 */
	function coordsAreEqual(c1, c2) {
	  return c1.reduce((prev, curr, index) => prev && (curr === c2[index]), true);
	}


/***/ },
/* 195 */
/***/ function(module, exports) {

	/**
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
	 */

	// Set of preset definitions for use with CubicBezierWidget
	// Credit: http://easings.net

	"use strict";

	const PREDEFINED = {
	  "ease": [0.25, 0.1, 0.25, 1],
	  "linear": [0, 0, 1, 1],
	  "ease-in": [0.42, 0, 1, 1],
	  "ease-out": [0, 0, 0.58, 1],
	  "ease-in-out": [0.42, 0, 0.58, 1]
	};

	const PRESETS = {
	  "ease-in": {
	    "ease-in-linear": [0, 0, 1, 1],
	    "ease-in-ease-in": [0.42, 0, 1, 1],
	    "ease-in-sine": [0.47, 0, 0.74, 0.71],
	    "ease-in-quadratic": [0.55, 0.09, 0.68, 0.53],
	    "ease-in-cubic": [0.55, 0.06, 0.68, 0.19],
	    "ease-in-quartic": [0.9, 0.03, 0.69, 0.22],
	    "ease-in-quintic": [0.76, 0.05, 0.86, 0.06],
	    "ease-in-exponential": [0.95, 0.05, 0.8, 0.04],
	    "ease-in-circular": [0.6, 0.04, 0.98, 0.34],
	    "ease-in-backward": [0.6, -0.28, 0.74, 0.05]
	  },
	  "ease-out": {
	    "ease-out-linear": [0, 0, 1, 1],
	    "ease-out-ease-out": [0, 0, 0.58, 1],
	    "ease-out-sine": [0.39, 0.58, 0.57, 1],
	    "ease-out-quadratic": [0.25, 0.46, 0.45, 0.94],
	    "ease-out-cubic": [0.22, 0.61, 0.36, 1],
	    "ease-out-quartic": [0.17, 0.84, 0.44, 1],
	    "ease-out-quintic": [0.23, 1, 0.32, 1],
	    "ease-out-exponential": [0.19, 1, 0.22, 1],
	    "ease-out-circular": [0.08, 0.82, 0.17, 1],
	    "ease-out-backward": [0.18, 0.89, 0.32, 1.28]
	  },
	  "ease-in-out": {
	    "ease-in-out-linear": [0, 0, 1, 1],
	    "ease-in-out-ease": [0.25, 0.1, 0.25, 1],
	    "ease-in-out-ease-in-out": [0.42, 0, 0.58, 1],
	    "ease-in-out-sine": [0.45, 0.05, 0.55, 0.95],
	    "ease-in-out-quadratic": [0.46, 0.03, 0.52, 0.96],
	    "ease-in-out-cubic": [0.65, 0.05, 0.36, 1],
	    "ease-in-out-quartic": [0.77, 0, 0.18, 1],
	    "ease-in-out-quintic": [0.86, 0, 0.07, 1],
	    "ease-in-out-exponential": [1, 0, 0, 1],
	    "ease-in-out-circular": [0.79, 0.14, 0.15, 0.86],
	    "ease-in-out-backward": [0.68, -0.55, 0.27, 1.55]
	  }
	};

	const DEFAULT_PRESET_CATEGORY = Object.keys(PRESETS)[0];

	exports.PRESETS = PRESETS;
	exports.PREDEFINED = PREDEFINED;
	exports.DEFAULT_PRESET_CATEGORY = DEFAULT_PRESET_CATEGORY;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	  * This is a CSS Filter Editor widget used
	  * for Rule View's filter swatches
	  */

	const EventEmitter = __webpack_require__(6);
	const { Cc, Ci } = __webpack_require__(9);
	const XHTML_NS = "http://www.w3.org/1999/xhtml";

	const { LocalizationHelper } = __webpack_require__(56);
	const STRINGS_URI = "devtools/locale/filterwidget.properties";
	const L10N = new LocalizationHelper(STRINGS_URI);

	const {cssTokenizer} = __webpack_require__(182);

	const asyncStorage = __webpack_require__(197);

	({ lazyRequireGetter: () => {} }).lazyGetter(this, "DOMUtils", () => {
	  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	});

	const DEFAULT_FILTER_TYPE = "length";
	const UNIT_MAPPING = {
	  percentage: "%",
	  length: "px",
	  angle: "deg",
	  string: ""
	};

	const FAST_VALUE_MULTIPLIER = 10;
	const SLOW_VALUE_MULTIPLIER = 0.1;
	const DEFAULT_VALUE_MULTIPLIER = 1;

	const LIST_PADDING = 7;
	const LIST_ITEM_HEIGHT = 32;

	const filterList = [
	  {
	    "name": "blur",
	    "range": [0, Infinity],
	    "type": "length"
	  },
	  {
	    "name": "brightness",
	    "range": [0, Infinity],
	    "type": "percentage"
	  },
	  {
	    "name": "contrast",
	    "range": [0, Infinity],
	    "type": "percentage"
	  },
	  {
	    "name": "drop-shadow",
	    "placeholder": L10N.getStr("dropShadowPlaceholder"),
	    "type": "string"
	  },
	  {
	    "name": "grayscale",
	    "range": [0, 100],
	    "type": "percentage"
	  },
	  {
	    "name": "hue-rotate",
	    "range": [0, Infinity],
	    "type": "angle"
	  },
	  {
	    "name": "invert",
	    "range": [0, 100],
	    "type": "percentage"
	  },
	  {
	    "name": "opacity",
	    "range": [0, 100],
	    "type": "percentage"
	  },
	  {
	    "name": "saturate",
	    "range": [0, Infinity],
	    "type": "percentage"
	  },
	  {
	    "name": "sepia",
	    "range": [0, 100],
	    "type": "percentage"
	  },
	  {
	    "name": "url",
	    "placeholder": "example.svg#c1",
	    "type": "string"
	  }
	];

	// Valid values that shouldn't be parsed for filters.
	const SPECIAL_VALUES = new Set(["none", "unset", "initial", "inherit"]);

	/**
	 * A CSS Filter editor widget used to add/remove/modify
	 * filters.
	 *
	 * Normally, it takes a CSS filter value as input, parses it
	 * and creates the required elements / bindings.
	 *
	 * You can, however, use add/remove/update methods manually.
	 * See each method's comments for more details
	 *
	 * @param {nsIDOMNode} el
	 *        The widget container.
	 * @param {String} value
	 *        CSS filter value
	 */
	function CSSFilterEditorWidget(el, value = "") {
	  this.doc = el.ownerDocument;
	  this.win = this.doc.defaultView;
	  this.el = el;

	  this._addButtonClick = this._addButtonClick.bind(this);
	  this._removeButtonClick = this._removeButtonClick.bind(this);
	  this._mouseMove = this._mouseMove.bind(this);
	  this._mouseUp = this._mouseUp.bind(this);
	  this._mouseDown = this._mouseDown.bind(this);
	  this._keyDown = this._keyDown.bind(this);
	  this._input = this._input.bind(this);
	  this._presetClick = this._presetClick.bind(this);
	  this._savePreset = this._savePreset.bind(this);
	  this._togglePresets = this._togglePresets.bind(this);
	  this._resetFocus = this._resetFocus.bind(this);

	  // Passed to asyncStorage, requires binding
	  this.renderPresets = this.renderPresets.bind(this);

	  this._initMarkup();
	  this._buildFilterItemMarkup();
	  this._buildPresetItemMarkup();
	  this._addEventListeners();

	  EventEmitter.decorate(this);

	  this.filters = [];
	  this.setCssValue(value);
	  this.renderPresets();
	}

	exports.CSSFilterEditorWidget = CSSFilterEditorWidget;

	CSSFilterEditorWidget.prototype = {
	  _initMarkup: function () {
	    let filterListSelectPlaceholder =
	      L10N.getStr("filterListSelectPlaceholder");
	    let addNewFilterButton = L10N.getStr("addNewFilterButton");
	    let presetsToggleButton = L10N.getStr("presetsToggleButton");
	    let newPresetPlaceholder = L10N.getStr("newPresetPlaceholder");
	    let savePresetButton = L10N.getStr("savePresetButton");

	    this.el.innerHTML = `
	      <div class="filters-list">
	        <div id="filters"></div>
	        <div class="footer">
	          <select value="">
	            <option value="">${filterListSelectPlaceholder}</option>
	          </select>
	          <button id="add-filter" class="add">${addNewFilterButton}</button>
	          <button id="toggle-presets">${presetsToggleButton}</button>
	        </div>
	      </div>

	      <div class="presets-list">
	        <div id="presets"></div>
	        <div class="footer">
	          <input value="" class="devtools-textinput"
	                 placeholder="${newPresetPlaceholder}"></input>
	          <button class="add">${savePresetButton}</button>
	        </div>
	      </div>
	    `;
	    this.filtersList = this.el.querySelector("#filters");
	    this.presetsList = this.el.querySelector("#presets");
	    this.togglePresets = this.el.querySelector("#toggle-presets");
	    this.filterSelect = this.el.querySelector("select");
	    this.addPresetButton = this.el.querySelector(".presets-list .add");
	    this.addPresetInput = this.el.querySelector(".presets-list .footer input");

	    this.el.querySelector(".presets-list input").value = "";

	    this._populateFilterSelect();
	  },

	  _destroyMarkup: function () {
	    this._filterItemMarkup.remove();
	    this.el.remove();
	    this.el = this.filtersList = this._filterItemMarkup = null;
	    this.presetsList = this.togglePresets = this.filterSelect = null;
	    this.addPresetButton = null;
	  },

	  destroy: function () {
	    this._removeEventListeners();
	    this._destroyMarkup();
	  },

	  /**
	    * Creates <option> elements for each filter definition
	    * in filterList
	    */
	  _populateFilterSelect: function () {
	    let select = this.filterSelect;
	    filterList.forEach(filter => {
	      let option = this.doc.createElementNS(XHTML_NS, "option");
	      option.innerHTML = option.value = filter.name;
	      select.appendChild(option);
	    });
	  },

	  /**
	    * Creates a template for filter elements which is cloned and used in render
	    */
	  _buildFilterItemMarkup: function () {
	    let base = this.doc.createElementNS(XHTML_NS, "div");
	    base.className = "filter";

	    let name = this.doc.createElementNS(XHTML_NS, "div");
	    name.className = "filter-name";

	    let value = this.doc.createElementNS(XHTML_NS, "div");
	    value.className = "filter-value";

	    let drag = this.doc.createElementNS(XHTML_NS, "i");
	    drag.title = L10N.getStr("dragHandleTooltipText");

	    let label = this.doc.createElementNS(XHTML_NS, "label");

	    name.appendChild(drag);
	    name.appendChild(label);

	    let unitPreview = this.doc.createElementNS(XHTML_NS, "span");
	    let input = this.doc.createElementNS(XHTML_NS, "input");
	    input.classList.add("devtools-textinput");

	    value.appendChild(input);
	    value.appendChild(unitPreview);

	    let removeButton = this.doc.createElementNS(XHTML_NS, "button");
	    removeButton.className = "remove-button";

	    base.appendChild(name);
	    base.appendChild(value);
	    base.appendChild(removeButton);

	    this._filterItemMarkup = base;
	  },

	  _buildPresetItemMarkup: function () {
	    let base = this.doc.createElementNS(XHTML_NS, "div");
	    base.classList.add("preset");

	    let name = this.doc.createElementNS(XHTML_NS, "label");
	    base.appendChild(name);

	    let value = this.doc.createElementNS(XHTML_NS, "span");
	    base.appendChild(value);

	    let removeButton = this.doc.createElementNS(XHTML_NS, "button");
	    removeButton.classList.add("remove-button");

	    base.appendChild(removeButton);

	    this._presetItemMarkup = base;
	  },

	  _addEventListeners: function () {
	    this.addButton = this.el.querySelector("#add-filter");
	    this.addButton.addEventListener("click", this._addButtonClick);
	    this.filtersList.addEventListener("click", this._removeButtonClick);
	    this.filtersList.addEventListener("mousedown", this._mouseDown);
	    this.filtersList.addEventListener("keydown", this._keyDown);
	    this.el.addEventListener("mousedown", this._resetFocus);

	    this.presetsList.addEventListener("click", this._presetClick);
	    this.togglePresets.addEventListener("click", this._togglePresets);
	    this.addPresetButton.addEventListener("click", this._savePreset);

	    // These events are event delegators for
	    // drag-drop re-ordering and label-dragging
	    this.win.addEventListener("mousemove", this._mouseMove);
	    this.win.addEventListener("mouseup", this._mouseUp);

	    // Used to workaround float-precision problems
	    this.filtersList.addEventListener("input", this._input);
	  },

	  _removeEventListeners: function () {
	    this.addButton.removeEventListener("click", this._addButtonClick);
	    this.filtersList.removeEventListener("click", this._removeButtonClick);
	    this.filtersList.removeEventListener("mousedown", this._mouseDown);
	    this.filtersList.removeEventListener("keydown", this._keyDown);
	    this.el.removeEventListener("mousedown", this._resetFocus);

	    this.presetsList.removeEventListener("click", this._presetClick);
	    this.togglePresets.removeEventListener("click", this._togglePresets);
	    this.addPresetButton.removeEventListener("click", this._savePreset);

	    // These events are used for drag drop re-ordering
	    this.win.removeEventListener("mousemove", this._mouseMove);
	    this.win.removeEventListener("mouseup", this._mouseUp);

	    // Used to workaround float-precision problems
	    this.filtersList.removeEventListener("input", this._input);
	  },

	  _getFilterElementIndex: function (el) {
	    return [...this.filtersList.children].indexOf(el);
	  },

	  _keyDown: function (e) {
	    if (e.target.tagName.toLowerCase() !== "input" ||
	       (e.keyCode !== 40 && e.keyCode !== 38)) {
	      return;
	    }
	    let input = e.target;

	    const direction = e.keyCode === 40 ? -1 : 1;

	    let multiplier = DEFAULT_VALUE_MULTIPLIER;
	    if (e.altKey) {
	      multiplier = SLOW_VALUE_MULTIPLIER;
	    } else if (e.shiftKey) {
	      multiplier = FAST_VALUE_MULTIPLIER;
	    }

	    const filterEl = e.target.closest(".filter");
	    const index = this._getFilterElementIndex(filterEl);
	    const filter = this.filters[index];

	    // Filters that have units are number-type filters. For them,
	    // the value can be incremented/decremented simply.
	    // For other types of filters (e.g. drop-shadow) we need to check
	    // if the keypress happened close to a number first.
	    if (filter.unit) {
	      let startValue = parseFloat(e.target.value);
	      let value = startValue + direction * multiplier;

	      const [min, max] = this._definition(filter.name).range;
	      if (value < min) {
	        value = min;
	      } else if (value > max) {
	        value = max;
	      }

	      input.value = fixFloat(value);

	      this.updateValueAt(index, value);
	    } else {
	      let selectionStart = input.selectionStart;
	      let num = getNeighbourNumber(input.value, selectionStart);
	      if (!num) {
	        return;
	      }

	      let {start, end, value} = num;

	      let split = input.value.split("");
	      let computed = fixFloat(value + direction * multiplier);
	      let dotIndex = computed.indexOf(".0");
	      if (dotIndex > -1) {
	        computed = computed.slice(0, -2);

	        selectionStart = selectionStart > start + dotIndex ?
	                                          start + dotIndex :
	                                          selectionStart;
	      }
	      split.splice(start, end - start, computed);

	      value = split.join("");
	      input.value = value;
	      this.updateValueAt(index, value);
	      input.setSelectionRange(selectionStart, selectionStart);
	    }
	    e.preventDefault();
	  },

	  _input: function (e) {
	    let filterEl = e.target.closest(".filter");
	    let index = this._getFilterElementIndex(filterEl);
	    let filter = this.filters[index];
	    let def = this._definition(filter.name);

	    if (def.type !== "string") {
	      e.target.value = fixFloat(e.target.value);
	    }
	    this.updateValueAt(index, e.target.value);
	  },

	  _mouseDown: function (e) {
	    let filterEl = e.target.closest(".filter");

	    // re-ordering drag handle
	    if (e.target.tagName.toLowerCase() === "i") {
	      this.isReorderingFilter = true;
	      filterEl.startingY = e.pageY;
	      filterEl.classList.add("dragging");

	      this.el.classList.add("dragging");
	    // label-dragging
	    } else if (e.target.classList.contains("devtools-draglabel")) {
	      let label = e.target;
	      let input = filterEl.querySelector("input");
	      let index = this._getFilterElementIndex(filterEl);

	      this._dragging = {
	        index, label, input,
	        startX: e.pageX
	      };

	      this.isDraggingLabel = true;
	    }
	  },

	  _addButtonClick: function () {
	    const select = this.filterSelect;
	    if (!select.value) {
	      return;
	    }

	    const key = select.value;
	    this.add(key, null);

	    this.render();
	  },

	  _removeButtonClick: function (e) {
	    const isRemoveButton = e.target.classList.contains("remove-button");
	    if (!isRemoveButton) {
	      return;
	    }

	    let filterEl = e.target.closest(".filter");
	    let index = this._getFilterElementIndex(filterEl);
	    this.removeAt(index);
	  },

	  _mouseMove: function (e) {
	    if (this.isReorderingFilter) {
	      this._dragFilterElement(e);
	    } else if (this.isDraggingLabel) {
	      this._dragLabel(e);
	    }
	  },

	  _dragFilterElement: function (e) {
	    const rect = this.filtersList.getBoundingClientRect();
	    let top = e.pageY - LIST_PADDING;
	    let bottom = e.pageY + LIST_PADDING;
	    // don't allow dragging over top/bottom of list
	    if (top < rect.top || bottom > rect.bottom) {
	      return;
	    }

	    const filterEl = this.filtersList.querySelector(".dragging");

	    const delta = e.pageY - filterEl.startingY;
	    filterEl.style.top = delta + "px";

	    // change is the number of _steps_ taken from initial position
	    // i.e. how many elements we have passed
	    let change = delta / LIST_ITEM_HEIGHT;
	    if (change > 0) {
	      change = Math.floor(change);
	    } else if (change < 0) {
	      change = Math.ceil(change);
	    }

	    const children = this.filtersList.children;
	    const index = [...children].indexOf(filterEl);
	    const destination = index + change;

	    // If we're moving out, or there's no change at all, stop and return
	    if (destination >= children.length || destination < 0 || change === 0) {
	      return;
	    }

	    // Re-order filter objects
	    swapArrayIndices(this.filters, index, destination);

	    // Re-order the dragging element in markup
	    const target = change > 0 ? children[destination + 1]
	                              : children[destination];
	    if (target) {
	      this.filtersList.insertBefore(filterEl, target);
	    } else {
	      this.filtersList.appendChild(filterEl);
	    }

	    filterEl.removeAttribute("style");

	    const currentPosition = change * LIST_ITEM_HEIGHT;
	    filterEl.startingY = e.pageY + currentPosition - delta;
	  },

	  _dragLabel: function (e) {
	    let dragging = this._dragging;

	    let input = dragging.input;

	    let multiplier = DEFAULT_VALUE_MULTIPLIER;

	    if (e.altKey) {
	      multiplier = SLOW_VALUE_MULTIPLIER;
	    } else if (e.shiftKey) {
	      multiplier = FAST_VALUE_MULTIPLIER;
	    }

	    dragging.lastX = e.pageX;
	    const delta = e.pageX - dragging.startX;
	    const startValue = parseFloat(input.value);
	    let value = startValue + delta * multiplier;

	    const filter = this.filters[dragging.index];
	    const [min, max] = this._definition(filter.name).range;
	    if (value < min) {
	      value = min;
	    } else if (value > max) {
	      value = max;
	    }

	    input.value = fixFloat(value);

	    dragging.startX = e.pageX;

	    this.updateValueAt(dragging.index, value);
	  },

	  _mouseUp: function () {
	    // Label-dragging is disabled on mouseup
	    this._dragging = null;
	    this.isDraggingLabel = false;

	    // Filter drag/drop needs more cleaning
	    if (!this.isReorderingFilter) {
	      return;
	    }
	    let filterEl = this.filtersList.querySelector(".dragging");

	    this.isReorderingFilter = false;
	    filterEl.classList.remove("dragging");
	    this.el.classList.remove("dragging");
	    filterEl.removeAttribute("style");

	    this.emit("updated", this.getCssValue());
	    this.render();
	  },

	  _presetClick: function (e) {
	    let el = e.target;
	    let preset = el.closest(".preset");
	    if (!preset) {
	      return;
	    }

	    let id = +preset.dataset.id;

	    this.getPresets().then(presets => {
	      if (el.classList.contains("remove-button")) {
	        // If the click happened on the remove button.
	        presets.splice(id, 1);
	        this.setPresets(presets).then(this.renderPresets,
	                                      ex => console.error(ex));
	      } else {
	        // Or if the click happened on a preset.
	        let p = presets[id];

	        this.setCssValue(p.value);
	        this.addPresetInput.value = p.name;
	      }
	    }, ex => console.error(ex));
	  },

	  _togglePresets: function () {
	    this.el.classList.toggle("show-presets");
	    this.emit("render");
	  },

	  _savePreset: function (e) {
	    e.preventDefault();

	    let name = this.addPresetInput.value;
	    let value = this.getCssValue();

	    if (!name || !value || SPECIAL_VALUES.has(value)) {
	      this.emit("preset-save-error");
	      return;
	    }

	    this.getPresets().then(presets => {
	      let index = presets.findIndex(preset => preset.name === name);

	      if (index > -1) {
	        presets[index].value = value;
	      } else {
	        presets.push({name, value});
	      }

	      this.setPresets(presets).then(this.renderPresets,
	                                    ex => console.error(ex));
	    }, ex => console.error(ex));
	  },

	  /**
	   * Workaround needed to reset the focus when using a HTML select inside a XUL panel.
	   * See Bug 1294366.
	   */
	  _resetFocus: function () {
	    this.filterSelect.ownerDocument.defaultView.focus();
	  },

	  /**
	   * Clears the list and renders filters, binding required events.
	   * There are some delegated events bound in _addEventListeners method
	   */
	  render: function () {
	    if (!this.filters.length) {
	      this.filtersList.innerHTML = `<p> ${L10N.getStr("emptyFilterList")} <br />
	                                 ${L10N.getStr("addUsingList")} </p>`;
	      this.emit("render");
	      return;
	    }

	    this.filtersList.innerHTML = "";

	    let base = this._filterItemMarkup;

	    for (let filter of this.filters) {
	      const def = this._definition(filter.name);

	      let el = base.cloneNode(true);

	      let [name, value] = el.children;
	      let label = name.children[1];
	      let [input, unitPreview] = value.children;

	      let min, max;
	      if (def.range) {
	        [min, max] = def.range;
	      }

	      label.textContent = filter.name;
	      input.value = filter.value;

	      switch (def.type) {
	        case "percentage":
	        case "angle":
	        case "length":
	          input.type = "number";
	          input.min = min;
	          if (max !== Infinity) {
	            input.max = max;
	          }
	          input.step = "0.1";
	          break;
	        case "string":
	          input.type = "text";
	          input.placeholder = def.placeholder;
	          break;
	      }

	      // use photoshop-style label-dragging
	      // and show filters' unit next to their <input>
	      if (def.type !== "string") {
	        unitPreview.textContent = filter.unit;

	        label.classList.add("devtools-draglabel");
	        label.title = L10N.getStr("labelDragTooltipText");
	      } else {
	        // string-type filters have no unit
	        unitPreview.remove();
	      }

	      this.filtersList.appendChild(el);
	    }

	    let lastInput =
	        this.filtersList.querySelector(".filter:last-of-type input");
	    if (lastInput) {
	      lastInput.focus();
	      if (lastInput.type === "text") {
	        // move cursor to end of input
	        const end = lastInput.value.length;
	        lastInput.setSelectionRange(end, end);
	      }
	    }

	    this.emit("render");
	  },

	  renderPresets: function () {
	    this.getPresets().then(presets => {
	      // getPresets is async and the widget may be destroyed in between.
	      if (!this.presetsList) {
	        return;
	      }

	      if (!presets || !presets.length) {
	        this.presetsList.innerHTML = `<p>${L10N.getStr("emptyPresetList")}</p>`;
	        this.emit("render");
	        return;
	      }
	      let base = this._presetItemMarkup;

	      this.presetsList.innerHTML = "";

	      for (let [index, preset] of presets.entries()) {
	        let el = base.cloneNode(true);

	        let [label, span] = el.children;

	        el.dataset.id = index;

	        label.textContent = preset.name;
	        span.textContent = preset.value;

	        this.presetsList.appendChild(el);
	      }

	      this.emit("render");
	    });
	  },

	  /**
	    * returns definition of a filter as defined in filterList
	    *
	    * @param {String} name
	    *        filter name (e.g. blur)
	    * @return {Object}
	    *        filter's definition
	    */
	  _definition: function (name) {
	    name = name.toLowerCase();
	    return filterList.find(a => a.name === name);
	  },

	  /**
	    * Parses the CSS value specified, updating widget's filters
	    *
	    * @param {String} cssValue
	    *        css value to be parsed
	    */
	  setCssValue: function (cssValue) {
	    if (!cssValue) {
	      throw new Error("Missing CSS filter value in setCssValue");
	    }

	    this.filters = [];

	    if (SPECIAL_VALUES.has(cssValue)) {
	      this._specialValue = cssValue;
	      this.emit("updated", this.getCssValue());
	      this.render();
	      return;
	    }

	    for (let {name, value, quote} of tokenizeFilterValue(cssValue)) {
	      // If the specified value is invalid, replace it with the
	      // default.
	      if (name !== "url") {
	        if (!DOMUtils.cssPropertyIsValid("filter", name + "(" + value + ")")) {
	          value = null;
	        }
	      }

	      this.add(name, value, quote, true);
	    }

	    this.emit("updated", this.getCssValue());
	    this.render();
	  },

	  /**
	    * Creates a new [name] filter record with value
	    *
	    * @param {String} name
	    *        filter name (e.g. blur)
	    * @param {String} value
	    *        value of the filter (e.g. 30px, 20%)
	    *        If this is |null|, then a default value may be supplied.
	    * @param {String} quote
	    *        For a url filter, the quoting style.  This can be a
	    *        single quote, a double quote, or empty.
	    * @return {Number}
	    *        The index of the new filter in the current list of filters
	    * @param {Boolean}
	    *        By default, adding a new filter emits an "updated" event, but if
	    *        you're calling add in a loop and wait to emit a single event after
	    *        the loop yourself, set this parameter to true.
	    */
	  add: function (name, value, quote, noEvent) {
	    const def = this._definition(name);
	    if (!def) {
	      return false;
	    }

	    if (value === null) {
	      // UNIT_MAPPING[string] is an empty string (falsy), so
	      // using || doesn't work here
	      const unitLabel = typeof UNIT_MAPPING[def.type] === "undefined" ?
	                               UNIT_MAPPING[DEFAULT_FILTER_TYPE] :
	                               UNIT_MAPPING[def.type];

	      // string-type filters have no default value but a placeholder instead
	      if (!unitLabel) {
	        value = "";
	      } else {
	        value = def.range[0] + unitLabel;
	      }

	      if (name === "url") {
	        // Default quote.
	        quote = "\"";
	      }
	    }

	    let unit = def.type === "string"
	               ? ""
	               : (/[a-zA-Z%]+/.exec(value) || [])[0];

	    if (def.type !== "string") {
	      value = parseFloat(value);

	      // You can omit percentage values' and use a value between 0..1
	      if (def.type === "percentage" && !unit) {
	        value = value * 100;
	        unit = "%";
	      }

	      const [min, max] = def.range;
	      if (value < min) {
	        value = min;
	      } else if (value > max) {
	        value = max;
	      }
	    }

	    const index = this.filters.push({value, unit, name, quote}) - 1;
	    if (!noEvent) {
	      this.emit("updated", this.getCssValue());
	    }

	    return index;
	  },

	  /**
	    * returns value + unit of the specified filter
	    *
	    * @param {Number} index
	    *        filter index
	    * @return {String}
	    *        css value of filter
	    */
	  getValueAt: function (index) {
	    let filter = this.filters[index];
	    if (!filter) {
	      return null;
	    }

	    // Just return the value+unit for non-url functions.
	    if (filter.name !== "url") {
	      return filter.value + filter.unit;
	    }

	    // url values need to be quoted and escaped.
	    if (filter.quote === "'") {
	      return "'" + filter.value.replace(/\'/g, "\\'") + "'";
	    } else if (filter.quote === "\"") {
	      return "\"" + filter.value.replace(/\"/g, "\\\"") + "\"";
	    }

	    // Unquoted.  This approach might change the original input -- for
	    // example the original might be over-quoted.  But, this is
	    // correct and probably good enough.
	    return filter.value.replace(/[\\ \t()"']/g, "\\$&");
	  },

	  removeAt: function (index) {
	    if (!this.filters[index]) {
	      return;
	    }

	    this.filters.splice(index, 1);
	    this.emit("updated", this.getCssValue());
	    this.render();
	  },

	  /**
	    * Generates CSS filter value for filters of the widget
	    *
	    * @return {String}
	    *        css value of filters
	    */
	  getCssValue: function () {
	    return this.filters.map((filter, i) => {
	      return `${filter.name}(${this.getValueAt(i)})`;
	    }).join(" ") || this._specialValue || "none";
	  },

	  /**
	    * Updates specified filter's value
	    *
	    * @param {Number} index
	    *        The index of the filter in the current list of filters
	    * @param {number/string} value
	    *        value to set, string for string-typed filters
	    *        number for the rest (unit automatically determined)
	    */
	  updateValueAt: function (index, value) {
	    let filter = this.filters[index];
	    if (!filter) {
	      return;
	    }

	    const def = this._definition(filter.name);

	    if (def.type !== "string") {
	      const [min, max] = def.range;
	      if (value < min) {
	        value = min;
	      } else if (value > max) {
	        value = max;
	      }
	    }

	    filter.value = filter.unit ? fixFloat(value, true) : value;

	    this.emit("updated", this.getCssValue());
	  },

	  getPresets: function () {
	    return asyncStorage.getItem("cssFilterPresets").then(presets => {
	      if (!presets) {
	        return [];
	      }

	      return presets;
	    }, e => console.error(e));
	  },

	  setPresets: function (presets) {
	    return asyncStorage.setItem("cssFilterPresets", presets)
	      .catch(e => console.error(e));
	  }
	};

	// Fixes JavaScript's float precision
	function fixFloat(a, number) {
	  let fixed = parseFloat(a).toFixed(1);
	  return number ? parseFloat(fixed) : fixed;
	}

	/**
	 * Used to swap two filters' indexes
	 * after drag/drop re-ordering
	 *
	 * @param {Array} array
	 *        the array to swap elements of
	 * @param {Number} a
	 *        index of first element
	 * @param {Number} b
	 *        index of second element
	 */
	function swapArrayIndices(array, a, b) {
	  array[a] = array.splice(b, 1, array[a])[0];
	}

	/**
	 * Tokenizes a CSS Filter value and returns an array of {name, value} pairs.
	 *
	 * @param {String} css CSS Filter value to be parsed
	 * @return {Array} An array of {name, value} pairs
	 */
	function tokenizeFilterValue(css) {
	  let filters = [];
	  let depth = 0;

	  if (SPECIAL_VALUES.has(css)) {
	    return filters;
	  }

	  let state = "initial";
	  let name;
	  let contents;
	  for (let token of cssTokenizer(css)) {
	    switch (state) {
	      case "initial":
	        if (token.tokenType === "function") {
	          name = token.text;
	          contents = "";
	          state = "function";
	          depth = 1;
	        } else if (token.tokenType === "url" || token.tokenType === "bad_url") {
	          // Extract the quoting style from the url.
	          let originalText = css.substring(token.startOffset, token.endOffset);
	          let [, quote] = /^url\([ \t\r\n\f]*(["']?)/i.exec(originalText);

	          filters.push({name: "url", value: token.text.trim(), quote: quote});
	          // Leave state as "initial" because the URL token includes
	          // the trailing close paren.
	        }
	        break;

	      case "function":
	        if (token.tokenType === "symbol" && token.text === ")") {
	          --depth;
	          if (depth === 0) {
	            filters.push({name: name, value: contents.trim()});
	            state = "initial";
	            break;
	          }
	        }
	        contents += css.substring(token.startOffset, token.endOffset);
	        if (token.tokenType === "function" ||
	            (token.tokenType === "symbol" && token.text === "(")) {
	          ++depth;
	        }
	        break;
	    }
	  }

	  return filters;
	}

	/**
	  * Finds neighbour number characters of an index in a string
	  * the numbers may be floats (containing dots)
	  * It's assumed that the value given to this function is a valid number
	  *
	  * @param {String} string
	  *        The string containing numbers
	  * @param {Number} index
	  *        The index to look for neighbours for
	  * @return {Object}
	  *         returns null if no number is found
	  *         value: The number found
	  *         start: The number's starting index
	  *         end: The number's ending index
	  */
	function getNeighbourNumber(string, index) {
	  if (!/\d/.test(string)) {
	    return null;
	  }

	  let left = /-?[0-9.]*$/.exec(string.slice(0, index));
	  let right = /-?[0-9.]*/.exec(string.slice(index));

	  left = left ? left[0] : "";
	  right = right ? right[0] : "";

	  if (!right && !left) {
	    return null;
	  }

	  return {
	    value: fixFloat(left + right, true),
	    start: index - left.length,
	    end: index + right.length
	  };
	}


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *
	 * Adapted from https://github.com/mozilla-b2g/gaia/blob/f09993563fb5fec4393eb71816ce76cb00463190/shared/js/async_storage.js
	 * (converted to use Promises instead of callbacks).
	 *
	 * This file defines an asynchronous version of the localStorage API, backed by
	 * an IndexedDB database.  It creates a global asyncStorage object that has
	 * methods like the localStorage object.
	 *
	 * To store a value use setItem:
	 *
	 *   asyncStorage.setItem("key", "value");
	 *
	 * This returns a promise in case you want confirmation that the value has been stored.
	 *
	 *  asyncStorage.setItem("key", "newvalue").then(function() {
	 *    console.log("new value stored");
	 *  });
	 *
	 * To read a value, call getItem(), but note that you must wait for a promise
	 * resolution for the value to be retrieved.
	 *
	 *  asyncStorage.getItem("key").then(function(value) {
	 *    console.log("The value of key is:", value);
	 *  });
	 *
	 * Note that unlike localStorage, asyncStorage does not allow you to store and
	 * retrieve values by setting and querying properties directly. You cannot just
	 * write asyncStorage.key; you have to explicitly call setItem() or getItem().
	 *
	 * removeItem(), clear(), length(), and key() are like the same-named methods of
	 * localStorage, and all return a promise.
	 *
	 * The asynchronous nature of getItem() makes it tricky to retrieve multiple
	 * values. But unlike localStorage, asyncStorage does not require the values you
	 * store to be strings.  So if you need to save multiple values and want to
	 * retrieve them together, in a single asynchronous operation, just group the
	 * values into a single object. The properties of this object may not include
	 * DOM elements, but they may include things like Blobs and typed arrays.
	 *
	 */

	"use strict";

	const Promise = __webpack_require__(4);

	const DBNAME = "devtools-async-storage";
	const DBVERSION = 1;
	const STORENAME = "keyvaluepairs";
	var db = null;

	function withStore(type, onsuccess, onerror) {
	  if (db) {
	    let transaction = db.transaction(STORENAME, type);
	    let store = transaction.objectStore(STORENAME);
	    onsuccess(store);
	  } else {
	    let openreq = indexedDB.open(DBNAME, DBVERSION);
	    openreq.onerror = function withStoreOnError() {
	      onerror();
	    };
	    openreq.onupgradeneeded = function withStoreOnUpgradeNeeded() {
	      // First time setup: create an empty object store
	      openreq.result.createObjectStore(STORENAME);
	    };
	    openreq.onsuccess = function withStoreOnSuccess() {
	      db = openreq.result;
	      let transaction = db.transaction(STORENAME, type);
	      let store = transaction.objectStore(STORENAME);
	      onsuccess(store);
	    };
	  }
	}

	function getItem(itemKey) {
	  return new Promise((resolve, reject) => {
	    let req;
	    withStore("readonly", (store) => {
	      store.transaction.oncomplete = function onComplete() {
	        let value = req.result;
	        if (value === undefined) {
	          value = null;
	        }
	        resolve(value);
	      };
	      req = store.get(itemKey);
	      req.onerror = function getItemOnError() {
	        reject("Error in asyncStorage.getItem(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function setItem(itemKey, value) {
	  return new Promise((resolve, reject) => {
	    withStore("readwrite", (store) => {
	      store.transaction.oncomplete = resolve;
	      let req = store.put(value, itemKey);
	      req.onerror = function setItemOnError() {
	        reject("Error in asyncStorage.setItem(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function removeItem(itemKey) {
	  return new Promise((resolve, reject) => {
	    withStore("readwrite", (store) => {
	      store.transaction.oncomplete = resolve;
	      let req = store.delete(itemKey);
	      req.onerror = function removeItemOnError() {
	        reject("Error in asyncStorage.removeItem(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function clear() {
	  return new Promise((resolve, reject) => {
	    withStore("readwrite", (store) => {
	      store.transaction.oncomplete = resolve;
	      let req = store.clear();
	      req.onerror = function clearOnError() {
	        reject("Error in asyncStorage.clear(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function length() {
	  return new Promise((resolve, reject) => {
	    let req;
	    withStore("readonly", (store) => {
	      store.transaction.oncomplete = function onComplete() {
	        resolve(req.result);
	      };
	      req = store.count();
	      req.onerror = function lengthOnError() {
	        reject("Error in asyncStorage.length(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	function key(n) {
	  return new Promise((resolve, reject) => {
	    if (n < 0) {
	      resolve(null);
	      return;
	    }

	    let req;
	    withStore("readonly", (store) => {
	      store.transaction.oncomplete = function onComplete() {
	        let cursor = req.result;
	        resolve(cursor ? cursor.key : null);
	      };
	      let advanced = false;
	      req = store.openCursor();
	      req.onsuccess = function keyOnSuccess() {
	        let cursor = req.result;
	        if (!cursor) {
	          // this means there weren"t enough keys
	          return;
	        }
	        if (n === 0 || advanced) {
	          // Either 1) we have the first key, return it if that's what they
	          // wanted, or 2) we"ve got the nth key.
	          return;
	        }

	        // Otherwise, ask the cursor to skip ahead n records
	        advanced = true;
	        cursor.advance(n);
	      };
	      req.onerror = function keyOnError() {
	        reject("Error in asyncStorage.key(): ", req.error.name);
	      };
	    }, reject);
	  });
	}

	exports.getItem = getItem;
	exports.setItem = setItem;
	exports.removeItem = removeItem;
	exports.clear = clear;
	exports.length = length;
	exports.key = key;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* globals gDevTools */

	"use strict";

	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);
	const Services = __webpack_require__(1);
	const {Task} = __webpack_require__(15);
	const {Tools} = __webpack_require__(36);
	const {l10n} = __webpack_require__(173);
	const {ELEMENT_STYLE} = __webpack_require__(175);
	const {OutputParser} = __webpack_require__(177);
	const {PrefObserver, PREF_ORIG_SOURCES} = __webpack_require__(180);
	const {ElementStyle} = __webpack_require__(199);
	const {Rule} = __webpack_require__(200);
	const {RuleEditor} = __webpack_require__(202);
	const {createChild, promiseWarn, throttle} = __webpack_require__(181);
	const {gDevTools} = __webpack_require__(38);
	const {getCssProperties} = __webpack_require__(16);

	const overlays = __webpack_require__(183);
	const EventEmitter = __webpack_require__(6);
	const StyleInspectorMenu = __webpack_require__(206);
	const {KeyShortcuts} = __webpack_require__(13);
	const clipboardHelper = __webpack_require__(207);

	const {AutocompletePopup} = __webpack_require__(208);

	const HTML_NS = "http://www.w3.org/1999/xhtml";
	const PREF_UA_STYLES = "devtools.inspector.showUserAgentStyles";
	const PREF_DEFAULT_COLOR_UNIT = "devtools.defaultColorUnit";
	const PREF_ENABLE_MDN_DOCS_TOOLTIP =
	      "devtools.inspector.mdnDocsTooltip.enabled";
	const FILTER_CHANGED_TIMEOUT = 150;

	// This is used to parse user input when filtering.
	const FILTER_PROP_RE = /\s*([^:\s]*)\s*:\s*(.*?)\s*;?$/;
	// This is used to parse the filter search value to see if the filter
	// should be strict or not
	const FILTER_STRICT_RE = /\s*`(.*?)`\s*$/;

	/**
	 * Our model looks like this:
	 *
	 * ElementStyle:
	 *   Responsible for keeping track of which properties are overridden.
	 *   Maintains a list of Rule objects that apply to the element.
	 * Rule:
	 *   Manages a single style declaration or rule.
	 *   Responsible for applying changes to the properties in a rule.
	 *   Maintains a list of TextProperty objects.
	 * TextProperty:
	 *   Manages a single property from the authoredText attribute of the
	 *     relevant declaration.
	 *   Maintains a list of computed properties that come from this
	 *     property declaration.
	 *   Changes to the TextProperty are sent to its related Rule for
	 *     application.
	 *
	 * View hierarchy mostly follows the model hierarchy.
	 *
	 * CssRuleView:
	 *   Owns an ElementStyle and creates a list of RuleEditors for its
	 *    Rules.
	 * RuleEditor:
	 *   Owns a Rule object and creates a list of TextPropertyEditors
	 *     for its TextProperties.
	 *   Manages creation of new text properties.
	 * TextPropertyEditor:
	 *   Owns a TextProperty object.
	 *   Manages changes to the TextProperty.
	 *   Can be expanded to display computed properties.
	 *   Can mark a property disabled or enabled.
	 */

	/**
	 * To figure out how shorthand properties are interpreted by the
	 * engine, we will set properties on a dummy element and observe
	 * how their .style attribute reflects them as computed values.
	 * This function creates the document in which those dummy elements
	 * will be created.
	 */
	var gDummyPromise;
	function createDummyDocument() {
	  if (gDummyPromise) {
	    return gDummyPromise;
	  }
	  const { getDocShell, create: makeFrame } = __webpack_require__(209);

	  let frame = makeFrame(Services.appShell.hiddenDOMWindow.document, {
	    nodeName: "iframe",
	    namespaceURI: "http://www.w3.org/1999/xhtml",
	    allowJavascript: false,
	    allowPlugins: false,
	    allowAuth: false
	  });
	  let docShell = getDocShell(frame);
	  let eventTarget = docShell.chromeEventHandler;
	  let ssm = Services.scriptSecurityManager;

	  // We probably need to call InheritFromDocShellToDoc to get the correct origin
	  // attributes, but right now we can't call it from JS.
	  let nullPrincipal = ssm.createNullPrincipal(docShell.getOriginAttributes());
	  docShell.createAboutBlankContentViewer(nullPrincipal);
	  let window = docShell.contentViewer.DOMDocument.defaultView;
	  window.location = "data:text/html,<html></html>";
	  let deferred = defer();
	  eventTarget.addEventListener("DOMContentLoaded", function handler() {
	    eventTarget.removeEventListener("DOMContentLoaded", handler, false);
	    deferred.resolve(window.document);
	    frame.remove();
	  }, false);
	  gDummyPromise = deferred.promise;
	  return gDummyPromise;
	}

	/**
	 * CssRuleView is a view of the style rules and declarations that
	 * apply to a given element.  After construction, the 'element'
	 * property will be available with the user interface.
	 *
	 * @param {Inspector} inspector
	 *        Inspector toolbox panel
	 * @param {Document} document
	 *        The document that will contain the rule view.
	 * @param {Object} store
	 *        The CSS rule view can use this object to store metadata
	 *        that might outlast the rule view, particularly the current
	 *        set of disabled properties.
	 * @param {PageStyleFront} pageStyle
	 *        The PageStyleFront for communicating with the remote server.
	 */
	function CssRuleView(inspector, document, store, pageStyle) {
	  this.inspector = inspector;
	  this.styleDocument = document;
	  this.styleWindow = this.styleDocument.defaultView;
	  this.store = store || {};
	  this.pageStyle = pageStyle;

	  // Allow tests to override throttling behavior, as this can cause intermittents.
	  this.throttle = throttle;

	  this.cssProperties = getCssProperties(inspector.toolbox);

	  this._outputParser = new OutputParser(document, this.cssProperties.supportsType);

	  this._onAddRule = this._onAddRule.bind(this);
	  this._onContextMenu = this._onContextMenu.bind(this);
	  this._onCopy = this._onCopy.bind(this);
	  this._onFilterStyles = this._onFilterStyles.bind(this);
	  this._onClearSearch = this._onClearSearch.bind(this);
	  this._onFilterTextboxContextMenu =
	    this._onFilterTextboxContextMenu.bind(this);
	  this._onTogglePseudoClassPanel = this._onTogglePseudoClassPanel.bind(this);
	  this._onTogglePseudoClass = this._onTogglePseudoClass.bind(this);

	  let doc = this.styleDocument;
	  this.element = doc.getElementById("ruleview-container-focusable");
	  this.addRuleButton = doc.getElementById("ruleview-add-rule-button");
	  this.searchField = doc.getElementById("ruleview-searchbox");
	  this.searchClearButton = doc.getElementById("ruleview-searchinput-clear");
	  this.pseudoClassPanel = doc.getElementById("pseudo-class-panel");
	  this.pseudoClassToggle = doc.getElementById("pseudo-class-panel-toggle");
	  this.hoverCheckbox = doc.getElementById("pseudo-hover-toggle");
	  this.activeCheckbox = doc.getElementById("pseudo-active-toggle");
	  this.focusCheckbox = doc.getElementById("pseudo-focus-toggle");

	  this.searchClearButton.hidden = true;

	  this.shortcuts = new KeyShortcuts({ window: this.styleWindow });
	  this._onShortcut = this._onShortcut.bind(this);
	  this.shortcuts.on("Escape", this._onShortcut);
	  this.shortcuts.on("Return", this._onShortcut);
	  this.shortcuts.on("Space", this._onShortcut);
	  this.shortcuts.on("CmdOrCtrl+F", this._onShortcut);
	  this.element.addEventListener("copy", this._onCopy);
	  this.element.addEventListener("contextmenu", this._onContextMenu);
	  this.addRuleButton.addEventListener("click", this._onAddRule);
	  this.searchField.addEventListener("input", this._onFilterStyles);
	  this.searchField.addEventListener("contextmenu",
	                                    this._onFilterTextboxContextMenu);
	  this.searchClearButton.addEventListener("click", this._onClearSearch);
	  this.pseudoClassToggle.addEventListener("click",
	                                          this._onTogglePseudoClassPanel);
	  this.hoverCheckbox.addEventListener("click", this._onTogglePseudoClass);
	  this.activeCheckbox.addEventListener("click", this._onTogglePseudoClass);
	  this.focusCheckbox.addEventListener("click", this._onTogglePseudoClass);

	  this._handlePrefChange = this._handlePrefChange.bind(this);
	  this._onSourcePrefChanged = this._onSourcePrefChanged.bind(this);

	  this._prefObserver = new PrefObserver("devtools.");
	  this._prefObserver.on(PREF_ORIG_SOURCES, this._onSourcePrefChanged);
	  this._prefObserver.on(PREF_UA_STYLES, this._handlePrefChange);
	  this._prefObserver.on(PREF_DEFAULT_COLOR_UNIT, this._handlePrefChange);
	  this._prefObserver.on(PREF_ENABLE_MDN_DOCS_TOOLTIP, this._handlePrefChange);

	  this.showUserAgentStyles = Services.prefs.getBoolPref(PREF_UA_STYLES);
	  this.enableMdnDocsTooltip =
	    Services.prefs.getBoolPref(PREF_ENABLE_MDN_DOCS_TOOLTIP);

	  let options = {
	    autoSelect: true,
	    theme: "auto"
	  };
	  this.popup = new AutocompletePopup(inspector._toolbox, options);

	  this._showEmpty();

	  this._contextmenu = new StyleInspectorMenu(this, { isRuleView: true });

	  // Add the tooltips and highlighters to the view
	  this.tooltips = new overlays.TooltipsOverlay(this);
	  this.tooltips.addToView();
	  this.highlighters = new overlays.HighlightersOverlay(this);
	  this.highlighters.addToView();

	  EventEmitter.decorate(this);
	}

	CssRuleView.prototype = {
	  // The element that we're inspecting.
	  _viewedElement: null,

	  // Used for cancelling timeouts in the style filter.
	  _filterChangedTimeout: null,

	  // Empty, unconnected element of the same type as this node, used
	  // to figure out how shorthand properties will be parsed.
	  _dummyElement: null,

	  // Get the dummy elemenet.
	  get dummyElement() {
	    return this._dummyElement;
	  },

	  // Get the filter search value.
	  get searchValue() {
	    return this.searchField.value.toLowerCase();
	  },

	  /**
	   * Get an instance of SelectorHighlighter (used to highlight nodes that match
	   * selectors in the rule-view). A new instance is only created the first time
	   * this function is called. The same instance will then be returned.
	   *
	   * @return {Promise} Resolves to the instance of the highlighter.
	   */
	  getSelectorHighlighter: Task.async(function* () {
	    let utils = this.inspector.toolbox.highlighterUtils;
	    if (!utils.supportsCustomHighlighters()) {
	      return null;
	    }

	    if (this.selectorHighlighter) {
	      return this.selectorHighlighter;
	    }

	    try {
	      let h = yield utils.getHighlighterByType("SelectorHighlighter");
	      this.selectorHighlighter = h;
	      return h;
	    } catch (e) {
	      // The SelectorHighlighter type could not be created in the
	      // current target.  It could be an older server, or a XUL page.
	      return null;
	    }
	  }),

	  /**
	   * Highlight/unhighlight all the nodes that match a given set of selectors
	   * inside the document of the current selected node.
	   * Only one selector can be highlighted at a time, so calling the method a
	   * second time with a different selector will first unhighlight the previously
	   * highlighted nodes.
	   * Calling the method a second time with the same selector will just
	   * unhighlight the highlighted nodes.
	   *
	   * @param {DOMNode} selectorIcon
	   *        The icon that was clicked to toggle the selector. The
	   *        class 'highlighted' will be added when the selector is
	   *        highlighted.
	   * @param {String} selector
	   *        The selector used to find nodes in the page.
	   */
	  toggleSelectorHighlighter: function (selectorIcon, selector) {
	    if (this.lastSelectorIcon) {
	      this.lastSelectorIcon.classList.remove("highlighted");
	    }
	    selectorIcon.classList.remove("highlighted");

	    this.unhighlightSelector().then(() => {
	      if (selector !== this.highlightedSelector) {
	        this.highlightedSelector = selector;
	        selectorIcon.classList.add("highlighted");
	        this.lastSelectorIcon = selectorIcon;
	        this.highlightSelector(selector).then(() => {
	          this.emit("ruleview-selectorhighlighter-toggled", true);
	        }, e => console.error(e));
	      } else {
	        this.highlightedSelector = null;
	        this.emit("ruleview-selectorhighlighter-toggled", false);
	      }
	    }, e => console.error(e));
	  },

	  highlightSelector: Task.async(function* (selector) {
	    let node = this.inspector.selection.nodeFront;

	    let highlighter = yield this.getSelectorHighlighter();
	    if (!highlighter) {
	      return;
	    }

	    yield highlighter.show(node, {
	      hideInfoBar: true,
	      hideGuides: true,
	      selector
	    });
	  }),

	  unhighlightSelector: Task.async(function* () {
	    let highlighter = yield this.getSelectorHighlighter();
	    if (!highlighter) {
	      return;
	    }

	    yield highlighter.hide();
	  }),

	  /**
	   * Get the type of a given node in the rule-view
	   *
	   * @param {DOMNode} node
	   *        The node which we want information about
	   * @return {Object} The type information object contains the following props:
	   * - type {String} One of the VIEW_NODE_XXX_TYPE const in
	   *   style-inspector-overlays
	   * - value {Object} Depends on the type of the node
	   * returns null of the node isn't anything we care about
	   */
	  getNodeInfo: function (node) {
	    if (!node) {
	      return null;
	    }

	    let type, value;
	    let classes = node.classList;
	    let prop = getParentTextProperty(node);

	    if (classes.contains("ruleview-propertyname") && prop) {
	      type = overlays.VIEW_NODE_PROPERTY_TYPE;
	      value = {
	        property: node.textContent,
	        value: getPropertyNameAndValue(node).value,
	        enabled: prop.enabled,
	        overridden: prop.overridden,
	        pseudoElement: prop.rule.pseudoElement,
	        sheetHref: prop.rule.domRule.href,
	        textProperty: prop
	      };
	    } else if (classes.contains("ruleview-propertyvalue") && prop) {
	      type = overlays.VIEW_NODE_VALUE_TYPE;
	      value = {
	        property: getPropertyNameAndValue(node).name,
	        value: node.textContent,
	        enabled: prop.enabled,
	        overridden: prop.overridden,
	        pseudoElement: prop.rule.pseudoElement,
	        sheetHref: prop.rule.domRule.href,
	        textProperty: prop
	      };
	    } else if (classes.contains("theme-link") &&
	               !classes.contains("ruleview-rule-source") && prop) {
	      type = overlays.VIEW_NODE_IMAGE_URL_TYPE;
	      value = {
	        property: getPropertyNameAndValue(node).name,
	        value: node.parentNode.textContent,
	        url: node.href,
	        enabled: prop.enabled,
	        overridden: prop.overridden,
	        pseudoElement: prop.rule.pseudoElement,
	        sheetHref: prop.rule.domRule.href,
	        textProperty: prop
	      };
	    } else if (classes.contains("ruleview-selector-unmatched") ||
	               classes.contains("ruleview-selector-matched") ||
	               classes.contains("ruleview-selectorcontainer") ||
	               classes.contains("ruleview-selector") ||
	               classes.contains("ruleview-selector-attribute") ||
	               classes.contains("ruleview-selector-pseudo-class") ||
	               classes.contains("ruleview-selector-pseudo-class-lock")) {
	      type = overlays.VIEW_NODE_SELECTOR_TYPE;
	      value = this._getRuleEditorForNode(node).selectorText.textContent;
	    } else if (classes.contains("ruleview-rule-source") ||
	               classes.contains("ruleview-rule-source-label")) {
	      type = overlays.VIEW_NODE_LOCATION_TYPE;
	      let rule = this._getRuleEditorForNode(node).rule;
	      value = (rule.sheet && rule.sheet.href) ? rule.sheet.href : rule.title;
	    } else {
	      return null;
	    }

	    return {type, value};
	  },

	  /**
	   * Retrieve the RuleEditor instance that should be stored on
	   * the offset parent of the node
	   */
	  _getRuleEditorForNode: function (node) {
	    if (!node.offsetParent) {
	      // some nodes don't have an offsetParent, but their parentNode does
	      node = node.parentNode;
	    }
	    return node.offsetParent._ruleEditor;
	  },

	  /**
	   * Context menu handler.
	   */
	  _onContextMenu: function (event) {
	    this._contextmenu.show(event);
	  },

	  /**
	   * Callback for copy event. Copy the selected text.
	   *
	   * @param {Event} event
	   *        copy event object.
	   */
	  _onCopy: function (event) {
	    if (event) {
	      this.copySelection(event.target);
	      event.preventDefault();
	    }
	  },

	  /**
	   * Copy the current selection. The current target is necessary
	   * if the selection is inside an input or a textarea
	   *
	   * @param {DOMNode} target
	   *        DOMNode target of the copy action
	   */
	  copySelection: function (target) {
	    try {
	      let text = "";

	      let nodeName = target && target.nodeName;
	      if (nodeName === "input" || nodeName == "textarea") {
	        let start = Math.min(target.selectionStart, target.selectionEnd);
	        let end = Math.max(target.selectionStart, target.selectionEnd);
	        let count = end - start;
	        text = target.value.substr(start, count);
	      } else {
	        text = this.styleWindow.getSelection().toString();

	        // Remove any double newlines.
	        text = text.replace(/(\r?\n)\r?\n/g, "$1");
	      }

	      clipboardHelper.copyString(text);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  /**
	   * A helper for _onAddRule that handles the case where the actor
	   * does not support as-authored styles.
	   */
	  _onAddNewRuleNonAuthored: function () {
	    let elementStyle = this._elementStyle;
	    let element = elementStyle.element;
	    let rules = elementStyle.rules;
	    let pseudoClasses = element.pseudoClassLocks;

	    this.pageStyle.addNewRule(element, pseudoClasses).then(options => {
	      let newRule = new Rule(elementStyle, options);
	      rules.push(newRule);
	      let editor = new RuleEditor(this, newRule);
	      newRule.editor = editor;

	      // Insert the new rule editor after the inline element rule
	      if (rules.length <= 1) {
	        this.element.appendChild(editor.element);
	      } else {
	        for (let rule of rules) {
	          if (rule.domRule.type === ELEMENT_STYLE) {
	            let referenceElement = rule.editor.element.nextSibling;
	            this.element.insertBefore(editor.element, referenceElement);
	            break;
	          }
	        }
	      }

	      // Focus and make the new rule's selector editable
	      editor.selectorText.click();
	      elementStyle._changed();
	    });
	  },

	  /**
	   * Add a new rule to the current element.
	   */
	  _onAddRule: function () {
	    let elementStyle = this._elementStyle;
	    let element = elementStyle.element;
	    let client = this.inspector.toolbox._target.client;
	    let pseudoClasses = element.pseudoClassLocks;

	    if (!client.traits.addNewRule) {
	      return;
	    }

	    if (!this.pageStyle.supportsAuthoredStyles) {
	      // We're talking to an old server.
	      this._onAddNewRuleNonAuthored();
	      return;
	    }

	    // Adding a new rule with authored styles will cause the actor to
	    // emit an event, which will in turn cause the rule view to be
	    // updated.  So, we wait for this update and for the rule creation
	    // request to complete, and then focus the new rule's selector.
	    let eventPromise = this.once("ruleview-refreshed");
	    let newRulePromise = this.pageStyle.addNewRule(element, pseudoClasses);
	    promise.all([eventPromise, newRulePromise]).then((values) => {
	      let options = values[1];
	      // Be sure the reference the correct |rules| here.
	      for (let rule of this._elementStyle.rules) {
	        if (options.rule === rule.domRule) {
	          rule.editor.selectorText.click();
	          elementStyle._changed();
	          break;
	        }
	      }
	    });
	  },

	  /**
	   * Disables add rule button when needed
	   */
	  refreshAddRuleButtonState: function () {
	    let shouldBeDisabled = !this._viewedElement ||
	                           !this.inspector.selection.isElementNode() ||
	                           this.inspector.selection.isAnonymousNode();
	    this.addRuleButton.disabled = shouldBeDisabled;
	  },

	  setPageStyle: function (pageStyle) {
	    this.pageStyle = pageStyle;
	  },

	  /**
	   * Return {Boolean} true if the rule view currently has an input
	   * editor visible.
	   */
	  get isEditing() {
	    return this.tooltips.isEditing ||
	      this.element.querySelectorAll(".styleinspector-propertyeditor")
	        .length > 0;
	  },

	  _handlePrefChange: function (pref) {
	    if (pref === PREF_UA_STYLES) {
	      this.showUserAgentStyles = Services.prefs.getBoolPref(pref);
	    }

	    // Reselect the currently selected element
	    let refreshOnPrefs = [PREF_UA_STYLES, PREF_DEFAULT_COLOR_UNIT];
	    if (refreshOnPrefs.indexOf(pref) > -1) {
	      this.selectElement(this._viewedElement, true);
	    }
	  },

	  /**
	   * Update source links when pref for showing original sources changes
	   */
	  _onSourcePrefChanged: function () {
	    if (this._elementStyle && this._elementStyle.rules) {
	      for (let rule of this._elementStyle.rules) {
	        if (rule.editor) {
	          rule.editor.updateSourceLink();
	        }
	      }
	      this.inspector.emit("rule-view-sourcelinks-updated");
	    }
	  },

	  /**
	   * Set the filter style search value.
	   * @param {String} value
	   *        The search value.
	   */
	  setFilterStyles: function (value = "") {
	    this.searchField.value = value;
	    this.searchField.focus();
	    this._onFilterStyles();
	  },

	  /**
	   * Called when the user enters a search term in the filter style search box.
	   */
	  _onFilterStyles: function () {
	    if (this._filterChangedTimeout) {
	      clearTimeout(this._filterChangedTimeout);
	    }

	    let filterTimeout = (this.searchValue.length > 0) ?
	                        FILTER_CHANGED_TIMEOUT : 0;
	    this.searchClearButton.hidden = this.searchValue.length === 0;

	    this._filterChangedTimeout = setTimeout(() => {
	      if (this.searchField.value.length > 0) {
	        this.searchField.setAttribute("filled", true);
	      } else {
	        this.searchField.removeAttribute("filled");
	      }

	      this.searchData = {
	        searchPropertyMatch: FILTER_PROP_RE.exec(this.searchValue),
	        searchPropertyName: this.searchValue,
	        searchPropertyValue: this.searchValue,
	        strictSearchValue: "",
	        strictSearchPropertyName: false,
	        strictSearchPropertyValue: false,
	        strictSearchAllValues: false
	      };

	      if (this.searchData.searchPropertyMatch) {
	        // Parse search value as a single property line and extract the
	        // property name and value. If the parsed property name or value is
	        // contained in backquotes (`), extract the value within the backquotes
	        // and set the corresponding strict search for the property to true.
	        if (FILTER_STRICT_RE.test(this.searchData.searchPropertyMatch[1])) {
	          this.searchData.strictSearchPropertyName = true;
	          this.searchData.searchPropertyName =
	            FILTER_STRICT_RE.exec(this.searchData.searchPropertyMatch[1])[1];
	        } else {
	          this.searchData.searchPropertyName =
	            this.searchData.searchPropertyMatch[1];
	        }

	        if (FILTER_STRICT_RE.test(this.searchData.searchPropertyMatch[2])) {
	          this.searchData.strictSearchPropertyValue = true;
	          this.searchData.searchPropertyValue =
	            FILTER_STRICT_RE.exec(this.searchData.searchPropertyMatch[2])[1];
	        } else {
	          this.searchData.searchPropertyValue =
	            this.searchData.searchPropertyMatch[2];
	        }

	        // Strict search for stylesheets will match the property line regex.
	        // Extract the search value within the backquotes to be used
	        // in the strict search for stylesheets in _highlightStyleSheet.
	        if (FILTER_STRICT_RE.test(this.searchValue)) {
	          this.searchData.strictSearchValue =
	            FILTER_STRICT_RE.exec(this.searchValue)[1];
	        }
	      } else if (FILTER_STRICT_RE.test(this.searchValue)) {
	        // If the search value does not correspond to a property line and
	        // is contained in backquotes, extract the search value within the
	        // backquotes and set the flag to perform a strict search for all
	        // the values (selector, stylesheet, property and computed values).
	        let searchValue = FILTER_STRICT_RE.exec(this.searchValue)[1];
	        this.searchData.strictSearchAllValues = true;
	        this.searchData.searchPropertyName = searchValue;
	        this.searchData.searchPropertyValue = searchValue;
	        this.searchData.strictSearchValue = searchValue;
	      }

	      this._clearHighlight(this.element);
	      this._clearRules();
	      this._createEditors();

	      this.inspector.emit("ruleview-filtered");

	      this._filterChangeTimeout = null;
	    }, filterTimeout);
	  },

	  /**
	   * Context menu handler for filter style search box.
	   */
	  _onFilterTextboxContextMenu: function (event) {
	    try {
	      this.styleWindow.focus();
	      let contextmenu = this.inspector.toolbox.textboxContextMenuPopup;
	      contextmenu.openPopupAtScreen(event.screenX, event.screenY, true);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  /**
	   * Called when the user clicks on the clear button in the filter style search
	   * box. Returns true if the search box is cleared and false otherwise.
	   */
	  _onClearSearch: function () {
	    if (this.searchField.value) {
	      this.setFilterStyles("");
	      return true;
	    }

	    return false;
	  },

	  destroy: function () {
	    this.isDestroyed = true;
	    this.clear();

	    this._dummyElement = null;
	    this.dummyElementPromise = null;
	    gDummyPromise = null;

	    this._prefObserver.off(PREF_ORIG_SOURCES, this._onSourcePrefChanged);
	    this._prefObserver.off(PREF_UA_STYLES, this._handlePrefChange);
	    this._prefObserver.off(PREF_DEFAULT_COLOR_UNIT, this._handlePrefChange);
	    this._prefObserver.destroy();

	    this._outputParser = null;

	    // Remove context menu
	    if (this._contextmenu) {
	      this._contextmenu.destroy();
	      this._contextmenu = null;
	    }

	    this.tooltips.destroy();
	    this.highlighters.destroy();

	    // Remove bound listeners
	    this.shortcuts.destroy();
	    this.element.removeEventListener("copy", this._onCopy);
	    this.element.removeEventListener("contextmenu", this._onContextMenu);
	    this.addRuleButton.removeEventListener("click", this._onAddRule);
	    this.searchField.removeEventListener("input", this._onFilterStyles);
	    this.searchField.removeEventListener("contextmenu",
	      this._onFilterTextboxContextMenu);
	    this.searchClearButton.removeEventListener("click", this._onClearSearch);
	    this.pseudoClassToggle.removeEventListener("click",
	      this._onTogglePseudoClassPanel);
	    this.hoverCheckbox.removeEventListener("click", this._onTogglePseudoClass);
	    this.activeCheckbox.removeEventListener("click", this._onTogglePseudoClass);
	    this.focusCheckbox.removeEventListener("click", this._onTogglePseudoClass);

	    this.searchField = null;
	    this.searchClearButton = null;
	    this.pseudoClassPanel = null;
	    this.pseudoClassToggle = null;
	    this.hoverCheckbox = null;
	    this.activeCheckbox = null;
	    this.focusCheckbox = null;

	    this.inspector = null;
	    this.styleDocument = null;
	    this.styleWindow = null;

	    if (this.element.parentNode) {
	      this.element.parentNode.removeChild(this.element);
	    }

	    if (this._elementStyle) {
	      this._elementStyle.destroy();
	    }

	    this.popup.destroy();
	  },

	  /**
	   * Mark the view as selecting an element, disabling all interaction, and
	   * visually clearing the view after a few milliseconds to avoid confusion
	   * about which element's styles the rule view shows.
	   */
	  _startSelectingElement: function () {
	    this.element.classList.add("non-interactive");
	  },

	  /**
	   * Mark the view as no longer selecting an element, re-enabling interaction.
	   */
	  _stopSelectingElement: function () {
	    this.element.classList.remove("non-interactive");
	  },

	  /**
	   * Update the view with a new selected element.
	   *
	   * @param {NodeActor} element
	   *        The node whose style rules we'll inspect.
	   * @param {Boolean} allowRefresh
	   *        Update the view even if the element is the same as last time.
	   */
	  selectElement: function (element, allowRefresh = false) {
	    let refresh = (this._viewedElement === element);
	    if (refresh && !allowRefresh) {
	      return promise.resolve(undefined);
	    }

	    if (this.popup.isOpen) {
	      this.popup.hidePopup();
	    }

	    this.clear(false);
	    this._viewedElement = element;

	    this.clearPseudoClassPanel();
	    this.refreshAddRuleButtonState();

	    if (!this._viewedElement) {
	      this._stopSelectingElement();
	      this._clearRules();
	      this._showEmpty();
	      this.refreshPseudoClassPanel();
	      return promise.resolve(undefined);
	    }

	    // To figure out how shorthand properties are interpreted by the
	    // engine, we will set properties on a dummy element and observe
	    // how their .style attribute reflects them as computed values.
	    this.dummyElementPromise = createDummyDocument().then(document => {
	      // ::before and ::after do not have a namespaceURI
	      let namespaceURI = this.element.namespaceURI ||
	          document.documentElement.namespaceURI;
	      this._dummyElement = document.createElementNS(namespaceURI,
	                                                   this.element.tagName);
	      document.documentElement.appendChild(this._dummyElement);
	      return this._dummyElement;
	    }).then(null, promiseWarn);

	    let elementStyle = new ElementStyle(element, this, this.store,
	      this.pageStyle, this.showUserAgentStyles);
	    this._elementStyle = elementStyle;

	    this._startSelectingElement();

	    return this.dummyElementPromise.then(() => {
	      if (this._elementStyle === elementStyle) {
	        return this._populate();
	      }
	      return undefined;
	    }).then(() => {
	      if (this._elementStyle === elementStyle) {
	        if (!refresh) {
	          this.element.scrollTop = 0;
	        }
	        this._stopSelectingElement();
	        this._elementStyle.onChanged = () => {
	          this._changed();
	        };
	      }
	    }).then(null, e => {
	      if (this._elementStyle === elementStyle) {
	        this._stopSelectingElement();
	        this._clearRules();
	      }
	      console.error(e);
	    });
	  },

	  /**
	   * Update the rules for the currently highlighted element.
	   */
	  refreshPanel: function () {
	    // Ignore refreshes during editing or when no element is selected.
	    if (this.isEditing || !this._elementStyle) {
	      return promise.resolve(undefined);
	    }

	    // Repopulate the element style once the current modifications are done.
	    let promises = [];
	    for (let rule of this._elementStyle.rules) {
	      if (rule._applyingModifications) {
	        promises.push(rule._applyingModifications);
	      }
	    }

	    return promise.all(promises).then(() => {
	      return this._populate();
	    });
	  },

	  /**
	   * Clear the pseudo class options panel by removing the checked and disabled
	   * attributes for each checkbox.
	   */
	  clearPseudoClassPanel: function () {
	    this.hoverCheckbox.checked = this.hoverCheckbox.disabled = false;
	    this.activeCheckbox.checked = this.activeCheckbox.disabled = false;
	    this.focusCheckbox.checked = this.focusCheckbox.disabled = false;
	  },

	  /**
	   * Update the pseudo class options for the currently highlighted element.
	   */
	  refreshPseudoClassPanel: function () {
	    if (!this._elementStyle || !this.inspector.selection.isElementNode()) {
	      this.hoverCheckbox.disabled = true;
	      this.activeCheckbox.disabled = true;
	      this.focusCheckbox.disabled = true;
	      return;
	    }

	    for (let pseudoClassLock of this._elementStyle.element.pseudoClassLocks) {
	      switch (pseudoClassLock) {
	        case ":hover": {
	          this.hoverCheckbox.checked = true;
	          break;
	        }
	        case ":active": {
	          this.activeCheckbox.checked = true;
	          break;
	        }
	        case ":focus": {
	          this.focusCheckbox.checked = true;
	          break;
	        }
	      }
	    }
	  },

	  _populate: function () {
	    let elementStyle = this._elementStyle;
	    return this._elementStyle.populate().then(() => {
	      if (this._elementStyle !== elementStyle || this.isDestroyed) {
	        return null;
	      }

	      this._clearRules();
	      let onEditorsReady = this._createEditors();
	      this.refreshPseudoClassPanel();

	      // Notify anyone that cares that we refreshed.
	      return onEditorsReady.then(() => {
	        this.emit("ruleview-refreshed");
	      }, e => console.error(e));
	    }).then(null, promiseWarn);
	  },

	  /**
	   * Show the user that the rule view has no node selected.
	   */
	  _showEmpty: function () {
	    if (this.styleDocument.getElementById("ruleview-no-results")) {
	      return;
	    }

	    createChild(this.element, "div", {
	      id: "ruleview-no-results",
	      textContent: l10n("rule.empty")
	    });
	  },

	  /**
	   * Clear the rules.
	   */
	  _clearRules: function () {
	    this.element.innerHTML = "";
	  },

	  /**
	   * Clear the rule view.
	   */
	  clear: function (clearDom = true) {
	    this.lastSelectorIcon = null;

	    if (clearDom) {
	      this._clearRules();
	    }
	    this._viewedElement = null;

	    if (this._elementStyle) {
	      this._elementStyle.destroy();
	      this._elementStyle = null;
	    }
	  },

	  /**
	   * Called when the user has made changes to the ElementStyle.
	   * Emits an event that clients can listen to.
	   */
	  _changed: function () {
	    this.emit("ruleview-changed");
	  },

	  /**
	   * Text for header that shows above rules for this element
	   */
	  get selectedElementLabel() {
	    if (this._selectedElementLabel) {
	      return this._selectedElementLabel;
	    }
	    this._selectedElementLabel = l10n("rule.selectedElement");
	    return this._selectedElementLabel;
	  },

	  /**
	   * Text for header that shows above rules for pseudo elements
	   */
	  get pseudoElementLabel() {
	    if (this._pseudoElementLabel) {
	      return this._pseudoElementLabel;
	    }
	    this._pseudoElementLabel = l10n("rule.pseudoElement");
	    return this._pseudoElementLabel;
	  },

	  get showPseudoElements() {
	    if (this._showPseudoElements === undefined) {
	      this._showPseudoElements =
	        Services.prefs.getBoolPref("devtools.inspector.show_pseudo_elements");
	    }
	    return this._showPseudoElements;
	  },

	  /**
	   * Creates an expandable container in the rule view
	   *
	   * @param  {String} label
	   *         The label for the container header
	   * @param  {Boolean} isPseudo
	   *         Whether or not the container will hold pseudo element rules
	   * @return {DOMNode} The container element
	   */
	  createExpandableContainer: function (label, isPseudo = false) {
	    let header = this.styleDocument.createElementNS(HTML_NS, "div");
	    header.className = this._getRuleViewHeaderClassName(true);
	    header.textContent = label;

	    let twisty = this.styleDocument.createElementNS(HTML_NS, "span");
	    twisty.className = "ruleview-expander theme-twisty";
	    twisty.setAttribute("open", "true");

	    header.insertBefore(twisty, header.firstChild);
	    this.element.appendChild(header);

	    let container = this.styleDocument.createElementNS(HTML_NS, "div");
	    container.classList.add("ruleview-expandable-container");
	    container.hidden = false;
	    this.element.appendChild(container);

	    header.addEventListener("dblclick", () => {
	      this._toggleContainerVisibility(twisty, container, isPseudo,
	        !this.showPseudoElements);
	    }, false);

	    twisty.addEventListener("click", () => {
	      this._toggleContainerVisibility(twisty, container, isPseudo,
	        !this.showPseudoElements);
	    }, false);

	    if (isPseudo) {
	      this._toggleContainerVisibility(twisty, container, isPseudo,
	        this.showPseudoElements);
	    }

	    return container;
	  },

	  /**
	   * Toggle the visibility of an expandable container
	   *
	   * @param  {DOMNode}  twisty
	   *         Clickable toggle DOM Node
	   * @param  {DOMNode}  container
	   *         Expandable container DOM Node
	   * @param  {Boolean}  isPseudo
	   *         Whether or not the container will hold pseudo element rules
	   * @param  {Boolean}  showPseudo
	   *         Whether or not pseudo element rules should be displayed
	   */
	  _toggleContainerVisibility: function (twisty, container, isPseudo,
	      showPseudo) {
	    let isOpen = twisty.getAttribute("open");

	    if (isPseudo) {
	      this._showPseudoElements = !!showPseudo;

	      Services.prefs.setBoolPref("devtools.inspector.show_pseudo_elements",
	        this.showPseudoElements);

	      container.hidden = !this.showPseudoElements;
	      isOpen = !this.showPseudoElements;
	    } else {
	      container.hidden = !container.hidden;
	    }

	    if (isOpen) {
	      twisty.removeAttribute("open");
	    } else {
	      twisty.setAttribute("open", "true");
	    }
	  },

	  _getRuleViewHeaderClassName: function (isPseudo) {
	    let baseClassName = "theme-gutter ruleview-header";
	    return isPseudo ? baseClassName + " ruleview-expandable-header" :
	      baseClassName;
	  },

	  /**
	   * Creates editor UI for each of the rules in _elementStyle.
	   */
	  _createEditors: function () {
	    // Run through the current list of rules, attaching
	    // their editors in order.  Create editors if needed.
	    let lastInheritedSource = "";
	    let lastKeyframes = null;
	    let seenPseudoElement = false;
	    let seenNormalElement = false;
	    let seenSearchTerm = false;
	    let container = null;

	    if (!this._elementStyle.rules) {
	      return promise.resolve();
	    }

	    let editorReadyPromises = [];
	    for (let rule of this._elementStyle.rules) {
	      if (rule.domRule.system) {
	        continue;
	      }

	      // Initialize rule editor
	      if (!rule.editor) {
	        rule.editor = new RuleEditor(this, rule);
	        editorReadyPromises.push(rule.editor.once("source-link-updated"));
	      }

	      // Filter the rules and highlight any matches if there is a search input
	      if (this.searchValue && this.searchData) {
	        if (this.highlightRule(rule)) {
	          seenSearchTerm = true;
	        } else if (rule.domRule.type !== ELEMENT_STYLE) {
	          continue;
	        }
	      }

	      // Only print header for this element if there are pseudo elements
	      if (seenPseudoElement && !seenNormalElement && !rule.pseudoElement) {
	        seenNormalElement = true;
	        let div = this.styleDocument.createElementNS(HTML_NS, "div");
	        div.className = this._getRuleViewHeaderClassName();
	        div.textContent = this.selectedElementLabel;
	        this.element.appendChild(div);
	      }

	      let inheritedSource = rule.inheritedSource;
	      if (inheritedSource && inheritedSource !== lastInheritedSource) {
	        let div = this.styleDocument.createElementNS(HTML_NS, "div");
	        div.className = this._getRuleViewHeaderClassName();
	        div.textContent = inheritedSource;
	        lastInheritedSource = inheritedSource;
	        this.element.appendChild(div);
	      }

	      if (!seenPseudoElement && rule.pseudoElement) {
	        seenPseudoElement = true;
	        container = this.createExpandableContainer(this.pseudoElementLabel,
	                                                   true);
	      }

	      let keyframes = rule.keyframes;
	      if (keyframes && keyframes !== lastKeyframes) {
	        lastKeyframes = keyframes;
	        container = this.createExpandableContainer(rule.keyframesName);
	      }

	      if (container && (rule.pseudoElement || keyframes)) {
	        container.appendChild(rule.editor.element);
	      } else {
	        this.element.appendChild(rule.editor.element);
	      }
	    }

	    if (this.searchValue && !seenSearchTerm) {
	      this.searchField.classList.add("devtools-style-searchbox-no-match");
	    } else {
	      this.searchField.classList.remove("devtools-style-searchbox-no-match");
	    }

	    return promise.all(editorReadyPromises);
	  },

	  /**
	   * Highlight rules that matches the filter search value and returns a
	   * boolean indicating whether or not rules were highlighted.
	   *
	   * @param  {Rule} rule
	   *         The rule object we're highlighting if its rule selectors or
	   *         property values match the search value.
	   * @return {Boolean} true if the rule was highlighted, false otherwise.
	   */
	  highlightRule: function (rule) {
	    let isRuleSelectorHighlighted = this._highlightRuleSelector(rule);
	    let isStyleSheetHighlighted = this._highlightStyleSheet(rule);
	    let isHighlighted = isRuleSelectorHighlighted || isStyleSheetHighlighted;

	    // Highlight search matches in the rule properties
	    for (let textProp of rule.textProps) {
	      if (!textProp.invisible && this._highlightProperty(textProp.editor)) {
	        isHighlighted = true;
	      }
	    }

	    return isHighlighted;
	  },

	  /**
	   * Highlights the rule selector that matches the filter search value and
	   * returns a boolean indicating whether or not the selector was highlighted.
	   *
	   * @param  {Rule} rule
	   *         The Rule object.
	   * @return {Boolean} true if the rule selector was highlighted,
	   *         false otherwise.
	   */
	  _highlightRuleSelector: function (rule) {
	    let isSelectorHighlighted = false;

	    let selectorNodes = [...rule.editor.selectorText.childNodes];
	    if (rule.domRule.type === CSSRule.KEYFRAME_RULE) {
	      selectorNodes = [rule.editor.selectorText];
	    } else if (rule.domRule.type === ELEMENT_STYLE) {
	      selectorNodes = [];
	    }

	    // Highlight search matches in the rule selectors
	    for (let selectorNode of selectorNodes) {
	      let selector = selectorNode.textContent.toLowerCase();
	      if ((this.searchData.strictSearchAllValues &&
	           selector === this.searchData.strictSearchValue) ||
	          (!this.searchData.strictSearchAllValues &&
	           selector.includes(this.searchValue))) {
	        selectorNode.classList.add("ruleview-highlight");
	        isSelectorHighlighted = true;
	      }
	    }

	    return isSelectorHighlighted;
	  },

	  /**
	   * Highlights the stylesheet source that matches the filter search value and
	   * returns a boolean indicating whether or not the stylesheet source was
	   * highlighted.
	   *
	   * @return {Boolean} true if the stylesheet source was highlighted, false
	   *         otherwise.
	   */
	  _highlightStyleSheet: function (rule) {
	    let styleSheetSource = rule.title.toLowerCase();
	    let isStyleSheetHighlighted = this.searchData.strictSearchValue ?
	      styleSheetSource === this.searchData.strictSearchValue :
	      styleSheetSource.includes(this.searchValue);

	    if (isStyleSheetHighlighted) {
	      rule.editor.source.classList.add("ruleview-highlight");
	    }

	    return isStyleSheetHighlighted;
	  },

	  /**
	   * Highlights the rule properties and computed properties that match the
	   * filter search value and returns a boolean indicating whether or not the
	   * property or computed property was highlighted.
	   *
	   * @param  {TextPropertyEditor} editor
	   *         The rule property TextPropertyEditor object.
	   * @return {Boolean} true if the property or computed property was
	   *         highlighted, false otherwise.
	   */
	  _highlightProperty: function (editor) {
	    let isPropertyHighlighted = this._highlightRuleProperty(editor);
	    let isComputedHighlighted = this._highlightComputedProperty(editor);

	    // Expand the computed list if a computed property is highlighted and the
	    // property rule is not highlighted
	    if (!isPropertyHighlighted && isComputedHighlighted &&
	        !editor.computed.hasAttribute("user-open")) {
	      editor.expandForFilter();
	    }

	    return isPropertyHighlighted || isComputedHighlighted;
	  },

	  /**
	   * Called when TextPropertyEditor is updated and updates the rule property
	   * highlight.
	   *
	   * @param  {TextPropertyEditor} editor
	   *         The rule property TextPropertyEditor object.
	   */
	  _updatePropertyHighlight: function (editor) {
	    if (!this.searchValue || !this.searchData) {
	      return;
	    }

	    this._clearHighlight(editor.element);

	    if (this._highlightProperty(editor)) {
	      this.searchField.classList.remove("devtools-style-searchbox-no-match");
	    }
	  },

	  /**
	   * Highlights the rule property that matches the filter search value
	   * and returns a boolean indicating whether or not the property was
	   * highlighted.
	   *
	   * @param  {TextPropertyEditor} editor
	   *         The rule property TextPropertyEditor object.
	   * @return {Boolean} true if the rule property was highlighted,
	   *         false otherwise.
	   */
	  _highlightRuleProperty: function (editor) {
	    // Get the actual property value displayed in the rule view
	    let propertyName = editor.prop.name.toLowerCase();
	    let propertyValue = editor.valueSpan.textContent.toLowerCase();

	    return this._highlightMatches(editor.container, propertyName,
	                                  propertyValue);
	  },

	  /**
	   * Highlights the computed property that matches the filter search value and
	   * returns a boolean indicating whether or not the computed property was
	   * highlighted.
	   *
	   * @param  {TextPropertyEditor} editor
	   *         The rule property TextPropertyEditor object.
	   * @return {Boolean} true if the computed property was highlighted, false
	   *         otherwise.
	   */
	  _highlightComputedProperty: function (editor) {
	    let isComputedHighlighted = false;

	    // Highlight search matches in the computed list of properties
	    editor._populateComputed();
	    for (let computed of editor.prop.computed) {
	      if (computed.element) {
	        // Get the actual property value displayed in the computed list
	        let computedName = computed.name.toLowerCase();
	        let computedValue = computed.parsedValue.toLowerCase();

	        isComputedHighlighted = this._highlightMatches(computed.element,
	          computedName, computedValue) ? true : isComputedHighlighted;
	      }
	    }

	    return isComputedHighlighted;
	  },

	  /**
	   * Helper function for highlightRules that carries out highlighting the given
	   * element if the search terms match the property, and returns a boolean
	   * indicating whether or not the search terms match.
	   *
	   * @param  {DOMNode} element
	   *         The node to highlight if search terms match
	   * @param  {String} propertyName
	   *         The property name of a rule
	   * @param  {String} propertyValue
	   *         The property value of a rule
	   * @return {Boolean} true if the given search terms match the property, false
	   *         otherwise.
	   */
	  _highlightMatches: function (element, propertyName, propertyValue) {
	    let {
	      searchPropertyName,
	      searchPropertyValue,
	      searchPropertyMatch,
	      strictSearchPropertyName,
	      strictSearchPropertyValue,
	      strictSearchAllValues,
	    } = this.searchData;
	    let matches = false;

	    // If the inputted search value matches a property line like
	    // `font-family: arial`, then check to make sure the name and value match.
	    // Otherwise, just compare the inputted search string directly against the
	    // name and value of the rule property.
	    let hasNameAndValue = searchPropertyMatch &&
	                          searchPropertyName &&
	                          searchPropertyValue;
	    let isMatch = (value, query, isStrict) => {
	      return isStrict ? value === query : query && value.includes(query);
	    };

	    if (hasNameAndValue) {
	      matches =
	        isMatch(propertyName, searchPropertyName, strictSearchPropertyName) &&
	        isMatch(propertyValue, searchPropertyValue, strictSearchPropertyValue);
	    } else {
	      matches =
	        isMatch(propertyName, searchPropertyName,
	                strictSearchPropertyName || strictSearchAllValues) ||
	        isMatch(propertyValue, searchPropertyValue,
	                strictSearchPropertyValue || strictSearchAllValues);
	    }

	    if (matches) {
	      element.classList.add("ruleview-highlight");
	    }

	    return matches;
	  },

	  /**
	   * Clear all search filter highlights in the panel, and close the computed
	   * list if toggled opened
	   */
	  _clearHighlight: function (element) {
	    for (let el of element.querySelectorAll(".ruleview-highlight")) {
	      el.classList.remove("ruleview-highlight");
	    }

	    for (let computed of element.querySelectorAll(
	          ".ruleview-computedlist[filter-open]")) {
	      computed.parentNode._textPropertyEditor.collapseForFilter();
	    }
	  },

	  /**
	   * Called when the pseudo class panel button is clicked and toggles
	   * the display of the pseudo class panel.
	   */
	  _onTogglePseudoClassPanel: function () {
	    if (this.pseudoClassPanel.hidden) {
	      this.pseudoClassToggle.setAttribute("checked", "true");
	      this.hoverCheckbox.setAttribute("tabindex", "0");
	      this.activeCheckbox.setAttribute("tabindex", "0");
	      this.focusCheckbox.setAttribute("tabindex", "0");
	    } else {
	      this.pseudoClassToggle.removeAttribute("checked");
	      this.hoverCheckbox.setAttribute("tabindex", "-1");
	      this.activeCheckbox.setAttribute("tabindex", "-1");
	      this.focusCheckbox.setAttribute("tabindex", "-1");
	    }

	    this.pseudoClassPanel.hidden = !this.pseudoClassPanel.hidden;
	  },

	  /**
	   * Called when a pseudo class checkbox is clicked and toggles
	   * the pseudo class for the current selected element.
	   */
	  _onTogglePseudoClass: function (event) {
	    let target = event.currentTarget;
	    this.inspector.togglePseudoClass(target.value);
	  },

	  /**
	   * Handle the keypress event in the rule view.
	   */
	  _onShortcut: function (name, event) {
	    if (!event.target.closest("#sidebar-panel-ruleview")) {
	      return;
	    }

	    if (name === "CmdOrCtrl+F") {
	      this.searchField.focus();
	      event.preventDefault();
	    } else if ((name === "Return" || name === "Space") &&
	               this.element.classList.contains("non-interactive")) {
	      event.preventDefault();
	    } else if (name === "Escape" &&
	               event.target === this.searchField &&
	               this._onClearSearch()) {
	      // Handle the search box's keypress event. If the escape key is pressed,
	      // clear the search box field.
	      event.preventDefault();
	      event.stopPropagation();
	    }
	  }

	};

	/**
	 * Helper functions
	 */

	/**
	 * Walk up the DOM from a given node until a parent property holder is found.
	 * For elements inside the computed property list, the non-computed parent
	 * property holder will be returned
	 *
	 * @param {DOMNode} node
	 *        The node to start from
	 * @return {DOMNode} The parent property holder node, or null if not found
	 */
	function getParentTextPropertyHolder(node) {
	  while (true) {
	    if (!node || !node.classList) {
	      return null;
	    }
	    if (node.classList.contains("ruleview-property")) {
	      return node;
	    }
	    node = node.parentNode;
	  }
	}

	/**
	 * For any given node, find the TextProperty it is in if any
	 * @param {DOMNode} node
	 *        The node to start from
	 * @return {TextProperty}
	 */
	function getParentTextProperty(node) {
	  let parent = getParentTextPropertyHolder(node);
	  if (!parent) {
	    return null;
	  }

	  let propValue = parent.querySelector(".ruleview-propertyvalue");
	  if (!propValue) {
	    return null;
	  }

	  return propValue.textProperty;
	}

	/**
	 * Walker up the DOM from a given node until a parent property holder is found,
	 * and return the textContent for the name and value nodes.
	 * Stops at the first property found, so if node is inside the computed property
	 * list, the computed property will be returned
	 *
	 * @param {DOMNode} node
	 *        The node to start from
	 * @return {Object} {name, value}
	 */
	function getPropertyNameAndValue(node) {
	  while (true) {
	    if (!node || !node.classList) {
	      return null;
	    }
	    // Check first for ruleview-computed since it's the deepest
	    if (node.classList.contains("ruleview-computed") ||
	        node.classList.contains("ruleview-property")) {
	      return {
	        name: node.querySelector(".ruleview-propertyname").textContent,
	        value: node.querySelector(".ruleview-propertyvalue").textContent
	      };
	    }
	    node = node.parentNode;
	  }
	}

	function RuleViewTool(inspector, window) {
	  this.inspector = inspector;
	  this.document = window.document;

	  this.view = new CssRuleView(this.inspector, this.document);

	  this.onLinkClicked = this.onLinkClicked.bind(this);
	  this.onSelected = this.onSelected.bind(this);
	  this.refresh = this.refresh.bind(this);
	  this.clearUserProperties = this.clearUserProperties.bind(this);
	  this.onPropertyChanged = this.onPropertyChanged.bind(this);
	  this.onViewRefreshed = this.onViewRefreshed.bind(this);
	  this.onPanelSelected = this.onPanelSelected.bind(this);
	  this.onMutations = this.onMutations.bind(this);
	  this.onResized = this.onResized.bind(this);

	  this.view.on("ruleview-changed", this.onPropertyChanged);
	  this.view.on("ruleview-refreshed", this.onViewRefreshed);
	  this.view.on("ruleview-linked-clicked", this.onLinkClicked);

	  this.inspector.selection.on("detached-front", this.onSelected);
	  this.inspector.selection.on("new-node-front", this.onSelected);
	  this.inspector.selection.on("pseudoclass", this.refresh);
	  this.inspector.target.on("navigate", this.clearUserProperties);
	  this.inspector.sidebar.on("ruleview-selected", this.onPanelSelected);
	  this.inspector.pageStyle.on("stylesheet-updated", this.refresh);
	  this.inspector.walker.on("mutations", this.onMutations);
	  this.inspector.walker.on("resize", this.onResized);

	  this.onSelected();
	}

	RuleViewTool.prototype = {
	  isSidebarActive: function () {
	    if (!this.view) {
	      return false;
	    }
	    return this.inspector.sidebar.getCurrentTabID() == "ruleview";
	  },

	  onSelected: function (event) {
	    // Ignore the event if the view has been destroyed, or if it's inactive.
	    // But only if the current selection isn't null. If it's been set to null,
	    // let the update go through as this is needed to empty the view on
	    // navigation.
	    if (!this.view) {
	      return;
	    }

	    let isInactive = !this.isSidebarActive() &&
	                     this.inspector.selection.nodeFront;
	    if (isInactive) {
	      return;
	    }

	    this.view.setPageStyle(this.inspector.pageStyle);

	    if (!this.inspector.selection.isConnected() ||
	        !this.inspector.selection.isElementNode()) {
	      this.view.selectElement(null);
	      return;
	    }

	    if (!event || event == "new-node-front") {
	      let done = this.inspector.updating("rule-view");
	      this.view.selectElement(this.inspector.selection.nodeFront)
	        .then(done, done);
	    }
	  },

	  refresh: function () {
	    if (this.isSidebarActive()) {
	      this.view.refreshPanel();
	    }
	  },

	  clearUserProperties: function () {
	    if (this.view && this.view.store && this.view.store.userProperties) {
	      this.view.store.userProperties.clear();
	    }
	  },

	  onPanelSelected: function () {
	    if (this.inspector.selection.nodeFront === this.view._viewedElement) {
	      this.refresh();
	    } else {
	      this.onSelected();
	    }
	  },

	  onLinkClicked: function (e, rule) {
	    let sheet = rule.parentStyleSheet;

	    // Chrome stylesheets are not listed in the style editor, so show
	    // these sheets in the view source window instead.
	    if (!sheet || sheet.isSystem) {
	      let href = rule.nodeHref || rule.href;
	      let toolbox = gDevTools.getToolbox(this.inspector.target);
	      toolbox.viewSource(href, rule.line);
	      return;
	    }

	    let location = promise.resolve(rule.location);
	    if (Services.prefs.getBoolPref(PREF_ORIG_SOURCES)) {
	      location = rule.getOriginalLocation();
	    }
	    location.then(({ source, href, line, column }) => {
	      let target = this.inspector.target;
	      if (Tools.styleEditor.isTargetSupported(target)) {
	        gDevTools.showToolbox(target, "styleeditor").then(function (toolbox) {
	          let url = source || href;
	          toolbox.getCurrentPanel().selectStyleSheet(url, line, column);
	        });
	      }
	      return;
	    });
	  },

	  onPropertyChanged: function () {
	    this.inspector.markDirty();
	  },

	  onViewRefreshed: function () {
	    this.inspector.emit("rule-view-refreshed");
	  },

	  /**
	   * When markup mutations occur, if an attribute of the selected node changes,
	   * we need to refresh the view as that might change the node's styles.
	   */
	  onMutations: function (mutations) {
	    for (let {type, target} of mutations) {
	      if (target === this.inspector.selection.nodeFront &&
	          type === "attributes") {
	        this.refresh();
	        break;
	      }
	    }
	  },

	  /**
	   * When the window gets resized, this may cause media-queries to match, and
	   * therefore, different styles may apply.
	   */
	  onResized: function () {
	    this.refresh();
	  },

	  destroy: function () {
	    this.inspector.walker.off("mutations", this.onMutations);
	    this.inspector.walker.off("resize", this.onResized);
	    this.inspector.selection.off("detached-front", this.onSelected);
	    this.inspector.selection.off("pseudoclass", this.refresh);
	    this.inspector.selection.off("new-node-front", this.onSelected);
	    this.inspector.target.off("navigate", this.clearUserProperties);
	    this.inspector.sidebar.off("ruleview-selected", this.onPanelSelected);
	    if (this.inspector.pageStyle) {
	      this.inspector.pageStyle.off("stylesheet-updated", this.refresh);
	    }

	    this.view.off("ruleview-linked-clicked", this.onLinkClicked);
	    this.view.off("ruleview-changed", this.onPropertyChanged);
	    this.view.off("ruleview-refreshed", this.onViewRefreshed);

	    this.view.destroy();

	    this.view = this.document = this.inspector = null;
	  }
	};

	exports.CssRuleView = CssRuleView;
	exports.RuleViewTool = RuleViewTool;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);
	const {Rule} = __webpack_require__(200);
	const {promiseWarn} = __webpack_require__(181);
	const {ELEMENT_STYLE} = __webpack_require__(175);
	const {getCssProperties} = __webpack_require__(16);

	/**
	 * ElementStyle is responsible for the following:
	 *   Keeps track of which properties are overridden.
	 *   Maintains a list of Rule objects for a given element.
	 *
	 * @param {Element} element
	 *        The element whose style we are viewing.
	 * @param {CssRuleView} ruleView
	 *        The instance of the rule-view panel.
	 * @param {Object} store
	 *        The ElementStyle can use this object to store metadata
	 *        that might outlast the rule view, particularly the current
	 *        set of disabled properties.
	 * @param {PageStyleFront} pageStyle
	 *        Front for the page style actor that will be providing
	 *        the style information.
	 * @param {Boolean} showUserAgentStyles
	 *        Should user agent styles be inspected?
	 */
	function ElementStyle(element, ruleView, store, pageStyle,
	    showUserAgentStyles) {
	  this.element = element;
	  this.ruleView = ruleView;
	  this.store = store || {};
	  this.pageStyle = pageStyle;
	  this.showUserAgentStyles = showUserAgentStyles;
	  this.rules = [];
	  this.cssProperties = getCssProperties(this.ruleView.inspector.toolbox);

	  // We don't want to overwrite this.store.userProperties so we only create it
	  // if it doesn't already exist.
	  if (!("userProperties" in this.store)) {
	    this.store.userProperties = new UserProperties();
	  }

	  if (!("disabled" in this.store)) {
	    this.store.disabled = new WeakMap();
	  }
	}

	ElementStyle.prototype = {
	  // The element we're looking at.
	  element: null,

	  destroy: function () {
	    if (this.destroyed) {
	      return;
	    }
	    this.destroyed = true;

	    for (let rule of this.rules) {
	      if (rule.editor) {
	        rule.editor.destroy();
	      }
	    }
	  },

	  /**
	   * Called by the Rule object when it has been changed through the
	   * setProperty* methods.
	   */
	  _changed: function () {
	    if (this.onChanged) {
	      this.onChanged();
	    }
	  },

	  /**
	   * Refresh the list of rules to be displayed for the active element.
	   * Upon completion, this.rules[] will hold a list of Rule objects.
	   *
	   * Returns a promise that will be resolved when the elementStyle is
	   * ready.
	   */
	  populate: function () {
	    let populated = this.pageStyle.getApplied(this.element, {
	      inherited: true,
	      matchedSelectors: true,
	      filter: this.showUserAgentStyles ? "ua" : undefined,
	    }).then(entries => {
	      if (this.destroyed) {
	        return promise.resolve(undefined);
	      }

	      if (this.populated !== populated) {
	        // Don't care anymore.
	        return promise.resolve(undefined);
	      }

	      // Store the current list of rules (if any) during the population
	      // process.  They will be reused if possible.
	      let existingRules = this.rules;

	      this.rules = [];

	      for (let entry of entries) {
	        this._maybeAddRule(entry, existingRules);
	      }

	      // Mark overridden computed styles.
	      this.markOverriddenAll();

	      this._sortRulesForPseudoElement();

	      // We're done with the previous list of rules.
	      for (let r of existingRules) {
	        if (r && r.editor) {
	          r.editor.destroy();
	        }
	      }

	      return undefined;
	    }).then(null, e => {
	      // populate is often called after a setTimeout,
	      // the connection may already be closed.
	      if (this.destroyed) {
	        return promise.resolve(undefined);
	      }
	      return promiseWarn(e);
	    });
	    this.populated = populated;
	    return this.populated;
	  },

	  /**
	   * Put pseudo elements in front of others.
	   */
	  _sortRulesForPseudoElement: function () {
	    this.rules = this.rules.sort((a, b) => {
	      return (a.pseudoElement || "z") > (b.pseudoElement || "z");
	    });
	  },

	  /**
	   * Add a rule if it's one we care about.  Filters out duplicates and
	   * inherited styles with no inherited properties.
	   *
	   * @param {Object} options
	   *        Options for creating the Rule, see the Rule constructor.
	   * @param {Array} existingRules
	   *        Rules to reuse if possible.  If a rule is reused, then it
	   *        it will be deleted from this array.
	   * @return {Boolean} true if we added the rule.
	   */
	  _maybeAddRule: function (options, existingRules) {
	    // If we've already included this domRule (for example, when a
	    // common selector is inherited), ignore it.
	    if (options.rule &&
	        this.rules.some(rule => rule.domRule === options.rule)) {
	      return false;
	    }

	    if (options.system) {
	      return false;
	    }

	    let rule = null;

	    // If we're refreshing and the rule previously existed, reuse the
	    // Rule object.
	    if (existingRules) {
	      let ruleIndex = existingRules.findIndex((r) => r.matches(options));
	      if (ruleIndex >= 0) {
	        rule = existingRules[ruleIndex];
	        rule.refresh(options);
	        existingRules.splice(ruleIndex, 1);
	      }
	    }

	    // If this is a new rule, create its Rule object.
	    if (!rule) {
	      rule = new Rule(this, options);
	    }

	    // Ignore inherited rules with no visible properties.
	    if (options.inherited && !rule.hasAnyVisibleProperties()) {
	      return false;
	    }

	    this.rules.push(rule);
	    return true;
	  },

	  /**
	   * Calls markOverridden with all supported pseudo elements
	   */
	  markOverriddenAll: function () {
	    this.markOverridden();
	    for (let pseudo of this.cssProperties.pseudoElements) {
	      this.markOverridden(pseudo);
	    }
	  },

	  /**
	   * Mark the properties listed in this.rules for a given pseudo element
	   * with an overridden flag if an earlier property overrides it.
	   *
	   * @param {String} pseudo
	   *        Which pseudo element to flag as overridden.
	   *        Empty string or undefined will default to no pseudo element.
	   */
	  markOverridden: function (pseudo = "") {
	    // Gather all the text properties applied by these rules, ordered
	    // from more- to less-specific. Text properties from keyframes rule are
	    // excluded from being marked as overridden since a number of criteria such
	    // as time, and animation overlay are required to be check in order to
	    // determine if the property is overridden.
	    let textProps = [];
	    for (let rule of this.rules) {
	      if ((rule.matchedSelectors.length > 0 ||
	           rule.domRule.type === ELEMENT_STYLE) &&
	          rule.pseudoElement === pseudo && !rule.keyframes) {
	        for (let textProp of rule.textProps.slice(0).reverse()) {
	          if (textProp.enabled) {
	            textProps.push(textProp);
	          }
	        }
	      }
	    }

	    // Gather all the computed properties applied by those text
	    // properties.
	    let computedProps = [];
	    for (let textProp of textProps) {
	      computedProps = computedProps.concat(textProp.computed);
	    }

	    // Walk over the computed properties.  As we see a property name
	    // for the first time, mark that property's name as taken by this
	    // property.
	    //
	    // If we come across a property whose name is already taken, check
	    // its priority against the property that was found first:
	    //
	    //   If the new property is a higher priority, mark the old
	    //   property overridden and mark the property name as taken by
	    //   the new property.
	    //
	    //   If the new property is a lower or equal priority, mark it as
	    //   overridden.
	    //
	    // _overriddenDirty will be set on each prop, indicating whether its
	    // dirty status changed during this pass.
	    let taken = {};
	    for (let computedProp of computedProps) {
	      let earlier = taken[computedProp.name];

	      // Prevent -webkit-gradient from being selected after unchecking
	      // linear-gradient in this case:
	      //  -moz-linear-gradient: ...;
	      //  -webkit-linear-gradient: ...;
	      //  linear-gradient: ...;
	      if (!computedProp.textProp.isValid()) {
	        computedProp.overridden = true;
	        continue;
	      }
	      let overridden;
	      if (earlier &&
	          computedProp.priority === "important" &&
	          earlier.priority !== "important" &&
	          (earlier.textProp.rule.inherited ||
	           !computedProp.textProp.rule.inherited)) {
	        // New property is higher priority.  Mark the earlier property
	        // overridden (which will reverse its dirty state).
	        earlier._overriddenDirty = !earlier._overriddenDirty;
	        earlier.overridden = true;
	        overridden = false;
	      } else {
	        overridden = !!earlier;
	      }

	      computedProp._overriddenDirty =
	        (!!computedProp.overridden !== overridden);
	      computedProp.overridden = overridden;
	      if (!computedProp.overridden && computedProp.textProp.enabled) {
	        taken[computedProp.name] = computedProp;
	      }
	    }

	    // For each TextProperty, mark it overridden if all of its
	    // computed properties are marked overridden.  Update the text
	    // property's associated editor, if any.  This will clear the
	    // _overriddenDirty state on all computed properties.
	    for (let textProp of textProps) {
	      // _updatePropertyOverridden will return true if the
	      // overridden state has changed for the text property.
	      if (this._updatePropertyOverridden(textProp)) {
	        textProp.updateEditor();
	      }
	    }
	  },

	  /**
	   * Mark a given TextProperty as overridden or not depending on the
	   * state of its computed properties.  Clears the _overriddenDirty state
	   * on all computed properties.
	   *
	   * @param {TextProperty} prop
	   *        The text property to update.
	   * @return {Boolean} true if the TextProperty's overridden state (or any of
	   *         its computed properties overridden state) changed.
	   */
	  _updatePropertyOverridden: function (prop) {
	    let overridden = true;
	    let dirty = false;
	    for (let computedProp of prop.computed) {
	      if (!computedProp.overridden) {
	        overridden = false;
	      }
	      dirty = computedProp._overriddenDirty || dirty;
	      delete computedProp._overriddenDirty;
	    }

	    dirty = (!!prop.overridden !== overridden) || dirty;
	    prop.overridden = overridden;
	    return dirty;
	  }
	};

	/**
	 * Store of CSSStyleDeclarations mapped to properties that have been changed by
	 * the user.
	 */
	function UserProperties() {
	  this.map = new Map();
	}

	UserProperties.prototype = {
	  /**
	   * Get a named property for a given CSSStyleDeclaration.
	   *
	   * @param {CSSStyleDeclaration} style
	   *        The CSSStyleDeclaration against which the property is mapped.
	   * @param {String} name
	   *        The name of the property to get.
	   * @param {String} value
	   *        Default value.
	   * @return {String}
	   *        The property value if it has previously been set by the user, null
	   *        otherwise.
	   */
	  getProperty: function (style, name, value) {
	    let key = this.getKey(style);
	    let entry = this.map.get(key, null);

	    if (entry && name in entry) {
	      return entry[name];
	    }
	    return value;
	  },

	  /**
	   * Set a named property for a given CSSStyleDeclaration.
	   *
	   * @param {CSSStyleDeclaration} style
	   *        The CSSStyleDeclaration against which the property is to be mapped.
	   * @param {String} bame
	   *        The name of the property to set.
	   * @param {String} userValue
	   *        The value of the property to set.
	   */
	  setProperty: function (style, bame, userValue) {
	    let key = this.getKey(style, bame);
	    let entry = this.map.get(key, null);

	    if (entry) {
	      entry[bame] = userValue;
	    } else {
	      let props = {};
	      props[bame] = userValue;
	      this.map.set(key, props);
	    }
	  },

	  /**
	   * Check whether a named property for a given CSSStyleDeclaration is stored.
	   *
	   * @param {CSSStyleDeclaration} style
	   *        The CSSStyleDeclaration against which the property would be mapped.
	   * @param {String} name
	   *        The name of the property to check.
	   */
	  contains: function (style, name) {
	    let key = this.getKey(style, name);
	    let entry = this.map.get(key, null);
	    return !!entry && name in entry;
	  },

	  getKey: function (style, name) {
	    return style.actorID + ":" + name;
	  },

	  clear: function () {
	    this.map.clear();
	  }
	};

	exports.ElementStyle = ElementStyle;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);
	const CssLogic = __webpack_require__(173);
	const {ELEMENT_STYLE} = __webpack_require__(175);
	const {TextProperty} =
	      __webpack_require__(201);
	const {promiseWarn} = __webpack_require__(181);
	const {parseDeclarations} = __webpack_require__(182);
	const Services = __webpack_require__(1);

	const STYLE_INSPECTOR_PROPERTIES = "devtools-shared/locale/styleinspector.properties";
	const {LocalizationHelper} = __webpack_require__(56);
	const STYLE_INSPECTOR_L10N = new LocalizationHelper(STYLE_INSPECTOR_PROPERTIES);

	/**
	 * Rule is responsible for the following:
	 *   Manages a single style declaration or rule.
	 *   Applies changes to the properties in a rule.
	 *   Maintains a list of TextProperty objects.
	 *
	 * @param {ElementStyle} elementStyle
	 *        The ElementStyle to which this rule belongs.
	 * @param {Object} options
	 *        The information used to construct this rule.  Properties include:
	 *          rule: A StyleRuleActor
	 *          inherited: An element this rule was inherited from.  If omitted,
	 *            the rule applies directly to the current element.
	 *          isSystem: Is this a user agent style?
	 *          isUnmatched: True if the rule does not match the current selected
	 *            element, otherwise, false.
	 */
	function Rule(elementStyle, options) {
	  this.elementStyle = elementStyle;
	  this.domRule = options.rule || null;
	  this.style = options.rule;
	  this.matchedSelectors = options.matchedSelectors || [];
	  this.pseudoElement = options.pseudoElement || "";

	  this.isSystem = options.isSystem;
	  this.isUnmatched = options.isUnmatched || false;
	  this.inherited = options.inherited || null;
	  this.keyframes = options.keyframes || null;
	  this._modificationDepth = 0;

	  if (this.domRule && this.domRule.mediaText) {
	    this.mediaText = this.domRule.mediaText;
	  }

	  this.cssProperties = this.elementStyle.ruleView.cssProperties;

	  // Populate the text properties with the style's current authoredText
	  // value, and add in any disabled properties from the store.
	  this.textProps = this._getTextProperties();
	  this.textProps = this.textProps.concat(this._getDisabledProperties());
	}

	Rule.prototype = {
	  mediaText: "",

	  get title() {
	    let title = CssLogic.shortSource(this.sheet);
	    if (this.domRule.type !== ELEMENT_STYLE && this.ruleLine > 0) {
	      title += ":" + this.ruleLine;
	    }

	    return title + (this.mediaText ? " @media " + this.mediaText : "");
	  },

	  get inheritedSource() {
	    if (this._inheritedSource) {
	      return this._inheritedSource;
	    }
	    this._inheritedSource = "";
	    if (this.inherited) {
	      let eltText = this.inherited.displayName;
	      if (this.inherited.id) {
	        eltText += "#" + this.inherited.id;
	      }
	      this._inheritedSource =
	        STYLE_INSPECTOR_L10N.getFormatStr("rule.inheritedFrom", eltText);
	    }
	    return this._inheritedSource;
	  },

	  get keyframesName() {
	    if (this._keyframesName) {
	      return this._keyframesName;
	    }
	    this._keyframesName = "";
	    if (this.keyframes) {
	      this._keyframesName =
	        STYLE_INSPECTOR_L10N.getFormatStr("rule.keyframe", this.keyframes.name);
	    }
	    return this._keyframesName;
	  },

	  get selectorText() {
	    return this.domRule.selectors ? this.domRule.selectors.join(", ") :
	      CssLogic.l10n("rule.sourceElement");
	  },

	  /**
	   * The rule's stylesheet.
	   */
	  get sheet() {
	    return this.domRule ? this.domRule.parentStyleSheet : null;
	  },

	  /**
	   * The rule's line within a stylesheet
	   */
	  get ruleLine() {
	    return this.domRule ? this.domRule.line : "";
	  },

	  /**
	   * The rule's column within a stylesheet
	   */
	  get ruleColumn() {
	    return this.domRule ? this.domRule.column : null;
	  },

	  /**
	   * Get display name for this rule based on the original source
	   * for this rule's style sheet.
	   *
	   * @return {Promise}
	   *         Promise which resolves with location as an object containing
	   *         both the full and short version of the source string.
	   */
	  getOriginalSourceStrings: function () {
	    return this.domRule.getOriginalLocation().then(({href,
	                                                     line, mediaText}) => {
	      let mediaString = mediaText ? " @" + mediaText : "";
	      let linePart = line > 0 ? (":" + line) : "";

	      let sourceStrings = {
	        full: (href || CssLogic.l10n("rule.sourceInline")) + linePart +
	          mediaString,
	        short: CssLogic.shortSource({href: href}) + linePart + mediaString
	      };

	      return sourceStrings;
	    });
	  },

	  /**
	   * Returns true if the rule matches the creation options
	   * specified.
	   *
	   * @param {Object} options
	   *        Creation options. See the Rule constructor for documentation.
	   */
	  matches: function (options) {
	    return this.style === options.rule;
	  },

	  /**
	   * Create a new TextProperty to include in the rule.
	   *
	   * @param {String} name
	   *        The text property name (such as "background" or "border-top").
	   * @param {String} value
	   *        The property's value (not including priority).
	   * @param {String} priority
	   *        The property's priority (either "important" or an empty string).
	   * @param {Boolean} enabled
	   *        True if the property should be enabled.
	   * @param {TextProperty} siblingProp
	   *        Optional, property next to which the new property will be added.
	   */
	  createProperty: function (name, value, priority, enabled, siblingProp) {
	    let prop = new TextProperty(this, name, value, priority, enabled);

	    let ind;
	    if (siblingProp) {
	      ind = this.textProps.indexOf(siblingProp) + 1;
	      this.textProps.splice(ind, 0, prop);
	    } else {
	      ind = this.textProps.length;
	      this.textProps.push(prop);
	    }

	    this.applyProperties((modifications) => {
	      modifications.createProperty(ind, name, value, priority);
	      // Now that the rule has been updated, the server might have given us data
	      // that changes the state of the property. Update it now.
	      prop.updateEditor();
	    });

	    return prop;
	  },

	  /**
	   * Helper function for applyProperties that is called when the actor
	   * does not support as-authored styles.  Store disabled properties
	   * in the element style's store.
	   */
	  _applyPropertiesNoAuthored: function (modifications) {
	    this.elementStyle.markOverriddenAll();

	    let disabledProps = [];

	    for (let prop of this.textProps) {
	      if (prop.invisible) {
	        continue;
	      }
	      if (!prop.enabled) {
	        disabledProps.push({
	          name: prop.name,
	          value: prop.value,
	          priority: prop.priority
	        });
	        continue;
	      }
	      if (prop.value.trim() === "") {
	        continue;
	      }

	      modifications.setProperty(-1, prop.name, prop.value, prop.priority);

	      prop.updateComputed();
	    }

	    // Store disabled properties in the disabled store.
	    let disabled = this.elementStyle.store.disabled;
	    if (disabledProps.length > 0) {
	      disabled.set(this.style, disabledProps);
	    } else {
	      disabled.delete(this.style);
	    }

	    return modifications.apply().then(() => {
	      let cssProps = {};
	      // Note that even though StyleRuleActors normally provide parsed
	      // declarations already, _applyPropertiesNoAuthored is only used when
	      // connected to older backend that do not provide them. So parse here.
	      for (let cssProp of parseDeclarations(this.cssProperties.isKnown,
	                                            this.style.authoredText)) {
	        cssProps[cssProp.name] = cssProp;
	      }

	      for (let textProp of this.textProps) {
	        if (!textProp.enabled) {
	          continue;
	        }
	        let cssProp = cssProps[textProp.name];

	        if (!cssProp) {
	          cssProp = {
	            name: textProp.name,
	            value: "",
	            priority: ""
	          };
	        }

	        textProp.priority = cssProp.priority;
	      }
	    });
	  },

	  /**
	   * A helper for applyProperties that applies properties in the "as
	   * authored" case; that is, when the StyleRuleActor supports
	   * setRuleText.
	   */
	  _applyPropertiesAuthored: function (modifications) {
	    return modifications.apply().then(() => {
	      // The rewriting may have required some other property values to
	      // change, e.g., to insert some needed terminators.  Update the
	      // relevant properties here.
	      for (let index in modifications.changedDeclarations) {
	        let newValue = modifications.changedDeclarations[index];
	        this.textProps[index].noticeNewValue(newValue);
	      }
	      // Recompute and redisplay the computed properties.
	      for (let prop of this.textProps) {
	        if (!prop.invisible && prop.enabled) {
	          prop.updateComputed();
	          prop.updateEditor();
	        }
	      }
	    });
	  },

	  /**
	   * Reapply all the properties in this rule, and update their
	   * computed styles.  Will re-mark overridden properties.  Sets the
	   * |_applyingModifications| property to a promise which will resolve
	   * when the edit has completed.
	   *
	   * @param {Function} modifier a function that takes a RuleModificationList
	   *        (or RuleRewriter) as an argument and that modifies it
	   *        to apply the desired edit
	   * @return {Promise} a promise which will resolve when the edit
	   *        is complete
	   */
	  applyProperties: function (modifier) {
	    // If there is already a pending modification, we have to wait
	    // until it settles before applying the next modification.
	    let resultPromise =
	        promise.resolve(this._applyingModifications).then(() => {
	          let modifications = this.style.startModifyingProperties(
	            this.cssProperties);
	          modifier(modifications);
	          if (this.style.canSetRuleText) {
	            return this._applyPropertiesAuthored(modifications);
	          }
	          return this._applyPropertiesNoAuthored(modifications);
	        }).then(() => {
	          this.elementStyle.markOverriddenAll();

	          if (resultPromise === this._applyingModifications) {
	            this._applyingModifications = null;
	            this.elementStyle._changed();
	          }
	        }).catch(promiseWarn);

	    this._applyingModifications = resultPromise;
	    return resultPromise;
	  },

	  /**
	   * Renames a property.
	   *
	   * @param {TextProperty} property
	   *        The property to rename.
	   * @param {String} name
	   *        The new property name (such as "background" or "border-top").
	   */
	  setPropertyName: function (property, name) {
	    if (name === property.name) {
	      return;
	    }

	    let oldName = property.name;
	    property.name = name;
	    let index = this.textProps.indexOf(property);
	    this.applyProperties((modifications) => {
	      modifications.renameProperty(index, oldName, name);
	    });
	  },

	  /**
	   * Sets the value and priority of a property, then reapply all properties.
	   *
	   * @param {TextProperty} property
	   *        The property to manipulate.
	   * @param {String} value
	   *        The property's value (not including priority).
	   * @param {String} priority
	   *        The property's priority (either "important" or an empty string).
	   */
	  setPropertyValue: function (property, value, priority) {
	    if (value === property.value && priority === property.priority) {
	      return;
	    }

	    property.value = value;
	    property.priority = priority;

	    let index = this.textProps.indexOf(property);
	    this.applyProperties((modifications) => {
	      modifications.setProperty(index, property.name, value, priority);
	    });
	  },

	  /**
	   * Just sets the value and priority of a property, in order to preview its
	   * effect on the content document.
	   *
	   * @param {TextProperty} property
	   *        The property which value will be previewed
	   * @param {String} value
	   *        The value to be used for the preview
	   * @param {String} priority
	   *        The property's priority (either "important" or an empty string).
	   */
	  previewPropertyValue: function (property, value, priority) {
	    let modifications = this.style.startModifyingProperties(this.cssProperties);
	    modifications.setProperty(this.textProps.indexOf(property),
	                              property.name, value, priority);
	    modifications.apply().then(() => {
	      // Ensure dispatching a ruleview-changed event
	      // also for previews
	      this.elementStyle._changed();
	    });
	  },

	  /**
	   * Disables or enables given TextProperty.
	   *
	   * @param {TextProperty} property
	   *        The property to enable/disable
	   * @param {Boolean} value
	   */
	  setPropertyEnabled: function (property, value) {
	    if (property.enabled === !!value) {
	      return;
	    }
	    property.enabled = !!value;
	    let index = this.textProps.indexOf(property);
	    this.applyProperties((modifications) => {
	      modifications.setPropertyEnabled(index, property.name, property.enabled);
	    });
	  },

	  /**
	   * Remove a given TextProperty from the rule and update the rule
	   * accordingly.
	   *
	   * @param {TextProperty} property
	   *        The property to be removed
	   */
	  removeProperty: function (property) {
	    let index = this.textProps.indexOf(property);
	    this.textProps.splice(index, 1);
	    // Need to re-apply properties in case removing this TextProperty
	    // exposes another one.
	    this.applyProperties((modifications) => {
	      modifications.removeProperty(index, property.name);
	    });
	  },

	  /**
	   * Get the list of TextProperties from the style. Needs
	   * to parse the style's authoredText.
	   */
	  _getTextProperties: function () {
	    let textProps = [];
	    let store = this.elementStyle.store;

	    // Starting with FF49, StyleRuleActors provide parsed declarations.
	    let props = this.style.declarations;
	    if (!props.length) {
	      props = parseDeclarations(this.cssProperties.isKnown,
	                                this.style.authoredText, true);
	    }

	    for (let prop of props) {
	      let name = prop.name;
	      // If the authored text has an invalid property, it will show up
	      // as nameless.  Skip these as we don't currently have a good
	      // way to display them.
	      if (!name) {
	        continue;
	      }
	      // In an inherited rule, we only show inherited properties.
	      // However, we must keep all properties in order for rule
	      // rewriting to work properly.  So, compute the "invisible"
	      // property here.
	      let invisible = this.inherited && !this.cssProperties.isInherited(name);
	      let value = store.userProperties.getProperty(this.style, name,
	                                                   prop.value);
	      let textProp = new TextProperty(this, name, value, prop.priority,
	                                      !("commentOffsets" in prop),
	                                      invisible);
	      textProps.push(textProp);
	    }

	    return textProps;
	  },

	  /**
	   * Return the list of disabled properties from the store for this rule.
	   */
	  _getDisabledProperties: function () {
	    let store = this.elementStyle.store;

	    // Include properties from the disabled property store, if any.
	    let disabledProps = store.disabled.get(this.style);
	    if (!disabledProps) {
	      return [];
	    }

	    let textProps = [];

	    for (let prop of disabledProps) {
	      let value = store.userProperties.getProperty(this.style, prop.name,
	                                                   prop.value);
	      let textProp = new TextProperty(this, prop.name, value, prop.priority);
	      textProp.enabled = false;
	      textProps.push(textProp);
	    }

	    return textProps;
	  },

	  /**
	   * Reread the current state of the rules and rebuild text
	   * properties as needed.
	   */
	  refresh: function (options) {
	    this.matchedSelectors = options.matchedSelectors || [];
	    let newTextProps = this._getTextProperties();

	    // Update current properties for each property present on the style.
	    // This will mark any touched properties with _visited so we
	    // can detect properties that weren't touched (because they were
	    // removed from the style).
	    // Also keep track of properties that didn't exist in the current set
	    // of properties.
	    let brandNewProps = [];
	    for (let newProp of newTextProps) {
	      if (!this._updateTextProperty(newProp)) {
	        brandNewProps.push(newProp);
	      }
	    }

	    // Refresh editors and disabled state for all the properties that
	    // were updated.
	    for (let prop of this.textProps) {
	      // Properties that weren't touched during the update
	      // process must no longer exist on the node.  Mark them disabled.
	      if (!prop._visited) {
	        prop.enabled = false;
	        prop.updateEditor();
	      } else {
	        delete prop._visited;
	      }
	    }

	    // Add brand new properties.
	    this.textProps = this.textProps.concat(brandNewProps);

	    // Refresh the editor if one already exists.
	    if (this.editor) {
	      this.editor.populate();
	    }
	  },

	  /**
	   * Update the current TextProperties that match a given property
	   * from the authoredText.  Will choose one existing TextProperty to update
	   * with the new property's value, and will disable all others.
	   *
	   * When choosing the best match to reuse, properties will be chosen
	   * by assigning a rank and choosing the highest-ranked property:
	   *   Name, value, and priority match, enabled. (6)
	   *   Name, value, and priority match, disabled. (5)
	   *   Name and value match, enabled. (4)
	   *   Name and value match, disabled. (3)
	   *   Name matches, enabled. (2)
	   *   Name matches, disabled. (1)
	   *
	   * If no existing properties match the property, nothing happens.
	   *
	   * @param {TextProperty} newProp
	   *        The current version of the property, as parsed from the
	   *        authoredText in Rule._getTextProperties().
	   * @return {Boolean} true if a property was updated, false if no properties
	   *         were updated.
	   */
	  _updateTextProperty: function (newProp) {
	    let match = { rank: 0, prop: null };

	    for (let prop of this.textProps) {
	      if (prop.name !== newProp.name) {
	        continue;
	      }

	      // Mark this property visited.
	      prop._visited = true;

	      // Start at rank 1 for matching name.
	      let rank = 1;

	      // Value and Priority matches add 2 to the rank.
	      // Being enabled adds 1.  This ranks better matches higher,
	      // with priority breaking ties.
	      if (prop.value === newProp.value) {
	        rank += 2;
	        if (prop.priority === newProp.priority) {
	          rank += 2;
	        }
	      }

	      if (prop.enabled) {
	        rank += 1;
	      }

	      if (rank > match.rank) {
	        if (match.prop) {
	          // We outrank a previous match, disable it.
	          match.prop.enabled = false;
	          match.prop.updateEditor();
	        }
	        match.rank = rank;
	        match.prop = prop;
	      } else if (rank) {
	        // A previous match outranks us, disable ourself.
	        prop.enabled = false;
	        prop.updateEditor();
	      }
	    }

	    // If we found a match, update its value with the new text property
	    // value.
	    if (match.prop) {
	      match.prop.set(newProp);
	      return true;
	    }

	    return false;
	  },

	  /**
	   * Jump between editable properties in the UI. If the focus direction is
	   * forward, begin editing the next property name if available or focus the
	   * new property editor otherwise. If the focus direction is backward,
	   * begin editing the previous property value or focus the selector editor if
	   * this is the first element in the property list.
	   *
	   * @param {TextProperty} textProperty
	   *        The text property that will be left to focus on a sibling.
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  editClosestTextProperty: function (textProperty, direction) {
	    let index = this.textProps.indexOf(textProperty);

	    if (direction === Services.focus.MOVEFOCUS_FORWARD) {
	      for (++index; index < this.textProps.length; ++index) {
	        if (!this.textProps[index].invisible) {
	          break;
	        }
	      }
	      if (index === this.textProps.length) {
	        textProperty.rule.editor.closeBrace.click();
	      } else {
	        this.textProps[index].editor.nameSpan.click();
	      }
	    } else if (direction === Services.focus.MOVEFOCUS_BACKWARD) {
	      for (--index; index >= 0; --index) {
	        if (!this.textProps[index].invisible) {
	          break;
	        }
	      }
	      if (index < 0) {
	        textProperty.editor.ruleEditor.selectorText.click();
	      } else {
	        this.textProps[index].editor.valueSpan.click();
	      }
	    }
	  },

	  /**
	   * Return a string representation of the rule.
	   */
	  stringifyRule: function () {
	    let selectorText = this.selectorText;
	    let cssText = "";
	    let terminator = Services.appinfo.OS === "WINNT" ? "\r\n" : "\n";

	    for (let textProp of this.textProps) {
	      if (!textProp.invisible) {
	        cssText += "\t" + textProp.stringifyProperty() + terminator;
	      }
	    }

	    return selectorText + " {" + terminator + cssText + "}";
	  },

	  /**
	   * See whether this rule has any non-invisible properties.
	   * @return {Boolean} true if there is any visible property, or false
	   *         if all properties are invisible
	   */
	  hasAnyVisibleProperties: function () {
	    for (let prop of this.textProps) {
	      if (!prop.invisible) {
	        return true;
	      }
	    }
	    return false;
	  }
	};

	exports.Rule = Rule;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* eslint-disable mozilla/reject-some-requires */
	const {Cc, Ci} = __webpack_require__(9);
	/* eslint-enable mozilla/reject-some-requires */
	const {escapeCSSComment} = __webpack_require__(182);
	const {getCssProperties} = __webpack_require__(16);
	/* eslint-disable mozilla/reject-some-requires */
	const {XPCOMUtils} = __webpack_require__(9);
	/* eslint-enable mozilla/reject-some-requires */

	XPCOMUtils.defineLazyGetter(this, "domUtils", function () {
	  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
	});

	/**
	 * TextProperty is responsible for the following:
	 *   Manages a single property from the authoredText attribute of the
	 *     relevant declaration.
	 *   Maintains a list of computed properties that come from this
	 *     property declaration.
	 *   Changes to the TextProperty are sent to its related Rule for
	 *     application.
	 *
	 * @param {Rule} rule
	 *        The rule this TextProperty came from.
	 * @param {String} name
	 *        The text property name (such as "background" or "border-top").
	 * @param {String} value
	 *        The property's value (not including priority).
	 * @param {String} priority
	 *        The property's priority (either "important" or an empty string).
	 * @param {Boolean} enabled
	 *        Whether the property is enabled.
	 * @param {Boolean} invisible
	 *        Whether the property is invisible.  An invisible property
	 *        does not show up in the UI; these are needed so that the
	 *        index of a property in Rule.textProps is the same as the index
	 *        coming from parseDeclarations.
	 */
	function TextProperty(rule, name, value, priority, enabled = true,
	                      invisible = false) {
	  this.rule = rule;
	  this.name = name;
	  this.value = value;
	  this.priority = priority;
	  this.enabled = !!enabled;
	  this.invisible = invisible;
	  this.updateComputed();

	  const toolbox = this.rule.elementStyle.ruleView.inspector.toolbox;
	  this.cssProperties = getCssProperties(toolbox);
	}

	TextProperty.prototype = {
	  /**
	   * Update the editor associated with this text property,
	   * if any.
	   */
	  updateEditor: function () {
	    if (this.editor) {
	      this.editor.update();
	    }
	  },

	  /**
	   * Update the list of computed properties for this text property.
	   */
	  updateComputed: function () {
	    if (!this.name) {
	      return;
	    }

	    // This is a bit funky.  To get the list of computed properties
	    // for this text property, we'll set the property on a dummy element
	    // and see what the computed style looks like.
	    let dummyElement = this.rule.elementStyle.ruleView.dummyElement;
	    let dummyStyle = dummyElement.style;
	    dummyStyle.cssText = "";
	    dummyStyle.setProperty(this.name, this.value, this.priority);

	    this.computed = [];

	    try {
	      // Manually get all the properties that are set when setting a value on
	      // this.name and check the computed style on dummyElement for each one.
	      // If we just read dummyStyle, it would skip properties when value === "".
	      let subProps = domUtils.getSubpropertiesForCSSProperty(this.name);

	      for (let prop of subProps) {
	        this.computed.push({
	          textProp: this,
	          name: prop,
	          value: dummyStyle.getPropertyValue(prop),
	          priority: dummyStyle.getPropertyPriority(prop),
	        });
	      }
	    } catch (e) {
	      // This is a partial property name, probably from cutting and pasting
	      // text. At this point don't check for computed properties.
	    }
	  },

	  /**
	   * Set all the values from another TextProperty instance into
	   * this TextProperty instance.
	   *
	   * @param {TextProperty} prop
	   *        The other TextProperty instance.
	   */
	  set: function (prop) {
	    let changed = false;
	    for (let item of ["name", "value", "priority", "enabled"]) {
	      if (this[item] !== prop[item]) {
	        this[item] = prop[item];
	        changed = true;
	      }
	    }

	    if (changed) {
	      this.updateEditor();
	    }
	  },

	  setValue: function (value, priority, force = false) {
	    let store = this.rule.elementStyle.store;

	    if (this.editor && value !== this.editor.committed.value || force) {
	      store.userProperties.setProperty(this.rule.style, this.name, value);
	    }

	    this.rule.setPropertyValue(this, value, priority);
	    this.updateEditor();
	  },

	  /**
	   * Called when the property's value has been updated externally, and
	   * the property and editor should update.
	   */
	  noticeNewValue: function (value) {
	    if (value !== this.value) {
	      this.value = value;
	      this.updateEditor();
	    }
	  },

	  setName: function (name) {
	    let store = this.rule.elementStyle.store;

	    if (name !== this.name) {
	      store.userProperties.setProperty(this.rule.style, name,
	                                       this.editor.committed.value);
	    }

	    this.rule.setPropertyName(this, name);
	    this.updateEditor();
	  },

	  setEnabled: function (value) {
	    this.rule.setPropertyEnabled(this, value);
	    this.updateEditor();
	  },

	  remove: function () {
	    this.rule.removeProperty(this);
	  },

	  /**
	   * Return a string representation of the rule property.
	   */
	  stringifyProperty: function () {
	    // Get the displayed property value
	    let declaration = this.name + ": " + this.editor.valueSpan.textContent +
	      ";";

	    // Comment out property declarations that are not enabled
	    if (!this.enabled) {
	      declaration = "/* " + escapeCSSComment(declaration) + " */";
	    }

	    return declaration;
	  },

	  /**
	   * See whether this property's name is known.
	   *
	   * @return {Boolean} true if the property name is known, false otherwise.
	   */
	  isKnownProperty: function () {
	    return this.cssProperties.isKnown(this.name);
	  },

	  /**
	   * Validate this property. Does it make sense for this value to be assigned
	   * to this property name?
	   *
	   * @return {Boolean} true if the property value is valid, false otherwise.
	   */
	  isValid: function () {
	    // Starting with FF49, StyleRuleActors provide a list of parsed
	    // declarations, with data about their validity, but if we don't have this,
	    // compute validity locally (which might not be correct, but better than
	    // nothing).
	    if (!this.rule.domRule.declarations) {
	      return domUtils.cssPropertyIsValid(this.name, this.value);
	    }

	    let selfIndex = this.rule.textProps.indexOf(this);

	    // When adding a new property in the rule-view, the TextProperty object is
	    // created right away before the rule gets updated on the server, so we're
	    // not going to find the corresponding declaration object yet. Default to
	    // true.
	    if (!this.rule.domRule.declarations[selfIndex]) {
	      return true;
	    }

	    return this.rule.domRule.declarations[selfIndex].isValid;
	  }
	};

	exports.TextProperty = TextProperty;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {l10n} = __webpack_require__(173);
	const {ELEMENT_STYLE} = __webpack_require__(175);
	const {PREF_ORIG_SOURCES} = __webpack_require__(180);
	const {Rule} = __webpack_require__(200);
	const {InplaceEditor, editableField, editableItem} =
	      __webpack_require__(203);
	const {TextPropertyEditor} =
	      __webpack_require__(205);
	const {
	  createChild,
	  blurOnMultipleProperties,
	  promiseWarn
	} = __webpack_require__(181);
	const {
	  parseDeclarations,
	  parsePseudoClassesAndAttributes,
	  SELECTOR_ATTRIBUTE,
	  SELECTOR_ELEMENT,
	  SELECTOR_PSEUDO_CLASS
	} = __webpack_require__(182);
	const promise = __webpack_require__(4);
	const Services = __webpack_require__(1);
	const EventEmitter = __webpack_require__(6);

	const STYLE_INSPECTOR_PROPERTIES = "devtools-shared/locale/styleinspector.properties";
	const {LocalizationHelper} = __webpack_require__(56);
	const STYLE_INSPECTOR_L10N = new LocalizationHelper(STYLE_INSPECTOR_PROPERTIES);

	const HTML_NS = "http://www.w3.org/1999/xhtml";
	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";

	/**
	 * RuleEditor is responsible for the following:
	 *   Owns a Rule object and creates a list of TextPropertyEditors
	 *     for its TextProperties.
	 *   Manages creation of new text properties.
	 *
	 * One step of a RuleEditor's instantiation is figuring out what's the original
	 * source link to the parent stylesheet (in case of source maps). This step is
	 * asynchronous and is triggered as soon as the RuleEditor is instantiated (see
	 * updateSourceLink). If you need to know when the RuleEditor is done with this,
	 * you need to listen to the source-link-updated event.
	 *
	 * @param {CssRuleView} ruleView
	 *        The CssRuleView containg the document holding this rule editor.
	 * @param {Rule} rule
	 *        The Rule object we're editing.
	 */
	function RuleEditor(ruleView, rule) {
	  EventEmitter.decorate(this);

	  this.ruleView = ruleView;
	  this.doc = this.ruleView.styleDocument;
	  this.toolbox = this.ruleView.inspector.toolbox;
	  this.rule = rule;

	  this.isEditable = !rule.isSystem;
	  // Flag that blocks updates of the selector and properties when it is
	  // being edited
	  this.isEditing = false;

	  this._onNewProperty = this._onNewProperty.bind(this);
	  this._newPropertyDestroy = this._newPropertyDestroy.bind(this);
	  this._onSelectorDone = this._onSelectorDone.bind(this);
	  this._locationChanged = this._locationChanged.bind(this);
	  this.updateSourceLink = this.updateSourceLink.bind(this);

	  this.rule.domRule.on("location-changed", this._locationChanged);
	  this.toolbox.on("tool-registered", this.updateSourceLink);
	  this.toolbox.on("tool-unregistered", this.updateSourceLink);

	  this._create();
	}

	RuleEditor.prototype = {
	  destroy: function () {
	    this.rule.domRule.off("location-changed");
	    this.toolbox.off("tool-registered", this.updateSourceLink);
	    this.toolbox.off("tool-unregistered", this.updateSourceLink);
	  },

	  get isSelectorEditable() {
	    let trait = this.isEditable &&
	      this.toolbox.target.client.traits.selectorEditable &&
	      this.rule.domRule.type !== ELEMENT_STYLE &&
	      this.rule.domRule.type !== CSSRule.KEYFRAME_RULE;

	    // Do not allow editing anonymousselectors until we can
	    // detect mutations on  pseudo elements in Bug 1034110.
	    return trait && !this.rule.elementStyle.element.isAnonymous;
	  },

	  _create: function () {
	    this.element = this.doc.createElementNS(HTML_NS, "div");
	    this.element.className = "ruleview-rule theme-separator";
	    this.element.setAttribute("uneditable", !this.isEditable);
	    this.element.setAttribute("unmatched", this.rule.isUnmatched);
	    this.element._ruleEditor = this;

	    // Give a relative position for the inplace editor's measurement
	    // span to be placed absolutely against.
	    this.element.style.position = "relative";

	    // Add the source link.
	    this.source = createChild(this.element, "div", {
	      class: "ruleview-rule-source theme-link"
	    });
	    this.source.addEventListener("click", function () {
	      if (this.source.hasAttribute("unselectable")) {
	        return;
	      }
	      let rule = this.rule.domRule;
	      this.ruleView.emit("ruleview-linked-clicked", rule);
	    }.bind(this));
	    let sourceLabel = this.doc.createElementNS(XUL_NS, "label");
	    sourceLabel.setAttribute("crop", "center");
	    sourceLabel.classList.add("ruleview-rule-source-label");
	    this.source.appendChild(sourceLabel);

	    this.updateSourceLink();

	    let code = createChild(this.element, "div", {
	      class: "ruleview-code"
	    });

	    let header = createChild(code, "div", {});

	    this.selectorText = createChild(header, "span", {
	      class: "ruleview-selectorcontainer theme-fg-color3",
	      tabindex: this.isSelectorEditable ? "0" : "-1",
	    });

	    if (this.isSelectorEditable) {
	      this.selectorText.addEventListener("click", event => {
	        // Clicks within the selector shouldn't propagate any further.
	        event.stopPropagation();
	      }, false);

	      editableField({
	        element: this.selectorText,
	        done: this._onSelectorDone,
	        cssProperties: this.rule.cssProperties
	      });
	    }

	    if (this.rule.domRule.type !== CSSRule.KEYFRAME_RULE &&
	        this.rule.domRule.selectors) {
	      let selector = this.rule.domRule.selectors.join(", ");

	      let selectorHighlighter = createChild(header, "span", {
	        class: "ruleview-selectorhighlighter" +
	               (this.ruleView.highlightedSelector === selector ?
	                " highlighted" : ""),
	        title: l10n("rule.selectorHighlighter.tooltip")
	      });
	      selectorHighlighter.addEventListener("click", () => {
	        this.ruleView.toggleSelectorHighlighter(selectorHighlighter, selector);
	      });
	    }

	    this.openBrace = createChild(header, "span", {
	      class: "ruleview-ruleopen",
	      textContent: " {"
	    });

	    this.propertyList = createChild(code, "ul", {
	      class: "ruleview-propertylist"
	    });

	    this.populate();

	    this.closeBrace = createChild(code, "div", {
	      class: "ruleview-ruleclose",
	      tabindex: this.isEditable ? "0" : "-1",
	      textContent: "}"
	    });

	    if (this.isEditable) {
	      // A newProperty editor should only be created when no editor was
	      // previously displayed. Since the editors are cleared on blur,
	      // check this.ruleview.isEditing on mousedown
	      this._ruleViewIsEditing = false;

	      code.addEventListener("mousedown", () => {
	        this._ruleViewIsEditing = this.ruleView.isEditing;
	      });

	      code.addEventListener("click", () => {
	        let selection = this.doc.defaultView.getSelection();
	        if (selection.isCollapsed && !this._ruleViewIsEditing) {
	          this.newProperty();
	        }
	        // Cleanup the _ruleViewIsEditing flag
	        this._ruleViewIsEditing = false;
	      }, false);

	      this.element.addEventListener("mousedown", () => {
	        this.doc.defaultView.focus();
	      }, false);

	      // Create a property editor when the close brace is clicked.
	      editableItem({ element: this.closeBrace }, () => {
	        this.newProperty();
	      });
	    }
	  },

	  /**
	   * Event handler called when a property changes on the
	   * StyleRuleActor.
	   */
	  _locationChanged: function () {
	    this.updateSourceLink();
	  },

	  updateSourceLink: function () {
	    let sourceLabel = this.element.querySelector(".ruleview-rule-source-label");
	    let title = this.rule.title;
	    let sourceHref = (this.rule.sheet && this.rule.sheet.href) ?
	      this.rule.sheet.href : title;
	    let sourceLine = this.rule.ruleLine > 0 ? ":" + this.rule.ruleLine : "";

	    sourceLabel.setAttribute("tooltiptext", sourceHref + sourceLine);

	    if (this.toolbox.isToolRegistered("styleeditor")) {
	      this.source.removeAttribute("unselectable");
	    } else {
	      this.source.setAttribute("unselectable", true);
	    }

	    if (this.rule.isSystem) {
	      let uaLabel = STYLE_INSPECTOR_L10N.getStr("rule.userAgentStyles");
	      sourceLabel.setAttribute("value", uaLabel + " " + title);

	      // Special case about:PreferenceStyleSheet, as it is generated on the
	      // fly and the URI is not registered with the about: handler.
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=935803#c37
	      if (sourceHref === "about:PreferenceStyleSheet") {
	        this.source.setAttribute("unselectable", "true");
	        sourceLabel.setAttribute("value", uaLabel);
	        sourceLabel.removeAttribute("tooltiptext");
	      }
	    } else {
	      sourceLabel.setAttribute("value", title);
	      if (this.rule.ruleLine === -1 && this.rule.domRule.parentStyleSheet) {
	        this.source.setAttribute("unselectable", "true");
	      }
	    }

	    let showOrig = Services.prefs.getBoolPref(PREF_ORIG_SOURCES);
	    if (showOrig && !this.rule.isSystem &&
	        this.rule.domRule.type !== ELEMENT_STYLE) {
	      // Only get the original source link if the right pref is set, if the rule
	      // isn't a system rule and if it isn't an inline rule.
	      this.rule.getOriginalSourceStrings().then((strings) => {
	        sourceLabel.setAttribute("value", strings.short);
	        sourceLabel.setAttribute("tooltiptext", strings.full);
	      }, e => console.error(e)).then(() => {
	        this.emit("source-link-updated");
	      });
	    } else {
	      // If we're not getting the original source link, then we can emit the
	      // event immediately (but still asynchronously to give consumers a chance
	      // to register it after having instantiated the RuleEditor).
	      promise.resolve().then(() => {
	        this.emit("source-link-updated");
	      });
	    }
	  },

	  /**
	   * Update the rule editor with the contents of the rule.
	   */
	  populate: function () {
	    // Clear out existing viewers.
	    while (this.selectorText.hasChildNodes()) {
	      this.selectorText.removeChild(this.selectorText.lastChild);
	    }

	    // If selector text comes from a css rule, highlight selectors that
	    // actually match.  For custom selector text (such as for the 'element'
	    // style, just show the text directly.
	    if (this.rule.domRule.type === ELEMENT_STYLE) {
	      this.selectorText.textContent = this.rule.selectorText;
	    } else if (this.rule.domRule.type === CSSRule.KEYFRAME_RULE) {
	      this.selectorText.textContent = this.rule.domRule.keyText;
	    } else {
	      this.rule.domRule.selectors.forEach((selector, i) => {
	        if (i !== 0) {
	          createChild(this.selectorText, "span", {
	            class: "ruleview-selector-separator",
	            textContent: ", "
	          });
	        }

	        let containerClass =
	          (this.rule.matchedSelectors.indexOf(selector) > -1) ?
	          "ruleview-selector-matched" : "ruleview-selector-unmatched";
	        let selectorContainer = createChild(this.selectorText, "span", {
	          class: containerClass
	        });

	        let parsedSelector = parsePseudoClassesAndAttributes(selector);

	        for (let selectorText of parsedSelector) {
	          let selectorClass = "";

	          switch (selectorText.type) {
	            case SELECTOR_ATTRIBUTE:
	              selectorClass = "ruleview-selector-attribute";
	              break;
	            case SELECTOR_ELEMENT:
	              selectorClass = "ruleview-selector";
	              break;
	            case SELECTOR_PSEUDO_CLASS:
	              selectorClass = [":active", ":focus", ":hover"].some(
	                  pseudo => selectorText.value === pseudo) ?
	                "ruleview-selector-pseudo-class-lock" :
	                "ruleview-selector-pseudo-class";
	              break;
	            default:
	              break;
	          }

	          createChild(selectorContainer, "span", {
	            textContent: selectorText.value,
	            class: selectorClass
	          });
	        }
	      });
	    }

	    for (let prop of this.rule.textProps) {
	      if (!prop.editor && !prop.invisible) {
	        let editor = new TextPropertyEditor(this, prop);
	        this.propertyList.appendChild(editor.element);
	      }
	    }
	  },

	  /**
	   * Programatically add a new property to the rule.
	   *
	   * @param {String} name
	   *        Property name.
	   * @param {String} value
	   *        Property value.
	   * @param {String} priority
	   *        Property priority.
	   * @param {Boolean} enabled
	   *        True if the property should be enabled.
	   * @param {TextProperty} siblingProp
	   *        Optional, property next to which the new property will be added.
	   * @return {TextProperty}
	   *        The new property
	   */
	  addProperty: function (name, value, priority, enabled, siblingProp) {
	    let prop = this.rule.createProperty(name, value, priority, enabled,
	      siblingProp);
	    let index = this.rule.textProps.indexOf(prop);
	    let editor = new TextPropertyEditor(this, prop);

	    // Insert this node before the DOM node that is currently at its new index
	    // in the property list.  There is currently one less node in the DOM than
	    // in the property list, so this causes it to appear after siblingProp.
	    // If there is no node at its index, as is the case where this is the last
	    // node being inserted, then this behaves as appendChild.
	    this.propertyList.insertBefore(editor.element,
	      this.propertyList.children[index]);

	    return prop;
	  },

	  /**
	   * Programatically add a list of new properties to the rule.  Focus the UI
	   * to the proper location after adding (either focus the value on the
	   * last property if it is empty, or create a new property and focus it).
	   *
	   * @param {Array} properties
	   *        Array of properties, which are objects with this signature:
	   *        {
	   *          name: {string},
	   *          value: {string},
	   *          priority: {string}
	   *        }
	   * @param {TextProperty} siblingProp
	   *        Optional, the property next to which all new props should be added.
	   */
	  addProperties: function (properties, siblingProp) {
	    if (!properties || !properties.length) {
	      return;
	    }

	    let lastProp = siblingProp;
	    for (let p of properties) {
	      let isCommented = Boolean(p.commentOffsets);
	      let enabled = !isCommented;
	      lastProp = this.addProperty(p.name, p.value, p.priority, enabled,
	        lastProp);
	    }

	    // Either focus on the last value if incomplete, or start a new one.
	    if (lastProp && lastProp.value.trim() === "") {
	      lastProp.editor.valueSpan.click();
	    } else {
	      this.newProperty();
	    }
	  },

	  /**
	   * Create a text input for a property name.  If a non-empty property
	   * name is given, we'll create a real TextProperty and add it to the
	   * rule.
	   */
	  newProperty: function () {
	    // If we're already creating a new property, ignore this.
	    if (!this.closeBrace.hasAttribute("tabindex")) {
	      return;
	    }

	    // While we're editing a new property, it doesn't make sense to
	    // start a second new property editor, so disable focusing the
	    // close brace for now.
	    this.closeBrace.removeAttribute("tabindex");

	    this.newPropItem = createChild(this.propertyList, "li", {
	      class: "ruleview-property ruleview-newproperty",
	    });

	    this.newPropSpan = createChild(this.newPropItem, "span", {
	      class: "ruleview-propertyname",
	      tabindex: "0"
	    });

	    this.multipleAddedProperties = null;

	    this.editor = new InplaceEditor({
	      element: this.newPropSpan,
	      done: this._onNewProperty,
	      destroy: this._newPropertyDestroy,
	      advanceChars: ":",
	      contentType: InplaceEditor.CONTENT_TYPES.CSS_PROPERTY,
	      popup: this.ruleView.popup,
	      cssProperties: this.rule.cssProperties
	    });

	    // Auto-close the input if multiple rules get pasted into new property.
	    this.editor.input.addEventListener("paste",
	      blurOnMultipleProperties(this.rule.cssProperties), false);
	  },

	  /**
	   * Called when the new property input has been dismissed.
	   *
	   * @param {String} value
	   *        The value in the editor.
	   * @param {Boolean} commit
	   *        True if the value should be committed.
	   */
	  _onNewProperty: function (value, commit) {
	    if (!value || !commit) {
	      return;
	    }

	    // parseDeclarations allows for name-less declarations, but in the present
	    // case, we're creating a new declaration, it doesn't make sense to accept
	    // these entries
	    this.multipleAddedProperties =
	      parseDeclarations(this.rule.cssProperties.isKnown, value, true)
	      .filter(d => d.name);

	    // Blur the editor field now and deal with adding declarations later when
	    // the field gets destroyed (see _newPropertyDestroy)
	    this.editor.input.blur();
	  },

	  /**
	   * Called when the new property editor is destroyed.
	   * This is where the properties (type TextProperty) are actually being
	   * added, since we want to wait until after the inplace editor `destroy`
	   * event has been fired to keep consistent UI state.
	   */
	  _newPropertyDestroy: function () {
	    // We're done, make the close brace focusable again.
	    this.closeBrace.setAttribute("tabindex", "0");

	    this.propertyList.removeChild(this.newPropItem);
	    delete this.newPropItem;
	    delete this.newPropSpan;

	    // If properties were added, we want to focus the proper element.
	    // If the last new property has no value, focus the value on it.
	    // Otherwise, start a new property and focus that field.
	    if (this.multipleAddedProperties && this.multipleAddedProperties.length) {
	      this.addProperties(this.multipleAddedProperties);
	    }
	  },

	  /**
	   * Called when the selector's inplace editor is closed.
	   * Ignores the change if the user pressed escape, otherwise
	   * commits it.
	   *
	   * @param {String} value
	   *        The value contained in the editor.
	   * @param {Boolean} commit
	   *        True if the change should be applied.
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  _onSelectorDone: function (value, commit, direction) {
	    if (!commit || this.isEditing || value === "" ||
	        value === this.rule.selectorText) {
	      return;
	    }

	    let ruleView = this.ruleView;
	    let elementStyle = ruleView._elementStyle;
	    let element = elementStyle.element;
	    let supportsUnmatchedRules =
	      this.rule.domRule.supportsModifySelectorUnmatched;

	    this.isEditing = true;

	    this.rule.domRule.modifySelector(element, value).then(response => {
	      this.isEditing = false;

	      if (!supportsUnmatchedRules) {
	        if (response) {
	          this.ruleView.refreshPanel();
	        }
	        return;
	      }

	      let {ruleProps, isMatching} = response;
	      if (!ruleProps) {
	        // Notify for changes, even when nothing changes,
	        // just to allow tests being able to track end of this request.
	        ruleView.emit("ruleview-invalid-selector");
	        return;
	      }

	      ruleProps.isUnmatched = !isMatching;
	      let newRule = new Rule(elementStyle, ruleProps);
	      let editor = new RuleEditor(ruleView, newRule);
	      let rules = elementStyle.rules;

	      rules.splice(rules.indexOf(this.rule), 1);
	      rules.push(newRule);
	      elementStyle._changed();
	      elementStyle.markOverriddenAll();

	      this.element.parentNode.replaceChild(editor.element, this.element);

	      // Remove highlight for modified selector
	      if (ruleView.highlightedSelector) {
	        ruleView.toggleSelectorHighlighter(ruleView.lastSelectorIcon,
	          ruleView.highlightedSelector);
	      }

	      editor._moveSelectorFocus(direction);
	    }).then(null, err => {
	      this.isEditing = false;
	      promiseWarn(err);
	    });
	  },

	  /**
	   * Handle moving the focus change after a tab or return keypress in the
	   * selector inplace editor.
	   *
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  _moveSelectorFocus: function (direction) {
	    if (!direction || direction === Services.focus.MOVEFOCUS_BACKWARD) {
	      return;
	    }

	    if (this.rule.textProps.length > 0) {
	      this.rule.textProps[0].editor.nameSpan.click();
	    } else {
	      this.propertyList.click();
	    }
	  }
	};

	exports.RuleEditor = RuleEditor;


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/**
	 * Basic use:
	 * let spanToEdit = document.getElementById("somespan");
	 *
	 * editableField({
	 *   element: spanToEdit,
	 *   done: function(value, commit, direction) {
	 *     if (commit) {
	 *       spanToEdit.textContent = value;
	 *     }
	 *   },
	 *   trigger: "dblclick"
	 * });
	 *
	 * See editableField() for more options.
	 */

	"use strict";

	const Services = __webpack_require__(1);
	const focusManager = Services.focus;
	const {KeyCodes} = __webpack_require__(14);

	const HTML_NS = "http://www.w3.org/1999/xhtml";
	const CONTENT_TYPES = {
	  PLAIN_TEXT: 0,
	  CSS_VALUE: 1,
	  CSS_MIXED: 2,
	  CSS_PROPERTY: 3,
	};

	// The limit of 500 autocomplete suggestions should not be reached but is kept
	// for safety.
	const MAX_POPUP_ENTRIES = 500;

	const FOCUS_FORWARD = focusManager.MOVEFOCUS_FORWARD;
	const FOCUS_BACKWARD = focusManager.MOVEFOCUS_BACKWARD;

	const EventEmitter = __webpack_require__(6);
	const { findMostRelevantCssPropertyIndex } = __webpack_require__(204);

	/**
	 * Helper to check if the provided key matches one of the expected keys.
	 * Keys will be prefixed with DOM_VK_ and should match a key in KeyCodes.
	 *
	 * @param {String} key
	 *        the key to check (can be a keyCode).
	 * @param {...String} keys
	 *        list of possible keys allowed.
	 * @return {Boolean} true if the key matches one of the keys.
	 */
	function isKeyIn(key, ...keys) {
	  return keys.some(expectedKey => {
	    return key === KeyCodes["DOM_VK_" + expectedKey];
	  });
	}

	/**
	 * Mark a span editable.  |editableField| will listen for the span to
	 * be focused and create an InlineEditor to handle text input.
	 * Changes will be committed when the InlineEditor's input is blurred
	 * or dropped when the user presses escape.
	 *
	 * @param {Object} options
	 *    Options for the editable field, including:
	 *    {Element} element:
	 *      (required) The span to be edited on focus.
	 *    {Function} canEdit:
	 *       Will be called before creating the inplace editor.  Editor
	 *       won't be created if canEdit returns false.
	 *    {Function} start:
	 *       Will be called when the inplace editor is initialized.
	 *    {Function} change:
	 *       Will be called when the text input changes.  Will be called
	 *       with the current value of the text input.
	 *    {Function} done:
	 *       Called when input is committed or blurred.  Called with
	 *       current value, a boolean telling the caller whether to
	 *       commit the change, and the direction of the next element to be
	 *       selected. Direction may be one of Services.focus.MOVEFOCUS_FORWARD,
	 *       Services.focus.MOVEFOCUS_BACKWARD, or null (no movement).
	 *       This function is called before the editor has been torn down.
	 *    {Function} destroy:
	 *       Called when the editor is destroyed and has been torn down.
	 *    {Object} advanceChars:
	 *       This can be either a string or a function.
	 *       If it is a string, then if any characters in it are typed,
	 *       focus will advance to the next element.
	 *       Otherwise, if it is a function, then the function will
	 *       be called with three arguments: a key code, the current text,
	 *       and the insertion point.  If the function returns true,
	 *       then the focus advance takes place.  If it returns false,
	 *       then the character is inserted instead.
	 *    {Boolean} stopOnReturn:
	 *       If true, the return key will not advance the editor to the next
	 *       focusable element.
	 *    {Boolean} stopOnTab:
	 *       If true, the tab key will not advance the editor to the next
	 *       focusable element.
	 *    {Boolean} stopOnShiftTab:
	 *       If true, shift tab will not advance the editor to the previous
	 *       focusable element.
	 *    {String} trigger: The DOM event that should trigger editing,
	 *      defaults to "click"
	 *    {Boolean} multiline: Should the editor be a multiline textarea?
	 *      defaults to false
	 *    {Function or Number} maxWidth:
	 *       Should the editor wrap to remain below the provided max width. Only
	 *       available if multiline is true. If a function is provided, it will be
	 *       called when replacing the element by the inplace input.
	 *    {Boolean} trimOutput: Should the returned string be trimmed?
	 *      defaults to true
	 *    {Boolean} preserveTextStyles: If true, do not copy text-related styles
	 *              from `element` to the new input.
	 *      defaults to false
	 *    {Object} cssProperties: An instance of CSSProperties.
	 */
	function editableField(options) {
	  return editableItem(options, function (element, event) {
	    if (!options.element.inplaceEditor) {
	      new InplaceEditor(options, event);
	    }
	  });
	}

	exports.editableField = editableField;

	/**
	 * Handle events for an element that should respond to
	 * clicks and sit in the editing tab order, and call
	 * a callback when it is activated.
	 *
	 * @param {Object} options
	 *    The options for this editor, including:
	 *    {Element} element: The DOM element.
	 *    {String} trigger: The DOM event that should trigger editing,
	 *      defaults to "click"
	 * @param {Function} callback
	 *        Called when the editor is activated.
	 * @return {Function} function which calls callback
	 */
	function editableItem(options, callback) {
	  let trigger = options.trigger || "click";
	  let element = options.element;
	  element.addEventListener(trigger, function (evt) {
	    if (evt.target.nodeName !== "a") {
	      let win = this.ownerDocument.defaultView;
	      let selection = win.getSelection();
	      if (trigger != "click" || selection.isCollapsed) {
	        callback(element, evt);
	      }
	      evt.stopPropagation();
	    }
	  }, false);

	  // If focused by means other than a click, start editing by
	  // pressing enter or space.
	  element.addEventListener("keypress", function (evt) {
	    if (isKeyIn(evt.keyCode, "RETURN") || isKeyIn(evt.charCode, "SPACE")) {
	      callback(element);
	    }
	  }, true);

	  // Ugly workaround - the element is focused on mousedown but
	  // the editor is activated on click/mouseup.  This leads
	  // to an ugly flash of the focus ring before showing the editor.
	  // So hide the focus ring while the mouse is down.
	  element.addEventListener("mousedown", function (evt) {
	    if (evt.target.nodeName !== "a") {
	      let cleanup = function () {
	        element.style.removeProperty("outline-style");
	        element.removeEventListener("mouseup", cleanup, false);
	        element.removeEventListener("mouseout", cleanup, false);
	      };
	      element.style.setProperty("outline-style", "none");
	      element.addEventListener("mouseup", cleanup, false);
	      element.addEventListener("mouseout", cleanup, false);
	    }
	  }, false);

	  // Mark the element editable field for tab
	  // navigation while editing.
	  element._editable = true;

	  // Save the trigger type so we can dispatch this later
	  element._trigger = trigger;

	  // Add button semantics to the element, to indicate that it can be activated.
	  element.setAttribute("role", "button");

	  return function turnOnEditMode() {
	    callback(element);
	  };
	}

	exports.editableItem = editableItem;

	/*
	 * Various API consumers (especially tests) sometimes want to grab the
	 * inplaceEditor expando off span elements. However, when each global has its
	 * own compartment, those expandos live on Xray wrappers that are only visible
	 * within this JSM. So we provide a little workaround here.
	 */

	function getInplaceEditorForSpan(span) {
	  return span.inplaceEditor;
	}

	exports.getInplaceEditorForSpan = getInplaceEditorForSpan;

	function InplaceEditor(options, event) {
	  this.elt = options.element;
	  let doc = this.elt.ownerDocument;
	  this.doc = doc;
	  this.elt.inplaceEditor = this;
	  this.cssProperties = options.cssProperties;
	  this.change = options.change;
	  this.done = options.done;
	  this.destroy = options.destroy;
	  this.initial = options.initial ? options.initial : this.elt.textContent;
	  this.multiline = options.multiline || false;
	  this.maxWidth = options.maxWidth;
	  if (typeof this.maxWidth == "function") {
	    this.maxWidth = this.maxWidth();
	  }

	  this.trimOutput = options.trimOutput === undefined
	                    ? true
	                    : !!options.trimOutput;
	  this.stopOnShiftTab = !!options.stopOnShiftTab;
	  this.stopOnTab = !!options.stopOnTab;
	  this.stopOnReturn = !!options.stopOnReturn;
	  this.contentType = options.contentType || CONTENT_TYPES.PLAIN_TEXT;
	  this.property = options.property;
	  this.popup = options.popup;
	  this.preserveTextStyles = options.preserveTextStyles === undefined
	                          ? false
	                          : !!options.preserveTextStyles;

	  this._onBlur = this._onBlur.bind(this);
	  this._onWindowBlur = this._onWindowBlur.bind(this);
	  this._onKeyPress = this._onKeyPress.bind(this);
	  this._onInput = this._onInput.bind(this);
	  this._onKeyup = this._onKeyup.bind(this);
	  this._onAutocompletePopupClick = this._onAutocompletePopupClick.bind(this);

	  this._createInput();

	  // Hide the provided element and add our editor.
	  this.originalDisplay = this.elt.style.display;
	  this.elt.style.display = "none";
	  this.elt.parentNode.insertBefore(this.input, this.elt);

	  // After inserting the input to have all CSS styles applied, start autosizing.
	  this._autosize();

	  this.inputCharDimensions = this._getInputCharDimensions();
	  // Pull out character codes for advanceChars, listing the
	  // characters that should trigger a blur.
	  if (typeof options.advanceChars === "function") {
	    this._advanceChars = options.advanceChars;
	  } else {
	    let advanceCharcodes = {};
	    let advanceChars = options.advanceChars || "";
	    for (let i = 0; i < advanceChars.length; i++) {
	      advanceCharcodes[advanceChars.charCodeAt(i)] = true;
	    }
	    this._advanceChars = charCode => charCode in advanceCharcodes;
	  }

	  this.input.focus();

	  if (typeof options.selectAll == "undefined" || options.selectAll) {
	    this.input.select();
	  }

	  if (this.contentType == CONTENT_TYPES.CSS_VALUE && this.input.value == "") {
	    this._maybeSuggestCompletion(false);
	  }

	  this.input.addEventListener("blur", this._onBlur, false);
	  this.input.addEventListener("keypress", this._onKeyPress, false);
	  this.input.addEventListener("input", this._onInput, false);
	  this.input.addEventListener("dblclick", this._stopEventPropagation, false);
	  this.input.addEventListener("click", this._stopEventPropagation, false);
	  this.input.addEventListener("mousedown", this._stopEventPropagation, false);
	  this.doc.defaultView.addEventListener("blur", this._onWindowBlur, false);

	  this.validate = options.validate;

	  if (this.validate) {
	    this.input.addEventListener("keyup", this._onKeyup, false);
	  }

	  this._updateSize();

	  EventEmitter.decorate(this);

	  if (options.start) {
	    options.start(this, event);
	  }
	}

	exports.InplaceEditor = InplaceEditor;

	InplaceEditor.CONTENT_TYPES = CONTENT_TYPES;

	InplaceEditor.prototype = {

	  get currentInputValue() {
	    let val = this.trimOutput ? this.input.value.trim() : this.input.value;
	    return val;
	  },

	  _createInput: function () {
	    this.input =
	      this.doc.createElementNS(HTML_NS, this.multiline ? "textarea" : "input");
	    this.input.inplaceEditor = this;

	    if (this.multiline) {
	      // Hide the textarea resize handle.
	      this.input.style.resize = "none";
	      this.input.style.overflow = "hidden";
	    }

	    this.input.classList.add("styleinspector-propertyeditor");
	    this.input.value = this.initial;
	    if (!this.preserveTextStyles) {
	      copyTextStyles(this.elt, this.input);
	    }
	  },

	  /**
	   * Get rid of the editor.
	   */
	  _clear: function () {
	    if (!this.input) {
	      // Already cleared.
	      return;
	    }

	    this.input.removeEventListener("blur", this._onBlur, false);
	    this.input.removeEventListener("keypress", this._onKeyPress, false);
	    this.input.removeEventListener("keyup", this._onKeyup, false);
	    this.input.removeEventListener("input", this._onInput, false);
	    this.input.removeEventListener("dblclick", this._stopEventPropagation,
	      false);
	    this.input.removeEventListener("click", this._stopEventPropagation, false);
	    this.input.removeEventListener("mousedown", this._stopEventPropagation,
	      false);
	    this.doc.defaultView.removeEventListener("blur", this._onWindowBlur, false);

	    this._stopAutosize();

	    this.elt.style.display = this.originalDisplay;

	    if (this.doc.activeElement == this.input) {
	      this.elt.focus();
	    }

	    this.input.remove();
	    this.input = null;

	    delete this.elt.inplaceEditor;
	    delete this.elt;

	    if (this.destroy) {
	      this.destroy();
	    }
	  },

	  /**
	   * Keeps the editor close to the size of its input string.  This is pretty
	   * crappy, suggestions for improvement welcome.
	   */
	  _autosize: function () {
	    // Create a hidden, absolutely-positioned span to measure the text
	    // in the input.  Boo.

	    // We can't just measure the original element because a) we don't
	    // change the underlying element's text ourselves (we leave that
	    // up to the client), and b) without tweaking the style of the
	    // original element, it might wrap differently or something.
	    this._measurement =
	      this.doc.createElementNS(HTML_NS, this.multiline ? "pre" : "span");
	    this._measurement.className = "autosizer";
	    this.elt.parentNode.appendChild(this._measurement);
	    let style = this._measurement.style;
	    style.visibility = "hidden";
	    style.position = "absolute";
	    style.top = "0";
	    style.left = "0";

	    if (this.multiline) {
	      style.whiteSpace = "pre-wrap";
	      style.wordWrap = "break-word";
	      if (this.maxWidth) {
	        style.maxWidth = this.maxWidth + "px";
	        // Use position fixed to measure dimensions without any influence from
	        // the container of the editor.
	        style.position = "fixed";
	      }
	    }

	    copyAllStyles(this.input, this._measurement);
	    this._updateSize();
	  },

	  /**
	   * Clean up the mess created by _autosize().
	   */
	  _stopAutosize: function () {
	    if (!this._measurement) {
	      return;
	    }
	    this._measurement.remove();
	    delete this._measurement;
	  },

	  /**
	   * Size the editor to fit its current contents.
	   */
	  _updateSize: function () {
	    // Replace spaces with non-breaking spaces.  Otherwise setting
	    // the span's textContent will collapse spaces and the measurement
	    // will be wrong.
	    let content = this.input.value;
	    let unbreakableSpace = "\u00a0";

	    // Make sure the content is not empty.
	    if (content === "") {
	      content = unbreakableSpace;
	    }

	    // If content ends with a new line, add a blank space to force the autosize
	    // element to adapt its height.
	    if (content.lastIndexOf("\n") === content.length - 1) {
	      content = content + unbreakableSpace;
	    }

	    if (!this.multiline) {
	      content = content.replace(/ /g, unbreakableSpace);
	    }

	    this._measurement.textContent = content;

	    // Do not use offsetWidth: it will round floating width values.
	    let width = this._measurement.getBoundingClientRect().width + 2;
	    if (this.multiline) {
	      if (this.maxWidth) {
	        width = Math.min(this.maxWidth, width);
	      }
	      let height = this._measurement.getBoundingClientRect().height;
	      this.input.style.height = height + "px";
	    }
	    this.input.style.width = width + "px";
	  },

	  /**
	   * Get the width and height of a single character in the input to properly
	   * position the autocompletion popup.
	   */
	  _getInputCharDimensions: function () {
	    // Just make the text content to be 'x' to get the width and height of any
	    // character in a monospace font.
	    this._measurement.textContent = "x";
	    let width = this._measurement.clientWidth;
	    let height = this._measurement.clientHeight;
	    return { width, height };
	  },

	   /**
	   * Increment property values in rule view.
	   *
	   * @param {Number} increment
	   *        The amount to increase/decrease the property value.
	   * @return {Boolean} true if value has been incremented.
	   */
	  _incrementValue: function (increment) {
	    let value = this.input.value;
	    let selectionStart = this.input.selectionStart;
	    let selectionEnd = this.input.selectionEnd;

	    let newValue = this._incrementCSSValue(value, increment, selectionStart,
	                                           selectionEnd);

	    if (!newValue) {
	      return false;
	    }

	    this.input.value = newValue.value;
	    this.input.setSelectionRange(newValue.start, newValue.end);
	    this._doValidation();

	    // Call the user's change handler if available.
	    if (this.change) {
	      this.change(this.currentInputValue);
	    }

	    return true;
	  },

	  /**
	   * Increment the property value based on the property type.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} increment
	   *        Amount to increase/decrease the property value.
	   * @param {Number} selStart
	   *        Starting index of the value.
	   * @param {Number} selEnd
	   *        Ending index of the value.
	   * @return {Object} object with properties 'value', 'start', and 'end'.
	   */
	  _incrementCSSValue: function (value, increment, selStart, selEnd) {
	    let range = this._parseCSSValue(value, selStart);
	    let type = (range && range.type) || "";
	    let rawValue = range ? value.substring(range.start, range.end) : "";
	    let preRawValue = range ? value.substr(0, range.start) : "";
	    let postRawValue = range ? value.substr(range.end) : "";
	    let info;

	    let incrementedValue = null, selection;
	    if (type === "num") {
	      if (rawValue == "0") {
	        info = {};
	        info.units = this._findCompatibleUnit(preRawValue, postRawValue);
	      }

	      let newValue = this._incrementRawValue(rawValue, increment, info);
	      if (newValue !== null) {
	        incrementedValue = newValue;
	        selection = [0, incrementedValue.length];
	      }
	    } else if (type === "hex") {
	      let exprOffset = selStart - range.start;
	      let exprOffsetEnd = selEnd - range.start;
	      let newValue = this._incHexColor(rawValue, increment, exprOffset,
	                                       exprOffsetEnd);
	      if (newValue) {
	        incrementedValue = newValue.value;
	        selection = newValue.selection;
	      }
	    } else {
	      if (type === "rgb" || type === "hsl") {
	        info = {};
	        let part = value.substring(range.start, selStart).split(",").length - 1;
	        if (part === 3) {
	          // alpha
	          info.minValue = 0;
	          info.maxValue = 1;
	        } else if (type === "rgb") {
	          info.minValue = 0;
	          info.maxValue = 255;
	        } else if (part !== 0) {
	          // hsl percentage
	          info.minValue = 0;
	          info.maxValue = 100;

	          // select the previous number if the selection is at the end of a
	          // percentage sign.
	          if (value.charAt(selStart - 1) === "%") {
	            --selStart;
	          }
	        }
	      }
	      return this._incrementGenericValue(value, increment, selStart, selEnd,
	                                         info);
	    }

	    if (incrementedValue === null) {
	      return null;
	    }

	    return {
	      value: preRawValue + incrementedValue + postRawValue,
	      start: range.start + selection[0],
	      end: range.start + selection[1]
	    };
	  },

	  /**
	   * Find a compatible unit to use for a CSS number value inserted between the
	   * provided beforeValue and afterValue. The compatible unit will be picked
	   * from a selection of default units corresponding to supported CSS value
	   * dimensions (distance, angle, duration).
	   *
	   * @param {String} beforeValue
	   *        The string preceeding the number value in the current property
	   *        value.
	   * @param {String} afterValue
	   *        The string following the number value in the current property value.
	   * @return {String} a valid unit that can be used for this number value or
	   *         empty string if no match could be found.
	   */
	  _findCompatibleUnit: function (beforeValue, afterValue) {
	    if (!this.property || !this.property.name) {
	      return "";
	    }

	    // A DOM element is used to test the validity of various units. This is to
	    // avoid having to do an async call to the server to get this information.
	    let el = this.doc.createElement("div");
	    let units = ["px", "deg", "s"];
	    for (let unit of units) {
	      let value = beforeValue + "1" + unit + afterValue;
	      el.style.setProperty(this.property.name, "");
	      el.style.setProperty(this.property.name, value);
	      if (el.style.getPropertyValue(this.property.name) !== "") {
	        return unit;
	      }
	    }
	    return "";
	  },

	  /**
	   * Parses the property value and type.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} offset
	   *        Starting index of value.
	   * @return {Object} object with properties 'value', 'start', 'end', and
	   *         'type'.
	   */
	  _parseCSSValue: function (value, offset) {
	    /* eslint-disable max-len */
	    const reSplitCSS = /(url\("?[^"\)]+"?\)?)|(rgba?\([^)]*\)?)|(hsla?\([^)]*\)?)|(#[\dA-Fa-f]+)|(-?\d*\.?\d+(%|[a-z]{1,4})?)|"([^"]*)"?|'([^']*)'?|([^,\s\/!\(\)]+)|(!(.*)?)/;
	    /* eslint-enable */
	    let start = 0;
	    let m;

	    // retreive values from left to right until we find the one at our offset
	    while ((m = reSplitCSS.exec(value)) &&
	          (m.index + m[0].length < offset)) {
	      value = value.substr(m.index + m[0].length);
	      start += m.index + m[0].length;
	      offset -= m.index + m[0].length;
	    }

	    if (!m) {
	      return null;
	    }

	    let type;
	    if (m[1]) {
	      type = "url";
	    } else if (m[2]) {
	      type = "rgb";
	    } else if (m[3]) {
	      type = "hsl";
	    } else if (m[4]) {
	      type = "hex";
	    } else if (m[5]) {
	      type = "num";
	    }

	    return {
	      value: m[0],
	      start: start + m.index,
	      end: start + m.index + m[0].length,
	      type: type
	    };
	  },

	  /**
	   * Increment the property value for types other than
	   * number or hex, such as rgb, hsl, and file names.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} increment
	   *        Amount to increment/decrement.
	   * @param {Number} offset
	   *        Starting index of the property value.
	   * @param {Number} offsetEnd
	   *        Ending index of the property value.
	   * @param {Object} info
	   *        Object with details about the property value.
	   * @return {Object} object with properties 'value', 'start', and 'end'.
	   */
	  _incrementGenericValue: function (value, increment, offset, offsetEnd, info) {
	    // Try to find a number around the cursor to increment.
	    let start, end;
	    // Check if we are incrementing in a non-number context (such as a URL)
	    if (/^-?[0-9.]/.test(value.substring(offset, offsetEnd)) &&
	      !(/\d/.test(value.charAt(offset - 1) + value.charAt(offsetEnd)))) {
	      // We have a number selected, possibly with a suffix, and we are not in
	      // the disallowed case of just part of a known number being selected.
	      // Use that number.
	      start = offset;
	      end = offsetEnd;
	    } else {
	      // Parse periods as belonging to the number only if we are in a known
	      // number context. (This makes incrementing the 1 in 'image1.gif' work.)
	      let pattern = "[" + (info ? "0-9." : "0-9") + "]*";
	      let before = new RegExp(pattern + "$")
	        .exec(value.substr(0, offset))[0].length;
	      let after = new RegExp("^" + pattern)
	        .exec(value.substr(offset))[0].length;

	      start = offset - before;
	      end = offset + after;

	      // Expand the number to contain an initial minus sign if it seems
	      // free-standing.
	      if (value.charAt(start - 1) === "-" &&
	         (start - 1 === 0 || /[ (:,='"]/.test(value.charAt(start - 2)))) {
	        --start;
	      }
	    }

	    if (start !== end) {
	      // Include percentages as part of the incremented number (they are
	      // common enough).
	      if (value.charAt(end) === "%") {
	        ++end;
	      }

	      let first = value.substr(0, start);
	      let mid = value.substring(start, end);
	      let last = value.substr(end);

	      mid = this._incrementRawValue(mid, increment, info);

	      if (mid !== null) {
	        return {
	          value: first + mid + last,
	          start: start,
	          end: start + mid.length
	        };
	      }
	    }

	    return null;
	  },

	  /**
	   * Increment the property value for numbers.
	   *
	   * @param {String} rawValue
	   *        Raw value to increment.
	   * @param {Number} increment
	   *        Amount to increase/decrease the raw value.
	   * @param {Object} info
	   *        Object with info about the property value.
	   * @return {String} the incremented value.
	   */
	  _incrementRawValue: function (rawValue, increment, info) {
	    let num = parseFloat(rawValue);

	    if (isNaN(num)) {
	      return null;
	    }

	    let number = /\d+(\.\d+)?/.exec(rawValue);

	    let units = rawValue.substr(number.index + number[0].length);
	    if (info && "units" in info) {
	      units = info.units;
	    }

	    // avoid rounding errors
	    let newValue = Math.round((num + increment) * 1000) / 1000;

	    if (info && "minValue" in info) {
	      newValue = Math.max(newValue, info.minValue);
	    }
	    if (info && "maxValue" in info) {
	      newValue = Math.min(newValue, info.maxValue);
	    }

	    newValue = newValue.toString();

	    return newValue + units;
	  },

	  /**
	   * Increment the property value for hex.
	   *
	   * @param {String} value
	   *        Property value.
	   * @param {Number} increment
	   *        Amount to increase/decrease the property value.
	   * @param {Number} offset
	   *        Starting index of the property value.
	   * @param {Number} offsetEnd
	   *        Ending index of the property value.
	   * @return {Object} object with properties 'value' and 'selection'.
	   */
	  _incHexColor: function (rawValue, increment, offset, offsetEnd) {
	    // Return early if no part of the rawValue is selected.
	    if (offsetEnd > rawValue.length && offset >= rawValue.length) {
	      return null;
	    }
	    if (offset < 1 && offsetEnd <= 1) {
	      return null;
	    }
	    // Ignore the leading #.
	    rawValue = rawValue.substr(1);
	    --offset;
	    --offsetEnd;

	    // Clamp the selection to within the actual value.
	    offset = Math.max(offset, 0);
	    offsetEnd = Math.min(offsetEnd, rawValue.length);
	    offsetEnd = Math.max(offsetEnd, offset);

	    // Normalize #ABC -> #AABBCC.
	    if (rawValue.length === 3) {
	      rawValue = rawValue.charAt(0) + rawValue.charAt(0) +
	                 rawValue.charAt(1) + rawValue.charAt(1) +
	                 rawValue.charAt(2) + rawValue.charAt(2);
	      offset *= 2;
	      offsetEnd *= 2;
	    }

	    // Normalize #ABCD -> #AABBCCDD.
	    if (rawValue.length === 4) {
	      rawValue = rawValue.charAt(0) + rawValue.charAt(0) +
	                 rawValue.charAt(1) + rawValue.charAt(1) +
	                 rawValue.charAt(2) + rawValue.charAt(2) +
	                 rawValue.charAt(3) + rawValue.charAt(3);
	      offset *= 2;
	      offsetEnd *= 2;
	    }

	    if (rawValue.length !== 6 && rawValue.length !== 8) {
	      return null;
	    }

	    // If no selection, increment an adjacent color, preferably one to the left.
	    if (offset === offsetEnd) {
	      if (offset === 0) {
	        offsetEnd = 1;
	      } else {
	        offset = offsetEnd - 1;
	      }
	    }

	    // Make the selection cover entire parts.
	    offset -= offset % 2;
	    offsetEnd += offsetEnd % 2;

	    // Remap the increments from [0.1, 1, 10] to [1, 1, 16].
	    if (increment > -1 && increment < 1) {
	      increment = (increment < 0 ? -1 : 1);
	    }
	    if (Math.abs(increment) === 10) {
	      increment = (increment < 0 ? -16 : 16);
	    }

	    let isUpper = (rawValue.toUpperCase() === rawValue);

	    for (let pos = offset; pos < offsetEnd; pos += 2) {
	      // Increment the part in [pos, pos+2).
	      let mid = rawValue.substr(pos, 2);
	      let value = parseInt(mid, 16);

	      if (isNaN(value)) {
	        return null;
	      }

	      mid = Math.min(Math.max(value + increment, 0), 255).toString(16);

	      while (mid.length < 2) {
	        mid = "0" + mid;
	      }
	      if (isUpper) {
	        mid = mid.toUpperCase();
	      }

	      rawValue = rawValue.substr(0, pos) + mid + rawValue.substr(pos + 2);
	    }

	    return {
	      value: "#" + rawValue,
	      selection: [offset + 1, offsetEnd + 1]
	    };
	  },

	  /**
	   * Cycle through the autocompletion suggestions in the popup.
	   *
	   * @param {Boolean} reverse
	   *        true to select previous item from the popup.
	   * @param {Boolean} noSelect
	   *        true to not select the text after selecting the newly selectedItem
	   *        from the popup.
	   */
	  _cycleCSSSuggestion: function (reverse, noSelect) {
	    // selectedItem can be null when nothing is selected in an empty editor.
	    let {label, preLabel} = this.popup.selectedItem ||
	                            {label: "", preLabel: ""};
	    if (reverse) {
	      this.popup.selectPreviousItem();
	    } else {
	      this.popup.selectNextItem();
	    }

	    this._selectedIndex = this.popup.selectedIndex;
	    let input = this.input;
	    let pre = "";

	    if (input.selectionStart < input.selectionEnd) {
	      pre = input.value.slice(0, input.selectionStart);
	    } else {
	      pre = input.value.slice(0, input.selectionStart - label.length +
	                              preLabel.length);
	    }

	    let post = input.value.slice(input.selectionEnd, input.value.length);
	    let item = this.popup.selectedItem;
	    let toComplete = item.label.slice(item.preLabel.length);
	    input.value = pre + toComplete + post;

	    if (!noSelect) {
	      input.setSelectionRange(pre.length, pre.length + toComplete.length);
	    } else {
	      input.setSelectionRange(pre.length + toComplete.length,
	                              pre.length + toComplete.length);
	    }

	    this._updateSize();
	    // This emit is mainly for the purpose of making the test flow simpler.
	    this.emit("after-suggest");
	  },

	  /**
	   * Call the client's done handler and clear out.
	   */
	  _apply: function (event, direction) {
	    if (this._applied) {
	      return null;
	    }

	    this._applied = true;

	    if (this.done) {
	      let val = this.cancelled ? this.initial : this.currentInputValue;
	      return this.done(val, !this.cancelled, direction);
	    }

	    return null;
	  },

	  /**
	   * Hide the popup and cancel any pending popup opening.
	   */
	  _onWindowBlur: function () {
	    if (this.popup && this.popup.isOpen) {
	      this.popup.hidePopup();
	    }

	    if (this._openPopupTimeout) {
	      this.doc.defaultView.clearTimeout(this._openPopupTimeout);
	    }
	  },

	  /**
	   * Event handler called when the inplace-editor's input loses focus.
	   */
	  _onBlur: function (event) {
	    if (event && this.popup && this.popup.isOpen &&
	      this.popup.selectedIndex >= 0) {
	      this._acceptPopupSuggestion();
	    } else {
	      this._apply();
	      this._clear();
	    }
	  },

	  /**
	   * Event handler called by the autocomplete popup when receiving a click
	   * event.
	   */
	  _onAutocompletePopupClick: function () {
	    this._acceptPopupSuggestion();
	  },

	  _acceptPopupSuggestion: function () {
	    let label, preLabel;

	    if (this._selectedIndex === undefined) {
	      ({label, preLabel} = this.popup.getItemAtIndex(this.popup.selectedIndex));
	    } else {
	      ({label, preLabel} = this.popup.getItemAtIndex(this._selectedIndex));
	    }

	    let input = this.input;

	    let pre = "";

	    // CSS_MIXED needs special treatment here to make it so that
	    // multiple presses of tab will cycle through completions, but
	    // without selecting the completed text.  However, this same
	    // special treatment will do the wrong thing for other editing
	    // styles.
	    if (input.selectionStart < input.selectionEnd ||
	        this.contentType !== CONTENT_TYPES.CSS_MIXED) {
	      pre = input.value.slice(0, input.selectionStart);
	    } else {
	      pre = input.value.slice(0, input.selectionStart - label.length +
	                              preLabel.length);
	    }
	    let post = input.value.slice(input.selectionEnd, input.value.length);
	    let item = this.popup.selectedItem;
	    this._selectedIndex = this.popup.selectedIndex;
	    let toComplete = item.label.slice(item.preLabel.length);
	    input.value = pre + toComplete + post;
	    input.setSelectionRange(pre.length + toComplete.length,
	                            pre.length + toComplete.length);
	    this._updateSize();
	    // Wait for the popup to hide and then focus input async otherwise it does
	    // not work.
	    let onPopupHidden = () => {
	      this.popup.off("popup-closed", onPopupHidden);
	      this.doc.defaultView.setTimeout(()=> {
	        input.focus();
	        this.emit("after-suggest");
	      }, 0);
	    };
	    this.popup.on("popup-closed", onPopupHidden);
	    this._hideAutocompletePopup();
	  },

	  /**
	   * Handle the input field's keypress event.
	   */
	  _onKeyPress: function (event) {
	    let prevent = false;

	    let key = event.keyCode;
	    let input = this.input;

	    let multilineNavigation = !this._isSingleLine() &&
	      isKeyIn(key, "UP", "DOWN", "LEFT", "RIGHT");
	    let isPlainText = this.contentType == CONTENT_TYPES.PLAIN_TEXT;
	    let isPopupOpen = this.popup && this.popup.isOpen;

	    let increment = 0;
	    if (!isPlainText && !multilineNavigation) {
	      increment = this._getIncrement(event);
	    }

	    if (isKeyIn(key, "PAGE_UP", "PAGE_DOWN")) {
	      this._preventSuggestions = true;
	    }

	    let cycling = false;
	    if (increment && this._incrementValue(increment)) {
	      this._updateSize();
	      prevent = true;
	      cycling = true;
	    }

	    if (isPopupOpen && isKeyIn(key, "UP", "DOWN", "PAGE_UP", "PAGE_DOWN")) {
	      prevent = true;
	      cycling = true;
	      this._cycleCSSSuggestion(isKeyIn(key, "UP", "PAGE_UP"));
	      this._doValidation();
	    }

	    if (isKeyIn(key, "BACK_SPACE", "DELETE", "LEFT", "RIGHT", "HOME", "END")) {
	      if (isPopupOpen) {
	        this._hideAutocompletePopup();
	      }
	    } else if (!cycling && !multilineNavigation &&
	      !event.metaKey && !event.altKey && !event.ctrlKey) {
	      this._maybeSuggestCompletion(true);
	    }

	    if (this.multiline && event.shiftKey && isKeyIn(key, "RETURN")) {
	      prevent = false;
	    } else if (
	      this._advanceChars(event.charCode, input.value, input.selectionStart) ||
	      isKeyIn(key, "RETURN", "TAB")) {
	      prevent = true;

	      let direction;
	      if ((this.stopOnReturn && isKeyIn(key, "RETURN")) ||
	          (this.stopOnTab && !event.shiftKey && isKeyIn(key, "TAB")) ||
	          (this.stopOnShiftTab && event.shiftKey && isKeyIn(key, "TAB"))) {
	        direction = null;
	      } else if (event.shiftKey && isKeyIn(key, "TAB")) {
	        direction = FOCUS_BACKWARD;
	      } else {
	        direction = FOCUS_FORWARD;
	      }

	      // Now we don't want to suggest anything as we are moving out.
	      this._preventSuggestions = true;
	      // But we still want to show suggestions for css values. i.e. moving out
	      // of css property input box in forward direction
	      if (this.contentType == CONTENT_TYPES.CSS_PROPERTY &&
	          direction == FOCUS_FORWARD) {
	        this._preventSuggestions = false;
	      }

	      if (isKeyIn(key, "TAB") && this.contentType == CONTENT_TYPES.CSS_MIXED) {
	        if (this.popup && input.selectionStart < input.selectionEnd) {
	          event.preventDefault();
	          input.setSelectionRange(input.selectionEnd, input.selectionEnd);
	          this.emit("after-suggest");
	          return;
	        } else if (this.popup && this.popup.isOpen) {
	          event.preventDefault();
	          this._cycleCSSSuggestion(event.shiftKey, true);
	          return;
	        }
	      }

	      this._apply(event, direction);

	      // Close the popup if open
	      if (this.popup && this.popup.isOpen) {
	        this._hideAutocompletePopup();
	      }

	      if (direction !== null && focusManager.focusedElement === input) {
	        // If the focused element wasn't changed by the done callback,
	        // move the focus as requested.
	        let next = moveFocus(this.doc.defaultView, direction);

	        // If the next node to be focused has been tagged as an editable
	        // node, trigger editing using the configured event
	        if (next && next.ownerDocument === this.doc && next._editable) {
	          let e = this.doc.createEvent("Event");
	          e.initEvent(next._trigger, true, true);
	          next.dispatchEvent(e);
	        }
	      }

	      this._clear();
	    } else if (isKeyIn(key, "ESCAPE")) {
	      // Cancel and blur ourselves.
	      // Now we don't want to suggest anything as we are moving out.
	      this._preventSuggestions = true;
	      // Close the popup if open
	      if (this.popup && this.popup.isOpen) {
	        this._hideAutocompletePopup();
	      }
	      prevent = true;
	      this.cancelled = true;
	      this._apply();
	      this._clear();
	      event.stopPropagation();
	    } else if (isKeyIn(key, "SPACE")) {
	      // No need for leading spaces here.  This is particularly
	      // noticable when adding a property: it's very natural to type
	      // <name>: (which advances to the next property) then spacebar.
	      prevent = !input.value;
	    }

	    if (prevent) {
	      event.preventDefault();
	    }
	  },

	  /**
	   * Open the autocomplete popup, adding a custom click handler and classname.
	   *
	   * @param {Number} offset
	   *        X-offset relative to the input starting edge.
	   * @param {Number} selectedIndex
	   *        The index of the item that should be selected. Use -1 to have no
	   *        item selected.
	   */
	  _openAutocompletePopup: function (offset, selectedIndex) {
	    this.popup.on("popup-click", this._onAutocompletePopupClick);
	    this.popup.openPopup(this.input, offset, 0, selectedIndex);
	  },

	  /**
	   * Remove the custom classname and click handler and close the autocomplete
	   * popup.
	   */
	  _hideAutocompletePopup: function () {
	    this.popup.off("popup-click", this._onAutocompletePopupClick);
	    this.popup.hidePopup();
	  },

	  /**
	   * Get the increment/decrement step to use for the provided key event.
	   */
	  _getIncrement: function (event) {
	    const largeIncrement = 100;
	    const mediumIncrement = 10;
	    const smallIncrement = 0.1;

	    let increment = 0;
	    let key = event.keyCode;

	    if (isKeyIn(key, "UP", "PAGE_UP")) {
	      increment = 1;
	    } else if (isKeyIn(key, "DOWN", "PAGE_DOWN")) {
	      increment = -1;
	    }

	    if (event.shiftKey && !event.altKey) {
	      if (isKeyIn(key, "PAGE_UP", "PAGE_DOWN")) {
	        increment *= largeIncrement;
	      } else {
	        increment *= mediumIncrement;
	      }
	    } else if (event.altKey && !event.shiftKey) {
	      increment *= smallIncrement;
	    }

	    return increment;
	  },

	  /**
	   * Handle the input field's keyup event.
	   */
	  _onKeyup: function () {
	    this._applied = false;
	  },

	  /**
	   * Handle changes to the input text.
	   */
	  _onInput: function () {
	    // Validate the entered value.
	    this._doValidation();

	    // Update size if we're autosizing.
	    if (this._measurement) {
	      this._updateSize();
	    }

	    // Call the user's change handler if available.
	    if (this.change) {
	      this.change(this.currentInputValue);
	    }
	  },

	  /**
	   * Stop propagation on the provided event
	   */
	  _stopEventPropagation: function (e) {
	    e.stopPropagation();
	  },

	  /**
	   * Fire validation callback with current input
	   */
	  _doValidation: function () {
	    if (this.validate && this.input) {
	      this.validate(this.input.value);
	    }
	  },

	  /**
	   * Handles displaying suggestions based on the current input.
	   *
	   * @param {Boolean} autoInsert
	   *        Pass true to automatically insert the most relevant suggestion.
	   */
	  _maybeSuggestCompletion: function (autoInsert) {
	    // Input can be null in cases when you intantaneously switch out of it.
	    if (!this.input) {
	      return;
	    }
	    let preTimeoutQuery = this.input.value;

	    // Since we are calling this method from a keypress event handler, the
	    // |input.value| does not include currently typed character. Thus we perform
	    // this method async.
	    this._openPopupTimeout = this.doc.defaultView.setTimeout(() => {
	      if (this._preventSuggestions) {
	        this._preventSuggestions = false;
	        return;
	      }
	      if (this.contentType == CONTENT_TYPES.PLAIN_TEXT) {
	        return;
	      }
	      if (!this.input) {
	        return;
	      }
	      let input = this.input;
	      // The length of input.value should be increased by 1
	      if (input.value.length - preTimeoutQuery.length > 1) {
	        return;
	      }
	      let query = input.value.slice(0, input.selectionStart);
	      let startCheckQuery = query;
	      if (query == null) {
	        return;
	      }
	      // If nothing is selected and there is a word (\w) character after the cursor, do
	      // not autocomplete.
	      if (input.selectionStart == input.selectionEnd &&
	          input.selectionStart < input.value.length) {
	        let nextChar = input.value.slice(input.selectionStart)[0];
	        // Check if the next character is a valid word character, no suggestion should be
	        // provided when preceeding a word.
	        if (/[\w-]/.test(nextChar)) {
	          // This emit is mainly to make the test flow simpler.
	          this.emit("after-suggest", "nothing to autocomplete");
	          return;
	        }
	      }
	      let list = [];
	      if (this.contentType == CONTENT_TYPES.CSS_PROPERTY) {
	        list = this._getCSSPropertyList();
	      } else if (this.contentType == CONTENT_TYPES.CSS_VALUE) {
	        // Get the last query to be completed before the caret.
	        let match = /([^\s,.\/]+$)/.exec(query);
	        if (match) {
	          startCheckQuery = match[0];
	        } else {
	          startCheckQuery = "";
	        }

	        list =
	          ["!important",
	           ...this._getCSSValuesForPropertyName(this.property.name)];

	        if (query == "") {
	          // Do not suggest '!important' without any manually typed character.
	          list.splice(0, 1);
	        }
	      } else if (this.contentType == CONTENT_TYPES.CSS_MIXED &&
	                 /^\s*style\s*=/.test(query)) {
	        // Check if the style attribute is closed before the selection.
	        let styleValue = query.replace(/^\s*style\s*=\s*/, "");
	        // Look for a quote matching the opening quote (single or double).
	        if (/^("[^"]*"|'[^']*')/.test(styleValue)) {
	          // This emit is mainly to make the test flow simpler.
	          this.emit("after-suggest", "nothing to autocomplete");
	          return;
	        }

	        // Detecting if cursor is at property or value;
	        let match = query.match(/([:;"'=]?)\s*([^"';:=]+)?$/);
	        if (match && match.length >= 2) {
	          if (match[1] == ":") {
	            // We are in CSS value completion
	            let propertyName =
	              query.match(/[;"'=]\s*([^"';:= ]+)\s*:\s*[^"';:=]*$/)[1];
	            list =
	              ["!important;",
	               ...this._getCSSValuesForPropertyName(propertyName)];
	            let matchLastQuery = /([^\s,.\/]+$)/.exec(match[2] || "");
	            if (matchLastQuery) {
	              startCheckQuery = matchLastQuery[0];
	            } else {
	              startCheckQuery = "";
	            }
	            if (!match[2]) {
	              // Don't suggest '!important' without any manually typed character
	              list.splice(0, 1);
	            }
	          } else if (match[1]) {
	            // We are in CSS property name completion
	            list = this._getCSSPropertyList();
	            startCheckQuery = match[2];
	          }
	          if (startCheckQuery == null) {
	            // This emit is mainly to make the test flow simpler.
	            this.emit("after-suggest", "nothing to autocomplete");
	            return;
	          }
	        }
	      }

	      if (!this.popup) {
	        // This emit is mainly to make the test flow simpler.
	        this.emit("after-suggest", "no popup");
	        return;
	      }

	      let finalList = [];
	      let length = list.length;
	      for (let i = 0, count = 0; i < length && count < MAX_POPUP_ENTRIES; i++) {
	        if (startCheckQuery != null && list[i].startsWith(startCheckQuery)) {
	          count++;
	          finalList.push({
	            preLabel: startCheckQuery,
	            label: list[i]
	          });
	        } else if (count > 0) {
	          // Since count was incremented, we had already crossed the entries
	          // which would have started with query, assuming that list is sorted.
	          break;
	        } else if (startCheckQuery != null && list[i][0] > startCheckQuery[0]) {
	          // We have crossed all possible matches alphabetically.
	          break;
	        }
	      }

	      // Sort items starting with [a-z0-9] first, to make sure vendor-prefixed
	      // values and "!important" are suggested only after standard values.
	      finalList.sort((item1, item2) => {
	        // Get the expected alphabetical comparison between the items.
	        let comparison = item1.label.localeCompare(item2.label);
	        if (/^\w/.test(item1.label) != /^\w/.test(item2.label)) {
	          // One starts with [a-z0-9], one does not: flip the comparison.
	          comparison = -1 * comparison;
	        }
	        return comparison;
	      });

	      let index = 0;
	      if (startCheckQuery) {
	        // Only select a "best" suggestion when the user started a query.
	        let cssValues = finalList.map(item => item.label);
	        index = findMostRelevantCssPropertyIndex(cssValues);
	      }

	      // Insert the most relevant item from the final list as the input value.
	      if (autoInsert && finalList[index]) {
	        let item = finalList[index].label;
	        input.value = query + item.slice(startCheckQuery.length) +
	                      input.value.slice(query.length);
	        input.setSelectionRange(query.length, query.length + item.length -
	                                              startCheckQuery.length);
	        this._updateSize();
	      }

	      // Display the list of suggestions if there are more than one.
	      if (finalList.length > 1) {
	        // Calculate the popup horizontal offset.
	        let indent = this.input.selectionStart - startCheckQuery.length;
	        let offset = indent * this.inputCharDimensions.width;
	        offset = this._isSingleLine() ? offset : 0;

	        // Select the most relevantItem if autoInsert is allowed
	        let selectedIndex = autoInsert ? index : -1;

	        // Open the suggestions popup.
	        this.popup.setItems(finalList);
	        this._openAutocompletePopup(offset, selectedIndex);
	      } else {
	        this._hideAutocompletePopup();
	      }
	      // This emit is mainly for the purpose of making the test flow simpler.
	      this.emit("after-suggest");
	      this._doValidation();
	    }, 0);
	  },

	  /**
	   * Check if the current input is displaying more than one line of text.
	   *
	   * @return {Boolean} true if the input has a single line of text
	   */
	  _isSingleLine: function () {
	    let inputRect = this.input.getBoundingClientRect();
	    return inputRect.height < 2 * this.inputCharDimensions.height;
	  },

	  /**
	   * Returns the list of CSS properties to use for the autocompletion. This
	   * method is overridden by tests in order to use mocked suggestion lists.
	   *
	   * @return {Array} array of CSS property names (Strings)
	   */
	  _getCSSPropertyList: function () {
	    return this.cssProperties.getNames().sort();
	  },

	  /**
	   * Returns a list of CSS values valid for a provided property name to use for
	   * the autocompletion. This method is overridden by tests in order to use
	   * mocked suggestion lists.
	   *
	   * @param {String} propertyName
	   * @return {Array} array of CSS property values (Strings)
	   */
	  _getCSSValuesForPropertyName: function (propertyName) {
	    return this.cssProperties.getValues(propertyName);
	  },
	};

	/**
	 * Copy text-related styles from one element to another.
	 */
	function copyTextStyles(from, to) {
	  let win = from.ownerDocument.defaultView;
	  let style = win.getComputedStyle(from);
	  let getCssText = name => style.getPropertyCSSValue(name).cssText;

	  to.style.fontFamily = getCssText("font-family");
	  to.style.fontSize = getCssText("font-size");
	  to.style.fontWeight = getCssText("font-weight");
	  to.style.fontStyle = getCssText("font-style");
	}

	/**
	 * Copy all styles which could have an impact on the element size.
	 */
	function copyAllStyles(from, to) {
	  let win = from.ownerDocument.defaultView;
	  let style = win.getComputedStyle(from);
	  let getCssText = name => style.getPropertyCSSValue(name).cssText;

	  copyTextStyles(from, to);
	  to.style.lineHeight = getCssText("line-height");

	  // If box-sizing is set to border-box, box model styles also need to be
	  // copied.
	  let boxSizing = getCssText("box-sizing");
	  if (boxSizing === "border-box") {
	    to.style.boxSizing = boxSizing;
	    copyBoxModelStyles(from, to);
	  }
	}

	/**
	 * Copy box model styles that can impact width and height measurements when box-
	 * sizing is set to "border-box" instead of "content-box".
	 *
	 * @param {DOMNode} from
	 *        the element from which styles are copied
	 * @param {DOMNode} to
	 *        the element on which copied styles are applied
	 */
	function copyBoxModelStyles(from, to) {
	  let win = from.ownerDocument.defaultView;
	  let style = win.getComputedStyle(from);
	  let getCssText = name => style.getPropertyCSSValue(name).cssText;

	  // Copy all paddings.
	  to.style.paddingTop = getCssText("padding-top");
	  to.style.paddingRight = getCssText("padding-right");
	  to.style.paddingBottom = getCssText("padding-bottom");
	  to.style.paddingLeft = getCssText("padding-left");

	  // Copy border styles.
	  to.style.borderTopStyle = getCssText("border-top-style");
	  to.style.borderRightStyle = getCssText("border-right-style");
	  to.style.borderBottomStyle = getCssText("border-bottom-style");
	  to.style.borderLeftStyle = getCssText("border-left-style");

	  // Copy border widths.
	  to.style.borderTopWidth = getCssText("border-top-width");
	  to.style.borderRightWidth = getCssText("border-right-width");
	  to.style.borderBottomWidth = getCssText("border-bottom-width");
	  to.style.borderLeftWidth = getCssText("border-left-width");
	}

	/**
	 * Trigger a focus change similar to pressing tab/shift-tab.
	 */
	function moveFocus(win, direction) {
	  return focusManager.moveFocus(win, null, direction, 0);
	}


/***/ },
/* 204 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Allows to find the lowest ranking index in an index
	 * of suggestions, by comparing it to another array of "most relevant" items
	 * which has been sorted by relevance.
	 *
	 * Example usage:
	 *  let sortedBrowsers = ["firefox", "safari", "edge", "chrome"];
	 *  let myBrowsers = ["brave", "chrome", "firefox"];
	 *  let bestBrowserIndex = findMostRelevantIndex(myBrowsers, sortedBrowsers);
	 *  // returns "2", the index of firefox in myBrowsers array
	 *
	 * @param {Array} items
	 *        Array of items to compare against sortedItems.
	 * @param {Array} sortedItems
	 *        Array of sorted items that suggestions are evaluated against. Array
	 *        should be sorted by relevance, most relevant item first.
	 * @return {Number}
	 */
	function findMostRelevantIndex(items, sortedItems) {
	  if (!Array.isArray(items) || !Array.isArray(sortedItems)) {
	    throw new Error("Please provide valid items and sortedItems arrays.");
	  }

	  // If the items array is empty, no valid index can be found.
	  if (!items.length) {
	    return -1;
	  }

	  // Return 0 if no match was found in the suggestion list.
	  let bestIndex = 0;
	  let lowestIndex = Infinity;
	  items.forEach((item, i) => {
	    let index = sortedItems.indexOf(item);
	    if (index !== -1 && index <= lowestIndex) {
	      lowestIndex = index;
	      bestIndex = i;
	    }
	  });

	  return bestIndex;
	}

	/**
	 * Top 100 CSS property names sorted by relevance, most relevant first.
	 *
	 * List based on the one used by Chrome devtools :
	 * https://code.google.com/p/chromium/codesearch#chromium/src/third_party/
	 * WebKit/Source/devtools/front_end/sdk/CSSMetadata.js&q=CSSMetadata&
	 * sq=package:chromium&type=cs&l=676
	 *
	 * The data is a mix of https://www.chromestatus.com/metrics/css and usage
	 * metrics from popular sites collected via https://gist.github.com/NV/3751436
	 *
	 * @type {Array}
	 */
	const SORTED_CSS_PROPERTIES = [
	  "width",
	  "margin",
	  "height",
	  "padding",
	  "font-size",
	  "border",
	  "display",
	  "position",
	  "text-align",
	  "background",
	  "background-color",
	  "top",
	  "font-weight",
	  "color",
	  "overflow",
	  "font-family",
	  "margin-top",
	  "float",
	  "opacity",
	  "cursor",
	  "left",
	  "text-decoration",
	  "background-image",
	  "right",
	  "line-height",
	  "margin-left",
	  "visibility",
	  "margin-bottom",
	  "padding-top",
	  "z-index",
	  "margin-right",
	  "background-position",
	  "vertical-align",
	  "padding-left",
	  "background-repeat",
	  "border-bottom",
	  "padding-right",
	  "border-top",
	  "padding-bottom",
	  "clear",
	  "white-space",
	  "bottom",
	  "border-color",
	  "max-width",
	  "border-radius",
	  "border-right",
	  "outline",
	  "border-left",
	  "font-style",
	  "content",
	  "min-width",
	  "min-height",
	  "box-sizing",
	  "list-style",
	  "border-width",
	  "box-shadow",
	  "font",
	  "border-collapse",
	  "text-shadow",
	  "text-indent",
	  "border-style",
	  "max-height",
	  "text-overflow",
	  "background-size",
	  "text-transform",
	  "zoom",
	  "list-style-type",
	  "border-spacing",
	  "word-wrap",
	  "overflow-y",
	  "transition",
	  "border-top-color",
	  "border-bottom-color",
	  "border-top-right-radius",
	  "letter-spacing",
	  "border-top-left-radius",
	  "border-bottom-left-radius",
	  "border-bottom-right-radius",
	  "overflow-x",
	  "pointer-events",
	  "border-right-color",
	  "transform",
	  "border-top-width",
	  "border-bottom-width",
	  "border-right-width",
	  "direction",
	  "animation",
	  "border-left-color",
	  "clip",
	  "border-left-width",
	  "table-layout",
	  "src",
	  "resize",
	  "word-break",
	  "background-clip",
	  "transform-origin",
	  "font-variant",
	  "filter",
	  "quotes",
	  "word-spacing"
	];

	/**
	 * Helper to find the most relevant CSS property name in a provided array.
	 *
	 * @param items {Array}
	 *              Array of CSS property names.
	 */
	function findMostRelevantCssPropertyIndex(items) {
	  return findMostRelevantIndex(items, SORTED_CSS_PROPERTIES);
	}

	exports.findMostRelevantIndex = findMostRelevantIndex;
	exports.findMostRelevantCssPropertyIndex = findMostRelevantCssPropertyIndex;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {l10n} = __webpack_require__(173);
	const {getCssProperties} = __webpack_require__(16);
	const {InplaceEditor, editableField} =
	      __webpack_require__(203);
	const {
	  createChild,
	  appendText,
	  advanceValidate,
	  blurOnMultipleProperties
	} = __webpack_require__(181);
	const {
	  parseDeclarations,
	  parseSingleValue,
	} = __webpack_require__(182);
	const Services = __webpack_require__(1);

	const HTML_NS = "http://www.w3.org/1999/xhtml";

	const SHARED_SWATCH_CLASS = "ruleview-swatch";
	const COLOR_SWATCH_CLASS = "ruleview-colorswatch";
	const BEZIER_SWATCH_CLASS = "ruleview-bezierswatch";
	const FILTER_SWATCH_CLASS = "ruleview-filterswatch";
	const ANGLE_SWATCH_CLASS = "ruleview-angleswatch";

	/*
	 * An actionable element is an element which on click triggers a specific action
	 * (e.g. shows a color tooltip, opens a link, …).
	 */
	const ACTIONABLE_ELEMENTS_SELECTORS = [
	  `.${COLOR_SWATCH_CLASS}`,
	  `.${BEZIER_SWATCH_CLASS}`,
	  `.${FILTER_SWATCH_CLASS}`,
	  `.${ANGLE_SWATCH_CLASS}`,
	  "a"
	];

	/**
	 * TextPropertyEditor is responsible for the following:
	 *   Owns a TextProperty object.
	 *   Manages changes to the TextProperty.
	 *   Can be expanded to display computed properties.
	 *   Can mark a property disabled or enabled.
	 *
	 * @param {RuleEditor} ruleEditor
	 *        The rule editor that owns this TextPropertyEditor.
	 * @param {TextProperty} property
	 *        The text property to edit.
	 */
	function TextPropertyEditor(ruleEditor, property) {
	  this.ruleEditor = ruleEditor;
	  this.ruleView = this.ruleEditor.ruleView;
	  this.doc = this.ruleEditor.doc;
	  this.popup = this.ruleView.popup;
	  this.prop = property;
	  this.prop.editor = this;
	  this.browserWindow = this.doc.defaultView.top;
	  this._populatedComputed = false;
	  this._hasPendingClick = false;
	  this._clickedElementOptions = null;

	  const toolbox = this.ruleView.inspector.toolbox;
	  this.cssProperties = getCssProperties(toolbox);

	  this._onEnableClicked = this._onEnableClicked.bind(this);
	  this._onExpandClicked = this._onExpandClicked.bind(this);
	  this._onStartEditing = this._onStartEditing.bind(this);
	  this._onNameDone = this._onNameDone.bind(this);
	  this._onValueDone = this._onValueDone.bind(this);
	  this._onSwatchCommit = this._onSwatchCommit.bind(this);
	  this._onSwatchPreview = this._onSwatchPreview.bind(this);
	  this._onSwatchRevert = this._onSwatchRevert.bind(this);
	  this._onValidate = this.ruleView.throttle(this._previewValue, 10, this);
	  this.update = this.update.bind(this);
	  this.updatePropertyState = this.updatePropertyState.bind(this);

	  this._create();
	  this.update();
	}

	TextPropertyEditor.prototype = {
	  /**
	   * Boolean indicating if the name or value is being currently edited.
	   */
	  get editing() {
	    return !!(this.nameSpan.inplaceEditor || this.valueSpan.inplaceEditor ||
	      this.ruleView.tooltips.isEditing) || this.popup.isOpen;
	  },

	  /**
	   * Get the rule to the current text property
	   */
	  get rule() {
	    return this.prop.rule;
	  },

	  /**
	   * Create the property editor's DOM.
	   */
	  _create: function () {
	    this.element = this.doc.createElementNS(HTML_NS, "li");
	    this.element.classList.add("ruleview-property");
	    this.element._textPropertyEditor = this;

	    this.container = createChild(this.element, "div", {
	      class: "ruleview-propertycontainer"
	    });

	    // The enable checkbox will disable or enable the rule.
	    this.enable = createChild(this.container, "div", {
	      class: "ruleview-enableproperty theme-checkbox",
	      tabindex: "-1"
	    });

	    // Click to expand the computed properties of the text property.
	    this.expander = createChild(this.container, "span", {
	      class: "ruleview-expander theme-twisty"
	    });
	    this.expander.addEventListener("click", this._onExpandClicked, true);

	    this.nameContainer = createChild(this.container, "span", {
	      class: "ruleview-namecontainer"
	    });

	    // Property name, editable when focused.  Property name
	    // is committed when the editor is unfocused.
	    this.nameSpan = createChild(this.nameContainer, "span", {
	      class: "ruleview-propertyname theme-fg-color5",
	      tabindex: this.ruleEditor.isEditable ? "0" : "-1",
	    });

	    appendText(this.nameContainer, ": ");

	    // Create a span that will hold the property and semicolon.
	    // Use this span to create a slightly larger click target
	    // for the value.
	    this.valueContainer = createChild(this.container, "span", {
	      class: "ruleview-propertyvaluecontainer"
	    });

	    // Property value, editable when focused.  Changes to the
	    // property value are applied as they are typed, and reverted
	    // if the user presses escape.
	    this.valueSpan = createChild(this.valueContainer, "span", {
	      class: "ruleview-propertyvalue theme-fg-color1",
	      tabindex: this.ruleEditor.isEditable ? "0" : "-1",
	    });

	    // Storing the TextProperty on the elements for easy access
	    // (for instance by the tooltip)
	    this.valueSpan.textProperty = this.prop;
	    this.nameSpan.textProperty = this.prop;

	    // If the value is a color property we need to put it through the parser
	    // so that colors can be coerced into the default color type. This prevents
	    // us from thinking that when colors are coerced they have been changed by
	    // the user.
	    let outputParser = this.ruleView._outputParser;
	    let frag = outputParser.parseCssProperty(this.prop.name, this.prop.value);
	    let parsedValue = frag.textContent;

	    // Save the initial value as the last committed value,
	    // for restoring after pressing escape.
	    this.committed = { name: this.prop.name,
	                       value: parsedValue,
	                       priority: this.prop.priority };

	    appendText(this.valueContainer, ";");

	    this.warning = createChild(this.container, "div", {
	      class: "ruleview-warning",
	      hidden: "",
	      title: l10n("rule.warning.title"),
	    });

	    // Filter button that filters for the current property name and is
	    // displayed when the property is overridden by another rule.
	    this.filterProperty = createChild(this.container, "div", {
	      class: "ruleview-overridden-rule-filter",
	      hidden: "",
	      title: l10n("rule.filterProperty.title"),
	    });

	    this.filterProperty.addEventListener("click", event => {
	      this.ruleEditor.ruleView.setFilterStyles("`" + this.prop.name + "`");
	      event.stopPropagation();
	    }, false);

	    // Holds the viewers for the computed properties.
	    // will be populated in |_updateComputed|.
	    this.computed = createChild(this.element, "ul", {
	      class: "ruleview-computedlist",
	    });

	    // Only bind event handlers if the rule is editable.
	    if (this.ruleEditor.isEditable) {
	      this.enable.addEventListener("click", this._onEnableClicked, true);

	      this.nameContainer.addEventListener("click", (event) => {
	        // Clicks within the name shouldn't propagate any further.
	        event.stopPropagation();

	        // Forward clicks on nameContainer to the editable nameSpan
	        if (event.target === this.nameContainer) {
	          this.nameSpan.click();
	        }
	      }, false);

	      editableField({
	        start: this._onStartEditing,
	        element: this.nameSpan,
	        done: this._onNameDone,
	        destroy: this.updatePropertyState,
	        advanceChars: ":",
	        contentType: InplaceEditor.CONTENT_TYPES.CSS_PROPERTY,
	        popup: this.popup,
	        cssProperties: this.cssProperties
	      });

	      // Auto blur name field on multiple CSS rules get pasted in.
	      this.nameContainer.addEventListener("paste",
	        blurOnMultipleProperties(this.cssProperties), false);

	      this.valueContainer.addEventListener("click", (event) => {
	        // Clicks within the value shouldn't propagate any further.
	        event.stopPropagation();

	        // Forward clicks on valueContainer to the editable valueSpan
	        if (event.target === this.valueContainer) {
	          this.valueSpan.click();
	        }
	      }, false);

	      // The mousedown event could trigger a blur event on nameContainer, which
	      // will trigger a call to the update function. The update function clears
	      // valueSpan's markup. Thus the regular click event does not bubble up, and
	      // listener's callbacks are not called.
	      // So we need to remember where the user clicks in order to re-trigger the click
	      // after the valueSpan's markup is re-populated. We only need to track this for
	      // valueSpan's child elements, because direct click on valueSpan will always
	      // trigger a click event.
	      this.valueSpan.addEventListener("mousedown", (event) => {
	        let clickedEl = event.target;
	        if (clickedEl === this.valueSpan) {
	          return;
	        }
	        this._hasPendingClick = true;

	        let matchedSelector = ACTIONABLE_ELEMENTS_SELECTORS.find(
	          (selector) => clickedEl.matches(selector));
	        if (matchedSelector) {
	          let similarElements = [...this.valueSpan.querySelectorAll(matchedSelector)];
	          this._clickedElementOptions = {
	            selector: matchedSelector,
	            index: similarElements.indexOf(clickedEl)
	          };
	        }
	      }, false);

	      this.valueSpan.addEventListener("mouseup", (event) => {
	        this._clickedElementOptions = null;
	        this._hasPendingClick = false;
	      }, false);

	      this.valueSpan.addEventListener("click", (event) => {
	        let target = event.target;

	        if (target.nodeName === "a") {
	          event.stopPropagation();
	          event.preventDefault();
	          this.browserWindow.openUILinkIn(target.href, "tab");
	        }
	      }, false);

	      editableField({
	        start: this._onStartEditing,
	        element: this.valueSpan,
	        done: this._onValueDone,
	        destroy: this.update,
	        validate: this._onValidate,
	        advanceChars: advanceValidate,
	        contentType: InplaceEditor.CONTENT_TYPES.CSS_VALUE,
	        property: this.prop,
	        popup: this.popup,
	        multiline: true,
	        maxWidth: () => this.container.getBoundingClientRect().width,
	        cssProperties: this.cssProperties
	      });
	    }
	  },

	  /**
	   * Get the path from which to resolve requests for this
	   * rule's stylesheet.
	   *
	   * @return {String} the stylesheet's href.
	   */
	  get sheetHref() {
	    let domRule = this.rule.domRule;
	    if (domRule) {
	      return domRule.href || domRule.nodeHref;
	    }
	    return undefined;
	  },

	  /**
	   * Populate the span based on changes to the TextProperty.
	   */
	  update: function () {
	    if (this.ruleView.isDestroyed) {
	      return;
	    }

	    this.updatePropertyState();

	    let name = this.prop.name;
	    this.nameSpan.textContent = name;

	    // Combine the property's value and priority into one string for
	    // the value.
	    let store = this.rule.elementStyle.store;
	    let val = store.userProperties.getProperty(this.rule.style, name,
	                                               this.prop.value);
	    if (this.prop.priority) {
	      val += " !" + this.prop.priority;
	    }

	    let propDirty = store.userProperties.contains(this.rule.style, name);

	    if (propDirty) {
	      this.element.setAttribute("dirty", "");
	    } else {
	      this.element.removeAttribute("dirty");
	    }

	    let outputParser = this.ruleView._outputParser;
	    let parserOptions = {
	      colorSwatchClass: SHARED_SWATCH_CLASS + " " + COLOR_SWATCH_CLASS,
	      colorClass: "ruleview-color",
	      bezierSwatchClass: SHARED_SWATCH_CLASS + " " + BEZIER_SWATCH_CLASS,
	      bezierClass: "ruleview-bezier",
	      filterSwatchClass: SHARED_SWATCH_CLASS + " " + FILTER_SWATCH_CLASS,
	      filterClass: "ruleview-filter",
	      angleSwatchClass: SHARED_SWATCH_CLASS + " " + ANGLE_SWATCH_CLASS,
	      angleClass: "ruleview-angle",
	      defaultColorType: !propDirty,
	      urlClass: "theme-link",
	      baseURI: this.sheetHref
	    };
	    let frag = outputParser.parseCssProperty(name, val, parserOptions);
	    this.valueSpan.innerHTML = "";
	    this.valueSpan.appendChild(frag);

	    this.ruleView.emit("property-value-updated", this.valueSpan);

	    // Attach the color picker tooltip to the color swatches
	    this._colorSwatchSpans =
	      this.valueSpan.querySelectorAll("." + COLOR_SWATCH_CLASS);
	    if (this.ruleEditor.isEditable) {
	      for (let span of this._colorSwatchSpans) {
	        // Adding this swatch to the list of swatches our colorpicker
	        // knows about
	        this.ruleView.tooltips.colorPicker.addSwatch(span, {
	          onShow: this._onStartEditing,
	          onPreview: this._onSwatchPreview,
	          onCommit: this._onSwatchCommit,
	          onRevert: this._onSwatchRevert
	        });
	        span.on("unit-change", this._onSwatchCommit);
	        let title = l10n("rule.colorSwatch.tooltip");
	        span.setAttribute("title", title);
	      }
	    }

	    // Attach the cubic-bezier tooltip to the bezier swatches
	    this._bezierSwatchSpans =
	      this.valueSpan.querySelectorAll("." + BEZIER_SWATCH_CLASS);
	    if (this.ruleEditor.isEditable) {
	      for (let span of this._bezierSwatchSpans) {
	        // Adding this swatch to the list of swatches our colorpicker
	        // knows about
	        this.ruleView.tooltips.cubicBezier.addSwatch(span, {
	          onShow: this._onStartEditing,
	          onPreview: this._onSwatchPreview,
	          onCommit: this._onSwatchCommit,
	          onRevert: this._onSwatchRevert
	        });
	        let title = l10n("rule.bezierSwatch.tooltip");
	        span.setAttribute("title", title);
	      }
	    }

	    // Attach the filter editor tooltip to the filter swatch
	    let span = this.valueSpan.querySelector("." + FILTER_SWATCH_CLASS);
	    if (this.ruleEditor.isEditable) {
	      if (span) {
	        parserOptions.filterSwatch = true;

	        this.ruleView.tooltips.filterEditor.addSwatch(span, {
	          onShow: this._onStartEditing,
	          onPreview: this._onSwatchPreview,
	          onCommit: this._onSwatchCommit,
	          onRevert: this._onSwatchRevert
	        }, outputParser, parserOptions);
	        let title = l10n("rule.filterSwatch.tooltip");
	        span.setAttribute("title", title);
	      }
	    }

	    this.angleSwatchSpans =
	      this.valueSpan.querySelectorAll("." + ANGLE_SWATCH_CLASS);
	    if (this.ruleEditor.isEditable) {
	      for (let angleSpan of this.angleSwatchSpans) {
	        angleSpan.on("unit-change", this._onSwatchCommit);
	        let title = l10n("rule.angleSwatch.tooltip");
	        angleSpan.setAttribute("title", title);
	      }
	    }

	    // Now that we have updated the property's value, we might have a pending
	    // click on the value container. If we do, we have to trigger a click event
	    // on the right element.
	    if (this._hasPendingClick) {
	      this._hasPendingClick = false;
	      let elToClick;

	      if (this._clickedElementOptions !== null) {
	        let {selector, index} = this._clickedElementOptions;
	        elToClick = this.valueSpan.querySelectorAll(selector)[index];

	        this._clickedElementOptions = null;
	      }

	      if (!elToClick) {
	        elToClick = this.valueSpan;
	      }
	      elToClick.click();
	    }

	    // Populate the computed styles.
	    this._updateComputed();

	    // Update the rule property highlight.
	    this.ruleView._updatePropertyHighlight(this);
	  },

	  _onStartEditing: function () {
	    this.element.classList.remove("ruleview-overridden");
	    this.enable.style.visibility = "hidden";
	  },

	  /**
	   * Update the visibility of the enable checkbox, the warning indicator and
	   * the filter property, as well as the overriden state of the property.
	   */
	  updatePropertyState: function () {
	    if (this.prop.enabled) {
	      this.enable.style.removeProperty("visibility");
	      this.enable.setAttribute("checked", "");
	    } else {
	      this.enable.style.visibility = "visible";
	      this.enable.removeAttribute("checked");
	    }

	    this.warning.hidden = this.editing || this.isValid();
	    this.filterProperty.hidden = this.editing ||
	                                 !this.isValid() ||
	                                 !this.prop.overridden ||
	                                 this.ruleEditor.rule.isUnmatched;

	    if (!this.editing &&
	        (this.prop.overridden || !this.prop.enabled ||
	         !this.prop.isKnownProperty())) {
	      this.element.classList.add("ruleview-overridden");
	    } else {
	      this.element.classList.remove("ruleview-overridden");
	    }
	  },

	  /**
	   * Update the indicator for computed styles. The computed styles themselves
	   * are populated on demand, when they become visible.
	   */
	  _updateComputed: function () {
	    this.computed.innerHTML = "";

	    let showExpander = this.prop.computed.some(c => c.name !== this.prop.name);
	    this.expander.style.visibility = showExpander ? "visible" : "hidden";

	    this._populatedComputed = false;
	    if (this.expander.hasAttribute("open")) {
	      this._populateComputed();
	    }
	  },

	  /**
	   * Populate the list of computed styles.
	   */
	  _populateComputed: function () {
	    if (this._populatedComputed) {
	      return;
	    }
	    this._populatedComputed = true;

	    for (let computed of this.prop.computed) {
	      // Don't bother to duplicate information already
	      // shown in the text property.
	      if (computed.name === this.prop.name) {
	        continue;
	      }

	      let li = createChild(this.computed, "li", {
	        class: "ruleview-computed"
	      });

	      if (computed.overridden) {
	        li.classList.add("ruleview-overridden");
	      }

	      createChild(li, "span", {
	        class: "ruleview-propertyname theme-fg-color5",
	        textContent: computed.name
	      });
	      appendText(li, ": ");

	      let outputParser = this.ruleView._outputParser;
	      let frag = outputParser.parseCssProperty(
	        computed.name, computed.value, {
	          colorSwatchClass: "ruleview-swatch ruleview-colorswatch",
	          urlClass: "theme-link",
	          baseURI: this.sheetHref
	        }
	      );

	      // Store the computed property value that was parsed for output
	      computed.parsedValue = frag.textContent;

	      createChild(li, "span", {
	        class: "ruleview-propertyvalue theme-fg-color1",
	        child: frag
	      });

	      appendText(li, ";");

	      // Store the computed style element for easy access when highlighting
	      // styles
	      computed.element = li;
	    }
	  },

	  /**
	   * Handles clicks on the disabled property.
	   */
	  _onEnableClicked: function (event) {
	    let checked = this.enable.hasAttribute("checked");
	    if (checked) {
	      this.enable.removeAttribute("checked");
	    } else {
	      this.enable.setAttribute("checked", "");
	    }
	    this.prop.setEnabled(!checked);
	    event.stopPropagation();
	  },

	  /**
	   * Handles clicks on the computed property expander. If the computed list is
	   * open due to user expanding or style filtering, collapse the computed list
	   * and close the expander. Otherwise, add user-open attribute which is used to
	   * expand the computed list and tracks whether or not the computed list is
	   * expanded by manually by the user.
	   */
	  _onExpandClicked: function (event) {
	    if (this.computed.hasAttribute("filter-open") ||
	        this.computed.hasAttribute("user-open")) {
	      this.expander.removeAttribute("open");
	      this.computed.removeAttribute("filter-open");
	      this.computed.removeAttribute("user-open");
	    } else {
	      this.expander.setAttribute("open", "true");
	      this.computed.setAttribute("user-open", "");
	      this._populateComputed();
	    }

	    event.stopPropagation();
	  },

	  /**
	   * Expands the computed list when a computed property is matched by the style
	   * filtering. The filter-open attribute is used to track whether or not the
	   * computed list was toggled opened by the filter.
	   */
	  expandForFilter: function () {
	    if (!this.computed.hasAttribute("user-open")) {
	      this.expander.setAttribute("open", "true");
	      this.computed.setAttribute("filter-open", "");
	      this._populateComputed();
	    }
	  },

	  /**
	   * Collapses the computed list that was expanded by style filtering.
	   */
	  collapseForFilter: function () {
	    this.computed.removeAttribute("filter-open");

	    if (!this.computed.hasAttribute("user-open")) {
	      this.expander.removeAttribute("open");
	    }
	  },

	  /**
	   * Called when the property name's inplace editor is closed.
	   * Ignores the change if the user pressed escape, otherwise
	   * commits it.
	   *
	   * @param {String} value
	   *        The value contained in the editor.
	   * @param {Boolean} commit
	   *        True if the change should be applied.
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  _onNameDone: function (value, commit, direction) {
	    let isNameUnchanged = (!commit && !this.ruleEditor.isEditing) ||
	                          this.committed.name === value;
	    if (this.prop.value && isNameUnchanged) {
	      return;
	    }

	    // Remove a property if the name is empty
	    if (!value.trim()) {
	      this.remove(direction);
	      return;
	    }

	    // Remove a property if the property value is empty and the property
	    // value is not about to be focused
	    if (!this.prop.value &&
	        direction !== Services.focus.MOVEFOCUS_FORWARD) {
	      this.remove(direction);
	      return;
	    }

	    // Adding multiple rules inside of name field overwrites the current
	    // property with the first, then adds any more onto the property list.
	    let properties = parseDeclarations(this.cssProperties.isKnown, value);

	    if (properties.length) {
	      this.prop.setName(properties[0].name);
	      this.committed.name = this.prop.name;

	      if (!this.prop.enabled) {
	        this.prop.setEnabled(true);
	      }

	      if (properties.length > 1) {
	        this.prop.setValue(properties[0].value, properties[0].priority);
	        this.ruleEditor.addProperties(properties.slice(1), this.prop);
	      }
	    }
	  },

	  /**
	   * Remove property from style and the editors from DOM.
	   * Begin editing next or previous available property given the focus
	   * direction.
	   *
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  remove: function (direction) {
	    if (this._colorSwatchSpans && this._colorSwatchSpans.length) {
	      for (let span of this._colorSwatchSpans) {
	        this.ruleView.tooltips.colorPicker.removeSwatch(span);
	        span.off("unit-change", this._onSwatchCommit);
	      }
	    }

	    if (this.angleSwatchSpans && this.angleSwatchSpans.length) {
	      for (let span of this.angleSwatchSpans) {
	        span.off("unit-change", this._onSwatchCommit);
	      }
	    }

	    this.element.parentNode.removeChild(this.element);
	    this.ruleEditor.rule.editClosestTextProperty(this.prop, direction);
	    this.nameSpan.textProperty = null;
	    this.valueSpan.textProperty = null;
	    this.prop.remove();
	  },

	  /**
	   * Called when a value editor closes.  If the user pressed escape,
	   * revert to the value this property had before editing.
	   *
	   * @param {String} value
	   *        The value contained in the editor.
	   * @param {Boolean} commit
	   *        True if the change should be applied.
	   * @param {Number} direction
	   *        The move focus direction number.
	   */
	  _onValueDone: function (value = "", commit, direction) {
	    let parsedProperties = this._getValueAndExtraProperties(value);
	    let val = parseSingleValue(this.cssProperties.isKnown,
	                               parsedProperties.firstValue);
	    let isValueUnchanged = (!commit && !this.ruleEditor.isEditing) ||
	                           !parsedProperties.propertiesToAdd.length &&
	                           this.committed.value === val.value &&
	                           this.committed.priority === val.priority;
	    // If the value is not empty and unchanged, revert the property back to
	    // its original value and enabled or disabled state
	    if (value.trim() && isValueUnchanged) {
	      this.ruleEditor.rule.previewPropertyValue(this.prop, val.value,
	                                                val.priority);
	      this.rule.setPropertyEnabled(this.prop, this.prop.enabled);
	      return;
	    }

	    // First, set this property value (common case, only modified a property)
	    this.prop.setValue(val.value, val.priority);

	    if (!this.prop.enabled) {
	      this.prop.setEnabled(true);
	    }

	    this.committed.value = this.prop.value;
	    this.committed.priority = this.prop.priority;

	    // If needed, add any new properties after this.prop.
	    this.ruleEditor.addProperties(parsedProperties.propertiesToAdd, this.prop);

	    // If the input value is empty and the focus is moving forward to the next
	    // editable field, then remove the whole property.
	    // A timeout is used here to accurately check the state, since the inplace
	    // editor `done` and `destroy` events fire before the next editor
	    // is focused.
	    if (!value.trim() && direction !== Services.focus.MOVEFOCUS_BACKWARD) {
	      setTimeout(() => {
	        if (!this.editing) {
	          this.remove(direction);
	        }
	      }, 0);
	    }
	  },

	  /**
	   * Called when the swatch editor wants to commit a value change.
	   */
	  _onSwatchCommit: function () {
	    this._onValueDone(this.valueSpan.textContent, true);
	    this.update();
	  },

	  /**
	   * Called when the swatch editor wants to preview a value change.
	   */
	  _onSwatchPreview: function () {
	    this._previewValue(this.valueSpan.textContent);
	  },

	  /**
	   * Called when the swatch editor closes from an ESC. Revert to the original
	   * value of this property before editing.
	   */
	  _onSwatchRevert: function () {
	    this._previewValue(this.prop.value, true);
	    this.update();
	  },

	  /**
	   * Parse a value string and break it into pieces, starting with the
	   * first value, and into an array of additional properties (if any).
	   *
	   * Example: Calling with "red; width: 100px" would return
	   * { firstValue: "red", propertiesToAdd: [{ name: "width", value: "100px" }] }
	   *
	   * @param {String} value
	   *        The string to parse
	   * @return {Object} An object with the following properties:
	   *        firstValue: A string containing a simple value, like
	   *                    "red" or "100px!important"
	   *        propertiesToAdd: An array with additional properties, following the
	   *                         parseDeclarations format of {name,value,priority}
	   */
	  _getValueAndExtraProperties: function (value) {
	    // The inplace editor will prevent manual typing of multiple properties,
	    // but we need to deal with the case during a paste event.
	    // Adding multiple properties inside of value editor sets value with the
	    // first, then adds any more onto the property list (below this property).
	    let firstValue = value;
	    let propertiesToAdd = [];

	    let properties = parseDeclarations(this.cssProperties.isKnown, value);

	    // Check to see if the input string can be parsed as multiple properties
	    if (properties.length) {
	      // Get the first property value (if any), and any remaining
	      // properties (if any)
	      if (!properties[0].name && properties[0].value) {
	        firstValue = properties[0].value;
	        propertiesToAdd = properties.slice(1);
	      } else if (properties[0].name && properties[0].value) {
	        // In some cases, the value could be a property:value pair
	        // itself.  Join them as one value string and append
	        // potentially following properties
	        firstValue = properties[0].name + ": " + properties[0].value;
	        propertiesToAdd = properties.slice(1);
	      }
	    }

	    return {
	      propertiesToAdd: propertiesToAdd,
	      firstValue: firstValue
	    };
	  },

	  /**
	   * Live preview this property, without committing changes.
	   *
	   * @param {String} value
	   *        The value to set the current property to.
	   * @param {Boolean} reverting
	   *        True if we're reverting the previously previewed value
	   */
	  _previewValue: function (value, reverting = false) {
	    // Since function call is throttled, we need to make sure we are still
	    // editing, and any selector modifications have been completed
	    if (!reverting && (!this.editing || this.ruleEditor.isEditing)) {
	      return;
	    }

	    let val = parseSingleValue(this.cssProperties.isKnown, value);
	    this.ruleEditor.rule.previewPropertyValue(this.prop, val.value,
	                                              val.priority);
	  },

	  /**
	   * Validate this property. Does it make sense for this value to be assigned
	   * to this property name? This does not apply the property value
	   *
	   * @return {Boolean} true if the property value is valid, false otherwise.
	   */
	  isValid: function () {
	    return this.prop.isValid();
	  }
	};

	exports.TextPropertyEditor = TextPropertyEditor;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {PREF_ORIG_SOURCES} = __webpack_require__(180);
	const Services = __webpack_require__(1);
	const {Task} = __webpack_require__(15);

	const Menu = __webpack_require__(33);
	const MenuItem = __webpack_require__(34);

	const overlays = __webpack_require__(183);
	const clipboardHelper = __webpack_require__(207);

	const STYLE_INSPECTOR_PROPERTIES = "devtools-shared/locale/styleinspector.properties";
	const {LocalizationHelper} = __webpack_require__(56);
	const STYLE_INSPECTOR_L10N = new LocalizationHelper(STYLE_INSPECTOR_PROPERTIES);

	const PREF_ENABLE_MDN_DOCS_TOOLTIP =
	  "devtools.inspector.mdnDocsTooltip.enabled";

	/**
	 * Style inspector context menu
	 *
	 * @param {RuleView|ComputedView} view
	 *        RuleView or ComputedView instance controlling this menu
	 * @param {Object} options
	 *        Option menu configuration
	 */
	function StyleInspectorMenu(view, options) {
	  this.view = view;
	  this.inspector = this.view.inspector;
	  this.styleDocument = this.view.styleDocument;
	  this.styleWindow = this.view.styleWindow;

	  this.isRuleView = options.isRuleView;

	  this._onAddNewRule = this._onAddNewRule.bind(this);
	  this._onCopy = this._onCopy.bind(this);
	  this._onCopyColor = this._onCopyColor.bind(this);
	  this._onCopyImageDataUrl = this._onCopyImageDataUrl.bind(this);
	  this._onCopyLocation = this._onCopyLocation.bind(this);
	  this._onCopyPropertyDeclaration = this._onCopyPropertyDeclaration.bind(this);
	  this._onCopyPropertyName = this._onCopyPropertyName.bind(this);
	  this._onCopyPropertyValue = this._onCopyPropertyValue.bind(this);
	  this._onCopyRule = this._onCopyRule.bind(this);
	  this._onCopySelector = this._onCopySelector.bind(this);
	  this._onCopyUrl = this._onCopyUrl.bind(this);
	  this._onSelectAll = this._onSelectAll.bind(this);
	  this._onShowMdnDocs = this._onShowMdnDocs.bind(this);
	  this._onToggleOrigSources = this._onToggleOrigSources.bind(this);
	}

	module.exports = StyleInspectorMenu;

	StyleInspectorMenu.prototype = {
	  /**
	   * Display the style inspector context menu
	   */
	  show: function (event) {
	    try {
	      this._openMenu({
	        target: event.explicitOriginalTarget,
	        screenX: event.screenX,
	        screenY: event.screenY,
	      });
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  _openMenu: function ({ target, screenX = 0, screenY = 0 } = { }) {
	    // In the sidebar we do not have this.styleDocument.popupNode
	    // so we need to save the node ourselves.
	    this.styleDocument.popupNode = target;
	    this.styleWindow.focus();

	    let menu = new Menu();

	    let menuitemCopy = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copy"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copy.accessKey"),
	      click: () => {
	        this._onCopy();
	      },
	      disabled: !this._hasTextSelected(),
	    });
	    let menuitemCopyLocation = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyLocation"),
	      click: () => {
	        this._onCopyLocation();
	      },
	      visible: false,
	    });
	    let menuitemCopyRule = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyRule"),
	      click: () => {
	        this._onCopyRule();
	      },
	      visible: this.isRuleView,
	    });
	    let copyColorAccessKey = "styleinspector.contextmenu.copyColor.accessKey";
	    let menuitemCopyColor = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyColor"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(copyColorAccessKey),
	      click: () => {
	        this._onCopyColor();
	      },
	      visible: this._isColorPopup(),
	    });
	    let copyUrlAccessKey = "styleinspector.contextmenu.copyUrl.accessKey";
	    let menuitemCopyUrl = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyUrl"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(copyUrlAccessKey),
	      click: () => {
	        this._onCopyUrl();
	      },
	      visible: this._isImageUrl(),
	    });
	    let copyImageAccessKey = "styleinspector.contextmenu.copyImageDataUrl.accessKey";
	    let menuitemCopyImageDataUrl = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyImageDataUrl"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(copyImageAccessKey),
	      click: () => {
	        this._onCopyImageDataUrl();
	      },
	      visible: this._isImageUrl(),
	    });
	    let copyPropDeclarationLabel = "styleinspector.contextmenu.copyPropertyDeclaration";
	    let menuitemCopyPropertyDeclaration = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr(copyPropDeclarationLabel),
	      click: () => {
	        this._onCopyPropertyDeclaration();
	      },
	      visible: false,
	    });
	    let menuitemCopyPropertyName = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyPropertyName"),
	      click: () => {
	        this._onCopyPropertyName();
	      },
	      visible: false,
	    });
	    let menuitemCopyPropertyValue = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copyPropertyValue"),
	      click: () => {
	        this._onCopyPropertyValue();
	      },
	      visible: false,
	    });
	    let menuitemCopySelector = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.copySelector"),
	      click: () => {
	        this._onCopySelector();
	      },
	      visible: false,
	    });

	    this._clickedNodeInfo = this._getClickedNodeInfo();
	    if (this.isRuleView && this._clickedNodeInfo) {
	      switch (this._clickedNodeInfo.type) {
	        case overlays.VIEW_NODE_PROPERTY_TYPE :
	          menuitemCopyPropertyDeclaration.visible = true;
	          menuitemCopyPropertyName.visible = true;
	          break;
	        case overlays.VIEW_NODE_VALUE_TYPE :
	          menuitemCopyPropertyDeclaration.visible = true;
	          menuitemCopyPropertyValue.visible = true;
	          break;
	        case overlays.VIEW_NODE_SELECTOR_TYPE :
	          menuitemCopySelector.visible = true;
	          break;
	        case overlays.VIEW_NODE_LOCATION_TYPE :
	          menuitemCopyLocation.visible = true;
	          break;
	      }
	    }

	    menu.append(menuitemCopy);
	    menu.append(menuitemCopyLocation);
	    menu.append(menuitemCopyRule);
	    menu.append(menuitemCopyColor);
	    menu.append(menuitemCopyUrl);
	    menu.append(menuitemCopyImageDataUrl);
	    menu.append(menuitemCopyPropertyDeclaration);
	    menu.append(menuitemCopyPropertyName);
	    menu.append(menuitemCopyPropertyValue);
	    menu.append(menuitemCopySelector);

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    // Select All
	    let selectAllAccessKey = "styleinspector.contextmenu.selectAll.accessKey";
	    let menuitemSelectAll = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.selectAll"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(selectAllAccessKey),
	      click: () => {
	        this._onSelectAll();
	      },
	    });
	    menu.append(menuitemSelectAll);

	    menu.append(new MenuItem({
	      type: "separator",
	    }));

	    // Add new rule
	    let addRuleAccessKey = "styleinspector.contextmenu.addNewRule.accessKey";
	    let menuitemAddRule = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.addNewRule"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(addRuleAccessKey),
	      click: () => {
	        this._onAddNewRule();
	      },
	      visible: this.isRuleView,
	      disabled: !this.isRuleView ||
	                this.inspector.selection.isAnonymousNode(),
	    });
	    menu.append(menuitemAddRule);

	    // Show MDN Docs
	    let mdnDocsAccessKey = "styleinspector.contextmenu.showMdnDocs.accessKey";
	    let menuitemShowMdnDocs = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.showMdnDocs"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(mdnDocsAccessKey),
	      click: () => {
	        this._onShowMdnDocs();
	      },
	      visible: (Services.prefs.getBoolPref(PREF_ENABLE_MDN_DOCS_TOOLTIP) &&
	                                                    this._isPropertyName()),
	    });
	    menu.append(menuitemShowMdnDocs);

	    // Show Original Sources
	    let sourcesAccessKey = "styleinspector.contextmenu.toggleOrigSources.accessKey";
	    let menuitemSources = new MenuItem({
	      label: STYLE_INSPECTOR_L10N.getStr("styleinspector.contextmenu.toggleOrigSources"),
	      accesskey: STYLE_INSPECTOR_L10N.getStr(sourcesAccessKey),
	      click: () => {
	        this._onToggleOrigSources();
	      },
	      type: "checkbox",
	      checked: Services.prefs.getBoolPref(PREF_ORIG_SOURCES),
	    });
	    menu.append(menuitemSources);

	    menu.popup(screenX, screenY, this.inspector._toolbox);
	    return menu;
	  },

	  _hasTextSelected: function () {
	    let hasTextSelected;
	    let selection = this.styleWindow.getSelection();

	    let node = this._getClickedNode();
	    if (node.nodeName == "input" || node.nodeName == "textarea") {
	      let { selectionStart, selectionEnd } = node;
	      hasTextSelected = isFinite(selectionStart) && isFinite(selectionEnd)
	        && selectionStart !== selectionEnd;
	    } else {
	      hasTextSelected = selection.toString() && !selection.isCollapsed;
	    }

	    return hasTextSelected;
	  },

	  /**
	   * Get the type of the currently clicked node
	   */
	  _getClickedNodeInfo: function () {
	    let node = this._getClickedNode();
	    return this.view.getNodeInfo(node);
	  },

	  /**
	   * A helper that determines if the popup was opened with a click to a color
	   * value and saves the color to this._colorToCopy.
	   *
	   * @return {Boolean}
	   *         true if click on color opened the popup, false otherwise.
	   */
	  _isColorPopup: function () {
	    this._colorToCopy = "";

	    let container = this._getClickedNode();
	    if (!container) {
	      return false;
	    }

	    let isColorNode = el => el.dataset && "color" in el.dataset;

	    while (!isColorNode(container)) {
	      container = container.parentNode;
	      if (!container) {
	        return false;
	      }
	    }

	    this._colorToCopy = container.dataset.color;
	    return true;
	  },

	  _isPropertyName: function () {
	    let nodeInfo = this._getClickedNodeInfo();
	    if (!nodeInfo) {
	      return false;
	    }
	    return nodeInfo.type == overlays.VIEW_NODE_PROPERTY_TYPE;
	  },

	  /**
	   * Check if the current node (clicked node) is an image URL
	   *
	   * @return {Boolean} true if the node is an image url
	   */
	  _isImageUrl: function () {
	    let nodeInfo = this._getClickedNodeInfo();
	    if (!nodeInfo) {
	      return false;
	    }
	    return nodeInfo.type == overlays.VIEW_NODE_IMAGE_URL_TYPE;
	  },

	  /**
	   * Get the DOM Node container for the current popupNode.
	   * If popupNode is a textNode, return the parent node, otherwise return
	   * popupNode itself.
	   *
	   * @return {DOMNode}
	   */
	  _getClickedNode: function () {
	    let container = null;
	    let node = this.styleDocument.popupNode;

	    if (node) {
	      let isTextNode = node.nodeType == node.TEXT_NODE;
	      container = isTextNode ? node.parentElement : node;
	    }

	    return container;
	  },

	  /**
	   * Select all text.
	   */
	  _onSelectAll: function () {
	    let selection = this.styleWindow.getSelection();
	    selection.selectAllChildren(this.view.element);
	  },

	  /**
	   * Copy the most recently selected color value to clipboard.
	   */
	  _onCopy: function () {
	    this.view.copySelection(this.styleDocument.popupNode);
	  },

	  /**
	   * Copy the most recently selected color value to clipboard.
	   */
	  _onCopyColor: function () {
	    clipboardHelper.copyString(this._colorToCopy);
	  },

	  /*
	   * Retrieve the url for the selected image and copy it to the clipboard
	   */
	  _onCopyUrl: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value.url);
	  },

	  /**
	   * Retrieve the image data for the selected image url and copy it to the
	   * clipboard
	   */
	  _onCopyImageDataUrl: Task.async(function* () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    let message;
	    try {
	      let inspectorFront = this.inspector.inspector;
	      let imageUrl = this._clickedNodeInfo.value.url;
	      let data = yield inspectorFront.getImageDataFromURL(imageUrl);
	      message = yield data.data.string();
	    } catch (e) {
	      message =
	        STYLE_INSPECTOR_L10N.getStr("styleinspector.copyImageDataUrlError");
	    }

	    clipboardHelper.copyString(message);
	  }),

	  /**
	   *  Show docs from MDN for a CSS property.
	   */
	  _onShowMdnDocs: function () {
	    let cssPropertyName = this.styleDocument.popupNode.textContent;
	    let anchor = this.styleDocument.popupNode.parentNode;
	    let cssDocsTooltip = this.view.tooltips.cssDocs;
	    cssDocsTooltip.show(anchor, cssPropertyName);
	  },

	  /**
	   * Add a new rule to the current element.
	   */
	  _onAddNewRule: function () {
	    this.view._onAddRule();
	  },

	  /**
	   * Copy the rule source location of the current clicked node.
	   */
	  _onCopyLocation: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value);
	  },

	  /**
	   * Copy the rule property declaration of the current clicked node.
	   */
	  _onCopyPropertyDeclaration: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    let textProp = this._clickedNodeInfo.value.textProperty;
	    clipboardHelper.copyString(textProp.stringifyProperty());
	  },

	  /**
	   * Copy the rule property name of the current clicked node.
	   */
	  _onCopyPropertyName: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value.property);
	  },

	  /**
	   * Copy the rule property value of the current clicked node.
	   */
	  _onCopyPropertyValue: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value.value);
	  },

	  /**
	   * Copy the rule of the current clicked node.
	   */
	  _onCopyRule: function () {
	    let ruleEditor =
	      this.styleDocument.popupNode.parentNode.offsetParent._ruleEditor;
	    let rule = ruleEditor.rule;
	    clipboardHelper.copyString(rule.stringifyRule());
	  },

	  /**
	   * Copy the rule selector of the current clicked node.
	   */
	  _onCopySelector: function () {
	    if (!this._clickedNodeInfo) {
	      return;
	    }

	    clipboardHelper.copyString(this._clickedNodeInfo.value);
	  },

	  /**
	   *  Toggle the original sources pref.
	   */
	  _onToggleOrigSources: function () {
	    let isEnabled = Services.prefs.getBoolPref(PREF_ORIG_SOURCES);
	    Services.prefs.setBoolPref(PREF_ORIG_SOURCES, !isEnabled);
	  },

	  destroy: function () {
	    this.popupNode = null;
	    this.styleDocument.popupNode = null;
	    this.view = null;
	    this.inspector = null;
	    this.styleDocument = null;
	    this.styleWindow = null;
	  }
	};


/***/ },
/* 207 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	// Helpers for clipboard handling.

	/* globals document */

	"use strict";

	function copyString(string) {
	  let doCopy = function (e) {
	    e.clipboardData.setData("text/plain", string);
	    e.preventDefault();
	  };

	  document.addEventListener("copy", doCopy);
	  document.execCommand("copy", false, null);
	  document.removeEventListener("copy", doCopy);
	}

	function getCurrentFlavors() {
	  // See bug 1295692.
	  return [];
	}

	function getData() {
	  // See bug 1295692.
	  return null;
	}

	exports.copyString = copyString;
	exports.getCurrentFlavors = getCurrentFlavors;
	exports.getData = getData;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const HTML_NS = "http://www.w3.org/1999/xhtml";
	const Services = __webpack_require__(1);
	const {gDevTools} = __webpack_require__(38);
	const {HTMLTooltip} = __webpack_require__(186);
	const EventEmitter = __webpack_require__(6);

	let itemIdCounter = 0;
	/**
	 * Autocomplete popup UI implementation.
	 *
	 * @constructor
	 * @param {Toolbox} toolbox
	 *        The devtools toolbox required to instanciate the HTMLTooltip.
	 * @param {Object} options
	 *        An object consiting any of the following options:
	 *        - listId {String} The id for the list <LI> element.
	 *        - position {String} The position for the tooltip ("top" or "bottom").
	 *        - theme {String} String related to the theme of the popup
	 *        - autoSelect {Boolean} Boolean to allow the first entry of the popup
	 *          panel to be automatically selected when the popup shows.
	 *        - onSelect {String} Callback called when the selected index is updated.
	 *        - onClick {String} Callback called when the autocomplete popup receives a click
	 *          event. The selectedIndex will already be updated if need be.
	 */
	function AutocompletePopup(toolbox, options = {}) {
	  EventEmitter.decorate(this);

	  this._document = toolbox.doc;

	  this.autoSelect = options.autoSelect || false;
	  this.position = options.position || "bottom";
	  let theme = options.theme || "dark";

	  this.onSelectCallback = options.onSelect;
	  this.onClickCallback = options.onClick;

	  // If theme is auto, use the devtools.theme pref
	  if (theme === "auto") {
	    theme = Services.prefs.getCharPref("devtools.theme");
	    this.autoThemeEnabled = true;
	    // Setup theme change listener.
	    this._handleThemeChange = this._handleThemeChange.bind(this);
	    gDevTools.on("pref-changed", this._handleThemeChange);
	  }

	  // Create HTMLTooltip instance
	  this._tooltip = new HTMLTooltip(toolbox);
	  this._tooltip.panel.classList.add(
	    "devtools-autocomplete-popup",
	    "devtools-monospace",
	    theme + "-theme");
	  // Stop this appearing as an alert to accessibility.
	  this._tooltip.panel.setAttribute("role", "presentation");

	  this._list = this._document.createElementNS(HTML_NS, "ul");
	  this._list.setAttribute("flex", "1");

	  // The list clone will be inserted in the same document as the anchor, and will receive
	  // a copy of the main list innerHTML to allow screen readers to access the list.
	  this._listClone = this._document.createElementNS(HTML_NS, "ul");
	  this._listClone.className = "devtools-autocomplete-list-aria-clone";

	  if (options.listId) {
	    this._list.setAttribute("id", options.listId);
	  }
	  this._list.className = "devtools-autocomplete-listbox " + theme + "-theme";

	  this._tooltip.setContent(this._list);

	  this.onClick = this.onClick.bind(this);
	  this._list.addEventListener("click", this.onClick, false);

	  // Array of raw autocomplete items
	  this.items = [];
	  // Map of autocompleteItem to HTMLElement
	  this.elements = new WeakMap();

	  this.selectedIndex = -1;
	}
	exports.AutocompletePopup = AutocompletePopup;

	AutocompletePopup.prototype = {
	  _document: null,
	  _tooltip: null,
	  _list: null,

	  onSelect: function (e) {
	    if (this.onSelectCallback) {
	      this.onSelectCallback(e);
	    }
	  },

	  onClick: function (e) {
	    let item = e.target.closest(".autocomplete-item");
	    if (item && typeof item.dataset.index !== "undefined") {
	      this.selectedIndex = parseInt(item.dataset.index, 10);
	    }

	    this.emit("popup-click");
	    if (this.onClickCallback) {
	      this.onClickCallback(e);
	    }
	  },

	  /**
	   * Open the autocomplete popup panel.
	   *
	   * @param {nsIDOMNode} anchor
	   *        Optional node to anchor the panel to.
	   * @param {Number} xOffset
	   *        Horizontal offset in pixels from the left of the node to the left
	   *        of the popup.
	   * @param {Number} yOffset
	   *        Vertical offset in pixels from the top of the node to the starting
	   *        of the popup.
	   * @param {Number} index
	   *        The position of item to select.
	   */
	  openPopup: function (anchor, xOffset = 0, yOffset = 0, index) {
	    this.__maxLabelLength = -1;
	    this._updateSize();

	    // Retrieve the anchor's document active element to add accessibility metadata.
	    this._activeElement = anchor.ownerDocument.activeElement;

	    this._tooltip.show(anchor, {
	      x: xOffset,
	      y: yOffset,
	      position: this.position,
	    });

	    this._tooltip.once("shown", () => {
	      if (this.autoSelect) {
	        this.selectItemAtIndex(index);
	      }

	      this.emit("popup-opened");
	    });
	  },

	  /**
	   * Select item at the provided index.
	   *
	   * @param {Number} index
	   *        The position of the item to select.
	   */
	  selectItemAtIndex: function (index) {
	    if (typeof index !== "number") {
	      // If no index was provided, select the item closest to the input.
	      let isAboveInput = this.position === "top";
	      index = isAboveInput ? this.itemCount - 1 : 0;
	    }
	    this.selectedIndex = index;
	  },

	  /**
	   * Hide the autocomplete popup panel.
	   */
	  hidePopup: function () {
	    this._tooltip.once("hidden", () => {
	      this.emit("popup-closed");
	    });

	    this._clearActiveDescendant();
	    this._activeElement = null;
	    this._tooltip.hide();
	  },

	  /**
	   * Check if the autocomplete popup is open.
	   */
	  get isOpen() {
	    return this._tooltip && this._tooltip.isVisible();
	  },

	  /**
	   * Destroy the object instance. Please note that the panel DOM elements remain
	   * in the DOM, because they might still be in use by other instances of the
	   * same code. It is the responsability of the client code to perform DOM
	   * cleanup.
	   */
	  destroy: function () {
	    if (this.isOpen) {
	      this.hidePopup();
	    }

	    this._list.removeEventListener("click", this.onClick, false);

	    if (this.autoThemeEnabled) {
	      gDevTools.off("pref-changed", this._handleThemeChange);
	    }

	    this._list.remove();
	    this._listClone.remove();
	    this._tooltip.destroy();
	    this._document = null;
	    this._list = null;
	    this._tooltip = null;
	  },

	  /**
	   * Get the autocomplete items array.
	   *
	   * @param {Number} index
	   *        The index of the item what is wanted.
	   *
	   * @return {Object} The autocomplete item at index index.
	   */
	  getItemAtIndex: function (index) {
	    return this.items[index];
	  },

	  /**
	   * Get the autocomplete items array.
	   *
	   * @return {Array} The array of autocomplete items.
	   */
	  getItems: function () {
	    // Return a copy of the array to avoid side effects from the caller code.
	    return this.items.slice(0);
	  },

	  /**
	   * Set the autocomplete items list, in one go.
	   *
	   * @param {Array} items
	   *        The list of items you want displayed in the popup list.
	   * @param {Number} index
	   *        The position of the item to select.
	   */
	  setItems: function (items, index) {
	    this.clearItems();
	    items.forEach(this.appendItem, this);

	    if (this.isOpen && this.autoSelect) {
	      this.selectItemAtIndex(index);
	    }
	  },

	  __maxLabelLength: -1,

	  get _maxLabelLength() {
	    if (this.__maxLabelLength !== -1) {
	      return this.__maxLabelLength;
	    }

	    let max = 0;
	    for (let {label, count} of this.items) {
	      if (count) {
	        label += count + "";
	      }
	      max = Math.max(label.length, max);
	    }

	    this.__maxLabelLength = max;
	    return this.__maxLabelLength;
	  },

	  /**
	   * Update the panel size to fit the content.
	   */
	  _updateSize: function () {
	    if (!this._tooltip) {
	      return;
	    }

	    this._list.style.width = (this._maxLabelLength + 3) + "ch";
	    let selectedItem = this.selectedItem;
	    if (selectedItem) {
	      this._scrollElementIntoViewIfNeeded(this.elements.get(selectedItem));
	    }
	  },

	  _scrollElementIntoViewIfNeeded: function (element) {
	    let quads = element.getBoxQuads({relativeTo: this._tooltip.panel});
	    if (!quads || !quads[0]) {
	      return;
	    }

	    let {top, height} = quads[0].bounds;
	    let containerHeight = this._tooltip.panel.getBoundingClientRect().height;
	    if (top < 0) {
	      // Element is above container.
	      element.scrollIntoView(true);
	    } else if ((top + height) > containerHeight) {
	      // Element is beloew container.
	      element.scrollIntoView(false);
	    }
	  },

	  /**
	   * Clear all the items from the autocomplete list.
	   */
	  clearItems: function () {
	    // Reset the selectedIndex to -1 before clearing the list
	    this.selectedIndex = -1;
	    this._list.innerHTML = "";
	    this.__maxLabelLength = -1;
	    this.items = [];
	    this.elements = new WeakMap();
	  },

	  /**
	   * Getter for the index of the selected item.
	   *
	   * @type {Number}
	   */
	  get selectedIndex() {
	    return this._selectedIndex;
	  },

	  /**
	   * Setter for the selected index.
	   *
	   * @param {Number} index
	   *        The number (index) of the item you want to select in the list.
	   */
	  set selectedIndex(index) {
	    let previousSelected = this._list.querySelector(".autocomplete-selected");
	    if (previousSelected) {
	      previousSelected.classList.remove("autocomplete-selected");
	    }

	    let item = this.items[index];
	    if (this.isOpen && item) {
	      let element = this.elements.get(item);

	      element.classList.add("autocomplete-selected");
	      this._scrollElementIntoViewIfNeeded(element);
	      this._setActiveDescendant(element.id);
	    } else {
	      this._clearActiveDescendant();
	    }
	    this._selectedIndex = index;

	    if (this.isOpen && item && this.onSelectCallback) {
	      // Call the user-defined select callback if defined.
	      this.onSelectCallback();
	    }
	  },

	  /**
	   * Getter for the selected item.
	   * @type Object
	   */
	  get selectedItem() {
	    return this.items[this._selectedIndex];
	  },

	  /**
	   * Setter for the selected item.
	   *
	   * @param {Object} item
	   *        The object you want selected in the list.
	   */
	  set selectedItem(item) {
	    let index = this.items.indexOf(item);
	    if (index !== -1 && this.isOpen) {
	      this.selectedIndex = index;
	    }
	  },

	  /**
	   * Update the aria-activedescendant attribute on the current active element for
	   * accessibility.
	   *
	   * @param {String} id
	   *        The id (as in DOM id) of the currently selected autocomplete suggestion
	   */
	  _setActiveDescendant: function (id) {
	    if (!this._activeElement) {
	      return;
	    }

	    // Make sure the list clone is in the same document as the anchor.
	    let anchorDoc = this._activeElement.ownerDocument;
	    if (!this._listClone.parentNode || this._listClone.ownerDocument !== anchorDoc) {
	      anchorDoc.documentElement.appendChild(this._listClone);
	    }

	    // Update the clone content to match the current list content.
	    this._listClone.innerHTML = this._list.innerHTML;

	    this._activeElement.setAttribute("aria-activedescendant", id);
	  },

	  /**
	   * Clear the aria-activedescendant attribute on the current active element.
	   */
	  _clearActiveDescendant: function () {
	    if (!this._activeElement) {
	      return;
	    }

	    this._activeElement.removeAttribute("aria-activedescendant");
	  },

	  /**
	   * Append an item into the autocomplete list.
	   *
	   * @param {Object} item
	   *        The item you want appended to the list.
	   *        The item object can have the following properties:
	   *        - label {String} Property which is used as the displayed value.
	   *        - preLabel {String} [Optional] The String that will be displayed
	   *                   before the label indicating that this is the already
	   *                   present text in the input box, and label is the text
	   *                   that will be auto completed. When this property is
	   *                   present, |preLabel.length| starting characters will be
	   *                   removed from label.
	   *        - count {Number} [Optional] The number to represent the count of
	   *                autocompleted label.
	   */
	  appendItem: function (item) {
	    let listItem = this._document.createElementNS(HTML_NS, "li");
	    // Items must have an id for accessibility.
	    listItem.setAttribute("id", "autocomplete-item-" + itemIdCounter++);
	    listItem.className = "autocomplete-item";
	    listItem.setAttribute("data-index", this.items.length);
	    if (this.direction) {
	      listItem.setAttribute("dir", this.direction);
	    }
	    let label = this._document.createElementNS(HTML_NS, "span");
	    label.textContent = item.label;
	    label.className = "autocomplete-value";
	    if (item.preLabel) {
	      let preDesc = this._document.createElementNS(HTML_NS, "span");
	      preDesc.textContent = item.preLabel;
	      preDesc.className = "initial-value";
	      listItem.appendChild(preDesc);
	      label.textContent = item.label.slice(item.preLabel.length);
	    }
	    listItem.appendChild(label);
	    if (item.count && item.count > 1) {
	      let countDesc = this._document.createElementNS(HTML_NS, "span");
	      countDesc.textContent = item.count;
	      countDesc.setAttribute("flex", "1");
	      countDesc.className = "autocomplete-count";
	      listItem.appendChild(countDesc);
	    }

	    this._list.appendChild(listItem);
	    this.items.push(item);
	    this.elements.set(item, listItem);
	  },

	  /**
	   * Remove an item from the popup list.
	   *
	   * @param {Object} item
	   *        The item you want removed.
	   */
	  removeItem: function (item) {
	    if (!this.items.includes(item)) {
	      return;
	    }

	    let itemIndex = this.items.indexOf(item);
	    let selectedIndex = this.selectedIndex;

	    // Remove autocomplete item.
	    this.items.splice(itemIndex, 1);

	    // Remove corresponding DOM element from the elements WeakMap and from the DOM.
	    let elementToRemove = this.elements.get(item);
	    this.elements.delete(elementToRemove);
	    elementToRemove.remove();

	    if (itemIndex <= selectedIndex) {
	      // If the removed item index was before or equal to the selected index, shift the
	      // selected index by 1.
	      this.selectedIndex = Math.max(0, selectedIndex - 1);
	    }
	  },

	  /**
	   * Getter for the number of items in the popup.
	   * @type {Number}
	   */
	  get itemCount() {
	    return this.items.length;
	  },

	  /**
	   * Getter for the height of each item in the list.
	   *
	   * @type {Number}
	   */
	  get _itemsPerPane() {
	    if (this.items.length) {
	      let listHeight = this._tooltip.panel.clientHeight;
	      let element = this.elements.get(this.items[0]);
	      let elementHeight = element.getBoundingClientRect().height;
	      return Math.floor(listHeight / elementHeight);
	    }
	    return 0;
	  },

	  /**
	   * Select the next item in the list.
	   *
	   * @return {Object}
	   *         The newly selected item object.
	   */
	  selectNextItem: function () {
	    if (this.selectedIndex < (this.items.length - 1)) {
	      this.selectedIndex++;
	    } else {
	      this.selectedIndex = 0;
	    }
	    return this.selectedItem;
	  },

	  /**
	   * Select the previous item in the list.
	   *
	   * @return {Object}
	   *         The newly-selected item object.
	   */
	  selectPreviousItem: function () {
	    if (this.selectedIndex > 0) {
	      this.selectedIndex--;
	    } else {
	      this.selectedIndex = this.items.length - 1;
	    }

	    return this.selectedItem;
	  },

	  /**
	   * Select the top-most item in the next page of items or
	   * the last item in the list.
	   *
	   * @return {Object}
	   *         The newly-selected item object.
	   */
	  selectNextPageItem: function () {
	    let nextPageIndex = this.selectedIndex + this._itemsPerPane + 1;
	    this.selectedIndex = Math.min(nextPageIndex, this.itemCount - 1);
	    return this.selectedItem;
	  },

	  /**
	   * Select the bottom-most item in the previous page of items,
	   * or the first item in the list.
	   *
	   * @return {Object}
	   *         The newly-selected item object.
	   */
	  selectPreviousPageItem: function () {
	    let prevPageIndex = this.selectedIndex - this._itemsPerPane - 1;
	    this.selectedIndex = Math.max(prevPageIndex, 0);
	    return this.selectedItem;
	  },

	  /**
	   * Manages theme switching for the popup based on the devtools.theme pref.
	   *
	   * @private
	   *
	   * @param {String} event
	   *        The name of the event. In this case, "pref-changed".
	   * @param {Object} data
	   *        An object passed by the emitter of the event. In this case, the
	   *        object consists of three properties:
	   *        - pref {String} The name of the preference that was modified.
	   *        - newValue {Object} The new value of the preference.
	   *        - oldValue {Object} The old value of the preference.
	   */
	  _handleThemeChange: function (event, data) {
	    if (data.pref === "devtools.theme") {
	      this._tooltip.panel.classList.toggle(data.oldValue + "-theme", false);
	      this._tooltip.panel.classList.toggle(data.newValue + "-theme", true);
	      this._list.classList.toggle(data.oldValue + "-theme", false);
	      this._list.classList.toggle(data.newValue + "-theme", true);
	    }
	  },

	  /**
	   * Used by tests.
	   */
	  get _panel() {
	    return this._tooltip.panel;
	  },

	  /**
	   * Used by tests.
	   */
	  get _window() {
	    return this._document.defaultView;
	  },
	};


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	'use strict';

	module.metadata = {
	  "stability": "experimental"
	};

	const { Ci } = __webpack_require__(9);
	const XUL = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';

	function eventTarget(frame) {
	  return getDocShell(frame).chromeEventHandler;
	}
	exports.eventTarget = eventTarget;

	function getDocShell(frame) {
	  let { frameLoader } = frame.QueryInterface(Ci.nsIFrameLoaderOwner);
	  return frameLoader && frameLoader.docShell;
	}
	exports.getDocShell = getDocShell;

	/**
	 * Creates a XUL `browser` element in a privileged document.
	 * @params {nsIDOMDocument} document
	 * @params {String} options.type
	 *    By default is 'content' for possible values see:
	 *    https://developer.mozilla.org/en/XUL/iframe#a-browser.type
	 * @params {String} options.uri
	 *    URI of the document to be loaded into created frame.
	 * @params {Boolean} options.remote
	 *    If `true` separate process will be used for this frame, also in such
	 *    case all the following options are ignored.
	 * @params {Boolean} options.allowAuth
	 *    Whether to allow auth dialogs. Defaults to `false`.
	 * @params {Boolean} options.allowJavascript
	 *    Whether to allow Javascript execution. Defaults to `false`.
	 * @params {Boolean} options.allowPlugins
	 *    Whether to allow plugin execution. Defaults to `false`.
	 */
	function create(target, options) {
	  target = target instanceof Ci.nsIDOMDocument ? target.documentElement :
	           target instanceof Ci.nsIDOMWindow ? target.document.documentElement :
	           target;
	  options = options || {};
	  let remote = options.remote || false;
	  let namespaceURI = options.namespaceURI || XUL;
	  let isXUL = namespaceURI === XUL;
	  let nodeName = isXUL && options.browser ? 'browser' : 'iframe';
	  let document = target.ownerDocument;

	  let frame = document.createElementNS(namespaceURI, nodeName);
	  // Type="content" is mandatory to enable stuff here:
	  // http://mxr.mozilla.org/mozilla-central/source/content/base/src/nsFrameLoader.cpp#1776
	  frame.setAttribute('type', options.type || 'content');
	  frame.setAttribute('src', options.uri || 'about:blank');

	  // Must set the remote attribute before attaching the frame to the document
	  if (remote && isXUL) {
	    // We remove XBL binding to avoid execution of code that is not going to
	    // work because browser has no docShell attribute in remote mode
	    // (for example)
	    frame.setAttribute('style', '-moz-binding: none;');
	    frame.setAttribute('remote', 'true');
	  }

	  target.appendChild(frame);

	  // Load in separate process if `options.remote` is `true`.
	  // http://mxr.mozilla.org/mozilla-central/source/content/base/src/nsFrameLoader.cpp#1347
	  if (remote && !isXUL) {
	    frame.QueryInterface(Ci.nsIMozBrowserFrame);
	    frame.createRemoteFrameLoader(null);
	  }

	  // If browser is remote it won't have a `docShell`.
	  if (!remote) {
	    let docShell = getDocShell(frame);
	    docShell.allowAuth = options.allowAuth || false;
	    docShell.allowJavascript = options.allowJavascript || false;
	    docShell.allowPlugins = options.allowPlugins || false;
	    docShell.allowWindowControl = options.allowWindowControl || false;
	  }

	  return frame;
	}
	exports.create = create;

	function swapFrameLoaders(from, to) {
	  return from.QueryInterface(Ci.nsIFrameLoaderOwner).swapFrameLoaders(to);
	}
	exports.swapFrameLoaders = swapFrameLoaders;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19)(module)))

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {Task} = __webpack_require__(15);
	const {InplaceEditor, editableItem} =
	      __webpack_require__(203);
	const {ReflowFront} = __webpack_require__(211);
	const {LocalizationHelper} = __webpack_require__(56);
	const {getCssProperties} = __webpack_require__(16);

	const STRINGS_URI = "devtools/locale/shared.properties";
	const STRINGS_INSPECTOR = "devtools-shared/locale/styleinspector.properties";
	const SHARED_L10N = new LocalizationHelper(STRINGS_URI);
	const INSPECTOR_L10N = new LocalizationHelper(STRINGS_INSPECTOR);
	const NUMERIC = /^-?[\d\.]+$/;
	const LONG_TEXT_ROTATE_LIMIT = 3;

	/**
	 * An instance of EditingSession tracks changes that have been made during the
	 * modification of box model values. All of these changes can be reverted by
	 * calling revert. The main parameter is the LayoutView that created it.
	 *
	 * @param inspector The inspector panel.
	 * @param doc       A DOM document that can be used to test style rules.
	 * @param rules     An array of the style rules defined for the node being
	 *                  edited. These should be in order of priority, least
	 *                  important first.
	 */
	function EditingSession({inspector, doc, elementRules}) {
	  this._doc = doc;
	  this._rules = elementRules;
	  this._modifications = new Map();
	  this._cssProperties = getCssProperties(inspector.toolbox);
	}

	EditingSession.prototype = {
	  /**
	   * Gets the value of a single property from the CSS rule.
	   *
	   * @param {StyleRuleFront} rule The CSS rule.
	   * @param {String} property The name of the property.
	   * @return {String} The value.
	   */
	  getPropertyFromRule: function (rule, property) {
	    // Use the parsed declarations in the StyleRuleFront object if available.
	    let index = this.getPropertyIndex(property, rule);
	    if (index !== -1) {
	      return rule.declarations[index].value;
	    }

	    // Fallback to parsing the cssText locally otherwise.
	    let dummyStyle = this._element.style;
	    dummyStyle.cssText = rule.cssText;
	    return dummyStyle.getPropertyValue(property);
	  },

	  /**
	   * Returns the current value for a property as a string or the empty string if
	   * no style rules affect the property.
	   *
	   * @param property  The name of the property as a string
	   */
	  getProperty: function (property) {
	    // Create a hidden element for getPropertyFromRule to use
	    let div = this._doc.createElement("div");
	    div.setAttribute("style", "display: none");
	    this._doc.getElementById("sidebar-panel-computedview").appendChild(div);
	    this._element = this._doc.createElement("p");
	    div.appendChild(this._element);

	    // As the rules are in order of priority we can just iterate until we find
	    // the first that defines a value for the property and return that.
	    for (let rule of this._rules) {
	      let value = this.getPropertyFromRule(rule, property);
	      if (value !== "") {
	        div.remove();
	        return value;
	      }
	    }
	    div.remove();
	    return "";
	  },

	  /**
	   * Get the index of a given css property name in a CSS rule.
	   * Or -1, if there are no properties in the rule yet.
	   * @param {String} name The property name.
	   * @param {StyleRuleFront} rule Optional, defaults to the element style rule.
	   * @return {Number} The property index in the rule.
	   */
	  getPropertyIndex: function (name, rule = this._rules[0]) {
	    let elementStyleRule = this._rules[0];
	    if (!elementStyleRule.declarations.length) {
	      return -1;
	    }

	    return elementStyleRule.declarations.findIndex(p => p.name === name);
	  },

	  /**
	   * Sets a number of properties on the node.
	   * @param properties  An array of properties, each is an object with name and
	   *                    value properties. If the value is "" then the property
	   *                    is removed.
	   * @return {Promise} Resolves when the modifications are complete.
	   */
	  setProperties: Task.async(function* (properties) {
	    for (let property of properties) {
	      // Get a RuleModificationList or RuleRewriter helper object from the
	      // StyleRuleActor to make changes to CSS properties.
	      // Note that RuleRewriter doesn't support modifying several properties at
	      // once, so we do this in a sequence here.
	      let modifications = this._rules[0].startModifyingProperties(
	        this._cssProperties);

	      // Remember the property so it can be reverted.
	      if (!this._modifications.has(property.name)) {
	        this._modifications.set(property.name,
	          this.getPropertyFromRule(this._rules[0], property.name));
	      }

	      // Find the index of the property to be changed, or get the next index to
	      // insert the new property at.
	      let index = this.getPropertyIndex(property.name);
	      if (index === -1) {
	        index = this._rules[0].declarations.length;
	      }

	      if (property.value == "") {
	        modifications.removeProperty(index, property.name);
	      } else {
	        modifications.setProperty(index, property.name, property.value, "");
	      }

	      yield modifications.apply();
	    }
	  }),

	  /**
	   * Reverts all of the property changes made by this instance.
	   * @return {Promise} Resolves when all properties have been reverted.
	   */
	  revert: Task.async(function* () {
	    // Revert each property that we modified previously, one by one. See
	    // setProperties for information about why.
	    for (let [property, value] of this._modifications) {
	      let modifications = this._rules[0].startModifyingProperties(
	        this._cssProperties);

	      // Find the index of the property to be reverted.
	      let index = this.getPropertyIndex(property);

	      if (value != "") {
	        // If the property doesn't exist anymore, insert at the beginning of the
	        // rule.
	        if (index === -1) {
	          index = 0;
	        }
	        modifications.setProperty(index, property, value, "");
	      } else {
	        // If the property doesn't exist anymore, no need to remove it. It had
	        // not been added after all.
	        if (index === -1) {
	          continue;
	        }
	        modifications.removeProperty(index, property);
	      }

	      yield modifications.apply();
	    }
	  }),

	  destroy: function () {
	    this._doc = null;
	    this._rules = null;
	    this._modifications.clear();
	  }
	};

	/**
	 * The layout-view panel
	 * @param {InspectorPanel} inspector
	 *        An instance of the inspector-panel currently loaded in the toolbox
	 * @param {Document} document
	 *        The document that will contain the layout view.
	 */
	function LayoutView(inspector, document) {
	  this.inspector = inspector;
	  this.doc = document;
	  this.wrapper = this.doc.getElementById("layout-wrapper");
	  this.container = this.doc.getElementById("layout-container");
	  this.expander = this.doc.getElementById("layout-expander");
	  this.sizeLabel = this.doc.querySelector(".layout-size > span");
	  this.sizeHeadingLabel = this.doc.getElementById("layout-element-size");
	  this._geometryEditorHighlighter = null;
	  this._cssProperties = getCssProperties(inspector.toolbox);

	  this.init();
	}

	LayoutView.prototype = {
	  init: function () {
	    this.update = this.update.bind(this);

	    this.onNewSelection = this.onNewSelection.bind(this);
	    this.inspector.selection.on("new-node-front", this.onNewSelection);

	    this.onNewNode = this.onNewNode.bind(this);
	    this.inspector.sidebar.on("computedview-selected", this.onNewNode);

	    this.onSidebarSelect = this.onSidebarSelect.bind(this);
	    this.inspector.sidebar.on("select", this.onSidebarSelect);

	    this.onToggleExpander = this.onToggleExpander.bind(this);
	    this.expander.addEventListener("click", this.onToggleExpander);
	    let header = this.doc.getElementById("layout-header");
	    header.addEventListener("dblclick", this.onToggleExpander);

	    this.onFilterComputedView = this.onFilterComputedView.bind(this);
	    this.inspector.on("computed-view-filtered",
	      this.onFilterComputedView);

	    this.onPickerStarted = this.onPickerStarted.bind(this);
	    this.onMarkupViewLeave = this.onMarkupViewLeave.bind(this);
	    this.onMarkupViewNodeHover = this.onMarkupViewNodeHover.bind(this);
	    this.onWillNavigate = this.onWillNavigate.bind(this);

	    this.initBoxModelHighlighter();

	    // Store for the different dimensions of the node.
	    // 'selector' refers to the element that holds the value in view.xhtml;
	    // 'property' is what we are measuring;
	    // 'value' is the computed dimension, computed in update().
	    this.map = {
	      position: {
	        selector: "#layout-element-position",
	        property: "position",
	        value: undefined
	      },
	      marginTop: {
	        selector: ".layout-margin.layout-top > span",
	        property: "margin-top",
	        value: undefined
	      },
	      marginBottom: {
	        selector: ".layout-margin.layout-bottom > span",
	        property: "margin-bottom",
	        value: undefined
	      },
	      marginLeft: {
	        selector: ".layout-margin.layout-left > span",
	        property: "margin-left",
	        value: undefined
	      },
	      marginRight: {
	        selector: ".layout-margin.layout-right > span",
	        property: "margin-right",
	        value: undefined
	      },
	      paddingTop: {
	        selector: ".layout-padding.layout-top > span",
	        property: "padding-top",
	        value: undefined
	      },
	      paddingBottom: {
	        selector: ".layout-padding.layout-bottom > span",
	        property: "padding-bottom",
	        value: undefined
	      },
	      paddingLeft: {
	        selector: ".layout-padding.layout-left > span",
	        property: "padding-left",
	        value: undefined
	      },
	      paddingRight: {
	        selector: ".layout-padding.layout-right > span",
	        property: "padding-right",
	        value: undefined
	      },
	      borderTop: {
	        selector: ".layout-border.layout-top > span",
	        property: "border-top-width",
	        value: undefined
	      },
	      borderBottom: {
	        selector: ".layout-border.layout-bottom > span",
	        property: "border-bottom-width",
	        value: undefined
	      },
	      borderLeft: {
	        selector: ".layout-border.layout-left > span",
	        property: "border-left-width",
	        value: undefined
	      },
	      borderRight: {
	        selector: ".layout-border.layout-right > span",
	        property: "border-right-width",
	        value: undefined
	      }
	    };

	    // Make each element the dimensions editable
	    for (let i in this.map) {
	      if (i == "position") {
	        continue;
	      }

	      let dimension = this.map[i];
	      editableItem({
	        element: this.doc.querySelector(dimension.selector)
	      }, (element, event) => {
	        this.initEditor(element, event, dimension);
	      });
	    }

	    this.onNewNode();

	    let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	    this.onGeometryButtonClick = this.onGeometryButtonClick.bind(this);
	    nodeGeometry.addEventListener("click", this.onGeometryButtonClick);
	  },

	  initBoxModelHighlighter: function () {
	    let highlightElts = this.doc.querySelectorAll("#layout-container *[title]");
	    this.onHighlightMouseOver = this.onHighlightMouseOver.bind(this);
	    this.onHighlightMouseOut = this.onHighlightMouseOut.bind(this);

	    for (let element of highlightElts) {
	      element.addEventListener("mouseover", this.onHighlightMouseOver, true);
	      element.addEventListener("mouseout", this.onHighlightMouseOut, true);
	    }
	  },

	  /**
	   * Start listening to reflows in the current tab.
	   */
	  trackReflows: function () {
	    if (!this.reflowFront) {
	      let toolbox = this.inspector.toolbox;
	      if (toolbox.target.form.reflowActor) {
	        this.reflowFront = ReflowFront(toolbox.target.client,
	                                       toolbox.target.form);
	      } else {
	        return;
	      }
	    }

	    this.reflowFront.on("reflows", this.update);
	    this.reflowFront.start();
	  },

	  /**
	   * Stop listening to reflows in the current tab.
	   */
	  untrackReflows: function () {
	    if (!this.reflowFront) {
	      return;
	    }

	    this.reflowFront.off("reflows", this.update);
	    this.reflowFront.stop();
	  },

	  /**
	   * Called when the user clicks on one of the editable values in the layoutview
	   */
	  initEditor: function (element, event, dimension) {
	    let { property } = dimension;
	    let session = new EditingSession(this);
	    let initialValue = session.getProperty(property);

	    let editor = new InplaceEditor({
	      element: element,
	      initial: initialValue,
	      contentType: InplaceEditor.CONTENT_TYPES.CSS_VALUE,
	      property: {
	        name: dimension.property
	      },
	      start: self => {
	        self.elt.parentNode.classList.add("layout-editing");
	      },

	      change: value => {
	        if (NUMERIC.test(value)) {
	          value += "px";
	        }

	        let properties = [
	          { name: property, value: value }
	        ];

	        if (property.substring(0, 7) == "border-") {
	          let bprop = property.substring(0, property.length - 5) + "style";
	          let style = session.getProperty(bprop);
	          if (!style || style == "none" || style == "hidden") {
	            properties.push({ name: bprop, value: "solid" });
	          }
	        }

	        session.setProperties(properties).catch(e => console.error(e));
	      },

	      done: (value, commit) => {
	        editor.elt.parentNode.classList.remove("layout-editing");
	        if (!commit) {
	          session.revert().then(() => {
	            session.destroy();
	          }, e => console.error(e));
	        }
	      },
	      cssProperties: this._cssProperties
	    }, event);
	  },

	  /**
	   * Is the layoutview visible in the sidebar.
	   * @return {Boolean}
	   */
	  isViewVisible: function () {
	    return this.inspector &&
	           this.inspector.sidebar.getCurrentTabID() == "computedview";
	  },

	  /**
	   * Is the layoutview visible in the sidebar and is the current node valid to
	   * be displayed in the view.
	   * @return {Boolean}
	   */
	  isViewVisibleAndNodeValid: function () {
	    return this.isViewVisible() &&
	           this.inspector.selection.isConnected() &&
	           this.inspector.selection.isElementNode();
	  },

	  /**
	   * Destroy the nodes. Remove listeners.
	   */
	  destroy: function () {
	    let highlightElts = this.doc.querySelectorAll("#layout-container *[title]");

	    for (let element of highlightElts) {
	      element.removeEventListener("mouseover", this.onHighlightMouseOver, true);
	      element.removeEventListener("mouseout", this.onHighlightMouseOut, true);
	    }

	    this.expander.removeEventListener("click", this.onToggleExpander);
	    let header = this.doc.getElementById("layout-header");
	    header.removeEventListener("dblclick", this.onToggleExpander);

	    let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	    nodeGeometry.removeEventListener("click", this.onGeometryButtonClick);

	    this.inspector.off("picker-started", this.onPickerStarted);

	    // Inspector Panel will destroy `markup` object on "will-navigate" event,
	    // therefore we have to check if it's still available in case LayoutView
	    // is destroyed immediately after.
	    if (this.inspector.markup) {
	      this.inspector.markup.off("leave", this.onMarkupViewLeave);
	      this.inspector.markup.off("node-hover", this.onMarkupViewNodeHover);
	    }

	    this.inspector.sidebar.off("computedview-selected", this.onNewNode);
	    this.inspector.selection.off("new-node-front", this.onNewSelection);
	    this.inspector.sidebar.off("select", this.onSidebarSelect);
	    this.inspector._target.off("will-navigate", this.onWillNavigate);
	    this.inspector.off("computed-view-filtered", this.onFilterComputedView);

	    this.inspector = null;
	    this.doc = null;
	    this.wrapper = null;
	    this.container = null;
	    this.expander = null;
	    this.sizeLabel = null;
	    this.sizeHeadingLabel = null;

	    if (this.reflowFront) {
	      this.untrackReflows();
	      this.reflowFront.destroy();
	      this.reflowFront = null;
	    }
	  },

	  onSidebarSelect: function (e, sidebar) {
	    this.setActive(sidebar === "computedview");
	  },

	  /**
	   * Selection 'new-node-front' event handler.
	   */
	  onNewSelection: function () {
	    let done = this.inspector.updating("computed-view");
	    this.onNewNode()
	      .then(() => this.hideGeometryEditor())
	      .then(done, (err) => {
	        console.error(err);
	        done();
	      }).catch(console.error);
	  },

	  /**
	   * @return a promise that resolves when the view has been updated
	   */
	  onNewNode: function () {
	    this.setActive(this.isViewVisibleAndNodeValid());
	    return this.update();
	  },

	  onHighlightMouseOver: function (e) {
	    let region = e.target.getAttribute("data-box");
	    if (!region) {
	      return;
	    }

	    this.showBoxModel({
	      region,
	      showOnly: region,
	      onlyRegionArea: true
	    });
	  },

	  onHighlightMouseOut: function () {
	    this.hideBoxModel();
	  },

	  onGeometryButtonClick: function ({target}) {
	    if (target.hasAttribute("checked")) {
	      target.removeAttribute("checked");
	      this.hideGeometryEditor();
	    } else {
	      target.setAttribute("checked", "true");
	      this.showGeometryEditor();
	    }
	  },

	  onPickerStarted: function () {
	    this.hideGeometryEditor();
	  },

	  onToggleExpander: function () {
	    let isOpen = this.expander.hasAttribute("open");

	    if (isOpen) {
	      this.container.hidden = true;
	      this.expander.removeAttribute("open");
	    } else {
	      this.container.hidden = false;
	      this.expander.setAttribute("open", "");
	    }
	  },

	  onMarkupViewLeave: function () {
	    this.showGeometryEditor(true);
	  },

	  onMarkupViewNodeHover: function () {
	    this.hideGeometryEditor(false);
	  },

	  onWillNavigate: function () {
	    this._geometryEditorHighlighter.release().catch(console.error);
	    this._geometryEditorHighlighter = null;
	  },

	  /**
	   * Event handler that responds to the computed view being filtered
	   * @param {String} reason
	   * @param {Boolean} hidden
	   *        Whether or not to hide the layout wrapper
	   */
	  onFilterComputedView: function (reason, hidden) {
	    this.wrapper.hidden = hidden;
	  },

	  /**
	   * Stop tracking reflows and hide all values when no node is selected or the
	   * layout-view is hidden, otherwise track reflows and show values.
	   * @param {Boolean} isActive
	   */
	  setActive: function (isActive) {
	    if (isActive === this.isActive) {
	      return;
	    }
	    this.isActive = isActive;

	    if (isActive) {
	      this.trackReflows();
	    } else {
	      this.untrackReflows();
	    }
	  },

	  /**
	   * Compute the dimensions of the node and update the values in
	   * the inspector.xul document.
	   * @return a promise that will be resolved when complete.
	   */
	  update: function () {
	    let lastRequest = Task.spawn((function* () {
	      if (!this.isViewVisibleAndNodeValid()) {
	        this.wrapper.hidden = true;
	        this.inspector.emit("layoutview-updated");
	        return null;
	      }

	      let node = this.inspector.selection.nodeFront;
	      let layout = yield this.inspector.pageStyle.getLayout(node, {
	        autoMargins: this.isActive
	      });
	      let styleEntries = yield this.inspector.pageStyle.getApplied(node, {});

	      yield this.updateGeometryButton();

	      // If a subsequent request has been made, wait for that one instead.
	      if (this._lastRequest != lastRequest) {
	        return this._lastRequest;
	      }

	      this._lastRequest = null;
	      let width = layout.width;
	      let height = layout.height;
	      let newLabel = SHARED_L10N.getFormatStr("dimensions", width, height);

	      if (this.sizeHeadingLabel.textContent != newLabel) {
	        this.sizeHeadingLabel.textContent = newLabel;
	      }

	      for (let i in this.map) {
	        let property = this.map[i].property;
	        if (!(property in layout)) {
	          // Depending on the actor version, some properties
	          // might be missing.
	          continue;
	        }
	        let parsedValue = parseFloat(layout[property]);
	        if (Number.isNaN(parsedValue)) {
	          // Not a number. We use the raw string.
	          // Useful for "position" for example.
	          this.map[i].value = layout[property];
	        } else {
	          this.map[i].value = parsedValue;
	        }
	      }

	      let margins = layout.autoMargins;
	      if ("top" in margins) {
	        this.map.marginTop.value = "auto";
	      }
	      if ("right" in margins) {
	        this.map.marginRight.value = "auto";
	      }
	      if ("bottom" in margins) {
	        this.map.marginBottom.value = "auto";
	      }
	      if ("left" in margins) {
	        this.map.marginLeft.value = "auto";
	      }

	      for (let i in this.map) {
	        let selector = this.map[i].selector;
	        let span = this.doc.querySelector(selector);
	        this.updateSourceRuleTooltip(span, this.map[i].property, styleEntries);
	        if (span.textContent.length > 0 &&
	            span.textContent == this.map[i].value) {
	          continue;
	        }
	        span.textContent = this.map[i].value;
	        this.manageOverflowingText(span);
	      }

	      width -= this.map.borderLeft.value + this.map.borderRight.value +
	               this.map.paddingLeft.value + this.map.paddingRight.value;
	      width = parseFloat(width.toPrecision(6));
	      height -= this.map.borderTop.value + this.map.borderBottom.value +
	                this.map.paddingTop.value + this.map.paddingBottom.value;
	      height = parseFloat(height.toPrecision(6));

	      let newValue = width + "\u00D7" + height;
	      if (this.sizeLabel.textContent != newValue) {
	        this.sizeLabel.textContent = newValue;
	      }

	      this.elementRules = styleEntries.map(e => e.rule);

	      this.wrapper.hidden = false;

	      this.inspector.emit("layoutview-updated");
	      return null;
	    }).bind(this)).catch(console.error);

	    this._lastRequest = lastRequest;
	    return this._lastRequest;
	  },

	  /**
	   * Update the text in the tooltip shown when hovering over a value to provide
	   * information about the source CSS rule that sets this value.
	   * @param {DOMNode} el The element that will receive the tooltip.
	   * @param {String} property The name of the CSS property for the tooltip.
	   * @param {Array} rules An array of applied rules retrieved by
	   * styleActor.getApplied.
	   */
	  updateSourceRuleTooltip: function (el, property, rules) {
	    // Dummy element used to parse the cssText of applied rules.
	    let dummyEl = this.doc.createElement("div");

	    // Rules are in order of priority so iterate until we find the first that
	    // defines a value for the property.
	    let sourceRule, value;
	    for (let {rule} of rules) {
	      dummyEl.style.cssText = rule.cssText;
	      value = dummyEl.style.getPropertyValue(property);
	      if (value !== "") {
	        sourceRule = rule;
	        break;
	      }
	    }

	    let title = property;
	    if (sourceRule && sourceRule.selectors) {
	      title += "\n" + sourceRule.selectors.join(", ");
	    }
	    if (sourceRule && sourceRule.parentStyleSheet) {
	      if (sourceRule.parentStyleSheet.href) {
	        title += "\n" + sourceRule.parentStyleSheet.href + ":" + sourceRule.line;
	      } else {
	        title += "\n" + INSPECTOR_L10N.getStr("rule.sourceInline") +
	          ":" + sourceRule.line;
	      }
	    }

	    el.setAttribute("title", title);
	  },

	  /**
	   * Show the box-model highlighter on the currently selected element
	   * @param {Object} options Options passed to the highlighter actor
	   */
	  showBoxModel: function (options = {}) {
	    let toolbox = this.inspector.toolbox;
	    let nodeFront = this.inspector.selection.nodeFront;

	    toolbox.highlighterUtils.highlightNodeFront(nodeFront, options);
	  },

	  /**
	   * Hide the box-model highlighter on the currently selected element
	   */
	  hideBoxModel: function () {
	    let toolbox = this.inspector.toolbox;

	    toolbox.highlighterUtils.unhighlight();
	  },

	  /**
	   * Show the geometry editor highlighter on the currently selected element
	   * @param {Boolean} [showOnlyIfActive=false]
	   *   Indicates if the Geometry Editor should be shown only if it's active but
	   *   hidden.
	   */
	  showGeometryEditor: function (showOnlyIfActive = false) {
	    let toolbox = this.inspector.toolbox;
	    let nodeFront = this.inspector.selection.nodeFront;
	    let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	    let isActive = nodeGeometry.hasAttribute("checked");

	    if (showOnlyIfActive && !isActive) {
	      return;
	    }

	    if (this._geometryEditorHighlighter) {
	      this._geometryEditorHighlighter.show(nodeFront).catch(console.error);
	      return;
	    }

	    // instantiate Geometry Editor highlighter
	    toolbox.highlighterUtils
	      .getHighlighterByType("GeometryEditorHighlighter").then(highlighter => {
	        highlighter.show(nodeFront).catch(console.error);
	        this._geometryEditorHighlighter = highlighter;

	        // Hide completely the geometry editor if the picker is clicked
	        toolbox.on("picker-started", this.onPickerStarted);

	        // Temporary hide the geometry editor
	        this.inspector.markup.on("leave", this.onMarkupViewLeave);
	        this.inspector.markup.on("node-hover", this.onMarkupViewNodeHover);

	        // Release the actor on will-navigate event
	        this.inspector._target.once("will-navigate", this.onWillNavigate);
	      });
	  },

	  /**
	   * Hide the geometry editor highlighter on the currently selected element
	   * @param {Boolean} [updateButton=true]
	   *   Indicates if the Geometry Editor's button needs to be unchecked too
	   */
	  hideGeometryEditor: function (updateButton = true) {
	    if (this._geometryEditorHighlighter) {
	      this._geometryEditorHighlighter.hide().catch(console.error);
	    }

	    if (updateButton) {
	      let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	      nodeGeometry.removeAttribute("checked");
	    }
	  },

	  /**
	   * Update the visibility and the state of the geometry editor button,
	   * based on the selected node.
	   */
	  updateGeometryButton: Task.async(function* () {
	    let node = this.inspector.selection.nodeFront;
	    let isEditable = false;

	    if (node) {
	      isEditable = yield this.inspector.pageStyle.isPositionEditable(node);
	    }

	    let nodeGeometry = this.doc.getElementById("layout-geometry-editor");
	    nodeGeometry.style.visibility = isEditable ? "visible" : "hidden";
	  }),

	  manageOverflowingText: function (span) {
	    let classList = span.parentNode.classList;

	    if (classList.contains("layout-left") ||
	        classList.contains("layout-right")) {
	      let force = span.textContent.length > LONG_TEXT_ROTATE_LIMIT;
	      classList.toggle("layout-rotate", force);
	    }
	  }
	};

	exports.LayoutView = LayoutView;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {reflowSpec} = __webpack_require__(212);
	const protocol = __webpack_require__(17);

	/**
	 * Usage example of the reflow front:
	 *
	 * let front = ReflowFront(toolbox.target.client, toolbox.target.form);
	 * front.on("reflows", this._onReflows);
	 * front.start();
	 * // now wait for events to come
	 */
	const ReflowFront = protocol.FrontClassWithSpec(reflowSpec, {
	  initialize: function (client, {reflowActor}) {
	    protocol.Front.prototype.initialize.call(this, client, {actor: reflowActor});
	    this.manage(this);
	  },

	  destroy: function () {
	    protocol.Front.prototype.destroy.call(this);
	  },
	});

	exports.ReflowFront = ReflowFront;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {Arg, generateActorSpec} = __webpack_require__(17);

	const reflowSpec = generateActorSpec({
	  typeName: "reflow",

	  events: {
	    /**
	     * The reflows event is emitted when reflows have been detected. The event
	     * is sent with an array of reflows that occured. Each item has the
	     * following properties:
	     * - start {Number}
	     * - end {Number}
	     * - isInterruptible {Boolean}
	     */
	    reflows: {
	      type: "reflows",
	      reflows: Arg(0, "array:json")
	    }
	  },

	  methods: {
	    start: {oneway: true},
	    stop: {oneway: true},
	  },
	});

	exports.reflowSpec = reflowSpec;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {gDevTools} = __webpack_require__(38);
	const Services = __webpack_require__(1);

	const DEFAULT_PREVIEW_TEXT = "Abc";
	const PREVIEW_UPDATE_DELAY = 150;

	const {Task} = __webpack_require__(15);

	function FontInspector(inspector, window) {
	  this.inspector = inspector;
	  this.pageStyle = this.inspector.pageStyle;
	  this.chromeDoc = window.document;
	  this.init();
	}

	FontInspector.prototype = {
	  init: function () {
	    this.update = this.update.bind(this);
	    this.onNewNode = this.onNewNode.bind(this);
	    this.onThemeChanged = this.onThemeChanged.bind(this);
	    this.inspector.selection.on("new-node-front", this.onNewNode);
	    this.inspector.sidebar.on("fontinspector-selected", this.onNewNode);
	    this.showAll = this.showAll.bind(this);
	    this.showAllLink = this.chromeDoc.getElementById("font-showall");
	    this.showAllLink.addEventListener("click", this.showAll);
	    this.previewTextChanged = this.previewTextChanged.bind(this);
	    this.previewInput =
	      this.chromeDoc.getElementById("font-preview-text-input");
	    this.previewInput.addEventListener("input", this.previewTextChanged);

	    // Listen for theme changes as the color of the previews depend on the theme
	    gDevTools.on("theme-switched", this.onThemeChanged);

	    this.update();
	  },

	  /**
	   * Is the fontinspector visible in the sidebar?
	   */
	  isActive: function () {
	    return this.inspector.sidebar &&
	           this.inspector.sidebar.getCurrentTabID() == "fontinspector";
	  },

	  /**
	   * Remove listeners.
	   */
	  destroy: function () {
	    this.chromeDoc = null;
	    this.inspector.sidebar.off("fontinspector-selected", this.onNewNode);
	    this.inspector.selection.off("new-node-front", this.onNewNode);
	    this.showAllLink.removeEventListener("click", this.showAll);
	    this.previewInput.removeEventListener("input", this.previewTextChanged);

	    gDevTools.off("theme-switched", this.onThemeChanged);

	    if (this._previewUpdateTimeout) {
	      clearTimeout(this._previewUpdateTimeout);
	    }
	  },

	  /**
	   * Selection 'new-node' event handler.
	   */
	  onNewNode: function () {
	    if (this.isActive() &&
	        this.inspector.selection.isConnected() &&
	        this.inspector.selection.isElementNode()) {
	      this.undim();
	      this.update();
	    } else {
	      this.dim();
	    }
	  },

	  /**
	   * The text to use for previews. Returns either the value user has typed to
	   * the preview input or DEFAULT_PREVIEW_TEXT if the input is empty or contains
	   * only whitespace.
	   */
	  getPreviewText: function () {
	    let inputText = this.previewInput.value.trim();
	    if (inputText === "") {
	      return DEFAULT_PREVIEW_TEXT;
	    }

	    return inputText;
	  },

	  /**
	   * Preview input 'input' event handler.
	   */
	  previewTextChanged: function () {
	    if (this._previewUpdateTimeout) {
	      clearTimeout(this._previewUpdateTimeout);
	    }

	    this._previewUpdateTimeout = setTimeout(() => {
	      this.update(this._lastUpdateShowedAllFonts);
	    }, PREVIEW_UPDATE_DELAY);
	  },

	  /**
	   * Callback for the theme-switched event.
	   */
	  onThemeChanged: function (event, frame) {
	    if (frame === this.chromeDoc.defaultView) {
	      this.update(this._lastUpdateShowedAllFonts);
	    }
	  },

	  /**
	   * Hide the font list. No node are selected.
	   */
	  dim: function () {
	    let panel = this.chromeDoc.getElementById("sidebar-panel-fontinspector");
	    panel.classList.add("dim");
	    this.clear();
	  },

	  /**
	   * Show the font list. A node is selected.
	   */
	  undim: function () {
	    let panel = this.chromeDoc.getElementById("sidebar-panel-fontinspector");
	    panel.classList.remove("dim");
	  },

	  /**
	   * Clears the font list.
	   */
	  clear: function () {
	    this.chromeDoc.querySelector("#all-fonts").innerHTML = "";
	  },

	 /**
	  * Retrieve all the font info for the selected node and display it.
	  */
	  update: Task.async(function* (showAllFonts) {
	    let node = this.inspector.selection.nodeFront;
	    let panel = this.chromeDoc.getElementById("sidebar-panel-fontinspector");

	    if (!node ||
	        !this.isActive() ||
	        !this.inspector.selection.isConnected() ||
	        !this.inspector.selection.isElementNode() ||
	        panel.classList.contains("dim")) {
	      return;
	    }

	    this._lastUpdateShowedAllFonts = showAllFonts;

	    // Assume light theme colors as the default (see also bug 1118179).
	    let fillStyle = (Services.prefs.getCharPref("devtools.theme") == "dark") ?
	        "white" : "black";

	    let options = {
	      includePreviews: true,
	      previewText: this.getPreviewText(),
	      previewFillStyle: fillStyle
	    };

	    let fonts = [];
	    if (showAllFonts) {
	      fonts = yield this.pageStyle.getAllUsedFontFaces(options)
	                      .then(null, console.error);
	    } else {
	      fonts = yield this.pageStyle.getUsedFontFaces(node, options)
	                      .then(null, console.error);
	    }

	    if (!fonts || !fonts.length) {
	      // No fonts to display. Clear the previously shown fonts.
	      this.clear();
	      return;
	    }

	    for (let font of fonts) {
	      font.previewUrl = yield font.preview.data.string();
	    }

	    // in case we've been destroyed in the meantime
	    if (!this.chromeDoc) {
	      return;
	    }

	    // Make room for the new fonts.
	    this.clear();

	    for (let font of fonts) {
	      this.render(font);
	    }

	    this.inspector.emit("fontinspector-updated");
	  }),

	  /**
	   * Display the information of one font.
	   */
	  render: function (font) {
	    let s = this.chromeDoc.querySelector("#font-template > section");
	    s = s.cloneNode(true);

	    s.querySelector(".font-name").textContent = font.name;
	    s.querySelector(".font-css-name").textContent = font.CSSFamilyName;

	    if (font.URI) {
	      s.classList.add("is-remote");
	    } else {
	      s.classList.add("is-local");
	    }

	    let formatElem = s.querySelector(".font-format");
	    if (font.format) {
	      formatElem.textContent = font.format;
	    } else {
	      formatElem.hidden = true;
	    }

	    s.querySelector(".font-url").value = font.URI;

	    if (font.rule) {
	      // This is the @font-face{…} code.
	      let cssText = font.ruleText;

	      s.classList.add("has-code");
	      s.querySelector(".font-css-code").textContent = cssText;
	    }
	    let preview = s.querySelector(".font-preview");
	    preview.src = font.previewUrl;

	    this.chromeDoc.querySelector("#all-fonts").appendChild(s);
	  },

	  /**
	   * Show all fonts for the document (including iframes)
	   */
	  showAll: function () {
	    this.update(true);
	  },
	};

	exports.FontInspector = FontInspector;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);

	const {ELLIPSIS} = __webpack_require__(56);

	const MAX_LABEL_LENGTH = 40;

	const NS_XHTML = "http://www.w3.org/1999/xhtml";
	const SCROLL_REPEAT_MS = 100;

	const EventEmitter = __webpack_require__(6);
	const {KeyShortcuts} = __webpack_require__(13);

	// Some margin may be required for visible element detection.
	const SCROLL_MARGIN = 1;

	/**
	 * Component to replicate functionality of XUL arrowscrollbox
	 * for breadcrumbs
	 *
	 * @param {Window} win The window containing the breadcrumbs
	 * @parem {DOMNode} container The element in which to put the scroll box
	 */
	function ArrowScrollBox(win, container) {
	  this.win = win;
	  this.doc = win.document;
	  this.container = container;
	  EventEmitter.decorate(this);
	  this.init();
	}

	ArrowScrollBox.prototype = {

	  // Scroll behavior, exposed for testing
	  scrollBehavior: "smooth",

	  /**
	   * Build the HTML, add to the DOM and start listening to
	   * events
	   */
	  init: function () {
	    this.constructHtml();

	    this.onUnderflow();

	    this.onScroll = this.onScroll.bind(this);
	    this.onStartBtnClick = this.onStartBtnClick.bind(this);
	    this.onEndBtnClick = this.onEndBtnClick.bind(this);
	    this.onStartBtnDblClick = this.onStartBtnDblClick.bind(this);
	    this.onEndBtnDblClick = this.onEndBtnDblClick.bind(this);
	    this.onUnderflow = this.onUnderflow.bind(this);
	    this.onOverflow = this.onOverflow.bind(this);

	    this.inner.addEventListener("scroll", this.onScroll, false);
	    this.startBtn.addEventListener("mousedown", this.onStartBtnClick, false);
	    this.endBtn.addEventListener("mousedown", this.onEndBtnClick, false);
	    this.startBtn.addEventListener("dblclick", this.onStartBtnDblClick, false);
	    this.endBtn.addEventListener("dblclick", this.onEndBtnDblClick, false);

	    // Overflow and underflow are moz specific events
	    this.inner.addEventListener("underflow", this.onUnderflow, false);
	    this.inner.addEventListener("overflow", this.onOverflow, false);
	  },

	  /**
	   * Determine whether the current text directionality is RTL
	   */
	  isRtl: function () {
	    return this.win.getComputedStyle(this.container).direction === "rtl";
	  },

	  /**
	   * Scroll to the specified element using the current scroll behavior
	   * @param {Element} element element to scroll
	   * @param {String} block desired alignment of element after scrolling
	   */
	  scrollToElement: function (element, block) {
	    element.scrollIntoView({ block: block, behavior: this.scrollBehavior });
	  },

	  /**
	   * Call the given function once; then continuously
	   * while the mouse button is held
	   * @param {Function} repeatFn the function to repeat while the button is held
	   */
	  clickOrHold: function (repeatFn) {
	    let timer;
	    let container = this.container;

	    function handleClick() {
	      cancelHold();
	      repeatFn();
	    }

	    let window = this.win;
	    function cancelHold() {
	      window.clearTimeout(timer);
	      container.removeEventListener("mouseout", cancelHold, false);
	      container.removeEventListener("mouseup", handleClick, false);
	    }

	    function repeated() {
	      repeatFn();
	      timer = window.setTimeout(repeated, SCROLL_REPEAT_MS);
	    }

	    container.addEventListener("mouseout", cancelHold, false);
	    container.addEventListener("mouseup", handleClick, false);
	    timer = window.setTimeout(repeated, SCROLL_REPEAT_MS);
	  },

	  /**
	   * When start button is dbl clicked scroll to first element
	   */
	  onStartBtnDblClick: function () {
	    let children = this.inner.childNodes;
	    if (children.length < 1) {
	      return;
	    }

	    let element = this.inner.childNodes[0];
	    this.scrollToElement(element, "start");
	  },

	  /**
	   * When end button is dbl clicked scroll to last element
	   */
	  onEndBtnDblClick: function () {
	    let children = this.inner.childNodes;
	    if (children.length < 1) {
	      return;
	    }

	    let element = children[children.length - 1];
	    this.scrollToElement(element, "start");
	  },

	  /**
	   * When start arrow button is clicked scroll towards first element
	   */
	  onStartBtnClick: function () {
	    let scrollToStart = () => {
	      let element = this.getFirstInvisibleElement();
	      if (!element) {
	        return;
	      }

	      let block = this.isRtl() ? "end" : "start";
	      this.scrollToElement(element, block);
	    };

	    this.clickOrHold(scrollToStart);
	  },

	  /**
	   * When end arrow button is clicked scroll towards last element
	   */
	  onEndBtnClick: function () {
	    let scrollToEnd = () => {
	      let element = this.getLastInvisibleElement();
	      if (!element) {
	        return;
	      }

	      let block = this.isRtl() ? "start" : "end";
	      this.scrollToElement(element, block);
	    };

	    this.clickOrHold(scrollToEnd);
	  },

	  /**
	   * Event handler for scrolling, update the
	   * enabled/disabled status of the arrow buttons
	   */
	  onScroll: function () {
	    let first = this.getFirstInvisibleElement();
	    if (!first) {
	      this.startBtn.setAttribute("disabled", "true");
	    } else {
	      this.startBtn.removeAttribute("disabled");
	    }

	    let last = this.getLastInvisibleElement();
	    if (!last) {
	      this.endBtn.setAttribute("disabled", "true");
	    } else {
	      this.endBtn.removeAttribute("disabled");
	    }
	  },

	  /**
	   * On underflow, make the arrow buttons invisible
	   */
	  onUnderflow: function () {
	    this.startBtn.style.visibility = "collapse";
	    this.endBtn.style.visibility = "collapse";
	    this.emit("underflow");
	  },

	  /**
	   * On overflow, show the arrow buttons
	   */
	  onOverflow: function () {
	    this.startBtn.style.visibility = "visible";
	    this.endBtn.style.visibility = "visible";
	    this.emit("overflow");
	  },

	  /**
	   * Check whether the element is to the left of its container but does
	   * not also span the entire container.
	   * @param {Number} left the left scroll point of the container
	   * @param {Number} right the right edge of the container
	   * @param {Number} elementLeft the left edge of the element
	   * @param {Number} elementRight the right edge of the element
	   */
	  elementLeftOfContainer: function (left, right, elementLeft, elementRight) {
	    return elementLeft < (left - SCROLL_MARGIN)
	           && elementRight < (right - SCROLL_MARGIN);
	  },

	  /**
	   * Check whether the element is to the right of its container but does
	   * not also span the entire container.
	   * @param {Number} left the left scroll point of the container
	   * @param {Number} right the right edge of the container
	   * @param {Number} elementLeft the left edge of the element
	   * @param {Number} elementRight the right edge of the element
	   */
	  elementRightOfContainer: function (left, right, elementLeft, elementRight) {
	    return elementLeft > (left + SCROLL_MARGIN)
	           && elementRight > (right + SCROLL_MARGIN);
	  },

	  /**
	   * Get the first (i.e. furthest left for LTR)
	   * non or partly visible element in the scroll box
	   */
	  getFirstInvisibleElement: function () {
	    let elementsList = Array.from(this.inner.childNodes).reverse();

	    let predicate = this.isRtl() ?
	      this.elementRightOfContainer : this.elementLeftOfContainer;
	    return this.findFirstWithBounds(elementsList, predicate);
	  },

	  /**
	   * Get the last (i.e. furthest right for LTR)
	   * non or partly visible element in the scroll box
	   */
	  getLastInvisibleElement: function () {
	    let predicate = this.isRtl() ?
	      this.elementLeftOfContainer : this.elementRightOfContainer;
	    return this.findFirstWithBounds(this.inner.childNodes, predicate);
	  },

	  /**
	   * Find the first element that matches the given predicate, called with bounds
	   * information
	   * @param {Array} elements an ordered list of elements
	   * @param {Function} predicate a function to be called with bounds
	   * information
	   */
	  findFirstWithBounds: function (elements, predicate) {
	    let left = this.inner.scrollLeft;
	    let right = left + this.inner.clientWidth;
	    for (let element of elements) {
	      let elementLeft = element.offsetLeft - element.parentElement.offsetLeft;
	      let elementRight = elementLeft + element.offsetWidth;

	      // Check that the starting edge of the element is out of the visible area
	      // and that the ending edge does not span the whole container
	      if (predicate(left, right, elementLeft, elementRight)) {
	        return element;
	      }
	    }

	    return null;
	  },

	  /**
	   * Build the HTML for the scroll box and insert it into the DOM
	   */
	  constructHtml: function () {
	    this.startBtn = this.createElement("div", "scrollbutton-up",
	                                       this.container);
	    this.createElement("div", "toolbarbutton-icon", this.startBtn);

	    this.createElement("div", "arrowscrollbox-overflow-start-indicator",
	                       this.container);
	    this.inner = this.createElement("div", "html-arrowscrollbox-inner",
	                                    this.container);
	    this.createElement("div", "arrowscrollbox-overflow-end-indicator",
	                       this.container);

	    this.endBtn = this.createElement("div", "scrollbutton-down",
	                                     this.container);
	    this.createElement("div", "toolbarbutton-icon", this.endBtn);
	  },

	  /**
	   * Create an XHTML element with the given class name, and append it to the
	   * parent.
	   * @param {String} tagName name of the tag to create
	   * @param {String} className class of the element
	   * @param {DOMNode} parent the parent node to which it should be appended
	   * @return {DOMNode} The new element
	   */
	  createElement: function (tagName, className, parent) {
	    let el = this.doc.createElementNS(NS_XHTML, tagName);
	    el.className = className;
	    if (parent) {
	      parent.appendChild(el);
	    }

	    return el;
	  },

	  /**
	   * Remove event handlers and clean up
	   */
	  destroy: function () {
	    this.inner.removeEventListener("scroll", this.onScroll, false);
	    this.startBtn.removeEventListener("mousedown",
	                                      this.onStartBtnClick, false);
	    this.endBtn.removeEventListener("mousedown", this.onEndBtnClick, false);
	    this.startBtn.removeEventListener("dblclick",
	                                      this.onStartBtnDblClick, false);
	    this.endBtn.removeEventListener("dblclick",
	                                    this.onRightBtnDblClick, false);

	    // Overflow and underflow are moz specific events
	    this.inner.removeEventListener("underflow", this.onUnderflow, false);
	    this.inner.removeEventListener("overflow", this.onOverflow, false);
	  },
	};

	/**
	 * Display the ancestors of the current node and its children.
	 * Only one "branch" of children are displayed (only one line).
	 *
	 * Mechanism:
	 * - If no nodes displayed yet:
	 *   then display the ancestor of the selected node and the selected node;
	 *   else select the node;
	 * - If the selected node is the last node displayed, append its first (if any).
	 *
	 * @param {InspectorPanel} inspector The inspector hosting this widget.
	 */
	function HTMLBreadcrumbs(inspector) {
	  this.inspector = inspector;
	  this.selection = this.inspector.selection;
	  this.win = this.inspector.panelWin;
	  this.doc = this.inspector.panelDoc;
	  this._init();
	}

	exports.HTMLBreadcrumbs = HTMLBreadcrumbs;

	HTMLBreadcrumbs.prototype = {
	  get walker() {
	    return this.inspector.walker;
	  },

	  _init: function () {
	    this.outer = this.doc.getElementById("inspector-breadcrumbs");
	    this.arrowScrollBox = new ArrowScrollBox(
	        this.win,
	        this.outer);

	    this.container = this.arrowScrollBox.inner;
	    this.scroll = this.scroll.bind(this);
	    this.arrowScrollBox.on("overflow", this.scroll);

	    // These separators are used for CSS purposes only, and are positioned
	    // off screen, but displayed with -moz-element.
	    this.separators = this.doc.createElementNS(NS_XHTML, "div");
	    this.separators.className = "breadcrumb-separator-container";
	    this.separators.innerHTML =
	                      "<div id='breadcrumb-separator-before'></div>" +
	                      "<div id='breadcrumb-separator-after'></div>" +
	                      "<div id='breadcrumb-separator-normal'></div>";
	    this.container.parentNode.appendChild(this.separators);

	    this.outer.addEventListener("click", this, true);
	    this.outer.addEventListener("mouseover", this, true);
	    this.outer.addEventListener("mouseout", this, true);
	    this.outer.addEventListener("focus", this, true);

	    this.shortcuts = new KeyShortcuts({ window: this.win, target: this.outer });
	    this.handleShortcut = this.handleShortcut.bind(this);

	    this.shortcuts.on("Right", this.handleShortcut);
	    this.shortcuts.on("Left", this.handleShortcut);

	    // We will save a list of already displayed nodes in this array.
	    this.nodeHierarchy = [];

	    // Last selected node in nodeHierarchy.
	    this.currentIndex = -1;

	    // Used to build a unique breadcrumb button Id.
	    this.breadcrumbsWidgetItemId = 0;

	    this.update = this.update.bind(this);
	    this.updateSelectors = this.updateSelectors.bind(this);
	    this.selection.on("new-node-front", this.update);
	    this.selection.on("pseudoclass", this.updateSelectors);
	    this.selection.on("attribute-changed", this.updateSelectors);
	    this.inspector.on("markupmutation", this.update);
	    this.update();
	  },

	  /**

	   * Build a string that represents the node: tagName#id.class1.class2.
	   * @param {NodeFront} node The node to pretty-print
	   * @return {String}
	   */
	  prettyPrintNodeAsText: function (node) {
	    let text = node.displayName;
	    if (node.isPseudoElement) {
	      text = node.isBeforePseudoElement ? "::before" : "::after";
	    }

	    if (node.id) {
	      text += "#" + node.id;
	    }

	    if (node.className) {
	      let classList = node.className.split(/\s+/);
	      for (let i = 0; i < classList.length; i++) {
	        text += "." + classList[i];
	      }
	    }

	    for (let pseudo of node.pseudoClassLocks) {
	      text += pseudo;
	    }

	    return text;
	  },

	  /**
	   * Build <span>s that represent the node:
	   *   <span class="breadcrumbs-widget-item-tag">tagName</span>
	   *   <span class="breadcrumbs-widget-item-id">#id</span>
	   *   <span class="breadcrumbs-widget-item-classes">.class1.class2</span>
	   * @param {NodeFront} node The node to pretty-print
	   * @returns {DocumentFragment}
	   */
	  prettyPrintNodeAsXHTML: function (node) {
	    let tagLabel = this.doc.createElementNS(NS_XHTML, "span");
	    tagLabel.className = "breadcrumbs-widget-item-tag plain";

	    let idLabel = this.doc.createElementNS(NS_XHTML, "span");
	    idLabel.className = "breadcrumbs-widget-item-id plain";

	    let classesLabel = this.doc.createElementNS(NS_XHTML, "span");
	    classesLabel.className = "breadcrumbs-widget-item-classes plain";

	    let pseudosLabel = this.doc.createElementNS(NS_XHTML, "span");
	    pseudosLabel.className = "breadcrumbs-widget-item-pseudo-classes plain";

	    let tagText = node.displayName;
	    if (node.isPseudoElement) {
	      tagText = node.isBeforePseudoElement ? "::before" : "::after";
	    }
	    let idText = node.id ? ("#" + node.id) : "";
	    let classesText = "";

	    if (node.className) {
	      let classList = node.className.split(/\s+/);
	      for (let i = 0; i < classList.length; i++) {
	        classesText += "." + classList[i];
	      }
	    }

	    // Figure out which element (if any) needs ellipsing.
	    // Substring for that element, then clear out any extras
	    // (except for pseudo elements).
	    let maxTagLength = MAX_LABEL_LENGTH;
	    let maxIdLength = MAX_LABEL_LENGTH - tagText.length;
	    let maxClassLength = MAX_LABEL_LENGTH - tagText.length - idText.length;

	    if (tagText.length > maxTagLength) {
	      tagText = tagText.substr(0, maxTagLength) + ELLIPSIS;
	      idText = classesText = "";
	    } else if (idText.length > maxIdLength) {
	      idText = idText.substr(0, maxIdLength) + ELLIPSIS;
	      classesText = "";
	    } else if (classesText.length > maxClassLength) {
	      classesText = classesText.substr(0, maxClassLength) + ELLIPSIS;
	    }

	    tagLabel.textContent = tagText;
	    idLabel.textContent = idText;
	    classesLabel.textContent = classesText;
	    pseudosLabel.textContent = node.pseudoClassLocks.join("");

	    let fragment = this.doc.createDocumentFragment();
	    fragment.appendChild(tagLabel);
	    fragment.appendChild(idLabel);
	    fragment.appendChild(classesLabel);
	    fragment.appendChild(pseudosLabel);

	    return fragment;
	  },

	  /**
	   * Generic event handler.
	   * @param {DOMEvent} event.
	   */
	  handleEvent: function (event) {
	    if (event.type == "click" && event.button == 0) {
	      this.handleClick(event);
	    } else if (event.type == "mouseover") {
	      this.handleMouseOver(event);
	    } else if (event.type == "mouseout") {
	      this.handleMouseOut(event);
	    } else if (event.type == "focus") {
	      this.handleFocus(event);
	    }
	  },

	  /**
	   * Focus event handler. When breadcrumbs container gets focus,
	   * aria-activedescendant needs to be updated to currently selected
	   * breadcrumb. Ensures that the focus stays on the container at all times.
	   * @param {DOMEvent} event.
	   */
	  handleFocus: function (event) {
	    event.stopPropagation();

	    let node = this.nodeHierarchy[this.currentIndex];
	    if (node) {
	      this.outer.setAttribute("aria-activedescendant", node.button.id);
	    } else {
	      this.outer.removeAttribute("aria-activedescendant");
	    }

	    this.outer.focus();
	  },

	  /**
	   * On click navigate to the correct node.
	   * @param {DOMEvent} event.
	   */
	  handleClick: function (event) {
	    let target = event.originalTarget;
	    if (target.tagName == "button") {
	      target.onBreadcrumbsClick();
	    }
	  },

	  /**
	   * On mouse over, highlight the corresponding content DOM Node.
	   * @param {DOMEvent} event.
	   */
	  handleMouseOver: function (event) {
	    let target = event.originalTarget;
	    if (target.tagName == "button") {
	      target.onBreadcrumbsHover();
	    }
	  },

	  /**
	   * On mouse out, make sure to unhighlight.
	   * @param {DOMEvent} event.
	   */
	  handleMouseOut: function (event) {
	    this.inspector.toolbox.highlighterUtils.unhighlight();
	  },

	  /**
	   * Handle a keyboard shortcut supported by the breadcrumbs widget.
	   *
	   * @param {String} name
	   *        Name of the keyboard shortcut received.
	   * @param {DOMEvent} event
	   *        Original event that triggered the shortcut.
	   */
	  handleShortcut: function (name, event) {
	    if (!this.selection.isElementNode()) {
	      return;
	    }

	    event.preventDefault();
	    event.stopPropagation();

	    this.keyPromise = (this.keyPromise || promise.resolve(null)).then(() => {
	      let currentnode;
	      if (name === "Left" && this.currentIndex != 0) {
	        currentnode = this.nodeHierarchy[this.currentIndex - 1];
	      } else if (name === "Right" && this.currentIndex < this.nodeHierarchy.length - 1) {
	        currentnode = this.nodeHierarchy[this.currentIndex + 1];
	      } else {
	        return null;
	      }

	      this.outer.setAttribute("aria-activedescendant", currentnode.button.id);
	      return this.selection.setNodeFront(currentnode.node, "breadcrumbs");
	    });
	  },

	  /**
	   * Remove nodes and clean up.
	   */
	  destroy: function () {
	    this.selection.off("new-node-front", this.update);
	    this.selection.off("pseudoclass", this.updateSelectors);
	    this.selection.off("attribute-changed", this.updateSelectors);
	    this.inspector.off("markupmutation", this.update);

	    this.container.removeEventListener("click", this, true);
	    this.container.removeEventListener("mouseover", this, true);
	    this.container.removeEventListener("mouseout", this, true);
	    this.container.removeEventListener("focus", this, true);
	    this.shortcuts.destroy();

	    this.empty();
	    this.separators.remove();

	    this.arrowScrollBox.off("overflow", this.scroll);
	    this.arrowScrollBox.destroy();
	    this.arrowScrollBox = null;
	    this.outer = null;
	    this.container = null;
	    this.separators = null;
	    this.nodeHierarchy = null;

	    this.isDestroyed = true;
	  },

	  /**
	   * Empty the breadcrumbs container.
	   */
	  empty: function () {
	    while (this.container.hasChildNodes()) {
	      this.container.firstChild.remove();
	    }
	  },

	  /**
	   * Set which button represent the selected node.
	   * @param {Number} index Index of the displayed-button to select.
	   */
	  setCursor: function (index) {
	    // Unselect the previously selected button
	    if (this.currentIndex > -1
	        && this.currentIndex < this.nodeHierarchy.length) {
	      this.nodeHierarchy[this.currentIndex].button.removeAttribute("checked");
	    }
	    if (index > -1) {
	      this.nodeHierarchy[index].button.setAttribute("checked", "true");
	    } else {
	      // Unset active active descendant when all buttons are unselected.
	      this.outer.removeAttribute("aria-activedescendant");
	    }
	    this.currentIndex = index;
	  },

	  /**
	   * Get the index of the node in the cache.
	   * @param {NodeFront} node.
	   * @returns {Number} The index for this node or -1 if not found.
	   */
	  indexOf: function (node) {
	    for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
	      if (this.nodeHierarchy[i].node === node) {
	        return i;
	      }
	    }
	    return -1;
	  },

	  /**
	   * Remove all the buttons and their references in the cache after a given
	   * index.
	   * @param {Number} index.
	   */
	  cutAfter: function (index) {
	    while (this.nodeHierarchy.length > (index + 1)) {
	      let toRemove = this.nodeHierarchy.pop();
	      this.container.removeChild(toRemove.button);
	    }
	  },

	  /**
	   * Build a button representing the node.
	   * @param {NodeFront} node The node from the page.
	   * @return {DOMNode} The <button> for this node.
	   */
	  buildButton: function (node) {
	    let button = this.doc.createElementNS(NS_XHTML, "button");
	    button.appendChild(this.prettyPrintNodeAsXHTML(node));
	    button.className = "breadcrumbs-widget-item";
	    button.id = "breadcrumbs-widget-item-" + this.breadcrumbsWidgetItemId++;

	    button.setAttribute("tabindex", "-1");
	    button.setAttribute("title", this.prettyPrintNodeAsText(node));

	    button.onclick = () => {
	      button.focus();
	    };

	    button.onBreadcrumbsClick = () => {
	      this.selection.setNodeFront(node, "breadcrumbs");
	    };

	    button.onBreadcrumbsHover = () => {
	      this.inspector.toolbox.highlighterUtils.highlightNodeFront(node);
	    };

	    return button;
	  },

	  /**
	   * Connecting the end of the breadcrumbs to a node.
	   * @param {NodeFront} node The node to reach.
	   */
	  expand: function (node) {
	    let fragment = this.doc.createDocumentFragment();
	    let lastButtonInserted = null;
	    let originalLength = this.nodeHierarchy.length;
	    let stopNode = null;
	    if (originalLength > 0) {
	      stopNode = this.nodeHierarchy[originalLength - 1].node;
	    }
	    while (node && node != stopNode) {
	      if (node.tagName) {
	        let button = this.buildButton(node);
	        fragment.insertBefore(button, lastButtonInserted);
	        lastButtonInserted = button;
	        this.nodeHierarchy.splice(originalLength, 0, {
	          node,
	          button,
	          currentPrettyPrintText: this.prettyPrintNodeAsText(node)
	        });
	      }
	      node = node.parentNode();
	    }
	    this.container.appendChild(fragment, this.container.firstChild);
	  },

	  /**
	   * Find the "youngest" ancestor of a node which is already in the breadcrumbs.
	   * @param {NodeFront} node.
	   * @return {Number} Index of the ancestor in the cache, or -1 if not found.
	   */
	  getCommonAncestor: function (node) {
	    while (node) {
	      let idx = this.indexOf(node);
	      if (idx > -1) {
	        return idx;
	      }
	      node = node.parentNode();
	    }
	    return -1;
	  },

	  /**
	   * Ensure the selected node is visible.
	   */
	  scroll: function () {
	    // FIXME bug 684352: make sure its immediate neighbors are visible too.
	    if (!this.isDestroyed) {
	      let element = this.nodeHierarchy[this.currentIndex].button;
	      this.arrowScrollBox.scrollToElement(element, "end");
	    }
	  },

	  /**
	   * Update all button outputs.
	   */
	  updateSelectors: function () {
	    if (this.isDestroyed) {
	      return;
	    }

	    for (let i = this.nodeHierarchy.length - 1; i >= 0; i--) {
	      let {node, button, currentPrettyPrintText} = this.nodeHierarchy[i];

	      // If the output of the node doesn't change, skip the update.
	      let textOutput = this.prettyPrintNodeAsText(node);
	      if (currentPrettyPrintText === textOutput) {
	        continue;
	      }

	      // Otherwise, update the whole markup for the button.
	      while (button.hasChildNodes()) {
	        button.firstChild.remove();
	      }
	      button.appendChild(this.prettyPrintNodeAsXHTML(node));
	      button.setAttribute("title", textOutput);

	      this.nodeHierarchy[i].currentPrettyPrintText = textOutput;
	    }
	  },

	  /**
	   * Given a list of mutation changes (passed by the markupmutation event),
	   * decide whether or not they are "interesting" to the current state of the
	   * breadcrumbs widget, i.e. at least one of them should cause part of the
	   * widget to be updated.
	   * @param {Array} mutations The mutations array.
	   * @return {Boolean}
	   */
	  _hasInterestingMutations: function (mutations) {
	    if (!mutations || !mutations.length) {
	      return false;
	    }

	    for (let {type, added, removed, target, attributeName} of mutations) {
	      if (type === "childList") {
	        // Only interested in childList mutations if the added or removed
	        // nodes are currently displayed.
	        return added.some(node => this.indexOf(node) > -1) ||
	               removed.some(node => this.indexOf(node) > -1);
	      } else if (type === "attributes" && this.indexOf(target) > -1) {
	        // Only interested in attributes mutations if the target is
	        // currently displayed, and the attribute is either id or class.
	        return attributeName === "class" || attributeName === "id";
	      }
	    }

	    // Catch all return in case the mutations array was empty, or in case none
	    // of the changes iterated above were interesting.
	    return false;
	  },

	  /**
	   * Update the breadcrumbs display when a new node is selected.
	   * @param {String} reason The reason for the update, if any.
	   * @param {Array} mutations An array of mutations in case this was called as
	   * the "markupmutation" event listener.
	   */
	  update: function (reason, mutations) {
	    if (this.isDestroyed) {
	      return;
	    }

	    let hasInterestingMutations = this._hasInterestingMutations(mutations);
	    if (reason === "markupmutation" && !hasInterestingMutations) {
	      return;
	    }

	    if (!this.selection.isConnected()) {
	      // remove all the crumbs
	      this.cutAfter(-1);
	      return;
	    }

	    // If this was an interesting deletion; then trim the breadcrumb trail
	    let trimmed = false;
	    if (reason === "markupmutation") {
	      for (let {type, removed} of mutations) {
	        if (type !== "childList") {
	          continue;
	        }

	        for (let node of removed) {
	          let removedIndex = this.indexOf(node);
	          if (removedIndex > -1) {
	            this.cutAfter(removedIndex - 1);
	            trimmed = true;
	          }
	        }
	      }
	    }

	    if (!this.selection.isElementNode()) {
	      // no selection
	      this.setCursor(-1);
	      if (trimmed) {
	        // Since something changed, notify the interested parties.
	        this.inspector.emit("breadcrumbs-updated", this.selection.nodeFront);
	      }
	      return;
	    }

	    let idx = this.indexOf(this.selection.nodeFront);

	    // Is the node already displayed in the breadcrumbs?
	    // (and there are no mutations that need re-display of the crumbs)
	    if (idx > -1 && !hasInterestingMutations) {
	      // Yes. We select it.
	      this.setCursor(idx);
	    } else {
	      // No. Is the breadcrumbs display empty?
	      if (this.nodeHierarchy.length > 0) {
	        // No. We drop all the element that are not direct ancestors
	        // of the selection
	        let parent = this.selection.nodeFront.parentNode();
	        let ancestorIdx = this.getCommonAncestor(parent);
	        this.cutAfter(ancestorIdx);
	      }
	      // we append the missing button between the end of the breadcrumbs display
	      // and the current node.
	      this.expand(this.selection.nodeFront);

	      // we select the current node button
	      idx = this.indexOf(this.selection.nodeFront);
	      this.setCursor(idx);
	    }

	    let doneUpdating = this.inspector.updating("breadcrumbs");

	    this.updateSelectors();

	    // Make sure the selected node and its neighbours are visible.
	    setTimeout(() => {
	      try {
	        this.scroll();
	        this.inspector.emit("breadcrumbs-updated", this.selection.nodeFront);
	        doneUpdating();
	      } catch (e) {
	        // Only log this as an error if we haven't been destroyed in the meantime.
	        if (!this.isDestroyed) {
	          console.error(e);
	        }
	      }
	    }, 0);
	  }
	};


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const promise = __webpack_require__(4);
	const {Task} = __webpack_require__(15);
	const {KeyCodes} = __webpack_require__(14);

	const EventEmitter = __webpack_require__(6);
	const {AutocompletePopup} = __webpack_require__(208);
	const Services = __webpack_require__(1);

	// Maximum number of selector suggestions shown in the panel.
	const MAX_SUGGESTIONS = 15;

	/**
	 * Converts any input field into a document search box.
	 *
	 * @param {InspectorPanel} inspector
	 *        The InspectorPanel whose `walker` attribute should be used for
	 *        document traversal.
	 * @param {DOMNode} input
	 *        The input element to which the panel will be attached and from where
	 *        search input will be taken.
	 * @param {DOMNode} clearBtn
	 *        The clear button in the input field that will clear the input value.
	 *
	 * Emits the following events:
	 * - search-cleared: when the search box is emptied
	 * - search-result: when a search is made and a result is selected
	 */
	function InspectorSearch(inspector, input, clearBtn) {
	  this.inspector = inspector;
	  this.searchBox = input;
	  this.searchClearButton = clearBtn;
	  this._lastSearched = null;

	  this.searchClearButton.hidden = true;

	  this._onKeyDown = this._onKeyDown.bind(this);
	  this._onInput = this._onInput.bind(this);
	  this._onClearSearch = this._onClearSearch.bind(this);
	  this._onFilterTextboxContextMenu =
	    this._onFilterTextboxContextMenu.bind(this);
	  this.searchBox.addEventListener("keydown", this._onKeyDown, true);
	  this.searchBox.addEventListener("input", this._onInput, true);
	  this.searchBox.addEventListener("contextmenu",
	    this._onFilterTextboxContextMenu);
	  this.searchClearButton.addEventListener("click", this._onClearSearch);

	  // For testing, we need to be able to wait for the most recent node request
	  // to finish.  Tests can watch this promise for that.
	  this._lastQuery = promise.resolve(null);

	  this.autocompleter = new SelectorAutocompleter(inspector, input);
	  EventEmitter.decorate(this);
	}

	exports.InspectorSearch = InspectorSearch;

	InspectorSearch.prototype = {
	  get walker() {
	    return this.inspector.walker;
	  },

	  destroy: function () {
	    this.searchBox.removeEventListener("keydown", this._onKeyDown, true);
	    this.searchBox.removeEventListener("input", this._onInput, true);
	    this.searchBox.removeEventListener("contextmenu",
	      this._onFilterTextboxContextMenu);
	    this.searchClearButton.removeEventListener("click", this._onClearSearch);
	    this.searchBox = null;
	    this.searchClearButton = null;
	    this.autocompleter.destroy();
	  },

	  _onSearch: function (reverse = false) {
	    this.doFullTextSearch(this.searchBox.value, reverse)
	        .catch(e => console.error(e));
	  },

	  doFullTextSearch: Task.async(function* (query, reverse) {
	    let lastSearched = this._lastSearched;
	    this._lastSearched = query;

	    if (query.length === 0) {
	      this.searchBox.classList.remove("devtools-style-searchbox-no-match");
	      if (!lastSearched || lastSearched.length > 0) {
	        this.emit("search-cleared");
	      }
	      return;
	    }

	    let res = yield this.walker.search(query, { reverse });

	    // Value has changed since we started this request, we're done.
	    if (query !== this.searchBox.value) {
	      return;
	    }

	    if (res) {
	      this.inspector.selection.setNodeFront(res.node, "inspectorsearch");
	      this.searchBox.classList.remove("devtools-style-searchbox-no-match");

	      res.query = query;
	      this.emit("search-result", res);
	    } else {
	      this.searchBox.classList.add("devtools-style-searchbox-no-match");
	      this.emit("search-result");
	    }
	  }),

	  _onInput: function () {
	    if (this.searchBox.value.length === 0) {
	      this.searchClearButton.hidden = true;
	      this.searchBox.removeAttribute("filled");
	      this._onSearch();
	    } else {
	      this.searchClearButton.hidden = false;
	      this.searchBox.setAttribute("filled", true);
	    }
	  },

	  _onKeyDown: function (event) {
	    if (event.keyCode === KeyCodes.DOM_VK_RETURN) {
	      this._onSearch(event.shiftKey);
	    }

	    const modifierKey = Services.appinfo.OS === "Darwin"
	                        ? event.metaKey : event.ctrlKey;
	    if (event.keyCode === KeyCodes.DOM_VK_G && modifierKey) {
	      this._onSearch(event.shiftKey);
	      event.preventDefault();
	    }
	  },

	  /**
	   * Context menu handler for filter search box.
	   */
	  _onFilterTextboxContextMenu: function (event) {
	    try {
	      let contextmenu = this.inspector.toolbox.textboxContextMenuPopup;
	      contextmenu.openPopupAtScreen(event.screenX, event.screenY, true);
	    } catch (e) {
	      console.error(e);
	    }
	  },

	  _onClearSearch: function () {
	    this.searchBox.classList.remove("devtools-style-searchbox-no-match");
	    this.searchBox.value = "";
	    this.searchClearButton.hidden = true;
	    this.emit("search-cleared");
	  }
	};

	/**
	 * Converts any input box on a page to a CSS selector search and suggestion box.
	 *
	 * Emits 'processing-done' event when it is done processing the current
	 * keypress, search request or selection from the list, whether that led to a
	 * search or not.
	 *
	 * @constructor
	 * @param InspectorPanel inspector
	 *        The InspectorPanel whose `walker` attribute should be used for
	 *        document traversal.
	 * @param nsiInputElement inputNode
	 *        The input element to which the panel will be attached and from where
	 *        search input will be taken.
	 */
	function SelectorAutocompleter(inspector, inputNode) {
	  this.inspector = inspector;
	  this.searchBox = inputNode;
	  this.panelDoc = this.searchBox.ownerDocument;

	  this.showSuggestions = this.showSuggestions.bind(this);
	  this._onSearchKeypress = this._onSearchKeypress.bind(this);
	  this._onSearchPopupClick = this._onSearchPopupClick.bind(this);
	  this._onMarkupMutation = this._onMarkupMutation.bind(this);

	  // Options for the AutocompletePopup.
	  let options = {
	    listId: "searchbox-panel-listbox",
	    autoSelect: true,
	    position: "top",
	    theme: "auto",
	    onClick: this._onSearchPopupClick,
	  };

	  this.searchPopup = new AutocompletePopup(inspector._toolbox, options);

	  this.searchBox.addEventListener("input", this.showSuggestions, true);
	  this.searchBox.addEventListener("keypress", this._onSearchKeypress, true);
	  this.inspector.on("markupmutation", this._onMarkupMutation);

	  // For testing, we need to be able to wait for the most recent node request
	  // to finish.  Tests can watch this promise for that.
	  this._lastQuery = promise.resolve(null);
	  EventEmitter.decorate(this);
	}

	exports.SelectorAutocompleter = SelectorAutocompleter;

	SelectorAutocompleter.prototype = {
	  get walker() {
	    return this.inspector.walker;
	  },

	  // The possible states of the query.
	  States: {
	    CLASS: "class",
	    ID: "id",
	    TAG: "tag",
	    ATTRIBUTE: "attribute",
	  },

	  // The current state of the query.
	  _state: null,

	  // The query corresponding to last state computation.
	  _lastStateCheckAt: null,

	  /**
	   * Computes the state of the query. State refers to whether the query
	   * currently requires a class suggestion, or a tag, or an Id suggestion.
	   * This getter will effectively compute the state by traversing the query
	   * character by character each time the query changes.
	   *
	   * @example
	   *        '#f' requires an Id suggestion, so the state is States.ID
	   *        'div > .foo' requires class suggestion, so state is States.CLASS
	   */
	  get state() {
	    if (!this.searchBox || !this.searchBox.value) {
	      return null;
	    }

	    let query = this.searchBox.value;
	    if (this._lastStateCheckAt == query) {
	      // If query is the same, return early.
	      return this._state;
	    }
	    this._lastStateCheckAt = query;

	    this._state = null;
	    let subQuery = "";
	    // Now we iterate over the query and decide the state character by
	    // character.
	    // The logic here is that while iterating, the state can go from one to
	    // another with some restrictions. Like, if the state is Class, then it can
	    // never go to Tag state without a space or '>' character; Or like, a Class
	    // state with only '.' cannot go to an Id state without any [a-zA-Z] after
	    // the '.' which means that '.#' is a selector matching a class name '#'.
	    // Similarily for '#.' which means a selctor matching an id '.'.
	    for (let i = 1; i <= query.length; i++) {
	      // Calculate the state.
	      subQuery = query.slice(0, i);
	      let [secondLastChar, lastChar] = subQuery.slice(-2);
	      switch (this._state) {
	        case null:
	          // This will happen only in the first iteration of the for loop.
	          lastChar = secondLastChar;

	        case this.States.TAG: // eslint-disable-line
	          if (lastChar === ".") {
	            this._state = this.States.CLASS;
	          } else if (lastChar === "#") {
	            this._state = this.States.ID;
	          } else if (lastChar === "[") {
	            this._state = this.States.ATTRIBUTE;
	          } else {
	            this._state = this.States.TAG;
	          }
	          break;

	        case this.States.CLASS:
	          if (subQuery.match(/[\.]+[^\.]*$/)[0].length > 2) {
	            // Checks whether the subQuery has atleast one [a-zA-Z] after the
	            // '.'.
	            if (lastChar === " " || lastChar === ">") {
	              this._state = this.States.TAG;
	            } else if (lastChar === "#") {
	              this._state = this.States.ID;
	            } else if (lastChar === "[") {
	              this._state = this.States.ATTRIBUTE;
	            } else {
	              this._state = this.States.CLASS;
	            }
	          }
	          break;

	        case this.States.ID:
	          if (subQuery.match(/[#]+[^#]*$/)[0].length > 2) {
	            // Checks whether the subQuery has atleast one [a-zA-Z] after the
	            // '#'.
	            if (lastChar === " " || lastChar === ">") {
	              this._state = this.States.TAG;
	            } else if (lastChar === ".") {
	              this._state = this.States.CLASS;
	            } else if (lastChar === "[") {
	              this._state = this.States.ATTRIBUTE;
	            } else {
	              this._state = this.States.ID;
	            }
	          }
	          break;

	        case this.States.ATTRIBUTE:
	          if (subQuery.match(/[\[][^\]]+[\]]/) !== null) {
	            // Checks whether the subQuery has at least one ']' after the '['.
	            if (lastChar === " " || lastChar === ">") {
	              this._state = this.States.TAG;
	            } else if (lastChar === ".") {
	              this._state = this.States.CLASS;
	            } else if (lastChar === "#") {
	              this._state = this.States.ID;
	            } else {
	              this._state = this.States.ATTRIBUTE;
	            }
	          }
	          break;
	      }
	    }
	    return this._state;
	  },

	  /**
	   * Removes event listeners and cleans up references.
	   */
	  destroy: function () {
	    this.searchBox.removeEventListener("input", this.showSuggestions, true);
	    this.searchBox.removeEventListener("keypress",
	      this._onSearchKeypress, true);
	    this.inspector.off("markupmutation", this._onMarkupMutation);
	    this.searchPopup.destroy();
	    this.searchPopup = null;
	    this.searchBox = null;
	    this.panelDoc = null;
	  },

	  /**
	   * Handles keypresses inside the input box.
	   */
	  _onSearchKeypress: function (event) {
	    let popup = this.searchPopup;

	    switch (event.keyCode) {
	      case KeyCodes.DOM_VK_RETURN:
	      case KeyCodes.DOM_VK_TAB:
	        if (popup.isOpen) {
	          if (popup.selectedItem) {
	            this.searchBox.value = popup.selectedItem.label;
	          }
	          this.hidePopup();
	        } else if (!popup.isOpen) {
	          // When tab is pressed with focus on searchbox and closed popup,
	          // do not prevent the default to avoid a keyboard trap and move focus
	          // to next/previous element.
	          this.emit("processing-done");
	          return;
	        }
	        break;

	      case KeyCodes.DOM_VK_UP:
	        if (popup.isOpen && popup.itemCount > 0) {
	          if (popup.selectedIndex === 0) {
	            popup.selectedIndex = popup.itemCount - 1;
	          } else {
	            popup.selectedIndex--;
	          }
	          this.searchBox.value = popup.selectedItem.label;
	        }
	        break;

	      case KeyCodes.DOM_VK_DOWN:
	        if (popup.isOpen && popup.itemCount > 0) {
	          if (popup.selectedIndex === popup.itemCount - 1) {
	            popup.selectedIndex = 0;
	          } else {
	            popup.selectedIndex++;
	          }
	          this.searchBox.value = popup.selectedItem.label;
	        }
	        break;

	      case KeyCodes.DOM_VK_ESCAPE:
	        if (popup.isOpen) {
	          this.hidePopup();
	        }
	        break;

	      default:
	        return;
	    }

	    event.preventDefault();
	    event.stopPropagation();
	    this.emit("processing-done");
	  },

	  /**
	   * Handles click events from the autocomplete popup.
	   */
	  _onSearchPopupClick: function (event) {
	    let selectedItem = this.searchPopup.selectedItem;
	    if (selectedItem) {
	      this.searchBox.value = selectedItem.label;
	    }
	    this.hidePopup();

	    event.preventDefault();
	    event.stopPropagation();
	  },

	  /**
	   * Reset previous search results on markup-mutations to make sure we search
	   * again after nodes have been added/removed/changed.
	   */
	  _onMarkupMutation: function () {
	    this._searchResults = null;
	    this._lastSearched = null;
	  },

	  /**
	   * Populates the suggestions list and show the suggestion popup.
	   *
	   * @return {Promise} promise that will resolve when the autocomplete popup is fully
	   * displayed or hidden.
	   */
	  _showPopup: function (list, firstPart, popupState) {
	    let total = 0;
	    let query = this.searchBox.value;
	    let items = [];

	    for (let [value, , state] of list) {
	      if (query.match(/[\s>+]$/)) {
	        // for cases like 'div ' or 'div >' or 'div+'
	        value = query + value;
	      } else if (query.match(/[\s>+][\.#a-zA-Z][^\s>+\.#\[]*$/)) {
	        // for cases like 'div #a' or 'div .a' or 'div > d' and likewise
	        let lastPart = query.match(/[\s>+][\.#a-zA-Z][^\s>+\.#\[]*$/)[0];
	        value = query.slice(0, -1 * lastPart.length + 1) + value;
	      } else if (query.match(/[a-zA-Z][#\.][^#\.\s+>]*$/)) {
	        // for cases like 'div.class' or '#foo.bar' and likewise
	        let lastPart = query.match(/[a-zA-Z][#\.][^#\.\s+>]*$/)[0];
	        value = query.slice(0, -1 * lastPart.length + 1) + value;
	      } else if (query.match(/[a-zA-Z]*\[[^\]]*\][^\]]*/)) {
	        // for cases like '[foo].bar' and likewise
	        let attrPart = query.substring(0, query.lastIndexOf("]") + 1);
	        value = attrPart + value;
	      }

	      let item = {
	        preLabel: query,
	        label: value
	      };

	      // In case the query's state is tag and the item's state is id or class
	      // adjust the preLabel
	      if (popupState === this.States.TAG && state === this.States.CLASS) {
	        item.preLabel = "." + item.preLabel;
	      }
	      if (popupState === this.States.TAG && state === this.States.ID) {
	        item.preLabel = "#" + item.preLabel;
	      }

	      items.unshift(item);
	      if (++total > MAX_SUGGESTIONS - 1) {
	        break;
	      }
	    }

	    if (total > 0) {
	      let onPopupOpened = this.searchPopup.once("popup-opened");
	      this.searchPopup.once("popup-closed", () => {
	        this.searchPopup.setItems(items);
	        this.searchPopup.openPopup(this.searchBox);
	      });
	      this.searchPopup.hidePopup();
	      return onPopupOpened;
	    }

	    return this.hidePopup();
	  },

	  /**
	   * Hide the suggestion popup if necessary.
	   */
	  hidePopup: function () {
	    let onPopupClosed = this.searchPopup.once("popup-closed");
	    this.searchPopup.hidePopup();
	    return onPopupClosed;
	  },

	  /**
	   * Suggests classes,ids and tags based on the user input as user types in the
	   * searchbox.
	   */
	  showSuggestions: function () {
	    let query = this.searchBox.value;
	    let state = this.state;
	    let firstPart = "";

	    if (query.endsWith("*") || state === this.States.ATTRIBUTE) {
	      // Hide the popup if the query ends with * (because we don't want to
	      // suggest all nodes) or if it is an attribute selector (because
	      // it would give a lot of useless results).
	      this.hidePopup();
	      return;
	    }

	    if (state === this.States.TAG) {
	      // gets the tag that is being completed. For ex. 'div.foo > s' returns
	      // 's', 'di' returns 'di' and likewise.
	      firstPart = (query.match(/[\s>+]?([a-zA-Z]*)$/) || ["", query])[1];
	      query = query.slice(0, query.length - firstPart.length);
	    } else if (state === this.States.CLASS) {
	      // gets the class that is being completed. For ex. '.foo.b' returns 'b'
	      firstPart = query.match(/\.([^\.]*)$/)[1];
	      query = query.slice(0, query.length - firstPart.length - 1);
	    } else if (state === this.States.ID) {
	      // gets the id that is being completed. For ex. '.foo#b' returns 'b'
	      firstPart = query.match(/#([^#]*)$/)[1];
	      query = query.slice(0, query.length - firstPart.length - 1);
	    }
	    // TODO: implement some caching so that over the wire request is not made
	    // everytime.
	    if (/[\s+>~]$/.test(query)) {
	      query += "*";
	    }

	    let suggestionsPromise = this.walker.getSuggestionsForQuery(
	      query, firstPart, state);
	    this._lastQuery = suggestionsPromise.then(result => {
	      this.emit("processing-done");
	      if (result.query !== query) {
	        // This means that this response is for a previous request and the user
	        // as since typed something extra leading to a new request.
	        return promise.resolve(null);
	      }

	      if (state === this.States.CLASS) {
	        firstPart = "." + firstPart;
	      } else if (state === this.States.ID) {
	        firstPart = "#" + firstPart;
	      }

	      // If there is a single tag match and it's what the user typed, then
	      // don't need to show a popup.
	      if (result.suggestions.length === 1 &&
	          result.suggestions[0][0] === firstPart) {
	        result.suggestions = [];
	      }

	      // Wait for the autocomplete-popup to fire its popup-opened event, to make sure
	      // the autoSelect item has been selected.
	      return this._showPopup(result.suggestions, firstPart, state);
	    });

	    return;
	  }
	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	/* globals template */

	"use strict";

	// Page size for pageup/pagedown
	const PAGE_SIZE = 10;
	const DEFAULT_MAX_CHILDREN = 100;
	const COLLAPSE_DATA_URL_REGEX = /^data.+base64/;
	const COLLAPSE_DATA_URL_LENGTH = 60;
	const NEW_SELECTION_HIGHLIGHTER_TIMER = 1000;
	const DRAG_DROP_AUTOSCROLL_EDGE_MAX_DISTANCE = 50;
	const DRAG_DROP_AUTOSCROLL_EDGE_RATIO = 0.1;
	const DRAG_DROP_MIN_AUTOSCROLL_SPEED = 2;
	const DRAG_DROP_MAX_AUTOSCROLL_SPEED = 8;
	const DRAG_DROP_MIN_INITIAL_DISTANCE = 10;
	const DRAG_DROP_HEIGHT_TO_SPEED = 500;
	const DRAG_DROP_HEIGHT_TO_SPEED_MIN = 0.5;
	const DRAG_DROP_HEIGHT_TO_SPEED_MAX = 1;
	const ATTR_COLLAPSE_ENABLED_PREF = "devtools.markup.collapseAttributes";
	const ATTR_COLLAPSE_LENGTH_PREF = "devtools.markup.collapseAttributeLength";
	const PREVIEW_MAX_DIM_PREF = "devtools.inspector.imagePreviewTooltipSize";

	// Contains only void (without end tag) HTML elements
	const HTML_VOID_ELEMENTS = [ "area", "base", "br", "col", "command", "embed",
	  "hr", "img", "input", "keygen", "link", "meta", "param", "source",
	  "track", "wbr" ];

	const {UndoStack} = __webpack_require__(217);
	const {editableField, InplaceEditor} =
	      __webpack_require__(203);
	const {HTMLEditor} = __webpack_require__(218);
	const promise = __webpack_require__(4);
	const defer = __webpack_require__(5);
	const Services = __webpack_require__(1);
	const {HTMLTooltip} = __webpack_require__(186);
	const {setImageTooltip, setBrokenImageTooltip} =
	      __webpack_require__(189);
	const {setEventTooltip} = __webpack_require__(232);
	const EventEmitter = __webpack_require__(6);
	const Heritage = __webpack_require__(18);
	const {parseAttribute} =
	      __webpack_require__(237);
	const {Task} = __webpack_require__(15);
	const {scrollIntoViewIfNeeded} = __webpack_require__(238);
	const {PrefObserver} = __webpack_require__(180);
	const {KeyShortcuts} = __webpack_require__(13);
	const {template} = __webpack_require__(239);
	const nodeConstants = __webpack_require__(31);
	const nodeFilterConstants = __webpack_require__(240);
	const {getCssProperties} = __webpack_require__(16);
	const {KeyCodes} = __webpack_require__(14);

	const {AutocompletePopup} = __webpack_require__(208);
	const clipboardHelper = __webpack_require__(207);

	const {PluralForm} = __webpack_require__(241);
	const {LocalizationHelper} = __webpack_require__(56);
	const INSPECTOR_L10N = new LocalizationHelper("devtools/locale/inspector.properties");

	/**
	 * Vocabulary for the purposes of this file:
	 *
	 * MarkupContainer - the structure that holds an editor and its
	 *  immediate children in the markup panel.
	 *  - MarkupElementContainer: markup container for element nodes
	 *  - MarkupTextContainer: markup container for text / comment nodes
	 *  - MarkupReadonlyContainer: markup container for other nodes
	 * Node - A content node.
	 * object.elt - A UI element in the markup panel.
	 */

	/**
	 * The markup tree.  Manages the mapping of nodes to MarkupContainers,
	 * updating based on mutations, and the undo/redo bindings.
	 *
	 * @param  {Inspector} inspector
	 *         The inspector we're watching.
	 * @param  {iframe} frame
	 *         An iframe in which the caller has kindly loaded markup.xhtml.
	 */
	function MarkupView(inspector, frame, controllerWindow) {
	  this._inspector = inspector;
	  this.walker = this._inspector.walker;
	  this._frame = frame;
	  this.win = this._frame.contentWindow;
	  this.doc = this._frame.contentDocument;
	  this._elt = this.doc.querySelector("#root");
	  this.htmlEditor = new HTMLEditor(this.doc);

	  try {
	    this.maxChildren = Services.prefs.getIntPref("devtools.markup.pagesize");
	  } catch (ex) {
	    this.maxChildren = DEFAULT_MAX_CHILDREN;
	  }

	  this.collapseAttributes =
	    Services.prefs.getBoolPref(ATTR_COLLAPSE_ENABLED_PREF);
	  this.collapseAttributeLength =
	    Services.prefs.getIntPref(ATTR_COLLAPSE_LENGTH_PREF);

	  // Creating the popup to be used to show CSS suggestions.
	  let options = {
	    autoSelect: true,
	    theme: "auto",
	  };

	  this.popup = new AutocompletePopup(inspector._toolbox, options);

	  this.undo = new UndoStack();
	  this.undo.installController(controllerWindow);

	  this._containers = new Map();

	  // Binding functions that need to be called in scope.
	  this._handleRejectionIfNotDestroyed = this._handleRejectionIfNotDestroyed.bind(this);
	  this._mutationObserver = this._mutationObserver.bind(this);
	  this._onDisplayChange = this._onDisplayChange.bind(this);
	  this._onMouseClick = this._onMouseClick.bind(this);
	  this._onMouseUp = this._onMouseUp.bind(this);
	  this._onNewSelection = this._onNewSelection.bind(this);
	  this._onCopy = this._onCopy.bind(this);
	  this._onFocus = this._onFocus.bind(this);
	  this._onMouseMove = this._onMouseMove.bind(this);
	  this._onMouseOut = this._onMouseOut.bind(this);
	  this._onToolboxPickerHover = this._onToolboxPickerHover.bind(this);
	  this._onCollapseAttributesPrefChange =
	    this._onCollapseAttributesPrefChange.bind(this);
	  this._isImagePreviewTarget = this._isImagePreviewTarget.bind(this);
	  this._onBlur = this._onBlur.bind(this);

	  EventEmitter.decorate(this);

	  // Listening to various events.
	  this._elt.addEventListener("click", this._onMouseClick, false);
	  this._elt.addEventListener("mousemove", this._onMouseMove, false);
	  this._elt.addEventListener("mouseout", this._onMouseOut, false);
	  this._elt.addEventListener("blur", this._onBlur, true);
	  this.win.addEventListener("mouseup", this._onMouseUp);
	  this.win.addEventListener("copy", this._onCopy);
	  this._frame.addEventListener("focus", this._onFocus, false);
	  this.walker.on("mutations", this._mutationObserver);
	  this.walker.on("display-change", this._onDisplayChange);
	  this._inspector.selection.on("new-node-front", this._onNewSelection);
	  this._inspector.toolbox.on("picker-node-hovered", this._onToolboxPickerHover);

	  this._onNewSelection();
	  this._initTooltips();

	  this._prefObserver = new PrefObserver("devtools.markup");
	  this._prefObserver.on(ATTR_COLLAPSE_ENABLED_PREF,
	                        this._onCollapseAttributesPrefChange);
	  this._prefObserver.on(ATTR_COLLAPSE_LENGTH_PREF,
	                        this._onCollapseAttributesPrefChange);

	  this._initShortcuts();
	}

	MarkupView.prototype = {
	  /**
	   * How long does a node flash when it mutates (in ms).
	   */
	  CONTAINER_FLASHING_DURATION: 500,

	  _selectedContainer: null,

	  /**
	   * Handle promise rejections for various asynchronous actions, and only log errors if
	   * the markup view still exists.
	   * This is useful to silence useless errors that happen when the markup view is
	   * destroyed while still initializing (and making protocol requests).
	   */
	  _handleRejectionIfNotDestroyed: function (e) {
	    if (!this._destroyer) {
	      console.error(e);
	    }
	  },

	  _initTooltips: function () {
	    this.eventDetailsTooltip = new HTMLTooltip(this._inspector.toolbox,
	      {type: "arrow"});
	    this.imagePreviewTooltip = new HTMLTooltip(this._inspector.toolbox,
	      {type: "arrow", useXulWrapper: "true"});
	    this._enableImagePreviewTooltip();
	  },

	  _enableImagePreviewTooltip: function () {
	    this.imagePreviewTooltip.startTogglingOnHover(this._elt,
	      this._isImagePreviewTarget);
	  },

	  _disableImagePreviewTooltip: function () {
	    this.imagePreviewTooltip.stopTogglingOnHover();
	  },

	  _onToolboxPickerHover: function (event, nodeFront) {
	    this.showNode(nodeFront).then(() => {
	      this._showContainerAsHovered(nodeFront);
	    }, e => console.error(e));
	  },

	  isDragging: false,

	  _onMouseMove: function (event) {
	    let target = event.target;

	    // Auto-scroll if we're dragging.
	    if (this.isDragging) {
	      event.preventDefault();
	      this._autoScroll(event);
	      return;
	    }

	    // Show the current container as hovered and highlight it.
	    // This requires finding the current MarkupContainer (walking up the DOM).
	    while (!target.container) {
	      if (target.tagName.toLowerCase() === "body") {
	        return;
	      }
	      target = target.parentNode;
	    }

	    let container = target.container;
	    if (this._hoveredNode !== container.node) {
	      if (container.node.nodeType !== nodeConstants.TEXT_NODE) {
	        this._showBoxModel(container.node);
	      } else {
	        this._hideBoxModel();
	      }
	    }
	    this._showContainerAsHovered(container.node);

	    this.emit("node-hover");
	  },

	  /**
	   * If focus is moved outside of the markup view document and there is a
	   * selected container, make its contents not focusable by a keyboard.
	   */
	  _onBlur: function (event) {
	    if (!this._selectedContainer) {
	      return;
	    }

	    let {relatedTarget} = event;
	    if (relatedTarget && relatedTarget.ownerDocument === this.doc) {
	      return;
	    }

	    if (this._selectedContainer) {
	      this._selectedContainer.clearFocus();
	    }
	  },

	  /**
	   * Executed on each mouse-move while a node is being dragged in the view.
	   * Auto-scrolls the view to reveal nodes below the fold to drop the dragged
	   * node in.
	   */
	  _autoScroll: function (event) {
	    let docEl = this.doc.documentElement;

	    if (this._autoScrollAnimationFrame) {
	      this.win.cancelAnimationFrame(this._autoScrollAnimationFrame);
	    }

	    // Auto-scroll when the mouse approaches top/bottom edge.
	    let fromBottom = docEl.clientHeight - event.pageY + this.win.scrollY;
	    let fromTop = event.pageY - this.win.scrollY;
	    let edgeDistance = Math.min(DRAG_DROP_AUTOSCROLL_EDGE_MAX_DISTANCE,
	           docEl.clientHeight * DRAG_DROP_AUTOSCROLL_EDGE_RATIO);

	    // The smaller the screen, the slower the movement.
	    let heightToSpeedRatio =
	      Math.max(DRAG_DROP_HEIGHT_TO_SPEED_MIN,
	        Math.min(DRAG_DROP_HEIGHT_TO_SPEED_MAX,
	          docEl.clientHeight / DRAG_DROP_HEIGHT_TO_SPEED));

	    if (fromBottom <= edgeDistance) {
	      // Map our distance range to a speed range so that the speed is not too
	      // fast or too slow.
	      let speed = map(
	        fromBottom,
	        0, edgeDistance,
	        DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);

	      this._runUpdateLoop(() => {
	        docEl.scrollTop -= heightToSpeedRatio *
	          (speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED);
	      });
	    }

	    if (fromTop <= edgeDistance) {
	      let speed = map(
	        fromTop,
	        0, edgeDistance,
	        DRAG_DROP_MIN_AUTOSCROLL_SPEED, DRAG_DROP_MAX_AUTOSCROLL_SPEED);

	      this._runUpdateLoop(() => {
	        docEl.scrollTop += heightToSpeedRatio *
	          (speed - DRAG_DROP_MAX_AUTOSCROLL_SPEED);
	      });
	    }
	  },

	  /**
	   * Run a loop on the requestAnimationFrame.
	   */
	  _runUpdateLoop: function (update) {
	    let loop = () => {
	      update();
	      this._autoScrollAnimationFrame = this.win.requestAnimationFrame(loop);
	    };
	    loop();
	  },

	  _onMouseClick: function (event) {
	    // From the target passed here, let's find the parent MarkupContainer
	    // and ask it if the tooltip should be shown
	    let parentNode = event.target;
	    let container;
	    while (parentNode !== this.doc.body) {
	      if (parentNode.container) {
	        container = parentNode.container;
	        break;
	      }
	      parentNode = parentNode.parentNode;
	    }

	    if (container instanceof MarkupElementContainer) {
	      // With the newly found container, delegate the tooltip content creation
	      // and decision to show or not the tooltip
	      container._buildEventTooltipContent(event.target,
	        this.eventDetailsTooltip);
	    }
	  },

	  _onMouseUp: function () {
	    this.indicateDropTarget(null);
	    this.indicateDragTarget(null);
	    if (this._autoScrollAnimationFrame) {
	      this.win.cancelAnimationFrame(this._autoScrollAnimationFrame);
	    }
	  },

	  _onCollapseAttributesPrefChange: function () {
	    this.collapseAttributes =
	      Services.prefs.getBoolPref(ATTR_COLLAPSE_ENABLED_PREF);
	    this.collapseAttributeLength =
	      Services.prefs.getIntPref(ATTR_COLLAPSE_LENGTH_PREF);
	    this.update();
	  },

	  cancelDragging: function () {
	    if (!this.isDragging) {
	      return;
	    }

	    for (let [, container] of this._containers) {
	      if (container.isDragging) {
	        container.cancelDragging();
	        break;
	      }
	    }

	    this.indicateDropTarget(null);
	    this.indicateDragTarget(null);
	    if (this._autoScrollAnimationFrame) {
	      this.win.cancelAnimationFrame(this._autoScrollAnimationFrame);
	    }
	  },

	  _hoveredNode: null,

	  /**
	   * Show a NodeFront's container as being hovered
	   *
	   * @param  {NodeFront} nodeFront
	   *         The node to show as hovered
	   */
	  _showContainerAsHovered: function (nodeFront) {
	    if (this._hoveredNode === nodeFront) {
	      return;
	    }

	    if (this._hoveredNode) {
	      this.getContainer(this._hoveredNode).hovered = false;
	    }

	    this.getContainer(nodeFront).hovered = true;
	    this._hoveredNode = nodeFront;
	  },

	  _onMouseOut: function (event) {
	    // Emulate mouseleave by skipping any relatedTarget inside the markup-view.
	    if (this._elt.contains(event.relatedTarget)) {
	      return;
	    }

	    if (this._autoScrollAnimationFrame) {
	      this.win.cancelAnimationFrame(this._autoScrollAnimationFrame);
	    }
	    if (this.isDragging) {
	      return;
	    }

	    this._hideBoxModel(true);
	    if (this._hoveredNode) {
	      this.getContainer(this._hoveredNode).hovered = false;
	    }
	    this._hoveredNode = null;

	    this.emit("leave");
	  },

	  /**
	   * Show the box model highlighter on a given node front
	   *
	   * @param  {NodeFront} nodeFront
	   *         The node to show the highlighter for
	   * @return {Promise} Resolves when the highlighter for this nodeFront is
	   *         shown, taking into account that there could already be highlighter
	   *         requests queued up
	   */
	  _showBoxModel: function (nodeFront) {
	    return this._inspector.toolbox.highlighterUtils
	      .highlightNodeFront(nodeFront);
	  },

	  /**
	   * Hide the box model highlighter on a given node front
	   *
	   * @param  {NodeFront} nodeFront
	   *         The node to hide the highlighter for
	   * @param  {Boolean} forceHide
	   *         See toolbox-highlighter-utils/unhighlight
	   * @return {Promise} Resolves when the highlighter for this nodeFront is
	   *         hidden, taking into account that there could already be highlighter
	   *         requests queued up
	   */
	  _hideBoxModel: function (forceHide) {
	    return this._inspector.toolbox.highlighterUtils.unhighlight(forceHide);
	  },

	  _briefBoxModelTimer: null,

	  _clearBriefBoxModelTimer: function () {
	    if (this._briefBoxModelTimer) {
	      clearTimeout(this._briefBoxModelTimer);
	      this._briefBoxModelPromise.resolve();
	      this._briefBoxModelPromise = null;
	      this._briefBoxModelTimer = null;
	    }
	  },

	  _brieflyShowBoxModel: function (nodeFront) {
	    this._clearBriefBoxModelTimer();
	    let onShown = this._showBoxModel(nodeFront);
	    this._briefBoxModelPromise = defer();

	    this._briefBoxModelTimer = setTimeout(() => {
	      this._hideBoxModel()
	          .then(this._briefBoxModelPromise.resolve,
	                this._briefBoxModelPromise.resolve);
	    }, NEW_SELECTION_HIGHLIGHTER_TIMER);

	    return promise.all([onShown, this._briefBoxModelPromise.promise]);
	  },

	  template: function (name, dest, options = {stack: "markup.xhtml"}) {
	    let node = this.doc.getElementById("template-" + name).cloneNode(true);
	    node.removeAttribute("id");
	    template(node, dest, options);
	    return node;
	  },

	  /**
	   * Get the MarkupContainer object for a given node, or undefined if
	   * none exists.
	   */
	  getContainer: function (node) {
	    return this._containers.get(node);
	  },

	  update: function () {
	    let updateChildren = (node) => {
	      this.getContainer(node).update();
	      for (let child of node.treeChildren()) {
	        updateChildren(child);
	      }
	    };

	    // Start with the documentElement
	    let documentElement;
	    for (let node of this._rootNode.treeChildren()) {
	      if (node.isDocumentElement === true) {
	        documentElement = node;
	        break;
	      }
	    }

	    // Recursively update each node starting with documentElement.
	    updateChildren(documentElement);
	  },

	  /**
	   * Executed when the mouse hovers over a target in the markup-view and is used
	   * to decide whether this target should be used to display an image preview
	   * tooltip.
	   * Delegates the actual decision to the corresponding MarkupContainer instance
	   * if one is found.
	   *
	   * @return {Promise} the promise returned by
	   *         MarkupElementContainer._isImagePreviewTarget
	   */
	  _isImagePreviewTarget: Task.async(function* (target) {
	    // From the target passed here, let's find the parent MarkupContainer
	    // and ask it if the tooltip should be shown
	    if (this.isDragging) {
	      return false;
	    }

	    let parent = target, container;
	    while (parent !== this.doc.body) {
	      if (parent.container) {
	        container = parent.container;
	        break;
	      }
	      parent = parent.parentNode;
	    }

	    if (container instanceof MarkupElementContainer) {
	      // With the newly found container, delegate the tooltip content creation
	      // and decision to show or not the tooltip
	      return container.isImagePreviewTarget(target, this.imagePreviewTooltip);
	    }

	    return false;
	  }),

	  /**
	   * Given the known reason, should the current selection be briefly highlighted
	   * In a few cases, we don't want to highlight the node:
	   * - If the reason is null (used to reset the selection),
	   * - if it's "inspector-open" (when the inspector opens up, let's not
	   * highlight the default node)
	   * - if it's "navigateaway" (since the page is being navigated away from)
	   * - if it's "test" (this is a special case for mochitest. In tests, we often
	   * need to select elements but don't necessarily want the highlighter to come
	   * and go after a delay as this might break test scenarios)
	   * We also do not want to start a brief highlight timeout if the node is
	   * already being hovered over, since in that case it will already be
	   * highlighted.
	   */
	  _shouldNewSelectionBeHighlighted: function () {
	    let reason = this._inspector.selection.reason;
	    let unwantedReasons = [
	      "inspector-open",
	      "navigateaway",
	      "nodeselected",
	      "test"
	    ];
	    let isHighlight = this._hoveredNode === this._inspector.selection.nodeFront;
	    return !isHighlight && reason && unwantedReasons.indexOf(reason) === -1;
	  },

	  /**
	   * React to new-node-front selection events.
	   * Highlights the node if needed, and make sure it is shown and selected in
	   * the view.
	   */
	  _onNewSelection: function () {
	    let selection = this._inspector.selection;

	    this.htmlEditor.hide();
	    if (this._hoveredNode && this._hoveredNode !== selection.nodeFront) {
	      this.getContainer(this._hoveredNode).hovered = false;
	      this._hoveredNode = null;
	    }

	    if (!selection.isNode()) {
	      this.unmarkSelectedNode();
	      return;
	    }

	    let done = this._inspector.updating("markup-view");
	    let onShowBoxModel, onShow;

	    // Highlight the element briefly if needed.
	    if (this._shouldNewSelectionBeHighlighted()) {
	      onShowBoxModel = this._brieflyShowBoxModel(selection.nodeFront);
	    }

	    onShow = this.showNode(selection.nodeFront).then(() => {
	      // We could be destroyed by now.
	      if (this._destroyer) {
	        return promise.reject("markupview destroyed");
	      }

	      // Mark the node as selected.
	      this.markNodeAsSelected(selection.nodeFront);

	      // Make sure the new selection is navigated to.
	      this.maybeNavigateToNewSelection();
	      return undefined;
	    }).catch(this._handleRejectionIfNotDestroyed);

	    promise.all([onShowBoxModel, onShow]).then(done);
	  },

	  /**
	   * Maybe make selected the current node selection's MarkupContainer depending
	   * on why the current node got selected.
	   */
	  maybeNavigateToNewSelection: function () {
	    let {reason, nodeFront} = this._inspector.selection;

	    // The list of reasons that should lead to navigating to the node.
	    let reasonsToNavigate = [
	      // If the user picked an element with the element picker.
	      "picker-node-picked",
	      // If the user selected an element with the browser context menu.
	      "browser-context-menu",
	      // If the user added a new node by clicking in the inspector toolbar.
	      "node-inserted"
	    ];

	    if (reasonsToNavigate.includes(reason)) {
	      this.getContainer(this._rootNode).elt.focus();
	      this.navigate(this.getContainer(nodeFront));
	    }
	  },

	  /**
	   * Create a TreeWalker to find the next/previous
	   * node for selection.
	   */
	  _selectionWalker: function (start) {
	    let walker = this.doc.createTreeWalker(
	      start || this._elt,
	      nodeFilterConstants.SHOW_ELEMENT,
	      function (element) {
	        if (element.container &&
	            element.container.elt === element &&
	            element.container.visible) {
	          return nodeFilterConstants.FILTER_ACCEPT;
	        }
	        return nodeFilterConstants.FILTER_SKIP;
	      }
	    );
	    walker.currentNode = this._selectedContainer.elt;
	    return walker;
	  },

	  _onCopy: function (evt) {
	    // Ignore copy events from editors
	    if (this._isInputOrTextarea(evt.target)) {
	      return;
	    }

	    let selection = this._inspector.selection;
	    if (selection.isNode()) {
	      this._inspector.copyOuterHTML();
	    }
	    evt.stopPropagation();
	    evt.preventDefault();
	  },

	  /**
	   * Register all key shortcuts.
	   */
	  _initShortcuts: function () {
	    let shortcuts = new KeyShortcuts({
	      window: this.win,
	    });

	    this._onShortcut = this._onShortcut.bind(this);

	    // Process localizable keys
	    ["markupView.hide.key",
	     "markupView.edit.key",
	     "markupView.scrollInto.key"].forEach(name => {
	       let key = INSPECTOR_L10N.getStr(name);
	       shortcuts.on(key, (_, event) => this._onShortcut(name, event));
	     });

	    // Process generic keys:
	    ["Delete", "Backspace", "Home", "Left", "Right", "Up", "Down", "PageUp",
	     "PageDown", "Esc", "Enter", "Space"].forEach(key => {
	       shortcuts.on(key, this._onShortcut);
	     });
	  },

	  /**
	   * Key shortcut listener.
	   */
	  _onShortcut(name, event) {
	    if (this._isInputOrTextarea(event.target)) {
	      return;
	    }
	    switch (name) {
	      // Localizable keys
	      case "markupView.hide.key": {
	        let node = this._selectedContainer.node;
	        if (node.hidden) {
	          this.walker.unhideNode(node);
	        } else {
	          this.walker.hideNode(node);
	        }
	        break;
	      }
	      case "markupView.edit.key": {
	        this.beginEditingOuterHTML(this._selectedContainer.node);
	        break;
	      }
	      case "markupView.scrollInto.key": {
	        let selection = this._selectedContainer.node;
	        this._inspector.scrollNodeIntoView(selection);
	        break;
	      }
	      // Generic keys
	      case "Delete": {
	        this.deleteNodeOrAttribute();
	        break;
	      }
	      case "Backspace": {
	        this.deleteNodeOrAttribute(true);
	        break;
	      }
	      case "Home": {
	        let rootContainer = this.getContainer(this._rootNode);
	        this.navigate(rootContainer.children.firstChild.container);
	        break;
	      }
	      case "Left": {
	        if (this._selectedContainer.expanded) {
	          this.collapseNode(this._selectedContainer.node);
	        } else {
	          let parent = this._selectionWalker().parentNode();
	          if (parent) {
	            this.navigate(parent.container);
	          }
	        }
	        break;
	      }
	      case "Right": {
	        if (!this._selectedContainer.expanded &&
	            this._selectedContainer.hasChildren) {
	          this._expandContainer(this._selectedContainer);
	        } else {
	          let next = this._selectionWalker().nextNode();
	          if (next) {
	            this.navigate(next.container);
	          }
	        }
	        break;
	      }
	      case "Up": {
	        let previousNode = this._selectionWalker().previousNode();
	        if (previousNode) {
	          this.navigate(previousNode.container);
	        }
	        break;
	      }
	      case "Down": {
	        let nextNode = this._selectionWalker().nextNode();
	        if (nextNode) {
	          this.navigate(nextNode.container);
	        }
	        break;
	      }
	      case "PageUp": {
	        let walker = this._selectionWalker();
	        let selection = this._selectedContainer;
	        for (let i = 0; i < PAGE_SIZE; i++) {
	          let previousNode = walker.previousNode();
	          if (!previousNode) {
	            break;
	          }
	          selection = previousNode.container;
	        }
	        this.navigate(selection);
	        break;
	      }
	      case "PageDown": {
	        let walker = this._selectionWalker();
	        let selection = this._selectedContainer;
	        for (let i = 0; i < PAGE_SIZE; i++) {
	          let nextNode = walker.nextNode();
	          if (!nextNode) {
	            break;
	          }
	          selection = nextNode.container;
	        }
	        this.navigate(selection);
	        break;
	      }
	      case "Enter":
	      case "Space": {
	        if (!this._selectedContainer.canFocus) {
	          this._selectedContainer.canFocus = true;
	          this._selectedContainer.focus();
	        } else {
	          // Return early to prevent cancelling the event.
	          return;
	        }
	        break;
	      }
	      case "Esc": {
	        if (this.isDragging) {
	          this.cancelDragging();
	        } else {
	          // Return early to prevent cancelling the event when not
	          // dragging, to allow the split console to be toggled.
	          return;
	        }
	        break;
	      }
	      default:
	        console.error("Unexpected markup-view key shortcut", name);
	        return;
	    }
	    // Prevent default for this action
	    event.stopPropagation();
	    event.preventDefault();
	  },

	  /**
	   * Check if a node is an input or textarea
	   */
	  _isInputOrTextarea: function (element) {
	    let name = element.tagName.toLowerCase();
	    return name === "input" || name === "textarea";
	  },

	  /**
	   * If there's an attribute on the current node that's currently focused, then
	   * delete this attribute, otherwise delete the node itself.
	   *
	   * @param  {Boolean} moveBackward
	   *         If set to true and if we're deleting the node, focus the previous
	   *         sibling after deletion, otherwise the next one.
	   */
	  deleteNodeOrAttribute: function (moveBackward) {
	    let focusedAttribute = this.doc.activeElement
	                           ? this.doc.activeElement.closest(".attreditor")
	                           : null;
	    if (focusedAttribute) {
	      // The focused attribute might not be in the current selected container.
	      let container = focusedAttribute.closest("li.child").container;
	      container.removeAttribute(focusedAttribute.dataset.attr);
	    } else {
	      this.deleteNode(this._selectedContainer.node, moveBackward);
	    }
	  },

	  /**
	   * Delete a node from the DOM.
	   * This is an undoable action.
	   *
	   * @param  {NodeFront} node
	   *         The node to remove.
	   * @param  {Boolean} moveBackward
	   *         If set to true, focus the previous sibling, otherwise the next one.
	   */
	  deleteNode: function (node, moveBackward) {
	    if (node.isDocumentElement ||
	        node.nodeType == nodeConstants.DOCUMENT_TYPE_NODE ||
	        node.isAnonymous) {
	      return;
	    }

	    let container = this.getContainer(node);

	    // Retain the node so we can undo this...
	    this.walker.retainNode(node).then(() => {
	      let parent = node.parentNode();
	      let nextSibling = null;
	      this.undo.do(() => {
	        this.walker.removeNode(node).then(siblings => {
	          nextSibling = siblings.nextSibling;
	          let prevSibling = siblings.previousSibling;
	          let focusNode = moveBackward ? prevSibling : nextSibling;

	          // If we can't move as the user wants, we move to the other direction.
	          // If there is no sibling elements anymore, move to the parent node.
	          if (!focusNode) {
	            focusNode = nextSibling || prevSibling || parent;
	          }

	          let isNextSiblingText = nextSibling ?
	            nextSibling.nodeType === nodeConstants.TEXT_NODE : false;
	          let isPrevSiblingText = prevSibling ?
	            prevSibling.nodeType === nodeConstants.TEXT_NODE : false;

	          // If the parent had two children and the next or previous sibling
	          // is a text node, then it now has only a single text node, is about
	          // to be in-lined; and focus should move to the parent.
	          if (parent.numChildren === 2
	              && (isNextSiblingText || isPrevSiblingText)) {
	            focusNode = parent;
	          }

	          if (container.selected) {
	            this.navigate(this.getContainer(focusNode));
	          }
	        });
	      }, () => {
	        let isValidSibling = nextSibling && !nextSibling.isPseudoElement;
	        nextSibling = isValidSibling ? nextSibling : null;
	        this.walker.insertBefore(node, parent, nextSibling);
	      });
	    }).then(null, console.error);
	  },

	  /**
	   * If an editable item is focused, select its container.
	   */
	  _onFocus: function (event) {
	    let parent = event.target;
	    while (!parent.container) {
	      parent = parent.parentNode;
	    }
	    if (parent) {
	      this.navigate(parent.container);
	    }
	  },

	  /**
	   * Handle a user-requested navigation to a given MarkupContainer,
	   * updating the inspector's currently-selected node.
	   *
	   * @param  {MarkupContainer} container
	   *         The container we're navigating to.
	   */
	  navigate: function (container) {
	    if (!container) {
	      return;
	    }

	    let node = container.node;
	    this.markNodeAsSelected(node, "treepanel");
	  },

	  /**
	   * Make sure a node is included in the markup tool.
	   *
	   * @param  {NodeFront} node
	   *         The node in the content document.
	   * @param  {Boolean} flashNode
	   *         Whether the newly imported node should be flashed
	   * @return {MarkupContainer} The MarkupContainer object for this element.
	   */
	  importNode: function (node, flashNode) {
	    if (!node) {
	      return null;
	    }

	    if (this._containers.has(node)) {
	      return this.getContainer(node);
	    }

	    let container;
	    let {nodeType, isPseudoElement} = node;
	    if (node === this.walker.rootNode) {
	      container = new RootContainer(this, node);
	      this._elt.appendChild(container.elt);
	      this._rootNode = node;
	    } else if (nodeType == nodeConstants.ELEMENT_NODE && !isPseudoElement) {
	      container = new MarkupElementContainer(this, node, this._inspector);
	    } else if (nodeType == nodeConstants.COMMENT_NODE ||
	               nodeType == nodeConstants.TEXT_NODE) {
	      container = new MarkupTextContainer(this, node, this._inspector);
	    } else {
	      container = new MarkupReadOnlyContainer(this, node, this._inspector);
	    }

	    if (flashNode) {
	      container.flashMutation();
	    }

	    this._containers.set(node, container);
	    container.childrenDirty = true;

	    this._updateChildren(container);

	    this._inspector.emit("container-created", container);

	    return container;
	  },

	  /**
	   * Mutation observer used for included nodes.
	   */
	  _mutationObserver: function (mutations) {
	    for (let mutation of mutations) {
	      let type = mutation.type;
	      let target = mutation.target;

	      if (mutation.type === "documentUnload") {
	        // Treat this as a childList change of the child (maybe the protocol
	        // should do this).
	        type = "childList";
	        target = mutation.targetParent;
	        if (!target) {
	          continue;
	        }
	      }

	      let container = this.getContainer(target);
	      if (!container) {
	        // Container might not exist if this came from a load event for a node
	        // we're not viewing.
	        continue;
	      }

	      if (type === "attributes" && mutation.attributeName === "class") {
	        container.updateIsDisplayed();
	      }
	      if (type === "attributes" || type === "characterData"
	        || type === "events" || type === "pseudoClassLock") {
	        container.update();
	      } else if (type === "childList" || type === "nativeAnonymousChildList") {
	        container.childrenDirty = true;
	        // Update the children to take care of changes in the markup view DOM
	        // and update container (and its subtree) DOM tree depth level for
	        // accessibility where necessary.
	        this._updateChildren(container, {flash: true}).then(() =>
	          container.updateLevel());
	      } else if (type === "inlineTextChild") {
	        container.childrenDirty = true;
	        this._updateChildren(container, {flash: true});
	        container.update();
	      }
	    }

	    this._waitForChildren().then(() => {
	      if (this._destroyer) {
	        // Could not fully update after markup mutations, the markup-view was destroyed
	        // while waiting for children. Bail out silently.
	        return;
	      }
	      this._flashMutatedNodes(mutations);
	      this._inspector.emit("markupmutation", mutations);

	      // Since the htmlEditor is absolutely positioned, a mutation may change
	      // the location in which it should be shown.
	      this.htmlEditor.refresh();
	    });
	  },

	  /**
	   * React to display-change events from the walker
	   *
	   * @param  {Array} nodes
	   *         An array of nodeFronts
	   */
	  _onDisplayChange: function (nodes) {
	    for (let node of nodes) {
	      let container = this.getContainer(node);
	      if (container) {
	        container.updateIsDisplayed();
	      }
	    }
	  },

	  /**
	   * Given a list of mutations returned by the mutation observer, flash the
	   * corresponding containers to attract attention.
	   */
	  _flashMutatedNodes: function (mutations) {
	    let addedOrEditedContainers = new Set();
	    let removedContainers = new Set();

	    for (let {type, target, added, removed, newValue} of mutations) {
	      let container = this.getContainer(target);

	      if (container) {
	        if (type === "characterData") {
	          addedOrEditedContainers.add(container);
	        } else if (type === "attributes" && newValue === null) {
	          // Removed attributes should flash the entire node.
	          // New or changed attributes will flash the attribute itself
	          // in ElementEditor.flashAttribute.
	          addedOrEditedContainers.add(container);
	        } else if (type === "childList") {
	          // If there has been removals, flash the parent
	          if (removed.length) {
	            removedContainers.add(container);
	          }

	          // If there has been additions, flash the nodes if their associated
	          // container exist (so if their parent is expanded in the inspector).
	          added.forEach(node => {
	            let addedContainer = this.getContainer(node);
	            if (addedContainer) {
	              addedOrEditedContainers.add(addedContainer);

	              // The node may be added as a result of an append, in which case
	              // it will have been removed from another container first, but in
	              // these cases we don't want to flash both the removal and the
	              // addition
	              removedContainers.delete(container);
	            }
	          });
	        }
	      }
	    }

	    for (let container of removedContainers) {
	      container.flashMutation();
	    }
	    for (let container of addedOrEditedContainers) {
	      container.flashMutation();
	    }
	  },

	  /**
	   * Make sure the given node's parents are expanded and the
	   * node is scrolled on to screen.
	   */
	  showNode: function (node, centered = true) {
	    let parent = node;

	    this.importNode(node);

	    while ((parent = parent.parentNode())) {
	      this.importNode(parent);
	      this.expandNode(parent);
	    }

	    return this._waitForChildren().then(() => {
	      if (this._destroyer) {
	        return promise.reject("markupview destroyed");
	      }
	      return this._ensureVisible(node);
	    }).then(() => {
	      scrollIntoViewIfNeeded(this.getContainer(node).editor.elt, centered);
	    }, this._handleRejectionIfNotDestroyed);
	  },

	  /**
	   * Expand the container's children.
	   */
	  _expandContainer: function (container) {
	    return this._updateChildren(container, {expand: true}).then(() => {
	      if (this._destroyer) {
	        // Could not expand the node, the markup-view was destroyed in the meantime. Just
	        // silently give up.
	        return;
	      }
	      container.setExpanded(true);
	    });
	  },

	  /**
	   * Expand the node's children.
	   */
	  expandNode: function (node) {
	    let container = this.getContainer(node);
	    this._expandContainer(container);
	  },

	  /**
	   * Expand the entire tree beneath a container.
	   *
	   * @param  {MarkupContainer} container
	   *         The container to expand.
	   */
	  _expandAll: function (container) {
	    return this._expandContainer(container).then(() => {
	      let child = container.children.firstChild;
	      let promises = [];
	      while (child) {
	        promises.push(this._expandAll(child.container));
	        child = child.nextSibling;
	      }
	      return promise.all(promises);
	    }).then(null, console.error);
	  },

	  /**
	   * Expand the entire tree beneath a node.
	   *
	   * @param  {DOMNode} node
	   *         The node to expand, or null to start from the top.
	   */
	  expandAll: function (node) {
	    node = node || this._rootNode;
	    return this._expandAll(this.getContainer(node));
	  },

	  /**
	   * Collapse the node's children.
	   */
	  collapseNode: function (node) {
	    let container = this.getContainer(node);
	    container.setExpanded(false);
	  },

	  /**
	   * Returns either the innerHTML or the outerHTML for a remote node.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to get the outerHTML / innerHTML for.
	   * @param  {Boolean} isOuter
	   *         If true, makes the function return the outerHTML,
	   *         otherwise the innerHTML.
	   * @return {Promise} that will be resolved with the outerHTML / innerHTML.
	   */
	  _getNodeHTML: function (node, isOuter) {
	    let walkerPromise = null;

	    if (isOuter) {
	      walkerPromise = this.walker.outerHTML(node);
	    } else {
	      walkerPromise = this.walker.innerHTML(node);
	    }

	    return walkerPromise.then(longstr => {
	      return longstr.string().then(html => {
	        longstr.release().then(null, console.error);
	        return html;
	      });
	    });
	  },

	  /**
	   * Retrieve the outerHTML for a remote node.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to get the outerHTML for.
	   * @return {Promise} that will be resolved with the outerHTML.
	   */
	  getNodeOuterHTML: function (node) {
	    return this._getNodeHTML(node, true);
	  },

	  /**
	   * Retrieve the innerHTML for a remote node.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to get the innerHTML for.
	   * @return {Promise} that will be resolved with the innerHTML.
	   */
	  getNodeInnerHTML: function (node) {
	    return this._getNodeHTML(node);
	  },

	  /**
	   * Listen to mutations, expect a given node to be removed and try and select
	   * the node that sits at the same place instead.
	   * This is useful when changing the outerHTML or the tag name so that the
	   * newly inserted node gets selected instead of the one that just got removed.
	   */
	  reselectOnRemoved: function (removedNode, reason) {
	    // Only allow one removed node reselection at a time, so that when there are
	    // more than 1 request in parallel, the last one wins.
	    this.cancelReselectOnRemoved();

	    // Get the removedNode index in its parent node to reselect the right node.
	    let isHTMLTag = removedNode.tagName.toLowerCase() === "html";
	    let oldContainer = this.getContainer(removedNode);
	    let parentContainer = this.getContainer(removedNode.parentNode());
	    let childIndex = parentContainer.getChildContainers().indexOf(oldContainer);

	    let onMutations = this._removedNodeObserver = (e, mutations) => {
	      let isNodeRemovalMutation = false;
	      for (let mutation of mutations) {
	        let containsRemovedNode = mutation.removed &&
	                                  mutation.removed.some(n => n === removedNode);
	        if (mutation.type === "childList" &&
	            (containsRemovedNode || isHTMLTag)) {
	          isNodeRemovalMutation = true;
	          break;
	        }
	      }
	      if (!isNodeRemovalMutation) {
	        return;
	      }

	      this._inspector.off("markupmutation", onMutations);
	      this._removedNodeObserver = null;

	      // Don't select the new node if the user has already changed the current
	      // selection.
	      if (this._inspector.selection.nodeFront === parentContainer.node ||
	          (this._inspector.selection.nodeFront === removedNode && isHTMLTag)) {
	        let childContainers = parentContainer.getChildContainers();
	        if (childContainers && childContainers[childIndex]) {
	          this.markNodeAsSelected(childContainers[childIndex].node, reason);
	          if (childContainers[childIndex].hasChildren) {
	            this.expandNode(childContainers[childIndex].node);
	          }
	          this.emit("reselectedonremoved");
	        }
	      }
	    };

	    // Start listening for mutations until we find a childList change that has
	    // removedNode removed.
	    this._inspector.on("markupmutation", onMutations);
	  },

	  /**
	   * Make sure to stop listening for node removal markupmutations and not
	   * reselect the corresponding node when that happens.
	   * Useful when the outerHTML/tagname edition failed.
	   */
	  cancelReselectOnRemoved: function () {
	    if (this._removedNodeObserver) {
	      this._inspector.off("markupmutation", this._removedNodeObserver);
	      this._removedNodeObserver = null;
	      this.emit("canceledreselectonremoved");
	    }
	  },

	  /**
	   * Replace the outerHTML of any node displayed in the inspector with
	   * some other HTML code
	   *
	   * @param  {NodeFront} node
	   *         Node which outerHTML will be replaced.
	   * @param  {String} newValue
	   *         The new outerHTML to set on the node.
	   * @param  {String} oldValue
	   *         The old outerHTML that will be used if the user undoes the update.
	   * @return {Promise} that will resolve when the outer HTML has been updated.
	   */
	  updateNodeOuterHTML: function (node, newValue) {
	    let container = this.getContainer(node);
	    if (!container) {
	      return promise.reject();
	    }

	    // Changing the outerHTML removes the node which outerHTML was changed.
	    // Listen to this removal to reselect the right node afterwards.
	    this.reselectOnRemoved(node, "outerhtml");
	    return this.walker.setOuterHTML(node, newValue).then(null, () => {
	      this.cancelReselectOnRemoved();
	    });
	  },

	  /**
	   * Replace the innerHTML of any node displayed in the inspector with
	   * some other HTML code
	   * @param  {Node} node
	   *         node which innerHTML will be replaced.
	   * @param  {String} newValue
	   *         The new innerHTML to set on the node.
	   * @param  {String} oldValue
	   *         The old innerHTML that will be used if the user undoes the update.
	   * @return {Promise} that will resolve when the inner HTML has been updated.
	   */
	  updateNodeInnerHTML: function (node, newValue, oldValue) {
	    let container = this.getContainer(node);
	    if (!container) {
	      return promise.reject();
	    }

	    let def = defer();

	    container.undo.do(() => {
	      this.walker.setInnerHTML(node, newValue).then(def.resolve, def.reject);
	    }, () => {
	      this.walker.setInnerHTML(node, oldValue);
	    });

	    return def.promise;
	  },

	  /**
	   * Insert adjacent HTML to any node displayed in the inspector.
	   *
	   * @param  {NodeFront} node
	   *         The reference node.
	   * @param  {String} position
	   *         The position as specified for Element.insertAdjacentHTML
	   *         (i.e. "beforeBegin", "afterBegin", "beforeEnd", "afterEnd").
	   * @param  {String} newValue
	   *         The adjacent HTML.
	   * @return {Promise} that will resolve when the adjacent HTML has
	   *         been inserted.
	   */
	  insertAdjacentHTMLToNode: function (node, position, value) {
	    let container = this.getContainer(node);
	    if (!container) {
	      return promise.reject();
	    }

	    let def = defer();

	    let injectedNodes = [];
	    container.undo.do(() => {
	      this.walker.insertAdjacentHTML(node, position, value).then(nodeArray => {
	        injectedNodes = nodeArray.nodes;
	        return nodeArray;
	      }).then(def.resolve, def.reject);
	    }, () => {
	      this.walker.removeNodes(injectedNodes);
	    });

	    return def.promise;
	  },

	  /**
	   * Open an editor in the UI to allow editing of a node's outerHTML.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to edit.
	   */
	  beginEditingOuterHTML: function (node) {
	    this.getNodeOuterHTML(node).then(oldValue => {
	      let container = this.getContainer(node);
	      if (!container) {
	        return;
	      }
	      this.htmlEditor.show(container.tagLine, oldValue);
	      this.htmlEditor.once("popuphidden", (e, commit, value) => {
	        // Need to focus the <html> element instead of the frame / window
	        // in order to give keyboard focus back to doc (from editor).
	        this.doc.documentElement.focus();

	        if (commit) {
	          this.updateNodeOuterHTML(node, value, oldValue);
	        }
	      });
	    });
	  },

	  /**
	   * Mark the given node expanded.
	   *
	   * @param  {NodeFront} node
	   *         The NodeFront to mark as expanded.
	   * @param  {Boolean} expanded
	   *         Whether the expand or collapse.
	   * @param  {Boolean} expandDescendants
	   *         Whether to expand all descendants too
	   */
	  setNodeExpanded: function (node, expanded, expandDescendants) {
	    if (expanded) {
	      if (expandDescendants) {
	        this.expandAll(node);
	      } else {
	        this.expandNode(node);
	      }
	    } else {
	      this.collapseNode(node);
	    }
	  },

	  /**
	   * Mark the given node selected, and update the inspector.selection
	   * object's NodeFront to keep consistent state between UI and selection.
	   *
	   * @param  {NodeFront} aNode
	   *         The NodeFront to mark as selected.
	   * @param  {String} reason
	   *         The reason for marking the node as selected.
	   * @return {Boolean} False if the node is already marked as selected, true
	   *         otherwise.
	   */
	  markNodeAsSelected: function (node, reason) {
	    let container = this.getContainer(node);

	    if (this._selectedContainer === container) {
	      return false;
	    }

	    // Un-select and remove focus from the previous container.
	    if (this._selectedContainer) {
	      this._selectedContainer.selected = false;
	      this._selectedContainer.clearFocus();
	    }

	    // Select the new container.
	    this._selectedContainer = container;
	    if (node) {
	      this._selectedContainer.selected = true;
	    }

	    // Change the current selection if needed.
	    if (this._inspector.selection.nodeFront !== node) {
	      this._inspector.selection.setNodeFront(node, reason || "nodeselected");
	    }

	    return true;
	  },

	  /**
	   * Make sure that every ancestor of the selection are updated
	   * and included in the list of visible children.
	   */
	  _ensureVisible: function (node) {
	    while (node) {
	      let container = this.getContainer(node);
	      let parent = node.parentNode();
	      if (!container.elt.parentNode) {
	        let parentContainer = this.getContainer(parent);
	        if (parentContainer) {
	          parentContainer.childrenDirty = true;
	          this._updateChildren(parentContainer, {expand: true});
	        }
	      }

	      node = parent;
	    }
	    return this._waitForChildren();
	  },

	  /**
	   * Unmark selected node (no node selected).
	   */
	  unmarkSelectedNode: function () {
	    if (this._selectedContainer) {
	      this._selectedContainer.selected = false;
	      this._selectedContainer = null;
	    }
	  },

	  /**
	   * Check if the current selection is a descendent of the container.
	   * if so, make sure it's among the visible set for the container,
	   * and set the dirty flag if needed.
	   *
	   * @return The node that should be made visible, if any.
	   */
	  _checkSelectionVisible: function (container) {
	    let centered = null;
	    let node = this._inspector.selection.nodeFront;
	    while (node) {
	      if (node.parentNode() === container.node) {
	        centered = node;
	        break;
	      }
	      node = node.parentNode();
	    }

	    return centered;
	  },

	  /**
	   * Make sure all children of the given container's node are
	   * imported and attached to the container in the right order.
	   *
	   * Children need to be updated only in the following circumstances:
	   * a) We just imported this node and have never seen its children.
	   *    container.childrenDirty will be set by importNode in this case.
	   * b) We received a childList mutation on the node.
	   *    container.childrenDirty will be set in that case too.
	   * c) We have changed the selection, and the path to that selection
	   *    wasn't loaded in a previous children request (because we only
	   *    grab a subset).
	   *    container.childrenDirty should be set in that case too!
	   *
	   * @param  {MarkupContainer} container
	   *         The markup container whose children need updating
	   * @param  {Object} options
	   *         Options are {expand:boolean,flash:boolean}
	   * @return {Promise} that will be resolved when the children are ready
	   *         (which may be immediately).
	   */
	  _updateChildren: function (container, options) {
	    let expand = options && options.expand;
	    let flash = options && options.flash;

	    container.hasChildren = container.node.hasChildren;
	    // Accessibility should either ignore empty children or semantically
	    // consider them a group.
	    container.setChildrenRole();

	    if (!this._queuedChildUpdates) {
	      this._queuedChildUpdates = new Map();
	    }

	    if (this._queuedChildUpdates.has(container)) {
	      return this._queuedChildUpdates.get(container);
	    }

	    if (!container.childrenDirty) {
	      return promise.resolve(container);
	    }

	    if (container.inlineTextChild
	        && container.inlineTextChild != container.node.inlineTextChild) {
	      // This container was doing double duty as a container for a single
	      // text child, back that out.
	      this._containers.delete(container.inlineTextChild);
	      container.clearInlineTextChild();

	      if (container.hasChildren && container.selected) {
	        container.setExpanded(true);
	      }
	    }

	    if (container.node.inlineTextChild) {
	      container.setExpanded(false);
	      // this container will do double duty as the container for the single
	      // text child.
	      while (container.children.firstChild) {
	        container.children.removeChild(container.children.firstChild);
	      }

	      container.setInlineTextChild(container.node.inlineTextChild);

	      this._containers.set(container.node.inlineTextChild, container);
	      container.childrenDirty = false;
	      return promise.resolve(container);
	    }

	    if (!container.hasChildren) {
	      while (container.children.firstChild) {
	        container.children.removeChild(container.children.firstChild);
	      }
	      container.childrenDirty = false;
	      container.setExpanded(false);
	      return promise.resolve(container);
	    }

	    // If we're not expanded (or asked to update anyway), we're done for
	    // now.  Note that this will leave the childrenDirty flag set, so when
	    // expanded we'll refresh the child list.
	    if (!(container.expanded || expand)) {
	      return promise.resolve(container);
	    }

	    // We're going to issue a children request, make sure it includes the
	    // centered node.
	    let centered = this._checkSelectionVisible(container);

	    // Children aren't updated yet, but clear the childrenDirty flag anyway.
	    // If the dirty flag is re-set while we're fetching we'll need to fetch
	    // again.
	    container.childrenDirty = false;
	    let updatePromise =
	      this._getVisibleChildren(container, centered).then(children => {
	        if (!this._containers) {
	          return promise.reject("markup view destroyed");
	        }
	        this._queuedChildUpdates.delete(container);

	        // If children are dirty, we got a change notification for this node
	        // while the request was in progress, we need to do it again.
	        if (container.childrenDirty) {
	          return this._updateChildren(container, {expand: centered});
	        }

	        let fragment = this.doc.createDocumentFragment();

	        for (let child of children.nodes) {
	          let childContainer = this.importNode(child, flash);
	          fragment.appendChild(childContainer.elt);
	        }

	        while (container.children.firstChild) {
	          container.children.removeChild(container.children.firstChild);
	        }

	        if (!(children.hasFirst && children.hasLast)) {
	          let nodesCount = container.node.numChildren;
	          let showAllString = PluralForm.get(nodesCount,
	            INSPECTOR_L10N.getStr("markupView.more.showAll2"));
	          let data = {
	            showing: INSPECTOR_L10N.getStr("markupView.more.showing"),
	            showAll: showAllString.replace("#1", nodesCount),
	            allButtonClick: () => {
	              container.maxChildren = -1;
	              container.childrenDirty = true;
	              this._updateChildren(container);
	            }
	          };

	          if (!children.hasFirst) {
	            let span = this.template("more-nodes", data);
	            fragment.insertBefore(span, fragment.firstChild);
	          }
	          if (!children.hasLast) {
	            let span = this.template("more-nodes", data);
	            fragment.appendChild(span);
	          }
	        }

	        container.children.appendChild(fragment);
	        return container;
	      }).catch(this._handleRejectionIfNotDestroyed);
	    this._queuedChildUpdates.set(container, updatePromise);
	    return updatePromise;
	  },

	  _waitForChildren: function () {
	    if (!this._queuedChildUpdates) {
	      return promise.resolve(undefined);
	    }

	    return promise.all([...this._queuedChildUpdates.values()]);
	  },

	  /**
	   * Return a list of the children to display for this container.
	   */
	  _getVisibleChildren: function (container, centered) {
	    let maxChildren = container.maxChildren || this.maxChildren;
	    if (maxChildren == -1) {
	      maxChildren = undefined;
	    }

	    return this.walker.children(container.node, {
	      maxNodes: maxChildren,
	      center: centered
	    });
	  },

	  /**
	   * Tear down the markup panel.
	   */
	  destroy: function () {
	    if (this._destroyer) {
	      return this._destroyer;
	    }

	    this._destroyer = promise.resolve();

	    this._clearBriefBoxModelTimer();

	    this._hoveredNode = null;

	    this.htmlEditor.destroy();
	    this.htmlEditor = null;

	    this.undo.destroy();
	    this.undo = null;

	    this.popup.destroy();
	    this.popup = null;

	    this._elt.removeEventListener("click", this._onMouseClick, false);
	    this._elt.removeEventListener("mousemove", this._onMouseMove, false);
	    this._elt.removeEventListener("mouseout", this._onMouseOut, false);
	    this._elt.removeEventListener("blur", this._onBlur, true);
	    this.win.removeEventListener("mouseup", this._onMouseUp);
	    this.win.removeEventListener("copy", this._onCopy);
	    this._frame.removeEventListener("focus", this._onFocus, false);
	    this.walker.off("mutations", this._mutationObserver);
	    this.walker.off("display-change", this._onDisplayChange);
	    this._inspector.selection.off("new-node-front", this._onNewSelection);
	    this._inspector.toolbox.off("picker-node-hovered",
	                                this._onToolboxPickerHover);

	    this._prefObserver.off(ATTR_COLLAPSE_ENABLED_PREF,
	                           this._onCollapseAttributesPrefChange);
	    this._prefObserver.off(ATTR_COLLAPSE_LENGTH_PREF,
	                           this._onCollapseAttributesPrefChange);
	    this._prefObserver.destroy();

	    this._elt = null;

	    for (let [, container] of this._containers) {
	      container.destroy();
	    }
	    this._containers = null;

	    this.eventDetailsTooltip.destroy();
	    this.eventDetailsTooltip = null;

	    this.imagePreviewTooltip.destroy();
	    this.imagePreviewTooltip = null;

	    this.win = null;
	    this.doc = null;

	    this._lastDropTarget = null;
	    this._lastDragTarget = null;

	    return this._destroyer;
	  },

	  /**
	   * Find the closest element with class tag-line. These are used to indicate
	   * drag and drop targets.
	   *
	   * @param  {DOMNode} el
	   * @return {DOMNode}
	   */
	  findClosestDragDropTarget: function (el) {
	    return el.classList.contains("tag-line")
	           ? el
	           : el.querySelector(".tag-line") || el.closest(".tag-line");
	  },

	  /**
	   * Takes an element as it's only argument and marks the element
	   * as the drop target
	   */
	  indicateDropTarget: function (el) {
	    if (this._lastDropTarget) {
	      this._lastDropTarget.classList.remove("drop-target");
	    }

	    if (!el) {
	      return;
	    }

	    let target = this.findClosestDragDropTarget(el);
	    if (target) {
	      target.classList.add("drop-target");
	      this._lastDropTarget = target;
	    }
	  },

	  /**
	   * Takes an element to mark it as indicator of dragging target's initial place
	   */
	  indicateDragTarget: function (el) {
	    if (this._lastDragTarget) {
	      this._lastDragTarget.classList.remove("drag-target");
	    }

	    if (!el) {
	      return;
	    }

	    let target = this.findClosestDragDropTarget(el);
	    if (target) {
	      target.classList.add("drag-target");
	      this._lastDragTarget = target;
	    }
	  },

	  /**
	   * Used to get the nodes required to modify the markup after dragging the
	   * element (parent/nextSibling).
	   */
	  get dropTargetNodes() {
	    let target = this._lastDropTarget;

	    if (!target) {
	      return null;
	    }

	    let parent, nextSibling;

	    if (target.previousElementSibling &&
	        target.previousElementSibling.nodeName.toLowerCase() === "ul") {
	      parent = target.parentNode.container.node;
	      nextSibling = null;
	    } else {
	      parent = target.parentNode.container.node.parentNode();
	      nextSibling = target.parentNode.container.node;
	    }

	    if (nextSibling && nextSibling.isBeforePseudoElement) {
	      nextSibling = target.parentNode.parentNode.children[1].container.node;
	    }
	    if (nextSibling && nextSibling.isAfterPseudoElement) {
	      parent = target.parentNode.container.node.parentNode();
	      nextSibling = null;
	    }

	    if (parent.nodeType !== nodeConstants.ELEMENT_NODE) {
	      return null;
	    }

	    return {parent, nextSibling};
	  }
	};

	/**
	 * The main structure for storing a document node in the markup
	 * tree.  Manages creation of the editor for the node and
	 * a <ul> for placing child elements, and expansion/collapsing
	 * of the element.
	 *
	 * This should not be instantiated directly, instead use one of:
	 *    MarkupReadOnlyContainer
	 *    MarkupTextContainer
	 *    MarkupElementContainer
	 */
	function MarkupContainer() { }

	/**
	 * Unique identifier used to set markup container node id.
	 * @type {Number}
	 */
	let markupContainerID = 0;

	MarkupContainer.prototype = {
	  /*
	   * Initialize the MarkupContainer.  Should be called while one
	   * of the other contain classes is instantiated.
	   *
	   * @param  {MarkupView} markupView
	   *         The markup view that owns this container.
	   * @param  {NodeFront} node
	   *         The node to display.
	   * @param  {String} templateID
	   *         Which template to render for this container
	   */
	  initialize: function (markupView, node, templateID) {
	    this.markup = markupView;
	    this.node = node;
	    this.undo = this.markup.undo;
	    this.win = this.markup._frame.contentWindow;
	    this.id = "treeitem-" + markupContainerID++;
	    this.htmlElt = this.win.document.documentElement;

	    // The template will fill the following properties
	    this.elt = null;
	    this.expander = null;
	    this.tagState = null;
	    this.tagLine = null;
	    this.children = null;
	    this.markup.template(templateID, this);
	    this.elt.container = this;

	    this._onMouseDown = this._onMouseDown.bind(this);
	    this._onToggle = this._onToggle.bind(this);
	    this._onMouseUp = this._onMouseUp.bind(this);
	    this._onMouseMove = this._onMouseMove.bind(this);
	    this._onKeyDown = this._onKeyDown.bind(this);

	    // Binding event listeners
	    this.elt.addEventListener("mousedown", this._onMouseDown, false);
	    this.win.addEventListener("mouseup", this._onMouseUp, true);
	    this.win.addEventListener("mousemove", this._onMouseMove, true);
	    this.elt.addEventListener("dblclick", this._onToggle, false);
	    if (this.expander) {
	      this.expander.addEventListener("click", this._onToggle, false);
	    }

	    // Marking the node as shown or hidden
	    this.updateIsDisplayed();
	  },

	  toString: function () {
	    return "[MarkupContainer for " + this.node + "]";
	  },

	  isPreviewable: function () {
	    if (this.node.tagName && !this.node.isPseudoElement) {
	      let tagName = this.node.tagName.toLowerCase();
	      let srcAttr = this.editor.getAttributeElement("src");
	      let isImage = tagName === "img" && srcAttr;
	      let isCanvas = tagName === "canvas";

	      return isImage || isCanvas;
	    }

	    return false;
	  },

	  /**
	   * Show whether the element is displayed or not
	   * If an element has the attribute `display: none` or has been hidden with
	   * the H key, it is not displayed (faded in markup view).
	   * Otherwise, it is displayed.
	   */
	  updateIsDisplayed: function () {
	    this.elt.classList.remove("not-displayed");
	    if (!this.node.isDisplayed || this.node.hidden) {
	      this.elt.classList.add("not-displayed");
	    }
	  },

	  /**
	   * True if the current node has children. The MarkupView
	   * will set this attribute for the MarkupContainer.
	   */
	  _hasChildren: false,

	  get hasChildren() {
	    return this._hasChildren;
	  },

	  set hasChildren(value) {
	    this._hasChildren = value;
	    this.updateExpander();
	  },

	  /**
	   * A list of all elements with tabindex that are not in container's children.
	   */
	  get focusableElms() {
	    return [...this.tagLine.querySelectorAll("[tabindex]")];
	  },

	  /**
	   * An indicator that the container internals are focusable.
	   */
	  get canFocus() {
	    return this._canFocus;
	  },

	  /**
	   * Toggle focusable state for container internals.
	   */
	  set canFocus(value) {
	    if (this._canFocus === value) {
	      return;
	    }

	    this._canFocus = value;

	    if (value) {
	      this.tagLine.addEventListener("keydown", this._onKeyDown, true);
	      this.focusableElms.forEach(elm => elm.setAttribute("tabindex", "0"));
	    } else {
	      this.tagLine.removeEventListener("keydown", this._onKeyDown, true);
	      // Exclude from tab order.
	      this.focusableElms.forEach(elm => elm.setAttribute("tabindex", "-1"));
	    }
	  },

	  /**
	   * If conatiner and its contents are focusable, exclude them from tab order,
	   * and, if necessary, remove focus.
	   */
	  clearFocus: function () {
	    if (!this.canFocus) {
	      return;
	    }

	    this.canFocus = false;
	    let doc = this.markup.doc;

	    if (!doc.activeElement || doc.activeElement === doc.body) {
	      return;
	    }

	    let parent = doc.activeElement;

	    while (parent && parent !== this.elt) {
	      parent = parent.parentNode;
	    }

	    if (parent) {
	      doc.activeElement.blur();
	    }
	  },

	  /**
	   * True if the current node can be expanded.
	   */
	  get canExpand() {
	    return this._hasChildren && !this.node.inlineTextChild;
	  },

	  /**
	   * True if this is the root <html> element and can't be collapsed.
	   */
	  get mustExpand() {
	    return this.node._parent === this.markup.walker.rootNode;
	  },

	  /**
	   * True if current node can be expanded and collapsed.
	   */
	  get showExpander() {
	    return this.canExpand && !this.mustExpand;
	  },

	  updateExpander: function () {
	    if (!this.expander) {
	      return;
	    }

	    if (this.showExpander) {
	      this.expander.style.visibility = "visible";
	      // Update accessibility expanded state.
	      this.tagLine.setAttribute("aria-expanded", this.expanded);
	    } else {
	      this.expander.style.visibility = "hidden";
	      // No need for accessible expanded state indicator when expander is not
	      // shown.
	      this.tagLine.removeAttribute("aria-expanded");
	    }
	  },

	  /**
	   * If current node has no children, ignore them. Otherwise, consider them a
	   * group from the accessibility point of view.
	   */
	  setChildrenRole: function () {
	    this.children.setAttribute("role",
	      this.hasChildren ? "group" : "presentation");
	  },

	  /**
	   * Set an appropriate DOM tree depth level for a node and its subtree.
	   */
	  updateLevel: function () {
	    // ARIA level should already be set when container template is rendered.
	    let currentLevel = this.tagLine.getAttribute("aria-level");
	    let newLevel = this.level;
	    if (currentLevel === newLevel) {
	      // If level did not change, ignore this node and its subtree.
	      return;
	    }

	    this.tagLine.setAttribute("aria-level", newLevel);
	    let childContainers = this.getChildContainers();
	    if (childContainers) {
	      childContainers.forEach(container => container.updateLevel());
	    }
	  },

	  /**
	   * If the node has children, return the list of containers for all these
	   * children.
	   */
	  getChildContainers: function () {
	    if (!this.hasChildren) {
	      return null;
	    }

	    return [...this.children.children].map(node => node.container);
	  },

	  /**
	   * True if the node has been visually expanded in the tree.
	   */
	  get expanded() {
	    return !this.elt.classList.contains("collapsed");
	  },

	  setExpanded: function (value) {
	    if (!this.expander) {
	      return;
	    }

	    if (!this.canExpand) {
	      value = false;
	    }
	    if (this.mustExpand) {
	      value = true;
	    }

	    if (value && this.elt.classList.contains("collapsed")) {
	      // Expanding a node means cloning its "inline" closing tag into a new
	      // tag-line that the user can interact with and showing the children.
	      let closingTag = this.elt.querySelector(".close");
	      if (closingTag) {
	        if (!this.closeTagLine) {
	          let line = this.markup.doc.createElement("div");
	          line.classList.add("tag-line");
	          // Closing tag is not important for accessibility.
	          line.setAttribute("role", "presentation");

	          let tagState = this.markup.doc.createElement("div");
	          tagState.classList.add("tag-state");
	          line.appendChild(tagState);

	          line.appendChild(closingTag.cloneNode(true));

	          flashElementOff(line);
	          this.closeTagLine = line;
	        }
	        this.elt.appendChild(this.closeTagLine);
	      }

	      this.elt.classList.remove("collapsed");
	      this.expander.setAttribute("open", "");
	      this.hovered = false;
	      this.markup.emit("expanded");
	    } else if (!value) {
	      if (this.closeTagLine) {
	        this.elt.removeChild(this.closeTagLine);
	        this.closeTagLine = undefined;
	      }
	      this.elt.classList.add("collapsed");
	      this.expander.removeAttribute("open");
	      this.markup.emit("collapsed");
	    }
	    if (this.showExpander) {
	      this.tagLine.setAttribute("aria-expanded", this.expanded);
	    }
	  },

	  parentContainer: function () {
	    return this.elt.parentNode ? this.elt.parentNode.container : null;
	  },

	  /**
	   * Determine tree depth level of a given node. This is used to specify ARIA
	   * level for node tree items and to give them better semantic context.
	   */
	  get level() {
	    let level = 1;
	    let parent = this.node.parentNode();
	    while (parent && parent !== this.markup.walker.rootNode) {
	      level++;
	      parent = parent.parentNode();
	    }
	    return level;
	  },

	  _isDragging: false,
	  _dragStartY: 0,

	  set isDragging(isDragging) {
	    let rootElt = this.markup.getContainer(this.markup._rootNode).elt;
	    this._isDragging = isDragging;
	    this.markup.isDragging = isDragging;
	    this.tagLine.setAttribute("aria-grabbed", isDragging);

	    if (isDragging) {
	      this.htmlElt.classList.add("dragging");
	      this.elt.classList.add("dragging");
	      this.markup.doc.body.classList.add("dragging");
	      rootElt.setAttribute("aria-dropeffect", "move");
	    } else {
	      this.htmlElt.classList.remove("dragging");
	      this.elt.classList.remove("dragging");
	      this.markup.doc.body.classList.remove("dragging");
	      rootElt.setAttribute("aria-dropeffect", "none");
	    }
	  },

	  get isDragging() {
	    return this._isDragging;
	  },

	  /**
	   * Check if element is draggable.
	   */
	  isDraggable: function () {
	    let tagName = this.node.tagName && this.node.tagName.toLowerCase();

	    return !this.node.isPseudoElement &&
	           !this.node.isAnonymous &&
	           !this.node.isDocumentElement &&
	           tagName !== "body" &&
	           tagName !== "head" &&
	           this.win.getSelection().isCollapsed &&
	           this.node.parentNode().tagName !== null;
	  },

	  /**
	   * Move keyboard focus to a next/previous focusable element inside container
	   * that is not part of its children (only if current focus is on first or last
	   * element).
	   *
	   * @param  {DOMNode} current  currently focused element
	   * @param  {Boolean} back     direction
	   * @return {DOMNode}          newly focused element if any
	   */
	  _wrapMoveFocus: function (current, back) {
	    let elms = this.focusableElms;
	    let next;
	    if (back) {
	      if (elms.indexOf(current) === 0) {
	        next = elms[elms.length - 1];
	        next.focus();
	      }
	    } else if (elms.indexOf(current) === elms.length - 1) {
	      next = elms[0];
	      next.focus();
	    }
	    return next;
	  },

	  _onKeyDown: function (event) {
	    let {target, keyCode, shiftKey} = event;
	    let isInput = this.markup._isInputOrTextarea(target);

	    // Ignore all keystrokes that originated in editors except for when 'Tab' is
	    // pressed.
	    if (isInput && keyCode !== KeyCodes.DOM_VK_TAB) {
	      return;
	    }

	    switch (keyCode) {
	      case KeyCodes.DOM_VK_TAB:
	        // Only handle 'Tab' if tabbable element is on the edge (first or last).
	        if (isInput) {
	          // Corresponding tabbable element is editor's next sibling.
	          let next = this._wrapMoveFocus(target.nextSibling, shiftKey);
	          if (next) {
	            event.preventDefault();
	            // Keep the editing state if possible.
	            if (next._editable) {
	              let e = this.markup.doc.createEvent("Event");
	              e.initEvent(next._trigger, true, true);
	              next.dispatchEvent(e);
	            }
	          }
	        } else {
	          let next = this._wrapMoveFocus(target, shiftKey);
	          if (next) {
	            event.preventDefault();
	          }
	        }
	        break;
	      case KeyCodes.DOM_VK_ESCAPE:
	        this.clearFocus();
	        this.markup.getContainer(this.markup._rootNode).elt.focus();
	        if (this.isDragging) {
	          // Escape when dragging is handled by markup view itself.
	          return;
	        }
	        event.preventDefault();
	        break;
	      default:
	        return;
	    }
	    event.stopPropagation();
	  },

	  _onMouseDown: function (event) {
	    let {target, button, metaKey, ctrlKey} = event;
	    let isLeftClick = button === 0;
	    let isMiddleClick = button === 1;
	    let isMetaClick = isLeftClick && (metaKey || ctrlKey);

	    // The "show more nodes" button already has its onclick, so early return.
	    if (target.nodeName === "button") {
	      return;
	    }

	    // target is the MarkupContainer itself.
	    this.hovered = false;
	    this.markup.navigate(this);
	    // Make container tabbable descendants tabbable and focus in.
	    this.canFocus = true;
	    this.focus();
	    event.stopPropagation();

	    // Preventing the default behavior will avoid the body to gain focus on
	    // mouseup (through bubbling) when clicking on a non focusable node in the
	    // line. So, if the click happened outside of a focusable element, do
	    // prevent the default behavior, so that the tagname or textcontent gains
	    // focus.
	    if (!target.closest(".editor [tabindex]")) {
	      event.preventDefault();
	    }

	    // Follow attribute links if middle or meta click.
	    if (isMiddleClick || isMetaClick) {
	      let link = target.dataset.link;
	      let type = target.dataset.type;
	      // Make container tabbable descendants not tabbable (by default).
	      this.canFocus = false;
	      this.markup._inspector.followAttributeLink(type, link);
	      return;
	    }

	    // Start node drag & drop (if the mouse moved, see _onMouseMove).
	    if (isLeftClick && this.isDraggable()) {
	      this._isPreDragging = true;
	      this._dragStartY = event.pageY;
	    }
	  },

	  /**
	   * On mouse up, stop dragging.
	   */
	  _onMouseUp: Task.async(function* () {
	    this._isPreDragging = false;

	    if (this.isDragging) {
	      this.cancelDragging();

	      let dropTargetNodes = this.markup.dropTargetNodes;

	      if (!dropTargetNodes) {
	        return;
	      }

	      yield this.markup.walker.insertBefore(this.node, dropTargetNodes.parent,
	                                            dropTargetNodes.nextSibling);
	      this.markup.emit("drop-completed");
	    }
	  }),

	  /**
	   * On mouse move, move the dragged element and indicate the drop target.
	   */
	  _onMouseMove: function (event) {
	    // If this is the first move after mousedown, only start dragging after the
	    // mouse has travelled a few pixels and then indicate the start position.
	    let initialDiff = Math.abs(event.pageY - this._dragStartY);
	    if (this._isPreDragging && initialDiff >= DRAG_DROP_MIN_INITIAL_DISTANCE) {
	      this._isPreDragging = false;
	      this.isDragging = true;

	      // If this is the last child, use the closing <div.tag-line> of parent as
	      // indicator.
	      let position = this.elt.nextElementSibling ||
	                     this.markup.getContainer(this.node.parentNode())
	                                .closeTagLine;
	      this.markup.indicateDragTarget(position);
	    }

	    if (this.isDragging) {
	      let x = 0;
	      let y = event.pageY - this.win.scrollY;

	      // Ensure we keep the dragged element within the markup view.
	      if (y < 0) {
	        y = 0;
	      } else if (y >= this.markup.doc.body.offsetHeight - this.win.scrollY) {
	        y = this.markup.doc.body.offsetHeight - this.win.scrollY - 1;
	      }

	      let diff = y - this._dragStartY + this.win.scrollY;
	      this.elt.style.top = diff + "px";

	      let el = this.markup.doc.elementFromPoint(x, y);
	      this.markup.indicateDropTarget(el);
	    }
	  },

	  cancelDragging: function () {
	    if (!this.isDragging) {
	      return;
	    }

	    this._isPreDragging = false;
	    this.isDragging = false;
	    this.elt.style.removeProperty("top");
	  },

	  /**
	   * Temporarily flash the container to attract attention.
	   * Used for markup mutations.
	   */
	  flashMutation: function () {
	    if (!this.selected) {
	      flashElementOn(this.tagState, this.editor.elt);
	      if (this._flashMutationTimer) {
	        clearTimeout(this._flashMutationTimer);
	        this._flashMutationTimer = null;
	      }
	      this._flashMutationTimer = setTimeout(() => {
	        flashElementOff(this.tagState, this.editor.elt);
	      }, this.markup.CONTAINER_FLASHING_DURATION);
	    }
	  },

	  _hovered: false,

	  /**
	   * Highlight the currently hovered tag + its closing tag if necessary
	   * (that is if the tag is expanded)
	   */
	  set hovered(value) {
	    this.tagState.classList.remove("flash-out");
	    this._hovered = value;
	    if (value) {
	      if (!this.selected) {
	        this.tagState.classList.add("theme-bg-darker");
	      }
	      if (this.closeTagLine) {
	        this.closeTagLine.querySelector(".tag-state").classList.add(
	          "theme-bg-darker");
	      }
	    } else {
	      this.tagState.classList.remove("theme-bg-darker");
	      if (this.closeTagLine) {
	        this.closeTagLine.querySelector(".tag-state").classList.remove(
	          "theme-bg-darker");
	      }
	    }
	  },

	  /**
	   * True if the container is visible in the markup tree.
	   */
	  get visible() {
	    return this.elt.getBoundingClientRect().height > 0;
	  },

	  /**
	   * True if the container is currently selected.
	   */
	  _selected: false,

	  get selected() {
	    return this._selected;
	  },

	  set selected(value) {
	    this.tagState.classList.remove("flash-out");
	    this._selected = value;
	    this.editor.selected = value;
	    // Markup tree item should have accessible selected state.
	    this.tagLine.setAttribute("aria-selected", value);
	    if (this._selected) {
	      this.markup.getContainer(this.markup._rootNode).elt.setAttribute(
	        "aria-activedescendant", this.id);
	      this.tagLine.setAttribute("selected", "");
	      this.tagState.classList.add("theme-selected");
	    } else {
	      this.tagLine.removeAttribute("selected");
	      this.tagState.classList.remove("theme-selected");
	    }
	  },

	  /**
	   * Update the container's editor to the current state of the
	   * viewed node.
	   */
	  update: function () {
	    if (this.node.pseudoClassLocks.length) {
	      this.elt.classList.add("pseudoclass-locked");
	    } else {
	      this.elt.classList.remove("pseudoclass-locked");
	    }

	    if (this.editor.update) {
	      this.editor.update();
	    }
	  },

	  /**
	   * Try to put keyboard focus on the current editor.
	   */
	  focus: function () {
	    // Elements with tabindex of -1 are not focusable.
	    let focusable = this.editor.elt.querySelector("[tabindex='0']");
	    if (focusable) {
	      focusable.focus();
	    }
	  },

	  _onToggle: function (event) {
	    this.markup.navigate(this);
	    if (this.hasChildren) {
	      this.markup.setNodeExpanded(this.node, !this.expanded, event.altKey);
	    }
	    event.stopPropagation();
	  },

	  /**
	   * Get rid of event listeners and references, when the container is no longer
	   * needed
	   */
	  destroy: function () {
	    // Remove event listeners
	    this.elt.removeEventListener("mousedown", this._onMouseDown, false);
	    this.elt.removeEventListener("dblclick", this._onToggle, false);
	    this.tagLine.removeEventListener("keydown", this._onKeyDown, true);
	    if (this.win) {
	      this.win.removeEventListener("mouseup", this._onMouseUp, true);
	      this.win.removeEventListener("mousemove", this._onMouseMove, true);
	    }

	    this.win = null;
	    this.htmlElt = null;

	    if (this.expander) {
	      this.expander.removeEventListener("click", this._onToggle, false);
	    }

	    // Recursively destroy children containers
	    let firstChild = this.children.firstChild;
	    while (firstChild) {
	      // Not all children of a container are containers themselves
	      // ("show more nodes" button is one example)
	      if (firstChild.container) {
	        firstChild.container.destroy();
	      }
	      this.children.removeChild(firstChild);
	      firstChild = this.children.firstChild;
	    }

	    this.editor.destroy();
	  }
	};

	/**
	 * An implementation of MarkupContainer for Pseudo Elements,
	 * Doctype nodes, or any other type generic node that doesn't
	 * fit for other editors.
	 * Does not allow any editing, just viewing / selecting.
	 *
	 * @param  {MarkupView} markupView
	 *         The markup view that owns this container.
	 * @param  {NodeFront} node
	 *         The node to display.
	 */
	function MarkupReadOnlyContainer(markupView, node) {
	  MarkupContainer.prototype.initialize.call(this, markupView, node,
	    "readonlycontainer");

	  this.editor = new GenericEditor(this, node);
	  this.tagLine.appendChild(this.editor.elt);
	}

	MarkupReadOnlyContainer.prototype =
	  Heritage.extend(MarkupContainer.prototype, {});

	/**
	 * An implementation of MarkupContainer for text node and comment nodes.
	 * Allows basic text editing in a textarea.
	 *
	 * @param  {MarkupView} markupView
	 *         The markup view that owns this container.
	 * @param  {NodeFront} node
	 *         The node to display.
	 * @param  {Inspector} inspector
	 *         The inspector tool container the markup-view
	 */
	function MarkupTextContainer(markupView, node) {
	  MarkupContainer.prototype.initialize.call(this, markupView, node,
	    "textcontainer");

	  if (node.nodeType == nodeConstants.TEXT_NODE) {
	    this.editor = new TextEditor(this, node, "text");
	  } else if (node.nodeType == nodeConstants.COMMENT_NODE) {
	    this.editor = new TextEditor(this, node, "comment");
	  } else {
	    throw new Error("Invalid node for MarkupTextContainer");
	  }

	  this.tagLine.appendChild(this.editor.elt);
	}

	MarkupTextContainer.prototype = Heritage.extend(MarkupContainer.prototype, {});

	/**
	 * An implementation of MarkupContainer for Elements that can contain
	 * child nodes.
	 * Allows editing of tag name, attributes, expanding / collapsing.
	 *
	 * @param  {MarkupView} markupView
	 *         The markup view that owns this container.
	 * @param  {NodeFront} node
	 *         The node to display.
	 */
	function MarkupElementContainer(markupView, node) {
	  MarkupContainer.prototype.initialize.call(this, markupView, node,
	    "elementcontainer");

	  if (node.nodeType === nodeConstants.ELEMENT_NODE) {
	    this.editor = new ElementEditor(this, node);
	  } else {
	    throw new Error("Invalid node for MarkupElementContainer");
	  }

	  this.tagLine.appendChild(this.editor.elt);
	}

	MarkupElementContainer.prototype = Heritage.extend(MarkupContainer.prototype, {
	  _buildEventTooltipContent: Task.async(function* (target, tooltip) {
	    if (target.hasAttribute("data-event")) {
	      yield tooltip.hide();

	      let listenerInfo = yield this.node.getEventListenerInfo();

	      let toolbox = this.markup._inspector.toolbox;
	      setEventTooltip(tooltip, listenerInfo, toolbox);
	      // Disable the image preview tooltip while we display the event details
	      this.markup._disableImagePreviewTooltip();
	      tooltip.once("hidden", () => {
	        // Enable the image preview tooltip after closing the event details
	        this.markup._enableImagePreviewTooltip();
	      });
	      tooltip.show(target);
	    }
	  }),

	  /**
	   * Generates the an image preview for this Element. The element must be an
	   * image or canvas (@see isPreviewable).
	   *
	   * @return {Promise} that is resolved with an object of form
	   *         { data, size: { naturalWidth, naturalHeight, resizeRatio } } where
	   *         - data is the data-uri for the image preview.
	   *         - size contains information about the original image size and if
	   *         the preview has been resized.
	   *
	   * If this element is not previewable or the preview cannot be generated for
	   * some reason, the Promise is rejected.
	   */
	  _getPreview: function () {
	    if (!this.isPreviewable()) {
	      return promise.reject("_getPreview called on a non-previewable element.");
	    }

	    if (this.tooltipDataPromise) {
	      // A preview request is already pending. Re-use that request.
	      return this.tooltipDataPromise;
	    }

	    // Fetch the preview from the server.
	    this.tooltipDataPromise = Task.spawn(function* () {
	      let maxDim = Services.prefs.getIntPref(PREVIEW_MAX_DIM_PREF);
	      let preview = yield this.node.getImageData(maxDim);
	      let data = yield preview.data.string();

	      // Clear the pending preview request. We can't reuse the results later as
	      // the preview contents might have changed.
	      this.tooltipDataPromise = null;
	      return { data, size: preview.size };
	    }.bind(this));

	    return this.tooltipDataPromise;
	  },

	  /**
	   * Executed by MarkupView._isImagePreviewTarget which is itself called when
	   * the mouse hovers over a target in the markup-view.
	   * Checks if the target is indeed something we want to have an image tooltip
	   * preview over and, if so, inserts content into the tooltip.
	   *
	   * @return {Promise} that resolves when the tooltip content is ready. Resolves
	   * true if the tooltip should be displayed, false otherwise.
	   */
	  isImagePreviewTarget: Task.async(function* (target, tooltip) {
	    // Is this Element previewable.
	    if (!this.isPreviewable()) {
	      return false;
	    }

	    // If the Element has an src attribute, the tooltip is shown when hovering
	    // over the src url. If not, the tooltip is shown when hovering over the tag
	    // name.
	    let src = this.editor.getAttributeElement("src");
	    let expectedTarget = src ? src.querySelector(".link") : this.editor.tag;
	    if (target !== expectedTarget) {
	      return false;
	    }

	    try {
	      let { data, size } = yield this._getPreview();
	      // The preview is ready.
	      let options = {
	        naturalWidth: size.naturalWidth,
	        naturalHeight: size.naturalHeight,
	        maxDim: Services.prefs.getIntPref(PREVIEW_MAX_DIM_PREF)
	      };

	      setImageTooltip(tooltip, this.markup.doc, data, options);
	    } catch (e) {
	      // Indicate the failure but show the tooltip anyway.
	      setBrokenImageTooltip(tooltip, this.markup.doc);
	    }
	    return true;
	  }),

	  copyImageDataUri: function () {
	    // We need to send again a request to gettooltipData even if one was sent
	    // for the tooltip, because we want the full-size image
	    this.node.getImageData().then(data => {
	      data.data.string().then(str => {
	        clipboardHelper.copyString(str);
	      });
	    });
	  },

	  setInlineTextChild: function (inlineTextChild) {
	    this.inlineTextChild = inlineTextChild;
	    this.editor.updateTextEditor();
	  },

	  clearInlineTextChild: function () {
	    this.inlineTextChild = undefined;
	    this.editor.updateTextEditor();
	  },

	  /**
	   * Trigger new attribute field for input.
	   */
	  addAttribute: function () {
	    this.editor.newAttr.editMode();
	  },

	  /**
	   * Trigger attribute field for editing.
	   */
	  editAttribute: function (attrName) {
	    this.editor.attrElements.get(attrName).editMode();
	  },

	  /**
	   * Remove attribute from container.
	   * This is an undoable action.
	   */
	  removeAttribute: function (attrName) {
	    let doMods = this.editor._startModifyingAttributes();
	    let undoMods = this.editor._startModifyingAttributes();
	    this.editor._saveAttribute(attrName, undoMods);
	    doMods.removeAttribute(attrName);
	    this.undo.do(() => {
	      doMods.apply();
	    }, () => {
	      undoMods.apply();
	    });
	  }
	});

	/**
	 * Dummy container node used for the root document element.
	 */
	function RootContainer(markupView, node) {
	  this.doc = markupView.doc;
	  this.elt = this.doc.createElement("ul");
	  // Root container has tree semantics for accessibility.
	  this.elt.setAttribute("role", "tree");
	  this.elt.setAttribute("tabindex", "0");
	  this.elt.setAttribute("aria-dropeffect", "none");
	  this.elt.container = this;
	  this.children = this.elt;
	  this.node = node;
	  this.toString = () => "[root container]";
	}

	RootContainer.prototype = {
	  hasChildren: true,
	  expanded: true,
	  update: function () {},
	  destroy: function () {},

	  /**
	   * If the node has children, return the list of containers for all these
	   * children.
	   */
	  getChildContainers: function () {
	    return [...this.children.children].map(node => node.container);
	  },

	  /**
	   * Set the expanded state of the container node.
	   * @param  {Boolean} value
	   */
	  setExpanded: function () {},

	  /**
	   * Set an appropriate role of the container's children node.
	   */
	  setChildrenRole: function () {},

	  /**
	   * Set an appropriate DOM tree depth level for a node and its subtree.
	   */
	  updateLevel: function () {}
	};

	/**
	 * Creates an editor for non-editable nodes.
	 */
	function GenericEditor(container, node) {
	  this.container = container;
	  this.markup = this.container.markup;
	  this.template = this.markup.template.bind(this.markup);
	  this.elt = null;
	  this.template("generic", this);

	  if (node.isPseudoElement) {
	    this.tag.classList.add("theme-fg-color5");
	    this.tag.textContent = node.isBeforePseudoElement ? "::before" : "::after";
	  } else if (node.nodeType == nodeConstants.DOCUMENT_TYPE_NODE) {
	    this.elt.classList.add("comment");
	    this.tag.textContent = node.doctypeString;
	  } else {
	    this.tag.textContent = node.nodeName;
	  }
	}

	GenericEditor.prototype = {
	  destroy: function () {
	    this.elt.remove();
	  },

	  /**
	   * Stub method for consistency with ElementEditor.
	   */
	  getInfoAtNode: function () {
	    return null;
	  }
	};

	/**
	 * Creates a simple text editor node, used for TEXT and COMMENT
	 * nodes.
	 *
	 * @param  {MarkupContainer} container
	 *         The container owning this editor.
	 * @param  {DOMNode} node
	 *         The node being edited.
	 * @param  {String} templateId
	 *         The template id to use to build the editor.
	 */
	function TextEditor(container, node, templateId) {
	  this.container = container;
	  this.markup = this.container.markup;
	  this.node = node;
	  this.template = this.markup.template.bind(templateId);
	  this._selected = false;

	  this.markup.template(templateId, this);

	  editableField({
	    element: this.value,
	    stopOnReturn: true,
	    trigger: "dblclick",
	    multiline: true,
	    maxWidth: () => getAutocompleteMaxWidth(this.value, this.container.elt),
	    trimOutput: false,
	    done: (val, commit) => {
	      if (!commit) {
	        return;
	      }
	      this.node.getNodeValue().then(longstr => {
	        longstr.string().then(oldValue => {
	          longstr.release().then(null, console.error);

	          this.container.undo.do(() => {
	            this.node.setNodeValue(val);
	          }, () => {
	            this.node.setNodeValue(oldValue);
	          });
	        });
	      });
	    },
	    cssProperties: getCssProperties(this.markup._inspector.toolbox)
	  });

	  this.update();
	}

	TextEditor.prototype = {
	  get selected() {
	    return this._selected;
	  },

	  set selected(value) {
	    if (value === this._selected) {
	      return;
	    }
	    this._selected = value;
	    this.update();
	  },

	  update: function () {
	    let longstr = null;
	    this.node.getNodeValue().then(ret => {
	      longstr = ret;
	      return longstr.string();
	    }).then(str => {
	      longstr.release().then(null, console.error);
	      this.value.textContent = str;
	    }).then(null, console.error);
	  },

	  destroy: function () {},

	  /**
	   * Stub method for consistency with ElementEditor.
	   */
	  getInfoAtNode: function () {
	    return null;
	  }
	};

	/**
	 * Creates an editor for an Element node.
	 *
	 * @param  {MarkupContainer} container
	 *         The container owning this editor.
	 * @param  {Element} node
	 *         The node being edited.
	 */
	function ElementEditor(container, node) {
	  this.container = container;
	  this.node = node;
	  this.markup = this.container.markup;
	  this.template = this.markup.template.bind(this.markup);
	  this.doc = this.markup.doc;
	  this._cssProperties = getCssProperties(this.markup._inspector.toolbox);

	  this.attrElements = new Map();
	  this.animationTimers = {};

	  // The templates will fill the following properties
	  this.elt = null;
	  this.tag = null;
	  this.closeTag = null;
	  this.attrList = null;
	  this.newAttr = null;
	  this.closeElt = null;

	  // Create the main editor
	  this.template("element", this);

	  // Make the tag name editable (unless this is a remote node or
	  // a document element)
	  if (!node.isDocumentElement) {
	    // Make the tag optionally tabbable but not by default.
	    this.tag.setAttribute("tabindex", "-1");
	    editableField({
	      element: this.tag,
	      multiline: true,
	      maxWidth: () => getAutocompleteMaxWidth(this.tag, this.container.elt),
	      trigger: "dblclick",
	      stopOnReturn: true,
	      done: this.onTagEdit.bind(this),
	      cssProperties: this._cssProperties
	    });
	  }

	  // Make the new attribute space editable.
	  this.newAttr.editMode = editableField({
	    element: this.newAttr,
	    multiline: true,
	    maxWidth: () => getAutocompleteMaxWidth(this.newAttr, this.container.elt),
	    trigger: "dblclick",
	    stopOnReturn: true,
	    contentType: InplaceEditor.CONTENT_TYPES.CSS_MIXED,
	    popup: this.markup.popup,
	    done: (val, commit) => {
	      if (!commit) {
	        return;
	      }

	      let doMods = this._startModifyingAttributes();
	      let undoMods = this._startModifyingAttributes();
	      this._applyAttributes(val, null, doMods, undoMods);
	      this.container.undo.do(() => {
	        doMods.apply();
	      }, function () {
	        undoMods.apply();
	      });
	    },
	    cssProperties: this._cssProperties
	  });

	  let displayName = this.node.displayName;
	  this.tag.textContent = displayName;
	  this.closeTag.textContent = displayName;

	  let isVoidElement = HTML_VOID_ELEMENTS.includes(displayName);
	  if (node.isInHTMLDocument && isVoidElement) {
	    this.elt.classList.add("void-element");
	  }

	  this.update();
	  this.initialized = true;
	}

	ElementEditor.prototype = {
	  set selected(value) {
	    if (this.textEditor) {
	      this.textEditor.selected = value;
	    }
	  },

	  flashAttribute: function (attrName) {
	    if (this.animationTimers[attrName]) {
	      clearTimeout(this.animationTimers[attrName]);
	    }

	    flashElementOn(this.getAttributeElement(attrName));

	    this.animationTimers[attrName] = setTimeout(() => {
	      flashElementOff(this.getAttributeElement(attrName));
	    }, this.markup.CONTAINER_FLASHING_DURATION);
	  },

	  /**
	   * Returns information about node in the editor.
	   *
	   * @param  {DOMNode} node
	   *         The node to get information from.
	   * @return {Object} An object literal with the following information:
	   *         {type: "attribute", name: "rel", value: "index", el: node}
	   */
	  getInfoAtNode: function (node) {
	    if (!node) {
	      return null;
	    }

	    let type = null;
	    let name = null;
	    let value = null;

	    // Attribute
	    let attribute = node.closest(".attreditor");
	    if (attribute) {
	      type = "attribute";
	      name = attribute.querySelector(".attr-name").textContent;
	      value = attribute.querySelector(".attr-value").textContent;
	    }

	    return {type, name, value, el: node};
	  },

	  /**
	   * Update the state of the editor from the node.
	   */
	  update: function () {
	    let nodeAttributes = this.node.attributes || [];

	    // Keep the data model in sync with attributes on the node.
	    let currentAttributes = new Set(nodeAttributes.map(a => a.name));
	    for (let name of this.attrElements.keys()) {
	      if (!currentAttributes.has(name)) {
	        this.removeAttribute(name);
	      }
	    }

	    // Only loop through the current attributes on the node.  Missing
	    // attributes have already been removed at this point.
	    for (let attr of nodeAttributes) {
	      let el = this.attrElements.get(attr.name);
	      let valueChanged = el &&
	        el.dataset.value !== attr.value;
	      let isEditing = el && el.querySelector(".editable").inplaceEditor;
	      let canSimplyShowEditor = el && (!valueChanged || isEditing);

	      if (canSimplyShowEditor) {
	        // Element already exists and doesn't need to be recreated.
	        // Just show it (it's hidden by default due to the template).
	        el.style.removeProperty("display");
	      } else {
	        // Create a new editor, because the value of an existing attribute
	        // has changed.
	        let attribute = this._createAttribute(attr, el);
	        attribute.style.removeProperty("display");

	        // Temporarily flash the attribute to highlight the change.
	        // But not if this is the first time the editor instance has
	        // been created.
	        if (this.initialized) {
	          this.flashAttribute(attr.name);
	        }
	      }
	    }

	    // Update the event bubble display
	    this.eventNode.style.display = this.node.hasEventListeners ?
	      "inline-block" : "none";

	    this.updateTextEditor();
	  },

	  /**
	   * Update the inline text editor in case of a single text child node.
	   */
	  updateTextEditor: function () {
	    let node = this.node.inlineTextChild;

	    if (this.textEditor && this.textEditor.node != node) {
	      this.elt.removeChild(this.textEditor.elt);
	      this.textEditor = null;
	    }

	    if (node && !this.textEditor) {
	      // Create a text editor added to this editor.
	      // This editor won't receive an update automatically, so we rely on
	      // child text editors to let us know that we need updating.
	      this.textEditor = new TextEditor(this.container, node, "text");
	      this.elt.insertBefore(this.textEditor.elt,
	                            this.elt.firstChild.nextSibling.nextSibling);
	    }

	    if (this.textEditor) {
	      this.textEditor.update();
	    }
	  },

	  _startModifyingAttributes: function () {
	    return this.node.startModifyingAttributes();
	  },

	  /**
	   * Get the element used for one of the attributes of this element.
	   *
	   * @param  {String} attrName
	   *         The name of the attribute to get the element for
	   * @return {DOMNode}
	   */
	  getAttributeElement: function (attrName) {
	    return this.attrList.querySelector(
	      ".attreditor[data-attr=" + CSS.escape(attrName) + "] .attr-value");
	  },

	  /**
	   * Remove an attribute from the attrElements object and the DOM.
	   *
	   * @param  {String} attrName
	   *         The name of the attribute to remove
	   */
	  removeAttribute: function (attrName) {
	    let attr = this.attrElements.get(attrName);
	    if (attr) {
	      this.attrElements.delete(attrName);
	      attr.remove();
	    }
	  },

	  _createAttribute: function (attribute, before = null) {
	    // Create the template editor, which will save some variables here.
	    let data = {
	      attrName: attribute.name,
	      tabindex: this.container.canFocus ? "0" : "-1",
	    };
	    this.template("attribute", data);
	    let {attr, inner, name, val} = data;

	    // Double quotes need to be handled specially to prevent DOMParser failing.
	    // name="v"a"l"u"e" when editing -> name='v"a"l"u"e"'
	    // name="v'a"l'u"e" when editing -> name="v'a&quot;l'u&quot;e"
	    let editValueDisplayed = attribute.value || "";
	    let hasDoubleQuote = editValueDisplayed.includes('"');
	    let hasSingleQuote = editValueDisplayed.includes("'");
	    let initial = attribute.name + '="' + editValueDisplayed + '"';

	    // Can't just wrap value with ' since the value contains both " and '.
	    if (hasDoubleQuote && hasSingleQuote) {
	      editValueDisplayed = editValueDisplayed.replace(/\"/g, "&quot;");
	      initial = attribute.name + '="' + editValueDisplayed + '"';
	    }

	    // Wrap with ' since there are no single quotes in the attribute value.
	    if (hasDoubleQuote && !hasSingleQuote) {
	      initial = attribute.name + "='" + editValueDisplayed + "'";
	    }

	    // Make the attribute editable.
	    attr.editMode = editableField({
	      element: inner,
	      trigger: "dblclick",
	      stopOnReturn: true,
	      selectAll: false,
	      initial: initial,
	      multiline: true,
	      maxWidth: () => getAutocompleteMaxWidth(inner, this.container.elt),
	      contentType: InplaceEditor.CONTENT_TYPES.CSS_MIXED,
	      popup: this.markup.popup,
	      start: (editor, event) => {
	        // If the editing was started inside the name or value areas,
	        // select accordingly.
	        if (event && event.target === name) {
	          editor.input.setSelectionRange(0, name.textContent.length);
	        } else if (event && event.target.closest(".attr-value") === val) {
	          let length = editValueDisplayed.length;
	          let editorLength = editor.input.value.length;
	          let start = editorLength - (length + 1);
	          editor.input.setSelectionRange(start, start + length);
	        } else {
	          editor.input.select();
	        }
	      },
	      done: (newValue, commit, direction) => {
	        if (!commit || newValue === initial) {
	          return;
	        }

	        let doMods = this._startModifyingAttributes();
	        let undoMods = this._startModifyingAttributes();

	        // Remove the attribute stored in this editor and re-add any attributes
	        // parsed out of the input element. Restore original attribute if
	        // parsing fails.
	        this.refocusOnEdit(attribute.name, attr, direction);
	        this._saveAttribute(attribute.name, undoMods);
	        doMods.removeAttribute(attribute.name);
	        this._applyAttributes(newValue, attr, doMods, undoMods);
	        this.container.undo.do(() => {
	          doMods.apply();
	        }, () => {
	          undoMods.apply();
	        });
	      },
	      cssProperties: this._cssProperties
	    });

	    // Figure out where we should place the attribute.
	    if (attribute.name == "id") {
	      before = this.attrList.firstChild;
	    } else if (attribute.name == "class") {
	      let idNode = this.attrElements.get("id");
	      before = idNode ? idNode.nextSibling : this.attrList.firstChild;
	    }
	    this.attrList.insertBefore(attr, before);

	    this.removeAttribute(attribute.name);
	    this.attrElements.set(attribute.name, attr);

	    // Parse the attribute value to detect whether there are linkable parts in
	    // it (make sure to pass a complete list of existing attributes to the
	    // parseAttribute function, by concatenating attribute, because this could
	    // be a newly added attribute not yet on this.node).
	    let attributes = this.node.attributes.filter(existingAttribute => {
	      return existingAttribute.name !== attribute.name;
	    });
	    attributes.push(attribute);
	    let parsedLinksData = parseAttribute(this.node.namespaceURI,
	      this.node.tagName, attributes, attribute.name);

	    // Create links in the attribute value, and collapse long attributes if
	    // needed.
	    let collapse = value => {
	      if (value && value.match(COLLAPSE_DATA_URL_REGEX)) {
	        return truncateString(value, COLLAPSE_DATA_URL_LENGTH);
	      }
	      return this.markup.collapseAttributes
	        ? truncateString(value, this.markup.collapseAttributeLength)
	        : value;
	    };

	    val.innerHTML = "";
	    for (let token of parsedLinksData) {
	      if (token.type === "string") {
	        val.appendChild(this.doc.createTextNode(collapse(token.value)));
	      } else {
	        let link = this.doc.createElement("span");
	        link.classList.add("link");
	        link.setAttribute("data-type", token.type);
	        link.setAttribute("data-link", token.value);
	        link.textContent = collapse(token.value);
	        val.appendChild(link);
	      }
	    }

	    name.textContent = attribute.name;

	    return attr;
	  },

	  /**
	   * Parse a user-entered attribute string and apply the resulting
	   * attributes to the node. This operation is undoable.
	   *
	   * @param  {String} value
	   *         The user-entered value.
	   * @param  {DOMNode} attrNode
	   *         The attribute editor that created this
	   *         set of attributes, used to place new attributes where the
	   *         user put them.
	   */
	  _applyAttributes: function (value, attrNode, doMods, undoMods) {
	    let attrs = parseAttributeValues(value, this.doc);
	    for (let attr of attrs) {
	      // Create an attribute editor next to the current attribute if needed.
	      this._createAttribute(attr, attrNode ? attrNode.nextSibling : null);
	      this._saveAttribute(attr.name, undoMods);
	      doMods.setAttribute(attr.name, attr.value);
	    }
	  },

	  /**
	   * Saves the current state of the given attribute into an attribute
	   * modification list.
	   */
	  _saveAttribute: function (name, undoMods) {
	    let node = this.node;
	    if (node.hasAttribute(name)) {
	      let oldValue = node.getAttribute(name);
	      undoMods.setAttribute(name, oldValue);
	    } else {
	      undoMods.removeAttribute(name);
	    }
	  },

	  /**
	   * Listen to mutations, and when the attribute list is regenerated
	   * try to focus on the attribute after the one that's being edited now.
	   * If the attribute order changes, go to the beginning of the attribute list.
	   */
	  refocusOnEdit: function (attrName, attrNode, direction) {
	    // Only allow one refocus on attribute change at a time, so when there's
	    // more than 1 request in parallel, the last one wins.
	    if (this._editedAttributeObserver) {
	      this.markup._inspector.off("markupmutation",
	        this._editedAttributeObserver);
	      this._editedAttributeObserver = null;
	    }

	    let container = this.markup.getContainer(this.node);

	    let activeAttrs = [...this.attrList.childNodes]
	      .filter(el => el.style.display != "none");
	    let attributeIndex = activeAttrs.indexOf(attrNode);

	    let onMutations = this._editedAttributeObserver = (e, mutations) => {
	      let isDeletedAttribute = false;
	      let isNewAttribute = false;

	      for (let mutation of mutations) {
	        let inContainer =
	          this.markup.getContainer(mutation.target) === container;
	        if (!inContainer) {
	          continue;
	        }

	        let isOriginalAttribute = mutation.attributeName === attrName;

	        isDeletedAttribute = isDeletedAttribute || isOriginalAttribute &&
	                             mutation.newValue === null;
	        isNewAttribute = isNewAttribute || mutation.attributeName !== attrName;
	      }

	      let isModifiedOrder = isDeletedAttribute && isNewAttribute;
	      this._editedAttributeObserver = null;

	      // "Deleted" attributes are merely hidden, so filter them out.
	      let visibleAttrs = [...this.attrList.childNodes]
	        .filter(el => el.style.display != "none");
	      let activeEditor;
	      if (visibleAttrs.length > 0) {
	        if (!direction) {
	          // No direction was given; stay on current attribute.
	          activeEditor = visibleAttrs[attributeIndex];
	        } else if (isModifiedOrder) {
	          // The attribute was renamed, reordering the existing attributes.
	          // So let's go to the beginning of the attribute list for consistency.
	          activeEditor = visibleAttrs[0];
	        } else {
	          let newAttributeIndex;
	          if (isDeletedAttribute) {
	            newAttributeIndex = attributeIndex;
	          } else if (direction == Services.focus.MOVEFOCUS_FORWARD) {
	            newAttributeIndex = attributeIndex + 1;
	          } else if (direction == Services.focus.MOVEFOCUS_BACKWARD) {
	            newAttributeIndex = attributeIndex - 1;
	          }

	          // The number of attributes changed (deleted), or we moved through
	          // the array so check we're still within bounds.
	          if (newAttributeIndex >= 0 &&
	              newAttributeIndex <= visibleAttrs.length - 1) {
	            activeEditor = visibleAttrs[newAttributeIndex];
	          }
	        }
	      }

	      // Either we have no attributes left,
	      // or we just edited the last attribute and want to move on.
	      if (!activeEditor) {
	        activeEditor = this.newAttr;
	      }

	      // Refocus was triggered by tab or shift-tab.
	      // Continue in edit mode.
	      if (direction) {
	        activeEditor.editMode();
	      } else {
	        // Refocus was triggered by enter.
	        // Exit edit mode (but restore focus).
	        let editable = activeEditor === this.newAttr ?
	          activeEditor : activeEditor.querySelector(".editable");
	        editable.focus();
	      }

	      this.markup.emit("refocusedonedit");
	    };

	    // Start listening for mutations until we find an attributes change
	    // that modifies this attribute.
	    this.markup._inspector.once("markupmutation", onMutations);
	  },

	  /**
	   * Called when the tag name editor has is done editing.
	   */
	  onTagEdit: function (newTagName, isCommit) {
	    if (!isCommit ||
	        newTagName.toLowerCase() === this.node.tagName.toLowerCase() ||
	        !("editTagName" in this.markup.walker)) {
	      return;
	    }

	    // Changing the tagName removes the node. Make sure the replacing node gets
	    // selected afterwards.
	    this.markup.reselectOnRemoved(this.node, "edittagname");
	    this.markup.walker.editTagName(this.node, newTagName).then(null, () => {
	      // Failed to edit the tag name, cancel the reselection.
	      this.markup.cancelReselectOnRemoved();
	    });
	  },

	  destroy: function () {
	    for (let key in this.animationTimers) {
	      clearTimeout(this.animationTimers[key]);
	    }
	    this.animationTimers = null;
	  }
	};

	function truncateString(str, maxLength) {
	  if (!str || str.length <= maxLength) {
	    return str;
	  }

	  return str.substring(0, Math.ceil(maxLength / 2)) +
	         "…" +
	         str.substring(str.length - Math.floor(maxLength / 2));
	}

	/**
	 * Parse attribute names and values from a string.
	 *
	 * @param  {String} attr
	 *         The input string for which names/values are to be parsed.
	 * @param  {HTMLDocument} doc
	 *         A document that can be used to test valid attributes.
	 * @return {Array}
	 *         An array of attribute names and their values.
	 */
	function parseAttributeValues(attr, doc) {
	  attr = attr.trim();

	  let parseAndGetNode = str => {
	    return new DOMParser().parseFromString(str, "text/html").body.childNodes[0];
	  };

	  // Handle bad user inputs by appending a " or ' if it fails to parse without
	  // them. Also note that a SVG tag is used to make sure the HTML parser
	  // preserves mixed-case attributes
	  let el = parseAndGetNode("<svg " + attr + "></svg>") ||
	           parseAndGetNode("<svg " + attr + "\"></svg>") ||
	           parseAndGetNode("<svg " + attr + "'></svg>");

	  let div = doc.createElement("div");
	  let attributes = [];
	  for (let {name, value} of el.attributes) {
	    // Try to set on an element in the document, throws exception on bad input.
	    // Prevents InvalidCharacterError - "String contains an invalid character".
	    try {
	      div.setAttribute(name, value);
	      attributes.push({ name, value });
	    } catch (e) {
	      // This may throw exceptions on bad input.
	      // Prevents InvalidCharacterError - "String contains an invalid
	      // character".
	    }
	  }

	  return attributes;
	}

	/**
	 * Apply a 'flashed' background and foreground color to elements. Intended
	 * to be used with flashElementOff as a way of drawing attention to an element.
	 *
	 * @param  {Node} backgroundElt
	 *         The element to set the highlighted background color on.
	 * @param  {Node} foregroundElt
	 *         The element to set the matching foreground color on.
	 *         Optional.  This will equal backgroundElt if not set.
	 */
	function flashElementOn(backgroundElt, foregroundElt = backgroundElt) {
	  if (!backgroundElt || !foregroundElt) {
	    return;
	  }

	  // Make sure the animation class is not here
	  backgroundElt.classList.remove("flash-out");

	  // Change the background
	  backgroundElt.classList.add("theme-bg-contrast");

	  foregroundElt.classList.add("theme-fg-contrast");
	  [].forEach.call(
	    foregroundElt.querySelectorAll("[class*=theme-fg-color]"),
	    span => span.classList.add("theme-fg-contrast")
	  );
	}

	/**
	 * Remove a 'flashed' background and foreground color to elements.
	 * See flashElementOn.
	 *
	 * @param  {Node} backgroundElt
	 *         The element to reomve the highlighted background color on.
	 * @param  {Node} foregroundElt
	 *         The element to remove the matching foreground color on.
	 *         Optional.  This will equal backgroundElt if not set.
	 */
	function flashElementOff(backgroundElt, foregroundElt = backgroundElt) {
	  if (!backgroundElt || !foregroundElt) {
	    return;
	  }

	  // Add the animation class to smoothly remove the background
	  backgroundElt.classList.add("flash-out");

	  // Remove the background
	  backgroundElt.classList.remove("theme-bg-contrast");

	  foregroundElt.classList.remove("theme-fg-contrast");
	  [].forEach.call(
	    foregroundElt.querySelectorAll("[class*=theme-fg-color]"),
	    span => span.classList.remove("theme-fg-contrast")
	  );
	}

	/**
	 * Map a number from one range to another.
	 */
	function map(value, oldMin, oldMax, newMin, newMax) {
	  let ratio = oldMax - oldMin;
	  if (ratio == 0) {
	    return value;
	  }
	  return newMin + (newMax - newMin) * ((value - oldMin) / ratio);
	}

	/**
	 * Retrieve the available width between a provided element left edge and a container right
	 * edge. This used can be used as a max-width for inplace-editor (autocomplete) widgets
	 * replacing Editor elements of the the markup-view;
	 */
	function getAutocompleteMaxWidth(element, container) {
	  let elementRect = element.getBoundingClientRect();
	  let containerRect = container.getBoundingClientRect();
	  return containerRect.right - elementRect.left - 2;
	}

	exports.MarkupView = MarkupView;


/***/ },
/* 217 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * A simple undo stack manager.
	 *
	 * Actions are added along with the necessary code to
	 * reverse the action.
	 *
	 * @param integer maxUndo Maximum number of undo steps.
	 *   defaults to 50.
	 */
	function UndoStack(maxUndo) {
	  this.maxUndo = maxUndo || 50;
	  this._stack = [];
	}

	exports.UndoStack = UndoStack;

	UndoStack.prototype = {
	  // Current index into the undo stack.  Is positioned after the last
	  // currently-applied change.
	  _index: 0,

	  // The current batch depth (see startBatch() for details)
	  _batchDepth: 0,

	  destroy: function () {
	    this.uninstallController();
	    delete this._stack;
	  },

	  /**
	   * Start a collection of related changes.  Changes will be batched
	   * together into one undo/redo item until endBatch() is called.
	   *
	   * Batches can be nested, in which case the outer batch will contain
	   * all items from the inner batches.  This allows larger user
	   * actions made up of a collection of smaller actions to be
	   * undone as a single action.
	   */
	  startBatch: function () {
	    if (this._batchDepth++ === 0) {
	      this._batch = [];
	    }
	  },

	  /**
	   * End a batch of related changes, performing its action and adding
	   * it to the undo stack.
	   */
	  endBatch: function () {
	    if (--this._batchDepth > 0) {
	      return;
	    }

	    // Cut off the end of the undo stack at the current index,
	    // and the beginning to prevent a stack larger than maxUndo.
	    let start = Math.max((this._index + 1) - this.maxUndo, 0);
	    this._stack = this._stack.slice(start, this._index);

	    let batch = this._batch;
	    delete this._batch;
	    let entry = {
	      do: function () {
	        for (let item of batch) {
	          item.do();
	        }
	      },
	      undo: function () {
	        for (let i = batch.length - 1; i >= 0; i--) {
	          batch[i].undo();
	        }
	      }
	    };
	    this._stack.push(entry);
	    this._index = this._stack.length;
	    entry.do();
	    this._change();
	  },

	  /**
	   * Perform an action, adding it to the undo stack.
	   *
	   * @param function toDo Called to perform the action.
	   * @param function undo Called to reverse the action.
	   */
	  do: function (toDo, undo) {
	    this.startBatch();
	    this._batch.push({ do: toDo, undo });
	    this.endBatch();
	  },

	  /*
	   * Returns true if undo() will do anything.
	   */
	  canUndo: function () {
	    return this._index > 0;
	  },

	  /**
	   * Undo the top of the undo stack.
	   *
	   * @return true if an action was undone.
	   */
	  undo: function () {
	    if (!this.canUndo()) {
	      return false;
	    }
	    this._stack[--this._index].undo();
	    this._change();
	    return true;
	  },

	  /**
	   * Returns true if redo() will do anything.
	   */
	  canRedo: function () {
	    return this._stack.length > this._index;
	  },

	  /**
	   * Redo the most recently undone action.
	   *
	   * @return true if an action was redone.
	   */
	  redo: function () {
	    if (!this.canRedo()) {
	      return false;
	    }
	    this._stack[this._index++].do();
	    this._change();
	    return true;
	  },

	  _change: function () {
	    if (this._controllerWindow) {
	      this._controllerWindow.goUpdateCommand("cmd_undo");
	      this._controllerWindow.goUpdateCommand("cmd_redo");
	    }
	  },

	  /**
	   * ViewController implementation for undo/redo.
	   */

	  /**
	   * Install this object as a command controller.
	   */
	  installController: function (controllerWindow) {
	    this._controllerWindow = controllerWindow;
	    controllerWindow.controllers.appendController(this);
	  },

	  /**
	   * Uninstall this object from the command controller.
	   */
	  uninstallController: function () {
	    if (!this._controllerWindow) {
	      return;
	    }
	    this._controllerWindow.controllers.removeController(this);
	  },

	  supportsCommand: function (command) {
	    return (command == "cmd_undo" ||
	            command == "cmd_redo");
	  },

	  isCommandEnabled: function (command) {
	    switch (command) {
	      case "cmd_undo": return this.canUndo();
	      case "cmd_redo": return this.canRedo();
	    }
	    return false;
	  },

	  doCommand: function (command) {
	    switch (command) {
	      case "cmd_undo": return this.undo();
	      case "cmd_redo": return this.redo();
	      default: return null;
	    }
	  },

	  onEvent: function (event) {},
	};


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const Editor = __webpack_require__(219);
	const Services = __webpack_require__(1);
	const EventEmitter = __webpack_require__(6);

	/**
	 * A wrapper around the Editor component, that allows editing of HTML.
	 *
	 * The main functionality this provides around the Editor is the ability
	 * to show/hide/position an editor inplace. It only appends once to the
	 * body, and uses CSS to position the editor.  The reason it is done this
	 * way is that the editor is loaded in an iframe, and calling appendChild
	 * causes it to reload.
	 *
	 * Meant to be embedded inside of an HTML page, as in markup.xhtml.
	 *
	 * @param HTMLDocument htmlDocument
	 *        The document to attach the editor to.  Will also use this
	 *        document as a basis for listening resize events.
	 */
	function HTMLEditor(htmlDocument) {
	  this.doc = htmlDocument;
	  this.container = this.doc.createElement("div");
	  this.container.className = "html-editor theme-body";
	  this.container.style.display = "none";
	  this.editorInner = this.doc.createElement("div");
	  this.editorInner.className = "html-editor-inner";
	  this.container.appendChild(this.editorInner);

	  this.doc.body.appendChild(this.container);
	  this.hide = this.hide.bind(this);
	  this.refresh = this.refresh.bind(this);

	  EventEmitter.decorate(this);

	  this.doc.defaultView.addEventListener("resize",
	    this.refresh, true);

	  let config = {
	    mode: Editor.modes.html,
	    lineWrapping: true,
	    styleActiveLine: false,
	    extraKeys: {},
	    theme: "mozilla markup-view"
	  };

	  config.extraKeys[ctrl("Enter")] = this.hide;
	  config.extraKeys.F2 = this.hide;
	  config.extraKeys.Esc = this.hide.bind(this, false);

	  this.container.addEventListener("click", this.hide, false);
	  this.editorInner.addEventListener("click", stopPropagation, false);
	  this.editor = new Editor(config);

	  let iframe = this.editorInner.ownerDocument.createElement("iframe");
	  this.editor.appendTo(this.editorInner, iframe).then(() => {
	    this.hide(false);
	  }).then(null, (err) => console.log(err.message));
	}

	HTMLEditor.prototype = {

	  /**
	   * Need to refresh position by manually setting CSS values, so this will
	   * need to be called on resizes and other sizing changes.
	   */
	  refresh: function () {
	    let element = this._attachedElement;

	    if (element) {
	      this.container.style.top = element.offsetTop + "px";
	      this.container.style.left = element.offsetLeft + "px";
	      this.container.style.width = element.offsetWidth + "px";
	      this.container.style.height = element.parentNode.offsetHeight + "px";
	      this.editor.refresh();
	    }
	  },

	  /**
	   * Anchor the editor to a particular element.
	   *
	   * @param DOMNode element
	   *        The element that the editor will be anchored to.
	   *        Should belong to the HTMLDocument passed into the constructor.
	   */
	  _attach: function (element) {
	    this._detach();
	    this._attachedElement = element;
	    element.classList.add("html-editor-container");
	    this.refresh();
	  },

	  /**
	   * Unanchor the editor from an element.
	   */
	  _detach: function () {
	    if (this._attachedElement) {
	      this._attachedElement.classList.remove("html-editor-container");
	      this._attachedElement = undefined;
	    }
	  },

	  /**
	   * Anchor the editor to a particular element, and show the editor.
	   *
	   * @param DOMNode element
	   *        The element that the editor will be anchored to.
	   *        Should belong to the HTMLDocument passed into the constructor.
	   * @param string text
	   *        Value to set the contents of the editor to
	   * @param function cb
	   *        The function to call when hiding
	   */
	  show: function (element, text) {
	    if (this._visible) {
	      return;
	    }

	    this._originalValue = text;
	    this.editor.setText(text);
	    this._attach(element);
	    this.container.style.display = "flex";
	    this._visible = true;

	    this.editor.refresh();
	    this.editor.focus();

	    this.emit("popupshown");
	  },

	  /**
	   * Hide the editor, optionally committing the changes
	   *
	   * @param bool shouldCommit
	   *             A change will be committed by default.  If this param
	   *             strictly equals false, no change will occur.
	   */
	  hide: function (shouldCommit) {
	    if (!this._visible) {
	      return;
	    }

	    this.container.style.display = "none";
	    this._detach();

	    let newValue = this.editor.getText();
	    let valueHasChanged = this._originalValue !== newValue;
	    let preventCommit = shouldCommit === false || !valueHasChanged;
	    this._originalValue = undefined;
	    this._visible = undefined;
	    this.emit("popuphidden", !preventCommit, newValue);
	  },

	  /**
	   * Destroy this object and unbind all event handlers
	   */
	  destroy: function () {
	    this.doc.defaultView.removeEventListener("resize",
	      this.refresh, true);
	    this.container.removeEventListener("click", this.hide, false);
	    this.editorInner.removeEventListener("click", stopPropagation, false);

	    this.hide(false);
	    this.container.remove();
	    this.editor.destroy();
	  }
	};

	function ctrl(k) {
	  return (Services.appinfo.OS == "Darwin" ? "Cmd-" : "Ctrl-") + k;
	}

	function stopPropagation(e) {
	  e.stopPropagation();
	}

	exports.HTMLEditor = HTMLEditor;


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2; fill-column: 80 -*- */
	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {
	  EXPAND_TAB,
	  TAB_SIZE,
	  DETECT_INDENT,
	  getIndentationFromIteration
	} = __webpack_require__(144);

	const ENABLE_CODE_FOLDING = "devtools.editor.enableCodeFolding";
	const KEYMAP = "devtools.editor.keymap";
	const AUTO_CLOSE = "devtools.editor.autoclosebrackets";
	const AUTOCOMPLETE = "devtools.editor.autocomplete";
	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	const VALID_KEYMAPS = new Set(["emacs", "vim", "sublime"]);

	// Maximum allowed margin (in number of lines) from top or bottom of the editor
	// while shifting to a line which was initially out of view.
	const MAX_VERTICAL_OFFSET = 3;

	// Match @Scratchpad/N:LINE[:COLUMN] or (LINE[:COLUMN]) anywhere at an end of
	// line in text selection.
	const RE_SCRATCHPAD_ERROR = /(?:@Scratchpad\/\d+:|\()(\d+):?(\d+)?(?:\)|\n)/;
	const RE_JUMP_TO_LINE = /^(\d+):?(\d+)?/;

	const Services = __webpack_require__(1);
	const promise = __webpack_require__(4);
	const events = __webpack_require__(6);
	const { PrefObserver } = __webpack_require__(180);
	const { getClientCssProperties } = __webpack_require__(16);

	const {LocalizationHelper} = __webpack_require__(56);
	const L10N = new LocalizationHelper("devtools/locale/sourceeditor.properties");

	const { OS } = Services.appinfo;

	// CM_STYLES, CM_SCRIPTS and CM_IFRAME represent the HTML,
	// JavaScript and CSS that is injected into an iframe in
	// order to initialize a CodeMirror instance.

	const CM_STYLES = [
	  "chrome://devtools/content/sourceeditor/codemirror/lib/codemirror.css",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/dialog/dialog.css",
	  "chrome://devtools/content/sourceeditor/codemirror/mozilla.css"
	];

	const CM_SCRIPTS = [
	  "chrome://devtools/content/shared/theme-switching.js",
	  "chrome://devtools/content/sourceeditor/codemirror/lib/codemirror.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/dialog/dialog.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/search/searchcursor.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/search/search.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/edit/matchbrackets.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/edit/closebrackets.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/comment/comment.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/javascript.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/xml.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/css.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/htmlmixed.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/clike.js",
	  "chrome://devtools/content/sourceeditor/codemirror/mode/wasm.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/selection/active-line.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/edit/trailingspace.js",
	  "chrome://devtools/content/sourceeditor/codemirror/keymap/emacs.js",
	  "chrome://devtools/content/sourceeditor/codemirror/keymap/vim.js",
	  "chrome://devtools/content/sourceeditor/codemirror/keymap/sublime.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/foldcode.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/brace-fold.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/comment-fold.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/xml-fold.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/fold/foldgutter.js"
	];

	const CM_IFRAME =
	  "data:text/html;charset=utf8,<!DOCTYPE html>" +
	  "<html dir='ltr'>" +
	  "  <head>" +
	  "    <style>" +
	  "      html, body { height: 100%; }" +
	  "      body { margin: 0; overflow: hidden; }" +
	  "      .CodeMirror { width: 100%; height: 100% !important; " +
	  "line-height: 1.25 !important;}" +
	  "    </style>" +
	  CM_STYLES.map(style => "<link rel='stylesheet' href='" + style + "'>").join("\n") +
	  "  </head>" +
	  "  <body class='theme-body devtools-monospace'></body>" +
	  "</html>";

	const CM_MAPPING = [
	  "focus",
	  "hasFocus",
	  "lineCount",
	  "somethingSelected",
	  "getCursor",
	  "setSelection",
	  "getSelection",
	  "replaceSelection",
	  "extendSelection",
	  "undo",
	  "redo",
	  "clearHistory",
	  "openDialog",
	  "refresh",
	  "getScrollInfo",
	  "getViewport"
	];

	const editors = new WeakMap();

	Editor.modes = {
	  text: { name: "text" },
	  html: { name: "htmlmixed" },
	  css: { name: "css" },
	  wasm: { name: "wasm" },
	  js: { name: "javascript" },
	  vs: { name: "x-shader/x-vertex" },
	  fs: { name: "x-shader/x-fragment" }
	};

	/**
	 * A very thin wrapper around CodeMirror. Provides a number
	 * of helper methods to make our use of CodeMirror easier and
	 * another method, appendTo, to actually create and append
	 * the CodeMirror instance.
	 *
	 * Note that Editor doesn't expose CodeMirror instance to the
	 * outside world.
	 *
	 * Constructor accepts one argument, config. It is very
	 * similar to the CodeMirror configuration object so for most
	 * properties go to CodeMirror's documentation (see below).
	 *
	 * Other than that, it accepts one additional and optional
	 * property contextMenu. This property should be an element, or
	 * an ID of an element that we can use as a context menu.
	 *
	 * This object is also an event emitter.
	 *
	 * CodeMirror docs: http://codemirror.net/doc/manual.html
	 */
	function Editor(config) {
	  const tabSize = Services.prefs.getIntPref(TAB_SIZE);
	  const useTabs = !Services.prefs.getBoolPref(EXPAND_TAB);
	  const useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);

	  this.version = null;
	  this.config = {
	    value: "",
	    mode: Editor.modes.text,
	    indentUnit: tabSize,
	    tabSize: tabSize,
	    contextMenu: null,
	    matchBrackets: true,
	    extraKeys: {},
	    indentWithTabs: useTabs,
	    inputStyle: "textarea",
	    styleActiveLine: true,
	    autoCloseBrackets: "()[]{}''\"\"``",
	    autoCloseEnabled: useAutoClose,
	    theme: "mozilla",
	    themeSwitching: true,
	    autocomplete: false,
	    autocompleteOpts: {}
	  };

	  // Additional shortcuts.
	  this.config.extraKeys[Editor.keyFor("jumpToLine")] = () => this.jumpToLine();
	  this.config.extraKeys[Editor.keyFor("moveLineUp", { noaccel: true })] =
	    () => this.moveLineUp();
	  this.config.extraKeys[Editor.keyFor("moveLineDown", { noaccel: true })] =
	    () => this.moveLineDown();
	  this.config.extraKeys[Editor.keyFor("toggleComment")] = "toggleComment";

	  // Disable ctrl-[ and ctrl-] because toolbox uses those shortcuts.
	  this.config.extraKeys[Editor.keyFor("indentLess")] = false;
	  this.config.extraKeys[Editor.keyFor("indentMore")] = false;

	  // Overwrite default config with user-provided, if needed.
	  Object.keys(config).forEach(k => {
	    if (k != "extraKeys") {
	      this.config[k] = config[k];
	      return;
	    }

	    if (!config.extraKeys) {
	      return;
	    }

	    Object.keys(config.extraKeys).forEach(key => {
	      this.config.extraKeys[key] = config.extraKeys[key];
	    });
	  });

	  if (!this.config.gutters) {
	    this.config.gutters = [];
	  }
	  if (this.config.lineNumbers
	      && this.config.gutters.indexOf("CodeMirror-linenumbers") === -1) {
	    this.config.gutters.push("CodeMirror-linenumbers");
	  }

	  // Remember the initial value of autoCloseBrackets.
	  this.config.autoCloseBracketsSaved = this.config.autoCloseBrackets;

	  // Overwrite default tab behavior. If something is selected,
	  // indent those lines. If nothing is selected and we're
	  // indenting with tabs, insert one tab. Otherwise insert N
	  // whitespaces where N == indentUnit option.
	  this.config.extraKeys.Tab = cm => {
	    if (cm.somethingSelected()) {
	      cm.indentSelection("add");
	      return;
	    }

	    if (this.config.indentWithTabs) {
	      cm.replaceSelection("\t", "end", "+input");
	      return;
	    }

	    let num = cm.getOption("indentUnit");
	    if (cm.getCursor().ch !== 0) {
	      num -= 1;
	    }
	    cm.replaceSelection(" ".repeat(num), "end", "+input");
	  };

	  // Allow add-ons to inject scripts for their editor instances
	  if (!this.config.externalScripts) {
	    this.config.externalScripts = [];
	  }

	  if (this.config.cssProperties) {
	    // Ensure that autocompletion has cssProperties if it's passed in via the options.
	    this.config.autocompleteOpts.cssProperties = this.config.cssProperties;
	  } else {
	    // Use a static client-side database of CSS values if none is provided.
	    this.config.cssProperties = getClientCssProperties();
	  }

	  events.decorate(this);
	}

	Editor.prototype = {
	  container: null,
	  version: null,
	  config: null,
	  Doc: null,

	  /**
	   * Appends the current Editor instance to the element specified by
	   * 'el'. You can also provide your won iframe to host the editor as
	   * an optional second parameter. This method actually creates and
	   * loads CodeMirror and all its dependencies.
	   *
	   * This method is asynchronous and returns a promise.
	   */
	  appendTo: function (el, env) {
	    let def = promise.defer();
	    let cm = editors.get(this);

	    if (!env) {
	      env = el.ownerDocument.createElementNS(XUL_NS, "iframe");
	    }

	    env.flex = 1;

	    if (cm) {
	      throw new Error("You can append an editor only once.");
	    }

	    let onLoad = () => {
	      // Once the iframe is loaded, we can inject CodeMirror
	      // and its dependencies into its DOM.

	      env.removeEventListener("load", onLoad, true);
	      let win = env.contentWindow.wrappedJSObject;

	      if (!this.config.themeSwitching) {
	        win.document.documentElement.setAttribute("force-theme", "light");
	      }

	      let scriptsToInject = CM_SCRIPTS.concat(this.config.externalScripts);
	      scriptsToInject.forEach(url => {
	        if (url.startsWith("chrome://")) {
	          Services.scriptloader.loadSubScript(url, win, "utf8");
	        }
	      });
	      // Replace the propertyKeywords, colorKeywords and valueKeywords
	      // properties of the CSS MIME type with the values provided by the CSS properties
	      // database.

	      const {
	        propertyKeywords,
	        colorKeywords,
	        valueKeywords
	      } = getCSSKeywords(this.config.cssProperties);

	      let cssSpec = win.CodeMirror.resolveMode("text/css");
	      cssSpec.propertyKeywords = propertyKeywords;
	      cssSpec.colorKeywords = colorKeywords;
	      cssSpec.valueKeywords = valueKeywords;
	      win.CodeMirror.defineMIME("text/css", cssSpec);

	      let scssSpec = win.CodeMirror.resolveMode("text/x-scss");
	      scssSpec.propertyKeywords = propertyKeywords;
	      scssSpec.colorKeywords = colorKeywords;
	      scssSpec.valueKeywords = valueKeywords;
	      win.CodeMirror.defineMIME("text/x-scss", scssSpec);

	      win.CodeMirror.commands.save = () => this.emit("saveRequested");

	      // Create a CodeMirror instance add support for context menus,
	      // overwrite the default controller (otherwise items in the top and
	      // context menus won't work).

	      cm = win.CodeMirror(win.document.body, this.config);
	      this.Doc = win.CodeMirror.Doc;

	      // Disable APZ for source editors. It currently causes the line numbers to
	      // "tear off" and swim around on top of the content. Bug 1160601 tracks
	      // finding a solution that allows APZ to work with CodeMirror.
	      cm.getScrollerElement().addEventListener("wheel", ev => {
	        // By handling the wheel events ourselves, we force the platform to
	        // scroll synchronously, like it did before APZ. However, we lose smooth
	        // scrolling for users with mouse wheels. This seems acceptible vs.
	        // doing nothing and letting the gutter slide around.
	        ev.preventDefault();

	        let { deltaX, deltaY } = ev;

	        if (ev.deltaMode == ev.DOM_DELTA_LINE) {
	          deltaX *= cm.defaultCharWidth();
	          deltaY *= cm.defaultTextHeight();
	        } else if (ev.deltaMode == ev.DOM_DELTA_PAGE) {
	          deltaX *= cm.getWrapperElement().clientWidth;
	          deltaY *= cm.getWrapperElement().clientHeight;
	        }

	        cm.getScrollerElement().scrollBy(deltaX, deltaY);
	      });

	      cm.getWrapperElement().addEventListener("contextmenu", ev => {
	        ev.preventDefault();

	        if (!this.config.contextMenu) {
	          return;
	        }

	        let popup = this.config.contextMenu;
	        if (typeof popup == "string") {
	          popup = el.ownerDocument.getElementById(this.config.contextMenu);
	        }

	        this.emit("popupOpen", ev, popup);
	        popup.openPopupAtScreen(ev.screenX, ev.screenY, true);
	      }, false);

	      // Intercept the find and find again keystroke on CodeMirror, to avoid
	      // the browser's search

	      let findKey = L10N.getStr("find.commandkey");
	      let findAgainKey = L10N.getStr("findAgain.commandkey");
	      let [accel, modifier] = OS === "Darwin"
	                                      ? ["metaKey", "altKey"]
	                                      : ["ctrlKey", "shiftKey"];

	      cm.getWrapperElement().addEventListener("keydown", ev => {
	        let key = ev.key.toUpperCase();
	        let node = ev.originalTarget;
	        let isInput = node.tagName === "INPUT";
	        let isSearchInput = isInput && node.type === "search";

	        // replace box is a different input instance than search, and it is
	        // located in a code mirror dialog
	        let isDialogInput = isInput &&
	                       node.parentNode &&
	                       node.parentNode.classList.contains("CodeMirror-dialog");

	        if (!ev[accel] || !(isSearchInput || isDialogInput)) {
	          return;
	        }

	        if (key === findKey) {
	          ev.preventDefault();

	          if (isSearchInput || ev[modifier]) {
	            node.select();
	          }
	        } else if (key === findAgainKey) {
	          ev.preventDefault();

	          if (!isSearchInput) {
	            return;
	          }

	          let query = node.value;

	          // If there isn't a search state, or the text in the input does not
	          // match with the current search state, we need to create a new one
	          if (!cm.state.search || cm.state.search.query !== query) {
	            cm.state.search = {
	              posFrom: null,
	              posTo: null,
	              overlay: null,
	              query
	            };
	          }

	          if (ev.shiftKey) {
	            cm.execCommand("findPrev");
	          } else {
	            cm.execCommand("findNext");
	          }
	        }
	      });

	      cm.on("focus", () => this.emit("focus"));
	      cm.on("scroll", () => this.emit("scroll"));
	      cm.on("change", () => {
	        this.emit("change");
	        if (!this._lastDirty) {
	          this._lastDirty = true;
	          this.emit("dirty-change");
	        }
	      });
	      cm.on("cursorActivity", () => this.emit("cursorActivity"));

	      cm.on("gutterClick", (cmArg, line, gutter, ev) => {
	        let head = { line: line, ch: 0 };
	        let tail = { line: line, ch: this.getText(line).length };

	        // Shift-click on a gutter selects the whole line.
	        if (ev.shiftKey) {
	          cmArg.setSelection(head, tail);
	          return;
	        }

	        this.emit("gutterClick", line, ev.button);
	      });

	      win.CodeMirror.defineExtension("l10n", (name) => {
	        return L10N.getStr(name);
	      });

	      cm.getInputField().controllers.insertControllerAt(0, controller(this));

	      this.container = env;
	      editors.set(this, cm);

	      this.reloadPreferences = this.reloadPreferences.bind(this);
	      this._prefObserver = new PrefObserver("devtools.editor.");
	      this._prefObserver.on(TAB_SIZE, this.reloadPreferences);
	      this._prefObserver.on(EXPAND_TAB, this.reloadPreferences);
	      this._prefObserver.on(KEYMAP, this.reloadPreferences);
	      this._prefObserver.on(AUTO_CLOSE, this.reloadPreferences);
	      this._prefObserver.on(AUTOCOMPLETE, this.reloadPreferences);
	      this._prefObserver.on(DETECT_INDENT, this.reloadPreferences);
	      this._prefObserver.on(ENABLE_CODE_FOLDING, this.reloadPreferences);

	      this.reloadPreferences();

	      win.editor = this;
	      let editorReadyEvent = new win.CustomEvent("editorReady");
	      win.dispatchEvent(editorReadyEvent);

	      def.resolve();
	    };

	    env.addEventListener("load", onLoad, true);
	    env.setAttribute("src", CM_IFRAME);
	    el.appendChild(env);

	    this.once("destroy", () => el.removeChild(env));
	    return def.promise;
	  },

	  /**
	   * Returns a boolean indicating whether the editor is ready to
	   * use. Use appendTo(el).then(() => {}) for most cases
	   */
	  isAppended: function () {
	    return editors.has(this);
	  },

	  /**
	   * Returns the currently active highlighting mode.
	   * See Editor.modes for the list of all suppoert modes.
	   */
	  getMode: function () {
	    return this.getOption("mode");
	  },

	  /**
	   * Loads a script into editor's containing window.
	   */
	  loadScript: function (url) {
	    if (!this.container) {
	      throw new Error("Can't load a script until the editor is loaded.");
	    }
	    let win = this.container.contentWindow.wrappedJSObject;
	    Services.scriptloader.loadSubScript(url, win, "utf8");
	  },

	  /**
	   * Creates a CodeMirror Document
	   * @returns CodeMirror.Doc
	   */
	  createDocument: function () {
	    return new this.Doc("");
	  },

	  /**
	   * Replaces the current document with a new source document
	   */
	  replaceDocument: function (doc) {
	    let cm = editors.get(this);
	    cm.swapDoc(doc);
	  },

	  /**
	   * Changes the value of a currently used highlighting mode.
	   * See Editor.modes for the list of all supported modes.
	   */
	  setMode: function (value) {
	    this.setOption("mode", value);

	    // If autocomplete was set up and the mode is changing, then
	    // turn it off and back on again so the proper mode can be used.
	    if (this.config.autocomplete) {
	      this.setOption("autocomplete", false);
	      this.setOption("autocomplete", true);
	    }
	  },

	  /**
	   * Returns text from the text area. If line argument is provided
	   * the method returns only that line.
	   */
	  getText: function (line) {
	    let cm = editors.get(this);

	    if (line == null) {
	      return cm.getValue();
	    }

	    let info = cm.lineInfo(line);
	    return info ? cm.lineInfo(line).text : "";
	  },

	  /**
	   * Replaces whatever is in the text area with the contents of
	   * the 'value' argument.
	   */
	  setText: function (value) {
	    let cm = editors.get(this);
	    cm.setValue(value);

	    this.resetIndentUnit();
	  },

	  /**
	   * Reloads the state of the editor based on all current preferences.
	   * This is called automatically when any of the relevant preferences
	   * change.
	   */
	  reloadPreferences: function () {
	    // Restore the saved autoCloseBrackets value if it is preffed on.
	    let useAutoClose = Services.prefs.getBoolPref(AUTO_CLOSE);
	    this.setOption("autoCloseBrackets",
	      useAutoClose ? this.config.autoCloseBracketsSaved : false);

	    // If alternative keymap is provided, use it.
	    const keyMap = Services.prefs.getCharPref(KEYMAP);
	    if (VALID_KEYMAPS.has(keyMap)) {
	      this.setOption("keyMap", keyMap);
	    } else {
	      this.setOption("keyMap", "default");
	    }
	    this.updateCodeFoldingGutter();

	    this.resetIndentUnit();
	    this.setupAutoCompletion();
	  },

	  /**
	   * Sets the editor's indentation based on the current prefs and
	   * re-detect indentation if we should.
	   */
	  resetIndentUnit: function () {
	    let cm = editors.get(this);

	    let iterFn = function (start, end, callback) {
	      cm.eachLine(start, end, (line) => {
	        return callback(line.text);
	      });
	    };

	    let {indentUnit, indentWithTabs} = getIndentationFromIteration(iterFn);

	    cm.setOption("tabSize", indentUnit);
	    cm.setOption("indentUnit", indentUnit);
	    cm.setOption("indentWithTabs", indentWithTabs);
	  },

	  /**
	   * Replaces contents of a text area within the from/to {line, ch}
	   * range. If neither `from` nor `to` arguments are provided works
	   * exactly like setText. If only `from` object is provided, inserts
	   * text at that point, *overwriting* as many characters as needed.
	   */
	  replaceText: function (value, from, to) {
	    let cm = editors.get(this);

	    if (!from) {
	      this.setText(value);
	      return;
	    }

	    if (!to) {
	      let text = cm.getRange({ line: 0, ch: 0 }, from);
	      this.setText(text + value);
	      return;
	    }

	    cm.replaceRange(value, from, to);
	  },

	  /**
	   * Inserts text at the specified {line, ch} position, shifting existing
	   * contents as necessary.
	   */
	  insertText: function (value, at) {
	    let cm = editors.get(this);
	    cm.replaceRange(value, at, at);
	  },

	  /**
	   * Deselects contents of the text area.
	   */
	  dropSelection: function () {
	    if (!this.somethingSelected()) {
	      return;
	    }

	    this.setCursor(this.getCursor());
	  },

	  /**
	   * Returns true if there is more than one selection in the editor.
	   */
	  hasMultipleSelections: function () {
	    let cm = editors.get(this);
	    return cm.listSelections().length > 1;
	  },

	  /**
	   * Gets the first visible line number in the editor.
	   */
	  getFirstVisibleLine: function () {
	    let cm = editors.get(this);
	    return cm.lineAtHeight(0, "local");
	  },

	  /**
	   * Scrolls the view such that the given line number is the first visible line.
	   */
	  setFirstVisibleLine: function (line) {
	    let cm = editors.get(this);
	    let { top } = cm.charCoords({line: line, ch: 0}, "local");
	    cm.scrollTo(0, top);
	  },

	  /**
	   * Sets the cursor to the specified {line, ch} position with an additional
	   * option to align the line at the "top", "center" or "bottom" of the editor
	   * with "top" being default value.
	   */
	  setCursor: function ({line, ch}, align) {
	    let cm = editors.get(this);
	    this.alignLine(line, align);
	    cm.setCursor({line: line, ch: ch});
	    this.emit("cursorActivity");
	  },

	  /**
	   * Aligns the provided line to either "top", "center" or "bottom" of the
	   * editor view with a maximum margin of MAX_VERTICAL_OFFSET lines from top or
	   * bottom.
	   */
	  alignLine: function (line, align) {
	    let cm = editors.get(this);
	    let from = cm.lineAtHeight(0, "page");
	    let to = cm.lineAtHeight(cm.getWrapperElement().clientHeight, "page");
	    let linesVisible = to - from;
	    let halfVisible = Math.round(linesVisible / 2);

	    // If the target line is in view, skip the vertical alignment part.
	    if (line <= to && line >= from) {
	      return;
	    }

	    // Setting the offset so that the line always falls in the upper half
	    // of visible lines (lower half for bottom aligned).
	    // MAX_VERTICAL_OFFSET is the maximum allowed value.
	    let offset = Math.min(halfVisible, MAX_VERTICAL_OFFSET);

	    let topLine = {
	      "center": Math.max(line - halfVisible, 0),
	      "bottom": Math.max(line - linesVisible + offset, 0),
	      "top": Math.max(line - offset, 0)
	    }[align || "top"] || offset;

	    // Bringing down the topLine to total lines in the editor if exceeding.
	    topLine = Math.min(topLine, this.lineCount());
	    this.setFirstVisibleLine(topLine);
	  },

	  /**
	   * Returns whether a marker of a specified class exists in a line's gutter.
	   */
	  hasMarker: function (line, gutterName, markerClass) {
	    let marker = this.getMarker(line, gutterName);
	    if (!marker) {
	      return false;
	    }

	    return marker.classList.contains(markerClass);
	  },

	  /**
	   * Adds a marker with a specified class to a line's gutter. If another marker
	   * exists on that line, the new marker class is added to its class list.
	   */
	  addMarker: function (line, gutterName, markerClass) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) {
	      return;
	    }

	    let gutterMarkers = info.gutterMarkers;
	    let marker;
	    if (gutterMarkers) {
	      marker = gutterMarkers[gutterName];
	      if (marker) {
	        marker.classList.add(markerClass);
	        return;
	      }
	    }

	    marker = cm.getWrapperElement().ownerDocument.createElement("div");
	    marker.className = markerClass;
	    cm.setGutterMarker(info.line, gutterName, marker);
	  },

	  /**
	   * The reverse of addMarker. Removes a marker of a specified class from a
	   * line's gutter.
	   */
	  removeMarker: function (line, gutterName, markerClass) {
	    if (!this.hasMarker(line, gutterName, markerClass)) {
	      return;
	    }

	    let cm = editors.get(this);
	    cm.lineInfo(line).gutterMarkers[gutterName].classList.remove(markerClass);
	  },

	  /**
	   * Adds a marker with a specified class and an HTML content to a line's
	   * gutter. If another marker exists on that line, it is overwritten by a new
	   * marker.
	   */
	  addContentMarker: function (line, gutterName, markerClass, content) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) {
	      return;
	    }

	    let marker = cm.getWrapperElement().ownerDocument.createElement("div");
	    marker.className = markerClass;
	    marker.innerHTML = content;
	    cm.setGutterMarker(info.line, gutterName, marker);
	  },

	  /**
	   * The reverse of addContentMarker. Removes any line's markers in the
	   * specified gutter.
	   */
	  removeContentMarker: function (line, gutterName) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) {
	      return;
	    }

	    cm.setGutterMarker(info.line, gutterName, null);
	  },

	  getMarker: function (line, gutterName) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);
	    if (!info) {
	      return null;
	    }

	    let gutterMarkers = info.gutterMarkers;
	    if (!gutterMarkers) {
	      return null;
	    }

	    return gutterMarkers[gutterName];
	  },

	  /**
	   * Removes all gutter markers in the gutter with the given name.
	   */
	  removeAllMarkers: function (gutterName) {
	    let cm = editors.get(this);
	    cm.clearGutter(gutterName);
	  },

	  /**
	   * Handles attaching a set of events listeners on a marker. They should
	   * be passed as an object literal with keys as event names and values as
	   * function listeners. The line number, marker node and optional data
	   * will be passed as arguments to the function listener.
	   *
	   * You don't need to worry about removing these event listeners.
	   * They're automatically orphaned when clearing markers.
	   */
	  setMarkerListeners: function (line, gutterName, markerClass, eventsArg, data) {
	    if (!this.hasMarker(line, gutterName, markerClass)) {
	      return;
	    }

	    let cm = editors.get(this);
	    let marker = cm.lineInfo(line).gutterMarkers[gutterName];

	    for (let name in eventsArg) {
	      let listener = eventsArg[name].bind(this, line, marker, data);
	      marker.addEventListener(name, listener);
	    }
	  },

	  /**
	   * Returns whether a line is decorated using the specified class name.
	   */
	  hasLineClass: function (line, className) {
	    let cm = editors.get(this);
	    let info = cm.lineInfo(line);

	    if (!info || !info.wrapClass) {
	      return false;
	    }

	    return info.wrapClass.split(" ").indexOf(className) != -1;
	  },

	  /**
	   * Sets a CSS class name for the given line, including the text and gutter.
	   */
	  addLineClass: function (line, className) {
	    let cm = editors.get(this);
	    cm.addLineClass(line, "wrap", className);
	  },

	  /**
	   * The reverse of addLineClass.
	   */
	  removeLineClass: function (line, className) {
	    let cm = editors.get(this);
	    cm.removeLineClass(line, "wrap", className);
	  },

	  /**
	   * Mark a range of text inside the two {line, ch} bounds. Since the range may
	   * be modified, for example, when typing text, this method returns a function
	   * that can be used to remove the mark.
	   */
	  markText: function (from, to, className = "marked-text") {
	    let cm = editors.get(this);
	    let text = cm.getRange(from, to);
	    let span = cm.getWrapperElement().ownerDocument.createElement("span");
	    span.className = className;
	    span.textContent = text;

	    let mark = cm.markText(from, to, { replacedWith: span });
	    return {
	      anchor: span,
	      clear: () => mark.clear()
	    };
	  },

	  /**
	   * Calculates and returns one or more {line, ch} objects for
	   * a zero-based index who's value is relative to the start of
	   * the editor's text.
	   *
	   * If only one argument is given, this method returns a single
	   * {line,ch} object. Otherwise it returns an array.
	   */
	  getPosition: function (...args) {
	    let cm = editors.get(this);
	    let res = args.map((ind) => cm.posFromIndex(ind));
	    return args.length === 1 ? res[0] : res;
	  },

	  /**
	   * The reverse of getPosition. Similarly to getPosition this
	   * method returns a single value if only one argument was given
	   * and an array otherwise.
	   */
	  getOffset: function (...args) {
	    let cm = editors.get(this);
	    let res = args.map((pos) => cm.indexFromPos(pos));
	    return args.length > 1 ? res : res[0];
	  },

	  /**
	   * Returns a {line, ch} object that corresponds to the
	   * left, top coordinates.
	   */
	  getPositionFromCoords: function ({left, top}) {
	    let cm = editors.get(this);
	    return cm.coordsChar({ left: left, top: top });
	  },

	  /**
	   * The reverse of getPositionFromCoords. Similarly, returns a {left, top}
	   * object that corresponds to the specified line and character number.
	   */
	  getCoordsFromPosition: function ({line, ch}) {
	    let cm = editors.get(this);
	    return cm.charCoords({ line: ~~line, ch: ~~ch });
	  },

	  /**
	   * Returns true if there's something to undo and false otherwise.
	   */
	  canUndo: function () {
	    let cm = editors.get(this);
	    return cm.historySize().undo > 0;
	  },

	  /**
	   * Returns true if there's something to redo and false otherwise.
	   */
	  canRedo: function () {
	    let cm = editors.get(this);
	    return cm.historySize().redo > 0;
	  },

	  /**
	   * Marks the contents as clean and returns the current
	   * version number.
	   */
	  setClean: function () {
	    let cm = editors.get(this);
	    this.version = cm.changeGeneration();
	    this._lastDirty = false;
	    this.emit("dirty-change");
	    return this.version;
	  },

	  /**
	   * Returns true if contents of the text area are
	   * clean i.e. no changes were made since the last version.
	   */
	  isClean: function () {
	    let cm = editors.get(this);
	    return cm.isClean(this.version);
	  },

	  /**
	   * This method opens an in-editor dialog asking for a line to
	   * jump to. Once given, it changes cursor to that line.
	   */
	  jumpToLine: function () {
	    let doc = editors.get(this).getWrapperElement().ownerDocument;
	    let div = doc.createElement("div");
	    let inp = doc.createElement("input");
	    let txt =
	      doc.createTextNode(L10N.getStr("gotoLineCmd.promptTitle"));

	    inp.type = "text";
	    inp.style.width = "10em";
	    inp.style.marginInlineStart = "1em";

	    div.appendChild(txt);
	    div.appendChild(inp);

	    if (!this.hasMultipleSelections()) {
	      let cm = editors.get(this);
	      let sel = cm.getSelection();
	      // Scratchpad inserts and selects a comment after an error happens:
	      // "@Scratchpad/1:10:2". Parse this to get the line and column.
	      // In the string above this is line 10, column 2.
	      let match = sel.match(RE_SCRATCHPAD_ERROR);
	      if (match) {
	        let [, line, column ] = match;
	        inp.value = column ? line + ":" + column : line;
	        inp.selectionStart = inp.selectionEnd = inp.value.length;
	      }
	    }

	    this.openDialog(div, (line) => {
	      // Handle LINE:COLUMN as well as LINE
	      let match = line.toString().match(RE_JUMP_TO_LINE);
	      if (match) {
	        let [, matchLine, column ] = match;
	        this.setCursor({line: matchLine - 1, ch: column ? column - 1 : 0 });
	      }
	    });
	  },

	  /**
	   * Moves the content of the current line or the lines selected up a line.
	   */
	  moveLineUp: function () {
	    let cm = editors.get(this);
	    let start = cm.getCursor("start");
	    let end = cm.getCursor("end");

	    if (start.line === 0) {
	      return;
	    }

	    // Get the text in the lines selected or the current line of the cursor
	    // and append the text of the previous line.
	    let value;
	    if (start.line !== end.line) {
	      value = cm.getRange({ line: start.line, ch: 0 },
	        { line: end.line, ch: cm.getLine(end.line).length }) + "\n";
	    } else {
	      value = cm.getLine(start.line) + "\n";
	    }
	    value += cm.getLine(start.line - 1);

	    // Replace the previous line and the currently selected lines with the new
	    // value and maintain the selection of the text.
	    cm.replaceRange(value, { line: start.line - 1, ch: 0 },
	      { line: end.line, ch: cm.getLine(end.line).length });
	    cm.setSelection({ line: start.line - 1, ch: start.ch },
	      { line: end.line - 1, ch: end.ch });
	  },

	  /**
	   * Moves the content of the current line or the lines selected down a line.
	   */
	  moveLineDown: function () {
	    let cm = editors.get(this);
	    let start = cm.getCursor("start");
	    let end = cm.getCursor("end");

	    if (end.line + 1 === cm.lineCount()) {
	      return;
	    }

	    // Get the text of next line and append the text in the lines selected
	    // or the current line of the cursor.
	    let value = cm.getLine(end.line + 1) + "\n";
	    if (start.line !== end.line) {
	      value += cm.getRange({ line: start.line, ch: 0 },
	        { line: end.line, ch: cm.getLine(end.line).length });
	    } else {
	      value += cm.getLine(start.line);
	    }

	    // Replace the currently selected lines and the next line with the new
	    // value and maintain the selection of the text.
	    cm.replaceRange(value, { line: start.line, ch: 0 },
	      { line: end.line + 1, ch: cm.getLine(end.line + 1).length});
	    cm.setSelection({ line: start.line + 1, ch: start.ch },
	      { line: end.line + 1, ch: end.ch });
	  },

	  /**
	   * Returns current font size for the editor area, in pixels.
	   */
	  getFontSize: function () {
	    let cm = editors.get(this);
	    let el = cm.getWrapperElement();
	    let win = el.ownerDocument.defaultView;

	    return parseInt(win.getComputedStyle(el).getPropertyValue("font-size"), 10);
	  },

	  /**
	   * Sets font size for the editor area.
	   */
	  setFontSize: function (size) {
	    let cm = editors.get(this);
	    cm.getWrapperElement().style.fontSize = parseInt(size, 10) + "px";
	    cm.refresh();
	  },

	  /**
	   * Sets an option for the editor.  For most options it just defers to
	   * CodeMirror.setOption, but certain ones are maintained within the editor
	   * instance.
	   */
	  setOption: function (o, v) {
	    let cm = editors.get(this);

	    // Save the state of a valid autoCloseBrackets string, so we can reset
	    // it if it gets preffed off and back on.
	    if (o === "autoCloseBrackets" && v) {
	      this.config.autoCloseBracketsSaved = v;
	    }

	    if (o === "autocomplete") {
	      this.config.autocomplete = v;
	      this.setupAutoCompletion();
	    } else {
	      cm.setOption(o, v);
	      this.config[o] = v;
	    }

	    if (o === "enableCodeFolding") {
	      // The new value maybe explicitly force foldGUtter on or off, ignoring
	      // the prefs service.
	      this.updateCodeFoldingGutter();
	    }
	  },

	  /**
	   * Gets an option for the editor.  For most options it just defers to
	   * CodeMirror.getOption, but certain ones are maintained within the editor
	   * instance.
	   */
	  getOption: function (o) {
	    let cm = editors.get(this);
	    if (o === "autocomplete") {
	      return this.config.autocomplete;
	    }

	    return cm.getOption(o);
	  },

	  /**
	   * Sets up autocompletion for the editor. Lazily imports the required
	   * dependencies because they vary by editor mode.
	   *
	   * Autocompletion is special, because we don't want to automatically use
	   * it just because it is preffed on (it still needs to be requested by the
	   * editor), but we do want to always disable it if it is preffed off.
	   */
	  setupAutoCompletion: function () {
	    // The autocomplete module will overwrite this.initializeAutoCompletion
	    // with a mode specific autocompletion handler.
	    if (!this.initializeAutoCompletion) {
	      this.extend(__webpack_require__(220));
	    }

	    if (this.config.autocomplete && Services.prefs.getBoolPref(AUTOCOMPLETE)) {
	      this.initializeAutoCompletion(this.config.autocompleteOpts);
	    } else {
	      this.destroyAutoCompletion();
	    }
	  },

	  /**
	   * Extends an instance of the Editor object with additional
	   * functions. Each function will be called with context as
	   * the first argument. Context is a {ed, cm} object where
	   * 'ed' is an instance of the Editor object and 'cm' is an
	   * instance of the CodeMirror object. Example:
	   *
	   * function hello(ctx, name) {
	   *   let { cm, ed } = ctx;
	   *   cm;   // CodeMirror instance
	   *   ed;   // Editor instance
	   *   name; // 'Mozilla'
	   * }
	   *
	   * editor.extend({ hello: hello });
	   * editor.hello('Mozilla');
	   */
	  extend: function (funcs) {
	    Object.keys(funcs).forEach(name => {
	      let cm = editors.get(this);
	      let ctx = { ed: this, cm: cm, Editor: Editor};

	      if (name === "initialize") {
	        funcs[name](ctx);
	        return;
	      }

	      this[name] = funcs[name].bind(null, ctx);
	    });
	  },

	  destroy: function () {
	    this.container = null;
	    this.config = null;
	    this.version = null;

	    if (this._prefObserver) {
	      this._prefObserver.off(TAB_SIZE, this.reloadPreferences);
	      this._prefObserver.off(EXPAND_TAB, this.reloadPreferences);
	      this._prefObserver.off(KEYMAP, this.reloadPreferences);
	      this._prefObserver.off(AUTO_CLOSE, this.reloadPreferences);
	      this._prefObserver.off(AUTOCOMPLETE, this.reloadPreferences);
	      this._prefObserver.off(DETECT_INDENT, this.reloadPreferences);
	      this._prefObserver.off(ENABLE_CODE_FOLDING, this.reloadPreferences);
	      this._prefObserver.destroy();
	    }

	    this.emit("destroy");
	  },

	  updateCodeFoldingGutter: function () {
	    let shouldFoldGutter = this.config.enableCodeFolding;
	    let foldGutterIndex = this.config.gutters.indexOf("CodeMirror-foldgutter");
	    let cm = editors.get(this);

	    if (shouldFoldGutter === undefined) {
	      shouldFoldGutter = Services.prefs.getBoolPref(ENABLE_CODE_FOLDING);
	    }

	    if (shouldFoldGutter) {
	      // Add the gutter before enabling foldGutter
	      if (foldGutterIndex === -1) {
	        let gutters = this.config.gutters.slice();
	        gutters.push("CodeMirror-foldgutter");
	        this.setOption("gutters", gutters);
	      }

	      this.setOption("foldGutter", true);
	    } else {
	      // No code should remain folded when folding is off.
	      if (cm) {
	        cm.execCommand("unfoldAll");
	      }

	      // Remove the gutter so it doesn't take up space
	      if (foldGutterIndex !== -1) {
	        let gutters = this.config.gutters.slice();
	        gutters.splice(foldGutterIndex, 1);
	        this.setOption("gutters", gutters);
	      }

	      this.setOption("foldGutter", false);
	    }
	  }
	};

	// Since Editor is a thin layer over CodeMirror some methods
	// are mapped directly—without any changes.

	CM_MAPPING.forEach(name => {
	  Editor.prototype[name] = function (...args) {
	    let cm = editors.get(this);
	    return cm[name].apply(cm, args);
	  };
	});

	// Static methods on the Editor object itself.

	/**
	 * Returns a string representation of a shortcut 'key' with
	 * a OS specific modifier. Cmd- for Macs, Ctrl- for other
	 * platforms. Useful with extraKeys configuration option.
	 *
	 * CodeMirror defines all keys with modifiers in the following
	 * order: Shift - Ctrl/Cmd - Alt - Key
	 */
	Editor.accel = function (key, modifiers = {}) {
	  return (modifiers.shift ? "Shift-" : "") +
	         (Services.appinfo.OS == "Darwin" ? "Cmd-" : "Ctrl-") +
	         (modifiers.alt ? "Alt-" : "") + key;
	};

	/**
	 * Returns a string representation of a shortcut for a
	 * specified command 'cmd'. Append Cmd- for macs, Ctrl- for other
	 * platforms unless noaccel is specified in the options. Useful when overwriting
	 * or disabling default shortcuts.
	 */
	Editor.keyFor = function (cmd, opts = { noaccel: false }) {
	  let key = L10N.getStr(cmd + ".commandkey");
	  return opts.noaccel ? key : Editor.accel(key);
	};

	/**
	 * We compute the CSS property names, values, and color names to be used with
	 * CodeMirror to more closely reflect what is supported by the target platform.
	 * The database is used to replace the values used in CodeMirror while initiating
	 * an editor object. This is done here instead of the file codemirror/css.js so
	 * as to leave that file untouched and easily upgradable.
	 */
	function getCSSKeywords(cssProperties) {
	  function keySet(array) {
	    let keys = {};
	    for (let i = 0; i < array.length; ++i) {
	      keys[array[i]] = true;
	    }
	    return keys;
	  }

	  let propertyKeywords = cssProperties.getNames();
	  let colorKeywords = {};
	  let valueKeywords = {};

	  propertyKeywords.forEach(property => {
	    if (property.includes("color")) {
	      cssProperties.getValues(property).forEach(value => {
	        colorKeywords[value] = true;
	      });
	    } else {
	      cssProperties.getValues(property).forEach(value => {
	        valueKeywords[value] = true;
	      });
	    }
	  });

	  return {
	    propertyKeywords: keySet(propertyKeywords),
	    colorKeywords: colorKeywords,
	    valueKeywords: valueKeywords
	  };
	}

	/**
	 * Returns a controller object that can be used for
	 * editor-specific commands such as find, jump to line,
	 * copy/paste, etc.
	 */
	function controller(ed) {
	  return {
	    supportsCommand: function (cmd) {
	      switch (cmd) {
	        case "cmd_find":
	        case "cmd_findAgain":
	        case "cmd_findPrevious":
	        case "cmd_gotoLine":
	        case "cmd_undo":
	        case "cmd_redo":
	        case "cmd_delete":
	        case "cmd_selectAll":
	          return true;
	      }

	      return false;
	    },

	    isCommandEnabled: function (cmd) {
	      let cm = editors.get(ed);

	      switch (cmd) {
	        case "cmd_find":
	        case "cmd_gotoLine":
	        case "cmd_selectAll":
	          return true;
	        case "cmd_findAgain":
	          return cm.state.search != null && cm.state.search.query != null;
	        case "cmd_undo":
	          return ed.canUndo();
	        case "cmd_redo":
	          return ed.canRedo();
	        case "cmd_delete":
	          return ed.somethingSelected();
	      }

	      return false;
	    },

	    doCommand: function (cmd) {
	      let cm = editors.get(ed);
	      let map = {
	        "cmd_selectAll": "selectAll",
	        "cmd_find": "find",
	        "cmd_undo": "undo",
	        "cmd_redo": "redo",
	        "cmd_delete": "delCharAfter",
	        "cmd_findAgain": "findNext"
	      };

	      if (map[cmd]) {
	        cm.execCommand(map[cmd]);
	        return;
	      }

	      if (cmd == "cmd_gotoLine") {
	        ed.jumpToLine();
	      }
	    },

	    onEvent: function () {}
	  };
	}

	module.exports = Editor;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/* vim:set ts=2 sw=2 sts=2 et tw=80:
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const CSSCompleter = __webpack_require__(221);
	const { AutocompletePopup } = __webpack_require__(208);
	const {KeyCodes} = __webpack_require__(14);

	const CM_TERN_SCRIPTS = [
	  "chrome://devtools/content/sourceeditor/codemirror/addon/tern/tern.js",
	  "chrome://devtools/content/sourceeditor/codemirror/addon/hint/show-hint.js"
	];

	const autocompleteMap = new WeakMap();

	/**
	 * Prepares an editor instance for autocompletion.
	 */
	function initializeAutoCompletion(ctx, options = {}) {
	  let { cm, ed, Editor } = ctx;
	  if (autocompleteMap.has(ed)) {
	    return;
	  }

	  let win = ed.container.contentWindow.wrappedJSObject;
	  let { CodeMirror, document } = win;

	  let completer = null;
	  let autocompleteKey = "Ctrl-" +
	                        Editor.keyFor("autocompletion", { noaccel: true });
	  if (ed.config.mode == Editor.modes.js) {
	    let defs = [
	      __webpack_require__(222),
	      __webpack_require__(223),
	    ];

	    CM_TERN_SCRIPTS.forEach(ed.loadScript, ed);
	    win.tern = __webpack_require__(224);
	    cm.tern = new CodeMirror.TernServer({
	      defs: defs,
	      typeTip: function (data) {
	        let tip = document.createElement("span");
	        tip.className = "CodeMirror-Tern-information";
	        let tipType = document.createElement("strong");
	        let tipText = document.createTextNode(data.type ||
	          cm.l10n("autocompletion.notFound"));
	        tipType.appendChild(tipText);
	        tip.appendChild(tipType);

	        if (data.doc) {
	          tip.appendChild(document.createTextNode(" — " + data.doc));
	        }

	        if (data.url) {
	          tip.appendChild(document.createTextNode(" "));
	          let docLink = document.createElement("a");
	          docLink.textContent = "[" + cm.l10n("autocompletion.docsLink") + "]";
	          docLink.href = data.url;
	          docLink.className = "theme-link";
	          docLink.setAttribute("target", "_blank");
	          tip.appendChild(docLink);
	        }

	        return tip;
	      }
	    });

	    let keyMap = {};
	    let updateArgHintsCallback = cm.tern.updateArgHints.bind(cm.tern, cm);
	    cm.on("cursorActivity", updateArgHintsCallback);

	    keyMap[autocompleteKey] = cmArg => {
	      cmArg.tern.getHint(cmArg, data => {
	        CodeMirror.on(data, "shown", () => ed.emit("before-suggest"));
	        CodeMirror.on(data, "close", () => ed.emit("after-suggest"));
	        CodeMirror.on(data, "select", () => ed.emit("suggestion-entered"));
	        CodeMirror.showHint(cmArg, (cmIgnore, cb) => cb(data), { async: true });
	      });
	    };

	    keyMap[Editor.keyFor("showInformation2", { noaccel: true })] = cmArg => {
	      cmArg.tern.showType(cmArg, null, () => {
	        ed.emit("show-information");
	      });
	    };
	    cm.addKeyMap(keyMap);

	    let destroyTern = function () {
	      ed.off("destroy", destroyTern);
	      cm.off("cursorActivity", updateArgHintsCallback);
	      cm.removeKeyMap(keyMap);
	      win.tern = cm.tern = null;
	      autocompleteMap.delete(ed);
	    };

	    ed.on("destroy", destroyTern);

	    autocompleteMap.set(ed, {
	      destroy: destroyTern
	    });

	    // TODO: Integrate tern autocompletion with this autocomplete API.
	    return;
	  } else if (ed.config.mode == Editor.modes.css) {
	    completer = new CSSCompleter({walker: options.walker,
	                                  cssProperties: options.cssProperties});
	  }

	  function insertSelectedPopupItem() {
	    let autocompleteState = autocompleteMap.get(ed);
	    if (!popup || !popup.isOpen || !autocompleteState) {
	      return false;
	    }

	    if (!autocompleteState.suggestionInsertedOnce && popup.selectedItem) {
	      autocompleteMap.get(ed).insertingSuggestion = true;
	      insertPopupItem(ed, popup.selectedItem);
	    }

	    popup.once("popup-closed", () => {
	      // This event is used in tests.
	      ed.emit("popup-hidden");
	    });
	    popup.hidePopup();
	    return true;
	  }

	  // Give each popup a new name to avoid sharing the elements.

	  let popup = new AutocompletePopup({ doc: win.parent.document }, {
	    position: "bottom",
	    theme: "auto",
	    autoSelect: true,
	    onClick: insertSelectedPopupItem
	  });

	  let cycle = reverse => {
	    if (popup && popup.isOpen) {
	      cycleSuggestions(ed, reverse == true);
	      return null;
	    }

	    return CodeMirror.Pass;
	  };

	  let keyMap = {
	    "Tab": cycle,
	    "Down": cycle,
	    "Shift-Tab": cycle.bind(null, true),
	    "Up": cycle.bind(null, true),
	    "Enter": () => {
	      let wasHandled = insertSelectedPopupItem();
	      return wasHandled ? true : CodeMirror.Pass;
	    }
	  };

	  let autoCompleteCallback = autoComplete.bind(null, ctx);
	  let keypressCallback = onEditorKeypress.bind(null, ctx);
	  keyMap[autocompleteKey] = autoCompleteCallback;
	  cm.addKeyMap(keyMap);

	  cm.on("keydown", keypressCallback);
	  ed.on("change", autoCompleteCallback);
	  ed.on("destroy", destroy);

	  function destroy() {
	    ed.off("destroy", destroy);
	    cm.off("keydown", keypressCallback);
	    ed.off("change", autoCompleteCallback);
	    cm.removeKeyMap(keyMap);
	    popup.destroy();
	    keyMap = popup = completer = null;
	    autocompleteMap.delete(ed);
	  }

	  autocompleteMap.set(ed, {
	    popup: popup,
	    completer: completer,
	    keyMap: keyMap,
	    destroy: destroy,
	    insertingSuggestion: false,
	    suggestionInsertedOnce: false
	  });
	}

	/**
	 * Destroy autocompletion on an editor instance.
	 */
	function destroyAutoCompletion(ctx) {
	  let { ed } = ctx;
	  if (!autocompleteMap.has(ed)) {
	    return;
	  }

	  let {destroy} = autocompleteMap.get(ed);
	  destroy();
	}

	/**
	 * Provides suggestions to autocomplete the current token/word being typed.
	 */
	function autoComplete({ ed, cm }) {
	  let autocompleteOpts = autocompleteMap.get(ed);
	  let { completer, popup } = autocompleteOpts;
	  if (!completer || autocompleteOpts.insertingSuggestion ||
	      autocompleteOpts.doNotAutocomplete) {
	    autocompleteOpts.insertingSuggestion = false;
	    return;
	  }
	  let cur = ed.getCursor();
	  completer.complete(cm.getRange({line: 0, ch: 0}, cur), cur).then(suggestions => {
	    if (!suggestions || !suggestions.length || suggestions[0].preLabel == null) {
	      autocompleteOpts.suggestionInsertedOnce = false;
	      popup.once("popup-closed", () => {
	        // This event is used in tests.
	        ed.emit("after-suggest");
	      });
	      popup.hidePopup();
	      return;
	    }
	    // The cursor is at the end of the currently entered part of the token,
	    // like "backgr|" but we need to open the popup at the beginning of the
	    // character "b". Thus we need to calculate the width of the entered part
	    // of the token ("backgr" here). 4 comes from the popup's left padding.

	    let cursorElement = cm.display.cursorDiv.querySelector(".CodeMirror-cursor");
	    let left = suggestions[0].preLabel.length * cm.defaultCharWidth() + 4;
	    popup.hidePopup();
	    popup.setItems(suggestions);

	    popup.once("popup-opened", () => {
	      // This event is used in tests.
	      ed.emit("after-suggest");
	    });
	    popup.openPopup(cursorElement, -1 * left, 0);
	    autocompleteOpts.suggestionInsertedOnce = false;
	  }).then(null, e => console.error(e));
	}

	/**
	 * Inserts a popup item into the current cursor location
	 * in the editor.
	 */
	function insertPopupItem(ed, popupItem) {
	  let {preLabel, text} = popupItem;
	  let cur = ed.getCursor();
	  let textBeforeCursor = ed.getText(cur.line).substring(0, cur.ch);
	  let backwardsTextBeforeCursor = textBeforeCursor.split("").reverse().join("");
	  let backwardsPreLabel = preLabel.split("").reverse().join("");

	  // If there is additional text in the preLabel vs the line, then
	  // just insert the entire autocomplete text.  An example:
	  // if you type 'a' and select '#about' from the autocomplete menu,
	  // then the final text needs to the end up as '#about'.
	  if (backwardsPreLabel.indexOf(backwardsTextBeforeCursor) === 0) {
	    ed.replaceText(text, {line: cur.line, ch: 0}, cur);
	  } else {
	    ed.replaceText(text.slice(preLabel.length), cur, cur);
	  }
	}

	/**
	 * Cycles through provided suggestions by the popup in a top to bottom manner
	 * when `reverse` is not true. Opposite otherwise.
	 */
	function cycleSuggestions(ed, reverse) {
	  let autocompleteOpts = autocompleteMap.get(ed);
	  let { popup } = autocompleteOpts;
	  let cur = ed.getCursor();
	  autocompleteOpts.insertingSuggestion = true;
	  if (!autocompleteOpts.suggestionInsertedOnce) {
	    autocompleteOpts.suggestionInsertedOnce = true;
	    let firstItem;
	    if (reverse) {
	      firstItem = popup.getItemAtIndex(popup.itemCount - 1);
	      popup.selectPreviousItem();
	    } else {
	      firstItem = popup.getItemAtIndex(0);
	      if (firstItem.label == firstItem.preLabel && popup.itemCount > 1) {
	        firstItem = popup.getItemAtIndex(1);
	        popup.selectNextItem();
	      }
	    }
	    if (popup.itemCount == 1) {
	      popup.hidePopup();
	    }
	    insertPopupItem(ed, firstItem);
	  } else {
	    let fromCur = {
	      line: cur.line,
	      ch: cur.ch - popup.selectedItem.text.length
	    };
	    if (reverse) {
	      popup.selectPreviousItem();
	    } else {
	      popup.selectNextItem();
	    }
	    ed.replaceText(popup.selectedItem.text, fromCur, cur);
	  }
	  // This event is used in tests.
	  ed.emit("suggestion-entered");
	}

	/**
	 * onkeydown handler for the editor instance to prevent autocompleting on some
	 * keypresses.
	 */
	function onEditorKeypress({ ed, Editor }, cm, event) {
	  let autocompleteOpts = autocompleteMap.get(ed);

	  // Do not try to autocomplete with multiple selections.
	  if (ed.hasMultipleSelections()) {
	    autocompleteOpts.doNotAutocomplete = true;
	    autocompleteOpts.popup.hidePopup();
	    return;
	  }

	  if ((event.ctrlKey || event.metaKey) && event.keyCode == KeyCodes.DOM_VK_SPACE) {
	    // When Ctrl/Cmd + Space is pressed, two simultaneous keypresses are emitted
	    // first one for just the Ctrl/Cmd and second one for combo. The first one
	    // leave the autocompleteOpts.doNotAutocomplete as true, so we have to make
	    // it false
	    autocompleteOpts.doNotAutocomplete = false;
	    return;
	  }

	  if (event.ctrlKey || event.metaKey || event.altKey) {
	    autocompleteOpts.doNotAutocomplete = true;
	    autocompleteOpts.popup.hidePopup();
	    return;
	  }

	  switch (event.keyCode) {
	    case KeyCodes.DOM_VK_RETURN:
	      autocompleteOpts.doNotAutocomplete = true;
	      break;
	    case KeyCodes.DOM_VK_ESCAPE:
	      if (autocompleteOpts.popup.isOpen) {
	        event.preventDefault();
	      }
	      break;
	    case KeyCodes.DOM_VK_LEFT:
	    case KeyCodes.DOM_VK_RIGHT:
	    case KeyCodes.DOM_VK_HOME:
	    case KeyCodes.DOM_VK_END:
	      autocompleteOpts.doNotAutocomplete = true;
	      autocompleteOpts.popup.hidePopup();
	      break;
	    case KeyCodes.DOM_VK_BACK_SPACE:
	    case KeyCodes.DOM_VK_DELETE:
	      if (ed.config.mode == Editor.modes.css) {
	        autocompleteOpts.completer.invalidateCache(ed.getCursor().line);
	      }
	      autocompleteOpts.doNotAutocomplete = true;
	      autocompleteOpts.popup.hidePopup();
	      break;
	    default:
	      autocompleteOpts.doNotAutocomplete = false;
	  }
	}

	/**
	 * Returns the private popup. This method is used by tests to test the feature.
	 */
	function getPopup({ ed }) {
	  if (autocompleteMap.has(ed)) {
	    return autocompleteMap.get(ed).popup;
	  }

	  return null;
	}

	/**
	 * Returns contextual information about the token covered by the caret if the
	 * implementation of completer supports it.
	 */
	function getInfoAt({ ed }, caret) {
	  if (autocompleteMap.has(ed)) {
	    let completer = autocompleteMap.get(ed).completer;
	    if (completer && completer.getInfoAt) {
	      return completer.getInfoAt(ed.getText(), caret);
	    }
	  }

	  return null;
	}

	/**
	 * Returns whether autocompletion is enabled for this editor.
	 * Used for testing
	 */
	function isAutocompletionEnabled({ ed }) {
	  return autocompleteMap.has(ed);
	}

	// Export functions

	module.exports.initializeAutoCompletion = initializeAutoCompletion;
	module.exports.destroyAutoCompletion = destroyAutoCompletion;
	module.exports.getAutocompletionPopup = getPopup;
	module.exports.getInfoAt = getInfoAt;
	module.exports.isAutocompletionEnabled = isAutocompletionEnabled;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/* eslint-disable complexity */
	const {cssTokenizer, cssTokenizerWithLineColumn} = __webpack_require__(182);
	const {getClientCssProperties} = __webpack_require__(16);

	/**
	 * Here is what this file (+ css-parsing-utils.js) do.
	 *
	 * The main objective here is to provide as much suggestions to the user editing
	 * a stylesheet in Style Editor. The possible things that can be suggested are:
	 *  - CSS property names
	 *  - CSS property values
	 *  - CSS Selectors
	 *  - Some other known CSS keywords
	 *
	 * Gecko provides a list of both property names and their corresponding values.
	 * We take out a list of matching selectors using the Inspector actor's
	 * `getSuggestionsForQuery` method. Now the only thing is to parse the CSS being
	 * edited by the user, figure out what token or word is being written and last
	 * but the most difficult, what is being edited.
	 *
	 * The file 'css-parsing-utils' helps to convert the CSS into meaningful tokens,
	 * each having a certain type associated with it. These tokens help us to figure
	 * out the currently edited word and to write a CSS state machine to figure out
	 * what the user is currently editing. By that, I mean, whether he is editing a
	 * selector or a property or a value, or even fine grained information like an
	 * id in the selector.
	 *
	 * The `resolveState` method iterated over the tokens spitted out by the
	 * tokenizer, using switch cases, follows a state machine logic and finally
	 * figures out these informations:
	 *  - The state of the CSS at the cursor (one out of CSS_STATES)
	 *  - The current token that is being edited `cmpleting`
	 *  - If the state is "selector", the selector state (one of SELECTOR_STATES)
	 *  - If the state is "selector", the current selector till the cursor
	 *  - If the state is "value", the corresponding property name
	 *
	 * In case of "value" and "property" states, we simply use the information
	 * provided by Gecko to filter out the possible suggestions.
	 * For "selector" state, we request the Inspector actor to query the page DOM
	 * and filter out the possible suggestions.
	 * For "media" and "keyframes" state, the only possible suggestions for now are
	 * "media" and "keyframes" respectively, although "media" can have suggestions
	 * like "max-width", "orientation" etc. Similarly "value" state can also have
	 * much better logical suggestions if we fine grain identify a sub state just
	 * like we do for the "selector" state.
	 */

	// Autocompletion types.

	/* eslint-disable no-inline-comments */
	const CSS_STATES = {
	  "null": "null",
	  property: "property",    // foo { bar|: … }
	  value: "value",          // foo {bar: baz|}
	  selector: "selector",    // f| {bar: baz}
	  media: "media",          // @med| , or , @media scr| { }
	  keyframes: "keyframes",  // @keyf|
	  frame: "frame",          // @keyframs foobar { t|
	};

	const SELECTOR_STATES = {
	  "null": "null",
	  id: "id",                // #f|
	  class: "class",          // #foo.b|
	  tag: "tag",              // fo|
	  pseudo: "pseudo",        // foo:|
	  attribute: "attribute",  // foo[b|
	  value: "value",          // foo[bar=b|
	};
	/* eslint-enable no-inline-comments */

	/**
	 * Constructor for the autocompletion object.
	 *
	 * @param options {Object} An options object containing the following options:
	 *        - walker {Object} The object used for query selecting from the current
	 *                 target's DOM.
	 *        - maxEntries {Number} Maximum selectors suggestions to display.
	 *        - cssProperties {Object} The database of CSS properties.
	 */
	function CSSCompleter(options = {}) {
	  this.walker = options.walker;
	  this.maxEntries = options.maxEntries || 15;
	  // If no css properties database is passed in, default to the client list.
	  this.cssProperties = options.cssProperties || getClientCssProperties();

	  this.propertyNames = this.cssProperties.getNames().sort();

	  // Array containing the [line, ch, scopeStack] for the locations where the
	  // CSS state is "null"
	  this.nullStates = [];
	}

	CSSCompleter.prototype = {

	  /**
	   * Returns a list of suggestions based on the caret position.
	   *
	   * @param source {String} String of the source code.
	   * @param caret {Object} Cursor location with line and ch properties.
	   *
	   * @returns [{object}] A sorted list of objects containing the following
	   *          peroperties:
	   *          - label {String} Full keyword for the suggestion
	   *          - preLabel {String} Already entered part of the label
	   */
	  complete: function (source, caret) {
	    // Getting the context from the caret position.
	    if (!this.resolveState(source, caret)) {
	      // We couldn't resolve the context, we won't be able to complete.
	      return Promise.resolve([]);
	    }

	    // Properly suggest based on the state.
	    switch (this.state) {
	      case CSS_STATES.property:
	        return this.completeProperties(this.completing);

	      case CSS_STATES.value:
	        return this.completeValues(this.propertyName, this.completing);

	      case CSS_STATES.selector:
	        return this.suggestSelectors();

	      case CSS_STATES.media:
	      case CSS_STATES.keyframes:
	        if ("media".startsWith(this.completing)) {
	          return Promise.resolve([{
	            label: "media",
	            preLabel: this.completing,
	            text: "media"
	          }]);
	        } else if ("keyframes".startsWith(this.completing)) {
	          return Promise.resolve([{
	            label: "keyframes",
	            preLabel: this.completing,
	            text: "keyframes"
	          }]);
	        }
	    }
	    return Promise.resolve([]);
	  },

	  /**
	   * Resolves the state of CSS at the cursor location. This method implements a
	   * custom written CSS state machine. The various switch statements provide the
	   * transition rules for the state. It also finds out various informatino about
	   * the nearby CSS like the property name being completed, the complete
	   * selector, etc.
	   *
	   * @param source {String} String of the source code.
	   * @param caret {Object} Cursor location with line and ch properties.
	   *
	   * @returns CSS_STATE
	   *          One of CSS_STATE enum or null if the state cannot be resolved.
	   */
	  resolveState: function (source, {line, ch}) {
	    // Function to return the last element of an array
	    let peek = arr => arr[arr.length - 1];
	    // _state can be one of CSS_STATES;
	    let _state = CSS_STATES.null;
	    let selector = "";
	    let selectorState = SELECTOR_STATES.null;
	    let propertyName = null;
	    let scopeStack = [];
	    let selectors = [];

	    // Fetch the closest null state line, ch from cached null state locations
	    let matchedStateIndex = this.findNearestNullState(line);
	    if (matchedStateIndex > -1) {
	      let state = this.nullStates[matchedStateIndex];
	      line -= state[0];
	      if (line == 0) {
	        ch -= state[1];
	      }
	      source = source.split("\n").slice(state[0]);
	      source[0] = source[0].slice(state[1]);
	      source = source.join("\n");
	      scopeStack = [...state[2]];
	      this.nullStates.length = matchedStateIndex + 1;
	    } else {
	      this.nullStates = [];
	    }
	    let tokens = cssTokenizerWithLineColumn(source);
	    let tokIndex = tokens.length - 1;
	    if (tokIndex >= 0 &&
	        (tokens[tokIndex].loc.end.line < line ||
	         (tokens[tokIndex].loc.end.line === line &&
	          tokens[tokIndex].loc.end.column < ch))) {
	      // If the last token ends before the cursor location, we didn't
	      // tokenize it correctly.  This special case can happen if the
	      // final token is a comment.
	      return null;
	    }

	    let cursor = 0;
	    // This will maintain a stack of paired elements like { & }, @m & }, : & ;
	    // etc
	    let token = null;
	    let selectorBeforeNot = null;
	    while (cursor <= tokIndex && (token = tokens[cursor++])) {
	      switch (_state) {
	        case CSS_STATES.property:
	          // From CSS_STATES.property, we can either go to CSS_STATES.value
	          // state when we hit the first ':' or CSS_STATES.selector if "}" is
	          // reached.
	          if (token.tokenType === "symbol") {
	            switch (token.text) {
	              case ":":
	                scopeStack.push(":");
	                if (tokens[cursor - 2].tokenType != "whitespace") {
	                  propertyName = tokens[cursor - 2].text;
	                } else {
	                  propertyName = tokens[cursor - 3].text;
	                }
	                _state = CSS_STATES.value;
	                break;

	              case "}":
	                if (/[{f]/.test(peek(scopeStack))) {
	                  let popped = scopeStack.pop();
	                  if (popped == "f") {
	                    _state = CSS_STATES.frame;
	                  } else {
	                    selector = "";
	                    selectors = [];
	                    _state = CSS_STATES.null;
	                  }
	                }
	                break;
	            }
	          }
	          break;

	        case CSS_STATES.value:
	          // From CSS_STATES.value, we can go to one of CSS_STATES.property,
	          // CSS_STATES.frame, CSS_STATES.selector and CSS_STATES.null
	          if (token.tokenType === "symbol") {
	            switch (token.text) {
	              case ";":
	                if (/[:]/.test(peek(scopeStack))) {
	                  scopeStack.pop();
	                  _state = CSS_STATES.property;
	                }
	                break;

	              case "}":
	                if (peek(scopeStack) == ":") {
	                  scopeStack.pop();
	                }

	                if (/[{f]/.test(peek(scopeStack))) {
	                  let popped = scopeStack.pop();
	                  if (popped == "f") {
	                    _state = CSS_STATES.frame;
	                  } else {
	                    selector = "";
	                    selectors = [];
	                    _state = CSS_STATES.null;
	                  }
	                }
	                break;
	            }
	          }
	          break;

	        case CSS_STATES.selector:
	          // From CSS_STATES.selector, we can only go to CSS_STATES.property
	          // when we hit "{"
	          if (token.tokenType === "symbol" && token.text == "{") {
	            scopeStack.push("{");
	            _state = CSS_STATES.property;
	            selectors.push(selector);
	            selector = "";
	            break;
	          }

	          switch (selectorState) {
	            case SELECTOR_STATES.id:
	            case SELECTOR_STATES.class:
	            case SELECTOR_STATES.tag:
	              switch (token.tokenType) {
	                case "hash":
	                case "id":
	                  selectorState = SELECTOR_STATES.id;
	                  selector += "#" + token.text;
	                  break;

	                case "symbol":
	                  if (token.text == ".") {
	                    selectorState = SELECTOR_STATES.class;
	                    selector += ".";
	                    if (cursor <= tokIndex &&
	                        tokens[cursor].tokenType == "ident") {
	                      token = tokens[cursor++];
	                      selector += token.text;
	                    }
	                  } else if (token.text == "#") {
	                    selectorState = SELECTOR_STATES.id;
	                    selector += "#";
	                  } else if (/[>~+]/.test(token.text)) {
	                    selectorState = SELECTOR_STATES.null;
	                    selector += token.text;
	                  } else if (token.text == ",") {
	                    selectorState = SELECTOR_STATES.null;
	                    selectors.push(selector);
	                    selector = "";
	                  } else if (token.text == ":") {
	                    selectorState = SELECTOR_STATES.pseudo;
	                    selector += ":";
	                    if (cursor > tokIndex) {
	                      break;
	                    }

	                    token = tokens[cursor++];
	                    switch (token.tokenType) {
	                      case "function":
	                        if (token.text == "not") {
	                          selectorBeforeNot = selector;
	                          selector = "";
	                          scopeStack.push("(");
	                        } else {
	                          selector += token.text + "(";
	                        }
	                        selectorState = SELECTOR_STATES.null;
	                        break;

	                      case "ident":
	                        selector += token.text;
	                        break;
	                    }
	                  } else if (token.text == "[") {
	                    selectorState = SELECTOR_STATES.attribute;
	                    scopeStack.push("[");
	                    selector += "[";
	                  } else if (token.text == ")") {
	                    if (peek(scopeStack) == "(") {
	                      scopeStack.pop();
	                      selector = selectorBeforeNot + "not(" + selector + ")";
	                      selectorBeforeNot = null;
	                    } else {
	                      selector += ")";
	                    }
	                    selectorState = SELECTOR_STATES.null;
	                  }
	                  break;

	                case "whitespace":
	                  selectorState = SELECTOR_STATES.null;
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.null:
	              // From SELECTOR_STATES.null state, we can go to one of
	              // SELECTOR_STATES.id, SELECTOR_STATES.class or
	              // SELECTOR_STATES.tag
	              switch (token.tokenType) {
	                case "hash":
	                case "id":
	                  selectorState = SELECTOR_STATES.id;
	                  selector += "#" + token.text;
	                  break;

	                case "ident":
	                  selectorState = SELECTOR_STATES.tag;
	                  selector += token.text;
	                  break;

	                case "symbol":
	                  if (token.text == ".") {
	                    selectorState = SELECTOR_STATES.class;
	                    selector += ".";
	                    if (cursor <= tokIndex &&
	                        tokens[cursor].tokenType == "ident") {
	                      token = tokens[cursor++];
	                      selector += token.text;
	                    }
	                  } else if (token.text == "#") {
	                    selectorState = SELECTOR_STATES.id;
	                    selector += "#";
	                  } else if (token.text == "*") {
	                    selectorState = SELECTOR_STATES.tag;
	                    selector += "*";
	                  } else if (/[>~+]/.test(token.text)) {
	                    selector += token.text;
	                  } else if (token.text == ",") {
	                    selectorState = SELECTOR_STATES.null;
	                    selectors.push(selector);
	                    selector = "";
	                  } else if (token.text == ":") {
	                    selectorState = SELECTOR_STATES.pseudo;
	                    selector += ":";
	                    if (cursor > tokIndex) {
	                      break;
	                    }

	                    token = tokens[cursor++];
	                    switch (token.tokenType) {
	                      case "function":
	                        if (token.text == "not") {
	                          selectorBeforeNot = selector;
	                          selector = "";
	                          scopeStack.push("(");
	                        } else {
	                          selector += token.text + "(";
	                        }
	                        selectorState = SELECTOR_STATES.null;
	                        break;

	                      case "ident":
	                        selector += token.text;
	                        break;
	                    }
	                  } else if (token.text == "[") {
	                    selectorState = SELECTOR_STATES.attribute;
	                    scopeStack.push("[");
	                    selector += "[";
	                  } else if (token.text == ")") {
	                    if (peek(scopeStack) == "(") {
	                      scopeStack.pop();
	                      selector = selectorBeforeNot + "not(" + selector + ")";
	                      selectorBeforeNot = null;
	                    } else {
	                      selector += ")";
	                    }
	                    selectorState = SELECTOR_STATES.null;
	                  }
	                  break;

	                case "whitespace":
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.pseudo:
	              switch (token.tokenType) {
	                case "symbol":
	                  if (/[>~+]/.test(token.text)) {
	                    selectorState = SELECTOR_STATES.null;
	                    selector += token.text;
	                  } else if (token.text == ",") {
	                    selectorState = SELECTOR_STATES.null;
	                    selectors.push(selector);
	                    selector = "";
	                  } else if (token.text == ":") {
	                    selectorState = SELECTOR_STATES.pseudo;
	                    selector += ":";
	                    if (cursor > tokIndex) {
	                      break;
	                    }

	                    token = tokens[cursor++];
	                    switch (token.tokenType) {
	                      case "function":
	                        if (token.text == "not") {
	                          selectorBeforeNot = selector;
	                          selector = "";
	                          scopeStack.push("(");
	                        } else {
	                          selector += token.text + "(";
	                        }
	                        selectorState = SELECTOR_STATES.null;
	                        break;

	                      case "ident":
	                        selector += token.text;
	                        break;
	                    }
	                  } else if (token.text == "[") {
	                    selectorState = SELECTOR_STATES.attribute;
	                    scopeStack.push("[");
	                    selector += "[";
	                  }
	                  break;

	                case "whitespace":
	                  selectorState = SELECTOR_STATES.null;
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.attribute:
	              switch (token.tokenType) {
	                case "symbol":
	                  if (/[~|^$*]/.test(token.text)) {
	                    selector += token.text;
	                    token = tokens[cursor++];
	                  } else if (token.text == "=") {
	                    selectorState = SELECTOR_STATES.value;
	                    selector += token.text;
	                  } else if (token.text == "]") {
	                    if (peek(scopeStack) == "[") {
	                      scopeStack.pop();
	                    }

	                    selectorState = SELECTOR_STATES.null;
	                    selector += "]";
	                  }
	                  break;

	                case "ident":
	                case "string":
	                  selector += token.text;
	                  break;

	                case "whitespace":
	                  selector && (selector += " ");
	                  break;
	              }
	              break;

	            case SELECTOR_STATES.value:
	              switch (token.tokenType) {
	                case "string":
	                case "ident":
	                  selector += token.text;
	                  break;

	                case "symbol":
	                  if (token.text == "]") {
	                    if (peek(scopeStack) == "[") {
	                      scopeStack.pop();
	                    }

	                    selectorState = SELECTOR_STATES.null;
	                    selector += "]";
	                  }
	                  break;

	                case "whitespace":
	                  selector && (selector += " ");
	                  break;
	              }
	              break;
	          }
	          break;

	        case CSS_STATES.null:
	          // From CSS_STATES.null state, we can go to either CSS_STATES.media or
	          // CSS_STATES.selector.
	          switch (token.tokenType) {
	            case "hash":
	            case "id":
	              selectorState = SELECTOR_STATES.id;
	              selector = "#" + token.text;
	              _state = CSS_STATES.selector;
	              break;

	            case "ident":
	              selectorState = SELECTOR_STATES.tag;
	              selector = token.text;
	              _state = CSS_STATES.selector;
	              break;

	            case "symbol":
	              if (token.text == ".") {
	                selectorState = SELECTOR_STATES.class;
	                selector = ".";
	                _state = CSS_STATES.selector;
	                if (cursor <= tokIndex &&
	                    tokens[cursor].tokenType == "ident") {
	                  token = tokens[cursor++];
	                  selector += token.text;
	                }
	              } else if (token.text == "#") {
	                selectorState = SELECTOR_STATES.id;
	                selector = "#";
	                _state = CSS_STATES.selector;
	              } else if (token.text == "*") {
	                selectorState = SELECTOR_STATES.tag;
	                selector = "*";
	                _state = CSS_STATES.selector;
	              } else if (token.text == ":") {
	                _state = CSS_STATES.selector;
	                selectorState = SELECTOR_STATES.pseudo;
	                selector += ":";
	                if (cursor > tokIndex) {
	                  break;
	                }

	                token = tokens[cursor++];
	                switch (token.tokenType) {
	                  case "function":
	                    if (token.text == "not") {
	                      selectorBeforeNot = selector;
	                      selector = "";
	                      scopeStack.push("(");
	                    } else {
	                      selector += token.text + "(";
	                    }
	                    selectorState = SELECTOR_STATES.null;
	                    break;

	                  case "ident":
	                    selector += token.text;
	                    break;
	                }
	              } else if (token.text == "[") {
	                _state = CSS_STATES.selector;
	                selectorState = SELECTOR_STATES.attribute;
	                scopeStack.push("[");
	                selector += "[";
	              } else if (token.text == "}") {
	                if (peek(scopeStack) == "@m") {
	                  scopeStack.pop();
	                }
	              }
	              break;

	            case "at":
	              _state = token.text.startsWith("m") ? CSS_STATES.media
	                                                   : CSS_STATES.keyframes;
	              break;
	          }
	          break;

	        case CSS_STATES.media:
	          // From CSS_STATES.media, we can only go to CSS_STATES.null state when
	          // we hit the first '{'
	          if (token.tokenType == "symbol" && token.text == "{") {
	            scopeStack.push("@m");
	            _state = CSS_STATES.null;
	          }
	          break;

	        case CSS_STATES.keyframes:
	          // From CSS_STATES.keyframes, we can only go to CSS_STATES.frame state
	          // when we hit the first '{'
	          if (token.tokenType == "symbol" && token.text == "{") {
	            scopeStack.push("@k");
	            _state = CSS_STATES.frame;
	          }
	          break;

	        case CSS_STATES.frame:
	          // From CSS_STATES.frame, we can either go to CSS_STATES.property
	          // state when we hit the first '{' or to CSS_STATES.selector when we
	          // hit '}'
	          if (token.tokenType == "symbol") {
	            if (token.text == "{") {
	              scopeStack.push("f");
	              _state = CSS_STATES.property;
	            } else if (token.text == "}") {
	              if (peek(scopeStack) == "@k") {
	                scopeStack.pop();
	              }

	              _state = CSS_STATES.null;
	            }
	          }
	          break;
	      }
	      if (_state == CSS_STATES.null) {
	        if (this.nullStates.length == 0) {
	          this.nullStates.push([token.loc.end.line, token.loc.end.column,
	                                [...scopeStack]]);
	          continue;
	        }
	        let tokenLine = token.loc.end.line;
	        let tokenCh = token.loc.end.column;
	        if (tokenLine == 0) {
	          continue;
	        }
	        if (matchedStateIndex > -1) {
	          tokenLine += this.nullStates[matchedStateIndex][0];
	        }
	        this.nullStates.push([tokenLine, tokenCh, [...scopeStack]]);
	      }
	    }
	    this.state = _state;
	    this.propertyName = _state == CSS_STATES.value ? propertyName : null;
	    this.selectorState = _state == CSS_STATES.selector ? selectorState : null;
	    this.selectorBeforeNot = selectorBeforeNot == null ?
	                             null : selectorBeforeNot;
	    if (token) {
	      selector = selector.slice(0, selector.length + token.loc.end.column - ch);
	      this.selector = selector;
	    } else {
	      this.selector = "";
	    }
	    this.selectors = selectors;

	    if (token && token.tokenType != "whitespace") {
	      let text;
	      if (token.tokenType == "dimension" || !token.text) {
	        text = source.substring(token.startOffset, token.endOffset);
	      } else {
	        text = token.text;
	      }
	      this.completing = (text.slice(0, ch - token.loc.start.column)
	                         .replace(/^[.#]$/, ""));
	    } else {
	      this.completing = "";
	    }
	    // Special case the situation when the user just entered ":" after typing a
	    // property name.
	    if (this.completing == ":" && _state == CSS_STATES.value) {
	      this.completing = "";
	    }

	    // Special check for !important; case.
	    if (token && tokens[cursor - 2] && tokens[cursor - 2].text == "!" &&
	        this.completing == "important".slice(0, this.completing.length)) {
	      this.completing = "!" + this.completing;
	    }
	    return _state;
	  },

	  /**
	   * Queries the DOM Walker actor for suggestions regarding the selector being
	   * completed
	   */
	  suggestSelectors: function () {
	    let walker = this.walker;
	    if (!walker) {
	      return Promise.resolve([]);
	    }

	    let query = this.selector;
	    // Even though the selector matched atleast one node, there is still
	    // possibility of suggestions.
	    switch (this.selectorState) {
	      case SELECTOR_STATES.null:
	        if (this.completing === ",") {
	          return Promise.resolve([]);
	        }

	        query += "*";
	        break;

	      case SELECTOR_STATES.tag:
	        query = query.slice(0, query.length - this.completing.length);
	        break;

	      case SELECTOR_STATES.id:
	      case SELECTOR_STATES.class:
	      case SELECTOR_STATES.pseudo:
	        if (/^[.:#]$/.test(this.completing)) {
	          query = query.slice(0, query.length - this.completing.length);
	          this.completing = "";
	        } else {
	          query = query.slice(0, query.length - this.completing.length - 1);
	        }
	        break;
	    }

	    if (/[\s+>~]$/.test(query) &&
	        this.selectorState != SELECTOR_STATES.attribute &&
	        this.selectorState != SELECTOR_STATES.value) {
	      query += "*";
	    }

	    // Set the values that this request was supposed to suggest to.
	    this._currentQuery = query;
	    return walker.getSuggestionsForQuery(query, this.completing,
	                                         this.selectorState)
	                 .then(result => this.prepareSelectorResults(result));
	  },

	 /**
	  * Prepares the selector suggestions returned by the walker actor.
	  */
	  prepareSelectorResults: function (result) {
	    if (this._currentQuery != result.query) {
	      return [];
	    }

	    result = result.suggestions;
	    let query = this.selector;
	    let completion = [];
	    for (let [value, count, state] of result) {
	      switch (this.selectorState) {
	        case SELECTOR_STATES.id:
	        case SELECTOR_STATES.class:
	        case SELECTOR_STATES.pseudo:
	          if (/^[.:#]$/.test(this.completing)) {
	            value = query.slice(0, query.length - this.completing.length) +
	                       value;
	          } else {
	            value = query.slice(0, query.length - this.completing.length - 1) +
	                       value;
	          }
	          break;

	        case SELECTOR_STATES.tag:
	          value = query.slice(0, query.length - this.completing.length) +
	                    value;
	          break;

	        case SELECTOR_STATES.null:
	          value = query + value;
	          break;

	        default:
	          value = query.slice(0, query.length - this.completing.length) +
	                    value;
	      }

	      let item = {
	        label: value,
	        preLabel: query,
	        text: value,
	        score: count
	      };

	      // In case the query's state is tag and the item's state is id or class
	      // adjust the preLabel
	      if (this.selectorState === SELECTOR_STATES.tag &&
	          state === SELECTOR_STATES.class) {
	        item.preLabel = "." + item.preLabel;
	      }
	      if (this.selectorState === SELECTOR_STATES.tag &&
	          state === SELECTOR_STATES.id) {
	        item.preLabel = "#" + item.preLabel;
	      }

	      completion.push(item);

	      if (completion.length > this.maxEntries - 1) {
	        break;
	      }
	    }
	    return completion;
	  },

	  /**
	   * Returns CSS property name suggestions based on the input.
	   *
	   * @param startProp {String} Initial part of the property being completed.
	   */
	  completeProperties: function (startProp) {
	    let finalList = [];
	    if (!startProp) {
	      return Promise.resolve(finalList);
	    }

	    let length = this.propertyNames.length;
	    let i = 0, count = 0;
	    for (; i < length && count < this.maxEntries; i++) {
	      if (this.propertyNames[i].startsWith(startProp)) {
	        count++;
	        let propName = this.propertyNames[i];
	        finalList.push({
	          preLabel: startProp,
	          label: propName,
	          text: propName + ": "
	        });
	      } else if (this.propertyNames[i] > startProp) {
	        // We have crossed all possible matches alphabetically.
	        break;
	      }
	    }
	    return Promise.resolve(finalList);
	  },

	  /**
	   * Returns CSS value suggestions based on the corresponding property.
	   *
	   * @param propName {String} The property to which the value being completed
	   *        belongs.
	   * @param startValue {String} Initial part of the value being completed.
	   */
	  completeValues: function (propName, startValue) {
	    let finalList = [];
	    let list = ["!important;", ...this.cssProperties.getValues(propName)];
	    // If there is no character being completed, we are showing an initial list
	    // of possible values. Skipping '!important' in this case.
	    if (!startValue) {
	      list.splice(0, 1);
	    }

	    let length = list.length;
	    let i = 0, count = 0;
	    for (; i < length && count < this.maxEntries; i++) {
	      if (list[i].startsWith(startValue)) {
	        count++;
	        let value = list[i];
	        finalList.push({
	          preLabel: startValue,
	          label: value,
	          text: value
	        });
	      } else if (list[i] > startValue) {
	        // We have crossed all possible matches alphabetically.
	        break;
	      }
	    }
	    return Promise.resolve(finalList);
	  },

	  /**
	   * A biased binary search in a sorted array where the middle element is
	   * calculated based on the values at the lower and the upper index in each
	   * iteration.
	   *
	   * This method returns the index of the closest null state from the passed
	   * `line` argument. Once we have the closest null state, we can start applying
	   * the state machine logic from that location instead of the absolute starting
	   * of the CSS source. This speeds up the tokenizing and the state machine a
	   * lot while using autocompletion at high line numbers in a CSS source.
	   */
	  findNearestNullState: function (line) {
	    let arr = this.nullStates;
	    let high = arr.length - 1;
	    let low = 0;
	    let target = 0;

	    if (high < 0) {
	      return -1;
	    }
	    if (arr[high][0] <= line) {
	      return high;
	    }
	    if (arr[low][0] > line) {
	      return -1;
	    }

	    while (high > low) {
	      if (arr[low][0] <= line && arr[low [0] + 1] > line) {
	        return low;
	      }
	      if (arr[high][0] > line && arr[high - 1][0] <= line) {
	        return high - 1;
	      }

	      target = (((line - arr[low][0]) / (arr[high][0] - arr[low][0])) *
	                (high - low)) | 0;

	      if (arr[target][0] <= line && arr[target + 1][0] > line) {
	        return target;
	      } else if (line > arr[target][0]) {
	        low = target + 1;
	        high--;
	      } else {
	        high = target - 1;
	        low++;
	      }
	    }

	    return -1;
	  },

	  /**
	   * Invalidates the state cache for and above the line.
	   */
	  invalidateCache: function (line) {
	    this.nullStates.length = this.findNearestNullState(line) + 1;
	  },

	  /**
	   * Get the state information about a token surrounding the {line, ch} position
	   *
	   * @param {string} source
	   *        The complete source of the CSS file. Unlike resolve state method,
	   *        this method requires the full source.
	   * @param {object} caret
	   *        The line, ch position of the caret.
	   *
	   * @returns {object}
	   *          An object containing the state of token covered by the caret.
	   *          The object has following properties when the the state is
	   *          "selector", "value" or "property", null otherwise:
	   *           - state {string} one of CSS_STATES - "selector", "value" etc.
	   *           - selector {string} The selector at the caret when `state` is
	   *                      selector. OR
	   *           - selectors {[string]} Array of selector strings in case when
	   *                       `state` is "value" or "property"
	   *           - propertyName {string} The property name at the current caret or
	   *                          the property name corresponding to the value at
	   *                          the caret.
	   *           - value {string} The css value at the current caret.
	   *           - loc {object} An object containing the starting and the ending
	   *                 caret position of the whole selector, value or property.
	   *                  - { start: {line, ch}, end: {line, ch}}
	   */
	  getInfoAt: function (source, caret) {
	    // Limits the input source till the {line, ch} caret position
	    function limit(sourceArg, {line, ch}) {
	      line++;
	      let list = sourceArg.split("\n");
	      if (list.length < line) {
	        return sourceArg;
	      }
	      if (line == 1) {
	        return list[0].slice(0, ch);
	      }
	      return [...list.slice(0, line - 1),
	              list[line - 1].slice(0, ch)].join("\n");
	    }

	    // Get the state at the given line, ch
	    let state = this.resolveState(limit(source, caret), caret);
	    let propertyName = this.propertyName;
	    let {line, ch} = caret;
	    let sourceArray = source.split("\n");
	    let limitedSource = limit(source, caret);

	    /**
	     * Method to traverse forwards from the caret location to figure out the
	     * ending point of a selector or css value.
	     *
	     * @param {function} check
	     *        A method which takes the current state as an input and determines
	     *        whether the state changed or not.
	     */
	    let traverseForward = check => {
	      let location;
	      // Backward loop to determine the beginning location of the selector.
	      do {
	        let lineText = sourceArray[line];
	        if (line == caret.line) {
	          lineText = lineText.substring(caret.ch);
	        }

	        let prevToken = undefined;
	        let tokens = cssTokenizer(lineText);
	        let found = false;
	        let ech = line == caret.line ? caret.ch : 0;
	        for (let token of tokens) {
	          // If the line is completely spaces, handle it differently
	          if (lineText.trim() == "") {
	            limitedSource += lineText;
	          } else {
	            limitedSource += sourceArray[line]
	                              .substring(ech + token.startOffset,
	                                         ech + token.endOffset);
	          }

	          // Whitespace cannot change state.
	          if (token.tokenType == "whitespace") {
	            prevToken = token;
	            continue;
	          }

	          let forwState = this.resolveState(limitedSource, {
	            line: line,
	            ch: token.endOffset + ech
	          });
	          if (check(forwState)) {
	            if (prevToken && prevToken.tokenType == "whitespace") {
	              token = prevToken;
	            }
	            location = {
	              line: line,
	              ch: token.startOffset + ech
	            };
	            found = true;
	            break;
	          }
	          prevToken = token;
	        }
	        limitedSource += "\n";
	        if (found) {
	          break;
	        }
	      } while (line++ < sourceArray.length);
	      return location;
	    };

	    /**
	     * Method to traverse backwards from the caret location to figure out the
	     * starting point of a selector or css value.
	     *
	     * @param {function} check
	     *        A method which takes the current state as an input and determines
	     *        whether the state changed or not.
	     * @param {boolean} isValue
	     *        true if the traversal is being done for a css value state.
	     */
	    let traverseBackwards = (check, isValue) => {
	      let location;
	      // Backward loop to determine the beginning location of the selector.
	      do {
	        let lineText = sourceArray[line];
	        if (line == caret.line) {
	          lineText = lineText.substring(0, caret.ch);
	        }

	        let tokens = Array.from(cssTokenizer(lineText));
	        let found = false;
	        for (let i = tokens.length - 1; i >= 0; i--) {
	          let token = tokens[i];
	          // If the line is completely spaces, handle it differently
	          if (lineText.trim() == "") {
	            limitedSource = limitedSource.slice(0, -1 * lineText.length);
	          } else {
	            let length = token.endOffset - token.startOffset;
	            limitedSource = limitedSource.slice(0, -1 * length);
	          }

	          // Whitespace cannot change state.
	          if (token.tokenType == "whitespace") {
	            continue;
	          }

	          let backState = this.resolveState(limitedSource, {
	            line: line,
	            ch: token.startOffset
	          });
	          if (check(backState)) {
	            if (tokens[i + 1] && tokens[i + 1].tokenType == "whitespace") {
	              token = tokens[i + 1];
	            }
	            location = {
	              line: line,
	              ch: isValue ? token.endOffset : token.startOffset
	            };
	            found = true;
	            break;
	          }
	        }
	        limitedSource = limitedSource.slice(0, -1);
	        if (found) {
	          break;
	        }
	      } while (line-- >= 0);
	      return location;
	    };

	    if (state == CSS_STATES.selector) {
	      // For selector state, the ending and starting point of the selector is
	      // either when the state changes or the selector becomes empty and a
	      // single selector can span multiple lines.
	      // Backward loop to determine the beginning location of the selector.
	      let start = traverseBackwards(backState => {
	        return (backState != CSS_STATES.selector ||
	               (this.selector == "" && this.selectorBeforeNot == null));
	      });

	      line = caret.line;
	      limitedSource = limit(source, caret);
	      // Forward loop to determine the ending location of the selector.
	      let end = traverseForward(forwState => {
	        return (forwState != CSS_STATES.selector ||
	               (this.selector == "" && this.selectorBeforeNot == null));
	      });

	      // Since we have start and end positions, figure out the whole selector.
	      let selector = source.split("\n").slice(start.line, end.line + 1);
	      selector[selector.length - 1] =
	        selector[selector.length - 1].substring(0, end.ch);
	      selector[0] = selector[0].substring(start.ch);
	      selector = selector.join("\n");
	      return {
	        state: state,
	        selector: selector,
	        loc: {
	          start: start,
	          end: end
	        }
	      };
	    } else if (state == CSS_STATES.property) {
	      // A property can only be a single word and thus very easy to calculate.
	      let tokens = cssTokenizer(sourceArray[line]);
	      for (let token of tokens) {
	        // Note that, because we're tokenizing a single line, the
	        // token's offset is also the column number.
	        if (token.startOffset <= ch && token.endOffset >= ch) {
	          return {
	            state: state,
	            propertyName: token.text,
	            selectors: this.selectors,
	            loc: {
	              start: {
	                line: line,
	                ch: token.startOffset
	              },
	              end: {
	                line: line,
	                ch: token.endOffset
	              }
	            }
	          };
	        }
	      }
	    } else if (state == CSS_STATES.value) {
	      // CSS value can be multiline too, so we go forward and backwards to
	      // determine the bounds of the value at caret
	      let start = traverseBackwards(backState => backState != CSS_STATES.value, true);

	      line = caret.line;
	      limitedSource = limit(source, caret);
	      let end = traverseForward(forwState => forwState != CSS_STATES.value);

	      let value = source.split("\n").slice(start.line, end.line + 1);
	      value[value.length - 1] = value[value.length - 1].substring(0, end.ch);
	      value[0] = value[0].substring(start.ch);
	      value = value.join("\n");
	      return {
	        state: state,
	        propertyName: propertyName,
	        selectors: this.selectors,
	        value: value,
	        loc: {
	          start: start,
	          end: end
	        }
	      };
	    }
	    return null;
	  }
	};

	module.exports = CSSCompleter;


/***/ },
/* 222 */
/***/ function(module, exports) {

	module.exports = {
	  "!name": "browser",
	  "location": {
	    "assign": {
	      "!type": "fn(url: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "Load the document at the provided URL."
	    },
	    "replace": {
	      "!type": "fn(url: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "Replace the current document with the one at the provided URL. The difference from the assign() method is that after using replace() the current page will not be saved in session history, meaning the user won't be able to use the Back button to navigate to it."
	    },
	    "reload": {
	      "!type": "fn()",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "Reload the document from the current URL. forceget is a boolean, which, when it is true, causes the page to always be reloaded from the server. If it is false or not specified, the browser may reload the page from its cache."
	    },
	    "origin": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The origin of the URL."
	    },
	    "hash": {
	      "!type": "string",
	      "!url": "https://developer.mthat follows the # symbol, including the # symbol."
	    },
	    "search": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The part of the URL that follows the ? symbol, including the ? symbol."
	    },
	    "pathname": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The path (relative to the host)."
	    },
	    "port": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The port number of the URL."
	    },
	    "hostname": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The host name (without the port number or square brackets)."
	    },
	    "host": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The host name and port number."
	    },
	    "protocol": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The protocol of the URL."
	    },
	    "href": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	      "!doc": "The entire URL."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.location",
	    "!doc": "Returns a location object with information about the current location of the document. Assigning to the location property changes the current page to the new address."
	  },
	  "Node": {
	    "!type": "fn()",
	    "prototype": {
	      "parentElement": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.parentElement",
	        "!doc": "Returns the DOM node's parent Element, or null if the node either has no parent, or its parent isn't a DOM Element."
	      },
	      "textContent": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.textContent",
	        "!doc": "Gets or sets the text content of a node and its descendants."
	      },
	      "baseURI": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.baseURI",
	        "!doc": "The absolute base URI of a node or null if unable to obtain an absolute URI."
	      },
	      "localName": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.localName",
	        "!doc": "Returns the local part of the qualified name of this node."
	      },
	      "prefix": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.prefix",
	        "!doc": "Returns the namespace prefix of the specified node, or null if no prefix is specified. This property is read only."
	      },
	      "namespaceURI": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.namespaceURI",
	        "!doc": "The namespace URI of the node, or null if the node is not in a namespace (read-only). When the node is a document, it returns the XML namespace for the current document."
	      },
	      "ownerDocument": {
	        "!type": "+Document",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.ownerDocument",
	        "!doc": "The ownerDocument property returns the top-level document object for this node."
	      },
	      "attributes": {
	        "!type": "+NamedNodeMap",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.attributes",
	        "!doc": "A collection of all attribute nodes registered to the specified node. It is a NamedNodeMap,not an Array, so it has no Array methods and the Attr nodes' indexes may differ among browsers."
	      },
	      "nextSibling": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nextSibling",
	        "!doc": "Returns the node immediately following the specified one in its parent's childNodes list, or null if the specified node is the last node in that list."
	      },
	      "previousSibling": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.previousSibling",
	        "!doc": "Returns the node immediately preceding the specified one in its parent's childNodes list, null if the specified node is the first in that list."
	      },
	      "lastChild": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.lastChild",
	        "!doc": "Returns the last child of a node."
	      },
	      "firstChild": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.firstChild",
	        "!doc": "Returns the node's first child in the tree, or null if the node is childless. If the node is a Document, it returns the first node in the list of its direct children."
	      },
	      "childNodes": {
	        "!type": "+NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.childNodes",
	        "!doc": "Returns a collection of child nodes of the given element."
	      },
	      "parentNode": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.parentNode",
	        "!doc": "Returns the parent of the specified node in the DOM tree."
	      },
	      "nodeType": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeType",
	        "!doc": "Returns an integer code representing the type of the node."
	      },
	      "nodeValue": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeValue",
	        "!doc": "Returns or sets the value of the current node."
	      },
	      "nodeName": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeName",
	        "!doc": "Returns the name of the current node as a string."
	      },
	      "tagName": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.nodeName",
	        "!doc": "Returns the name of the current node as a string."
	      },
	      "insertBefore": {
	        "!type": "fn(newElt: +Element, before: +Element) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.insertBefore",
	        "!doc": "Inserts the specified node before a reference element as a child of the current node."
	      },
	      "replaceChild": {
	        "!type": "fn(newElt: +Element, oldElt: +Element) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.replaceChild",
	        "!doc": "Replaces one child node of the specified element with another."
	      },
	      "removeChild": {
	        "!type": "fn(oldElt: +Element) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.removeChild",
	        "!doc": "Removes a child node from the DOM. Returns removed node."
	      },
	      "appendChild": {
	        "!type": "fn(newElt: +Element) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.appendChild",
	        "!doc": "Adds a node to the end of the list of children of a specified parent node. If the node already exists it is removed from current parent node, then added to new parent node."
	      },
	      "hasChildNodes": {
	        "!type": "fn() -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.hasChildNodes",
	        "!doc": "Returns a Boolean value indicating whether the current Node has child nodes or not."
	      },
	      "cloneNode": {
	        "!type": "fn(deep: bool) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.cloneNode",
	        "!doc": "Returns a duplicate of the node on which this method was called."
	      },
	      "normalize": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.normalize",
	        "!doc": "Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized subtree, no text nodes in the subtree are empty and there are no adjacent text nodes."
	      },
	      "isSupported": {
	        "!type": "fn(features: string, version: number) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isSupported",
	        "!doc": "Tests whether the DOM implementation implements a specific feature and that feature is supported by this node."
	      },
	      "hasAttributes": {
	        "!type": "fn() -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.hasAttributes",
	        "!doc": "Returns a boolean value of true or false, indicating if the current element has any attributes or not."
	      },
	      "lookupPrefix": {
	        "!type": "fn(uri: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.lookupPrefix",
	        "!doc": "Returns the prefix for a given namespaceURI if present, and null if not. When multiple prefixes are possible, the result is implementation-dependent."
	      },
	      "isDefaultNamespace": {
	        "!type": "fn(uri: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isDefaultNamespace",
	        "!doc": "Accepts a namespace URI as an argument and returns true if the namespace is the default namespace on the given node or false if not."
	      },
	      "lookupNamespaceURI": {
	        "!type": "fn(uri: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.lookupNamespaceURI",
	        "!doc": "Takes a prefix and returns the namespaceURI associated with it on the given node if found (and null if not). Supplying null for the prefix will return the default namespace."
	      },
	      "addEventListener": {
	        "!type": "fn(type: string, listener: fn(e: +Event), capture: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.addEventListener",
	        "!doc": "Registers a single event listener on a single target. The event target may be a single element in a document, the document itself, a window, or an XMLHttpRequest."
	      },
	      "removeEventListener": {
	        "!type": "fn(type: string, listener: fn(), capture: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.removeEventListener",
	        "!doc": "Allows the removal of event listeners from the event target."
	      },
	      "isSameNode": {
	        "!type": "fn(other: +Node) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isSameNode",
	        "!doc": "Tests whether two nodes are the same, that is they reference the same object."
	      },
	      "isEqualNode": {
	        "!type": "fn(other: +Node) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.isEqualNode",
	        "!doc": "Tests whether two nodes are equal."
	      },
	      "compareDocumentPosition": {
	        "!type": "fn(other: +Node) -> number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.compareDocumentPosition",
	        "!doc": "Compares the position of the current node against another node in any other document."
	      },
	      "contains": {
	        "!type": "fn(other: +Node) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Node.contains",
	        "!doc": "Indicates whether a node is a descendent of a given node."
	      },
	      "dispatchEvent": {
	        "!type": "fn(event: +Event) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.dispatchEvent",
	        "!doc": "Dispatches an event into the event system. The event is subject to the same capturing and bubbling behavior as directly dispatched events."
	      },
	      "ELEMENT_NODE": "number",
	      "ATTRIBUTE_NODE": "number",
	      "TEXT_NODE": "number",
	      "CDATA_SECTION_NODE": "number",
	      "ENTITY_REFERENCE_NODE": "number",
	      "ENTITY_NODE": "number",
	      "PROCESSING_INSTRUCTION_NODE": "number",
	      "COMMENT_NODE": "number",
	      "DOCUMENT_NODE": "number",
	      "DOCUMENT_TYPE_NODE": "number",
	      "DOCUMENT_FRAGMENT_NODE": "number",
	      "NOTATION_NODE": "number",
	      "DOCUMENT_POSITION_DISCONNECTED": "number",
	      "DOCUMENT_POSITION_PRECEDING": "number",
	      "DOCUMENT_POSITION_FOLLOWING": "number",
	      "DOCUMENT_POSITION_CONTAINS": "number",
	      "DOCUMENT_POSITION_CONTAINED_BY": "number",
	      "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Node",
	    "!doc": "A Node is an interface from which a number of DOM types inherit, and allows these various types to be treated (or tested) similarly."
	  },
	  "Element": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Node.prototype",
	      "getAttribute": {
	        "!type": "fn(name: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttribute",
	        "!doc": "Returns the value of the named attribute on the specified element. If the named attribute does not exist, the value returned will either be null or \"\" (the empty string)."
	      },
	      "setAttribute": {
	        "!type": "fn(name: string, value: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttribute",
	        "!doc": "Adds a new attribute or changes the value of an existing attribute on the specified element."
	      },
	      "removeAttribute": {
	        "!type": "fn(name: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.removeAttribute",
	        "!doc": "Removes an attribute from the specified element."
	      },
	      "getAttributeNode": {
	        "!type": "fn(name: string) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttributeNode",
	        "!doc": "Returns the specified attribute of the specified element, as an Attr node."
	      },
	      "getElementsByTagName": {
	        "!type": "fn(tagName: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getElementsByTagName",
	        "!doc": "Returns a list of elements with the given tag name. The subtree underneath the specified element is searched, excluding the element itself. The returned list is live, meaning that it updates itself with the DOM tree automatically. Consequently, there is no need to call several times element.getElementsByTagName with the same element and arguments."
	      },
	      "getElementsByTagNameNS": {
	        "!type": "fn(ns: string, tagName: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getElementsByTagNameNS",
	        "!doc": "Returns a list of elements with the given tag name belonging to the given namespace."
	      },
	      "getAttributeNS": {
	        "!type": "fn(ns: string, name: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttributeNS",
	        "!doc": "Returns the string value of the attribute with the specified namespace and name. If the named attribute does not exist, the value returned will either be null or \"\" (the empty string)."
	      },
	      "setAttributeNS": {
	        "!type": "fn(ns: string, name: string, value: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttributeNS",
	        "!doc": "Adds a new attribute or changes the value of an attribute with the given namespace and name."
	      },
	      "removeAttributeNS": {
	        "!type": "fn(ns: string, name: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.removeAttributeNS",
	        "!doc": "removeAttributeNS removes the specified attribute from an element."
	      },
	      "getAttributeNodeNS": {
	        "!type": "fn(ns: string, name: string) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getAttributeNodeNS",
	        "!doc": "Returns the Attr node for the attribute with the given namespace and name."
	      },
	      "hasAttribute": {
	        "!type": "fn(name: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.hasAttribute",
	        "!doc": "hasAttribute returns a boolean value indicating whether the specified element has the specified attribute or not."
	      },
	      "hasAttributeNS": {
	        "!type": "fn(ns: string, name: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.hasAttributeNS",
	        "!doc": "hasAttributeNS returns a boolean value indicating whether the current element has the specified attribute."
	      },
	      "focus": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.focus",
	        "!doc": "Sets focus on the specified element, if it can be focused."
	      },
	      "blur": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.blur",
	        "!doc": "The blur method removes keyboard focus from the current element."
	      },
	      "scrollIntoView": {
	        "!type": "fn(top: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollIntoView",
	        "!doc": "The scrollIntoView() method scrolls the element into view."
	      },
	      "scrollByLines": {
	        "!type": "fn(lines: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollByLines",
	        "!doc": "Scrolls the document by the given number of lines."
	      },
	      "scrollByPages": {
	        "!type": "fn(pages: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollByPages",
	        "!doc": "Scrolls the current document by the specified number of pages."
	      },
	      "getElementsByClassName": {
	        "!type": "fn(name: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByClassName",
	        "!doc": "Returns a set of elements which have all the given class names. When called on the document object, the complete document is searched, including the root node. You may also call getElementsByClassName on any element; it will return only elements which are descendants of the specified root element with the given class names."
	      },
	      "querySelector": {
	        "!type": "fn(selectors: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.querySelector",
	        "!doc": "Returns the first element that is a descendent of the element on which it is invoked that matches the specified group of selectors."
	      },
	      "querySelectorAll": {
	        "!type": "fn(selectors: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.querySelectorAll",
	        "!doc": "Returns a non-live NodeList of all elements descended from the element on which it is invoked that match the specified group of CSS selectors."
	      },
	      "getClientRects": {
	        "!type": "fn() -> [+ClientRect]",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Returns a collection of rectangles that indicate the bounding rectangles for each box in a client."
	      },
	      "getBoundingClientRect": {
	        "!type": "fn() -> +ClientRect",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getBoundingClientRect",
	        "!doc": "Returns a text rectangle object that encloses a group of text rectangles."
	      },
	      "setAttributeNode": {
	        "!type": "fn(attr: +Attr) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttributeNode",
	        "!doc": "Adds a new Attr node to the specified element."
	      },
	      "removeAttributeNode": {
	        "!type": "fn(attr: +Attr) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.removeAttributeNode",
	        "!doc": "Removes the specified attribute from the current element."
	      },
	      "setAttributeNodeNS": {
	        "!type": "fn(attr: +Attr) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.setAttributeNodeNS",
	        "!doc": "Adds a new namespaced attribute node to an element."
	      },
	      "insertAdjacentHTML": {
	        "!type": "fn(position: string, text: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.insertAdjacentHTML",
	        "!doc": "Parses the specified text as HTML or XML and inserts the resulting nodes into the DOM tree at a specified position. It does not reparse the element it is being used on and thus it does not corrupt the existing elements inside the element. This, and avoiding the extra step of serialization make it much faster than direct innerHTML manipulation."
	      },
	      "children": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.children",
	        "!doc": "Returns a collection of child elements of the given element."
	      },
	      "childElementCount": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.childElementCount",
	        "!doc": "Returns the number of child elements of the given element."
	      },
	      "className": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.className",
	        "!doc": "Gets and sets the value of the class attribute of the specified element."
	      },
	      "style": {
	        "cssText": "string",
	        "alignmentBaseline": "string",
	        "background": "string",
	        "backgroundAttachment": "string",
	        "backgroundClip": "string",
	        "backgroundColor": "string",
	        "backgroundImage": "string",
	        "backgroundOrigin": "string",
	        "backgroundPosition": "string",
	        "backgroundPositionX": "string",
	        "backgroundPositionY": "string",
	        "backgroundRepeat": "string",
	        "backgroundRepeatX": "string",
	        "backgroundRepeatY": "string",
	        "backgroundSize": "string",
	        "baselineShift": "string",
	        "border": "string",
	        "borderBottom": "string",
	        "borderBottomColor": "string",
	        "borderBottomLeftRadius": "string",
	        "borderBottomRightRadius": "string",
	        "borderBottomStyle": "string",
	        "borderBottomWidth": "string",
	        "borderCollapse": "string",
	        "borderColor": "string",
	        "borderImage": "string",
	        "borderImageOutset": "string",
	        "borderImageRepeat": "string",
	        "borderImageSlice": "string",
	        "borderImageSource": "string",
	        "borderImageWidth": "string",
	        "borderLeft": "string",
	        "borderLeftColor": "string",
	        "borderLeftStyle": "string",
	        "borderLeftWidth": "string",
	        "borderRadius": "string",
	        "borderRight": "string",
	        "borderRightColor": "string",
	        "borderRightStyle": "string",
	        "borderRightWidth": "string",
	        "borderSpacing": "string",
	        "borderStyle": "string",
	        "borderTop": "string",
	        "borderTopColor": "string",
	        "borderTopLeftRadius": "string",
	        "borderTopRightRadius": "string",
	        "borderTopStyle": "string",
	        "borderTopWidth": "string",
	        "borderWidth": "string",
	        "bottom": "string",
	        "boxShadow": "string",
	        "boxSizing": "string",
	        "captionSide": "string",
	        "clear": "string",
	        "clip": "string",
	        "clipPath": "string",
	        "clipRule": "string",
	        "color": "string",
	        "colorInterpolation": "string",
	        "colorInterpolationFilters": "string",
	        "colorProfile": "string",
	        "colorRendering": "string",
	        "content": "string",
	        "counterIncrement": "string",
	        "counterReset": "string",
	        "cursor": "string",
	        "direction": "string",
	        "display": "string",
	        "dominantBaseline": "string",
	        "emptyCells": "string",
	        "enableBackground": "string",
	        "fill": "string",
	        "fillOpacity": "string",
	        "fillRule": "string",
	        "filter": "string",
	        "float": "string",
	        "floodColor": "string",
	        "floodOpacity": "string",
	        "font": "string",
	        "fontFamily": "string",
	        "fontSize": "string",
	        "fontStretch": "string",
	        "fontStyle": "string",
	        "fontVariant": "string",
	        "fontWeight": "string",
	        "glyphOrientationHorizontal": "string",
	        "glyphOrientationVertical": "string",
	        "height": "string",
	        "imageRendering": "string",
	        "kerning": "string",
	        "left": "string",
	        "letterSpacing": "string",
	        "lightingColor": "string",
	        "lineHeight": "string",
	        "listStyle": "string",
	        "listStyleImage": "string",
	        "listStylePosition": "string",
	        "listStyleType": "string",
	        "margin": "string",
	        "marginBottom": "string",
	        "marginLeft": "string",
	        "marginRight": "string",
	        "marginTop": "string",
	        "marker": "string",
	        "markerEnd": "string",
	        "markerMid": "string",
	        "markerStart": "string",
	        "mask": "string",
	        "maxHeight": "string",
	        "maxWidth": "string",
	        "minHeight": "string",
	        "minWidth": "string",
	        "opacity": "string",
	        "orphans": "string",
	        "outline": "string",
	        "outlineColor": "string",
	        "outlineOffset": "string",
	        "outlineStyle": "string",
	        "outlineWidth": "string",
	        "overflow": "string",
	        "overflowWrap": "string",
	        "overflowX": "string",
	        "overflowY": "string",
	        "padding": "string",
	        "paddingBottom": "string",
	        "paddingLeft": "string",
	        "paddingRight": "string",
	        "paddingTop": "string",
	        "page": "string",
	        "pageBreakAfter": "string",
	        "pageBreakBefore": "string",
	        "pageBreakInside": "string",
	        "pointerEvents": "string",
	        "position": "string",
	        "quotes": "string",
	        "resize": "string",
	        "right": "string",
	        "shapeRendering": "string",
	        "size": "string",
	        "speak": "string",
	        "src": "string",
	        "stopColor": "string",
	        "stopOpacity": "string",
	        "stroke": "string",
	        "strokeDasharray": "string",
	        "strokeDashoffset": "string",
	        "strokeLinecap": "string",
	        "strokeLinejoin": "string",
	        "strokeMiterlimit": "string",
	        "strokeOpacity": "string",
	        "strokeWidth": "string",
	        "tabSize": "string",
	        "tableLayout": "string",
	        "textAlign": "string",
	        "textAnchor": "string",
	        "textDecoration": "string",
	        "textIndent": "string",
	        "textLineThrough": "string",
	        "textLineThroughColor": "string",
	        "textLineThroughMode": "string",
	        "textLineThroughStyle": "string",
	        "textLineThroughWidth": "string",
	        "textOverflow": "string",
	        "textOverline": "string",
	        "textOverlineColor": "string",
	        "textOverlineMode": "string",
	        "textOverlineStyle": "string",
	        "textOverlineWidth": "string",
	        "textRendering": "string",
	        "textShadow": "string",
	        "textTransform": "string",
	        "textUnderline": "string",
	        "textUnderlineColor": "string",
	        "textUnderlineMode": "string",
	        "textUnderlineStyle": "string",
	        "textUnderlineWidth": "string",
	        "top": "string",
	        "unicodeBidi": "string",
	        "unicodeRange": "string",
	        "vectorEffect": "string",
	        "verticalAlign": "string",
	        "visibility": "string",
	        "whiteSpace": "string",
	        "width": "string",
	        "wordBreak": "string",
	        "wordSpacing": "string",
	        "wordWrap": "string",
	        "writingMode": "string",
	        "zIndex": "string",
	        "zoom": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.style",
	        "!doc": "Returns an object that represents the element's style attribute."
	      },
	      "classList": {
	        "!type": "+DOMTokenList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.classList",
	        "!doc": "Returns a token list of the class attribute of the element."
	      },
	      "contentEditable": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.contentEditable",
	        "!doc": "Indicates whether or not the element is editable."
	      },
	      "firstElementChild": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.firstElementChild",
	        "!doc": "Returns the element's first child element or null if there are no child elements."
	      },
	      "lastElementChild": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.lastElementChild",
	        "!doc": "Returns the element's last child element or null if there are no child elements."
	      },
	      "nextElementSibling": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.nextElementSibling",
	        "!doc": "Returns the element immediately following the specified one in its parent's children list, or null if the specified element is the last one in the list."
	      },
	      "previousElementSibling": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Element.previousElementSibling",
	        "!doc": "Returns the element immediately prior to the specified one in its parent's children list, or null if the specified element is the first one in the list."
	      },
	      "tabIndex": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.tabIndex",
	        "!doc": "Gets/sets the tab order of the current element."
	      },
	      "title": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.title",
	        "!doc": "Establishes the text to be displayed in a 'tool tip' popup when the mouse is over the displayed node."
	      },
	      "width": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetWidth",
	        "!doc": "Returns the layout width of an element."
	      },
	      "height": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetHeight",
	        "!doc": "Height of an element relative to the element's offsetParent."
	      },
	      "getContext": {
	        "!type": "fn(id: string) -> CanvasRenderingContext2D",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCanvasElement",
	        "!doc": "DOM canvas elements expose the HTMLCanvasElement interface, which provides properties and methods for manipulating the layout and presentation of canvas elements. The HTMLCanvasElement interface inherits the properties and methods of the element object interface."
	      },
	      "supportsContext": "fn(id: string) -> bool",
	      "oncopy": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.oncopy",
	        "!doc": "The oncopy property returns the onCopy event handler code on the current element."
	      },
	      "oncut": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.oncut",
	        "!doc": "The oncut property returns the onCut event handler code on the current element."
	      },
	      "onpaste": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onpaste",
	        "!doc": "The onpaste property returns the onPaste event handler code on the current element."
	      },
	      "onbeforeunload": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/HTML/Element/body",
	        "!doc": "The HTML <body> element represents the main content of an HTML document. There is only one <body> element in a document."
	      },
	      "onfocus": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onfocus",
	        "!doc": "The onfocus property returns the onFocus event handler code on the current element."
	      },
	      "onblur": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onblur",
	        "!doc": "The onblur property returns the onBlur event handler code, if any, that exists on the current element."
	      },
	      "onchange": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onchange",
	        "!doc": "The onchange property sets and returns the onChange event handler code for the current element."
	      },
	      "onclick": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onclick",
	        "!doc": "The onclick property returns the onClick event handler code on the current element."
	      },
	      "ondblclick": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.ondblclick",
	        "!doc": "The ondblclick property returns the onDblClick event handler code on the current element."
	      },
	      "onmousedown": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmousedown",
	        "!doc": "The onmousedown property returns the onMouseDown event handler code on the current element."
	      },
	      "onmouseup": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseup",
	        "!doc": "The onmouseup property returns the onMouseUp event handler code on the current element."
	      },
	      "onmousewheel": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/wheel",
	        "!doc": "The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. This event deprecates the legacy mousewheel event."
	      },
	      "onmouseover": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseover",
	        "!doc": "The onmouseover property returns the onMouseOver event handler code on the current element."
	      },
	      "onmouseout": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseout",
	        "!doc": "The onmouseout property returns the onMouseOut event handler code on the current element."
	      },
	      "onmousemove": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmousemove",
	        "!doc": "The onmousemove property returns the mousemove event handler code on the current element."
	      },
	      "oncontextmenu": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/window.oncontextmenu",
	        "!doc": "An event handler property for right-click events on the window. Unless the default behavior is prevented, the browser context menu will activate. Note that this event will occur with any non-disabled right-click event and does not depend on an element possessing the \"contextmenu\" attribute."
	      },
	      "onkeydown": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeydown",
	        "!doc": "The onkeydown property returns the onKeyDown event handler code on the current element."
	      },
	      "onkeyup": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeyup",
	        "!doc": "The onkeyup property returns the onKeyUp event handler code for the current element."
	      },
	      "onkeypress": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeypress",
	        "!doc": "The onkeypress property sets and returns the onKeyPress event handler code for the current element."
	      },
	      "onresize": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onresize",
	        "!doc": "onresize returns the element's onresize event handler code. It can also be used to set the code to be executed when the resize event occurs."
	      },
	      "onscroll": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.onscroll",
	        "!doc": "The onscroll property returns the onScroll event handler code on the current element."
	      },
	      "ondragstart": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	        "!doc": "The following describes the steps that occur during a drag and drop operation."
	      },
	      "ondragover": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragover",
	        "!doc": "The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds)."
	      },
	      "ondragleave": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragleave",
	        "!doc": "The dragleave event is fired when a dragged element or text selection leaves a valid drop target."
	      },
	      "ondragenter": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragenter",
	        "!doc": "The dragenter event is fired when a dragged element or text selection enters a valid drop target."
	      },
	      "ondragend": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/dragend",
	        "!doc": "The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key)."
	      },
	      "ondrag": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Mozilla_event_reference/drag",
	        "!doc": "The drag event is fired when an element or text selection is being dragged (every few hundred milliseconds)."
	      },
	      "offsetTop": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetTop",
	        "!doc": "Returns the distance of the current element relative to the top of the offsetParent node."
	      },
	      "offsetLeft": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetLeft",
	        "!doc": "Returns the number of pixels that the upper left corner of the current element is offset to the left within the offsetParent node."
	      },
	      "offsetHeight": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetHeight",
	        "!doc": "Height of an element relative to the element's offsetParent."
	      },
	      "offsetWidth": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.offsetWidth",
	        "!doc": "Returns the layout width of an element."
	      },
	      "scrollTop": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollTop",
	        "!doc": "Gets or sets the number of pixels that the content of an element is scrolled upward."
	      },
	      "scrollLeft": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollLeft",
	        "!doc": "Gets or sets the number of pixels that an element's content is scrolled to the left."
	      },
	      "scrollHeight": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollHeight",
	        "!doc": "Height of the scroll view of an element; it includes the element padding but not its margin."
	      },
	      "scrollWidth": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.scrollWidth",
	        "!doc": "Read-only property that returns either the width in pixels of the content of an element or the width of the element itself, whichever is greater."
	      },
	      "clientTop": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientTop",
	        "!doc": "The width of the top border of an element in pixels. It does not include the top margin or padding. clientTop is read-only."
	      },
	      "clientLeft": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientLeft",
	        "!doc": "The width of the left border of an element in pixels. It includes the width of the vertical scrollbar if the text direction of the element is right-to-left and if there is an overflow causing a left vertical scrollbar to be rendered. clientLeft does not include the left margin or the left padding. clientLeft is read-only."
	      },
	      "clientHeight": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientHeight",
	        "!doc": "Returns the inner height of an element in pixels, including padding but not the horizontal scrollbar height, border, or margin."
	      },
	      "clientWidth": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.clientWidth",
	        "!doc": "The inner width of an element in pixels. It includes padding but not the vertical scrollbar (if present, if rendered), border or margin."
	      },
	      "innerHTML": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.innerHTML",
	        "!doc": "Sets or gets the HTML syntax describing the element's descendants."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Element",
	    "!doc": "Represents an element in an HTML or XML document."
	  },
	  "Text": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Node.prototype",
	      "wholeText": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Text.wholeText",
	        "!doc": "Returns all text of all Text nodes logically adjacent to the node.  The text is concatenated in document order.  This allows you to specify any text node and obtain all adjacent text as a single string."
	      },
	      "splitText": {
	        "!type": "fn(offset: number) -> +Text",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Text.splitText",
	        "!doc": "Breaks the Text node into two nodes at the specified offset, keeping both nodes in the tree as siblings."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Text",
	    "!doc": "In the DOM, the Text interface represents the textual content of an Element or Attr.  If an element has no markup within its content, it has a single child implementing Text that contains the element's text.  However, if the element contains markup, it is parsed into information items and Text nodes that form its children."
	  },
	  "Document": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Node.prototype",
	      "activeElement": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.activeElement",
	        "!doc": "Returns the currently focused element, that is, the element that will get keystroke events if the user types any. This attribute is read only."
	      },
	      "compatMode": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.compatMode",
	        "!doc": "Indicates whether the document is rendered in Quirks mode or Strict mode."
	      },
	      "designMode": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.designMode",
	        "!doc": "Can be used to make any document editable, for example in a <iframe />:"
	      },
	      "dir": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Document.dir",
	        "!doc": "This property should indicate and allow the setting of the directionality of the text of the document, whether left to right (default) or right to left."
	      },
	      "height": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.height",
	        "!doc": "Returns the height of the <body> element of the current document."
	      },
	      "width": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.width",
	        "!doc": "Returns the width of the <body> element of the current document in pixels."
	      },
	      "characterSet": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.characterSet",
	        "!doc": "Returns the character encoding of the current document."
	      },
	      "readyState": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.readyState",
	        "!doc": "Returns \"loading\" while the document is loading, \"interactive\" once it is finished parsing but still loading sub-resources, and \"complete\" once it has loaded."
	      },
	      "location": {
	        "!type": "location",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.location",
	        "!doc": "Returns a Location object, which contains information about the URL of the document and provides methods for changing that URL."
	      },
	      "lastModified": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.lastModified",
	        "!doc": "Returns a string containing the date and time on which the current document was last modified."
	      },
	      "head": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.head",
	        "!doc": "Returns the <head> element of the current document. If there are more than one <head> elements, the first one is returned."
	      },
	      "body": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.body",
	        "!doc": "Returns the <body> or <frameset> node of the current document."
	      },
	      "cookie": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.cookie",
	        "!doc": "Get and set the cookies associated with the current document."
	      },
	      "URL": "string",
	      "domain": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.domain",
	        "!doc": "Gets/sets the domain portion of the origin of the current document, as used by the same origin policy."
	      },
	      "referrer": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.referrer",
	        "!doc": "Returns the URI of the page that linked to this page."
	      },
	      "title": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.title",
	        "!doc": "Gets or sets the title of the document."
	      },
	      "defaultView": {
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.defaultView",
	        "!doc": "In browsers returns the window object associated with the document or null if none available."
	      },
	      "documentURI": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.documentURI",
	        "!doc": "Returns the document location as string. It is read-only per DOM4 specification."
	      },
	      "xmlStandalone": "bool",
	      "xmlVersion": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.xmlVersion",
	        "!doc": "Returns the version number as specified in the XML declaration (e.g., <?xml version=\"1.0\"?>) or \"1.0\" if the declaration is absent."
	      },
	      "xmlEncoding": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Document.xmlEncoding",
	        "!doc": "Returns the encoding as determined by the XML declaration. Should be null if unspecified or unknown."
	      },
	      "inputEncoding": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.inputEncoding",
	        "!doc": "Returns a string representing the encoding under which the document was parsed (e.g. ISO-8859-1)."
	      },
	      "documentElement": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.documentElement",
	        "!doc": "Read-only"
	      },
	      "implementation": {
	        "hasFeature": "fn(feature: string, version: number) -> bool",
	        "createDocumentType": {
	          "!type": "fn(qualifiedName: string, publicId: string, systemId: string) -> +Node",
	          "!url": "https://developer.mozilla.org/en/docs/DOM/DOMImplementation.createDocumentType",
	          "!doc": "Returns a DocumentType object which can either be used with DOMImplementation.createDocument upon document creation or they can be put into the document via Node.insertBefore() or Node.replaceChild(): http://www.w3.org/TR/DOM-Level-3-Cor...l#ID-B63ED1A31 (less ideal due to features not likely being as accessible: http://www.w3.org/TR/DOM-Level-3-Cor...createDocument ). In any case, entity declarations and notations will not be available: http://www.w3.org/TR/DOM-Level-3-Cor...-createDocType   "
	        },
	        "createHTMLDocument": {
	          "!type": "fn(title: string) -> +Document",
	          "!url": "https://developer.mozilla.org/en/docs/DOM/DOMImplementation.createHTMLDocument",
	          "!doc": "This method (available from document.implementation) creates a new HTML document."
	        },
	        "createDocument": {
	          "!type": "fn(namespaceURI: string, qualifiedName: string, type: +Node) -> +Document",
	          "!url": "https://developer.mozilla.org/en-US/docs/DOM/DOMImplementation.createHTMLDocument",
	          "!doc": "This method creates a new HTML document."
	        },
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.implementation",
	        "!doc": "Returns a DOMImplementation object associated with the current document."
	      },
	      "doctype": {
	        "!type": "+Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.doctype",
	        "!doc": "Returns the Document Type Declaration (DTD) associated with current document. The returned object implements the DocumentType interface. Use DOMImplementation.createDocumentType() to create a DocumentType."
	      },
	      "open": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.open",
	        "!doc": "The document.open() method opens a document for writing."
	      },
	      "close": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.close",
	        "!doc": "The document.close() method finishes writing to a document, opened with document.open()."
	      },
	      "write": {
	        "!type": "fn(html: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.write",
	        "!doc": "Writes a string of text to a document stream opened by document.open()."
	      },
	      "writeln": {
	        "!type": "fn(html: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.writeln",
	        "!doc": "Writes a string of text followed by a newline character to a document."
	      },
	      "clear": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.clear",
	        "!doc": "In recent versions of Mozilla-based applications as well as in Internet Explorer and Netscape 4 this method does nothing."
	      },
	      "hasFocus": {
	        "!type": "fn() -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.hasFocus",
	        "!doc": "Returns a Boolean value indicating whether the document or any element inside the document has focus. This method can be used to determine whether the active element in a document has focus."
	      },
	      "createElement": {
	        "!type": "fn(tagName: string) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createElement",
	        "!doc": "Creates the specified element."
	      },
	      "createElementNS": {
	        "!type": "fn(ns: string, tagName: string) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createElementNS",
	        "!doc": "Creates an element with the specified namespace URI and qualified name."
	      },
	      "createDocumentFragment": {
	        "!type": "fn() -> +DocumentFragment",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment",
	        "!doc": "Creates a new empty DocumentFragment."
	      },
	      "createTextNode": {
	        "!type": "fn(content: string) -> +Text",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createTextNode",
	        "!doc": "Creates a new Text node."
	      },
	      "createComment": {
	        "!type": "fn(content: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createComment",
	        "!doc": "Creates a new comment node, and returns it."
	      },
	      "createCDATASection": {
	        "!type": "fn(content: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createCDATASection",
	        "!doc": "Creates a new CDATA section node, and returns it. "
	      },
	      "createProcessingInstruction": {
	        "!type": "fn(content: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createProcessingInstruction",
	        "!doc": "Creates a new processing instruction node, and returns it."
	      },
	      "createAttribute": {
	        "!type": "fn(name: string) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createAttribute",
	        "!doc": "Creates a new attribute node, and returns it."
	      },
	      "createAttributeNS": {
	        "!type": "fn(ns: string, name: string) -> +Attr",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	      },
	      "importNode": {
	        "!type": "fn(node: +Node, deep: bool) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.importNode",
	        "!doc": "Creates a copy of a node from an external document that can be inserted into the current document."
	      },
	      "getElementById": {
	        "!type": "fn(id: string) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementById",
	        "!doc": "Returns a reference to the element by its ID."
	      },
	      "getElementsByTagName": {
	        "!type": "fn(tagName: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByTagName",
	        "!doc": "Returns a NodeList of elements with the given tag name. The complete document is searched, including the root node. The returned NodeList is live, meaning that it updates itself automatically to stay in sync with the DOM tree without having to call document.getElementsByTagName again."
	      },
	      "getElementsByTagNameNS": {
	        "!type": "fn(ns: string, tagName: string) -> +NodeList",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByTagNameNS",
	        "!doc": "Returns a list of elements with the given tag name belonging to the given namespace. The complete document is searched, including the root node."
	      },
	      "createEvent": {
	        "!type": "fn(type: string) -> +Event",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createEvent",
	        "!doc": "Creates an event of the type specified. The returned object should be first initialized and can then be passed to element.dispatchEvent."
	      },
	      "createRange": {
	        "!type": "fn() -> +Range",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createRange",
	        "!doc": "Returns a new Range object."
	      },
	      "evaluate": {
	        "!type": "fn(expr: ?) -> +XPathResult",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.evaluate",
	        "!doc": "Returns an XPathResult based on an XPath expression and other given parameters."
	      },
	      "execCommand": {
	        "!type": "fn(cmd: string)",
	        "!url": "https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla#Executing_Commands",
	        "!doc": "Run command to manipulate the contents of an editable region."
	      },
	      "queryCommandEnabled": {
	        "!type": "fn(cmd: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	        "!doc": "Returns true if the Midas command can be executed on the current range."
	      },
	      "queryCommandIndeterm": {
	        "!type": "fn(cmd: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	        "!doc": "Returns true if the Midas command is in a indeterminate state on the current range."
	      },
	      "queryCommandState": {
	        "!type": "fn(cmd: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	        "!doc": "Returns true if the Midas command has been executed on the current range."
	      },
	      "queryCommandSupported": {
	        "!type": "fn(cmd: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.queryCommandSupported",
	        "!doc": "Reports whether or not the specified editor query command is supported by the browser."
	      },
	      "queryCommandValue": {
	        "!type": "fn(cmd: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	        "!doc": "Returns the current value of the current range for Midas command."
	      },
	      "getElementsByName": {
	        "!type": "fn(name: string) -> +HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getElementsByName",
	        "!doc": "Returns a list of elements with a given name in the HTML document."
	      },
	      "elementFromPoint": {
	        "!type": "fn(x: number, y: number) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.elementFromPoint",
	        "!doc": "Returns the element from the document whose elementFromPoint method is being called which is the topmost element which lies under the given point.  To get an element, specify the point via coordinates, in CSS pixels, relative to the upper-left-most point in the window or frame containing the document."
	      },
	      "getSelection": {
	        "!type": "fn() -> +Selection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.getSelection",
	        "!doc": "The DOM getSelection() method is available on the Window and Document interfaces."
	      },
	      "adoptNode": {
	        "!type": "fn(node: +Node) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.adoptNode",
	        "!doc": "Adopts a node from an external document. The node and its subtree is removed from the document it's in (if any), and its ownerDocument is changed to the current document. The node can then be inserted into the current document."
	      },
	      "createTreeWalker": {
	        "!type": "fn(root: +Node, mask: number) -> ?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createTreeWalker",
	        "!doc": "Returns a new TreeWalker object."
	      },
	      "createExpression": {
	        "!type": "fn(text: string) -> ?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createExpression",
	        "!doc": "This method compiles an XPathExpression which can then be used for (repeated) evaluations."
	      },
	      "createNSResolver": {
	        "!type": "fn(node: +Node)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.createNSResolver",
	        "!doc": "Creates an XPathNSResolver which resolves namespaces with respect to the definitions in scope for a specified node."
	      },
	      "scripts": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Document.scripts",
	        "!doc": "Returns a list of the <script> elements in the document. The returned object is an HTMLCollection."
	      },
	      "plugins": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.plugins",
	        "!doc": "Returns an HTMLCollection object containing one or more HTMLEmbedElements or null which represent the <embed> elements in the current document."
	      },
	      "embeds": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.embeds",
	        "!doc": "Returns a list of the embedded OBJECTS within the current document."
	      },
	      "anchors": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.anchors",
	        "!doc": "Returns a list of all of the anchors in the document."
	      },
	      "links": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.links",
	        "!doc": "The links property returns a collection of all AREA elements and anchor elements in a document with a value for the href attribute. "
	      },
	      "forms": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.forms",
	        "!doc": "Returns a collection (an HTMLCollection) of the form elements within the current document."
	      },
	      "styleSheets": {
	        "!type": "+HTMLCollection",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.styleSheets",
	        "!doc": "Returns a list of stylesheet objects for stylesheets explicitly linked into or embedded in a document."
	      },
	      "querySelector": "Element.prototype.querySelector",
	      "querySelectorAll": "Element.prototype.querySelectorAll"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	    "!doc": "Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."
	  },
	  "document": {
	    "!type": "+Document",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/document",
	    "!doc": "Each web page loaded in the browser has its own document object. This object serves as an entry point to the web page's content (the DOM tree, including elements such as <body> and <table>) and provides functionality global to the document (such as obtaining the page's URL and creating new elements in the document)."
	  },
	  "XMLDocument": {
	    "!type": "fn()",
	    "prototype": "Document.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/Parsing_and_serializing_XML",
	    "!doc": "The Web platform provides the following objects for parsing and serializing XML:"
	  },
	  "Attr": {
	    "!type": "fn()",
	    "prototype": {
	      "isId": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	      },
	      "name": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	      },
	      "value": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	        "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Attr",
	    "!doc": "This type represents a DOM element's attribute as an object. In most DOM methods, you will probably directly retrieve the attribute as a string (e.g., Element.getAttribute(), but certain functions (e.g., Element.getAttributeNode()) or means of iterating give Attr types."
	  },
	  "NodeList": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.length",
	        "!doc": "Returns the number of items in a NodeList."
	      },
	      "item": {
	        "!type": "fn(i: number) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NodeList.item",
	        "!doc": "Returns a node from a NodeList by index."
	      },
	      "<i>": "+Element"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/NodeList",
	    "!doc": "NodeList objects are collections of nodes returned by getElementsByTagName, getElementsByTagNameNS, Node.childNodes, querySelectorAll, getElementsByClassName, etc."
	  },
	  "HTMLCollection": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
	        "!doc": "The number of items in the collection."
	      },
	      "item": {
	        "!type": "fn(i: number) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
	        "!doc": "Returns the specific node at the given zero-based index into the list. Returns null if the index is out of range."
	      },
	      "namedItem": {
	        "!type": "fn(name: string) -> +Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
	        "!doc": "Returns the specific node whose ID or, as a fallback, name matches the string specified by name. Matching by name is only done as a last resort, only in HTML, and only if the referenced element supports the name attribute. Returns null if no node exists by the given name."
	      },
	      "<i>": "+Element"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/HTMLCollection",
	    "!doc": "HTMLCollection is an interface representing a generic collection of elements (in document order) and offers methods and properties for traversing the list."
	  },
	  "NamedNodeMap": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "The number of items in the map."
	      },
	      "getNamedItem": {
	        "!type": "fn(name: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Gets a node by name."
	      },
	      "setNamedItem": {
	        "!type": "fn(node: +Node) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Adds (or replaces) a node by its nodeName."
	      },
	      "removeNamedItem": {
	        "!type": "fn(name: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Removes a node (or if an attribute, may reveal a default if present)."
	      },
	      "item": {
	        "!type": "fn(i: number) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Returns the item at the given index (or null if the index is higher or equal to the number of nodes)."
	      },
	      "getNamedItemNS": {
	        "!type": "fn(ns: string, name: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Gets a node by namespace and localName."
	      },
	      "setNamedItemNS": {
	        "!type": "fn(node: +Node) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Adds (or replaces) a node by its localName and namespaceURI."
	      },
	      "removeNamedItemNS": {
	        "!type": "fn(ns: string, name: string) -> +Node",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	        "!doc": "Removes a node (or if an attribute, may reveal a default if present)."
	      },
	      "<i>": "+Node"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/NamedNodeMap",
	    "!doc": "A collection of nodes returned by Element.attributes (also potentially for DocumentType.entities, DocumentType.notations). NamedNodeMaps are not in any particular order (unlike NodeList), although they may be accessed by an index as in an array (they may also be accessed with the item() method). A NamedNodeMap object are live and will thus be auto-updated if changes are made to their contents internally or elsewhere."
	  },
	  "DocumentFragment": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Node.prototype"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/document.createDocumentFragment",
	    "!doc": "Creates a new empty DocumentFragment."
	  },
	  "DOMTokenList": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "The amount of items in the list."
	      },
	      "item": {
	        "!type": "fn(i: number) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Returns an item in the list by its index."
	      },
	      "contains": {
	        "!type": "fn(token: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Return true if the underlying string contains token, otherwise false."
	      },
	      "add": {
	        "!type": "fn(token: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Adds token to the underlying string."
	      },
	      "remove": {
	        "!type": "fn(token: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Remove token from the underlying string."
	      },
	      "toggle": {
	        "!type": "fn(token: string) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	        "!doc": "Removes token from string and returns false. If token doesn't exist it's added and the function returns true."
	      },
	      "<i>": "string"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOMTokenList",
	    "!doc": "This type represents a set of space-separated tokens. Commonly returned by HTMLElement.classList, HTMLLinkElement.relList, HTMLAnchorElement.relList or HTMLAreaElement.relList. It is indexed beginning with 0 as with JavaScript arrays. DOMTokenList is always case-sensitive."
	  },
	  "XPathResult": {
	    "!type": "fn()",
	    "prototype": {
	      "boolValue": "bool",
	      "invalidIteratorState": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
	        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
	      },
	      "numberValue": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/XPathResult",
	        "!doc": "Refer to nsIDOMXPathResult for more detail."
	      },
	      "resultType": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/document.evaluate",
	        "!doc": "Returns an XPathResult based on an XPath expression and other given parameters."
	      },
	      "singleNodeValue": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
	        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
	      },
	      "snapshotLength": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/XPathResult",
	        "!doc": "Refer to nsIDOMXPathResult for more detail."
	      },
	      "stringValue": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
	        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
	      },
	      "iterateNext": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/Introduction_to_using_XPath_in_JavaScript",
	        "!doc": "This document describes the interface for using XPath in JavaScript internally, in extensions, and from websites. Mozilla implements a fair amount of the DOM 3 XPath. Which means that XPath expressions can be run against both HTML and XML documents."
	      },
	      "snapshotItem": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en-US/docs/XPathResult#snapshotItem()"
	      },
	      "ANY_TYPE": "number",
	      "NUMBER_TYPE": "number",
	      "STRING_TYPE": "number",
	      "BOOL_TYPE": "number",
	      "UNORDERED_NODE_ITERATOR_TYPE": "number",
	      "ORDERED_NODE_ITERATOR_TYPE": "number",
	      "UNORDERED_NODE_SNAPSHOT_TYPE": "number",
	      "ORDERED_NODE_SNAPSHOT_TYPE": "number",
	      "ANY_UNORDERED_NODE_TYPE": "number",
	      "FIRST_ORDERED_NODE_TYPE": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/XPathResult",
	    "!doc": "Refer to nsIDOMXPathResult for more detail."
	  },
	  "ClientRect": {
	    "!type": "fn()",
	    "prototype": {
	      "top": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Top of the box, in pixels, relative to the viewport."
	      },
	      "left": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Left of the box, in pixels, relative to the viewport."
	      },
	      "bottom": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Bottom of the box, in pixels, relative to the viewport."
	      },
	      "right": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	        "!doc": "Right of the box, in pixels, relative to the viewport."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.getClientRects",
	    "!doc": "Returns a collection of rectangles that indicate the bounding rectangles for each box in a client."
	  },
	  "Event": {
	    "!type": "fn()",
	    "prototype": {
	      "stopPropagation": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.stopPropagation",
	        "!doc": "Prevents further propagation of the current event."
	      },
	      "preventDefault": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.preventDefault",
	        "!doc": "Cancels the event if it is cancelable, without stopping further propagation of the event."
	      },
	      "initEvent": {
	        "!type": "fn(type: string, bubbles: bool, cancelable: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.initEvent",
	        "!doc": "The initEvent method is used to initialize the value of an event created using document.createEvent."
	      },
	      "stopImmediatePropagation": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.stopImmediatePropagation",
	        "!doc": "Prevents other listeners of the same event to be called."
	      },
	      "NONE": "number",
	      "CAPTURING_PHASE": "number",
	      "AT_TARGET": "number",
	      "BUBBLING_PHASE": "number",
	      "MOUSEDOWN": "number",
	      "MOUSEUP": "number",
	      "MOUSEOVER": "number",
	      "MOUSEOUT": "number",
	      "MOUSEMOVE": "number",
	      "MOUSEDRAG": "number",
	      "CLICK": "number",
	      "DBLCLICK": "number",
	      "KEYDOWN": "number",
	      "KEYUP": "number",
	      "KEYPRESS": "number",
	      "DRAGDROP": "number",
	      "FOCUS": "number",
	      "BLUR": "number",
	      "SELECT": "number",
	      "CHANGE": "number",
	      "target": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget",
	        "!doc": "An EventTarget is a DOM interface implemented by objects that can receive DOM events and have listeners for them. The most common EventTargets are DOM elements, although other objects can be EventTargets too, for example document, window, XMLHttpRequest, and others."
	      },
	      "relatedTarget": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.relatedTarget",
	        "!doc": "Identifies a secondary target for the event."
	      },
	      "pageX": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.pageX",
	        "!doc": "Returns the horizontal coordinate of the event relative to whole document."
	      },
	      "pageY": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.pageY",
	        "!doc": "Returns the vertical coordinate of the event relative to the whole document."
	      },
	      "clientX": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.clientX",
	        "!doc": "Returns the horizontal coordinate within the application's client area at which the event occurred (as opposed to the coordinates within the page). For example, clicking in the top-left corner of the client area will always result in a mouse event with a clientX value of 0, regardless of whether the page is scrolled horizontally."
	      },
	      "clientY": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.clientY",
	        "!doc": "Returns the vertical coordinate within the application's client area at which the event occurred (as opposed to the coordinates within the page). For example, clicking in the top-left corner of the client area will always result in a mouse event with a clientY value of 0, regardless of whether the page is scrolled vertically."
	      },
	      "keyCode": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.keyCode",
	        "!doc": "Returns the Unicode value of a non-character key in a keypress event or any key in any other type of keyboard event."
	      },
	      "charCode": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.charCode",
	        "!doc": "Returns the Unicode value of a character key pressed during a keypress event."
	      },
	      "which": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.which",
	        "!doc": "Returns the numeric keyCode of the key pressed, or the character code (charCode) for an alphanumeric key pressed."
	      },
	      "button": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.button",
	        "!doc": "Indicates which mouse button caused the event."
	      },
	      "shiftKey": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.shiftKey",
	        "!doc": "Indicates whether the SHIFT key was pressed when the event fired."
	      },
	      "ctrlKey": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.ctrlKey",
	        "!doc": "Indicates whether the CTRL key was pressed when the event fired."
	      },
	      "altKey": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.altKey",
	        "!doc": "Indicates whether the ALT key was pressed when the event fired."
	      },
	      "metaKey": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.metaKey",
	        "!doc": "Indicates whether the META key was pressed when the event fired."
	      },
	      "returnValue": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/window.onbeforeunload",
	        "!doc": "An event that fires when a window is about to unload its resources. The document is still visible and the event is still cancelable."
	      },
	      "cancelBubble": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/event.cancelBubble",
	        "!doc": "bool is the boolean value of true or false."
	      },
	      "dataTransfer": {
	        "dropEffect": {
	          "!type": "string",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
	          "!doc": "The actual effect that will be used, and should always be one of the possible values of effectAllowed."
	        },
	        "effectAllowed": {
	          "!type": "string",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Specifies the effects that are allowed for this drag."
	        },
	        "files": {
	          "!type": "+FileList",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
	          "!doc": "Contains a list of all the local files available on the data transfer."
	        },
	        "types": {
	          "!type": "[string]",
	          "!url": "https://developer.mozilla.org/en-US/docs/DragDrop/DataTransfer",
	          "!doc": "Holds a list of the format types of the data that is stored for the first item, in the same order the data was added. An empty list will be returned if no data was added."
	        },
	        "addElement": {
	          "!type": "fn(element: +Element)",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
	          "!doc": "Set the drag source."
	        },
	        "clearData": {
	          "!type": "fn(type?: string)",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Remove the data associated with a given type."
	        },
	        "getData": {
	          "!type": "fn(type: string) -> string",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Retrieves the data for a given type, or an empty string if data for that type does not exist or the data transfer contains no data."
	        },
	        "setData": {
	          "!type": "fn(type: string, data: string)",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Set the data for a given type."
	        },
	        "setDragImage": {
	          "!type": "fn(image: +Element)",
	          "!url": "https://developer.mozilla.org/en/docs/DragDrop/Drag_Operations",
	          "!doc": "Set the image to be used for dragging if a custom one is desired."
	        },
	        "!url": "https://developer.mozilla.org/en/docs/DragDrop/DataTransfer",
	        "!doc": "This object is available from the dataTransfer property of all drag events. It cannot be created separately."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/event",
	    "!doc": "The DOM Event interface is accessible from within the handler function, via the event object passed as the first argument."
	  },
	  "TouchEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Touch_events",
	    "!doc": "In order to provide quality support for touch-based user interfaces, touch events offer the ability to interpret finger activity on touch screens or trackpads."
	  },
	  "WheelEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/WheelEvent",
	    "!doc": "The DOM WheelEvent represents events that occur due to the user moving a mouse wheel or similar input device."
	  },
	  "MouseEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/MouseEvent",
	    "!doc": "The DOM MouseEvent represents events that occur due to the user interacting with a pointing device (such as a mouse). It's represented by the nsINSDOMMouseEvent interface, which extends the nsIDOMMouseEvent interface."
	  },
	  "KeyboardEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/KeyboardEvent",
	    "!doc": "KeyboardEvent objects describe a user interaction with the keyboard. Each event describes a key; the event type (keydown, keypress, or keyup) identifies what kind of activity was performed."
	  },
	  "HashChangeEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onhashchange",
	    "!doc": "The hashchange event fires when a window's hash changes."
	  },
	  "ErrorEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/error",
	    "!doc": "The error event is fired whenever a resource fails to load."
	  },
	  "CustomEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Event/CustomEvent",
	    "!doc": "The DOM CustomEvent are events initialized by an application for any purpose."
	  },
	  "BeforeLoadEvent": {
	    "!type": "fn()",
	    "prototype": "Event.prototype",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window",
	    "!doc": "This section provides a brief reference for all of the methods, properties, and events available through the DOM window object. The window object implements the Window interface, which in turn inherits from the AbstractView interface. Some additional global functions, namespaces objects, and constructors, not typically associated with the window, but available on it, are listed in the JavaScript Reference."
	  },
	  "WebSocket": {
	    "!type": "fn(url: string)",
	    "prototype": {
	      "close": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/CloseEvent",
	        "!doc": "A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute."
	      },
	      "send": {
	        "!type": "fn(data: string)",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "binaryType": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "bufferedAmount": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications",
	        "!doc": "WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."
	      },
	      "extensions": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "onclose": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/CloseEvent",
	        "!doc": "A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute."
	      },
	      "onerror": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications",
	        "!doc": "WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."
	      },
	      "onmessage": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "onopen": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/WebSockets_reference/WebSocket",
	        "!doc": "The WebSocket object provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection."
	      },
	      "protocol": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets",
	        "!doc": "WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply."
	      },
	      "url": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/WebSockets/Writing_WebSocket_client_applications",
	        "!doc": "WebSockets is a technology that makes it possible to open an interactive communication session between the user's browser and a server. Using a WebSocket connection, Web applications can perform real-time communication instead of having to poll for changes back and forth."
	      },
	      "CONNECTING": "number",
	      "OPEN": "number",
	      "CLOSING": "number",
	      "CLOSED": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/WebSockets",
	    "!doc": "WebSockets is an advanced technology that makes it possible to open an interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply."
	  },
	  "Worker": {
	    "!type": "fn(scriptURL: string)",
	    "prototype": {
	      "postMessage": {
	        "!type": "fn(message: ?)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	        "!doc": "Sends a message to the worker's inner scope. This accepts a single parameter, which is the data to send to the worker. The data may be any value or JavaScript object handled by the structured clone algorithm, which includes cyclical references."
	      },
	      "terminate": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	        "!doc": "Immediately terminates the worker. This does not offer the worker an opportunity to finish its operations; it is simply stopped at once."
	      },
	      "onmessage": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	        "!doc": "An event listener that is called whenever a MessageEvent with type message bubbles through the worker. The message is stored in the event's data member."
	      },
	      "onerror": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	        "!doc": "An event listener that is called whenever an ErrorEvent with type error bubbles through the worker."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	    "!doc": "Workers are background tasks that can be easily created and can send messages back to their creators. Creating a worker is as simple as calling the Worker() constructor, specifying a script to be run in the worker thread."
	  },
	  "localStorage": {
	    "setItem": {
	      "!type": "fn(name: string, value: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	      "!doc": "Store an item in storage."
	    },
	    "getItem": {
	      "!type": "fn(name: string) -> string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	      "!doc": "Retrieve an item from storage."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	    "!doc": "The DOM Storage mechanism is a means through which string key/value pairs can be securely stored and later retrieved for use."
	  },
	  "sessionStorage": {
	    "setItem": {
	      "!type": "fn(name: string, value: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	      "!doc": "Store an item in storage."
	    },
	    "getItem": {
	      "!type": "fn(name: string) -> string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	      "!doc": "Retrieve an item from storage."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Storage",
	    "!doc": "This is a global object (sessionStorage) that maintains a storage area that's available for the duration of the page session. A page session lasts for as long as the browser is open and survives over page reloads and restores. Opening a page in a new tab or window will cause a new session to be initiated."
	  },
	  "FileList": {
	    "!type": "fn()",
	    "prototype": {
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileList",
	        "!doc": "A read-only value indicating the number of files in the list."
	      },
	      "item": {
	        "!type": "fn(i: number) -> +File",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileList",
	        "!doc": "Returns a File object representing the file at the specified index in the file list."
	      },
	      "<i>": "+File"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/FileList",
	    "!doc": "An object of this type is returned by the files property of the HTML input element; this lets you access the list of files selected with the <input type=\"file\"> element. It's also used for a list of files dropped into web content when using the drag and drop API."
	  },
	  "File": {
	    "!type": "fn()",
	    "prototype": {
	      "!proto": "Blob.prototype",
	      "fileName": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/File.fileName",
	        "!doc": "Returns the name of the file. For security reasons the path is excluded from this property."
	      },
	      "fileSize": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/File.fileSize",
	        "!doc": "Returns the size of a file in bytes."
	      },
	      "lastModifiedDate": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/File.lastModifiedDate",
	        "!doc": "Returns the last modified date of the file. Files without a known last modified date use the current date instead."
	      },
	      "name": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/File.name",
	        "!doc": "Returns the name of the file. For security reasons, the path is excluded from this property."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/File",
	    "!doc": "The File object provides information about -- and access to the contents of -- files. These are generally retrieved from a FileList object returned as a result of a user selecting files using the input element, or from a drag and drop operation's DataTransfer object."
	  },
	  "Blob": {
	    "!type": "fn(parts: [?], properties?: ?)",
	    "prototype": {
	      "size": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
	        "!doc": "The size, in bytes, of the data contained in the Blob object. Read only."
	      },
	      "type": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
	        "!doc": "An ASCII-encoded string, in all lower case, indicating the MIME type of the data contained in the Blob. If the type is unknown, this string is empty. Read only."
	      },
	      "slice": {
	        "!type": "fn(start: number, end?: number, type?: string) -> +Blob",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
	        "!doc": "Returns a new Blob object containing the data in the specified range of bytes of the source Blob."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Blob",
	    "!doc": "A Blob object represents a file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system."
	  },
	  "FileReader": {
	    "!type": "fn()",
	    "prototype": {
	      "abort": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Aborts the read operation. Upon return, the readyState will be DONE."
	      },
	      "readAsArrayBuffer": {
	        "!type": "fn(blob: +Blob)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Starts reading the contents of the specified Blob, producing an ArrayBuffer."
	      },
	      "readAsBinaryString": {
	        "!type": "fn(blob: +Blob)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Starts reading the contents of the specified Blob, producing raw binary data."
	      },
	      "readAsDataURL": {
	        "!type": "fn(blob: +Blob)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Starts reading the contents of the specified Blob, producing a data: url."
	      },
	      "readAsText": {
	        "!type": "fn(blob: +Blob, encoding?: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Starts reading the contents of the specified Blob, producing a string."
	      },
	      "EMPTY": "number",
	      "LOADING": "number",
	      "DONE": "number",
	      "error": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "The error that occurred while reading the file. Read only."
	      },
	      "readyState": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Indicates the state of the FileReader. This will be one of the State constants. Read only."
	      },
	      "result": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "The file's contents. This property is only valid after the read operation is complete, and the format of the data depends on which of the methods was used to initiate the read operation. Read only."
	      },
	      "onabort": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when the read operation is aborted."
	      },
	      "onerror": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when an error occurs."
	      },
	      "onload": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when the read operation is successfully completed."
	      },
	      "onloadend": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when the read is completed, whether successful or not. This is called after either onload or onerror."
	      },
	      "onloadstart": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called when reading the data is about to begin."
	      },
	      "onprogress": {
	        "!type": "?",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	        "!doc": "Called periodically while the data is being read."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/FileReader",
	    "!doc": "The FileReader object lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using File or Blob objects to specify the file or data to read. File objects may be obtained from a FileList object returned as a result of a user selecting files using the <input> element, from a drag and drop operation's DataTransfer object, or from the mozGetAsFile() API on an HTMLCanvasElement."
	  },
	  "Range": {
	    "!type": "fn()",
	    "prototype": {
	      "collapsed": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.collapsed",
	        "!doc": "Returns a boolean indicating whether the range's start and end points are at the same position."
	      },
	      "commonAncestorContainer": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.commonAncestorContainer",
	        "!doc": "Returns the deepest Node that contains the  startContainer and  endContainer Nodes."
	      },
	      "endContainer": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.endContainer",
	        "!doc": "Returns the Node within which the Range ends."
	      },
	      "endOffset": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.endOffset",
	        "!doc": "Returns a number representing where in the  endContainer the Range ends."
	      },
	      "startContainer": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.startContainer",
	        "!doc": "Returns the Node within which the Range starts."
	      },
	      "startOffset": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.startOffset",
	        "!doc": "Returns a number representing where in the startContainer the Range starts."
	      },
	      "setStart": {
	        "!type": "fn(node: +Element, offset: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setStart",
	        "!doc": "Sets the start position of a Range."
	      },
	      "setEnd": {
	        "!type": "fn(node: +Element, offset: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setEnd",
	        "!doc": "Sets the end position of a Range."
	      },
	      "setStartBefore": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setStartBefore",
	        "!doc": "Sets the start position of a Range relative to another Node."
	      },
	      "setStartAfter": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setStartAfter",
	        "!doc": "Sets the start position of a Range relative to a Node."
	      },
	      "setEndBefore": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setEndBefore",
	        "!doc": "Sets the end position of a Range relative to another Node."
	      },
	      "setEndAfter": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.setEndAfter",
	        "!doc": "Sets the end position of a Range relative to another Node."
	      },
	      "selectNode": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.selectNode",
	        "!doc": "Sets the Range to contain the Node and its contents."
	      },
	      "selectNodeContents": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.selectNodeContents",
	        "!doc": "Sets the Range to contain the contents of a Node."
	      },
	      "collapse": {
	        "!type": "fn(toStart: bool)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.collapse",
	        "!doc": "Collapses the Range to one of its boundary points."
	      },
	      "cloneContents": {
	        "!type": "fn() -> +DocumentFragment",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.cloneContents",
	        "!doc": "Returns a DocumentFragment copying the Nodes of a Range."
	      },
	      "deleteContents": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.deleteContents",
	        "!doc": "Removes the contents of a Range from the Document."
	      },
	      "extractContents": {
	        "!type": "fn() -> +DocumentFragment",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.extractContents",
	        "!doc": "Moves contents of a Range from the document tree into a DocumentFragment."
	      },
	      "insertNode": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.insertNode",
	        "!doc": "Insert a node at the start of a Range."
	      },
	      "surroundContents": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.surroundContents",
	        "!doc": "Moves content of a Range into a new node, placing the new node at the start of the specified range."
	      },
	      "compareBoundaryPoints": {
	        "!type": "fn(how: number, other: +Range) -> number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.compareBoundaryPoints",
	        "!doc": "Compares the boundary points of two Ranges."
	      },
	      "cloneRange": {
	        "!type": "fn() -> +Range",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.cloneRange",
	        "!doc": "Returns a Range object with boundary points identical to the cloned Range."
	      },
	      "detach": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/range.detach",
	        "!doc": "Releases a Range from use to improve performance. This lets the browser choose to release resources associated with this Range. Subsequent attempts to use the detached range will result in a DOMException being thrown with an error code of INVALID_STATE_ERR."
	      },
	      "END_TO_END": "number",
	      "END_TO_START": "number",
	      "START_TO_END": "number",
	      "START_TO_START": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/range.detach",
	    "!doc": "Releases a Range from use to improve performance. This lets the browser choose to release resources associated with this Range. Subsequent attempts to use the detached range will result in a DOMException being thrown with an error code of INVALID_STATE_ERR."
	  },
	  "XMLHttpRequest": {
	    "!type": "fn()",
	    "prototype": {
	      "abort": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Aborts the request if it has already been sent."
	      },
	      "getAllResponseHeaders": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Returns all the response headers as a string, or null if no response has been received. Note: For multipart requests, this returns the headers from the current part of the request, not from the original channel."
	      },
	      "getResponseHeader": {
	        "!type": "fn(header: string) -> string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Returns the string containing the text of the specified header, or null if either the response has not yet been received or the header doesn't exist in the response."
	      },
	      "open": {
	        "!type": "fn(method: string, url: string, async?: bool, user?: string, password?: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Initializes a request."
	      },
	      "overrideMimeType": {
	        "!type": "fn(type: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Overrides the MIME type returned by the server."
	      },
	      "send": {
	        "!type": "fn(data?: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent. If the request is synchronous, this method doesn't return until the response has arrived."
	      },
	      "setRequestHeader": {
	        "!type": "fn(header: string, value: string)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Sets the value of an HTTP request header.You must call setRequestHeader() after open(), but before send()."
	      },
	      "onreadystatechange": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "A JavaScript function object that is called whenever the readyState attribute changes."
	      },
	      "readyState": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The state of the request. (0=unsent, 1=opened, 2=headers_received, 3=loading, 4=done)"
	      },
	      "response": {
	        "!type": "+Document",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The response entity body according to responseType, as an ArrayBuffer, Blob, Document, JavaScript object (for \"json\"), or string. This is null if the request is not complete or was not successful."
	      },
	      "responseText": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The response to the request as text, or null if the request was unsuccessful or has not yet been sent."
	      },
	      "responseType": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "Can be set to change the response type."
	      },
	      "responseXML": {
	        "!type": "+Document",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The response to the request as a DOM Document object, or null if the request was unsuccessful, has not yet been sent, or cannot be parsed as XML or HTML."
	      },
	      "status": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The status of the response to the request. This is the HTTP result code"
	      },
	      "statusText": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	        "!doc": "The response string returned by the HTTP server. Unlike status, this includes the entire text of the response message (\"200 OK\", for example)."
	      },
	      "timeout": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest/Synchronous_and_Asynchronous_Requests",
	        "!doc": "The number of milliseconds a request can take before automatically being terminated. A value of 0 (which is the default) means there is no timeout."
	      },
	      "UNSENT": "number",
	      "OPENED": "number",
	      "HEADERS_RECEIVED": "number",
	      "LOADING": "number",
	      "DONE": "number"
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/XMLHttpRequest",
	    "!doc": "XMLHttpRequest is a JavaScript object that was designed by Microsoft and adopted by Mozilla, Apple, and Google. It's now being standardized in the W3C. It provides an easy way to retrieve data at a URL. Despite its name, XMLHttpRequest can be used to retrieve any type of data, not just XML, and it supports protocols other than HTTP (including file and ftp)."
	  },
	  "DOMParser": {
	    "!type": "fn()",
	    "prototype": {
	      "parseFromString": {
	        "!type": "fn(data: string, mime: string) -> +Document",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/DOMParser",
	        "!doc": "DOMParser can parse XML or HTML source stored in a string into a DOM Document. DOMParser is specified in DOM Parsing and Serialization."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOMParser",
	    "!doc": "DOMParser can parse XML or HTML source stored in a string into a DOM Document. DOMParser is specified in DOM Parsing and Serialization."
	  },
	  "Selection": {
	    "!type": "fn()",
	    "prototype": {
	      "anchorNode": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/anchorNode",
	        "!doc": "Returns the node in which the selection begins."
	      },
	      "anchorOffset": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/anchorOffset",
	        "!doc": "Returns the number of characters that the selection's anchor is offset within the anchorNode."
	      },
	      "focusNode": {
	        "!type": "+Element",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/focusNode",
	        "!doc": "Returns the node in which the selection ends."
	      },
	      "focusOffset": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/focusOffset",
	        "!doc": "Returns the number of characters that the selection's focus is offset within the focusNode. "
	      },
	      "isCollapsed": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/isCollapsed",
	        "!doc": "Returns a boolean indicating whether the selection's start and end points are at the same position."
	      },
	      "rangeCount": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/rangeCount",
	        "!doc": "Returns the number of ranges in the selection."
	      },
	      "getRangeAt": {
	        "!type": "fn(i: number) -> +Range",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/getRangeAt",
	        "!doc": "Returns a range object representing one of the ranges currently selected."
	      },
	      "collapse": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/collapse",
	        "!doc": "Collapses the current selection to a single point. The document is not modified. If the content is focused and editable, the caret will blink there."
	      },
	      "extend": {
	        "!type": "fn(node: +Element, offset: number)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/extend",
	        "!doc": "Moves the focus of the selection to a specified point. The anchor of the selection does not move. The selection will be from the anchor to the new focus regardless of direction."
	      },
	      "collapseToStart": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/collapseToStart",
	        "!doc": "Collapses the selection to the start of the first range in the selection.  If the content of the selection is focused and editable, the caret will blink there."
	      },
	      "collapseToEnd": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/collapseToEnd",
	        "!doc": "Collapses the selection to the end of the last range in the selection.  If the content the selection is in is focused and editable, the caret will blink there."
	      },
	      "selectAllChildren": {
	        "!type": "fn(node: +Element)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/selectAllChildren",
	        "!doc": "Adds all the children of the specified node to the selection. Previous selection is lost."
	      },
	      "addRange": {
	        "!type": "fn(range: +Range)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/addRange",
	        "!doc": "Adds a Range to a Selection."
	      },
	      "removeRange": {
	        "!type": "fn(range: +Range)",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/removeRange",
	        "!doc": "Removes a range from the selection."
	      },
	      "removeAllRanges": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/removeAllRanges",
	        "!doc": "Removes all ranges from the selection, leaving the anchorNode and focusNode properties equal to null and leaving nothing selected. "
	      },
	      "deleteFromDocument": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/deleteFromDocument",
	        "!doc": "Deletes the actual text being represented by a selection object from the document's DOM."
	      },
	      "containsNode": {
	        "!type": "fn(node: +Element) -> bool",
	        "!url": "https://developer.mozilla.org/en/docs/DOM/Selection/containsNode",
	        "!doc": "Indicates if the node is part of the selection."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Selection",
	    "!doc": "Selection is the class of the object returned by window.getSelection() and other methods. It represents the text selection in the greater page, possibly spanning multiple elements, when the user drags over static text and other parts of the page. For information about text selection in an individual text editing element."
	  },
	  "console": {
	    "error": {
	      "!type": "fn(text: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/console.error",
	      "!doc": "Outputs an error message to the Web Console."
	    },
	    "info": {
	      "!type": "fn(text: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/console.info",
	      "!doc": "Outputs an informational message to the Web Console."
	    },
	    "log": {
	      "!type": "fn(text: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/console.log",
	      "!doc": "Outputs a message to the Web Console."
	    },
	    "warn": {
	      "!type": "fn(text: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/console.warn",
	      "!doc": "Outputs a warning message to the Web Console."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/console",
	    "!doc": "The console object provides access to the browser's debugging console. The specifics of how it works vary from browser to browser, but there is a de facto set of features that are typically provided."
	  },
	  "top": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.top",
	    "!doc": "Returns a reference to the topmost window in the window hierarchy."
	  },
	  "parent": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.parent",
	    "!doc": "A reference to the parent of the current window or subframe."
	  },
	  "window": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window",
	    "!doc": "This section provides a brief reference for all of the methods, properties, and events available through the DOM window object. The window object implements the Window interface, which in turn inherits from the AbstractView interface. Some additional global functions, namespaces objects, and constructors, not typically associated with the window, but available on it, are listed in the JavaScript Reference."
	  },
	  "opener": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.opener",
	    "!doc": "Returns a reference to the window that opened this current window."
	  },
	  "self": {
	    "!type": "<top>",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.self",
	    "!doc": "Returns an object reference to the window object. "
	  },
	  "devicePixelRatio": "number",
	  "name": {
	    "!type": "string",
	    "!url": "https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/Function/name",
	    "!doc": "The name of the function."
	  },
	  "closed": {
	    "!type": "bool",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.closed",
	    "!doc": "This property indicates whether the referenced window is closed or not."
	  },
	  "pageYOffset": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollY",
	    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
	  },
	  "pageXOffset": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollX",
	    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
	  },
	  "scrollY": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollY",
	    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
	  },
	  "scrollX": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollX",
	    "!doc": "Returns the number of pixels that the document has already been scrolled vertically."
	  },
	  "screenTop": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.top",
	    "!doc": "Returns the distance in pixels from the top side of the current screen."
	  },
	  "screenLeft": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.left",
	    "!doc": "Returns the distance in pixels from the left side of the main screen to the left side of the current screen."
	  },
	  "screenY": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/event.screenY",
	    "!doc": "Returns the vertical coordinate of the event within the screen as a whole."
	  },
	  "screenX": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/event.screenX",
	    "!doc": "Returns the horizontal coordinate of the event within the screen as a whole."
	  },
	  "innerWidth": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.innerWidth",
	    "!doc": "Width (in pixels) of the browser window viewport including, if rendered, the vertical scrollbar."
	  },
	  "innerHeight": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.innerHeight",
	    "!doc": "Height (in pixels) of the browser window viewport including, if rendered, the horizontal scrollbar."
	  },
	  "outerWidth": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.outerWidth",
	    "!doc": "window.outerWidth gets the width of the outside of the browser window. It represents the width of the whole browser window including sidebar (if expanded), window chrome and window resizing borders/handles."
	  },
	  "outerHeight": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.outerHeight",
	    "!doc": "window.outerHeight gets the height in pixels of the whole browser window."
	  },
	  "frameElement": {
	    "!type": "+Element",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.frameElement",
	    "!doc": "Returns the element (such as <iframe> or <object>) in which the window is embedded, or null if the window is top-level."
	  },
	  "crypto": {
	    "getRandomValues": {
	      "!type": "fn([number])",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.crypto.getRandomValues",
	      "!doc": "This methods lets you get cryptographically random values."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.crypto.getRandomValues",
	    "!doc": "This methods lets you get cryptographically random values."
	  },
	  "navigator": {
	    "appName": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.appName",
	      "!doc": "Returns the name of the browser. The HTML5 specification also allows any browser to return \"Netscape\" here, for compatibility reasons."
	    },
	    "appVersion": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.appVersion",
	      "!doc": "Returns the version of the browser as a string. It may be either a plain version number, like \"5.0\", or a version number followed by more detailed information. The HTML5 specification also allows any browser to return \"4.0\" here, for compatibility reasons."
	    },
	    "language": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.language",
	      "!doc": "Returns a string representing the language version of the browser."
	    },
	    "platform": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.platform",
	      "!doc": "Returns a string representing the platform of the browser."
	    },
	    "plugins": {
	      "!type": "[?]",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.plugins",
	      "!doc": "Returns a PluginArray object, listing the plugins installed in the application."
	    },
	    "userAgent": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.userAgent",
	      "!doc": "Returns the user agent string for the current browser."
	    },
	    "vendor": {
	      "!type": "string",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.vendor",
	      "!doc": "Returns the name of the browser vendor for the current browser."
	    },
	    "javaEnabled": {
	      "!type": "bool",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator.javaEnabled",
	      "!doc": "This method indicates whether the current browser is Java-enabled or not."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.navigator",
	    "!doc": "Returns a reference to the navigator object, which can be queried for information about the application running the script."
	  },
	  "history": {
	    "state": {
	      "!type": "?",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "length": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "go": {
	      "!type": "fn(delta: number)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.history",
	      "!doc": "Returns a reference to the History object, which provides an interface for manipulating the browser session history (pages visited in the tab or frame that the current page is loaded in)."
	    },
	    "forward": {
	      "!type": "fn()",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "back": {
	      "!type": "fn()",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "pushState": {
	      "!type": "fn(data: ?, title: string, url?: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "replaceState": {
	      "!type": "fn(data: ?, title: string, url?: string)",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	      "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Manipulating_the_browser_history",
	    "!doc": "The DOM window object provides access to the browser's history through the history object. It exposes useful methods and properties that let you move back and forth through the user's history, as well as -- starting with HTML5 -- manipulate the contents of the history stack."
	  },
	  "screen": {
	    "availWidth": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availWidth",
	      "!doc": "Returns the amount of horizontal space in pixels available to the window."
	    },
	    "availHeight": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availHeight",
	      "!doc": "Returns the amount of vertical space available to the window on the screen."
	    },
	    "availTop": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availTop",
	      "!doc": "Specifies the y-coordinate of the first pixel that is not allocated to permanent or semipermanent user interface features."
	    },
	    "availLeft": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.availLeft",
	      "!doc": "Returns the first available pixel available from the left side of the screen."
	    },
	    "pixelDepth": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.pixelDepth",
	      "!doc": "Returns the bit depth of the screen."
	    },
	    "colorDepth": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.colorDepth",
	      "!doc": "Returns the color depth of the screen."
	    },
	    "width": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.width",
	      "!doc": "Returns the width of the screen."
	    },
	    "height": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen.height",
	      "!doc": "Returns the height of the screen in pixels."
	    },
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.screen",
	    "!doc": "Returns a reference to the screen object associated with the window."
	  },
	  "postMessage": {
	    "!type": "fn(message: string, targetOrigin: string)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.postMessage",
	    "!doc": "window.postMessage, when called, causes a MessageEvent to be dispatched at the target window when any pending script that must be executed completes (e.g. remaining event handlers if window.postMessage is called from an event handler, previously-set pending timeouts, etc.). The MessageEvent has the type message, a data property which is set to the value of the first argument provided to window.postMessage, an origin property corresponding to the origin of the main document in the window calling window.postMessage at the time window.postMessage was called, and a source property which is the window from which window.postMessage is called. (Other standard properties of events are present with their expected values.)"
	  },
	  "close": {
	    "!type": "fn()",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.close",
	    "!doc": "Closes the current window, or a referenced window."
	  },
	  "blur": {
	    "!type": "fn()",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.blur",
	    "!doc": "The blur method removes keyboard focus from the current element."
	  },
	  "focus": {
	    "!type": "fn()",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.focus",
	    "!doc": "Sets focus on the specified element, if it can be focused."
	  },
	  "onload": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onload",
	    "!doc": "An event handler for the load event of a window."
	  },
	  "onunload": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onunload",
	    "!doc": "The unload event is raised when the window is unloading its content and resources. The resources removal is processed after the unload event occurs."
	  },
	  "onscroll": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onscroll",
	    "!doc": "Specifies the function to be called when the window is scrolled."
	  },
	  "onresize": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onresize",
	    "!doc": "An event handler for the resize event on the window."
	  },
	  "ononline": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/document.ononline",
	    "!doc": ",fgh s dgkljgsdfl dfjg sdlgj sdlg sdlfj dlg jkdfkj dfjgdfkglsdfjsdlfkgj hdflkg hdlkfjgh dfkjgh"
	  },
	  "onoffline": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/Online_and_offline_events",
	    "!doc": "Some browsers implement Online/Offline events from the WHATWG Web Applications 1.0 specification."
	  },
	  "onmousewheel": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/mousewheel",
	    "!doc": "The DOM mousewheel event is fired asynchronously when mouse wheel or similar device is operated. It's represented by the MouseWheelEvent interface."
	  },
	  "onmouseup": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onmouseup",
	    "!doc": "An event handler for the mouseup event on the window."
	  },
	  "onmouseover": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseover",
	    "!doc": "The onmouseover property returns the onMouseOver event handler code on the current element."
	  },
	  "onmouseout": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmouseout",
	    "!doc": "The onmouseout property returns the onMouseOut event handler code on the current element."
	  },
	  "onmousemove": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onmousemove",
	    "!doc": "The onmousemove property returns the mousemove event handler code on the current element."
	  },
	  "onmousedown": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onmousedown",
	    "!doc": "An event handler for the mousedown event on the window."
	  },
	  "onclick": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onclick",
	    "!doc": "The onclick property returns the onClick event handler code on the current element."
	  },
	  "ondblclick": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.ondblclick",
	    "!doc": "The ondblclick property returns the onDblClick event handler code on the current element."
	  },
	  "onmessage": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/Worker",
	    "!doc": "Dedicated Web Workers provide a simple means for web content to run scripts in background threads.  Once created, a worker can send messages to the spawning task by posting messages to an event handler specified by the creator."
	  },
	  "onkeyup": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeyup",
	    "!doc": "The onkeyup property returns the onKeyUp event handler code for the current element."
	  },
	  "onkeypress": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onkeypress",
	    "!doc": "The onkeypress property sets and returns the onKeyPress event handler code for the current element."
	  },
	  "onkeydown": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onkeydown",
	    "!doc": "An event handler for the keydown event on the window."
	  },
	  "oninput": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/DOM_event_reference/input",
	    "!doc": "The DOM input event is fired synchronously when the value of an <input> or <textarea> element is changed. Additionally, it's also fired on contenteditable editors when its contents are changed. In this case, the event target is the editing host element. If there are two or more elements which have contenteditable as true, \"editing host\" is the nearest ancestor element whose parent isn't editable. Similarly, it's also fired on root element of designMode editors."
	  },
	  "onpopstate": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onpopstate",
	    "!doc": "An event handler for the popstate event on the window."
	  },
	  "onhashchange": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onhashchange",
	    "!doc": "The hashchange event fires when a window's hash changes."
	  },
	  "onfocus": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onfocus",
	    "!doc": "The onfocus property returns the onFocus event handler code on the current element."
	  },
	  "onblur": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onblur",
	    "!doc": "The onblur property returns the onBlur event handler code, if any, that exists on the current element."
	  },
	  "onerror": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onerror",
	    "!doc": "An event handler for runtime script errors."
	  },
	  "ondrop": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/drop",
	    "!doc": "The drop event is fired when an element or text selection is dropped on a valid drop target."
	  },
	  "ondragstart": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragstart",
	    "!doc": "The dragstart event is fired when the user starts dragging an element or text selection."
	  },
	  "ondragover": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragover",
	    "!doc": "The dragover event is fired when an element or text selection is being dragged over a valid drop target (every few hundred milliseconds)."
	  },
	  "ondragleave": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragleave",
	    "!doc": "The dragleave event is fired when a dragged element or text selection leaves a valid drop target."
	  },
	  "ondragenter": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragenter",
	    "!doc": "The dragenter event is fired when a dragged element or text selection enters a valid drop target."
	  },
	  "ondragend": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/dragend",
	    "!doc": "The dragend event is fired when a drag operation is being ended (by releasing a mouse button or hitting the escape key)."
	  },
	  "ondrag": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/DOM/Mozilla_event_reference/drag",
	    "!doc": "The drag event is fired when an element or text selection is being dragged (every few hundred milliseconds)."
	  },
	  "oncontextmenu": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.oncontextmenu",
	    "!doc": "An event handler property for right-click events on the window. Unless the default behavior is prevented, the browser context menu will activate (though IE8 has a bug with this and will not activate the context menu if a contextmenu event handler is defined). Note that this event will occur with any non-disabled right-click event and does not depend on an element possessing the \"contextmenu\" attribute."
	  },
	  "onchange": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/element.onchange",
	    "!doc": "The onchange property sets and returns the onChange event handler code for the current element."
	  },
	  "onbeforeunload": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onbeforeunload",
	    "!doc": "An event that fires when a window is about to unload its resources. The document is still visible and the event is still cancelable."
	  },
	  "onabort": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.onabort",
	    "!doc": "An event handler for abort events sent to the window."
	  },
	  "getSelection": {
	    "!type": "fn() -> +Selection",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.getSelection",
	    "!doc": "Returns a selection object representing the range of text selected by the user. "
	  },
	  "alert": {
	    "!type": "fn(message: string)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.alert",
	    "!doc": "Display an alert dialog with the specified content and an OK button."
	  },
	  "confirm": {
	    "!type": "fn(message: string) -> bool",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.confirm",
	    "!doc": "Displays a modal dialog with a message and two buttons, OK and Cancel."
	  },
	  "prompt": {
	    "!type": "fn(message: string, value: string) -> string",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.prompt",
	    "!doc": "Displays a dialog with a message prompting the user to input some text."
	  },
	  "scrollBy": {
	    "!type": "fn(x: number, y: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollBy",
	    "!doc": "Scrolls the document in the window by the given amount."
	  },
	  "scrollTo": {
	    "!type": "fn(x: number, y: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scrollTo",
	    "!doc": "Scrolls to a particular set of coordinates in the document."
	  },
	  "scroll": {
	    "!type": "fn(x: number, y: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.scroll",
	    "!doc": "Scrolls the window to a particular place in the document."
	  },
	  "setTimeout": {
	    "!type": "fn(f: fn(), ms: number) -> number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.setTimeout",
	    "!doc": "Calls a function or executes a code snippet after specified delay."
	  },
	  "clearTimeout": {
	    "!type": "fn(timeout: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.clearTimeout",
	    "!doc": "Clears the delay set by window.setTimeout()."
	  },
	  "setInterval": {
	    "!type": "fn(f: fn(), ms: number) -> number",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.setInterval",
	    "!doc": "Calls a function or executes a code snippet repeatedly, with a fixed time delay between each call to that function."
	  },
	  "clearInterval": {
	    "!type": "fn(interval: number)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.clearInterval",
	    "!doc": "Cancels repeated action which was set up using setInterval."
	  },
	  "atob": {
	    "!type": "fn(encoded: string) -> string",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.atob",
	    "!doc": "Decodes a string of data which has been encoded using base-64 encoding."
	  },
	  "btoa": {
	    "!type": "fn(data: string) -> string",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.btoa",
	    "!doc": "Creates a base-64 encoded ASCII string from a string of binary data."
	  },
	  "addEventListener": {
	    "!type": "fn(type: string, listener: fn(e: +Event), capture: bool)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.addEventListener",
	    "!doc": "Registers a single event listener on a single target. The event target may be a single element in a document, the document itself, a window, or an XMLHttpRequest."
	  },
	  "removeEventListener": {
	    "!type": "fn(type: string, listener: fn(), capture: bool)",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.removeEventListener",
	    "!doc": "Allows the removal of event listeners from the event target."
	  },
	  "dispatchEvent": {
	    "!type": "fn(event: +Event) -> bool",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/EventTarget.dispatchEvent",
	    "!doc": "Dispatches an event into the event system. The event is subject to the same capturing and bubbling behavior as directly dispatched events."
	  },
	  "getComputedStyle": {
	    "!type": "fn(node: +Element, pseudo?: string) -> Element.prototype.style",
	    "!url": "https://developer.mozilla.org/en/docs/DOM/window.getComputedStyle",
	    "!doc": "Gives the final used values of all the CSS properties of an element."
	  },
	  "CanvasRenderingContext2D": {
	    "canvas": "+Element",
	    "width": "number",
	    "height": "number",
	    "commit": "fn()",
	    "save": "fn()",
	    "restore": "fn()",
	    "currentTransform": "?",
	    "scale": "fn(x: number, y: number)",
	    "rotate": "fn(angle: number)",
	    "translate": "fn(x: number, y: number)",
	    "transform": "fn(a: number, b: number, c: number, d: number, e: number, f: number)",
	    "setTransform": "fn(a: number, b: number, c: number, d: number, e: number, f: number)",
	    "resetTransform": "fn()",
	    "globalAlpha": "number",
	    "globalCompositeOperation": "string",
	    "imageSmoothingEnabled": "bool",
	    "strokeStyle": "string",
	    "fillStyle": "string",
	    "createLinearGradient": "fn(x0: number, y0: number, x1: number, y1: number) -> ?",
	    "createPattern": "fn(image: ?, repetition: string) -> ?",
	    "shadowOffsetX": "number",
	    "shadowOffsetY": "number",
	    "shadowBlur": "number",
	    "shadowColor": "string",
	    "clearRect": "fn(x: number, y: number, w: number, h: number)",
	    "fillRect": "fn(x: number, y: number, w: number, h: number)",
	    "strokeRect": "fn(x: number, y: number, w: number, h: number)",
	    "fillRule": "string",
	    "fill": "fn()",
	    "beginPath": "fn()",
	    "stroke": "fn()",
	    "clip": "fn()",
	    "resetClip": "fn()",
	    "measureText": "fn(text: string) -> ?",
	    "drawImage": "fn(image: ?, dx: number, dy: number)",
	    "createImageData": "fn(sw: number, sh: number) -> ?",
	    "getImageData": "fn(sx: number, sy: number, sw: number, sh: number) -> ?",
	    "putImageData": "fn(imagedata: ?, dx: number, dy: number)",
	    "lineWidth": "number",
	    "lineCap": "string",
	    "lineJoin": "string",
	    "miterLimit": "number",
	    "setLineDash": "fn(segments: [number])",
	    "getLineDash": "fn() -> [number]",
	    "lineDashOffset": "number",
	    "font": "string",
	    "textAlign": "string",
	    "textBaseline": "string",
	    "direction": "string",
	    "closePath": "fn()",
	    "moveTo": "fn(x: number, y: number)",
	    "lineTo": "fn(x: number, y: number)",
	    "quadraticCurveTo": "fn(cpx: number, cpy: number, x: number, y: number)",
	    "bezierCurveTo": "fn(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number)",
	    "arcTo": "fn(x1: number, y1: number, x2: number, y2: number, radius: number)",
	    "rect": "fn(x: number, y: number, w: number, h: number)",
	    "arc": "fn(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: bool)",
	    "ellipse": "fn(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise: bool)"
	  }
	}


/***/ },
/* 223 */
/***/ function(module, exports) {

	module.exports = {
	  "!name": "ecma5",
	  "!define": {"Error.prototype": "Error.prototype"},
	  "Infinity": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Infinity",
	    "!doc": "A numeric value representing infinity."
	  },
	  "undefined": {
	    "!type": "?",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/undefined",
	    "!doc": "The value undefined."
	  },
	  "NaN": {
	    "!type": "number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/NaN",
	    "!doc": "A value representing Not-A-Number."
	  },
	  "Object": {
	    "!type": "fn()",
	    "getPrototypeOf": {
	      "!type": "fn(obj: ?) -> ?",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getPrototypeOf",
	      "!doc": "Returns the prototype (i.e. the internal prototype) of the specified object."
	    },
	    "create": {
	      "!type": "fn(proto: ?) -> !custom:Object_create",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create",
	      "!doc": "Creates a new object with the specified prototype object and properties."
	    },
	    "defineProperty": {
	      "!type": "fn(obj: ?, prop: string, desc: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
	      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
	    },
	    "defineProperties": {
	      "!type": "fn(obj: ?, props: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/defineProperty",
	      "!doc": "Defines a new property directly on an object, or modifies an existing property on an object, and returns the object. If you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see this article."
	    },
	    "getOwnPropertyDescriptor": {
	      "!type": "fn(obj: ?, prop: string) -> ?",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor",
	      "!doc": "Returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object."
	    },
	    "keys": {
	      "!type": "fn(obj: ?) -> [string]",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys",
	      "!doc": "Returns an array of a given object's own enumerable properties, in the same order as that provided by a for-in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."
	    },
	    "getOwnPropertyNames": {
	      "!type": "fn(obj: ?) -> [string]",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames",
	      "!doc": "Returns an array of all properties (enumerable or not) found directly upon a given object."
	    },
	    "seal": {
	      "!type": "fn(obj: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/seal",
	      "!doc": "Seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable."
	    },
	    "isSealed": {
	      "!type": "fn(obj: ?) -> bool",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isSealed",
	      "!doc": "Determine if an object is sealed."
	    },
	    "freeze": {
	      "!type": "fn(obj: ?)",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/freeze",
	      "!doc": "Freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen."
	    },
	    "isFrozen": {
	      "!type": "fn(obj: ?) -> bool",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/isFrozen",
	      "!doc": "Determine if an object is frozen."
	    },
	    "prototype": {
	      "!stdProto": "Object",
	      "toString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toString",
	        "!doc": "Returns a string representing the object."
	      },
	      "toLocaleString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/toLocaleString",
	        "!doc": "Returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes."
	      },
	      "valueOf": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/valueOf",
	        "!doc": "Returns the primitive value of the specified object"
	      },
	      "hasOwnProperty": {
	        "!type": "fn(prop: string) -> bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty",
	        "!doc": "Returns a boolean indicating whether the object has the specified property."
	      },
	      "propertyIsEnumerable": {
	        "!type": "fn(prop: string) -> bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable",
	        "!doc": "Returns a Boolean indicating whether the specified property is enumerable."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object",
	    "!doc": "Creates an object wrapper."
	  },
	  "Function": {
	    "!type": "fn(body: string) -> fn()",
	    "prototype": {
	      "!stdProto": "Function",
	      "apply": {
	        "!type": "fn(this: ?, args: [?])",
	        "!effects": [
	          "call and return !this this=!0 !1.<i> !1.<i> !1.<i>"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/apply",
	        "!doc": "Calls a function with a given this value and arguments provided as an array (or an array like object)."
	      },
	      "call": {
	        "!type": "fn(this: ?, args?: ?) -> !this.!ret",
	        "!effects": [
	          "call and return !this this=!0 !1 !2 !3 !4"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/call",
	        "!doc": "Calls a function with a given this value and arguments provided individually."
	      },
	      "bind": {
	        "!type": "fn(this: ?, args?: ?) -> !custom:Function_bind",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind",
	        "!doc": "Creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function was called."
	      },
	      "prototype": "?"
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function",
	    "!doc": "Every function in JavaScript is actually a Function object."
	  },
	  "Array": {
	    "!type": "fn(size: number) -> !custom:Array_ctor",
	    "isArray": {
	      "!type": "fn(value: ?) -> bool",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray",
	      "!doc": "Returns true if an object is an array, false if it is not."
	    },
	    "prototype": {
	      "!stdProto": "Array",
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/length",
	        "!doc": "An unsigned, 32-bit integer that specifies the number of elements in an array."
	      },
	      "concat": {
	        "!type": "fn(other: [?]) -> !this",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/concat",
	        "!doc": "Returns a new array comprised of this array joined with other array(s) and/or value(s)."
	      },
	      "join": {
	        "!type": "fn(separator?: string) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/join",
	        "!doc": "Joins all elements of an array into a string."
	      },
	      "splice": {
	        "!type": "fn(pos: number, amount: number)",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/splice",
	        "!doc": "Changes the content of an array, adding new elements while removing old elements."
	      },
	      "pop": {
	        "!type": "fn() -> !this.<i>",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/pop",
	        "!doc": "Removes the last element from an array and returns that element."
	      },
	      "push": {
	        "!type": "fn(newelt: ?) -> number",
	        "!effects": [
	          "propagate !0 !this.<i>"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/push",
	        "!doc": "Mutates an array by appending the given elements and returning the new length of the array."
	      },
	      "shift": {
	        "!type": "fn() -> !this.<i>",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/shift",
	        "!doc": "Removes the first element from an array and returns that element. This method changes the length of the array."
	      },
	      "unshift": {
	        "!type": "fn(newelt: ?) -> number",
	        "!effects": [
	          "propagate !0 !this.<i>"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/unshift",
	        "!doc": "Adds one or more elements to the beginning of an array and returns the new length of the array."
	      },
	      "slice": {
	        "!type": "fn(from: number, to?: number) -> !this",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/slice",
	        "!doc": "Returns a shallow copy of a portion of an array."
	      },
	      "reverse": {
	        "!type": "fn()",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/reverse",
	        "!doc": "Reverses an array in place.  The first array element becomes the last and the last becomes the first."
	      },
	      "sort": {
	        "!type": "fn(compare?: fn(a: ?, b: ?) -> number)",
	        "!effects": [
	          "call !0 !this.<i> !this.<i>"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort",
	        "!doc": "Sorts the elements of an array in place and returns the array."
	      },
	      "indexOf": {
	        "!type": "fn(elt: ?, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf",
	        "!doc": "Returns the first index at which a given element can be found in the array, or -1 if it is not present."
	      },
	      "lastIndexOf": {
	        "!type": "fn(elt: ?, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/lastIndexOf",
	        "!doc": "Returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting at fromIndex."
	      },
	      "every": {
	        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> bool",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/every",
	        "!doc": "Tests whether all elements in the array pass the test implemented by the provided function."
	      },
	      "some": {
	        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> bool",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/some",
	        "!doc": "Tests whether some element in the array passes the test implemented by the provided function."
	      },
	      "filter": {
	        "!type": "fn(test: fn(elt: ?, i: number) -> bool, context?: ?) -> !this",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/filter",
	        "!doc": "Creates a new array with all elements that pass the test implemented by the provided function."
	      },
	      "forEach": {
	        "!type": "fn(f: fn(elt: ?, i: number), context?: ?)",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach",
	        "!doc": "Executes a provided function once per array element."
	      },
	      "map": {
	        "!type": "fn(f: fn(elt: ?, i: number) -> ?, context?: ?) -> [!0.!ret]",
	        "!effects": [
	          "call !0 this=!1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/map",
	        "!doc": "Creates a new array with the results of calling a provided function on every element in this array."
	      },
	      "reduce": {
	        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number) -> ?, init?: ?) -> !0.!ret",
	        "!effects": [
	          "call !0 !1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/Reduce",
	        "!doc": "Apply a function against an accumulator and each value of the array (from left-to-right) as to reduce it to a single value."
	      },
	      "reduceRight": {
	        "!type": "fn(combine: fn(sum: ?, elt: ?, i: number) -> ?, init?: ?) -> !0.!ret",
	        "!effects": [
	          "call !0 !1 !this.<i> number"
	        ],
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/ReduceRight",
	        "!doc": "Apply a function simultaneously against two values of the array (from right-to-left) as to reduce it to a single value."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array",
	    "!doc": "The JavaScript Array global object is a constructor for arrays, which are high-level, list-like objects."
	  },
	  "String": {
	    "!type": "fn(value: ?) -> string",
	    "fromCharCode": {
	      "!type": "fn(code: number) -> string",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/fromCharCode",
	      "!doc": "Returns a string created by using the specified sequence of Unicode values."
	    },
	    "prototype": {
	      "!stdProto": "String",
	      "length": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en/docs/JavaScript/Reference/Global_Objects/String/length",
	        "!doc": "Represents the length of a string."
	      },
	      "<i>": "string",
	      "charAt": {
	        "!type": "fn(i: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charAt",
	        "!doc": "Returns the specified character from a string."
	      },
	      "charCodeAt": {
	        "!type": "fn(i: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/charCodeAt",
	        "!doc": "Returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000)."
	      },
	      "indexOf": {
	        "!type": "fn(char: string, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/indexOf",
	        "!doc": "Returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex,\nreturns -1 if the value is not found."
	      },
	      "lastIndexOf": {
	        "!type": "fn(char: string, from?: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/lastIndexOf",
	        "!doc": "Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found. The calling string is searched backward, starting at fromIndex."
	      },
	      "substring": {
	        "!type": "fn(from: number, to?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substring",
	        "!doc": "Returns a subset of a string between one index and another, or through the end of the string."
	      },
	      "substr": {
	        "!type": "fn(from: number, length?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/substr",
	        "!doc": "Returns the characters in a string beginning at the specified location through the specified number of characters."
	      },
	      "slice": {
	        "!type": "fn(from: number, to?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/slice",
	        "!doc": "Extracts a section of a string and returns a new string."
	      },
	      "trim": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim",
	        "!doc": "Removes whitespace from both ends of the string."
	      },
	      "trimLeft": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/TrimLeft",
	        "!doc": "Removes whitespace from the left end of the string."
	      },
	      "trimRight": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/TrimRight",
	        "!doc": "Removes whitespace from the right end of the string."
	      },
	      "toUpperCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toUpperCase",
	        "!doc": "Returns the calling string value converted to uppercase."
	      },
	      "toLowerCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLowerCase",
	        "!doc": "Returns the calling string value converted to lowercase."
	      },
	      "toLocaleUpperCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleUpperCase",
	        "!doc": "Returns the calling string value converted to upper case, according to any locale-specific case mappings."
	      },
	      "toLocaleLowerCase": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/toLocaleLowerCase",
	        "!doc": "Returns the calling string value converted to lower case, according to any locale-specific case mappings."
	      },
	      "split": {
	        "!type": "fn(pattern: string) -> [string]",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/split",
	        "!doc": "Splits a String object into an array of strings by separating the string into substrings."
	      },
	      "concat": {
	        "!type": "fn(other: string) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/concat",
	        "!doc": "Combines the text of two or more strings and returns a new string."
	      },
	      "localeCompare": {
	        "!type": "fn(other: string) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/localeCompare",
	        "!doc": "Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order."
	      },
	      "match": {
	        "!type": "fn(pattern: +RegExp) -> [string]",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/match",
	        "!doc": "Used to retrieve the matches when matching a string against a regular expression."
	      },
	      "replace": {
	        "!type": "fn(pattern: +RegExp, replacement: string) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/replace",
	        "!doc": "Returns a new string with some or all matches of a pattern replaced by a replacement.  The pattern can be a string or a RegExp, and the replacement can be a string or a function to be called for each match."
	      },
	      "search": {
	        "!type": "fn(pattern: +RegExp) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/search",
	        "!doc": "Executes the search for a match between a regular expression and this String object."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String",
	    "!doc": "The String global object is a constructor for strings, or a sequence of characters."
	  },
	  "Number": {
	    "!type": "fn(value: ?) -> number",
	    "MAX_VALUE": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MAX_VALUE",
	      "!doc": "The maximum numeric value representable in JavaScript."
	    },
	    "MIN_VALUE": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/MIN_VALUE",
	      "!doc": "The smallest positive numeric value representable in JavaScript."
	    },
	    "POSITIVE_INFINITY": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/POSITIVE_INFINITY",
	      "!doc": "A value representing the positive Infinity value."
	    },
	    "NEGATIVE_INFINITY": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/NEGATIVE_INFINITY",
	      "!doc": "A value representing the negative Infinity value."
	    },
	    "prototype": {
	      "!stdProto": "Number",
	      "toString": {
	        "!type": "fn(radix?: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toString",
	        "!doc": "Returns a string representing the specified Number object"
	      },
	      "toFixed": {
	        "!type": "fn(digits: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed",
	        "!doc": "Formats a number using fixed-point notation"
	      },
	      "toExponential": {
	        "!type": "fn(digits: number) -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toExponential",
	        "!doc": "Returns a string representing the Number object in exponential notation"
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number",
	    "!doc": "The Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor."
	  },
	  "Boolean": {
	    "!type": "fn(value: ?) -> bool",
	    "prototype": {
	      "!stdProto": "Boolean"
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Boolean",
	    "!doc": "The Boolean object is an object wrapper for a boolean value."
	  },
	  "RegExp": {
	    "!type": "fn(source: string, flags?: string)",
	    "prototype": {
	      "!stdProto": "RegExp",
	      "exec": {
	        "!type": "fn(input: string) -> [string]",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/exec",
	        "!doc": "Executes a search for a match in a specified string. Returns a result array, or null."
	      },
	      "compile": {
	        "!type": "fn(source: string, flags?: string)",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	        "!doc": "Creates a regular expression object for matching text with a pattern."
	      },
	      "test": {
	        "!type": "fn(input: string) -> bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/test",
	        "!doc": "Executes the search for a match between a regular expression and a specified string. Returns true or false."
	      },
	      "global": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	        "!doc": "Creates a regular expression object for matching text with a pattern."
	      },
	      "ignoreCase": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	        "!doc": "Creates a regular expression object for matching text with a pattern."
	      },
	      "multiline": {
	        "!type": "bool",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/multiline",
	        "!doc": "Reflects whether or not to search in strings across multiple lines.\n"
	      },
	      "source": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/source",
	        "!doc": "A read-only property that contains the text of the pattern, excluding the forward slashes.\n"
	      },
	      "lastIndex": {
	        "!type": "number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp/lastIndex",
	        "!doc": "A read/write integer property that specifies the index at which to start the next match."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RegExp",
	    "!doc": "Creates a regular expression object for matching text with a pattern."
	  },
	  "Date": {
	    "!type": "fn(ms: number)",
	    "parse": {
	      "!type": "fn(source: string) -> +Date",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/parse",
	      "!doc": "Parses a string representation of a date, and returns the number of milliseconds since January 1, 1970, 00:00:00 UTC."
	    },
	    "UTC": {
	      "!type": "fn(year: number, month: number, date: number, hour?: number, min?: number, sec?: number, ms?: number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/UTC",
	      "!doc": "Accepts the same parameters as the longest form of the constructor, and returns the number of milliseconds in a Date object since January 1, 1970, 00:00:00, universal time."
	    },
	    "now": {
	      "!type": "fn() -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now",
	      "!doc": "Returns the number of milliseconds elapsed since 1 January 1970 00:00:00 UTC."
	    },
	    "prototype": {
	      "toUTCString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toUTCString",
	        "!doc": "Converts a date to a string, using the universal time convention."
	      },
	      "toISOString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toISOString",
	        "!doc": "JavaScript provides a direct way to convert a date object into a string in ISO format, the ISO 8601 Extended Format."
	      },
	      "toDateString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toDateString",
	        "!doc": "Returns the date portion of a Date object in human readable form in American English."
	      },
	      "toTimeString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toTimeString",
	        "!doc": "Returns the time portion of a Date object in human readable form in American English."
	      },
	      "toLocaleDateString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleDateString",
	        "!doc": "Converts a date to a string, returning the \"date\" portion using the operating system's locale's conventions.\n"
	      },
	      "toLocaleTimeString": {
	        "!type": "fn() -> string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/toLocaleTimeString",
	        "!doc": "Converts a date to a string, returning the \"time\" portion using the current locale's conventions."
	      },
	      "getTime": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTime",
	        "!doc": "Returns the numeric value corresponding to the time for the specified date according to universal time."
	      },
	      "getFullYear": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getFullYear",
	        "!doc": "Returns the year of the specified date according to local time."
	      },
	      "getYear": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getYear",
	        "!doc": "Returns the year in the specified date according to local time."
	      },
	      "getMonth": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMonth",
	        "!doc": "Returns the month in the specified date according to local time."
	      },
	      "getUTCMonth": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMonth",
	        "!doc": "Returns the month of the specified date according to universal time.\n"
	      },
	      "getDate": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDate",
	        "!doc": "Returns the day of the month for the specified date according to local time."
	      },
	      "getUTCDate": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDate",
	        "!doc": "Returns the day (date) of the month in the specified date according to universal time.\n"
	      },
	      "getDay": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getDay",
	        "!doc": "Returns the day of the week for the specified date according to local time."
	      },
	      "getUTCDay": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCDay",
	        "!doc": "Returns the day of the week in the specified date according to universal time.\n"
	      },
	      "getHours": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getHours",
	        "!doc": "Returns the hour for the specified date according to local time."
	      },
	      "getUTCHours": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCHours",
	        "!doc": "Returns the hours in the specified date according to universal time.\n"
	      },
	      "getMinutes": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMinutes",
	        "!doc": "Returns the minutes in the specified date according to local time."
	      },
	      "getUTCMinutes": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
	        "!doc": "Creates JavaScript Date instances which let you work with dates and times."
	      },
	      "getSeconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getSeconds",
	        "!doc": "Returns the seconds in the specified date according to local time."
	      },
	      "getUTCSeconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCSeconds",
	        "!doc": "Returns the seconds in the specified date according to universal time.\n"
	      },
	      "getMilliseconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getMilliseconds",
	        "!doc": "Returns the milliseconds in the specified date according to local time."
	      },
	      "getUTCMilliseconds": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getUTCMilliseconds",
	        "!doc": "Returns the milliseconds in the specified date according to universal time.\n"
	      },
	      "getTimezoneOffset": {
	        "!type": "fn() -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset",
	        "!doc": "Returns the time-zone offset from UTC, in minutes, for the current locale."
	      },
	      "setTime": {
	        "!type": "fn(date: +Date) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setTime",
	        "!doc": "Sets the Date object to the time represented by a number of milliseconds since January 1, 1970, 00:00:00 UTC.\n"
	      },
	      "setFullYear": {
	        "!type": "fn(year: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setFullYear",
	        "!doc": "Sets the full year for a specified date according to local time.\n"
	      },
	      "setUTCFullYear": {
	        "!type": "fn(year: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCFullYear",
	        "!doc": "Sets the full year for a specified date according to universal time.\n"
	      },
	      "setMonth": {
	        "!type": "fn(month: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMonth",
	        "!doc": "Set the month for a specified date according to local time."
	      },
	      "setUTCMonth": {
	        "!type": "fn(month: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMonth",
	        "!doc": "Sets the month for a specified date according to universal time.\n"
	      },
	      "setDate": {
	        "!type": "fn(day: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setDate",
	        "!doc": "Sets the day of the month for a specified date according to local time."
	      },
	      "setUTCDate": {
	        "!type": "fn(day: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCDate",
	        "!doc": "Sets the day of the month for a specified date according to universal time.\n"
	      },
	      "setHours": {
	        "!type": "fn(hour: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setHours",
	        "!doc": "Sets the hours for a specified date according to local time, and returns the number of milliseconds since 1 January 1970 00:00:00 UTC until the time represented by the updated Date instance."
	      },
	      "setUTCHours": {
	        "!type": "fn(hour: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCHours",
	        "!doc": "Sets the hour for a specified date according to universal time.\n"
	      },
	      "setMinutes": {
	        "!type": "fn(min: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMinutes",
	        "!doc": "Sets the minutes for a specified date according to local time."
	      },
	      "setUTCMinutes": {
	        "!type": "fn(min: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMinutes",
	        "!doc": "Sets the minutes for a specified date according to universal time.\n"
	      },
	      "setSeconds": {
	        "!type": "fn(sec: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setSeconds",
	        "!doc": "Sets the seconds for a specified date according to local time."
	      },
	      "setUTCSeconds": {
	        "!type": "fn(sec: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCSeconds",
	        "!doc": "Sets the seconds for a specified date according to universal time.\n"
	      },
	      "setMilliseconds": {
	        "!type": "fn(ms: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setMilliseconds",
	        "!doc": "Sets the milliseconds for a specified date according to local time.\n"
	      },
	      "setUTCMilliseconds": {
	        "!type": "fn(ms: number) -> number",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/setUTCMilliseconds",
	        "!doc": "Sets the milliseconds for a specified date according to universal time.\n"
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date",
	    "!doc": "Creates JavaScript Date instances which let you work with dates and times."
	  },
	  "Error": {
	    "!type": "fn(message: string)",
	    "prototype": {
	      "name": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/name",
	        "!doc": "A name for the type of error."
	      },
	      "message": {
	        "!type": "string",
	        "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error/message",
	        "!doc": "A human-readable description of the error."
	      }
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Error",
	    "!doc": "Creates an error object."
	  },
	  "SyntaxError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/SyntaxError",
	    "!doc": "Represents an error when trying to interpret syntactically invalid code."
	  },
	  "ReferenceError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/ReferenceError",
	    "!doc": "Represents an error when a non-existent variable is referenced."
	  },
	  "URIError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/URIError",
	    "!doc": "Represents an error when a malformed URI is encountered."
	  },
	  "EvalError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/EvalError",
	    "!doc": "Represents an error regarding the eval function."
	  },
	  "RangeError": {
	    "!type": "fn(message: string)",
	    "prototype": "Error.prototype",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/RangeError",
	    "!doc": "Represents an error when a number is not within the correct range allowed."
	  },
	  "parseInt": {
	    "!type": "fn(string: string, radix?: number) -> number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseInt",
	    "!doc": "Parses a string argument and returns an integer of the specified radix or base."
	  },
	  "parseFloat": {
	    "!type": "fn(string: string) -> number",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/parseFloat",
	    "!doc": "Parses a string argument and returns a floating point number."
	  },
	  "isNaN": {
	    "!type": "fn(value: number) -> bool",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/isNaN",
	    "!doc": "Determines whether a value is NaN or not. Be careful, this function is broken. You may be interested in ECMAScript 6 Number.isNaN."
	  },
	  "eval": {
	    "!type": "fn(code: string) -> ?",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/eval",
	    "!doc": "Evaluates JavaScript code represented as a string."
	  },
	  "encodeURI": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURI",
	    "!doc": "Encodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \"surrogate\" characters)."
	  },
	  "encodeURIComponent": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent",
	    "!doc": "Encodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two \"surrogate\" characters)."
	  },
	  "decodeURI": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURI",
	    "!doc": "Decodes a Uniform Resource Identifier (URI) previously created by encodeURI or by a similar routine."
	  },
	  "decodeURIComponent": {
	    "!type": "fn(uri: string) -> string",
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/decodeURIComponent",
	    "!doc": "Decodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine."
	  },
	  "Math": {
	    "E": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/E",
	      "!doc": "The base of natural logarithms, e, approximately 2.718."
	    },
	    "LN2": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN2",
	      "!doc": "The natural logarithm of 2, approximately 0.693."
	    },
	    "LN10": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LN10",
	      "!doc": "The natural logarithm of 10, approximately 2.302."
	    },
	    "LOG2E": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG2E",
	      "!doc": "The base 2 logarithm of E (approximately 1.442)."
	    },
	    "LOG10E": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/LOG10E",
	      "!doc": "The base 10 logarithm of E (approximately 0.434)."
	    },
	    "SQRT1_2": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT1_2",
	      "!doc": "The square root of 1/2; equivalently, 1 over the square root of 2, approximately 0.707."
	    },
	    "SQRT2": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/SQRT2",
	      "!doc": "The square root of 2, approximately 1.414."
	    },
	    "PI": {
	      "!type": "number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/PI",
	      "!doc": "The ratio of the circumference of a circle to its diameter, approximately 3.14159."
	    },
	    "abs": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/abs",
	      "!doc": "Returns the absolute value of a number."
	    },
	    "cos": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/cos",
	      "!doc": "Returns the cosine of a number."
	    },
	    "sin": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sin",
	      "!doc": "Returns the sine of a number."
	    },
	    "tan": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/tan",
	      "!doc": "Returns the tangent of a number."
	    },
	    "acos": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/acos",
	      "!doc": "Returns the arccosine (in radians) of a number."
	    },
	    "asin": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/asin",
	      "!doc": "Returns the arcsine (in radians) of a number."
	    },
	    "atan": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan",
	      "!doc": "Returns the arctangent (in radians) of a number."
	    },
	    "atan2": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/atan2",
	      "!doc": "Returns the arctangent of the quotient of its arguments."
	    },
	    "ceil": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/ceil",
	      "!doc": "Returns the smallest integer greater than or equal to a number."
	    },
	    "floor": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/floor",
	      "!doc": "Returns the largest integer less than or equal to a number."
	    },
	    "round": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/round",
	      "!doc": "Returns the value of a number rounded to the nearest integer."
	    },
	    "exp": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/exp",
	      "!doc": "Returns Ex, where x is the argument, and E is Euler's constant, the base of the natural logarithms."
	    },
	    "log": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/log",
	      "!doc": "Returns the natural logarithm (base E) of a number."
	    },
	    "sqrt": {
	      "!type": "fn(number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/sqrt",
	      "!doc": "Returns the square root of a number."
	    },
	    "pow": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/pow",
	      "!doc": "Returns base to the exponent power, that is, baseexponent."
	    },
	    "max": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/max",
	      "!doc": "Returns the largest of zero or more numbers."
	    },
	    "min": {
	      "!type": "fn(number, number) -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/min",
	      "!doc": "Returns the smallest of zero or more numbers."
	    },
	    "random": {
	      "!type": "fn() -> number",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random",
	      "!doc": "Returns a floating-point, pseudo-random number in the range [0, 1) that is, from 0 (inclusive) up to but not including 1 (exclusive), which you can then scale to your desired range."
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math",
	    "!doc": "A built-in object that has properties and methods for mathematical constants and functions."
	  },
	  "JSON": {
	    "parse": {
	      "!type": "fn(json: string) -> ?",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/parse",
	      "!doc": "Parse a string as JSON, optionally transforming the value produced by parsing."
	    },
	    "stringify": {
	      "!type": "fn(value: ?) -> string",
	      "!url": "https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify",
	      "!doc": "Convert a value to JSON, optionally replacing values if a replacer function is specified, or optionally including only the specified properties if a replacer array is specified."
	    },
	    "!url": "https://developer.mozilla.org/en-US/docs/JSON",
	    "!doc": "JSON (JavaScript Object Notation) is a data-interchange format.  It closely resembles a subset of JavaScript syntax, although it is not a strict subset. (See JSON in the JavaScript Reference for full details.)  It is useful when writing any kind of JavaScript-based application, including websites and browser extensions.  For example, you might store user information in JSON format in a cookie, or you might store extension preferences in JSON in a string-valued browser preference."
	  }
	}


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// The Tern server object

	// A server is a stateful object that manages the analysis for a
	// project, and defines an interface for querying the code in the
	// project.

	(function(root, mod) {
	  if (true) // CommonJS
	    return mod(exports, __webpack_require__(225), __webpack_require__(231),
	               __webpack_require__(226), __webpack_require__(229));
	  if (true) // AMD
	    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(225), __webpack_require__(231), __webpack_require__(226), __webpack_require__(229)], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  mod(root.tern || (root.tern = {}), tern, tern.signal, acorn, acorn.walk); // Plain browser env
	})(this, function(exports, infer, signal, acorn, walk) {
	  "use strict";

	  var plugins = Object.create(null);
	  exports.registerPlugin = function(name, init) { plugins[name] = init; };

	  var defaultOptions = exports.defaultOptions = {
	    debug: false,
	    async: false,
	    getFile: function(_f, c) { if (this.async) c(null, null); },
	    normalizeFilename: function(name) { return name },
	    defs: [],
	    plugins: {},
	    fetchTimeout: 1000,
	    dependencyBudget: 20000,
	    reuseInstances: true,
	    stripCRs: false,
	    ecmaVersion: 6,
	    projectDir: "/"
	  };

	  var queryTypes = {
	    completions: {
	      takesFile: true,
	      run: findCompletions
	    },
	    properties: {
	      run: findProperties
	    },
	    type: {
	      takesFile: true,
	      run: findTypeAt
	    },
	    documentation: {
	      takesFile: true,
	      run: findDocs
	    },
	    definition: {
	      takesFile: true,
	      run: findDef
	    },
	    refs: {
	      takesFile: true,
	      fullFile: true,
	      run: findRefs
	    },
	    rename: {
	      takesFile: true,
	      fullFile: true,
	      run: buildRename
	    },
	    files: {
	      run: listFiles
	    }
	  };

	  exports.defineQueryType = function(name, desc) { queryTypes[name] = desc; };

	  function File(name, parent) {
	    this.name = name;
	    this.parent = parent;
	    this.scope = this.text = this.ast = this.lineOffsets = null;
	  }
	  File.prototype.asLineChar = function(pos) { return asLineChar(this, pos); };

	  function parseFile(srv, file) {
	    var options = {
	      directSourceFile: file,
	      allowReturnOutsideFunction: true,
	      allowImportExportEverywhere: true,
	      ecmaVersion: srv.options.ecmaVersion
	    }
	    var text = srv.signalReturnFirst("preParse", file.text, options) || file.text
	    var ast = infer.parse(text, options)
	    srv.signal("postParse", ast, text)
	    return ast
	  }

	  function updateText(file, text, srv) {
	    file.text = srv.options.stripCRs ? text.replace(/\r\n/g, "\n") : text;
	    infer.withContext(srv.cx, function() {
	      file.ast = parseFile(srv, file)
	    });
	    file.lineOffsets = null;
	  }

	  var Server = exports.Server = function(options) {
	    this.cx = null;
	    this.options = options || {};
	    for (var o in defaultOptions) if (!options.hasOwnProperty(o))
	      options[o] = defaultOptions[o];

	    this.projectDir = options.projectDir.replace(/\\/g, "/")
	    if (!/\/$/.test(this.projectDir)) this.projectDir += "/"

	    this.handlers = Object.create(null);
	    this.files = [];
	    this.fileMap = Object.create(null);
	    this.needsPurge = [];
	    this.budgets = Object.create(null);
	    this.uses = 0;
	    this.pending = 0;
	    this.asyncError = null;
	    this.mod = {}

	    this.defs = options.defs.slice(0)
	    this.plugins = Object.create(null)
	    for (var plugin in options.plugins) if (options.plugins.hasOwnProperty(plugin))
	      this.loadPlugin(plugin, options.plugins[plugin])

	    this.reset();
	  };
	  Server.prototype = signal.mixin({
	    addFile: function(name, /*optional*/ text, parent) {
	      // Don't crash when sloppy plugins pass non-existent parent ids
	      if (parent && !(parent in this.fileMap)) parent = null;
	      if (!(name in this.fileMap))
	        name = this.normalizeFilename(name)
	      ensureFile(this, name, parent, text);
	    },
	    delFile: function(name) {
	      var file = this.findFile(name);
	      if (file) {
	        this.needsPurge.push(file.name);
	        this.files.splice(this.files.indexOf(file), 1);
	        delete this.fileMap[name];
	      }
	    },
	    reset: function() {
	      this.signal("reset");
	      this.cx = new infer.Context(this.defs, this);
	      this.uses = 0;
	      this.budgets = Object.create(null);
	      for (var i = 0; i < this.files.length; ++i) {
	        var file = this.files[i];
	        file.scope = null;
	      }
	      this.signal("postReset");
	    },

	    request: function(doc, c) {
	      var inv = invalidDoc(doc);
	      if (inv) return c(inv);

	      var self = this;
	      doRequest(this, doc, function(err, data) {
	        c(err, data);
	        if (self.uses > 40) {
	          self.reset();
	          analyzeAll(self, null, function(){});
	        }
	      });
	    },

	    findFile: function(name) {
	      return this.fileMap[name];
	    },

	    flush: function(c) {
	      var cx = this.cx;
	      analyzeAll(this, null, function(err) {
	        if (err) return c(err);
	        infer.withContext(cx, c);
	      });
	    },

	    startAsyncAction: function() {
	      ++this.pending;
	    },
	    finishAsyncAction: function(err) {
	      if (err) this.asyncError = err;
	      if (--this.pending === 0) this.signal("everythingFetched");
	    },

	    addDefs: function(defs, toFront) {
	      if (toFront) this.defs.unshift(defs)
	      else this.defs.push(defs)

	      if (this.cx) this.reset()
	    },

	    loadPlugin: function(name, options) {
	      if (arguments.length == 1) options = this.options.plugins[name] || true
	      if (name in this.plugins || !(name in plugins) || !options) return
	      this.plugins[name] = true
	      var init = plugins[name](this, options)

	      // This is for backwards-compatibilty. Don't rely on it -- use addDef and on directly
	      if (!init) return
	      if (init.defs) this.addDefs(init.defs, init.loadFirst)
	      if (init.passes) for (var type in init.passes) if (init.passes.hasOwnProperty(type))
	        this.on(type, init.passes[type])
	    },

	    normalizeFilename: function(name) {
	      var norm = this.options.normalizeFilename(name).replace(/\\/g, "/")
	      if (norm.indexOf(this.projectDir) == 0) norm = norm.slice(this.projectDir.length)
	      return norm
	    }
	  });

	  function doRequest(srv, doc, c) {
	    if (doc.query && !queryTypes.hasOwnProperty(doc.query.type))
	      return c("No query type '" + doc.query.type + "' defined");

	    var query = doc.query;
	    // Respond as soon as possible when this just uploads files
	    if (!query) c(null, {});

	    var files = doc.files || [];
	    if (files.length) ++srv.uses;
	    for (var i = 0; i < files.length; ++i) {
	      var file = files[i];
	      if (file.type == "delete")
	        srv.delFile(file.name);
	      else
	        ensureFile(srv, file.name, null, file.type == "full" ? file.text : null);
	    }

	    var timeBudget = typeof doc.timeout == "number" ? [doc.timeout] : null;
	    if (!query) {
	      analyzeAll(srv, timeBudget, function(){});
	      return;
	    }

	    var queryType = queryTypes[query.type];
	    if (queryType.takesFile) {
	      if (typeof query.file != "string") return c(".query.file must be a string");
	      if (!/^#/.test(query.file)) ensureFile(srv, query.file, null);
	    }

	    analyzeAll(srv, timeBudget, function(err) {
	      if (err) return c(err);
	      var file = queryType.takesFile && resolveFile(srv, files, query.file);
	      if (queryType.fullFile && file.type == "part")
	        return c("Can't run a " + query.type + " query on a file fragment");

	      function run() {
	        var result;
	        try {
	          result = queryType.run(srv, query, file);
	        } catch (e) {
	          if (srv.options.debug && e.name != "TernError") console.error(e.stack);
	          return c(e);
	        }
	        c(null, result);
	      }
	      infer.resetGuessing()
	      infer.withContext(srv.cx, timeBudget ? function() { infer.withTimeout(timeBudget[0], run); } : run);
	    });
	  }

	  function analyzeFile(srv, file) {
	    infer.withContext(srv.cx, function() {
	      file.scope = srv.cx.topScope;
	      srv.signal("beforeLoad", file);
	      infer.analyze(file.ast, file.name, file.scope);
	      srv.signal("afterLoad", file);
	    });
	    return file;
	  }

	  function ensureFile(srv, name, parent, text) {
	    var known = srv.findFile(name);
	    if (known) {
	      if (text != null) {
	        if (known.scope) {
	          srv.needsPurge.push(name);
	          known.scope = null;
	        }
	        updateText(known, text, srv);
	      }
	      if (parentDepth(srv, known.parent) > parentDepth(srv, parent)) {
	        known.parent = parent;
	        if (known.excluded) known.excluded = null;
	      }
	      return;
	    }

	    var file = new File(name, parent);
	    srv.files.push(file);
	    srv.fileMap[name] = file;
	    if (text != null) {
	      updateText(file, text, srv);
	    } else if (srv.options.async) {
	      srv.startAsyncAction();
	      srv.options.getFile(name, function(err, text) {
	        updateText(file, text || "", srv);
	        srv.finishAsyncAction(err);
	      });
	    } else {
	      updateText(file, srv.options.getFile(name) || "", srv);
	    }
	  }

	  function fetchAll(srv, c) {
	    var done = true, returned = false;
	    srv.files.forEach(function(file) {
	      if (file.text != null) return;
	      if (srv.options.async) {
	        done = false;
	        srv.options.getFile(file.name, function(err, text) {
	          if (err && !returned) { returned = true; return c(err); }
	          updateText(file, text || "", srv);
	          fetchAll(srv, c);
	        });
	      } else {
	        try {
	          updateText(file, srv.options.getFile(file.name) || "", srv);
	        } catch (e) { return c(e); }
	      }
	    });
	    if (done) c();
	  }

	  function waitOnFetch(srv, timeBudget, c) {
	    var done = function() {
	      srv.off("everythingFetched", done);
	      clearTimeout(timeout);
	      analyzeAll(srv, timeBudget, c);
	    };
	    srv.on("everythingFetched", done);
	    var timeout = setTimeout(done, srv.options.fetchTimeout);
	  }

	  function analyzeAll(srv, timeBudget, c) {
	    if (srv.pending) return waitOnFetch(srv, timeBudget, c);

	    var e = srv.fetchError;
	    if (e) { srv.fetchError = null; return c(e); }

	    if (srv.needsPurge.length > 0) infer.withContext(srv.cx, function() {
	      infer.purge(srv.needsPurge);
	      srv.needsPurge.length = 0;
	    });

	    var done = true;
	    // The second inner loop might add new files. The outer loop keeps
	    // repeating both inner loops until all files have been looked at.
	    for (var i = 0; i < srv.files.length;) {
	      var toAnalyze = [];
	      for (; i < srv.files.length; ++i) {
	        var file = srv.files[i];
	        if (file.text == null) done = false;
	        else if (file.scope == null && !file.excluded) toAnalyze.push(file);
	      }
	      toAnalyze.sort(function(a, b) {
	        return parentDepth(srv, a.parent) - parentDepth(srv, b.parent);
	      });
	      for (var j = 0; j < toAnalyze.length; j++) {
	        var file = toAnalyze[j];
	        if (file.parent && !chargeOnBudget(srv, file)) {
	          file.excluded = true;
	        } else if (timeBudget) {
	          var startTime = +new Date;
	          infer.withTimeout(timeBudget[0], function() { analyzeFile(srv, file); });
	          timeBudget[0] -= +new Date - startTime;
	        } else {
	          analyzeFile(srv, file);
	        }
	      }
	    }
	    if (done) c();
	    else waitOnFetch(srv, timeBudget, c);
	  }

	  function firstLine(str) {
	    var end = str.indexOf("\n");
	    if (end < 0) return str;
	    return str.slice(0, end);
	  }

	  function findMatchingPosition(line, file, near) {
	    var pos = Math.max(0, near - 500), closest = null;
	    if (!/^\s*$/.test(line)) for (;;) {
	      var found = file.indexOf(line, pos);
	      if (found < 0 || found > near + 500) break;
	      if (closest == null || Math.abs(closest - near) > Math.abs(found - near))
	        closest = found;
	      pos = found + line.length;
	    }
	    return closest;
	  }

	  function scopeDepth(s) {
	    for (var i = 0; s; ++i, s = s.prev) {}
	    return i;
	  }

	  function ternError(msg) {
	    var err = new Error(msg);
	    err.name = "TernError";
	    return err;
	  }

	  function resolveFile(srv, localFiles, name) {
	    var isRef = name.match(/^#(\d+)$/);
	    if (!isRef) return srv.findFile(name);

	    var file = localFiles[isRef[1]];
	    if (!file || file.type == "delete") throw ternError("Reference to unknown file " + name);
	    if (file.type == "full") return srv.findFile(file.name);

	    // This is a partial file

	    var realFile = file.backing = srv.findFile(file.name);
	    var offset = file.offset;
	    if (file.offsetLines) offset = {line: file.offsetLines, ch: 0};
	    file.offset = offset = resolvePos(realFile, file.offsetLines == null ? file.offset : {line: file.offsetLines, ch: 0}, true);
	    var line = firstLine(file.text);
	    var foundPos = findMatchingPosition(line, realFile.text, offset);
	    var pos = foundPos == null ? Math.max(0, realFile.text.lastIndexOf("\n", offset)) : foundPos;
	    var inObject, atFunction;

	    infer.withContext(srv.cx, function() {
	      infer.purge(file.name, pos, pos + file.text.length);

	      var text = file.text, m;
	      if (m = text.match(/(?:"([^"]*)"|([\w$]+))\s*:\s*function\b/)) {
	        var objNode = walk.findNodeAround(file.backing.ast, pos, "ObjectExpression");
	        if (objNode && objNode.node.objType)
	          inObject = {type: objNode.node.objType, prop: m[2] || m[1]};
	      }
	      if (foundPos && (m = line.match(/^(.*?)\bfunction\b/))) {
	        var cut = m[1].length, white = "";
	        for (var i = 0; i < cut; ++i) white += " ";
	        file.text = white + text.slice(cut);
	        atFunction = true;
	      }

	      var scopeStart = infer.scopeAt(realFile.ast, pos, realFile.scope);
	      var scopeEnd = infer.scopeAt(realFile.ast, pos + text.length, realFile.scope);
	      var scope = file.scope = scopeDepth(scopeStart) < scopeDepth(scopeEnd) ? scopeEnd : scopeStart;
	      file.ast = parseFile(srv, file)
	      infer.analyze(file.ast, file.name, scope);

	      // This is a kludge to tie together the function types (if any)
	      // outside and inside of the fragment, so that arguments and
	      // return values have some information known about them.
	      tieTogether: if (inObject || atFunction) {
	        var newInner = infer.scopeAt(file.ast, line.length, scopeStart);
	        if (!newInner.fnType) break tieTogether;
	        if (inObject) {
	          var prop = inObject.type.getProp(inObject.prop);
	          prop.addType(newInner.fnType);
	        } else if (atFunction) {
	          var inner = infer.scopeAt(realFile.ast, pos + line.length, realFile.scope);
	          if (inner == scopeStart || !inner.fnType) break tieTogether;
	          var fOld = inner.fnType, fNew = newInner.fnType;
	          if (!fNew || (fNew.name != fOld.name && fOld.name)) break tieTogether;
	          for (var i = 0, e = Math.min(fOld.args.length, fNew.args.length); i < e; ++i)
	            fOld.args[i].propagate(fNew.args[i]);
	          fOld.self.propagate(fNew.self);
	          fNew.retval.propagate(fOld.retval);
	        }
	      }
	    });
	    return file;
	  }

	  // Budget management

	  function astSize(node) {
	    var size = 0;
	    walk.simple(node, {Expression: function() { ++size; }});
	    return size;
	  }

	  function parentDepth(srv, parent) {
	    var depth = 0;
	    while (parent) {
	      parent = srv.findFile(parent).parent;
	      ++depth;
	    }
	    return depth;
	  }

	  function budgetName(srv, file) {
	    for (;;) {
	      var parent = srv.findFile(file.parent);
	      if (!parent.parent) break;
	      file = parent;
	    }
	    return file.name;
	  }

	  function chargeOnBudget(srv, file) {
	    var bName = budgetName(srv, file);
	    var size = astSize(file.ast);
	    var known = srv.budgets[bName];
	    if (known == null)
	      known = srv.budgets[bName] = srv.options.dependencyBudget;
	    if (known < size) return false;
	    srv.budgets[bName] = known - size;
	    return true;
	  }

	  // Query helpers

	  function isPosition(val) {
	    return typeof val == "number" || typeof val == "object" &&
	      typeof val.line == "number" && typeof val.ch == "number";
	  }

	  // Baseline query document validation
	  function invalidDoc(doc) {
	    if (doc.query) {
	      if (typeof doc.query.type != "string") return ".query.type must be a string";
	      if (doc.query.start && !isPosition(doc.query.start)) return ".query.start must be a position";
	      if (doc.query.end && !isPosition(doc.query.end)) return ".query.end must be a position";
	    }
	    if (doc.files) {
	      if (!Array.isArray(doc.files)) return "Files property must be an array";
	      for (var i = 0; i < doc.files.length; ++i) {
	        var file = doc.files[i];
	        if (typeof file != "object") return ".files[n] must be objects";
	        else if (typeof file.name != "string") return ".files[n].name must be a string";
	        else if (file.type == "delete") continue;
	        else if (typeof file.text != "string") return ".files[n].text must be a string";
	        else if (file.type == "part") {
	          if (!isPosition(file.offset) && typeof file.offsetLines != "number")
	            return ".files[n].offset must be a position";
	        } else if (file.type != "full") return ".files[n].type must be \"full\" or \"part\"";
	      }
	    }
	  }

	  var offsetSkipLines = 25;

	  function findLineStart(file, line) {
	    var text = file.text, offsets = file.lineOffsets || (file.lineOffsets = [0]);
	    var pos = 0, curLine = 0;
	    var storePos = Math.min(Math.floor(line / offsetSkipLines), offsets.length - 1);
	    var pos = offsets[storePos], curLine = storePos * offsetSkipLines;

	    while (curLine < line) {
	      ++curLine;
	      pos = text.indexOf("\n", pos) + 1;
	      if (pos === 0) return null;
	      if (curLine % offsetSkipLines === 0) offsets.push(pos);
	    }
	    return pos;
	  }

	  var resolvePos = exports.resolvePos = function(file, pos, tolerant) {
	    if (typeof pos != "number") {
	      var lineStart = findLineStart(file, pos.line);
	      if (lineStart == null) {
	        if (tolerant) pos = file.text.length;
	        else throw ternError("File doesn't contain a line " + pos.line);
	      } else {
	        pos = lineStart + pos.ch;
	      }
	    }
	    if (pos > file.text.length) {
	      if (tolerant) pos = file.text.length;
	      else throw ternError("Position " + pos + " is outside of file.");
	    }
	    return pos;
	  };

	  function asLineChar(file, pos) {
	    if (!file) return {line: 0, ch: 0};
	    var offsets = file.lineOffsets || (file.lineOffsets = [0]);
	    var text = file.text, line, lineStart;
	    for (var i = offsets.length - 1; i >= 0; --i) if (offsets[i] <= pos) {
	      line = i * offsetSkipLines;
	      lineStart = offsets[i];
	    }
	    for (;;) {
	      var eol = text.indexOf("\n", lineStart);
	      if (eol >= pos || eol < 0) break;
	      lineStart = eol + 1;
	      ++line;
	    }
	    return {line: line, ch: pos - lineStart};
	  }

	  var outputPos = exports.outputPos = function(query, file, pos) {
	    if (query.lineCharPositions) {
	      var out = asLineChar(file, pos);
	      if (file.type == "part")
	        out.line += file.offsetLines != null ? file.offsetLines : asLineChar(file.backing, file.offset).line;
	      return out;
	    } else {
	      return pos + (file.type == "part" ? file.offset : 0);
	    }
	  };

	  // Delete empty fields from result objects
	  function clean(obj) {
	    for (var prop in obj) if (obj[prop] == null) delete obj[prop];
	    return obj;
	  }
	  function maybeSet(obj, prop, val) {
	    if (val != null) obj[prop] = val;
	  }

	  // Built-in query types

	  function compareCompletions(a, b) {
	    if (typeof a != "string") { a = a.name; b = b.name; }
	    var aUp = /^[A-Z]/.test(a), bUp = /^[A-Z]/.test(b);
	    if (aUp == bUp) return a < b ? -1 : a == b ? 0 : 1;
	    else return aUp ? 1 : -1;
	  }

	  function isStringAround(node, start, end) {
	    return node.type == "Literal" && typeof node.value == "string" &&
	      node.start == start - 1 && node.end <= end + 1;
	  }

	  function pointInProp(objNode, point) {
	    for (var i = 0; i < objNode.properties.length; i++) {
	      var curProp = objNode.properties[i];
	      if (curProp.key.start <= point && curProp.key.end >= point)
	        return curProp;
	    }
	  }

	  var jsKeywords = ("break do instanceof typeof case else new var " +
	    "catch finally return void continue for switch while debugger " +
	    "function this with default if throw delete in try").split(" ");

	  var addCompletion = exports.addCompletion = function(query, completions, name, aval, depth) {
	    var typeInfo = query.types || query.docs || query.urls || query.origins;
	    var wrapAsObjs = typeInfo || query.depths;

	    for (var i = 0; i < completions.length; ++i) {
	      var c = completions[i];
	      if ((wrapAsObjs ? c.name : c) == name) return;
	    }
	    var rec = wrapAsObjs ? {name: name} : name;
	    completions.push(rec);

	    if (aval && typeInfo) {
	      infer.resetGuessing();
	      var type = aval.getType();
	      rec.guess = infer.didGuess();
	      if (query.types)
	        rec.type = infer.toString(aval);
	      if (query.docs)
	        maybeSet(rec, "doc", parseDoc(query, aval.doc || type && type.doc));
	      if (query.urls)
	        maybeSet(rec, "url", aval.url || type && type.url);
	      if (query.origins)
	        maybeSet(rec, "origin", aval.origin || type && type.origin);
	    }
	    if (query.depths) rec.depth = depth || 0;
	    return rec;
	  };

	  function findCompletions(srv, query, file) {
	    if (query.end == null) throw ternError("missing .query.end field");
	    var fromPlugin = srv.signalReturnFirst("completion", file, query)
	    if (fromPlugin) return fromPlugin

	    var wordStart = resolvePos(file, query.end), wordEnd = wordStart, text = file.text;
	    while (wordStart && acorn.isIdentifierChar(text.charCodeAt(wordStart - 1))) --wordStart;
	    if (query.expandWordForward !== false)
	      while (wordEnd < text.length && acorn.isIdentifierChar(text.charCodeAt(wordEnd))) ++wordEnd;
	    var word = text.slice(wordStart, wordEnd), completions = [], ignoreObj;
	    if (query.caseInsensitive) word = word.toLowerCase();

	    function gather(prop, obj, depth, addInfo) {
	      // 'hasOwnProperty' and such are usually just noise, leave them
	      // out when no prefix is provided.
	      if ((objLit || query.omitObjectPrototype !== false) && obj == srv.cx.protos.Object && !word) return;
	      if (query.filter !== false && word &&
	          (query.caseInsensitive ? prop.toLowerCase() : prop).indexOf(word) !== 0) return;
	      if (ignoreObj && ignoreObj.props[prop]) return;
	      var result = addCompletion(query, completions, prop, obj && obj.props[prop], depth);
	      if (addInfo && result && typeof result != "string") addInfo(result);
	    }

	    var hookname, prop, objType, isKey;

	    var exprAt = infer.findExpressionAround(file.ast, null, wordStart, file.scope);
	    var memberExpr, objLit;
	    // Decide whether this is an object property, either in a member
	    // expression or an object literal.
	    if (exprAt) {
	      var exprNode = exprAt.node;
	      if (exprNode.type == "MemberExpression" && exprNode.object.end < wordStart) {
	        memberExpr = exprAt;
	      } else if (isStringAround(exprNode, wordStart, wordEnd)) {
	        var parent = infer.parentNode(exprNode, file.ast);
	        if (parent.type == "MemberExpression" && parent.property == exprNode)
	          memberExpr = {node: parent, state: exprAt.state};
	      } else if (exprNode.type == "ObjectExpression") {
	        var objProp = pointInProp(exprNode, wordEnd);
	        if (objProp) {
	          objLit = exprAt;
	          prop = isKey = objProp.key.name;
	        } else if (!word && !/:\s*$/.test(file.text.slice(0, wordStart))) {
	          objLit = exprAt;
	          prop = isKey = true;
	        }
	      }
	    }

	    if (objLit) {
	      // Since we can't use the type of the literal itself to complete
	      // its properties (it doesn't contain the information we need),
	      // we have to try asking the surrounding expression for type info.
	      objType = infer.typeFromContext(file.ast, objLit);
	      ignoreObj = objLit.node.objType;
	    } else if (memberExpr) {
	      prop = memberExpr.node.property;
	      prop = prop.type == "Literal" ? prop.value.slice(1) : prop.name;
	      memberExpr.node = memberExpr.node.object;
	      objType = infer.expressionType(memberExpr);
	    } else if (text.charAt(wordStart - 1) == ".") {
	      var pathStart = wordStart - 1;
	      while (pathStart && (text.charAt(pathStart - 1) == "." || acorn.isIdentifierChar(text.charCodeAt(pathStart - 1)))) pathStart--;
	      var path = text.slice(pathStart, wordStart - 1);
	      if (path) {
	        objType = infer.def.parsePath(path, file.scope).getObjType();
	        prop = word;
	      }
	    }

	    if (prop != null) {
	      srv.cx.completingProperty = prop;

	      if (objType) infer.forAllPropertiesOf(objType, gather);

	      if (!completions.length && query.guess !== false && objType && objType.guessProperties)
	        objType.guessProperties(function(p, o, d) {if (p != prop && p != "✖") gather(p, o, d);});
	      if (!completions.length && word.length >= 2 && query.guess !== false)
	        for (var prop in srv.cx.props) gather(prop, srv.cx.props[prop][0], 0);
	      hookname = "memberCompletion";
	    } else {
	      infer.forAllLocalsAt(file.ast, wordStart, file.scope, gather);
	      if (query.includeKeywords) jsKeywords.forEach(function(kw) {
	        gather(kw, null, 0, function(rec) { rec.isKeyword = true; });
	      });
	      hookname = "variableCompletion";
	    }
	    srv.signal(hookname, file, wordStart, wordEnd, gather)

	    if (query.sort !== false) completions.sort(compareCompletions);
	    srv.cx.completingProperty = null;

	    return {start: outputPos(query, file, wordStart),
	            end: outputPos(query, file, wordEnd),
	            isProperty: !!prop,
	            isObjectKey: !!isKey,
	            completions: completions};
	  }

	  function findProperties(srv, query) {
	    var prefix = query.prefix, found = [];
	    for (var prop in srv.cx.props)
	      if (prop != "<i>" && (!prefix || prop.indexOf(prefix) === 0)) found.push(prop);
	    if (query.sort !== false) found.sort(compareCompletions);
	    return {completions: found};
	  }

	  var findExpr = exports.findQueryExpr = function(file, query, wide) {
	    if (query.end == null) throw ternError("missing .query.end field");

	    if (query.variable) {
	      var scope = infer.scopeAt(file.ast, resolvePos(file, query.end), file.scope);
	      return {node: {type: "Identifier", name: query.variable, start: query.end, end: query.end + 1},
	              state: scope};
	    } else {
	      var start = query.start && resolvePos(file, query.start), end = resolvePos(file, query.end);
	      var expr = infer.findExpressionAt(file.ast, start, end, file.scope);
	      if (expr) return expr;
	      expr = infer.findExpressionAround(file.ast, start, end, file.scope);
	      if (expr && (expr.node.type == "ObjectExpression" || wide ||
	                   (start == null ? end : start) - expr.node.start < 20 || expr.node.end - end < 20))
	        return expr;
	      return null;
	    }
	  };

	  function findExprOrThrow(file, query, wide) {
	    var expr = findExpr(file, query, wide);
	    if (expr) return expr;
	    throw ternError("No expression at the given position.");
	  }

	  function ensureObj(tp) {
	    if (!tp || !(tp = tp.getType()) || !(tp instanceof infer.Obj)) return null;
	    return tp;
	  }

	  function findExprType(srv, query, file, expr) {
	    var type;
	    if (expr) {
	      infer.resetGuessing();
	      type = infer.expressionType(expr);
	    }
	    var typeHandlers = srv.hasHandler("typeAt")
	    if (typeHandlers) {
	      var pos = resolvePos(file, query.end)
	      for (var i = 0; i < typeHandlers.length; i++)
	        type = typeHandlers[i](file, pos, expr, type)
	    }
	    if (!type) throw ternError("No type found at the given position.");

	    var objProp;
	    if (expr.node.type == "ObjectExpression" && query.end != null &&
	        (objProp = pointInProp(expr.node, resolvePos(file, query.end)))) {
	      var name = objProp.key.name;
	      var fromCx = ensureObj(infer.typeFromContext(file.ast, expr));
	      if (fromCx && fromCx.hasProp(name)) {
	        type = fromCx.hasProp(name);
	      } else {
	        var fromLocal = ensureObj(type);
	        if (fromLocal && fromLocal.hasProp(name))
	          type = fromLocal.hasProp(name);
	      }
	    }
	    return type;
	  };

	  function findTypeAt(srv, query, file) {
	    var expr = findExpr(file, query), exprName;
	    var type = findExprType(srv, query, file, expr), exprType = type;
	    if (query.preferFunction)
	      type = type.getFunctionType() || type.getType();
	    else
	      type = type.getType();

	    if (expr) {
	      if (expr.node.type == "Identifier")
	        exprName = expr.node.name;
	      else if (expr.node.type == "MemberExpression" && !expr.node.computed)
	        exprName = expr.node.property.name;
	    }

	    if (query.depth != null && typeof query.depth != "number")
	      throw ternError(".query.depth must be a number");

	    var result = {guess: infer.didGuess(),
	                  type: infer.toString(exprType, query.depth),
	                  name: type && type.name,
	                  exprName: exprName,
	                  doc: exprType.doc,
	                  url: exprType.url};
	    if (type) storeTypeDocs(query, type, result);

	    return clean(result);
	  }

	  function parseDoc(query, doc) {
	    if (!doc) return null;
	    if (query.docFormat == "full") return doc;
	    var parabreak = /.\n[\s@\n]/.exec(doc);
	    if (parabreak) doc = doc.slice(0, parabreak.index + 1);
	    doc = doc.replace(/\n\s*/g, " ");
	    if (doc.length < 100) return doc;
	    var sentenceEnd = /[\.!?] [A-Z]/g;
	    sentenceEnd.lastIndex = 80;
	    var found = sentenceEnd.exec(doc);
	    if (found) doc = doc.slice(0, found.index + 1);
	    return doc;
	  }

	  function findDocs(srv, query, file) {
	    var expr = findExpr(file, query);
	    var type = findExprType(srv, query, file, expr);
	    var result = {url: type.url, doc: parseDoc(query, type.doc), type: infer.toString(type)};
	    var inner = type.getType();
	    if (inner) storeTypeDocs(query, inner, result);
	    return clean(result);
	  }

	  function storeTypeDocs(query, type, out) {
	    if (!out.url) out.url = type.url;
	    if (!out.doc) out.doc = parseDoc(query, type.doc);
	    if (!out.origin) out.origin = type.origin;
	    var ctor, boring = infer.cx().protos;
	    if (!out.url && !out.doc && type.proto && (ctor = type.proto.hasCtor) &&
	        type.proto != boring.Object && type.proto != boring.Function && type.proto != boring.Array) {
	      out.url = ctor.url;
	      out.doc = parseDoc(query, ctor.doc);
	    }
	  }

	  var getSpan = exports.getSpan = function(obj) {
	    if (!obj.origin) return;
	    if (obj.originNode) {
	      var node = obj.originNode;
	      if (/^Function/.test(node.type) && node.id) node = node.id;
	      return {origin: obj.origin, node: node};
	    }
	    if (obj.span) return {origin: obj.origin, span: obj.span};
	  };

	  var storeSpan = exports.storeSpan = function(srv, query, span, target) {
	    target.origin = span.origin;
	    if (span.span) {
	      var m = /^(\d+)\[(\d+):(\d+)\]-(\d+)\[(\d+):(\d+)\]$/.exec(span.span);
	      target.start = query.lineCharPositions ? {line: Number(m[2]), ch: Number(m[3])} : Number(m[1]);
	      target.end = query.lineCharPositions ? {line: Number(m[5]), ch: Number(m[6])} : Number(m[4]);
	    } else {
	      var file = srv.findFile(span.origin);
	      target.start = outputPos(query, file, span.node.start);
	      target.end = outputPos(query, file, span.node.end);
	    }
	  };

	  function findDef(srv, query, file) {
	    var expr = findExpr(file, query);
	    var type = findExprType(srv, query, file, expr);
	    if (infer.didGuess()) return {};

	    var span = getSpan(type);
	    var result = {url: type.url, doc: parseDoc(query, type.doc), origin: type.origin};

	    if (type.types) for (var i = type.types.length - 1; i >= 0; --i) {
	      var tp = type.types[i];
	      storeTypeDocs(query, tp, result);
	      if (!span) span = getSpan(tp);
	    }

	    if (span && span.node) { // refers to a loaded file
	      var spanFile = span.node.sourceFile || srv.findFile(span.origin);
	      var start = outputPos(query, spanFile, span.node.start), end = outputPos(query, spanFile, span.node.end);
	      result.start = start; result.end = end;
	      result.file = span.origin;
	      var cxStart = Math.max(0, span.node.start - 50);
	      result.contextOffset = span.node.start - cxStart;
	      result.context = spanFile.text.slice(cxStart, cxStart + 50);
	    } else if (span) { // external
	      result.file = span.origin;
	      storeSpan(srv, query, span, result);
	    }
	    return clean(result);
	  }

	  function findRefsToVariable(srv, query, file, expr, checkShadowing) {
	    var name = expr.node.name;

	    for (var scope = expr.state; scope && !(name in scope.props); scope = scope.prev) {}
	    if (!scope) throw ternError("Could not find a definition for " + name);

	    var type, refs = [];
	    function storeRef(file) {
	      return function(node, scopeHere) {
	        if (checkShadowing) for (var s = scopeHere; s != scope; s = s.prev) {
	          var exists = s.hasProp(checkShadowing);
	          if (exists)
	            throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would make a variable at line " +
	                            (asLineChar(file, node.start).line + 1) + " point to the definition at line " +
	                            (asLineChar(file, exists.name.start).line + 1));
	        }
	        refs.push({file: file.name,
	                   start: outputPos(query, file, node.start),
	                   end: outputPos(query, file, node.end)});
	      };
	    }

	    if (scope.originNode) {
	      type = "local";
	      if (checkShadowing) {
	        for (var prev = scope.prev; prev; prev = prev.prev)
	          if (checkShadowing in prev.props) break;
	        if (prev) infer.findRefs(scope.originNode, scope, checkShadowing, prev, function(node) {
	          throw ternError("Renaming `" + name + "` to `" + checkShadowing + "` would shadow the definition used at line " +
	                          (asLineChar(file, node.start).line + 1));
	        });
	      }
	      infer.findRefs(scope.originNode, scope, name, scope, storeRef(file));
	    } else {
	      type = "global";
	      for (var i = 0; i < srv.files.length; ++i) {
	        var cur = srv.files[i];
	        infer.findRefs(cur.ast, cur.scope, name, scope, storeRef(cur));
	      }
	    }

	    return {refs: refs, type: type, name: name};
	  }

	  function findRefsToProperty(srv, query, expr, prop) {
	    var objType = infer.expressionType(expr).getObjType();
	    if (!objType) throw ternError("Couldn't determine type of base object.");

	    var refs = [];
	    function storeRef(file) {
	      return function(node) {
	        refs.push({file: file.name,
	                   start: outputPos(query, file, node.start),
	                   end: outputPos(query, file, node.end)});
	      };
	    }
	    for (var i = 0; i < srv.files.length; ++i) {
	      var cur = srv.files[i];
	      infer.findPropRefs(cur.ast, cur.scope, objType, prop.name, storeRef(cur));
	    }

	    return {refs: refs, name: prop.name};
	  }

	  function findRefs(srv, query, file) {
	    var expr = findExprOrThrow(file, query, true);
	    if (expr && expr.node.type == "Identifier") {
	      return findRefsToVariable(srv, query, file, expr);
	    } else if (expr && expr.node.type == "MemberExpression" && !expr.node.computed) {
	      var p = expr.node.property;
	      expr.node = expr.node.object;
	      return findRefsToProperty(srv, query, expr, p);
	    } else if (expr && expr.node.type == "ObjectExpression") {
	      var pos = resolvePos(file, query.end);
	      for (var i = 0; i < expr.node.properties.length; ++i) {
	        var k = expr.node.properties[i].key;
	        if (k.start <= pos && k.end >= pos)
	          return findRefsToProperty(srv, query, expr, k);
	      }
	    }
	    throw ternError("Not at a variable or property name.");
	  }

	  function buildRename(srv, query, file) {
	    if (typeof query.newName != "string") throw ternError(".query.newName should be a string");
	    var expr = findExprOrThrow(file, query);
	    if (!expr || expr.node.type != "Identifier") throw ternError("Not at a variable.");

	    var data = findRefsToVariable(srv, query, file, expr, query.newName), refs = data.refs;
	    delete data.refs;
	    data.files = srv.files.map(function(f){return f.name;});

	    var changes = data.changes = [];
	    for (var i = 0; i < refs.length; ++i) {
	      var use = refs[i];
	      use.text = query.newName;
	      changes.push(use);
	    }

	    return data;
	  }

	  function listFiles(srv) {
	    return {files: srv.files.map(function(f){return f.name;})};
	  }

	  exports.version = "0.16.0";
	});


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Main type inference engine

	// Walks an AST, building up a graph of abstract values and constraints
	// that cause types to flow from one node to another. Also defines a
	// number of utilities for accessing ASTs and scopes.

	// Analysis is done in a context, which is tracked by the dynamically
	// bound cx variable. Use withContext to set the current context.

	// For memory-saving reasons, individual types export an interface
	// similar to abstract values (which can hold multiple types), and can
	// thus be used in place abstract values that only ever contain a
	// single type.

	(function(root, mod) {
	  if (true) // CommonJS
	    return mod(exports, __webpack_require__(226), __webpack_require__(228), __webpack_require__(229),
	               __webpack_require__(230), __webpack_require__(231));
	  if (true) // AMD
	    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(226), __webpack_require__(228), __webpack_require__(229), __webpack_require__(230), __webpack_require__(231)], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  mod(root.tern || (root.tern = {}), acorn, acorn, acorn.walk, tern.def, tern.signal); // Plain browser env
	})(this, function(exports, acorn, acorn_loose, walk, def, signal) {
	  "use strict";

	  var toString = exports.toString = function(type, maxDepth, parent) {
	    if (!type || type == parent || maxDepth && maxDepth < -3) return "?";
	    return type.toString(maxDepth, parent);
	  };

	  // A variant of AVal used for unknown, dead-end values. Also serves
	  // as prototype for AVals, Types, and Constraints because it
	  // implements 'empty' versions of all the methods that the code
	  // expects.
	  var ANull = exports.ANull = signal.mixin({
	    addType: function() {},
	    propagate: function() {},
	    getProp: function() { return ANull; },
	    forAllProps: function() {},
	    hasType: function() { return false; },
	    isEmpty: function() { return true; },
	    getFunctionType: function() {},
	    getObjType: function() {},
	    getSymbolType: function() {},
	    getType: function() {},
	    gatherProperties: function() {},
	    propagatesTo: function() {},
	    typeHint: function() {},
	    propHint: function() {},
	    toString: function() { return "?"; }
	  });

	  function extend(proto, props) {
	    var obj = Object.create(proto);
	    if (props) for (var prop in props) obj[prop] = props[prop];
	    return obj;
	  }

	  // ABSTRACT VALUES

	  var WG_DEFAULT = 100, WG_NEW_INSTANCE = 90, WG_MADEUP_PROTO = 10,
	      WG_MULTI_MEMBER = 6, WG_CATCH_ERROR = 6,
	      WG_PHANTOM_OBJ = 1,
	      WG_GLOBAL_THIS = 90, WG_SPECULATIVE_THIS = 2, WG_SPECULATIVE_PROTO_THIS = 4;

	  var AVal = exports.AVal = function() {
	    this.types = [];
	    this.forward = null;
	    this.maxWeight = 0;
	  };
	  AVal.prototype = extend(ANull, {
	    addType: function(type, weight) {
	      weight = weight || WG_DEFAULT;
	      if (this.maxWeight < weight) {
	        this.maxWeight = weight;
	        if (this.types.length == 1 && this.types[0] == type) return;
	        this.types.length = 0;
	      } else if (this.maxWeight > weight || this.types.indexOf(type) > -1) {
	        return;
	      }

	      this.signal("addType", type);
	      this.types.push(type);
	      var forward = this.forward;
	      if (forward) withWorklist(function(add) {
	        for (var i = 0; i < forward.length; ++i) add(type, forward[i], weight);
	      });
	    },

	    propagate: function(target, weight) {
	      if (target == ANull || (target instanceof Type && this.forward && this.forward.length > 2)) return;
	      if (weight && weight != WG_DEFAULT) target = new Muffle(target, weight);
	      (this.forward || (this.forward = [])).push(target);
	      var types = this.types;
	      if (types.length) withWorklist(function(add) {
	        for (var i = 0; i < types.length; ++i) add(types[i], target, weight);
	      });
	    },

	    getProp: function(prop) {
	      if (prop == "__proto__" || prop == "✖") return ANull;
	      var found = (this.props || (this.props = Object.create(null)))[prop];
	      if (!found) {
	        found = this.props[prop] = new AVal;
	        this.propagate(new GetProp(prop, found));
	      }
	      return found;
	    },

	    forAllProps: function(c) {
	      this.propagate(new ForAllProps(c));
	    },

	    hasType: function(type) {
	      return this.types.indexOf(type) > -1;
	    },
	    isEmpty: function() { return this.types.length === 0; },
	    getFunctionType: function() {
	      for (var i = this.types.length - 1; i >= 0; --i)
	        if (this.types[i] instanceof Fn) return this.types[i];
	    },
	    getObjType: function() {
	      var seen = null;
	      for (var i = this.types.length - 1; i >= 0; --i) {
	        var type = this.types[i];
	        if (!(type instanceof Obj)) continue;
	        if (type.name) return type;
	        if (!seen) seen = type;
	      }
	      return seen;
	    },

	    getSymbolType: function() {
	      for (var i = this.types.length - 1; i >= 0; --i)
	        if (this.types[i] instanceof Sym) return this.types[i]
	    },

	    getType: function(guess) {
	      if (this.types.length === 0 && guess !== false) return this.makeupType();
	      if (this.types.length === 1) return this.types[0];
	      return canonicalType(this.types);
	    },

	    toString: function(maxDepth, parent) {
	      if (this.types.length == 0) return toString(this.makeupType(), maxDepth, parent);
	      if (this.types.length == 1) return toString(this.types[0], maxDepth, parent);
	      var simplified = simplifyTypes(this.types);
	      if (simplified.length > 2) return "?";
	      return simplified.map(function(tp) { return toString(tp, maxDepth, parent); }).join("|");
	    },

	    makeupPropType: function(obj) {
	      var propName = this.propertyName;

	      var protoProp = obj.proto && obj.proto.hasProp(propName);
	      if (protoProp) {
	        var fromProto = protoProp.getType();
	        if (fromProto) return fromProto;
	      }

	      if (propName != "<i>") {
	        var computedProp = obj.hasProp("<i>");
	        if (computedProp) return computedProp.getType();
	      } else if (obj.props["<i>"] != this) {
	        for (var prop in obj.props) {
	          var val = obj.props[prop];
	          if (!val.isEmpty()) return val.getType();
	        }
	      }
	    },

	    makeupType: function() {
	      var computed = this.propertyOf && this.makeupPropType(this.propertyOf);
	      if (computed) return computed;

	      if (!this.forward) return null;
	      for (var i = this.forward.length - 1; i >= 0; --i) {
	        var hint = this.forward[i].typeHint();
	        if (hint && !hint.isEmpty()) {guessing = true; return hint;}
	      }

	      var props = Object.create(null), foundProp = null;
	      for (var i = 0; i < this.forward.length; ++i) {
	        var prop = this.forward[i].propHint();
	        if (prop && prop != "length" && prop != "<i>" && prop != "✖" && prop != cx.completingProperty) {
	          props[prop] = true;
	          foundProp = prop;
	        }
	      }
	      if (!foundProp) return null;

	      var objs = objsWithProp(foundProp);
	      if (objs) {
	        var matches = [];
	        search: for (var i = 0; i < objs.length; ++i) {
	          var obj = objs[i];
	          for (var prop in props) if (!obj.hasProp(prop)) continue search;
	          if (obj.hasCtor) obj = getInstance(obj);
	          matches.push(obj);
	        }
	        var canon = canonicalType(matches);
	        if (canon) {guessing = true; return canon;}
	      }
	    },

	    typeHint: function() { return this.types.length ? this.getType() : null; },
	    propagatesTo: function() { return this; },

	    gatherProperties: function(f, depth) {
	      for (var i = 0; i < this.types.length; ++i)
	        this.types[i].gatherProperties(f, depth);
	    },

	    guessProperties: function(f) {
	      if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
	        var prop = this.forward[i].propHint();
	        if (prop) f(prop, null, 0);
	      }
	      var guessed = this.makeupType();
	      if (guessed) guessed.gatherProperties(f);
	    }
	  });

	  function similarAVal(a, b, depth) {
	    var typeA = a.getType(false), typeB = b.getType(false);
	    if (!typeA || !typeB) return true;
	    return similarType(typeA, typeB, depth);
	  }

	  function similarType(a, b, depth) {
	    if (!a || depth >= 5) return b;
	    if (!a || a == b) return a;
	    if (!b) return a;
	    if (a.constructor != b.constructor) return false;
	    if (a.constructor == Arr) {
	      var innerA = a.getProp("<i>").getType(false);
	      if (!innerA) return b;
	      var innerB = b.getProp("<i>").getType(false);
	      if (!innerB || similarType(innerA, innerB, depth + 1)) return b;
	    } else if (a.constructor == Obj) {
	      var propsA = 0, propsB = 0, same = 0;
	      for (var prop in a.props) {
	        propsA++;
	        if (prop in b.props && similarAVal(a.props[prop], b.props[prop], depth + 1))
	          same++;
	      }
	      for (var prop in b.props) propsB++;
	      if (propsA && propsB && same < Math.max(propsA, propsB) / 2) return false;
	      return propsA > propsB ? a : b;
	    } else if (a.constructor == Fn) {
	      if (a.args.length != b.args.length ||
	          !a.args.every(function(tp, i) { return similarAVal(tp, b.args[i], depth + 1); }) ||
	          !similarAVal(a.retval, b.retval, depth + 1) || !similarAVal(a.self, b.self, depth + 1))
	        return false;
	      return a;
	    } else {
	      return false;
	    }
	  }

	  var simplifyTypes = exports.simplifyTypes = function(types) {
	    var found = [];
	    outer: for (var i = 0; i < types.length; ++i) {
	      var tp = types[i];
	      for (var j = 0; j < found.length; j++) {
	        var similar = similarType(tp, found[j], 0);
	        if (similar) {
	          found[j] = similar;
	          continue outer;
	        }
	      }
	      found.push(tp);
	    }
	    return found;
	  };

	  function canonicalType(types) {
	    var arrays = 0, fns = 0, objs = 0, prim = null;
	    for (var i = 0; i < types.length; ++i) {
	      var tp = types[i];
	      if (tp instanceof Arr) ++arrays;
	      else if (tp instanceof Fn) ++fns;
	      else if (tp instanceof Obj) ++objs;
	      else if (tp instanceof Prim) {
	        if (prim && tp.name != prim.name) return null;
	        prim = tp;
	      }
	    }
	    var kinds = (arrays && 1) + (fns && 1) + (objs && 1) + (prim && 1);
	    if (kinds > 1) return null;
	    if (prim) return prim;

	    var maxScore = 0, maxTp = null;
	    for (var i = 0; i < types.length; ++i) {
	      var tp = types[i], score = 0;
	      if (arrays) {
	        score = tp.getProp("<i>").isEmpty() ? 1 : 2;
	      } else if (fns) {
	        score = 1;
	        for (var j = 0; j < tp.args.length; ++j) if (!tp.args[j].isEmpty()) ++score;
	        if (!tp.retval.isEmpty()) ++score;
	      } else if (objs) {
	        score = tp.name ? 100 : 2;
	      }
	      if (score >= maxScore) { maxScore = score; maxTp = tp; }
	    }
	    return maxTp;
	  }

	  // PROPAGATION STRATEGIES

	  var constraint = exports.constraint = function(methods) {
	    var ctor = function() {
	      this.origin = cx.curOrigin;
	      this.construct.apply(this, arguments);
	    };
	    ctor.prototype = Object.create(ANull);
	    for (var m in methods) if (methods.hasOwnProperty(m)) ctor.prototype[m] = methods[m];
	    return ctor;
	  };

	  var GetProp = constraint({
	    construct: function(prop, target) {
	      this.prop = prop; this.target = target;
	    },
	    addType: function(type, weight) {
	      if (type.getProp)
	        type.getProp(this.prop).propagate(this.target, weight);
	    },
	    propHint: function() { return this.prop; },
	    propagatesTo: function() {
	      if (this.prop == "<i>" || !/[^\w_]/.test(this.prop))
	        return {target: this.target, pathExt: "." + this.prop};
	    }
	  });

	  var DefProp = exports.PropHasSubset = exports.DefProp = constraint({
	    construct: function(prop, type, originNode) {
	      this.prop = prop; this.type = type; this.originNode = originNode;
	    },
	    addType: function(type, weight) {
	      if (!(type instanceof Obj)) return;
	      var prop = type.defProp(this.prop, this.originNode);
	      if (!prop.origin) prop.origin = this.origin;
	      this.type.propagate(prop, weight);
	    },
	    propHint: function() { return this.prop; }
	  });

	  var ForAllProps = constraint({
	    construct: function(c) { this.c = c; },
	    addType: function(type) {
	      if (!(type instanceof Obj)) return;
	      type.forAllProps(this.c);
	    }
	  });

	  function withDisabledComputing(fn, body) {
	    cx.disabledComputing = {fn: fn, prev: cx.disabledComputing};
	    var result = body();
	    cx.disabledComputing = cx.disabledComputing.prev;
	    return result;
	  }
	  var IsCallee = exports.IsCallee = constraint({
	    construct: function(self, args, argNodes, retval) {
	      this.self = self; this.args = args; this.argNodes = argNodes; this.retval = retval;
	      this.disabled = cx.disabledComputing;
	    },
	    addType: function(fn, weight) {
	      if (!(fn instanceof Fn)) return;
	      for (var i = 0; i < this.args.length; ++i) {
	        if (i < fn.args.length) this.args[i].propagate(fn.args[i], weight);
	        if (fn.arguments) this.args[i].propagate(fn.arguments, weight);
	      }
	      this.self.propagate(fn.self, this.self == cx.topScope ? WG_GLOBAL_THIS : weight);
	      var compute = fn.computeRet, result = fn.retval
	      if (compute) for (var d = this.disabled; d; d = d.prev)
	        if (d.fn == fn || fn.originNode && d.fn.originNode == fn.originNode) compute = null;
	      if (compute) {
	        var old = cx.disabledComputing;
	        cx.disabledComputing = this.disabled;
	        result = compute(this.self, this.args, this.argNodes)
	        cx.disabledComputing = old;
	      }
	      maybeIterator(fn, result).propagate(this.retval, weight)
	    },
	    typeHint: function() {
	      var names = [];
	      for (var i = 0; i < this.args.length; ++i) names.push("?");
	      return new Fn(null, this.self, this.args, names, ANull);
	    },
	    propagatesTo: function() {
	      return {target: this.retval, pathExt: ".!ret"};
	    }
	  });

	  var HasMethodCall = constraint({
	    construct: function(propName, args, argNodes, retval) {
	      this.propName = propName; this.args = args; this.argNodes = argNodes; this.retval = retval;
	      this.disabled = cx.disabledComputing;
	    },
	    addType: function(obj, weight) {
	      var callee = new IsCallee(obj, this.args, this.argNodes, this.retval);
	      callee.disabled = this.disabled;
	      obj.getProp(this.propName).propagate(callee, weight);
	    },
	    propHint: function() { return this.propName; }
	  });

	  var IsCtor = exports.IsCtor = constraint({
	    construct: function(target, noReuse) {
	      this.target = target; this.noReuse = noReuse;
	    },
	    addType: function(f, weight) {
	      if (!(f instanceof Fn)) return;
	      if (cx.parent && !cx.parent.options.reuseInstances) this.noReuse = true;
	      f.getProp("prototype").propagate(new IsProto(this.noReuse ? false : f, this.target), weight);
	    }
	  });

	  var getInstance = exports.getInstance = function(obj, ctor) {
	    if (ctor === false) return new Obj(obj);

	    if (!ctor) ctor = obj.hasCtor;
	    if (!obj.instances) obj.instances = [];
	    for (var i = 0; i < obj.instances.length; ++i) {
	      var cur = obj.instances[i];
	      if (cur.ctor == ctor) return cur.instance;
	    }
	    var instance = new Obj(obj, ctor && ctor.name);
	    instance.origin = obj.origin;
	    obj.instances.push({ctor: ctor, instance: instance});
	    return instance;
	  };

	  var IsProto = exports.IsProto = constraint({
	    construct: function(ctor, target) {
	      this.ctor = ctor; this.target = target;
	    },
	    addType: function(o, _weight) {
	      if (!(o instanceof Obj)) return;
	      if ((this.count = (this.count || 0) + 1) > 8) return;
	      if (o == cx.protos.Array)
	        this.target.addType(new Arr);
	      else
	        this.target.addType(getInstance(o, this.ctor));
	    }
	  });

	  var FnPrototype = constraint({
	    construct: function(fn) { this.fn = fn; },
	    addType: function(o, _weight) {
	      if (o instanceof Obj && !o.hasCtor) {
	        o.hasCtor = this.fn;
	        var adder = new SpeculativeThis(o, this.fn);
	        adder.addType(this.fn);
	        o.forAllProps(function(_prop, val, local) {
	          if (local) val.propagate(adder);
	        });
	      }
	    }
	  });

	  var IsAdded = constraint({
	    construct: function(other, target) {
	      this.other = other; this.target = target;
	    },
	    addType: function(type, weight) {
	      if (type == cx.str)
	        this.target.addType(cx.str, weight);
	      else if (type == cx.num && this.other.hasType(cx.num))
	        this.target.addType(cx.num, weight);
	    },
	    typeHint: function() { return this.other; }
	  });

	  var IfObj = exports.IfObj = constraint({
	    construct: function(target) { this.target = target; },
	    addType: function(t, weight) {
	      if (t instanceof Obj) this.target.addType(t, weight);
	    },
	    propagatesTo: function() { return this.target; }
	  });

	  var SpeculativeThis = constraint({
	    construct: function(obj, ctor) { this.obj = obj; this.ctor = ctor; },
	    addType: function(tp) {
	      if (tp instanceof Fn && tp.self)
	        tp.self.addType(getInstance(this.obj, this.ctor), WG_SPECULATIVE_PROTO_THIS);
	    }
	  });

	  var HasProto = constraint({
	    construct: function(obj) { this.obj = obj },
	    addType: function(tp) {
	      if (tp instanceof Obj && this.obj.proto == cx.protos.Object)
	        this.obj.replaceProto(tp)
	    }
	  });

	  var Muffle = constraint({
	    construct: function(inner, weight) {
	      this.inner = inner; this.weight = weight;
	    },
	    addType: function(tp, weight) {
	      this.inner.addType(tp, Math.min(weight, this.weight));
	    },
	    propagatesTo: function() { return this.inner.propagatesTo(); },
	    typeHint: function() { return this.inner.typeHint(); },
	    propHint: function() { return this.inner.propHint(); }
	  });

	  // TYPE OBJECTS

	  var Type = exports.Type = function() {};
	  Type.prototype = extend(ANull, {
	    constructor: Type,
	    propagate: function(c, w) { c.addType(this, w); },
	    hasType: function(other) { return other == this; },
	    isEmpty: function() { return false; },
	    typeHint: function() { return this; },
	    getType: function() { return this; }
	  });

	  var Prim = exports.Prim = function(proto, name) { this.name = name; this.proto = proto; };
	  Prim.prototype = extend(Type.prototype, {
	    constructor: Prim,
	    toString: function() { return this.name; },
	    getProp: function(prop) {return this.proto.hasProp(prop) || ANull;},
	    gatherProperties: function(f, depth) {
	      if (this.proto) this.proto.gatherProperties(f, depth);
	    }
	  });

	  function isInteger(str) {
	    var c0 = str.charCodeAt(0)
	    if (c0 >= 48 && c0 <= 57) return !/\D/.test(str)
	    else return false
	  }

	  var Obj = exports.Obj = function(proto, name) {
	    if (!this.props) this.props = Object.create(null);
	    this.proto = proto === true ? cx.protos.Object : proto;
	    if (proto && !name && proto.name && !(this instanceof Fn)) {
	      var match = /^(.*)\.prototype$/.exec(this.proto.name);
	      if (match) name = match[1];
	    }
	    this.name = name;
	    this.maybeProps = null;
	    this.origin = cx.curOrigin;
	  };
	  Obj.prototype = extend(Type.prototype, {
	    constructor: Obj,
	    toString: function(maxDepth) {
	      if (maxDepth == null) maxDepth = 0;
	      if (maxDepth <= 0 && this.name) return this.name;
	      var props = [], etc = false;
	      for (var prop in this.props) if (prop != "<i>") {
	        if (props.length > 5) { etc = true; break; }
	        if (maxDepth)
	          props.push(prop + ": " + toString(this.props[prop], maxDepth - 1, this));
	        else
	          props.push(prop);
	      }
	      props.sort();
	      if (etc) props.push("...");
	      return "{" + props.join(", ") + "}";
	    },
	    hasProp: function(prop, searchProto) {
	      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
	      var found = this.props[prop];
	      if (searchProto !== false)
	        for (var p = this.proto; p && !found; p = p.proto) found = p.props[prop];
	      return found;
	    },
	    defProp: function(prop, originNode) {
	      var found = this.hasProp(prop, false);
	      if (found) {
	        if (originNode && !found.originNode) found.originNode = originNode;
	        return found;
	      }
	      if (prop == "__proto__" || prop == "✖") return ANull;
	      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)

	      var av = this.maybeProps && this.maybeProps[prop];
	      if (av) {
	        delete this.maybeProps[prop];
	        this.maybeUnregProtoPropHandler();
	      } else {
	        av = new AVal;
	        av.propertyOf = this;
	        av.propertyName = prop;
	      }

	      this.props[prop] = av;
	      av.originNode = originNode;
	      av.origin = cx.curOrigin;
	      this.broadcastProp(prop, av, true);
	      return av;
	    },
	    getProp: function(prop) {
	      var found = this.hasProp(prop, true) || (this.maybeProps && this.maybeProps[prop]);
	      if (found) return found;
	      if (prop == "__proto__" || prop == "✖") return ANull;
	      if (isInteger(prop)) prop = this.normalizeIntegerProp(prop)
	      var av = this.ensureMaybeProps()[prop] = new AVal;
	      av.propertyOf = this;
	      av.propertyName = prop;
	      return av;
	    },
	    normalizeIntegerProp: function(_) { return "<i>" },
	    broadcastProp: function(prop, val, local) {
	      if (local) {
	        this.signal("addProp", prop, val);
	        // If this is a scope, it shouldn't be registered
	        if (!(this instanceof Scope)) registerProp(prop, this);
	      }

	      if (this.onNewProp) for (var i = 0; i < this.onNewProp.length; ++i) {
	        var h = this.onNewProp[i];
	        h.onProtoProp ? h.onProtoProp(prop, val, local) : h(prop, val, local);
	      }
	    },
	    onProtoProp: function(prop, val, _local) {
	      var maybe = this.maybeProps && this.maybeProps[prop];
	      if (maybe) {
	        delete this.maybeProps[prop];
	        this.maybeUnregProtoPropHandler();
	        this.proto.getProp(prop).propagate(maybe);
	      }
	      this.broadcastProp(prop, val, false);
	    },
	    replaceProto: function(proto) {
	      if (this.proto && this.maybeProps)
	        this.proto.unregPropHandler(this)
	      this.proto = proto
	      if (this.maybeProps)
	        this.proto.forAllProps(this)
	    },
	    ensureMaybeProps: function() {
	      if (!this.maybeProps) {
	        if (this.proto) this.proto.forAllProps(this);
	        this.maybeProps = Object.create(null);
	      }
	      return this.maybeProps;
	    },
	    removeProp: function(prop) {
	      var av = this.props[prop];
	      delete this.props[prop];
	      this.ensureMaybeProps()[prop] = av;
	      av.types.length = 0;
	    },
	    forAllProps: function(c) {
	      if (!this.onNewProp) {
	        this.onNewProp = [];
	        if (this.proto) this.proto.forAllProps(this);
	      }
	      this.onNewProp.push(c);
	      for (var o = this; o; o = o.proto) for (var prop in o.props) {
	        if (c.onProtoProp)
	          c.onProtoProp(prop, o.props[prop], o == this);
	        else
	          c(prop, o.props[prop], o == this);
	      }
	    },
	    maybeUnregProtoPropHandler: function() {
	      if (this.maybeProps) {
	        for (var _n in this.maybeProps) return;
	        this.maybeProps = null;
	      }
	      if (!this.proto || this.onNewProp && this.onNewProp.length) return;
	      this.proto.unregPropHandler(this);
	    },
	    unregPropHandler: function(handler) {
	      for (var i = 0; i < this.onNewProp.length; ++i)
	        if (this.onNewProp[i] == handler) { this.onNewProp.splice(i, 1); break; }
	      this.maybeUnregProtoPropHandler();
	    },
	    gatherProperties: function(f, depth) {
	      for (var prop in this.props) if (prop != "<i>" && prop.charAt(0) != ":")
	        f(prop, this, depth);
	      if (this.proto) this.proto.gatherProperties(f, depth + 1);
	    },
	    getObjType: function() { return this; }
	  });

	  var Fn = exports.Fn = function(name, self, args, argNames, retval, generator) {
	    Obj.call(this, cx.protos.Function, name);
	    this.self = self;
	    this.args = args;
	    this.argNames = argNames;
	    this.retval = retval;
	    this.generator = generator
	  };
	  Fn.prototype = extend(Obj.prototype, {
	    constructor: Fn,
	    toString: function(maxDepth) {
	      if (maxDepth == null) maxDepth = 0;
	      var str = this.generator ? "fn*(" : "fn(";
	      for (var i = 0; i < this.args.length; ++i) {
	        if (i) str += ", ";
	        var name = this.argNames[i];
	        if (name && name != "?") str += name + ": ";
	        str += maxDepth > -3 ? toString(this.args[i], maxDepth - 1, this) : "?";
	      }
	      str += ")";
	      if (!this.retval.isEmpty())
	        str += " -> " + (maxDepth > -3 ? toString(this.retval, maxDepth - 1, this) : "?");
	      return str;
	    },
	    getProp: function(prop) {
	      if (prop == "prototype") {
	        var known = this.hasProp(prop, false);
	        if (!known) {
	          known = this.defProp(prop);
	          var proto = new Obj(true, this.name && this.name + ".prototype");
	          proto.origin = this.origin;
	          known.addType(proto, WG_MADEUP_PROTO);
	        }
	        return known;
	      }
	      return Obj.prototype.getProp.call(this, prop);
	    },
	    defProp: function(prop, originNode) {
	      if (prop == "prototype") {
	        var found = this.hasProp(prop, false);
	        if (found) return found;
	        found = Obj.prototype.defProp.call(this, prop, originNode);
	        found.origin = this.origin;
	        found.propagate(new FnPrototype(this));
	        return found;
	      }
	      return Obj.prototype.defProp.call(this, prop, originNode);
	    },
	    getFunctionType: function() { return this; }
	  });

	  var Arr = exports.Arr = function(contentType) {
	    Obj.call(this, cx.protos.Array)
	    var content = this.defProp("<i>")
	    if (Array.isArray(contentType)) {
	      this.tuple = contentType.length
	      for (var i = 0; i < contentType.length; i++) {
	        var prop = this.defProp(String(i))
	        contentType[i].propagate(prop)
	        prop.propagate(content)
	      }
	    } else if (contentType) {
	      this.tuple = 0
	      contentType.propagate(content)
	    }
	  };
	  Arr.prototype = extend(Obj.prototype, {
	    constructor: Arr,
	    toString: function(maxDepth) {
	      if (maxDepth == null) maxDepth = 0
	      if (maxDepth <= -3) return "[?]"
	      var content = ""
	      if (this.tuple) {
	        var similar
	        for (var i = 0; i in this.props; i++) {
	          var type = toString(this.getProp(String(i)), maxDepth - 1, this)
	          if (similar == null)
	            similar = type
	          else if (similar != type)
	            similar = false
	          else
	            similar = type
	          content += (content ? ", " : "") + type
	        }
	        if (similar) content = similar
	      } else {
	        content = toString(this.getProp("<i>"), maxDepth - 1, this)
	      }
	      return "[" + content + "]"
	    },
	    normalizeIntegerProp: function(prop) {
	      if (+prop < this.tuple) return prop
	      else return "<i>"
	    }
	  });

	  var Sym = exports.Sym = function(name, originNode) {
	    Prim.call(this, cx.protos.Symbol, "Symbol")
	    this.symName = name
	    this.originNode = originNode
	  }
	  Sym.prototype = extend(Prim.prototype, {
	    constructor: Sym,
	    asPropName: function() { return ":" + this.symName },
	    getSymbolType: function() { return this }
	  })

	  exports.getSymbol = function(name, originNode) {
	    var cleanName = name.replace(/[^\w$\.]/g, "_")
	    var known = cx.symbols[cleanName]
	    if (known) {
	      if (originNode && !known.originNode) known.originNode = originNode
	      return known
	    }
	    return cx.symbols[cleanName] = new Sym(cleanName, originNode)
	  }

	  // THE PROPERTY REGISTRY

	  function registerProp(prop, obj) {
	    var data = cx.props[prop] || (cx.props[prop] = []);
	    data.push(obj);
	  }

	  function objsWithProp(prop) {
	    return cx.props[prop];
	  }

	  // INFERENCE CONTEXT

	  exports.Context = function(defs, parent) {
	    this.parent = parent;
	    this.props = Object.create(null);
	    this.protos = Object.create(null);
	    this.origins = [];
	    this.curOrigin = "ecma5";
	    this.paths = Object.create(null);
	    this.definitions = Object.create(null);
	    this.purgeGen = 0;
	    this.workList = null;
	    this.disabledComputing = null;
	    this.curSuperCtor = this.curSuper = null;
	    this.symbols = Object.create(null)

	    exports.withContext(this, function() {
	      cx.protos.Object = new Obj(null, "Object.prototype");
	      cx.topScope = new Scope();
	      cx.topScope.name = "<top>";
	      cx.protos.Array = new Obj(true, "Array.prototype");
	      cx.protos.Function = new Fn("Function.prototype", ANull, [], [], ANull);
	      cx.protos.Function.proto = cx.protos.Object;
	      cx.protos.RegExp = new Obj(true, "RegExp.prototype");
	      cx.protos.String = new Obj(true, "String.prototype");
	      cx.protos.Number = new Obj(true, "Number.prototype");
	      cx.protos.Boolean = new Obj(true, "Boolean.prototype");
	      cx.protos.Symbol = new Obj(true, "Symbol.prototype");
	      cx.str = new Prim(cx.protos.String, "string");
	      cx.bool = new Prim(cx.protos.Boolean, "bool");
	      cx.num = new Prim(cx.protos.Number, "number");
	      cx.curOrigin = null;

	      if (defs) for (var i = 0; i < defs.length; ++i)
	        def.load(defs[i]);
	    });
	  };

	  exports.Context.prototype.startAnalysis = function() {
	    this.disabledComputing = this.workList = this.curSuperCtor = this.curSuper = null;
	  };

	  var cx = null;
	  exports.cx = function() { return cx; };

	  exports.withContext = function(context, f) {
	    var old = cx;
	    cx = context;
	    try { return f(); }
	    finally { cx = old; }
	  };

	  exports.TimedOut = function() {
	    this.message = "Timed out";
	    this.stack = (new Error()).stack;
	  };
	  exports.TimedOut.prototype = Object.create(Error.prototype);
	  exports.TimedOut.prototype.name = "infer.TimedOut";

	  var timeout;
	  exports.withTimeout = function(ms, f) {
	    var end = +new Date + ms;
	    var oldEnd = timeout;
	    if (oldEnd && oldEnd < end) return f();
	    timeout = end;
	    try { return f(); }
	    finally { timeout = oldEnd; }
	  };

	  exports.addOrigin = function(origin) {
	    if (cx.origins.indexOf(origin) < 0) cx.origins.push(origin);
	  };

	  var baseMaxWorkDepth = 20, reduceMaxWorkDepth = 0.0001;
	  function withWorklist(f) {
	    if (cx.workList) return f(cx.workList);

	    var list = [], depth = 0;
	    var add = cx.workList = function(type, target, weight) {
	      if (depth < baseMaxWorkDepth - reduceMaxWorkDepth * list.length)
	        list.push(type, target, weight, depth);
	    };
	    var ret = f(add);
	    for (var i = 0; i < list.length; i += 4) {
	      if (timeout && +new Date >= timeout)
	        throw new exports.TimedOut();
	      depth = list[i + 3] + 1;
	      list[i + 1].addType(list[i], list[i + 2]);
	    }
	    cx.workList = null;
	    return ret;
	  }

	  function withSuper(ctor, obj, f) {
	    var oldCtor = cx.curSuperCtor, oldObj = cx.curSuper
	    cx.curSuperCtor = ctor; cx.curSuper = obj
	    var result = f()
	    cx.curSuperCtor = oldCtor; cx.curSuper = oldObj
	    return result
	  }

	  // SCOPES

	  var Scope = exports.Scope = function(prev, originNode, isBlock) {
	    Obj.call(this, prev || true);
	    this.prev = prev;
	    this.originNode = originNode
	    this.isBlock = !!isBlock
	  };
	  Scope.prototype = extend(Obj.prototype, {
	    constructor: Scope,
	    defVar: function(name, originNode) {
	      for (var s = this; ; s = s.proto) {
	        var found = s.props[name];
	        if (found) return found;
	        if (!s.prev) return s.defProp(name, originNode);
	      }
	    }
	  });

	  function functionScope(scope) {
	    while (scope.isBlock) scope = scope.prev
	    return scope
	  }


	  // RETVAL COMPUTATION HEURISTICS

	  function maybeInstantiate(scope, score) {
	    var fn = functionScope(scope).fnType
	    if (fn) fn.instantiateScore = (fn.instantiateScore || 0) + score;
	  }

	  var NotSmaller = {};
	  function nodeSmallerThan(node, n) {
	    try {
	      walk.simple(node, {Expression: function() { if (--n <= 0) throw NotSmaller; }});
	      return true;
	    } catch(e) {
	      if (e == NotSmaller) return false;
	      throw e;
	    }
	  }

	  function maybeTagAsInstantiated(node, fn) {
	    var score = fn.instantiateScore;
	    if (!cx.disabledComputing && score && fn.args.length && nodeSmallerThan(node, score * 5)) {
	      maybeInstantiate(functionScope(fn.originNode.scope.prev), score / 2);
	      setFunctionInstantiated(node, fn);
	      return true;
	    } else {
	      fn.instantiateScore = null;
	    }
	  }

	  function setFunctionInstantiated(node, fn) {
	    // Disconnect the arg avals, so that we can add info to them without side effects
	    for (var i = 0; i < fn.args.length; ++i) fn.args[i] = new AVal;
	    fn.self = new AVal;
	    fn.computeRet = function(self, args) {
	      // Prevent recursion
	      return withDisabledComputing(fn, function() {
	        var oldOrigin = cx.curOrigin;
	        cx.curOrigin = fn.origin;
	        var scope = node.scope
	        var scopeCopy = new Scope(scope.prev, scope.originNode);
	        for (var v in scope.props) {
	          var local = scopeCopy.defProp(v, scope.props[v].originNode);
	          for (var i = 0; i < args.length; ++i) if (fn.argNames[i] == v && i < args.length)
	            args[i].propagate(local);
	        }
	        var argNames = fn.argNames.length != args.length ? fn.argNames.slice(0, args.length) : fn.argNames;
	        while (argNames.length < args.length) argNames.push("?");
	        scopeCopy.fnType = new Fn(fn.name, self, args, argNames, ANull, fn.generator);
	        scopeCopy.fnType.originNode = fn.originNode;
	        if (fn.arguments) {
	          var argset = scopeCopy.fnType.arguments = new AVal;
	          scopeCopy.defProp("arguments").addType(new Arr(argset));
	          for (var i = 0; i < args.length; ++i) args[i].propagate(argset);
	        }
	        node.scope = scopeCopy;
	        walk.recursive(node.body, scopeCopy, null, scopeGatherer);
	        walk.recursive(node.body, scopeCopy, null, inferWrapper);
	        cx.curOrigin = oldOrigin;
	        return scopeCopy.fnType.retval;
	      });
	    };
	  }

	  function maybeTagAsGeneric(fn) {
	    var target = fn.retval;
	    if (target == ANull) return;
	    var targetInner, asArray;
	    if (!target.isEmpty() && (targetInner = target.getType()) instanceof Arr)
	      target = asArray = targetInner.getProp("<i>");

	    function explore(aval, path, depth) {
	      if (depth > 3 || !aval.forward) return;
	      for (var i = 0; i < aval.forward.length; ++i) {
	        var prop = aval.forward[i].propagatesTo();
	        if (!prop) continue;
	        var newPath = path, dest;
	        if (prop instanceof AVal) {
	          dest = prop;
	        } else if (prop.target instanceof AVal) {
	          newPath += prop.pathExt;
	          dest = prop.target;
	        } else continue;
	        if (dest == target) return newPath;
	        var found = explore(dest, newPath, depth + 1);
	        if (found) return found;
	      }
	    }

	    var foundPath = explore(fn.self, "!this", 0);
	    for (var i = 0; !foundPath && i < fn.args.length; ++i)
	      foundPath = explore(fn.args[i], "!" + i, 0);

	    if (foundPath) {
	      if (asArray) foundPath = "[" + foundPath + "]";
	      var p = new def.TypeParser(foundPath);
	      var parsed = p.parseType(true);
	      fn.computeRet = parsed.apply ? parsed : function() { return parsed; };
	      fn.computeRetSource = foundPath;
	      return true;
	    }
	  }

	  // SCOPE GATHERING PASS

	  function addVar(scope, nameNode) {
	    return scope.defProp(nameNode.name, nameNode);
	  }
	  function patternName(node) {
	    if (node.type == "Identifier") return node.name
	    if (node.type == "AssignmentPattern") return patternName(node.left)
	    if (node.type == "ObjectPattern") return "{" + node.properties.map(function(e) { return patternName(e.value) }).join(", ") + "}"
	    if (node.type == "ArrayPattern") return "[" + node.elements.map(patternName).join(", ") + "]"
	    if (node.type == "RestElement") return "..." + patternName(node.argument)
	    return "_"
	  }

	  function isBlockScopedDecl(node) {
	    return node.type == "VariableDeclaration" && node.kind != "var" ||
	      node.type == "FunctionDeclaration" ||
	      node.type == "ClassDeclaration";
	  }

	  function patternScopes(inner, outer) {
	    return {inner: inner, outer: outer || inner}
	  }

	  var scopeGatherer = exports.scopeGatherer = walk.make({
	    VariablePattern: function(node, scopes) {
	      if (scopes.inner) addVar(scopes.inner, node)
	    },
	    AssignmentPattern: function(node, scopes, c) {
	      c(node.left, scopes, "Pattern")
	      c(node.right, scopes.outer, "Expression")
	    },
	    AssignmentExpression: function(node, scope, c) {
	      if (node.left.type == "MemberExpression")
	        c(node.left, scope, "Expression")
	      else
	        c(node.left, patternScopes(false, scope), "Pattern")
	      c(node.right, scope, "Expression")
	    },
	    Function: function(node, scope, c) {
	      var inner = node.scope = new Scope(scope, node)
	      var argVals = [], argNames = []
	      for (var i = 0; i < node.params.length; ++i) {
	        var param = node.params[i]
	        argNames.push(patternName(param))
	        if (param.type == "Identifier") {
	          argVals.push(addVar(inner, param))
	        } else {
	          var arg = new AVal
	          argVals.push(arg)
	          arg.originNode = param
	          c(param, patternScopes(inner), "Pattern")
	        }
	      }
	      inner.fnType = new Fn(node.id && node.id.name, new AVal, argVals, argNames, ANull, node.generator)
	      inner.fnType.originNode = node;
	      if (node.id) {
	        var decl = node.type == "FunctionDeclaration";
	        addVar(decl ? scope : inner, node.id);
	      }
	      c(node.body, inner, node.expression ? "Expression" : "Statement");
	    },
	    BlockStatement: function(node, scope, c) {
	      if (!node.scope && node.body.some(isBlockScopedDecl))
	        scope = node.scope = new Scope(scope, node, true)
	      walk.base.BlockStatement(node, scope, c)
	    },
	    TryStatement: function(node, scope, c) {
	      c(node.block, scope, "Statement");
	      if (node.handler) {
	        if (node.handler.param.type == "Identifier") {
	          var v = addVar(scope, node.handler.param);
	          c(node.handler.body, scope, "Statement");
	          var e5 = cx.definitions.ecma5;
	          if (e5 && v.isEmpty()) getInstance(e5["Error.prototype"]).propagate(v, WG_CATCH_ERROR);
	        } else {
	          c(node.handler.param, patternScopes(scope), "Pattern")
	        }
	      }
	      if (node.finalizer) c(node.finalizer, scope, "Statement");
	    },
	    VariableDeclaration: function(node, scope, c) {
	      var targetScope = node.kind == "var" ? functionScope(scope) : scope
	      for (var i = 0; i < node.declarations.length; ++i) {
	        var decl = node.declarations[i];
	        c(decl.id, patternScopes(targetScope, scope), "Pattern")
	        if (decl.init) c(decl.init, scope, "Expression");
	      }
	    },
	    ClassDeclaration: function(node, scope, c) {
	      addVar(scope, node.id)
	      if (node.superClass) c(node.superClass, scope, "Expression")
	      for (var i = 0; i < node.body.body.length; i++)
	        c(node.body.body[i], scope)
	    },
	    ForInStatement: function(node, scope, c) {
	      if (!node.scope && isBlockScopedDecl(node.left))
	        scope = node.scope = new Scope(scope, node, true)
	      walk.base.ForInStatement(node, scope, c)
	    },
	    ForStatement: function(node, scope, c) {
	      if (!node.scope && node.init && isBlockScopedDecl(node.init))
	        scope = node.scope = new Scope(scope, node, true)
	      walk.base.ForStatement(node, scope, c)
	    },
	    ImportDeclaration: function(node, scope) {
	      for (var i = 0; i < node.specifiers.length; i++)
	        addVar(scope, node.specifiers[i].local)
	    }
	  });
	  scopeGatherer.ForOfStatement = scopeGatherer.ForInStatement

	  // CONSTRAINT GATHERING PASS

	  var propName = exports.propName = function(node, inferInScope) {
	    var key = node.property || node.key;
	    if (!node.computed && key.type == "Identifier") return key.name;
	    if (key.type == "Literal") {
	      if (typeof key.value == "string") return key.value
	      if (typeof key.value == "number") return String(key.value)
	    }
	    if (inferInScope) {
	      var symName = symbolName(infer(key, inferInScope))
	      if (symName) return node.propName = symName
	    } else if (node.propName) {
	      return node.propName
	    }
	    return "<i>";
	  }
	  function symbolName(val) {
	    var sym = val.getSymbolType()
	    if (sym) return sym.asPropName()
	  }

	  function unopResultType(op) {
	    switch (op) {
	    case "+": case "-": case "~": return cx.num;
	    case "!": return cx.bool;
	    case "typeof": return cx.str;
	    case "void": case "delete": return ANull;
	    }
	  }
	  function binopIsBoolean(op) {
	    switch (op) {
	    case "==": case "!=": case "===": case "!==": case "<": case ">": case ">=": case "<=":
	    case "in": case "instanceof": return true;
	    }
	  }
	  function literalType(node) {
	    if (node.regex) return getInstance(cx.protos.RegExp);
	    switch (typeof node.value) {
	    case "boolean": return cx.bool;
	    case "number": return cx.num;
	    case "string": return cx.str;
	    case "object":
	    case "function":
	      if (!node.value) return ANull;
	      return getInstance(cx.protos.RegExp);
	    }
	  }

	  function join(a, b) {
	    if (a == b || b == ANull) return a
	    if (a == ANull) return b
	    var joined = new AVal
	    a.propagate(joined)
	    b.propagate(joined)
	    return joined
	  }

	  function connectParams(node, scope) {
	    for (var i = 0; i < node.params.length; i++) {
	      var param = node.params[i]
	      if (param.type == "Identifier") continue
	      connectPattern(param, scope, node.scope.fnType.args[i])
	    }
	  }

	  function ensureVar(node, scope) {
	    return scope.hasProp(node.name) || cx.topScope.defProp(node.name, node)
	  }

	  var inferPatternVisitor = exports.inferPatternVisitor = {
	    Identifier: function(node, scope, source) {
	      source.propagate(ensureVar(node, scope))
	    },
	    MemberExpression: function(node, scope, source) {
	      var obj = infer(node.object, scope)
	      var pName = propName(node, scope)
	      obj.propagate(new DefProp(pName, source, node.property))
	    },
	    RestElement: function(node, scope, source) {
	      connectPattern(node.argument, scope, new Arr(source))
	    },
	    ObjectPattern: function(node, scope, source) {
	      for (var i = 0; i < node.properties.length; ++i) {
	        var prop = node.properties[i]
	        connectPattern(prop.value, scope, source.getProp(prop.key.name))
	      }
	    },
	    ArrayPattern: function(node, scope, source) {
	      for (var i = 0; i < node.elements.length; i++)
	        if (node.elements[i])
	          connectPattern(node.elements[i], scope, source.getProp(String(i)))
	    },
	    AssignmentPattern: function(node, scope, source) {
	      connectPattern(node.left, scope, join(source, infer(node.right, scope)))
	    }
	  }

	  function connectPattern(node, scope, source) {
	    var connecter = inferPatternVisitor[node.type]
	    if (connecter) connecter(node, scope, source)
	  }

	  function getThis(scope) {
	    var fnScope = functionScope(scope)
	    return fnScope.fnType ? fnScope.fnType.self : fnScope
	  }

	  function maybeAddPhantomObj(obj) {
	    if (!obj.isEmpty() || !obj.propertyOf) return
	    obj.propertyOf.getProp(obj.propertyName).addType(new Obj, WG_PHANTOM_OBJ)
	    maybeAddPhantomObj(obj.propertyOf)
	  }

	  function inferClass(node, scope, name) {
	    if (!name && node.id) name = node.id.name

	    var sup = cx.protos.Object, supCtor, delayed
	    if (node.superClass) {
	      if (node.superClass.type == "Literal" && node.superClass.value == null) {
	        sup = null
	      } else {
	        var supVal = infer(node.superClass, scope), supProto
	        supCtor = supVal.getFunctionType()
	        if (supCtor && (supProto = supCtor.getProp("prototype").getObjType())) {
	          sup = supProto
	        } else {
	          supCtor = supVal
	          delayed = supVal.getProp("prototype")
	        }
	      }
	    }
	    var proto = new Obj(sup, name && name + ".prototype")
	    if (delayed) delayed.propagate(new HasProto(proto))

	    return withSuper(supCtor, delayed || sup, function() {
	      var ctor, body = node.body.body
	      for (var i = 0; i < body.length; i++)
	        if (body[i].kind == "constructor") ctor = body[i].value
	      var fn = node.objType = ctor ? infer(ctor, scope) : new Fn(name, ANull, [], null, ANull)
	      fn.originNode = node.id || ctor || node

	      var inst = getInstance(proto, fn)
	      fn.self.addType(inst)
	      fn.defProp("prototype", node).addType(proto)
	      for (var i = 0; i < body.length; i++) {
	        var method = body[i], target
	        if (method.kind == "constructor") continue
	        var pName = propName(method, scope)
	        if (pName == "<i>" || method.kind == "set") {
	          target = ANull
	        } else {
	          target = (method.static ? fn : proto).defProp(pName, method.key)
	          target.initializer = true
	          if (method.kind == "get") target = new IsCallee(inst, [], null, target)
	        }
	        infer(method.value, scope, target)
	        var methodFn = target.getFunctionType()
	        if (methodFn) methodFn.self.addType(inst)
	      }
	      return fn
	    })
	  }

	  function arrayLiteralType(elements, scope, inner) {
	    var tuple = elements.length > 1 && elements.length < 6
	    if (tuple) {
	      var homogenous = true, litType
	      for (var i = 0; i < elements.length; i++) {
	        var elt = elements[i]
	        if (!elt)
	          tuple = false
	        else if (elt.type != "Literal" || (litType && litType != typeof elt.value))
	          homogenous = false
	        else
	          litType = typeof elt.value
	      }
	      if (homogenous) tuple = false
	    }

	    if (tuple) {
	      var types = []
	      for (var i = 0; i < elements.length; ++i)
	        types.push(inner(elements[i], scope))
	      return new Arr(types)
	    } else if (elements.length < 2) {
	      return new Arr(elements[0] && inner(elements[0], scope))
	    } else {
	      var eltVal = new AVal
	      for (var i = 0; i < elements.length; i++)
	        if (elements[i]) inner(elements[i], scope).propagate(eltVal)
	      return new Arr(eltVal)
	    }
	  }

	  function ret(f) {
	    return function(node, scope, out, name) {
	      var r = f(node, scope, name);
	      if (out) r.propagate(out);
	      return r;
	    };
	  }
	  function fill(f) {
	    return function(node, scope, out, name) {
	      if (!out) out = new AVal;
	      f(node, scope, out, name);
	      return out;
	    };
	  }

	  var inferExprVisitor = exports.inferExprVisitor = {
	    ArrayExpression: ret(function(node, scope) {
	      return arrayLiteralType(node.elements, scope, infer)
	    }),
	    ObjectExpression: ret(function(node, scope, name) {
	      var proto = true, waitForProto
	      for (var i = 0; i < node.properties.length; ++i) {
	        var prop = node.properties[i]
	        if (prop.key.name == "__proto__") {
	          if (prop.value.type == "Literal" && prop.value.value == null) {
	            proto = null
	          } else {
	            var protoVal = infer(prop.value, scope), known = protoVal.getObjType()
	            if (known) proto = known
	            else waitForProto = protoVal
	          }
	        }
	      }

	      var obj = node.objType = new Obj(proto, name);
	      if (waitForProto) waitForProto.propagate(new HasProto(obj))
	      obj.originNode = node;

	      withSuper(null, waitForProto || proto, function() {
	        for (var i = 0; i < node.properties.length; ++i) {
	          var prop = node.properties[i], key = prop.key;
	          if (prop.value.name == "✖" || prop.key.name == "__proto__") continue;

	          var name = propName(prop, scope), target
	          if (name == "<i>" || prop.kind == "set") {
	            target = ANull;
	          } else {
	            var val = target = obj.defProp(name, key);
	            val.initializer = true;
	            if (prop.kind == "get")
	              target = new IsCallee(obj, [], null, val);
	          }
	          infer(prop.value, scope, target, name);
	          if (prop.value.type == "FunctionExpression")
	            prop.value.scope.fnType.self.addType(obj, WG_SPECULATIVE_THIS);
	        }
	      })
	      return obj;
	    }),
	    FunctionExpression: ret(function(node, scope, name) {
	      var inner = node.scope, fn = inner.fnType;
	      if (name && !fn.name) fn.name = name;
	      connectParams(node, inner)
	      if (node.expression)
	        infer(node.body, inner, inner.fnType.retval = new AVal)
	      else
	        walk.recursive(node.body, inner, null, inferWrapper, "Statement")
	      if (node.type == "ArrowFunctionExpression") {
	        getThis(scope).propagate(fn.self)
	        fn.self = ANull
	      }
	      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
	      if (node.id) inner.getProp(node.id.name).addType(fn);
	      return fn;
	    }),
	    ClassExpression: ret(inferClass),
	    SequenceExpression: ret(function(node, scope) {
	      for (var i = 0, l = node.expressions.length - 1; i < l; ++i)
	        infer(node.expressions[i], scope, ANull);
	      return infer(node.expressions[l], scope);
	    }),
	    UnaryExpression: ret(function(node, scope) {
	      infer(node.argument, scope, ANull);
	      return unopResultType(node.operator);
	    }),
	    UpdateExpression: ret(function(node, scope) {
	      infer(node.argument, scope, ANull);
	      return cx.num;
	    }),
	    BinaryExpression: ret(function(node, scope) {
	      if (node.operator == "+") {
	        var lhs = infer(node.left, scope);
	        var rhs = infer(node.right, scope);
	        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
	        if (lhs.hasType(cx.num) && rhs.hasType(cx.num)) return cx.num;
	        var result = new AVal;
	        lhs.propagate(new IsAdded(rhs, result));
	        rhs.propagate(new IsAdded(lhs, result));
	        return result;
	      } else {
	        infer(node.left, scope, ANull);
	        infer(node.right, scope, ANull);
	        return binopIsBoolean(node.operator) ? cx.bool : cx.num;
	      }
	    }),
	    AssignmentExpression: ret(function(node, scope, name) {
	      var rhs, pName;
	      if (node.left.type == "MemberExpression") {
	        pName = propName(node.left, scope)
	        if (!name)
	          name = node.left.object.type == "Identifier" ? node.left.object.name + "." + pName : pName
	      } else if (!name && node.left.type == "Identifier") {
	        name = node.left.name
	      }

	      if (node.operator && node.operator != "=" && node.operator != "+=") {
	        infer(node.right, scope, ANull);
	        rhs = cx.num;
	      } else {
	        rhs = infer(node.right, scope, null, name);
	      }

	      if (node.left.type == "MemberExpression") {
	        var obj = infer(node.left.object, scope);
	        if (pName == "prototype") maybeInstantiate(scope, 20);
	        if (pName == "<i>") {
	          // This is a hack to recognize for/in loops that copy
	          // properties, and do the copying ourselves, insofar as we
	          // manage, because such loops tend to be relevant for type
	          // information.
	          var v = node.left.property.name, local = scope.props[v], over = local && local.iteratesOver;
	          if (over) {
	            maybeInstantiate(scope, 20);
	            var fromRight = node.right.type == "MemberExpression" && node.right.computed && node.right.property.name == v;
	            over.forAllProps(function(prop, val, local) {
	              if (local && prop != "prototype" && prop != "<i>")
	                obj.propagate(new DefProp(prop, fromRight ? val : ANull));
	            });
	            return rhs;
	          }
	        }

	        obj.propagate(new DefProp(pName, rhs, node.left.property));
	        maybeAddPhantomObj(obj)
	        if (node.right.type == "FunctionExpression")
	          obj.propagate(node.right.scope.fnType.self, WG_SPECULATIVE_THIS);
	      } else {
	        connectPattern(node.left, scope, rhs)
	      }
	      return rhs;
	    }),
	    LogicalExpression: fill(function(node, scope, out) {
	      infer(node.left, scope, out);
	      infer(node.right, scope, out);
	    }),
	    ConditionalExpression: fill(function(node, scope, out) {
	      infer(node.test, scope, ANull);
	      infer(node.consequent, scope, out);
	      infer(node.alternate, scope, out);
	    }),
	    NewExpression: fill(function(node, scope, out, name) {
	      if (node.callee.type == "Identifier" && node.callee.name in scope.props)
	        maybeInstantiate(scope, 20);

	      for (var i = 0, args = []; i < node.arguments.length; ++i)
	        args.push(infer(node.arguments[i], scope));
	      var callee = infer(node.callee, scope);
	      var self = new AVal;
	      callee.propagate(new IsCtor(self, name && /\.prototype$/.test(name)));
	      self.propagate(out, WG_NEW_INSTANCE);
	      callee.propagate(new IsCallee(self, args, node.arguments, new IfObj(out)));
	    }),
	    CallExpression: fill(function(node, scope, out) {
	      for (var i = 0, args = []; i < node.arguments.length; ++i)
	        args.push(infer(node.arguments[i], scope));
	      var outerFn = functionScope(scope).fnType
	      if (node.callee.type == "MemberExpression") {
	        var self = infer(node.callee.object, scope);
	        var pName = propName(node.callee, scope)
	        if (outerFn && (pName == "call" || pName == "apply") &&
	            outerFn.args.indexOf(self) > -1)
	          maybeInstantiate(scope, 30);
	        self.propagate(new HasMethodCall(pName, args, node.arguments, out));
	      } else if (node.callee.type == "Super" && cx.curSuperCtor) {
	        cx.curSuperCtor.propagate(new IsCallee(getThis(scope), args, node.arguments, out))
	      } else {
	        var callee = infer(node.callee, scope);
	        if (outerFn && outerFn.args.indexOf(callee) > -1)
	          maybeInstantiate(scope, 30);
	        var knownFn = callee.getFunctionType();
	        if (knownFn && knownFn.instantiateScore && outerFn)
	          maybeInstantiate(scope, knownFn.instantiateScore / 5);
	        callee.propagate(new IsCallee(cx.topScope, args, node.arguments, out));
	      }
	    }),
	    MemberExpression: fill(function(node, scope, out) {
	      var name = propName(node), wg;
	      if (name == "<i>") {
	        var propType = infer(node.property, scope)
	        var symName = symbolName(propType)
	        if (symName)
	          name = node.propName = symName
	        else if (!propType.hasType(cx.num))
	          wg = WG_MULTI_MEMBER
	      }
	      infer(node.object, scope).getProp(name).propagate(out, wg)
	    }),
	    Identifier: ret(function(node, scope) {
	      if (node.name == "arguments") {
	        var fnScope = functionScope(scope)
	        if (fnScope.fnType && !(node.name in fnScope.props))
	          scope.defProp(node.name, fnScope.fnType.originNode)
	            .addType(new Arr(fnScope.fnType.arguments = new AVal));
	      }
	      return scope.getProp(node.name);
	    }),
	    ThisExpression: ret(function(_node, scope) {
	      return getThis(scope)
	    }),
	    Super: ret(function(node) {
	      return node.superType = cx.curSuper || ANull
	    }),
	    Literal: ret(function(node) {
	      return literalType(node);
	    }),
	    TemplateLiteral: ret(function(node, scope) {
	      for (var i = 0; i < node.expressions.length; ++i)
	        infer(node.expressions[i], scope, ANull)
	      return cx.str
	    }),
	    TaggedTemplateExpression: fill(function(node, scope, out) {
	      var args = [new Arr(cx.str)]
	      for (var i = 0; i < node.quasi.expressions.length; ++i)
	        args.push(infer(node.quasi.expressions[i], scope))
	      infer(node.tag, scope, new IsCallee(cx.topScope, args, node.quasi.expressions, out))
	    }),
	    YieldExpression: ret(function(node, scope) {
	      var output = ANull, fn = functionScope(scope).fnType
	      if (fn) {
	        if (fn.retval == ANull) fn.retval = new AVal
	        if (!fn.yieldval) fn.yieldval = new AVal
	        output = fn.retval
	      }
	      if (node.argument) {
	        if (node.delegate) {
	          infer(node.argument, scope, new HasMethodCall("next", [], null,
	                                                        new GetProp("value", output)))
	        } else {
	          infer(node.argument, scope, output)
	        }
	      }
	      return fn ? fn.yieldval : ANull
	    })
	  };
	  inferExprVisitor.ArrowFunctionExpression = inferExprVisitor.FunctionExpression

	  function infer(node, scope, out, name) {
	    var handler = inferExprVisitor[node.type];
	    return handler ? handler(node, scope, out, name) : ANull;
	  }

	  function loopPattern(init) {
	    return init.type == "VariableDeclaration" ? init.declarations[0].id : init
	  }

	  var inferWrapper = exports.inferWrapper = walk.make({
	    Expression: function(node, scope) {
	      infer(node, node.scope || scope, ANull);
	    },

	    FunctionDeclaration: function(node, scope, c) {
	      var inner = node.scope, fn = inner.fnType;
	      connectParams(node, inner)
	      c(node.body, inner, "Statement");
	      maybeTagAsInstantiated(node, fn) || maybeTagAsGeneric(fn);
	      scope.getProp(node.id.name).addType(fn)
	    },

	    Statement: function(node, scope, c) {
	      c(node, node.scope || scope)
	    },

	    VariableDeclaration: function(node, scope) {
	      for (var i = 0; i < node.declarations.length; ++i) {
	        var decl = node.declarations[i];
	        if (decl.id.type == "Identifier") {
	          var prop = scope.getProp(decl.id.name);
	          if (decl.init)
	            infer(decl.init, scope, prop, decl.id.name);
	        } else if (decl.init) {
	          connectPattern(decl.id, scope, infer(decl.init, scope))
	        }
	      }
	    },

	    ClassDeclaration: function(node, scope) {
	      scope.getProp(node.id.name).addType(inferClass(node, scope, node.id.name))
	    },

	    ReturnStatement: function(node, scope) {
	      if (!node.argument) return;
	      var output = ANull, fn = functionScope(scope).fnType
	      if (fn) {
	        if (fn.retval == ANull) fn.retval = new AVal;
	        output = fn.retval;
	      }
	      infer(node.argument, scope, output);
	    },

	    ForInStatement: function(node, scope, c) {
	      var source = infer(node.right, scope);
	      if ((node.right.type == "Identifier" && node.right.name in scope.props) ||
	          (node.right.type == "MemberExpression" && node.right.property.name == "prototype")) {
	        maybeInstantiate(scope, 5);
	        var pattern = loopPattern(node.left)
	        if (pattern.type == "Identifier") {
	          if (pattern.name in scope.props)
	            scope.getProp(pattern.name).iteratesOver = source
	          source.getProp("<i>").propagate(ensureVar(pattern, scope))
	        } else {
	          connectPattern(pattern, scope, source.getProp("<i>"))
	        }
	      }
	      c(node.body, scope, "Statement");
	    },

	    ForOfStatement: function(node, scope, c) {
	      var pattern = loopPattern(node.left), target
	      if (pattern.type == "Identifier")
	        target = ensureVar(pattern, scope)
	      else
	        connectPattern(pattern, scope, target = new AVal)
	      infer(node.right, scope, new HasMethodCall(":Symbol.iterator", [], null,
	                                                 new HasMethodCall("next", [], null,
	                                                                   new GetProp("value", target))))
	      c(node.body, scope, "Statement")
	    }
	  });

	  // PARSING

	  var parse = exports.parse = function(text, options, thirdArg) {
	    if (!options || Array.isArray(options)) options = thirdArg
	    var ast;
	    try { ast = acorn.parse(text, options); }
	    catch(e) { ast = acorn_loose.parse_dammit(text, options); }
	    return ast;
	  };

	  // ANALYSIS INTERFACE

	  exports.analyze = function(ast, name, scope) {
	    if (typeof ast == "string") ast = parse(ast);

	    if (!name) name = "file#" + cx.origins.length;
	    exports.addOrigin(cx.curOrigin = name);

	    if (!scope) scope = cx.topScope;
	    cx.startAnalysis();

	    walk.recursive(ast, scope, null, scopeGatherer);
	    if (cx.parent) cx.parent.signal("preInfer", ast, scope)
	    walk.recursive(ast, scope, null, inferWrapper);
	    if (cx.parent) cx.parent.signal("postInfer", ast, scope)

	    cx.curOrigin = null;
	  };

	  // PURGING

	  exports.purge = function(origins, start, end) {
	    var test = makePredicate(origins, start, end);
	    ++cx.purgeGen;
	    cx.topScope.purge(test);
	    for (var prop in cx.props) {
	      var list = cx.props[prop];
	      for (var i = 0; i < list.length; ++i) {
	        var obj = list[i], av = obj.props[prop];
	        if (!av || test(av, av.originNode)) list.splice(i--, 1);
	      }
	      if (!list.length) delete cx.props[prop];
	    }
	  };

	  function makePredicate(origins, start, end) {
	    var arr = Array.isArray(origins);
	    if (arr && origins.length == 1) { origins = origins[0]; arr = false; }
	    if (arr) {
	      if (end == null) return function(n) { return origins.indexOf(n.origin) > -1; };
	      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && origins.indexOf(n.origin) > -1; };
	    } else {
	      if (end == null) return function(n) { return n.origin == origins; };
	      return function(n, pos) { return pos && pos.start >= start && pos.end <= end && n.origin == origins; };
	    }
	  }

	  AVal.prototype.purge = function(test) {
	    if (this.purgeGen == cx.purgeGen) return;
	    this.purgeGen = cx.purgeGen;
	    for (var i = 0; i < this.types.length; ++i) {
	      var type = this.types[i];
	      if (test(type, type.originNode))
	        this.types.splice(i--, 1);
	      else
	        type.purge(test);
	    }
	    if (!this.types.length) this.maxWeight = 0;

	    if (this.forward) for (var i = 0; i < this.forward.length; ++i) {
	      var f = this.forward[i];
	      if (test(f)) {
	        this.forward.splice(i--, 1);
	        if (this.props) this.props = null;
	      } else if (f.purge) {
	        f.purge(test);
	      }
	    }
	  };
	  ANull.purge = function() {};
	  Obj.prototype.purge = function(test) {
	    if (this.purgeGen == cx.purgeGen) return true;
	    this.purgeGen = cx.purgeGen;
	    for (var p in this.props) {
	      var av = this.props[p];
	      if (test(av, av.originNode))
	        this.removeProp(p);
	      av.purge(test);
	    }
	  };
	  Fn.prototype.purge = function(test) {
	    if (Obj.prototype.purge.call(this, test)) return;
	    this.self.purge(test);
	    this.retval.purge(test);
	    for (var i = 0; i < this.args.length; ++i) this.args[i].purge(test);
	  };

	  // EXPRESSION TYPE DETERMINATION

	  function findByPropertyName(name) {
	    guessing = true;
	    var found = objsWithProp(name);
	    if (found) for (var i = 0; i < found.length; ++i) {
	      var val = found[i].getProp(name);
	      if (!val.isEmpty()) return val;
	    }
	    return ANull;
	  }

	  function generatorResult(input, output) {
	    var retObj = new Obj(true)
	    retObj.defProp("done").addType(cx.bool)
	    output.propagate(retObj.defProp("value"))
	    var method = new Fn(null, ANull, input ? [input] : [], input ? ["?"] : [], retObj)
	    var result = new Obj(cx.definitions.ecma6 && cx.definitions.ecma6.generator_prototype || true)
	    result.defProp("next").addType(method)
	    return result
	  }

	  function maybeIterator(fn, output) {
	    if (!fn.generator) return output
	    if (!fn.computeRet) { // Reuse iterator objects for non-computed return types
	      if (fn.generator === true) fn.generator = generatorResult(fn.yieldval, output)
	      return fn.generator
	    }
	    return generatorResult(fn.yieldval, output)
	  }

	  function computeReturnType(funcNode, argNodes, scope) {
	    var fn = findType(funcNode, scope).getFunctionType()
	    if (!fn) return ANull
	    var result = fn.retval
	    if (fn.computeRet) {
	      for (var i = 0, args = []; i < argNodes.length; ++i)
	        args.push(findType(argNodes[i], scope))
	      var self = ANull
	      if (funcNode.type == "MemberExpression")
	        self = findType(funcNode.object, scope)
	      result = fn.computeRet(self, args, argNodes);
	    }
	    return maybeIterator(fn, result)
	  }

	  var typeFinder = exports.typeFinder = {
	    ArrayExpression: function(node, scope) {
	      return arrayLiteralType(node.elements, scope, findType)
	    },
	    ObjectExpression: function(node) {
	      return node.objType;
	    },
	    ClassExpression: function(node) {
	      return node.objType;
	    },
	    FunctionExpression: function(node) {
	      return node.scope.fnType;
	    },
	    ArrowFunctionExpression: function(node) {
	      return node.scope.fnType;
	    },
	    SequenceExpression: function(node, scope) {
	      return findType(node.expressions[node.expressions.length-1], scope);
	    },
	    UnaryExpression: function(node) {
	      return unopResultType(node.operator);
	    },
	    UpdateExpression: function() {
	      return cx.num;
	    },
	    BinaryExpression: function(node, scope) {
	      if (binopIsBoolean(node.operator)) return cx.bool;
	      if (node.operator == "+") {
	        var lhs = findType(node.left, scope);
	        var rhs = findType(node.right, scope);
	        if (lhs.hasType(cx.str) || rhs.hasType(cx.str)) return cx.str;
	      }
	      return cx.num;
	    },
	    AssignmentExpression: function(node, scope) {
	      return findType(node.right, scope);
	    },
	    LogicalExpression: function(node, scope) {
	      var lhs = findType(node.left, scope);
	      return lhs.isEmpty() ? findType(node.right, scope) : lhs;
	    },
	    ConditionalExpression: function(node, scope) {
	      var lhs = findType(node.consequent, scope);
	      return lhs.isEmpty() ? findType(node.alternate, scope) : lhs;
	    },
	    NewExpression: function(node, scope) {
	      var f = findType(node.callee, scope).getFunctionType();
	      var proto = f && f.getProp("prototype").getObjType();
	      if (!proto) return ANull;
	      return getInstance(proto, f);
	    },
	    CallExpression: function(node, scope) {
	      return computeReturnType(node.callee, node.arguments, scope)
	    },
	    MemberExpression: function(node, scope) {
	      var propN = propName(node), obj = findType(node.object, scope).getType();
	      if (obj) return obj.getProp(propN);
	      if (propN == "<i>") return ANull;
	      return findByPropertyName(propN);
	    },
	    Identifier: function(node, scope) {
	      return scope.hasProp(node.name) || ANull;
	    },
	    ThisExpression: function(_node, scope) {
	      return getThis(scope)
	    },
	    Literal: function(node) {
	      return literalType(node);
	    },
	    Super: ret(function(node) {
	      return node.superType
	    }),
	    TemplateLiteral: function() {
	      return cx.str
	    },
	    TaggedTemplateExpression: function(node, scope) {
	      return computeReturnType(node.tag, node.quasi.expressions, scope)
	    },
	    YieldExpression: function(_node, scope) {
	      var fn = functionScope(scope).fnType
	      return fn ? fn.yieldval : ANull
	    }
	  };

	  function findType(node, scope) {
	    var finder = typeFinder[node.type];
	    return finder ? finder(node, scope) : ANull;
	  }

	  var searchVisitor = exports.searchVisitor = walk.make({
	    Function: function(node, _st, c) {
	      walk.base.Function(node, node.scope, c)
	    },
	    Property: function(node, st, c) {
	      if (node.computed) c(node.key, st, "Expression");
	      if (node.key != node.value) c(node.value, st, "Expression");
	    },
	    Statement: function(node, st, c) {
	      c(node, node.scope || st)
	    },
	    ImportSpecifier: function(node, st, c) {
	      c(node.local, st)
	    },
	    ImportDefaultSpecifier: function(node, st, c) {
	      c(node.local, st)
	    },
	    ImportNamespaceSpecifier: function(node, st, c) {
	      c(node.local, st)
	    }
	  });
	  exports.fullVisitor = walk.make({
	    MemberExpression: function(node, st, c) {
	      c(node.object, st, "Expression");
	      c(node.property, st, node.computed ? "Expression" : null);
	    },
	    ObjectExpression: function(node, st, c) {
	      for (var i = 0; i < node.properties.length; ++i) {
	        c(node.properties[i].value, st, "Expression");
	        c(node.properties[i].key, st);
	      }
	    }
	  }, searchVisitor);

	  exports.findExpressionAt = function(ast, start, end, defaultScope, filter) {
	    var test = filter || function(_t, node) {
	      if (node.type == "Identifier" && node.name == "✖") return false;
	      return typeFinder.hasOwnProperty(node.type);
	    };
	    return walk.findNodeAt(ast, start, end, test, searchVisitor, defaultScope || cx.topScope);
	  };

	  exports.findExpressionAround = function(ast, start, end, defaultScope, filter) {
	    var test = filter || function(_t, node) {
	      if (start != null && node.start > start) return false;
	      if (node.type == "Identifier" && node.name == "✖") return false;
	      return typeFinder.hasOwnProperty(node.type);
	    };
	    return walk.findNodeAround(ast, end, test, searchVisitor, defaultScope || cx.topScope);
	  };

	  exports.expressionType = function(found) {
	    return findType(found.node, found.state);
	  };

	  // Finding the expected type of something, from context

	  exports.parentNode = function(child, ast) {
	    var stack = [];
	    function c(node, st, override) {
	      if (node.start <= child.start && node.end >= child.end) {
	        var top = stack[stack.length - 1];
	        if (node == child) throw {found: top};
	        if (top != node) stack.push(node);
	        walk.base[override || node.type](node, st, c);
	        if (top != node) stack.pop();
	      }
	    }
	    try {
	      c(ast, null);
	    } catch (e) {
	      if (e.found) return e.found;
	      throw e;
	    }
	  };

	  var findTypeFromContext = exports.findTypeFromContext = {
	    ArrayExpression: function(parent, _, get) { return get(parent, true).getProp("<i>"); },
	    ObjectExpression: function(parent, node, get) {
	      for (var i = 0; i < parent.properties.length; ++i) {
	        var prop = node.properties[i];
	        if (prop.value == node)
	          return get(parent, true).getProp(prop.key.name);
	      }
	    },
	    UnaryExpression: function(parent) { return unopResultType(parent.operator); },
	    UpdateExpression: function() { return cx.num; },
	    BinaryExpression: function(parent) { return binopIsBoolean(parent.operator) ? cx.bool : cx.num; },
	    AssignmentExpression: function(parent, _, get) { return get(parent.left); },
	    LogicalExpression: function(parent, _, get) { return get(parent, true); },
	    ConditionalExpression: function(parent, node, get) {
	      if (parent.consequent == node || parent.alternate == node) return get(parent, true);
	    },
	    CallExpression: function(parent, node, get) {
	      for (var i = 0; i < parent.arguments.length; i++) {
	        var arg = parent.arguments[i];
	        if (arg == node) {
	          var calleeType = get(parent.callee).getFunctionType();
	          if (calleeType instanceof Fn)
	            return calleeType.args[i];
	          break;
	        }
	      }
	    },
	    ReturnStatement: function(_parent, node, get) {
	      var fnNode = walk.findNodeAround(node.sourceFile.ast, node.start, "Function");
	      if (fnNode) {
	        var fnType = fnNode.node.type != "FunctionDeclaration"
	          ? get(fnNode.node, true).getFunctionType()
	          : fnNode.node.scope.fnType;
	        if (fnType) return fnType.retval.getType();
	      }
	    },
	    VariableDeclarator: function(parent, node, get) {
	      if (parent.init == node) return get(parent.id)
	    }
	  };
	  findTypeFromContext.NewExpression = findTypeFromContext.CallExpression

	  exports.typeFromContext = function(ast, found) {
	    var parent = exports.parentNode(found.node, ast);
	    var type = null;
	    if (findTypeFromContext.hasOwnProperty(parent.type)) {
	      var finder = findTypeFromContext[parent.type];
	      type = finder && finder(parent, found.node, function(node, fromContext) {
	        var obj = {node: node, state: found.state};
	        var tp = fromContext ? exports.typeFromContext(ast, obj) : exports.expressionType(obj);
	        return tp || ANull;
	      });
	    }
	    return type || exports.expressionType(found);
	  };

	  // Flag used to indicate that some wild guessing was used to produce
	  // a type or set of completions.
	  var guessing = false;

	  exports.resetGuessing = function(val) { guessing = val; };
	  exports.didGuess = function() { return guessing; };

	  exports.forAllPropertiesOf = function(type, f) {
	    type.gatherProperties(f, 0);
	  };

	  var refFindWalker = walk.make({}, searchVisitor);

	  exports.findRefs = function(ast, baseScope, name, refScope, f) {
	    refFindWalker.Identifier = refFindWalker.VariablePattern = function(node, scope) {
	      if (node.name != name) return;
	      for (var s = scope; s; s = s.prev) {
	        if (s == refScope) f(node, scope);
	        if (name in s.props) return;
	      }
	    };
	    walk.recursive(ast, baseScope, null, refFindWalker);
	  };

	  var simpleWalker = walk.make({
	    Function: function(node, _scope, c) {
	      c(node.body, node.scope, node.expression ? "Expression" : "Statement")
	    },
	    Statement: function(node, scope, c) {
	      c(node, node.scope || scope)
	    }
	  });

	  exports.findPropRefs = function(ast, scope, objType, propName, f) {
	    walk.simple(ast, {
	      MemberExpression: function(node, scope) {
	        if (node.computed || node.property.name != propName) return;
	        if (findType(node.object, scope).getType() == objType) f(node.property);
	      },
	      ObjectExpression: function(node, scope) {
	        if (findType(node, scope).getType() != objType) return;
	        for (var i = 0; i < node.properties.length; ++i)
	          if (node.properties[i].key.name == propName) f(node.properties[i].key);
	      }
	    }, simpleWalker, scope);
	  };

	  // LOCAL-VARIABLE QUERIES

	  var scopeAt = exports.scopeAt = function(ast, pos, defaultScope) {
	    var found = walk.findNodeAround(ast, pos, function(_, node) {
	      return node.scope;
	    });
	    if (found) return found.node.scope;
	    else return defaultScope || cx.topScope;
	  };

	  exports.forAllLocalsAt = function(ast, pos, defaultScope, f) {
	    var scope = scopeAt(ast, pos, defaultScope);
	    scope.gatherProperties(f, 0);
	  };

	  // INIT DEF MODULE

	  // Delayed initialization because of cyclic dependencies.
	  def = exports.def = def.init({}, exports);
	});


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.acorn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	// A recursive descent parser operates by defining functions for all
	// syntactic elements, and recursively calling those, each function
	// advancing the input stream and returning an AST node. Precedence
	// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
	// instead of `(!x)[1]` is handled by the fact that the parser
	// function that parses unary prefix operators is called first, and
	// in turn calls the function that parses `[]` subscripts — that
	// way, it'll receive the node for `x[1]` already parsed, and wraps
	// *that* in the unary operator node.
	//
	// Acorn uses an [operator precedence parser][opp] to handle binary
	// operator precedence, because it is much more compact than using
	// the technique outlined above, which uses different, nesting
	// functions to specify precedence, for all of the ten binary
	// precedence levels that JavaScript defines.
	//
	// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var pp = _state.Parser.prototype;

	// Check if property name clashes with already added.
	// Object/class getters and setters are not allowed to clash —
	// either with each other or with an init property — and in
	// strict mode, init properties are also not allowed to be repeated.

	pp.checkPropClash = function (prop, propHash) {
	  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) return;
	  var key = prop.key;var name = undefined;
	  switch (key.type) {
	    case "Identifier":
	      name = key.name;break;
	    case "Literal":
	      name = String(key.value);break;
	    default:
	      return;
	  }
	  var kind = prop.kind;

	  if (this.options.ecmaVersion >= 6) {
	    if (name === "__proto__" && kind === "init") {
	      if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
	      propHash.proto = true;
	    }
	    return;
	  }
	  name = "$" + name;
	  var other = propHash[name];
	  if (other) {
	    var isGetSet = kind !== "init";
	    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init)) this.raise(key.start, "Redefinition of property");
	  } else {
	    other = propHash[name] = {
	      init: false,
	      get: false,
	      set: false
	    };
	  }
	  other[kind] = true;
	};

	// ### Expression parsing

	// These nest, from the most general expression type at the top to
	// 'atomic', nondivisible expression types at the bottom. Most of
	// the functions will simply let the function(s) below them parse,
	// and, *if* the syntactic construct they handle is present, wrap
	// the AST node that the inner parser gave them in another node.

	// Parse a full expression. The optional arguments are used to
	// forbid the `in` operator (in for loops initalization expressions)
	// and provide reference for storing '=' operator inside shorthand
	// property assignment in contexts where both object expression
	// and object pattern might appear (so it's possible to raise
	// delayed syntax error at correct position).

	pp.parseExpression = function (noIn, refDestructuringErrors) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
	  if (this.type === _tokentype.types.comma) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.expressions = [expr];
	    while (this.eat(_tokentype.types.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors));
	    return this.finishNode(node, "SequenceExpression");
	  }
	  return expr;
	};

	// Parse an assignment expression. This includes applications of
	// operators like `+=`.

	pp.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {
	  if (this.type == _tokentype.types._yield && this.inGenerator) return this.parseYield();

	  var validateDestructuring = false;
	  if (!refDestructuringErrors) {
	    refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
	    validateDestructuring = true;
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  if (this.type == _tokentype.types.parenL || this.type == _tokentype.types.name) this.potentialArrowAt = this.start;
	  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
	  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
	  if (this.type.isAssign) {
	    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true);
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    node.left = this.type === _tokentype.types.eq ? this.toAssignable(left) : left;
	    refDestructuringErrors.shorthandAssign = 0; // reset because shorthand default was used correctly
	    this.checkLVal(left);
	    this.next();
	    node.right = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "AssignmentExpression");
	  } else {
	    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true);
	  }
	  return left;
	};

	// Parse a ternary conditional (`?:`) operator.

	pp.parseMaybeConditional = function (noIn, refDestructuringErrors) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprOps(noIn, refDestructuringErrors);
	  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	  if (this.eat(_tokentype.types.question)) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.test = expr;
	    node.consequent = this.parseMaybeAssign();
	    this.expect(_tokentype.types.colon);
	    node.alternate = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "ConditionalExpression");
	  }
	  return expr;
	};

	// Start the precedence parser.

	pp.parseExprOps = function (noIn, refDestructuringErrors) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseMaybeUnary(refDestructuringErrors);
	  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	  return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
	};

	// Parse binary operators with the operator precedence parsing
	// algorithm. `left` is the left-hand side of the operator.
	// `minPrec` provides context that allows the function to stop and
	// defer further parser to one of its callers when it encounters an
	// operator that has a lower precedence than the set it is parsing.

	pp.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
	  var prec = this.type.binop;
	  if (prec != null && (!noIn || this.type !== _tokentype.types._in)) {
	    if (prec > minPrec) {
	      var node = this.startNodeAt(leftStartPos, leftStartLoc);
	      node.left = left;
	      node.operator = this.value;
	      var op = this.type;
	      this.next();
	      var startPos = this.start,
	          startLoc = this.startLoc;
	      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);
	      this.finishNode(node, op === _tokentype.types.logicalOR || op === _tokentype.types.logicalAND ? "LogicalExpression" : "BinaryExpression");
	      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
	    }
	  }
	  return left;
	};

	// Parse unary operators, both prefix and postfix.

	pp.parseMaybeUnary = function (refDestructuringErrors) {
	  if (this.type.prefix) {
	    var node = this.startNode(),
	        update = this.type === _tokentype.types.incDec;
	    node.operator = this.value;
	    node.prefix = true;
	    this.next();
	    node.argument = this.parseMaybeUnary();
	    this.checkExpressionErrors(refDestructuringErrors, true);
	    if (update) this.checkLVal(node.argument);else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") this.raise(node.start, "Deleting local variable in strict mode");
	    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprSubscripts(refDestructuringErrors);
	  if (this.checkExpressionErrors(refDestructuringErrors)) return expr;
	  while (this.type.postfix && !this.canInsertSemicolon()) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.operator = this.value;
	    node.prefix = false;
	    node.argument = expr;
	    this.checkLVal(expr);
	    this.next();
	    expr = this.finishNode(node, "UpdateExpression");
	  }
	  return expr;
	};

	// Parse call, dot, and `[]`-subscript expressions.

	pp.parseExprSubscripts = function (refDestructuringErrors) {
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  var expr = this.parseExprAtom(refDestructuringErrors);
	  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
	  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr;
	  return this.parseSubscripts(expr, startPos, startLoc);
	};

	pp.parseSubscripts = function (base, startPos, startLoc, noCalls) {
	  for (;;) {
	    if (this.eat(_tokentype.types.dot)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.object = base;
	      node.property = this.parseIdent(true);
	      node.computed = false;
	      base = this.finishNode(node, "MemberExpression");
	    } else if (this.eat(_tokentype.types.bracketL)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.object = base;
	      node.property = this.parseExpression();
	      node.computed = true;
	      this.expect(_tokentype.types.bracketR);
	      base = this.finishNode(node, "MemberExpression");
	    } else if (!noCalls && this.eat(_tokentype.types.parenL)) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.callee = base;
	      node.arguments = this.parseExprList(_tokentype.types.parenR, false);
	      base = this.finishNode(node, "CallExpression");
	    } else if (this.type === _tokentype.types.backQuote) {
	      var node = this.startNodeAt(startPos, startLoc);
	      node.tag = base;
	      node.quasi = this.parseTemplate();
	      base = this.finishNode(node, "TaggedTemplateExpression");
	    } else {
	      return base;
	    }
	  }
	};

	// Parse an atomic expression — either a single token that is an
	// expression, an expression started by a keyword like `function` or
	// `new`, or an expression wrapped in punctuation like `()`, `[]`,
	// or `{}`.

	pp.parseExprAtom = function (refDestructuringErrors) {
	  var node = undefined,
	      canBeArrow = this.potentialArrowAt == this.start;
	  switch (this.type) {
	    case _tokentype.types._super:
	      if (!this.inFunction) this.raise(this.start, "'super' outside of function or class");
	    case _tokentype.types._this:
	      var type = this.type === _tokentype.types._this ? "ThisExpression" : "Super";
	      node = this.startNode();
	      this.next();
	      return this.finishNode(node, type);

	    case _tokentype.types._yield:
	      if (this.inGenerator) this.unexpected();

	    case _tokentype.types.name:
	      var startPos = this.start,
	          startLoc = this.startLoc;
	      var id = this.parseIdent(this.type !== _tokentype.types.name);
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id]);
	      return id;

	    case _tokentype.types.regexp:
	      var value = this.value;
	      node = this.parseLiteral(value.value);
	      node.regex = { pattern: value.pattern, flags: value.flags };
	      return node;

	    case _tokentype.types.num:case _tokentype.types.string:
	      return this.parseLiteral(this.value);

	    case _tokentype.types._null:case _tokentype.types._true:case _tokentype.types._false:
	      node = this.startNode();
	      node.value = this.type === _tokentype.types._null ? null : this.type === _tokentype.types._true;
	      node.raw = this.type.keyword;
	      this.next();
	      return this.finishNode(node, "Literal");

	    case _tokentype.types.parenL:
	      return this.parseParenAndDistinguishExpression(canBeArrow);

	    case _tokentype.types.bracketL:
	      node = this.startNode();
	      this.next();
	      // check whether this is array comprehension or regular array
	      if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
	        return this.parseComprehension(node, false);
	      }
	      node.elements = this.parseExprList(_tokentype.types.bracketR, true, true, refDestructuringErrors);
	      return this.finishNode(node, "ArrayExpression");

	    case _tokentype.types.braceL:
	      return this.parseObj(false, refDestructuringErrors);

	    case _tokentype.types._function:
	      node = this.startNode();
	      this.next();
	      return this.parseFunction(node, false);

	    case _tokentype.types._class:
	      return this.parseClass(this.startNode(), false);

	    case _tokentype.types._new:
	      return this.parseNew();

	    case _tokentype.types.backQuote:
	      return this.parseTemplate();

	    default:
	      this.unexpected();
	  }
	};

	pp.parseLiteral = function (value) {
	  var node = this.startNode();
	  node.value = value;
	  node.raw = this.input.slice(this.start, this.end);
	  this.next();
	  return this.finishNode(node, "Literal");
	};

	pp.parseParenExpression = function () {
	  this.expect(_tokentype.types.parenL);
	  var val = this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  return val;
	};

	pp.parseParenAndDistinguishExpression = function (canBeArrow) {
	  var startPos = this.start,
	      startLoc = this.startLoc,
	      val = undefined;
	  if (this.options.ecmaVersion >= 6) {
	    this.next();

	    if (this.options.ecmaVersion >= 7 && this.type === _tokentype.types._for) {
	      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true);
	    }

	    var innerStartPos = this.start,
	        innerStartLoc = this.startLoc;
	    var exprList = [],
	        first = true;
	    var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 },
	        spreadStart = undefined,
	        innerParenStart = undefined;
	    while (this.type !== _tokentype.types.parenR) {
	      first ? first = false : this.expect(_tokentype.types.comma);
	      if (this.type === _tokentype.types.ellipsis) {
	        spreadStart = this.start;
	        exprList.push(this.parseParenItem(this.parseRest()));
	        break;
	      } else {
	        if (this.type === _tokentype.types.parenL && !innerParenStart) {
	          innerParenStart = this.start;
	        }
	        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
	      }
	    }
	    var innerEndPos = this.start,
	        innerEndLoc = this.startLoc;
	    this.expect(_tokentype.types.parenR);

	    if (canBeArrow && !this.canInsertSemicolon() && this.eat(_tokentype.types.arrow)) {
	      this.checkPatternErrors(refDestructuringErrors, true);
	      if (innerParenStart) this.unexpected(innerParenStart);
	      return this.parseParenArrowList(startPos, startLoc, exprList);
	    }

	    if (!exprList.length) this.unexpected(this.lastTokStart);
	    if (spreadStart) this.unexpected(spreadStart);
	    this.checkExpressionErrors(refDestructuringErrors, true);

	    if (exprList.length > 1) {
	      val = this.startNodeAt(innerStartPos, innerStartLoc);
	      val.expressions = exprList;
	      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
	    } else {
	      val = exprList[0];
	    }
	  } else {
	    val = this.parseParenExpression();
	  }

	  if (this.options.preserveParens) {
	    var par = this.startNodeAt(startPos, startLoc);
	    par.expression = val;
	    return this.finishNode(par, "ParenthesizedExpression");
	  } else {
	    return val;
	  }
	};

	pp.parseParenItem = function (item) {
	  return item;
	};

	pp.parseParenArrowList = function (startPos, startLoc, exprList) {
	  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);
	};

	// New's precedence is slightly tricky. It must allow its argument
	// to be a `[]` or dot subscript expression, but not a call — at
	// least, not without wrapping it in parentheses. Thus, it uses the

	var empty = [];

	pp.parseNew = function () {
	  var node = this.startNode();
	  var meta = this.parseIdent(true);
	  if (this.options.ecmaVersion >= 6 && this.eat(_tokentype.types.dot)) {
	    node.meta = meta;
	    node.property = this.parseIdent(true);
	    if (node.property.name !== "target") this.raise(node.property.start, "The only valid meta property for new is new.target");
	    if (!this.inFunction) this.raise(node.start, "new.target can only be used in functions");
	    return this.finishNode(node, "MetaProperty");
	  }
	  var startPos = this.start,
	      startLoc = this.startLoc;
	  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
	  if (this.eat(_tokentype.types.parenL)) node.arguments = this.parseExprList(_tokentype.types.parenR, false);else node.arguments = empty;
	  return this.finishNode(node, "NewExpression");
	};

	// Parse template expression.

	pp.parseTemplateElement = function () {
	  var elem = this.startNode();
	  elem.value = {
	    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
	    cooked: this.value
	  };
	  this.next();
	  elem.tail = this.type === _tokentype.types.backQuote;
	  return this.finishNode(elem, "TemplateElement");
	};

	pp.parseTemplate = function () {
	  var node = this.startNode();
	  this.next();
	  node.expressions = [];
	  var curElt = this.parseTemplateElement();
	  node.quasis = [curElt];
	  while (!curElt.tail) {
	    this.expect(_tokentype.types.dollarBraceL);
	    node.expressions.push(this.parseExpression());
	    this.expect(_tokentype.types.braceR);
	    node.quasis.push(curElt = this.parseTemplateElement());
	  }
	  this.next();
	  return this.finishNode(node, "TemplateLiteral");
	};

	// Parse an object literal or binding pattern.

	pp.parseObj = function (isPattern, refDestructuringErrors) {
	  var node = this.startNode(),
	      first = true,
	      propHash = {};
	  node.properties = [];
	  this.next();
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;

	    var prop = this.startNode(),
	        isGenerator = undefined,
	        startPos = undefined,
	        startLoc = undefined;
	    if (this.options.ecmaVersion >= 6) {
	      prop.method = false;
	      prop.shorthand = false;
	      if (isPattern || refDestructuringErrors) {
	        startPos = this.start;
	        startLoc = this.startLoc;
	      }
	      if (!isPattern) isGenerator = this.eat(_tokentype.types.star);
	    }
	    this.parsePropertyName(prop);
	    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors);
	    this.checkPropClash(prop, propHash);
	    node.properties.push(this.finishNode(prop, "Property"));
	  }
	  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
	};

	pp.parsePropertyValue = function (prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
	  if (this.eat(_tokentype.types.colon)) {
	    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
	    prop.kind = "init";
	  } else if (this.options.ecmaVersion >= 6 && this.type === _tokentype.types.parenL) {
	    if (isPattern) this.unexpected();
	    prop.kind = "init";
	    prop.method = true;
	    prop.value = this.parseMethod(isGenerator);
	  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type != _tokentype.types.comma && this.type != _tokentype.types.braceR)) {
	    if (isGenerator || isPattern) this.unexpected();
	    prop.kind = prop.key.name;
	    this.parsePropertyName(prop);
	    prop.value = this.parseMethod(false);
	    var paramCount = prop.kind === "get" ? 0 : 1;
	    if (prop.value.params.length !== paramCount) {
	      var start = prop.value.start;
	      if (prop.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
	    }
	  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	    prop.kind = "init";
	    if (isPattern) {
	      if (this.keywords.test(prop.key.name) || (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name)) this.raise(prop.key.start, "Binding " + prop.key.name);
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else if (this.type === _tokentype.types.eq && refDestructuringErrors) {
	      if (!refDestructuringErrors.shorthandAssign) refDestructuringErrors.shorthandAssign = this.start;
	      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
	    } else {
	      prop.value = prop.key;
	    }
	    prop.shorthand = true;
	  } else this.unexpected();
	};

	pp.parsePropertyName = function (prop) {
	  if (this.options.ecmaVersion >= 6) {
	    if (this.eat(_tokentype.types.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseMaybeAssign();
	      this.expect(_tokentype.types.bracketR);
	      return prop.key;
	    } else {
	      prop.computed = false;
	    }
	  }
	  return prop.key = this.type === _tokentype.types.num || this.type === _tokentype.types.string ? this.parseExprAtom() : this.parseIdent(true);
	};

	// Initialize empty function node.

	pp.initFunction = function (node) {
	  node.id = null;
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = false;
	    node.expression = false;
	  }
	};

	// Parse object or class method.

	pp.parseMethod = function (isGenerator) {
	  var node = this.startNode();
	  this.initFunction(node);
	  this.expect(_tokentype.types.parenL);
	  node.params = this.parseBindingList(_tokentype.types.parenR, false, false);
	  if (this.options.ecmaVersion >= 6) node.generator = isGenerator;
	  this.parseFunctionBody(node, false);
	  return this.finishNode(node, "FunctionExpression");
	};

	// Parse arrow function expression with given parameters.

	pp.parseArrowExpression = function (node, params) {
	  this.initFunction(node);
	  node.params = this.toAssignableList(params, true);
	  this.parseFunctionBody(node, true);
	  return this.finishNode(node, "ArrowFunctionExpression");
	};

	// Parse function body and check parameters.

	pp.parseFunctionBody = function (node, isArrowFunction) {
	  var isExpression = isArrowFunction && this.type !== _tokentype.types.braceL;

	  if (isExpression) {
	    node.body = this.parseMaybeAssign();
	    node.expression = true;
	  } else {
	    // Start a new scope with regard to labels and the `inFunction`
	    // flag (restore them to their old value afterwards).
	    var oldInFunc = this.inFunction,
	        oldInGen = this.inGenerator,
	        oldLabels = this.labels;
	    this.inFunction = true;this.inGenerator = node.generator;this.labels = [];
	    node.body = this.parseBlock(true);
	    node.expression = false;
	    this.inFunction = oldInFunc;this.inGenerator = oldInGen;this.labels = oldLabels;
	  }

	  // If this is a strict mode function, verify that argument names
	  // are not repeated, and it does not try to bind the words `eval`
	  // or `arguments`.
	  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {
	    var oldStrict = this.strict;
	    this.strict = true;
	    if (node.id) this.checkLVal(node.id, true);
	    this.checkParams(node);
	    this.strict = oldStrict;
	  } else if (isArrowFunction) {
	    this.checkParams(node);
	  }
	};

	// Checks function params for various disallowed patterns such as using "eval"
	// or "arguments" and duplicate parameters.

	pp.checkParams = function (node) {
	  var nameHash = {};
	  for (var i = 0; i < node.params.length; i++) {
	    this.checkLVal(node.params[i], true, nameHash);
	  }
	};

	// Parses a comma-separated list of expressions, and returns them as
	// an array. `close` is the token type that ends the list, and
	// `allowEmpty` can be turned on to allow subsequent commas with
	// nothing in between them to be parsed as `null` (which is needed
	// for array literals).

	pp.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
	        refDestructuringErrors.trailingComma = this.lastTokStart;
	      }
	      if (allowTrailingComma && this.afterTrailingComma(close)) break;
	    } else first = false;

	    var elt = undefined;
	    if (allowEmpty && this.type === _tokentype.types.comma) elt = null;else if (this.type === _tokentype.types.ellipsis) elt = this.parseSpread(refDestructuringErrors);else elt = this.parseMaybeAssign(false, refDestructuringErrors);
	    elts.push(elt);
	  }
	  return elts;
	};

	// Parse the next token as an identifier. If `liberal` is true (used
	// when parsing properties), it will also convert keywords into
	// identifiers.

	pp.parseIdent = function (liberal) {
	  var node = this.startNode();
	  if (liberal && this.options.allowReserved == "never") liberal = false;
	  if (this.type === _tokentype.types.name) {
	    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) && (this.options.ecmaVersion >= 6 || this.input.slice(this.start, this.end).indexOf("\\") == -1)) this.raise(this.start, "The keyword '" + this.value + "' is reserved");
	    node.name = this.value;
	  } else if (liberal && this.type.keyword) {
	    node.name = this.type.keyword;
	  } else {
	    this.unexpected();
	  }
	  this.next();
	  return this.finishNode(node, "Identifier");
	};

	// Parses yield expression inside generator.

	pp.parseYield = function () {
	  var node = this.startNode();
	  this.next();
	  if (this.type == _tokentype.types.semi || this.canInsertSemicolon() || this.type != _tokentype.types.star && !this.type.startsExpr) {
	    node.delegate = false;
	    node.argument = null;
	  } else {
	    node.delegate = this.eat(_tokentype.types.star);
	    node.argument = this.parseMaybeAssign();
	  }
	  return this.finishNode(node, "YieldExpression");
	};

	// Parses array and generator comprehensions.

	pp.parseComprehension = function (node, isGenerator) {
	  node.blocks = [];
	  while (this.type === _tokentype.types._for) {
	    var block = this.startNode();
	    this.next();
	    this.expect(_tokentype.types.parenL);
	    block.left = this.parseBindingAtom();
	    this.checkLVal(block.left, true);
	    this.expectContextual("of");
	    block.right = this.parseExpression();
	    this.expect(_tokentype.types.parenR);
	    node.blocks.push(this.finishNode(block, "ComprehensionBlock"));
	  }
	  node.filter = this.eat(_tokentype.types._if) ? this.parseParenExpression() : null;
	  node.body = this.parseExpression();
	  this.expect(isGenerator ? _tokentype.types.parenR : _tokentype.types.bracketR);
	  node.generator = isGenerator;
	  return this.finishNode(node, "ComprehensionExpression");
	};

	},{"./state":10,"./tokentype":14}],2:[function(_dereq_,module,exports){
	// This is a trick taken from Esprima. It turns out that, on
	// non-Chrome browsers, to check whether a string is in a set, a
	// predicate containing a big ugly `switch` statement is faster than
	// a regular expression, and on Chrome the two are about on par.
	// This function uses `eval` (non-lexical) to produce such a
	// predicate from a space-separated string of words.
	//
	// It starts by sorting the words by length.

	// Reserved word lists for various dialects of the language

	"use strict";

	exports.__esModule = true;
	exports.isIdentifierStart = isIdentifierStart;
	exports.isIdentifierChar = isIdentifierChar;
	var reservedWords = {
	  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	  5: "class enum extends super const export import",
	  6: "enum",
	  strict: "implements interface let package private protected public static yield",
	  strictBind: "eval arguments"
	};

	exports.reservedWords = reservedWords;
	// And the keywords

	var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

	var keywords = {
	  5: ecma5AndLessKeywords,
	  6: ecma5AndLessKeywords + " let const class extends export import yield super"
	};

	exports.keywords = keywords;
	// ## Character categories

	// Big ugly regular expressions that match characters in the
	// whitespace, identifier, and identifier-start categories. These
	// are only applied when a character is found to actually have a
	// code point above 128.
	// Generated by `bin/generate-identifier-regex.js`.

	var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙա-ևא-תװ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࢠ-ࢲऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘౙౠౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൠൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄງຈຊຍດ-ທນ-ຟມ-ຣລວສຫອ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏼᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡷᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᧁ-ᧇᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᳩ-ᳬᳮ-ᳱᳵᳶᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄭㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿌ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞎꞐ-ꞭꞰꞱꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭟꭤꭥꯀ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
	var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣤ-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఃా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഁ-ഃാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ູົຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏ᦰ-ᧀᧈᧉ᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭ᳲ-᳴᳸᳹᷀-᷵᷼-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-꣄꣐-꣙꣠-꣱꤀-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︭︳︴﹍-﹏０-９＿";

	var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
	var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

	nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

	// These are a run-length and offset encoded representation of the
	// >0xffff code points that are a valid part of identifiers. The
	// offset starts at 0x10000, and each pair of numbers represents an
	// offset to the next range, and then a size of the range. They were
	// generated by tools/generate-identifier-regex.js
	var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 99, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 98, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 955, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 38, 17, 2, 24, 133, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 32, 4, 287, 47, 21, 1, 2, 0, 185, 46, 82, 47, 21, 0, 60, 42, 502, 63, 32, 0, 449, 56, 1288, 920, 104, 110, 2962, 1070, 13266, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 16481, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 1340, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 16355, 541];
	var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 16, 9, 83, 11, 168, 11, 6, 9, 8, 2, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 316, 19, 13, 9, 214, 6, 3, 8, 112, 16, 16, 9, 82, 12, 9, 9, 535, 9, 20855, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 4305, 6, 792618, 239];

	// This has a complexity linear to the value of the code. The
	// assumption is that looking up astral identifier characters is
	// rare.
	function isInAstralSet(code, set) {
	  var pos = 0x10000;
	  for (var i = 0; i < set.length; i += 2) {
	    pos += set[i];
	    if (pos > code) return false;
	    pos += set[i + 1];
	    if (pos >= code) return true;
	  }
	}

	// Test whether a given character code starts an identifier.

	function isIdentifierStart(code, astral) {
	  if (code < 65) return code === 36;
	  if (code < 91) return true;
	  if (code < 97) return code === 95;
	  if (code < 123) return true;
	  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
	  if (astral === false) return false;
	  return isInAstralSet(code, astralIdentifierStartCodes);
	}

	// Test whether a given character is part of an identifier.

	function isIdentifierChar(code, astral) {
	  if (code < 48) return code === 36;
	  if (code < 58) return true;
	  if (code < 65) return false;
	  if (code < 91) return true;
	  if (code < 97) return code === 95;
	  if (code < 123) return true;
	  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
	  if (astral === false) return false;
	  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
	}

	},{}],3:[function(_dereq_,module,exports){
	// Acorn is a tiny, fast JavaScript parser written in JavaScript.
	//
	// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
	// various contributors and released under an MIT license.
	//
	// Git repositories for Acorn are available at
	//
	//     http://marijnhaverbeke.nl/git/acorn
	//     https://github.com/ternjs/acorn.git
	//
	// Please use the [github bug tracker][ghbt] to report issues.
	//
	// [ghbt]: https://github.com/ternjs/acorn/issues
	//
	// This file defines the main parser interface. The library also comes
	// with a [error-tolerant parser][dammit] and an
	// [abstract syntax tree walker][walk], defined in other files.
	//
	// [dammit]: acorn_loose.js
	// [walk]: util/walk.js

	"use strict";

	exports.__esModule = true;
	exports.parse = parse;
	exports.parseExpressionAt = parseExpressionAt;
	exports.tokenizer = tokenizer;

	var _state = _dereq_("./state");

	_dereq_("./parseutil");

	_dereq_("./statement");

	_dereq_("./lval");

	_dereq_("./expression");

	_dereq_("./location");

	exports.Parser = _state.Parser;
	exports.plugins = _state.plugins;

	var _options = _dereq_("./options");

	exports.defaultOptions = _options.defaultOptions;

	var _locutil = _dereq_("./locutil");

	exports.Position = _locutil.Position;
	exports.SourceLocation = _locutil.SourceLocation;
	exports.getLineInfo = _locutil.getLineInfo;

	var _node = _dereq_("./node");

	exports.Node = _node.Node;

	var _tokentype = _dereq_("./tokentype");

	exports.TokenType = _tokentype.TokenType;
	exports.tokTypes = _tokentype.types;

	var _tokencontext = _dereq_("./tokencontext");

	exports.TokContext = _tokencontext.TokContext;
	exports.tokContexts = _tokencontext.types;

	var _identifier = _dereq_("./identifier");

	exports.isIdentifierChar = _identifier.isIdentifierChar;
	exports.isIdentifierStart = _identifier.isIdentifierStart;

	var _tokenize = _dereq_("./tokenize");

	exports.Token = _tokenize.Token;

	var _whitespace = _dereq_("./whitespace");

	exports.isNewLine = _whitespace.isNewLine;
	exports.lineBreak = _whitespace.lineBreak;
	exports.lineBreakG = _whitespace.lineBreakG;
	var version = "2.6.4";

	exports.version = version;
	// The main exported interface (under `self.acorn` when in the
	// browser) is a `parse` function that takes a code string and
	// returns an abstract syntax tree as specified by [Mozilla parser
	// API][api].
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

	function parse(input, options) {
	  return new _state.Parser(options, input).parse();
	}

	// This function tries to parse a single expression at a given
	// offset in a string. Useful for parsing mixed-language formats
	// that embed JavaScript expressions.

	function parseExpressionAt(input, pos, options) {
	  var p = new _state.Parser(options, input, pos);
	  p.nextToken();
	  return p.parseExpression();
	}

	// Acorn is organized as a tokenizer and a recursive-descent parser.
	// The `tokenizer` export provides an interface to the tokenizer.

	function tokenizer(input, options) {
	  return new _state.Parser(options, input);
	}

	},{"./expression":1,"./identifier":2,"./location":4,"./locutil":5,"./lval":6,"./node":7,"./options":8,"./parseutil":9,"./state":10,"./statement":11,"./tokencontext":12,"./tokenize":13,"./tokentype":14,"./whitespace":16}],4:[function(_dereq_,module,exports){
	"use strict";

	var _state = _dereq_("./state");

	var _locutil = _dereq_("./locutil");

	var pp = _state.Parser.prototype;

	// This function is used to raise exceptions on parse errors. It
	// takes an offset integer (into the current `input`) to indicate
	// the location of the error, attaches the position to the end
	// of the error message, and then raises a `SyntaxError` with that
	// message.

	pp.raise = function (pos, message) {
	  var loc = _locutil.getLineInfo(this.input, pos);
	  message += " (" + loc.line + ":" + loc.column + ")";
	  var err = new SyntaxError(message);
	  err.pos = pos;err.loc = loc;err.raisedAt = this.pos;
	  throw err;
	};

	pp.curPosition = function () {
	  if (this.options.locations) {
	    return new _locutil.Position(this.curLine, this.pos - this.lineStart);
	  }
	};

	},{"./locutil":5,"./state":10}],5:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.getLineInfo = getLineInfo;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _whitespace = _dereq_("./whitespace");

	// These are used when `options.locations` is on, for the
	// `startLoc` and `endLoc` properties.

	var Position = (function () {
	  function Position(line, col) {
	    _classCallCheck(this, Position);

	    this.line = line;
	    this.column = col;
	  }

	  Position.prototype.offset = function offset(n) {
	    return new Position(this.line, this.column + n);
	  };

	  return Position;
	})();

	exports.Position = Position;

	var SourceLocation = function SourceLocation(p, start, end) {
	  _classCallCheck(this, SourceLocation);

	  this.start = start;
	  this.end = end;
	  if (p.sourceFile !== null) this.source = p.sourceFile;
	}

	// The `getLineInfo` function is mostly useful when the
	// `locations` option is off (for performance reasons) and you
	// want to find the line/column position for a given character
	// offset. `input` should be the code string that the offset refers
	// into.

	;

	exports.SourceLocation = SourceLocation;

	function getLineInfo(input, offset) {
	  for (var line = 1, cur = 0;;) {
	    _whitespace.lineBreakG.lastIndex = cur;
	    var match = _whitespace.lineBreakG.exec(input);
	    if (match && match.index < offset) {
	      ++line;
	      cur = match.index + match[0].length;
	    } else {
	      return new Position(line, offset - cur);
	    }
	  }
	}

	},{"./whitespace":16}],6:[function(_dereq_,module,exports){
	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _util = _dereq_("./util");

	var pp = _state.Parser.prototype;

	// Convert existing expression atom to assignable pattern
	// if possible.

	pp.toAssignable = function (node, isBinding) {
	  if (this.options.ecmaVersion >= 6 && node) {
	    switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	        break;

	      case "ObjectExpression":
	        node.type = "ObjectPattern";
	        for (var i = 0; i < node.properties.length; i++) {
	          var prop = node.properties[i];
	          if (prop.kind !== "init") this.raise(prop.key.start, "Object pattern can't contain getter or setter");
	          this.toAssignable(prop.value, isBinding);
	        }
	        break;

	      case "ArrayExpression":
	        node.type = "ArrayPattern";
	        this.toAssignableList(node.elements, isBinding);
	        break;

	      case "AssignmentExpression":
	        if (node.operator === "=") {
	          node.type = "AssignmentPattern";
	          delete node.operator;
	          // falls through to AssignmentPattern
	        } else {
	            this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
	            break;
	          }

	      case "AssignmentPattern":
	        if (node.right.type === "YieldExpression") this.raise(node.right.start, "Yield expression cannot be a default value");
	        break;

	      case "ParenthesizedExpression":
	        node.expression = this.toAssignable(node.expression, isBinding);
	        break;

	      case "MemberExpression":
	        if (!isBinding) break;

	      default:
	        this.raise(node.start, "Assigning to rvalue");
	    }
	  }
	  return node;
	};

	// Convert list of expression atoms to binding list.

	pp.toAssignableList = function (exprList, isBinding) {
	  var end = exprList.length;
	  if (end) {
	    var last = exprList[end - 1];
	    if (last && last.type == "RestElement") {
	      --end;
	    } else if (last && last.type == "SpreadElement") {
	      last.type = "RestElement";
	      var arg = last.argument;
	      this.toAssignable(arg, isBinding);
	      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") this.unexpected(arg.start);
	      --end;
	    }

	    if (isBinding && last.type === "RestElement" && last.argument.type !== "Identifier") this.unexpected(last.argument.start);
	  }
	  for (var i = 0; i < end; i++) {
	    var elt = exprList[i];
	    if (elt) this.toAssignable(elt, isBinding);
	  }
	  return exprList;
	};

	// Parses spread element.

	pp.parseSpread = function (refDestructuringErrors) {
	  var node = this.startNode();
	  this.next();
	  node.argument = this.parseMaybeAssign(refDestructuringErrors);
	  return this.finishNode(node, "SpreadElement");
	};

	pp.parseRest = function (allowNonIdent) {
	  var node = this.startNode();
	  this.next();

	  // RestElement inside of a function parameter must be an identifier
	  if (allowNonIdent) node.argument = this.type === _tokentype.types.name ? this.parseIdent() : this.unexpected();else node.argument = this.type === _tokentype.types.name || this.type === _tokentype.types.bracketL ? this.parseBindingAtom() : this.unexpected();

	  return this.finishNode(node, "RestElement");
	};

	// Parses lvalue (assignable) atom.

	pp.parseBindingAtom = function () {
	  if (this.options.ecmaVersion < 6) return this.parseIdent();
	  switch (this.type) {
	    case _tokentype.types.name:
	      return this.parseIdent();

	    case _tokentype.types.bracketL:
	      var node = this.startNode();
	      this.next();
	      node.elements = this.parseBindingList(_tokentype.types.bracketR, true, true);
	      return this.finishNode(node, "ArrayPattern");

	    case _tokentype.types.braceL:
	      return this.parseObj(true);

	    default:
	      this.unexpected();
	  }
	};

	pp.parseBindingList = function (close, allowEmpty, allowTrailingComma, allowNonIdent) {
	  var elts = [],
	      first = true;
	  while (!this.eat(close)) {
	    if (first) first = false;else this.expect(_tokentype.types.comma);
	    if (allowEmpty && this.type === _tokentype.types.comma) {
	      elts.push(null);
	    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
	      break;
	    } else if (this.type === _tokentype.types.ellipsis) {
	      var rest = this.parseRest(allowNonIdent);
	      this.parseBindingListItem(rest);
	      elts.push(rest);
	      this.expect(close);
	      break;
	    } else {
	      var elem = this.parseMaybeDefault(this.start, this.startLoc);
	      this.parseBindingListItem(elem);
	      elts.push(elem);
	    }
	  }
	  return elts;
	};

	pp.parseBindingListItem = function (param) {
	  return param;
	};

	// Parses assignment pattern around given atom if possible.

	pp.parseMaybeDefault = function (startPos, startLoc, left) {
	  left = left || this.parseBindingAtom();
	  if (this.options.ecmaVersion < 6 || !this.eat(_tokentype.types.eq)) return left;
	  var node = this.startNodeAt(startPos, startLoc);
	  node.left = left;
	  node.right = this.parseMaybeAssign();
	  return this.finishNode(node, "AssignmentPattern");
	};

	// Verify that a node is an lval — something that can be assigned
	// to.

	pp.checkLVal = function (expr, isBinding, checkClashes) {
	  switch (expr.type) {
	    case "Identifier":
	      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) this.raise(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
	      if (checkClashes) {
	        if (_util.has(checkClashes, expr.name)) this.raise(expr.start, "Argument name clash");
	        checkClashes[expr.name] = true;
	      }
	      break;

	    case "MemberExpression":
	      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
	      break;

	    case "ObjectPattern":
	      for (var i = 0; i < expr.properties.length; i++) {
	        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
	      }break;

	    case "ArrayPattern":
	      for (var i = 0; i < expr.elements.length; i++) {
	        var elem = expr.elements[i];
	        if (elem) this.checkLVal(elem, isBinding, checkClashes);
	      }
	      break;

	    case "AssignmentPattern":
	      this.checkLVal(expr.left, isBinding, checkClashes);
	      break;

	    case "RestElement":
	      this.checkLVal(expr.argument, isBinding, checkClashes);
	      break;

	    case "ParenthesizedExpression":
	      this.checkLVal(expr.expression, isBinding, checkClashes);
	      break;

	    default:
	      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue");
	  }
	};

	},{"./state":10,"./tokentype":14,"./util":15}],7:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _state = _dereq_("./state");

	var _locutil = _dereq_("./locutil");

	var Node = function Node(parser, pos, loc) {
	  _classCallCheck(this, Node);

	  this.type = "";
	  this.start = pos;
	  this.end = 0;
	  if (parser.options.locations) this.loc = new _locutil.SourceLocation(parser, loc);
	  if (parser.options.directSourceFile) this.sourceFile = parser.options.directSourceFile;
	  if (parser.options.ranges) this.range = [pos, 0];
	}

	// Start an AST node, attaching a start offset.

	;

	exports.Node = Node;
	var pp = _state.Parser.prototype;

	pp.startNode = function () {
	  return new Node(this, this.start, this.startLoc);
	};

	pp.startNodeAt = function (pos, loc) {
	  return new Node(this, pos, loc);
	};

	// Finish an AST node, adding `type` and `end` properties.

	function finishNodeAt(node, type, pos, loc) {
	  node.type = type;
	  node.end = pos;
	  if (this.options.locations) node.loc.end = loc;
	  if (this.options.ranges) node.range[1] = pos;
	  return node;
	}

	pp.finishNode = function (node, type) {
	  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
	};

	// Finish node at given position

	pp.finishNodeAt = function (node, type, pos, loc) {
	  return finishNodeAt.call(this, node, type, pos, loc);
	};

	},{"./locutil":5,"./state":10}],8:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.getOptions = getOptions;

	var _util = _dereq_("./util");

	var _locutil = _dereq_("./locutil");

	// A second optional argument can be given to further configure
	// the parser process. These options are recognized:

	var defaultOptions = {
	  // `ecmaVersion` indicates the ECMAScript version to parse. Must
	  // be either 3, or 5, or 6. This influences support for strict
	  // mode, the set of reserved words, support for getters and
	  // setters and other features.
	  ecmaVersion: 5,
	  // Source type ("script" or "module") for different semantics
	  sourceType: "script",
	  // `onInsertedSemicolon` can be a callback that will be called
	  // when a semicolon is automatically inserted. It will be passed
	  // th position of the comma as an offset, and if `locations` is
	  // enabled, it is given the location as a `{line, column}` object
	  // as second argument.
	  onInsertedSemicolon: null,
	  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	  // trailing commas.
	  onTrailingComma: null,
	  // By default, reserved words are only enforced if ecmaVersion >= 5.
	  // Set `allowReserved` to a boolean value to explicitly turn this on
	  // an off. When this option has the value "never", reserved words
	  // and keywords can also not be used as property names.
	  allowReserved: null,
	  // When enabled, a return at the top level is not considered an
	  // error.
	  allowReturnOutsideFunction: false,
	  // When enabled, import/export statements are not constrained to
	  // appearing at the top of the program.
	  allowImportExportEverywhere: false,
	  // When enabled, hashbang directive in the beginning of file
	  // is allowed and treated as a line comment.
	  allowHashBang: false,
	  // When `locations` is on, `loc` properties holding objects with
	  // `start` and `end` properties in `{line, column}` form (with
	  // line being 1-based and column 0-based) will be attached to the
	  // nodes.
	  locations: false,
	  // A function can be passed as `onToken` option, which will
	  // cause Acorn to call that function with object in the same
	  // format as tokens returned from `tokenizer().getToken()`. Note
	  // that you are not allowed to call the parser from the
	  // callback—that will corrupt its internal state.
	  onToken: null,
	  // A function can be passed as `onComment` option, which will
	  // cause Acorn to call that function with `(block, text, start,
	  // end)` parameters whenever a comment is skipped. `block` is a
	  // boolean indicating whether this is a block (`/* */`) comment,
	  // `text` is the content of the comment, and `start` and `end` are
	  // character offsets that denote the start and end of the comment.
	  // When the `locations` option is on, two more parameters are
	  // passed, the full `{line, column}` locations of the start and
	  // end of the comments. Note that you are not allowed to call the
	  // parser from the callback—that will corrupt its internal state.
	  onComment: null,
	  // Nodes have their start and end characters offsets recorded in
	  // `start` and `end` properties (directly on the node, rather than
	  // the `loc` object, which holds line/column data. To also add a
	  // [semi-standardized][range] `range` property holding a `[start,
	  // end]` array with the same numbers, set the `ranges` option to
	  // `true`.
	  //
	  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	  ranges: false,
	  // It is possible to parse multiple files into a single AST by
	  // passing the tree produced by parsing the first file as
	  // `program` option in subsequent parses. This will add the
	  // toplevel forms of the parsed file to the `Program` (top) node
	  // of an existing parse tree.
	  program: null,
	  // When `locations` is on, you can pass this to record the source
	  // file in every node's `loc` object.
	  sourceFile: null,
	  // This value, if given, is stored in every node, whether
	  // `locations` is on or off.
	  directSourceFile: null,
	  // When enabled, parenthesized expressions are represented by
	  // (non-standard) ParenthesizedExpression nodes
	  preserveParens: false,
	  plugins: {}
	};

	exports.defaultOptions = defaultOptions;
	// Interpret and default an options object

	function getOptions(opts) {
	  var options = {};
	  for (var opt in defaultOptions) {
	    options[opt] = opts && _util.has(opts, opt) ? opts[opt] : defaultOptions[opt];
	  }if (options.allowReserved == null) options.allowReserved = options.ecmaVersion < 5;

	  if (_util.isArray(options.onToken)) {
	    (function () {
	      var tokens = options.onToken;
	      options.onToken = function (token) {
	        return tokens.push(token);
	      };
	    })();
	  }
	  if (_util.isArray(options.onComment)) options.onComment = pushComment(options, options.onComment);

	  return options;
	}

	function pushComment(options, array) {
	  return function (block, text, start, end, startLoc, endLoc) {
	    var comment = {
	      type: block ? 'Block' : 'Line',
	      value: text,
	      start: start,
	      end: end
	    };
	    if (options.locations) comment.loc = new _locutil.SourceLocation(this, startLoc, endLoc);
	    if (options.ranges) comment.range = [start, end];
	    array.push(comment);
	  };
	}

	},{"./locutil":5,"./util":15}],9:[function(_dereq_,module,exports){
	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _whitespace = _dereq_("./whitespace");

	var pp = _state.Parser.prototype;

	// ## Parser utilities

	// Test whether a statement node is the string literal `"use strict"`.

	pp.isUseStrict = function (stmt) {
	  return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && stmt.expression.raw.slice(1, -1) === "use strict";
	};

	// Predicate that tests whether the next token is of the given
	// type, and if yes, consumes it as a side effect.

	pp.eat = function (type) {
	  if (this.type === type) {
	    this.next();
	    return true;
	  } else {
	    return false;
	  }
	};

	// Tests whether parsed token is a contextual keyword.

	pp.isContextual = function (name) {
	  return this.type === _tokentype.types.name && this.value === name;
	};

	// Consumes contextual keyword if possible.

	pp.eatContextual = function (name) {
	  return this.value === name && this.eat(_tokentype.types.name);
	};

	// Asserts that following token is given contextual keyword.

	pp.expectContextual = function (name) {
	  if (!this.eatContextual(name)) this.unexpected();
	};

	// Test whether a semicolon can be inserted at the current position.

	pp.canInsertSemicolon = function () {
	  return this.type === _tokentype.types.eof || this.type === _tokentype.types.braceR || _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	};

	pp.insertSemicolon = function () {
	  if (this.canInsertSemicolon()) {
	    if (this.options.onInsertedSemicolon) this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
	    return true;
	  }
	};

	// Consume a semicolon, or, failing that, see if we are allowed to
	// pretend that there is a semicolon at this position.

	pp.semicolon = function () {
	  if (!this.eat(_tokentype.types.semi) && !this.insertSemicolon()) this.unexpected();
	};

	pp.afterTrailingComma = function (tokType) {
	  if (this.type == tokType) {
	    if (this.options.onTrailingComma) this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
	    this.next();
	    return true;
	  }
	};

	// Expect a token of a given type. If found, consume it, otherwise,
	// raise an unexpected token error.

	pp.expect = function (type) {
	  this.eat(type) || this.unexpected();
	};

	// Raise an unexpected token error.

	pp.unexpected = function (pos) {
	  this.raise(pos != null ? pos : this.start, "Unexpected token");
	};

	pp.checkPatternErrors = function (refDestructuringErrors, andThrow) {
	  var pos = refDestructuringErrors && refDestructuringErrors.trailingComma;
	  if (!andThrow) return !!pos;
	  if (pos) this.raise(pos, "Trailing comma is not permitted in destructuring patterns");
	};

	pp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {
	  var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign;
	  if (!andThrow) return !!pos;
	  if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns");
	};

	},{"./state":10,"./tokentype":14,"./whitespace":16}],10:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _identifier = _dereq_("./identifier");

	var _tokentype = _dereq_("./tokentype");

	var _whitespace = _dereq_("./whitespace");

	var _options = _dereq_("./options");

	// Registered plugins
	var plugins = {};

	exports.plugins = plugins;
	function keywordRegexp(words) {
	  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
	}

	var Parser = (function () {
	  function Parser(options, input, startPos) {
	    _classCallCheck(this, Parser);

	    this.options = options = _options.getOptions(options);
	    this.sourceFile = options.sourceFile;
	    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
	    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
	    this.reservedWords = keywordRegexp(reserved);
	    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
	    this.reservedWordsStrict = keywordRegexp(reservedStrict);
	    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
	    this.input = String(input);

	    // Used to signal to callers of `readWord1` whether the word
	    // contained any escape sequences. This is needed because words with
	    // escape sequences must not be interpreted as keywords.
	    this.containsEsc = false;

	    // Load plugins
	    this.loadPlugins(options.plugins);

	    // Set up token state

	    // The current position of the tokenizer in the input.
	    if (startPos) {
	      this.pos = startPos;
	      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
	      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
	    } else {
	      this.pos = this.lineStart = 0;
	      this.curLine = 1;
	    }

	    // Properties of the current token:
	    // Its type
	    this.type = _tokentype.types.eof;
	    // For tokens that include more information than their type, the value
	    this.value = null;
	    // Its start and end offset
	    this.start = this.end = this.pos;
	    // And, if locations are used, the {line, column} object
	    // corresponding to those offsets
	    this.startLoc = this.endLoc = this.curPosition();

	    // Position information for the previous token
	    this.lastTokEndLoc = this.lastTokStartLoc = null;
	    this.lastTokStart = this.lastTokEnd = this.pos;

	    // The context stack is used to superficially track syntactic
	    // context to predict whether a regular expression is allowed in a
	    // given position.
	    this.context = this.initialContext();
	    this.exprAllowed = true;

	    // Figure out if it's a module code.
	    this.strict = this.inModule = options.sourceType === "module";

	    // Used to signify the start of a potential arrow function
	    this.potentialArrowAt = -1;

	    // Flags to track whether we are in a function, a generator.
	    this.inFunction = this.inGenerator = false;
	    // Labels in scope.
	    this.labels = [];

	    // If enabled, skip leading hashbang line.
	    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);
	  }

	  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them

	  Parser.prototype.isKeyword = function isKeyword(word) {
	    return this.keywords.test(word);
	  };

	  Parser.prototype.isReservedWord = function isReservedWord(word) {
	    return this.reservedWords.test(word);
	  };

	  Parser.prototype.extend = function extend(name, f) {
	    this[name] = f(this[name]);
	  };

	  Parser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
	    for (var _name in pluginConfigs) {
	      var plugin = plugins[_name];
	      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
	      plugin(this, pluginConfigs[_name]);
	    }
	  };

	  Parser.prototype.parse = function parse() {
	    var node = this.options.program || this.startNode();
	    this.nextToken();
	    return this.parseTopLevel(node);
	  };

	  return Parser;
	})();

	exports.Parser = Parser;

	},{"./identifier":2,"./options":8,"./tokentype":14,"./whitespace":16}],11:[function(_dereq_,module,exports){
	"use strict";

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _whitespace = _dereq_("./whitespace");

	var pp = _state.Parser.prototype;

	// ### Statement parsing

	// Parse a program. Initializes the parser, reads any number of
	// statements, and wraps them in a Program node.  Optionally takes a
	// `program` argument.  If present, the statements will be appended
	// to its body instead of creating a new node.

	pp.parseTopLevel = function (node) {
	  var first = true;
	  if (!node.body) node.body = [];
	  while (this.type !== _tokentype.types.eof) {
	    var stmt = this.parseStatement(true, true);
	    node.body.push(stmt);
	    if (first) {
	      if (this.isUseStrict(stmt)) this.setStrict(true);
	      first = false;
	    }
	  }
	  this.next();
	  if (this.options.ecmaVersion >= 6) {
	    node.sourceType = this.options.sourceType;
	  }
	  return this.finishNode(node, "Program");
	};

	var loopLabel = { kind: "loop" },
	    switchLabel = { kind: "switch" };

	// Parse a single statement.
	//
	// If expecting a statement and finding a slash operator, parse a
	// regular expression literal. This is to handle cases like
	// `if (foo) /blah/.exec(foo)`, where looking at the previous token
	// does not help.

	pp.parseStatement = function (declaration, topLevel) {
	  var starttype = this.type,
	      node = this.startNode();

	  // Most types of statements are recognized by the keyword they
	  // start with. Many are trivial to parse, some require a bit of
	  // complexity.

	  switch (starttype) {
	    case _tokentype.types._break:case _tokentype.types._continue:
	      return this.parseBreakContinueStatement(node, starttype.keyword);
	    case _tokentype.types._debugger:
	      return this.parseDebuggerStatement(node);
	    case _tokentype.types._do:
	      return this.parseDoStatement(node);
	    case _tokentype.types._for:
	      return this.parseForStatement(node);
	    case _tokentype.types._function:
	      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected();
	      return this.parseFunctionStatement(node);
	    case _tokentype.types._class:
	      if (!declaration) this.unexpected();
	      return this.parseClass(node, true);
	    case _tokentype.types._if:
	      return this.parseIfStatement(node);
	    case _tokentype.types._return:
	      return this.parseReturnStatement(node);
	    case _tokentype.types._switch:
	      return this.parseSwitchStatement(node);
	    case _tokentype.types._throw:
	      return this.parseThrowStatement(node);
	    case _tokentype.types._try:
	      return this.parseTryStatement(node);
	    case _tokentype.types._let:case _tokentype.types._const:
	      if (!declaration) this.unexpected(); // NOTE: falls through to _var
	    case _tokentype.types._var:
	      return this.parseVarStatement(node, starttype);
	    case _tokentype.types._while:
	      return this.parseWhileStatement(node);
	    case _tokentype.types._with:
	      return this.parseWithStatement(node);
	    case _tokentype.types.braceL:
	      return this.parseBlock();
	    case _tokentype.types.semi:
	      return this.parseEmptyStatement(node);
	    case _tokentype.types._export:
	    case _tokentype.types._import:
	      if (!this.options.allowImportExportEverywhere) {
	        if (!topLevel) this.raise(this.start, "'import' and 'export' may only appear at the top level");
	        if (!this.inModule) this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
	      }
	      return starttype === _tokentype.types._import ? this.parseImport(node) : this.parseExport(node);

	    // If the statement does not start with a statement keyword or a
	    // brace, it's an ExpressionStatement or LabeledStatement. We
	    // simply start parsing an expression, and afterwards, if the
	    // next token is a colon and the expression was a simple
	    // Identifier node, we switch to interpreting it as a label.
	    default:
	      var maybeName = this.value,
	          expr = this.parseExpression();
	      if (starttype === _tokentype.types.name && expr.type === "Identifier" && this.eat(_tokentype.types.colon)) return this.parseLabeledStatement(node, maybeName, expr);else return this.parseExpressionStatement(node, expr);
	  }
	};

	pp.parseBreakContinueStatement = function (node, keyword) {
	  var isBreak = keyword == "break";
	  this.next();
	  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.label = null;else if (this.type !== _tokentype.types.name) this.unexpected();else {
	    node.label = this.parseIdent();
	    this.semicolon();
	  }

	  // Verify that there is an actual destination to break or
	  // continue to.
	  for (var i = 0; i < this.labels.length; ++i) {
	    var lab = this.labels[i];
	    if (node.label == null || lab.name === node.label.name) {
	      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
	      if (node.label && isBreak) break;
	    }
	  }
	  if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
	  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
	};

	pp.parseDebuggerStatement = function (node) {
	  this.next();
	  this.semicolon();
	  return this.finishNode(node, "DebuggerStatement");
	};

	pp.parseDoStatement = function (node) {
	  this.next();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  this.expect(_tokentype.types._while);
	  node.test = this.parseParenExpression();
	  if (this.options.ecmaVersion >= 6) this.eat(_tokentype.types.semi);else this.semicolon();
	  return this.finishNode(node, "DoWhileStatement");
	};

	// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	// loop is non-trivial. Basically, we have to parse the init `var`
	// statement or expression, disallowing the `in` operator (see
	// the second parameter to `parseExpression`), and then check
	// whether the next token is `in` or `of`. When there is no init
	// part (semicolon immediately after the opening parenthesis), it
	// is a regular `for` loop.

	pp.parseForStatement = function (node) {
	  this.next();
	  this.labels.push(loopLabel);
	  this.expect(_tokentype.types.parenL);
	  if (this.type === _tokentype.types.semi) return this.parseFor(node, null);
	  if (this.type === _tokentype.types._var || this.type === _tokentype.types._let || this.type === _tokentype.types._const) {
	    var _init = this.startNode(),
	        varKind = this.type;
	    this.next();
	    this.parseVar(_init, true, varKind);
	    this.finishNode(_init, "VariableDeclaration");
	    if ((this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && _init.declarations.length === 1 && !(varKind !== _tokentype.types._var && _init.declarations[0].init)) return this.parseForIn(node, _init);
	    return this.parseFor(node, _init);
	  }
	  var refDestructuringErrors = { shorthandAssign: 0, trailingComma: 0 };
	  var init = this.parseExpression(true, refDestructuringErrors);
	  if (this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) {
	    this.checkPatternErrors(refDestructuringErrors, true);
	    this.toAssignable(init);
	    this.checkLVal(init);
	    return this.parseForIn(node, init);
	  } else {
	    this.checkExpressionErrors(refDestructuringErrors, true);
	  }
	  return this.parseFor(node, init);
	};

	pp.parseFunctionStatement = function (node) {
	  this.next();
	  return this.parseFunction(node, true);
	};

	pp.parseIfStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  node.consequent = this.parseStatement(false);
	  node.alternate = this.eat(_tokentype.types._else) ? this.parseStatement(false) : null;
	  return this.finishNode(node, "IfStatement");
	};

	pp.parseReturnStatement = function (node) {
	  if (!this.inFunction && !this.options.allowReturnOutsideFunction) this.raise(this.start, "'return' outside of function");
	  this.next();

	  // In `return` (and `break`/`continue`), the keywords with
	  // optional arguments, we eagerly look for a semicolon or the
	  // possibility to insert one.

	  if (this.eat(_tokentype.types.semi) || this.insertSemicolon()) node.argument = null;else {
	    node.argument = this.parseExpression();this.semicolon();
	  }
	  return this.finishNode(node, "ReturnStatement");
	};

	pp.parseSwitchStatement = function (node) {
	  this.next();
	  node.discriminant = this.parseParenExpression();
	  node.cases = [];
	  this.expect(_tokentype.types.braceL);
	  this.labels.push(switchLabel);

	  // Statements under must be grouped (by label) in SwitchCase
	  // nodes. `cur` is used to keep the node that we are currently
	  // adding statements to.

	  for (var cur, sawDefault = false; this.type != _tokentype.types.braceR;) {
	    if (this.type === _tokentype.types._case || this.type === _tokentype.types._default) {
	      var isCase = this.type === _tokentype.types._case;
	      if (cur) this.finishNode(cur, "SwitchCase");
	      node.cases.push(cur = this.startNode());
	      cur.consequent = [];
	      this.next();
	      if (isCase) {
	        cur.test = this.parseExpression();
	      } else {
	        if (sawDefault) this.raise(this.lastTokStart, "Multiple default clauses");
	        sawDefault = true;
	        cur.test = null;
	      }
	      this.expect(_tokentype.types.colon);
	    } else {
	      if (!cur) this.unexpected();
	      cur.consequent.push(this.parseStatement(true));
	    }
	  }
	  if (cur) this.finishNode(cur, "SwitchCase");
	  this.next(); // Closing brace
	  this.labels.pop();
	  return this.finishNode(node, "SwitchStatement");
	};

	pp.parseThrowStatement = function (node) {
	  this.next();
	  if (_whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) this.raise(this.lastTokEnd, "Illegal newline after throw");
	  node.argument = this.parseExpression();
	  this.semicolon();
	  return this.finishNode(node, "ThrowStatement");
	};

	// Reused empty array added for node fields that are always empty.

	var empty = [];

	pp.parseTryStatement = function (node) {
	  this.next();
	  node.block = this.parseBlock();
	  node.handler = null;
	  if (this.type === _tokentype.types._catch) {
	    var clause = this.startNode();
	    this.next();
	    this.expect(_tokentype.types.parenL);
	    clause.param = this.parseBindingAtom();
	    this.checkLVal(clause.param, true);
	    this.expect(_tokentype.types.parenR);
	    clause.body = this.parseBlock();
	    node.handler = this.finishNode(clause, "CatchClause");
	  }
	  node.finalizer = this.eat(_tokentype.types._finally) ? this.parseBlock() : null;
	  if (!node.handler && !node.finalizer) this.raise(node.start, "Missing catch or finally clause");
	  return this.finishNode(node, "TryStatement");
	};

	pp.parseVarStatement = function (node, kind) {
	  this.next();
	  this.parseVar(node, false, kind);
	  this.semicolon();
	  return this.finishNode(node, "VariableDeclaration");
	};

	pp.parseWhileStatement = function (node) {
	  this.next();
	  node.test = this.parseParenExpression();
	  this.labels.push(loopLabel);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "WhileStatement");
	};

	pp.parseWithStatement = function (node) {
	  if (this.strict) this.raise(this.start, "'with' in strict mode");
	  this.next();
	  node.object = this.parseParenExpression();
	  node.body = this.parseStatement(false);
	  return this.finishNode(node, "WithStatement");
	};

	pp.parseEmptyStatement = function (node) {
	  this.next();
	  return this.finishNode(node, "EmptyStatement");
	};

	pp.parseLabeledStatement = function (node, maybeName, expr) {
	  for (var i = 0; i < this.labels.length; ++i) {
	    if (this.labels[i].name === maybeName) this.raise(expr.start, "Label '" + maybeName + "' is already declared");
	  }var kind = this.type.isLoop ? "loop" : this.type === _tokentype.types._switch ? "switch" : null;
	  for (var i = this.labels.length - 1; i >= 0; i--) {
	    var label = this.labels[i];
	    if (label.statementStart == node.start) {
	      label.statementStart = this.start;
	      label.kind = kind;
	    } else break;
	  }
	  this.labels.push({ name: maybeName, kind: kind, statementStart: this.start });
	  node.body = this.parseStatement(true);
	  this.labels.pop();
	  node.label = expr;
	  return this.finishNode(node, "LabeledStatement");
	};

	pp.parseExpressionStatement = function (node, expr) {
	  node.expression = expr;
	  this.semicolon();
	  return this.finishNode(node, "ExpressionStatement");
	};

	// Parse a semicolon-enclosed block of statements, handling `"use
	// strict"` declarations when `allowStrict` is true (used for
	// function bodies).

	pp.parseBlock = function (allowStrict) {
	  var node = this.startNode(),
	      first = true,
	      oldStrict = undefined;
	  node.body = [];
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    var stmt = this.parseStatement(true);
	    node.body.push(stmt);
	    if (first && allowStrict && this.isUseStrict(stmt)) {
	      oldStrict = this.strict;
	      this.setStrict(this.strict = true);
	    }
	    first = false;
	  }
	  if (oldStrict === false) this.setStrict(false);
	  return this.finishNode(node, "BlockStatement");
	};

	// Parse a regular `for` loop. The disambiguation code in
	// `parseStatement` will already have parsed the init statement or
	// expression.

	pp.parseFor = function (node, init) {
	  node.init = init;
	  this.expect(_tokentype.types.semi);
	  node.test = this.type === _tokentype.types.semi ? null : this.parseExpression();
	  this.expect(_tokentype.types.semi);
	  node.update = this.type === _tokentype.types.parenR ? null : this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, "ForStatement");
	};

	// Parse a `for`/`in` and `for`/`of` loop, which are almost
	// same from parser's perspective.

	pp.parseForIn = function (node, init) {
	  var type = this.type === _tokentype.types._in ? "ForInStatement" : "ForOfStatement";
	  this.next();
	  node.left = init;
	  node.right = this.parseExpression();
	  this.expect(_tokentype.types.parenR);
	  node.body = this.parseStatement(false);
	  this.labels.pop();
	  return this.finishNode(node, type);
	};

	// Parse a list of variable declarations.

	pp.parseVar = function (node, isFor, kind) {
	  node.declarations = [];
	  node.kind = kind.keyword;
	  for (;;) {
	    var decl = this.startNode();
	    this.parseVarId(decl);
	    if (this.eat(_tokentype.types.eq)) {
	      decl.init = this.parseMaybeAssign(isFor);
	    } else if (kind === _tokentype.types._const && !(this.type === _tokentype.types._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	      this.unexpected();
	    } else if (decl.id.type != "Identifier" && !(isFor && (this.type === _tokentype.types._in || this.isContextual("of")))) {
	      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
	    } else {
	      decl.init = null;
	    }
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	    if (!this.eat(_tokentype.types.comma)) break;
	  }
	  return node;
	};

	pp.parseVarId = function (decl) {
	  decl.id = this.parseBindingAtom();
	  this.checkLVal(decl.id, true);
	};

	// Parse a function declaration or literal (depending on the
	// `isStatement` parameter).

	pp.parseFunction = function (node, isStatement, allowExpressionBody) {
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 6) node.generator = this.eat(_tokentype.types.star);
	  if (isStatement || this.type === _tokentype.types.name) node.id = this.parseIdent();
	  this.parseFunctionParams(node);
	  this.parseFunctionBody(node, allowExpressionBody);
	  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	};

	pp.parseFunctionParams = function (node) {
	  this.expect(_tokentype.types.parenL);
	  node.params = this.parseBindingList(_tokentype.types.parenR, false, false, true);
	};

	// Parse a class declaration or literal (depending on the
	// `isStatement` parameter).

	pp.parseClass = function (node, isStatement) {
	  this.next();
	  this.parseClassId(node, isStatement);
	  this.parseClassSuper(node);
	  var classBody = this.startNode();
	  var hadConstructor = false;
	  classBody.body = [];
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (this.eat(_tokentype.types.semi)) continue;
	    var method = this.startNode();
	    var isGenerator = this.eat(_tokentype.types.star);
	    var isMaybeStatic = this.type === _tokentype.types.name && this.value === "static";
	    this.parsePropertyName(method);
	    method["static"] = isMaybeStatic && this.type !== _tokentype.types.parenL;
	    if (method["static"]) {
	      if (isGenerator) this.unexpected();
	      isGenerator = this.eat(_tokentype.types.star);
	      this.parsePropertyName(method);
	    }
	    method.kind = "method";
	    var isGetSet = false;
	    if (!method.computed) {
	      var key = method.key;

	      if (!isGenerator && key.type === "Identifier" && this.type !== _tokentype.types.parenL && (key.name === "get" || key.name === "set")) {
	        isGetSet = true;
	        method.kind = key.name;
	        key = this.parsePropertyName(method);
	      }
	      if (!method["static"] && (key.type === "Identifier" && key.name === "constructor" || key.type === "Literal" && key.value === "constructor")) {
	        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
	        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
	        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
	        method.kind = "constructor";
	        hadConstructor = true;
	      }
	    }
	    this.parseClassMethod(classBody, method, isGenerator);
	    if (isGetSet) {
	      var paramCount = method.kind === "get" ? 0 : 1;
	      if (method.value.params.length !== paramCount) {
	        var start = method.value.start;
	        if (method.kind === "get") this.raise(start, "getter should have no params");else this.raise(start, "setter should have exactly one param");
	      }
	    }
	  }
	  node.body = this.finishNode(classBody, "ClassBody");
	  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	};

	pp.parseClassMethod = function (classBody, method, isGenerator) {
	  method.value = this.parseMethod(isGenerator);
	  classBody.body.push(this.finishNode(method, "MethodDefinition"));
	};

	pp.parseClassId = function (node, isStatement) {
	  node.id = this.type === _tokentype.types.name ? this.parseIdent() : isStatement ? this.unexpected() : null;
	};

	pp.parseClassSuper = function (node) {
	  node.superClass = this.eat(_tokentype.types._extends) ? this.parseExprSubscripts() : null;
	};

	// Parses module export declaration.

	pp.parseExport = function (node) {
	  this.next();
	  // export * from '...'
	  if (this.eat(_tokentype.types.star)) {
	    this.expectContextual("from");
	    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	    this.semicolon();
	    return this.finishNode(node, "ExportAllDeclaration");
	  }
	  if (this.eat(_tokentype.types._default)) {
	    // export default ...
	    var expr = this.parseMaybeAssign();
	    var needsSemi = true;
	    if (expr.type == "FunctionExpression" || expr.type == "ClassExpression") {
	      needsSemi = false;
	      if (expr.id) {
	        expr.type = expr.type == "FunctionExpression" ? "FunctionDeclaration" : "ClassDeclaration";
	      }
	    }
	    node.declaration = expr;
	    if (needsSemi) this.semicolon();
	    return this.finishNode(node, "ExportDefaultDeclaration");
	  }
	  // export var|const|let|function|class ...
	  if (this.shouldParseExportStatement()) {
	    node.declaration = this.parseStatement(true);
	    node.specifiers = [];
	    node.source = null;
	  } else {
	    // export { x, y as z } [from '...']
	    node.declaration = null;
	    node.specifiers = this.parseExportSpecifiers();
	    if (this.eatContextual("from")) {
	      node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	    } else {
	      // check for keywords used as local names
	      for (var i = 0; i < node.specifiers.length; i++) {
	        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {
	          this.unexpected(node.specifiers[i].local.start);
	        }
	      }

	      node.source = null;
	    }
	    this.semicolon();
	  }
	  return this.finishNode(node, "ExportNamedDeclaration");
	};

	pp.shouldParseExportStatement = function () {
	  return this.type.keyword;
	};

	// Parses a comma-separated list of module exports.

	pp.parseExportSpecifiers = function () {
	  var nodes = [],
	      first = true;
	  // export { x, y as z } [from '...']
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;

	    var node = this.startNode();
	    node.local = this.parseIdent(this.type === _tokentype.types._default);
	    node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
	    nodes.push(this.finishNode(node, "ExportSpecifier"));
	  }
	  return nodes;
	};

	// Parses import declaration.

	pp.parseImport = function (node) {
	  this.next();
	  // import '...'
	  if (this.type === _tokentype.types.string) {
	    node.specifiers = empty;
	    node.source = this.parseExprAtom();
	  } else {
	    node.specifiers = this.parseImportSpecifiers();
	    this.expectContextual("from");
	    node.source = this.type === _tokentype.types.string ? this.parseExprAtom() : this.unexpected();
	  }
	  this.semicolon();
	  return this.finishNode(node, "ImportDeclaration");
	};

	// Parses a comma-separated list of module imports.

	pp.parseImportSpecifiers = function () {
	  var nodes = [],
	      first = true;
	  if (this.type === _tokentype.types.name) {
	    // import defaultObj, { x, y as z } from '...'
	    var node = this.startNode();
	    node.local = this.parseIdent();
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
	    if (!this.eat(_tokentype.types.comma)) return nodes;
	  }
	  if (this.type === _tokentype.types.star) {
	    var node = this.startNode();
	    this.next();
	    this.expectContextual("as");
	    node.local = this.parseIdent();
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportNamespaceSpecifier"));
	    return nodes;
	  }
	  this.expect(_tokentype.types.braceL);
	  while (!this.eat(_tokentype.types.braceR)) {
	    if (!first) {
	      this.expect(_tokentype.types.comma);
	      if (this.afterTrailingComma(_tokentype.types.braceR)) break;
	    } else first = false;

	    var node = this.startNode();
	    node.imported = this.parseIdent(true);
	    node.local = this.eatContextual("as") ? this.parseIdent() : node.imported;
	    this.checkLVal(node.local, true);
	    nodes.push(this.finishNode(node, "ImportSpecifier"));
	  }
	  return nodes;
	};

	},{"./state":10,"./tokentype":14,"./whitespace":16}],12:[function(_dereq_,module,exports){
	// The algorithm used to determine whether a regexp can appear at a
	// given point in the program is loosely based on sweet.js' approach.
	// See https://github.com/mozilla/sweet.js/wiki/design

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _state = _dereq_("./state");

	var _tokentype = _dereq_("./tokentype");

	var _whitespace = _dereq_("./whitespace");

	var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
	  _classCallCheck(this, TokContext);

	  this.token = token;
	  this.isExpr = !!isExpr;
	  this.preserveSpace = !!preserveSpace;
	  this.override = override;
	};

	exports.TokContext = TokContext;
	var types = {
	  b_stat: new TokContext("{", false),
	  b_expr: new TokContext("{", true),
	  b_tmpl: new TokContext("${", true),
	  p_stat: new TokContext("(", false),
	  p_expr: new TokContext("(", true),
	  q_tmpl: new TokContext("`", true, true, function (p) {
	    return p.readTmplToken();
	  }),
	  f_expr: new TokContext("function", true)
	};

	exports.types = types;
	var pp = _state.Parser.prototype;

	pp.initialContext = function () {
	  return [types.b_stat];
	};

	pp.braceIsBlock = function (prevType) {
	  if (prevType === _tokentype.types.colon) {
	    var _parent = this.curContext();
	    if (_parent === types.b_stat || _parent === types.b_expr) return !_parent.isExpr;
	  }
	  if (prevType === _tokentype.types._return) return _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
	  if (prevType === _tokentype.types._else || prevType === _tokentype.types.semi || prevType === _tokentype.types.eof || prevType === _tokentype.types.parenR) return true;
	  if (prevType == _tokentype.types.braceL) return this.curContext() === types.b_stat;
	  return !this.exprAllowed;
	};

	pp.updateContext = function (prevType) {
	  var update = undefined,
	      type = this.type;
	  if (type.keyword && prevType == _tokentype.types.dot) this.exprAllowed = false;else if (update = type.updateContext) update.call(this, prevType);else this.exprAllowed = type.beforeExpr;
	};

	// Token-specific context update code

	_tokentype.types.parenR.updateContext = _tokentype.types.braceR.updateContext = function () {
	  if (this.context.length == 1) {
	    this.exprAllowed = true;
	    return;
	  }
	  var out = this.context.pop();
	  if (out === types.b_stat && this.curContext() === types.f_expr) {
	    this.context.pop();
	    this.exprAllowed = false;
	  } else if (out === types.b_tmpl) {
	    this.exprAllowed = true;
	  } else {
	    this.exprAllowed = !out.isExpr;
	  }
	};

	_tokentype.types.braceL.updateContext = function (prevType) {
	  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
	  this.exprAllowed = true;
	};

	_tokentype.types.dollarBraceL.updateContext = function () {
	  this.context.push(types.b_tmpl);
	  this.exprAllowed = true;
	};

	_tokentype.types.parenL.updateContext = function (prevType) {
	  var statementParens = prevType === _tokentype.types._if || prevType === _tokentype.types._for || prevType === _tokentype.types._with || prevType === _tokentype.types._while;
	  this.context.push(statementParens ? types.p_stat : types.p_expr);
	  this.exprAllowed = true;
	};

	_tokentype.types.incDec.updateContext = function () {
	  // tokExprAllowed stays unchanged
	};

	_tokentype.types._function.updateContext = function () {
	  if (this.curContext() !== types.b_stat) this.context.push(types.f_expr);
	  this.exprAllowed = false;
	};

	_tokentype.types.backQuote.updateContext = function () {
	  if (this.curContext() === types.q_tmpl) this.context.pop();else this.context.push(types.q_tmpl);
	  this.exprAllowed = false;
	};

	},{"./state":10,"./tokentype":14,"./whitespace":16}],13:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _identifier = _dereq_("./identifier");

	var _tokentype = _dereq_("./tokentype");

	var _state = _dereq_("./state");

	var _locutil = _dereq_("./locutil");

	var _whitespace = _dereq_("./whitespace");

	// Object type used to represent tokens. Note that normally, tokens
	// simply exist as properties on the parser object. This is only
	// used for the onToken callback and the external tokenizer.

	var Token = function Token(p) {
	  _classCallCheck(this, Token);

	  this.type = p.type;
	  this.value = p.value;
	  this.start = p.start;
	  this.end = p.end;
	  if (p.options.locations) this.loc = new _locutil.SourceLocation(p, p.startLoc, p.endLoc);
	  if (p.options.ranges) this.range = [p.start, p.end];
	}

	// ## Tokenizer

	;

	exports.Token = Token;
	var pp = _state.Parser.prototype;

	// Are we running under Rhino?
	var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

	// Move to the next token

	pp.next = function () {
	  if (this.options.onToken) this.options.onToken(new Token(this));

	  this.lastTokEnd = this.end;
	  this.lastTokStart = this.start;
	  this.lastTokEndLoc = this.endLoc;
	  this.lastTokStartLoc = this.startLoc;
	  this.nextToken();
	};

	pp.getToken = function () {
	  this.next();
	  return new Token(this);
	};

	// If we're in an ES6 environment, make parsers iterable
	if (typeof Symbol !== "undefined") pp[Symbol.iterator] = function () {
	  var self = this;
	  return { next: function next() {
	      var token = self.getToken();
	      return {
	        done: token.type === _tokentype.types.eof,
	        value: token
	      };
	    } };
	};

	// Toggle strict mode. Re-reads the next number or string to please
	// pedantic tests (`"use strict"; 010;` should fail).

	pp.setStrict = function (strict) {
	  this.strict = strict;
	  if (this.type !== _tokentype.types.num && this.type !== _tokentype.types.string) return;
	  this.pos = this.start;
	  if (this.options.locations) {
	    while (this.pos < this.lineStart) {
	      this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
	      --this.curLine;
	    }
	  }
	  this.nextToken();
	};

	pp.curContext = function () {
	  return this.context[this.context.length - 1];
	};

	// Read a single token, updating the parser object's token-related
	// properties.

	pp.nextToken = function () {
	  var curContext = this.curContext();
	  if (!curContext || !curContext.preserveSpace) this.skipSpace();

	  this.start = this.pos;
	  if (this.options.locations) this.startLoc = this.curPosition();
	  if (this.pos >= this.input.length) return this.finishToken(_tokentype.types.eof);

	  if (curContext.override) return curContext.override(this);else this.readToken(this.fullCharCodeAtPos());
	};

	pp.readToken = function (code) {
	  // Identifier or keyword. '\uXXXX' sequences are allowed in
	  // identifiers, so '\' also dispatches to that.
	  if (_identifier.isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */) return this.readWord();

	  return this.getTokenFromCode(code);
	};

	pp.fullCharCodeAtPos = function () {
	  var code = this.input.charCodeAt(this.pos);
	  if (code <= 0xd7ff || code >= 0xe000) return code;
	  var next = this.input.charCodeAt(this.pos + 1);
	  return (code << 10) + next - 0x35fdc00;
	};

	pp.skipBlockComment = function () {
	  var startLoc = this.options.onComment && this.curPosition();
	  var start = this.pos,
	      end = this.input.indexOf("*/", this.pos += 2);
	  if (end === -1) this.raise(this.pos - 2, "Unterminated comment");
	  this.pos = end + 2;
	  if (this.options.locations) {
	    _whitespace.lineBreakG.lastIndex = start;
	    var match = undefined;
	    while ((match = _whitespace.lineBreakG.exec(this.input)) && match.index < this.pos) {
	      ++this.curLine;
	      this.lineStart = match.index + match[0].length;
	    }
	  }
	  if (this.options.onComment) this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
	};

	pp.skipLineComment = function (startSkip) {
	  var start = this.pos;
	  var startLoc = this.options.onComment && this.curPosition();
	  var ch = this.input.charCodeAt(this.pos += startSkip);
	  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	    ++this.pos;
	    ch = this.input.charCodeAt(this.pos);
	  }
	  if (this.options.onComment) this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
	};

	// Called at the start of the parse and after every token. Skips
	// whitespace and comments, and.

	pp.skipSpace = function () {
	  loop: while (this.pos < this.input.length) {
	    var ch = this.input.charCodeAt(this.pos);
	    switch (ch) {
	      case 32:case 160:
	        // ' '
	        ++this.pos;
	        break;
	      case 13:
	        if (this.input.charCodeAt(this.pos + 1) === 10) {
	          ++this.pos;
	        }
	      case 10:case 8232:case 8233:
	        ++this.pos;
	        if (this.options.locations) {
	          ++this.curLine;
	          this.lineStart = this.pos;
	        }
	        break;
	      case 47:
	        // '/'
	        switch (this.input.charCodeAt(this.pos + 1)) {
	          case 42:
	            // '*'
	            this.skipBlockComment();
	            break;
	          case 47:
	            this.skipLineComment(2);
	            break;
	          default:
	            break loop;
	        }
	        break;
	      default:
	        if (ch > 8 && ch < 14 || ch >= 5760 && _whitespace.nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	          ++this.pos;
	        } else {
	          break loop;
	        }
	    }
	  }
	};

	// Called at the end of every token. Sets `end`, `val`, and
	// maintains `context` and `exprAllowed`, and skips the space after
	// the token, so that the next one's `start` will point at the
	// right position.

	pp.finishToken = function (type, val) {
	  this.end = this.pos;
	  if (this.options.locations) this.endLoc = this.curPosition();
	  var prevType = this.type;
	  this.type = type;
	  this.value = val;

	  this.updateContext(prevType);
	};

	// ### Token reading

	// This is the function that is called to fetch the next token. It
	// is somewhat obscure, because it works in character codes rather
	// than characters, and because operator parsing has been inlined
	// into it.
	//
	// All in the name of speed.
	//
	pp.readToken_dot = function () {
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next >= 48 && next <= 57) return this.readNumber(true);
	  var next2 = this.input.charCodeAt(this.pos + 2);
	  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
	    // 46 = dot '.'
	    this.pos += 3;
	    return this.finishToken(_tokentype.types.ellipsis);
	  } else {
	    ++this.pos;
	    return this.finishToken(_tokentype.types.dot);
	  }
	};

	pp.readToken_slash = function () {
	  // '/'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (this.exprAllowed) {
	    ++this.pos;return this.readRegexp();
	  }
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.slash, 1);
	};

	pp.readToken_mult_modulo = function (code) {
	  // '%*'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(code === 42 ? _tokentype.types.star : _tokentype.types.modulo, 1);
	};

	pp.readToken_pipe_amp = function (code) {
	  // '|&'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) return this.finishOp(code === 124 ? _tokentype.types.logicalOR : _tokentype.types.logicalAND, 2);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(code === 124 ? _tokentype.types.bitwiseOR : _tokentype.types.bitwiseAND, 1);
	};

	pp.readToken_caret = function () {
	  // '^'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.bitwiseXOR, 1);
	};

	pp.readToken_plus_min = function (code) {
	  // '+-'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === code) {
	    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 && _whitespace.lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
	      // A `-->` line comment
	      this.skipLineComment(3);
	      this.skipSpace();
	      return this.nextToken();
	    }
	    return this.finishOp(_tokentype.types.incDec, 2);
	  }
	  if (next === 61) return this.finishOp(_tokentype.types.assign, 2);
	  return this.finishOp(_tokentype.types.plusMin, 1);
	};

	pp.readToken_lt_gt = function (code) {
	  // '<>'
	  var next = this.input.charCodeAt(this.pos + 1);
	  var size = 1;
	  if (next === code) {
	    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
	    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(_tokentype.types.assign, size + 1);
	    return this.finishOp(_tokentype.types.bitShift, size);
	  }
	  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 && this.input.charCodeAt(this.pos + 3) == 45) {
	    if (this.inModule) this.unexpected();
	    // `<!--`, an XML-style comment that should be interpreted as a line comment
	    this.skipLineComment(4);
	    this.skipSpace();
	    return this.nextToken();
	  }
	  if (next === 61) size = this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2;
	  return this.finishOp(_tokentype.types.relational, size);
	};

	pp.readToken_eq_excl = function (code) {
	  // '=!'
	  var next = this.input.charCodeAt(this.pos + 1);
	  if (next === 61) return this.finishOp(_tokentype.types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
	  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
	    // '=>'
	    this.pos += 2;
	    return this.finishToken(_tokentype.types.arrow);
	  }
	  return this.finishOp(code === 61 ? _tokentype.types.eq : _tokentype.types.prefix, 1);
	};

	pp.getTokenFromCode = function (code) {
	  switch (code) {
	    // The interpretation of a dot depends on whether it is followed
	    // by a digit or another two dots.
	    case 46:
	      // '.'
	      return this.readToken_dot();

	    // Punctuation tokens.
	    case 40:
	      ++this.pos;return this.finishToken(_tokentype.types.parenL);
	    case 41:
	      ++this.pos;return this.finishToken(_tokentype.types.parenR);
	    case 59:
	      ++this.pos;return this.finishToken(_tokentype.types.semi);
	    case 44:
	      ++this.pos;return this.finishToken(_tokentype.types.comma);
	    case 91:
	      ++this.pos;return this.finishToken(_tokentype.types.bracketL);
	    case 93:
	      ++this.pos;return this.finishToken(_tokentype.types.bracketR);
	    case 123:
	      ++this.pos;return this.finishToken(_tokentype.types.braceL);
	    case 125:
	      ++this.pos;return this.finishToken(_tokentype.types.braceR);
	    case 58:
	      ++this.pos;return this.finishToken(_tokentype.types.colon);
	    case 63:
	      ++this.pos;return this.finishToken(_tokentype.types.question);

	    case 96:
	      // '`'
	      if (this.options.ecmaVersion < 6) break;
	      ++this.pos;
	      return this.finishToken(_tokentype.types.backQuote);

	    case 48:
	      // '0'
	      var next = this.input.charCodeAt(this.pos + 1);
	      if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
	      if (this.options.ecmaVersion >= 6) {
	        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
	        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
	      }
	    // Anything else beginning with a digit is an integer, octal
	    // number, or float.
	    case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
	      // 1-9
	      return this.readNumber(false);

	    // Quotes produce strings.
	    case 34:case 39:
	      // '"', "'"
	      return this.readString(code);

	    // Operators are parsed inline in tiny state machines. '=' (61) is
	    // often referred to. `finishOp` simply skips the amount of
	    // characters it is given as second argument, and returns a token
	    // of the type given by its first argument.

	    case 47:
	      // '/'
	      return this.readToken_slash();

	    case 37:case 42:
	      // '%*'
	      return this.readToken_mult_modulo(code);

	    case 124:case 38:
	      // '|&'
	      return this.readToken_pipe_amp(code);

	    case 94:
	      // '^'
	      return this.readToken_caret();

	    case 43:case 45:
	      // '+-'
	      return this.readToken_plus_min(code);

	    case 60:case 62:
	      // '<>'
	      return this.readToken_lt_gt(code);

	    case 61:case 33:
	      // '=!'
	      return this.readToken_eq_excl(code);

	    case 126:
	      // '~'
	      return this.finishOp(_tokentype.types.prefix, 1);
	  }

	  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
	};

	pp.finishOp = function (type, size) {
	  var str = this.input.slice(this.pos, this.pos + size);
	  this.pos += size;
	  return this.finishToken(type, str);
	};

	// Parse a regular expression. Some context-awareness is necessary,
	// since a '/' inside a '[]' set does not end the expression.

	function tryCreateRegexp(src, flags, throwErrorAt, parser) {
	  try {
	    return new RegExp(src, flags);
	  } catch (e) {
	    if (throwErrorAt !== undefined) {
	      if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message);
	      throw e;
	    }
	  }
	}

	var regexpUnicodeSupport = !!tryCreateRegexp("￿", "u");

	pp.readRegexp = function () {
	  var _this = this;

	  var escaped = undefined,
	      inClass = undefined,
	      start = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
	    var ch = this.input.charAt(this.pos);
	    if (_whitespace.lineBreak.test(ch)) this.raise(start, "Unterminated regular expression");
	    if (!escaped) {
	      if (ch === "[") inClass = true;else if (ch === "]" && inClass) inClass = false;else if (ch === "/" && !inClass) break;
	      escaped = ch === "\\";
	    } else escaped = false;
	    ++this.pos;
	  }
	  var content = this.input.slice(start, this.pos);
	  ++this.pos;
	  // Need to use `readWord1` because '\uXXXX' sequences are allowed
	  // here (don't ask).
	  var mods = this.readWord1();
	  var tmp = content;
	  if (mods) {
	    var validFlags = /^[gmsiy]*$/;
	    if (this.options.ecmaVersion >= 6) validFlags = /^[gmsiyu]*$/;
	    if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
	    if (mods.indexOf('u') >= 0 && !regexpUnicodeSupport) {
	      // Replace each astral symbol and every Unicode escape sequence that
	      // possibly represents an astral symbol or a paired surrogate with a
	      // single ASCII symbol to avoid throwing on regular expressions that
	      // are only valid in combination with the `/u` flag.
	      // Note: replacing with the ASCII symbol `x` might cause false
	      // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	      // perfectly valid pattern that is equivalent to `[a-b]`, but it would
	      // be replaced by `[x-b]` which throws an error.
	      tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
	        code = Number("0x" + code);
	        if (code > 0x10FFFF) _this.raise(start + offset + 3, "Code point out of bounds");
	        return "x";
	      });
	      tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
	    }
	  }
	  // Detect invalid regular expressions.
	  var value = null;
	  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
	  // so don't do detection if we are running under Rhino
	  if (!isRhino) {
	    tryCreateRegexp(tmp, undefined, start, this);
	    // Get a regular expression object for this pattern-flag pair, or `null` in
	    // case the current environment doesn't support the flags it uses.
	    value = tryCreateRegexp(content, mods);
	  }
	  return this.finishToken(_tokentype.types.regexp, { pattern: content, flags: mods, value: value });
	};

	// Read an integer in the given radix. Return null if zero digits
	// were read, the integer value otherwise. When `len` is given, this
	// will return `null` unless the integer has exactly `len` digits.

	pp.readInt = function (radix, len) {
	  var start = this.pos,
	      total = 0;
	  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	    var code = this.input.charCodeAt(this.pos),
	        val = undefined;
	    if (code >= 97) val = code - 97 + 10; // a
	    else if (code >= 65) val = code - 65 + 10; // A
	      else if (code >= 48 && code <= 57) val = code - 48; // 0-9
	        else val = Infinity;
	    if (val >= radix) break;
	    ++this.pos;
	    total = total * radix + val;
	  }
	  if (this.pos === start || len != null && this.pos - start !== len) return null;

	  return total;
	};

	pp.readRadixNumber = function (radix) {
	  this.pos += 2; // 0x
	  var val = this.readInt(radix);
	  if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix);
	  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");
	  return this.finishToken(_tokentype.types.num, val);
	};

	// Read an integer, octal integer, or floating-point number.

	pp.readNumber = function (startsWithDot) {
	  var start = this.pos,
	      isFloat = false,
	      octal = this.input.charCodeAt(this.pos) === 48;
	  if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
	  var next = this.input.charCodeAt(this.pos);
	  if (next === 46) {
	    // '.'
	    ++this.pos;
	    this.readInt(10);
	    isFloat = true;
	    next = this.input.charCodeAt(this.pos);
	  }
	  if (next === 69 || next === 101) {
	    // 'eE'
	    next = this.input.charCodeAt(++this.pos);
	    if (next === 43 || next === 45) ++this.pos; // '+-'
	    if (this.readInt(10) === null) this.raise(start, "Invalid number");
	    isFloat = true;
	  }
	  if (_identifier.isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number");

	  var str = this.input.slice(start, this.pos),
	      val = undefined;
	  if (isFloat) val = parseFloat(str);else if (!octal || str.length === 1) val = parseInt(str, 10);else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number");else val = parseInt(str, 8);
	  return this.finishToken(_tokentype.types.num, val);
	};

	// Read a string value, interpreting backslash-escapes.

	pp.readCodePoint = function () {
	  var ch = this.input.charCodeAt(this.pos),
	      code = undefined;

	  if (ch === 123) {
	    if (this.options.ecmaVersion < 6) this.unexpected();
	    var codePos = ++this.pos;
	    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos);
	    ++this.pos;
	    if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
	  } else {
	    code = this.readHexChar(4);
	  }
	  return code;
	};

	function codePointToString(code) {
	  // UTF-16 Decoding
	  if (code <= 0xFFFF) return String.fromCharCode(code);
	  code -= 0x10000;
	  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);
	}

	pp.readString = function (quote) {
	  var out = "",
	      chunkStart = ++this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated string constant");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === quote) break;
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar(false);
	      chunkStart = this.pos;
	    } else {
	      if (_whitespace.isNewLine(ch)) this.raise(this.start, "Unterminated string constant");
	      ++this.pos;
	    }
	  }
	  out += this.input.slice(chunkStart, this.pos++);
	  return this.finishToken(_tokentype.types.string, out);
	};

	// Reads template string tokens.

	pp.readTmplToken = function () {
	  var out = "",
	      chunkStart = this.pos;
	  for (;;) {
	    if (this.pos >= this.input.length) this.raise(this.start, "Unterminated template");
	    var ch = this.input.charCodeAt(this.pos);
	    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
	      // '`', '${'
	      if (this.pos === this.start && this.type === _tokentype.types.template) {
	        if (ch === 36) {
	          this.pos += 2;
	          return this.finishToken(_tokentype.types.dollarBraceL);
	        } else {
	          ++this.pos;
	          return this.finishToken(_tokentype.types.backQuote);
	        }
	      }
	      out += this.input.slice(chunkStart, this.pos);
	      return this.finishToken(_tokentype.types.template, out);
	    }
	    if (ch === 92) {
	      // '\'
	      out += this.input.slice(chunkStart, this.pos);
	      out += this.readEscapedChar(true);
	      chunkStart = this.pos;
	    } else if (_whitespace.isNewLine(ch)) {
	      out += this.input.slice(chunkStart, this.pos);
	      ++this.pos;
	      switch (ch) {
	        case 13:
	          if (this.input.charCodeAt(this.pos) === 10) ++this.pos;
	        case 10:
	          out += "\n";
	          break;
	        default:
	          out += String.fromCharCode(ch);
	          break;
	      }
	      if (this.options.locations) {
	        ++this.curLine;
	        this.lineStart = this.pos;
	      }
	      chunkStart = this.pos;
	    } else {
	      ++this.pos;
	    }
	  }
	};

	// Used to read escaped characters

	pp.readEscapedChar = function (inTemplate) {
	  var ch = this.input.charCodeAt(++this.pos);
	  ++this.pos;
	  switch (ch) {
	    case 110:
	      return "\n"; // 'n' -> '\n'
	    case 114:
	      return "\r"; // 'r' -> '\r'
	    case 120:
	      return String.fromCharCode(this.readHexChar(2)); // 'x'
	    case 117:
	      return codePointToString(this.readCodePoint()); // 'u'
	    case 116:
	      return "\t"; // 't' -> '\t'
	    case 98:
	      return "\b"; // 'b' -> '\b'
	    case 118:
	      return "\u000b"; // 'v' -> '\u000b'
	    case 102:
	      return "\f"; // 'f' -> '\f'
	    case 13:
	      if (this.input.charCodeAt(this.pos) === 10) ++this.pos; // '\r\n'
	    case 10:
	      // ' \n'
	      if (this.options.locations) {
	        this.lineStart = this.pos;++this.curLine;
	      }
	      return "";
	    default:
	      if (ch >= 48 && ch <= 55) {
	        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
	        var octal = parseInt(octalStr, 8);
	        if (octal > 255) {
	          octalStr = octalStr.slice(0, -1);
	          octal = parseInt(octalStr, 8);
	        }
	        if (octal > 0 && (this.strict || inTemplate)) {
	          this.raise(this.pos - 2, "Octal literal in strict mode");
	        }
	        this.pos += octalStr.length - 1;
	        return String.fromCharCode(octal);
	      }
	      return String.fromCharCode(ch);
	  }
	};

	// Used to read character escape sequences ('\x', '\u', '\U').

	pp.readHexChar = function (len) {
	  var codePos = this.pos;
	  var n = this.readInt(16, len);
	  if (n === null) this.raise(codePos, "Bad character escape sequence");
	  return n;
	};

	// Read an identifier, and return it as a string. Sets `this.containsEsc`
	// to whether the word contained a '\u' escape.
	//
	// Incrementally adds only escaped chars, adding other chunks as-is
	// as a micro-optimization.

	pp.readWord1 = function () {
	  this.containsEsc = false;
	  var word = "",
	      first = true,
	      chunkStart = this.pos;
	  var astral = this.options.ecmaVersion >= 6;
	  while (this.pos < this.input.length) {
	    var ch = this.fullCharCodeAtPos();
	    if (_identifier.isIdentifierChar(ch, astral)) {
	      this.pos += ch <= 0xffff ? 1 : 2;
	    } else if (ch === 92) {
	      // "\"
	      this.containsEsc = true;
	      word += this.input.slice(chunkStart, this.pos);
	      var escStart = this.pos;
	      if (this.input.charCodeAt(++this.pos) != 117) // "u"
	        this.raise(this.pos, "Expecting Unicode escape sequence \\uXXXX");
	      ++this.pos;
	      var esc = this.readCodePoint();
	      if (!(first ? _identifier.isIdentifierStart : _identifier.isIdentifierChar)(esc, astral)) this.raise(escStart, "Invalid Unicode escape");
	      word += codePointToString(esc);
	      chunkStart = this.pos;
	    } else {
	      break;
	    }
	    first = false;
	  }
	  return word + this.input.slice(chunkStart, this.pos);
	};

	// Read an identifier or keyword token. Will check for reserved
	// words when necessary.

	pp.readWord = function () {
	  var word = this.readWord1();
	  var type = _tokentype.types.name;
	  if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word)) type = _tokentype.keywords[word];
	  return this.finishToken(type, word);
	};

	},{"./identifier":2,"./locutil":5,"./state":10,"./tokentype":14,"./whitespace":16}],14:[function(_dereq_,module,exports){
	// ## Token types

	// The assignment of fine-grained, information-carrying type objects
	// allows the tokenizer to store the information it has about a
	// token in a way that is very cheap for the parser to look up.

	// All token type variables start with an underscore, to make them
	// easy to recognize.

	// The `beforeExpr` property is used to disambiguate between regular
	// expressions and divisions. It is set on all token types that can
	// be followed by an expression (thus, a slash after them would be a
	// regular expression).
	//
	// The `startsExpr` property is used to check if the token ends a
	// `yield` expression. It is set on all token types that either can
	// directly start an expression (like a quotation mark) or can
	// continue an expression (like the body of a string).
	//
	// `isLoop` marks a keyword as starting a loop, which is important
	// to know when parsing a label, in order to allow or disallow
	// continue jumps to that label.

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var TokenType = function TokenType(label) {
	  var conf = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  _classCallCheck(this, TokenType);

	  this.label = label;
	  this.keyword = conf.keyword;
	  this.beforeExpr = !!conf.beforeExpr;
	  this.startsExpr = !!conf.startsExpr;
	  this.isLoop = !!conf.isLoop;
	  this.isAssign = !!conf.isAssign;
	  this.prefix = !!conf.prefix;
	  this.postfix = !!conf.postfix;
	  this.binop = conf.binop || null;
	  this.updateContext = null;
	};

	exports.TokenType = TokenType;

	function binop(name, prec) {
	  return new TokenType(name, { beforeExpr: true, binop: prec });
	}
	var beforeExpr = { beforeExpr: true },
	    startsExpr = { startsExpr: true };

	var types = {
	  num: new TokenType("num", startsExpr),
	  regexp: new TokenType("regexp", startsExpr),
	  string: new TokenType("string", startsExpr),
	  name: new TokenType("name", startsExpr),
	  eof: new TokenType("eof"),

	  // Punctuation token types.
	  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
	  bracketR: new TokenType("]"),
	  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
	  braceR: new TokenType("}"),
	  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
	  parenR: new TokenType(")"),
	  comma: new TokenType(",", beforeExpr),
	  semi: new TokenType(";", beforeExpr),
	  colon: new TokenType(":", beforeExpr),
	  dot: new TokenType("."),
	  question: new TokenType("?", beforeExpr),
	  arrow: new TokenType("=>", beforeExpr),
	  template: new TokenType("template"),
	  ellipsis: new TokenType("...", beforeExpr),
	  backQuote: new TokenType("`", startsExpr),
	  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),

	  // Operators. These carry several kinds of properties to help the
	  // parser use them properly (the presence of these properties is
	  // what categorizes them as operators).
	  //
	  // `binop`, when present, specifies that this operator is a binary
	  // operator, and will refer to its precedence.
	  //
	  // `prefix` and `postfix` mark the operator as a prefix or postfix
	  // unary operator.
	  //
	  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	  // binary operators with a very low precedence, that should result
	  // in AssignmentExpression nodes.

	  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
	  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
	  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
	  prefix: new TokenType("prefix", { beforeExpr: true, prefix: true, startsExpr: true }),
	  logicalOR: binop("||", 1),
	  logicalAND: binop("&&", 2),
	  bitwiseOR: binop("|", 3),
	  bitwiseXOR: binop("^", 4),
	  bitwiseAND: binop("&", 5),
	  equality: binop("==/!=", 6),
	  relational: binop("</>", 7),
	  bitShift: binop("<</>>", 8),
	  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
	  modulo: binop("%", 10),
	  star: binop("*", 10),
	  slash: binop("/", 10)
	};

	exports.types = types;
	// Map keyword names to token types.

	var keywords = {};

	exports.keywords = keywords;
	// Succinct definitions of keyword token types
	function kw(name) {
	  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

	  options.keyword = name;
	  keywords[name] = types["_" + name] = new TokenType(name, options);
	}

	kw("break");
	kw("case", beforeExpr);
	kw("catch");
	kw("continue");
	kw("debugger");
	kw("default", beforeExpr);
	kw("do", { isLoop: true, beforeExpr: true });
	kw("else", beforeExpr);
	kw("finally");
	kw("for", { isLoop: true });
	kw("function", startsExpr);
	kw("if");
	kw("return", beforeExpr);
	kw("switch");
	kw("throw", beforeExpr);
	kw("try");
	kw("var");
	kw("let");
	kw("const");
	kw("while", { isLoop: true });
	kw("with");
	kw("new", { beforeExpr: true, startsExpr: true });
	kw("this", startsExpr);
	kw("super", startsExpr);
	kw("class");
	kw("extends", beforeExpr);
	kw("export");
	kw("import");
	kw("yield", { beforeExpr: true, startsExpr: true });
	kw("null", startsExpr);
	kw("true", startsExpr);
	kw("false", startsExpr);
	kw("in", { beforeExpr: true, binop: 7 });
	kw("instanceof", { beforeExpr: true, binop: 7 });
	kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("void", { beforeExpr: true, prefix: true, startsExpr: true });
	kw("delete", { beforeExpr: true, prefix: true, startsExpr: true });

	},{}],15:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.isArray = isArray;
	exports.has = has;

	function isArray(obj) {
	  return Object.prototype.toString.call(obj) === "[object Array]";
	}

	// Checks if an object has a property.

	function has(obj, propName) {
	  return Object.prototype.hasOwnProperty.call(obj, propName);
	}

	},{}],16:[function(_dereq_,module,exports){
	// Matches a whole line break (where CRLF is considered a single
	// line break). Used to count lines.

	"use strict";

	exports.__esModule = true;
	exports.isNewLine = isNewLine;
	var lineBreak = /\r\n?|\n|\u2028|\u2029/;
	exports.lineBreak = lineBreak;
	var lineBreakG = new RegExp(lineBreak.source, "g");

	exports.lineBreakG = lineBreakG;

	function isNewLine(code) {
	  return code === 10 || code === 13 || code === 0x2028 || code == 0x2029;
	}

	var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
	exports.nonASCIIwhitespace = nonASCIIwhitespace;

	},{}]},{},[3])(3)
	});

/***/ },
/* 227 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 227;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).loose = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";

	module.exports = typeof acorn != 'undefined' ? acorn : __webpack_require__(226);

	},{}],2:[function(_dereq_,module,exports){
	"use strict";

	var _state = _dereq_("./state");

	var _parseutil = _dereq_("./parseutil");

	var _ = _dereq_("..");

	var lp = _state.LooseParser.prototype;

	lp.checkLVal = function (expr) {
	  if (!expr) return expr;
	  switch (expr.type) {
	    case "Identifier":
	    case "MemberExpression":
	      return expr;

	    case "ParenthesizedExpression":
	      expr.expression = this.checkLVal(expr.expression);
	      return expr;

	    default:
	      return this.dummyIdent();
	  }
	};

	lp.parseExpression = function (noIn) {
	  var start = this.storeCurrentPos();
	  var expr = this.parseMaybeAssign(noIn);
	  if (this.tok.type === _.tokTypes.comma) {
	    var node = this.startNodeAt(start);
	    node.expressions = [expr];
	    while (this.eat(_.tokTypes.comma)) node.expressions.push(this.parseMaybeAssign(noIn));
	    return this.finishNode(node, "SequenceExpression");
	  }
	  return expr;
	};

	lp.parseParenExpression = function () {
	  this.pushCx();
	  this.expect(_.tokTypes.parenL);
	  var val = this.parseExpression();
	  this.popCx();
	  this.expect(_.tokTypes.parenR);
	  return val;
	};

	lp.parseMaybeAssign = function (noIn) {
	  var start = this.storeCurrentPos();
	  var left = this.parseMaybeConditional(noIn);
	  if (this.tok.type.isAssign) {
	    var node = this.startNodeAt(start);
	    node.operator = this.tok.value;
	    node.left = this.tok.type === _.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);
	    this.next();
	    node.right = this.parseMaybeAssign(noIn);
	    return this.finishNode(node, "AssignmentExpression");
	  }
	  return left;
	};

	lp.parseMaybeConditional = function (noIn) {
	  var start = this.storeCurrentPos();
	  var expr = this.parseExprOps(noIn);
	  if (this.eat(_.tokTypes.question)) {
	    var node = this.startNodeAt(start);
	    node.test = expr;
	    node.consequent = this.parseMaybeAssign();
	    node.alternate = this.expect(_.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
	    return this.finishNode(node, "ConditionalExpression");
	  }
	  return expr;
	};

	lp.parseExprOps = function (noIn) {
	  var start = this.storeCurrentPos();
	  var indent = this.curIndent,
	      line = this.curLineStart;
	  return this.parseExprOp(this.parseMaybeUnary(noIn), start, -1, noIn, indent, line);
	};

	lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
	  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left;
	  var prec = this.tok.type.binop;
	  if (prec != null && (!noIn || this.tok.type !== _.tokTypes._in)) {
	    if (prec > minPrec) {
	      var node = this.startNodeAt(start);
	      node.left = left;
	      node.operator = this.tok.value;
	      this.next();
	      if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
	        node.right = this.dummyIdent();
	      } else {
	        var rightStart = this.storeCurrentPos();
	        node.right = this.parseExprOp(this.parseMaybeUnary(noIn), rightStart, prec, noIn, indent, line);
	      }
	      this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
	      return this.parseExprOp(node, start, minPrec, noIn, indent, line);
	    }
	  }
	  return left;
	};

	lp.parseMaybeUnary = function (noIn) {
	  if (this.tok.type.prefix) {
	    var node = this.startNode(),
	        update = this.tok.type === _.tokTypes.incDec;
	    node.operator = this.tok.value;
	    node.prefix = true;
	    this.next();
	    node.argument = this.parseMaybeUnary(noIn);
	    if (update) node.argument = this.checkLVal(node.argument);
	    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
	  } else if (this.tok.type === _.tokTypes.ellipsis) {
	    var node = this.startNode();
	    this.next();
	    node.argument = this.parseMaybeUnary(noIn);
	    return this.finishNode(node, "SpreadElement");
	  }
	  var start = this.storeCurrentPos();
	  var expr = this.parseExprSubscripts();
	  while (this.tok.type.postfix && !this.canInsertSemicolon()) {
	    var node = this.startNodeAt(start);
	    node.operator = this.tok.value;
	    node.prefix = false;
	    node.argument = this.checkLVal(expr);
	    this.next();
	    expr = this.finishNode(node, "UpdateExpression");
	  }
	  return expr;
	};

	lp.parseExprSubscripts = function () {
	  var start = this.storeCurrentPos();
	  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
	};

	lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
	  for (;;) {
	    if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
	      if (this.tok.type == _.tokTypes.dot && this.curIndent == startIndent) --startIndent;else return base;
	    }

	    if (this.eat(_.tokTypes.dot)) {
	      var node = this.startNodeAt(start);
	      node.object = base;
	      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) node.property = this.dummyIdent();else node.property = this.parsePropertyAccessor() || this.dummyIdent();
	      node.computed = false;
	      base = this.finishNode(node, "MemberExpression");
	    } else if (this.tok.type == _.tokTypes.bracketL) {
	      this.pushCx();
	      this.next();
	      var node = this.startNodeAt(start);
	      node.object = base;
	      node.property = this.parseExpression();
	      node.computed = true;
	      this.popCx();
	      this.expect(_.tokTypes.bracketR);
	      base = this.finishNode(node, "MemberExpression");
	    } else if (!noCalls && this.tok.type == _.tokTypes.parenL) {
	      var node = this.startNodeAt(start);
	      node.callee = base;
	      node.arguments = this.parseExprList(_.tokTypes.parenR);
	      base = this.finishNode(node, "CallExpression");
	    } else if (this.tok.type == _.tokTypes.backQuote) {
	      var node = this.startNodeAt(start);
	      node.tag = base;
	      node.quasi = this.parseTemplate();
	      base = this.finishNode(node, "TaggedTemplateExpression");
	    } else {
	      return base;
	    }
	  }
	};

	lp.parseExprAtom = function () {
	  var node = undefined;
	  switch (this.tok.type) {
	    case _.tokTypes._this:
	    case _.tokTypes._super:
	      var type = this.tok.type === _.tokTypes._this ? "ThisExpression" : "Super";
	      node = this.startNode();
	      this.next();
	      return this.finishNode(node, type);

	    case _.tokTypes.name:
	      var start = this.storeCurrentPos();
	      var id = this.parseIdent();
	      return this.eat(_.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id]) : id;

	    case _.tokTypes.regexp:
	      node = this.startNode();
	      var val = this.tok.value;
	      node.regex = { pattern: val.pattern, flags: val.flags };
	      node.value = val.value;
	      node.raw = this.input.slice(this.tok.start, this.tok.end);
	      this.next();
	      return this.finishNode(node, "Literal");

	    case _.tokTypes.num:case _.tokTypes.string:
	      node = this.startNode();
	      node.value = this.tok.value;
	      node.raw = this.input.slice(this.tok.start, this.tok.end);
	      this.next();
	      return this.finishNode(node, "Literal");

	    case _.tokTypes._null:case _.tokTypes._true:case _.tokTypes._false:
	      node = this.startNode();
	      node.value = this.tok.type === _.tokTypes._null ? null : this.tok.type === _.tokTypes._true;
	      node.raw = this.tok.type.keyword;
	      this.next();
	      return this.finishNode(node, "Literal");

	    case _.tokTypes.parenL:
	      var parenStart = this.storeCurrentPos();
	      this.next();
	      var inner = this.parseExpression();
	      this.expect(_.tokTypes.parenR);
	      if (this.eat(_.tokTypes.arrow)) {
	        return this.parseArrowExpression(this.startNodeAt(parenStart), inner.expressions || (_parseutil.isDummy(inner) ? [] : [inner]));
	      }
	      if (this.options.preserveParens) {
	        var par = this.startNodeAt(parenStart);
	        par.expression = inner;
	        inner = this.finishNode(par, "ParenthesizedExpression");
	      }
	      return inner;

	    case _.tokTypes.bracketL:
	      node = this.startNode();
	      node.elements = this.parseExprList(_.tokTypes.bracketR, true);
	      return this.finishNode(node, "ArrayExpression");

	    case _.tokTypes.braceL:
	      return this.parseObj();

	    case _.tokTypes._class:
	      return this.parseClass();

	    case _.tokTypes._function:
	      node = this.startNode();
	      this.next();
	      return this.parseFunction(node, false);

	    case _.tokTypes._new:
	      return this.parseNew();

	    case _.tokTypes._yield:
	      node = this.startNode();
	      this.next();
	      if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != _.tokTypes.star && !this.tok.type.startsExpr) {
	        node.delegate = false;
	        node.argument = null;
	      } else {
	        node.delegate = this.eat(_.tokTypes.star);
	        node.argument = this.parseMaybeAssign();
	      }
	      return this.finishNode(node, "YieldExpression");

	    case _.tokTypes.backQuote:
	      return this.parseTemplate();

	    default:
	      return this.dummyIdent();
	  }
	};

	lp.parseNew = function () {
	  var node = this.startNode(),
	      startIndent = this.curIndent,
	      line = this.curLineStart;
	  var meta = this.parseIdent(true);
	  if (this.options.ecmaVersion >= 6 && this.eat(_.tokTypes.dot)) {
	    node.meta = meta;
	    node.property = this.parseIdent(true);
	    return this.finishNode(node, "MetaProperty");
	  }
	  var start = this.storeCurrentPos();
	  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);
	  if (this.tok.type == _.tokTypes.parenL) {
	    node.arguments = this.parseExprList(_.tokTypes.parenR);
	  } else {
	    node.arguments = [];
	  }
	  return this.finishNode(node, "NewExpression");
	};

	lp.parseTemplateElement = function () {
	  var elem = this.startNode();
	  elem.value = {
	    raw: this.input.slice(this.tok.start, this.tok.end).replace(/\r\n?/g, '\n'),
	    cooked: this.tok.value
	  };
	  this.next();
	  elem.tail = this.tok.type === _.tokTypes.backQuote;
	  return this.finishNode(elem, "TemplateElement");
	};

	lp.parseTemplate = function () {
	  var node = this.startNode();
	  this.next();
	  node.expressions = [];
	  var curElt = this.parseTemplateElement();
	  node.quasis = [curElt];
	  while (!curElt.tail) {
	    this.next();
	    node.expressions.push(this.parseExpression());
	    if (this.expect(_.tokTypes.braceR)) {
	      curElt = this.parseTemplateElement();
	    } else {
	      curElt = this.startNode();
	      curElt.value = { cooked: '', raw: '' };
	      curElt.tail = true;
	    }
	    node.quasis.push(curElt);
	  }
	  this.expect(_.tokTypes.backQuote);
	  return this.finishNode(node, "TemplateLiteral");
	};

	lp.parseObj = function () {
	  var node = this.startNode();
	  node.properties = [];
	  this.pushCx();
	  var indent = this.curIndent + 1,
	      line = this.curLineStart;
	  this.eat(_.tokTypes.braceL);
	  if (this.curIndent + 1 < indent) {
	    indent = this.curIndent;line = this.curLineStart;
	  }
	  while (!this.closes(_.tokTypes.braceR, indent, line)) {
	    var prop = this.startNode(),
	        isGenerator = undefined,
	        start = undefined;
	    if (this.options.ecmaVersion >= 6) {
	      start = this.storeCurrentPos();
	      prop.method = false;
	      prop.shorthand = false;
	      isGenerator = this.eat(_.tokTypes.star);
	    }
	    this.parsePropertyName(prop);
	    if (_parseutil.isDummy(prop.key)) {
	      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
	    }
	    if (this.eat(_.tokTypes.colon)) {
	      prop.kind = "init";
	      prop.value = this.parseMaybeAssign();
	    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === _.tokTypes.parenL || this.tok.type === _.tokTypes.braceL)) {
	      prop.kind = "init";
	      prop.method = true;
	      prop.value = this.parseMethod(isGenerator);
	    } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && (this.tok.type != _.tokTypes.comma && this.tok.type != _.tokTypes.braceR)) {
	      prop.kind = prop.key.name;
	      this.parsePropertyName(prop);
	      prop.value = this.parseMethod(false);
	    } else {
	      prop.kind = "init";
	      if (this.options.ecmaVersion >= 6) {
	        if (this.eat(_.tokTypes.eq)) {
	          var assign = this.startNodeAt(start);
	          assign.operator = "=";
	          assign.left = prop.key;
	          assign.right = this.parseMaybeAssign();
	          prop.value = this.finishNode(assign, "AssignmentExpression");
	        } else {
	          prop.value = prop.key;
	        }
	      } else {
	        prop.value = this.dummyIdent();
	      }
	      prop.shorthand = true;
	    }
	    node.properties.push(this.finishNode(prop, "Property"));
	    this.eat(_.tokTypes.comma);
	  }
	  this.popCx();
	  if (!this.eat(_.tokTypes.braceR)) {
	    // If there is no closing brace, make the node span to the start
	    // of the next token (this is useful for Tern)
	    this.last.end = this.tok.start;
	    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
	  }
	  return this.finishNode(node, "ObjectExpression");
	};

	lp.parsePropertyName = function (prop) {
	  if (this.options.ecmaVersion >= 6) {
	    if (this.eat(_.tokTypes.bracketL)) {
	      prop.computed = true;
	      prop.key = this.parseExpression();
	      this.expect(_.tokTypes.bracketR);
	      return;
	    } else {
	      prop.computed = false;
	    }
	  }
	  var key = this.tok.type === _.tokTypes.num || this.tok.type === _.tokTypes.string ? this.parseExprAtom() : this.parseIdent();
	  prop.key = key || this.dummyIdent();
	};

	lp.parsePropertyAccessor = function () {
	  if (this.tok.type === _.tokTypes.name || this.tok.type.keyword) return this.parseIdent();
	};

	lp.parseIdent = function () {
	  var name = this.tok.type === _.tokTypes.name ? this.tok.value : this.tok.type.keyword;
	  if (!name) return this.dummyIdent();
	  var node = this.startNode();
	  this.next();
	  node.name = name;
	  return this.finishNode(node, "Identifier");
	};

	lp.initFunction = function (node) {
	  node.id = null;
	  node.params = [];
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = false;
	    node.expression = false;
	  }
	};

	// Convert existing expression atom to assignable pattern
	// if possible.

	lp.toAssignable = function (node, binding) {
	  if (!node || node.type == "Identifier" || node.type == "MemberExpression" && !binding) {
	    // Okay
	  } else if (node.type == "ParenthesizedExpression") {
	      node.expression = this.toAssignable(node.expression, binding);
	    } else if (this.options.ecmaVersion < 6) {
	      return this.dummyIdent();
	    } else if (node.type == "ObjectExpression") {
	      node.type = "ObjectPattern";
	      var props = node.properties;
	      for (var i = 0; i < props.length; i++) {
	        props[i].value = this.toAssignable(props[i].value, binding);
	      }
	    } else if (node.type == "ArrayExpression") {
	      node.type = "ArrayPattern";
	      this.toAssignableList(node.elements, binding);
	    } else if (node.type == "SpreadElement") {
	      node.type = "RestElement";
	      node.argument = this.toAssignable(node.argument, binding);
	    } else if (node.type == "AssignmentExpression") {
	      node.type = "AssignmentPattern";
	      delete node.operator;
	    } else {
	      return this.dummyIdent();
	    }
	  return node;
	};

	lp.toAssignableList = function (exprList, binding) {
	  for (var i = 0; i < exprList.length; i++) {
	    exprList[i] = this.toAssignable(exprList[i], binding);
	  }return exprList;
	};

	lp.parseFunctionParams = function (params) {
	  params = this.parseExprList(_.tokTypes.parenR);
	  return this.toAssignableList(params, true);
	};

	lp.parseMethod = function (isGenerator) {
	  var node = this.startNode();
	  this.initFunction(node);
	  node.params = this.parseFunctionParams();
	  node.generator = isGenerator || false;
	  node.expression = this.options.ecmaVersion >= 6 && this.tok.type !== _.tokTypes.braceL;
	  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
	  return this.finishNode(node, "FunctionExpression");
	};

	lp.parseArrowExpression = function (node, params) {
	  this.initFunction(node);
	  node.params = this.toAssignableList(params, true);
	  node.expression = this.tok.type !== _.tokTypes.braceL;
	  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
	  return this.finishNode(node, "ArrowFunctionExpression");
	};

	lp.parseExprList = function (close, allowEmpty) {
	  this.pushCx();
	  var indent = this.curIndent,
	      line = this.curLineStart,
	      elts = [];
	  this.next(); // Opening bracket
	  while (!this.closes(close, indent + 1, line)) {
	    if (this.eat(_.tokTypes.comma)) {
	      elts.push(allowEmpty ? null : this.dummyIdent());
	      continue;
	    }
	    var elt = this.parseMaybeAssign();
	    if (_parseutil.isDummy(elt)) {
	      if (this.closes(close, indent, line)) break;
	      this.next();
	    } else {
	      elts.push(elt);
	    }
	    this.eat(_.tokTypes.comma);
	  }
	  this.popCx();
	  if (!this.eat(close)) {
	    // If there is no closing brace, make the node span to the start
	    // of the next token (this is useful for Tern)
	    this.last.end = this.tok.start;
	    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
	  }
	  return elts;
	};

	},{"..":1,"./parseutil":4,"./state":5}],3:[function(_dereq_,module,exports){
	// Acorn: Loose parser
	//
	// This module provides an alternative parser (`parse_dammit`) that
	// exposes that same interface as `parse`, but will try to parse
	// anything as JavaScript, repairing syntax error the best it can.
	// There are circumstances in which it will raise an error and give
	// up, but they are very rare. The resulting AST will be a mostly
	// valid JavaScript AST (as per the [Mozilla parser API][api], except
	// that:
	//
	// - Return outside functions is allowed
	//
	// - Label consistency (no conflicts, break only to existing labels)
	//   is not enforced.
	//
	// - Bogus Identifier nodes with a name of `"✖"` are inserted whenever
	//   the parser got too confused to return anything meaningful.
	//
	// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
	//
	// The expected use for this is to *first* try `acorn.parse`, and only
	// if that fails switch to `parse_dammit`. The loose parser might
	// parse badly indented code incorrectly, so **don't** use it as
	// your default parser.
	//
	// Quite a lot of acorn.js is duplicated here. The alternative was to
	// add a *lot* of extra cruft to that file, making it less readable
	// and slower. Copying and editing the code allowed me to make
	// invasive changes and simplifications without creating a complicated
	// tangle.

	"use strict";

	exports.__esModule = true;
	exports.parse_dammit = parse_dammit;

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

	var _ = _dereq_("..");

	var acorn = _interopRequireWildcard(_);

	var _state = _dereq_("./state");

	_dereq_("./tokenize");

	_dereq_("./statement");

	_dereq_("./expression");

	exports.LooseParser = _state.LooseParser;
	exports.pluginsLoose = _state.pluginsLoose;

	acorn.defaultOptions.tabSize = 4;

	function parse_dammit(input, options) {
	  var p = new _state.LooseParser(input, options);
	  p.next();
	  return p.parseTopLevel();
	}

	// Don't define new properties on acorn because of:
	// TypeError: can't define property "parse_dammit": Object is not extensible
	// acorn.parse_dammit = parse_dammit;
	// acorn.LooseParser = _state.LooseParser;
	// acorn.pluginsLoose = _state.pluginsLoose;

	},{"..":1,"./expression":2,"./state":5,"./statement":6,"./tokenize":7}],4:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;
	exports.isDummy = isDummy;

	function isDummy(node) {
	  return node.name == "✖";
	}

	},{}],5:[function(_dereq_,module,exports){
	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _ = _dereq_("..");

	// Registered plugins
	var pluginsLoose = {};

	exports.pluginsLoose = pluginsLoose;

	var LooseParser = (function () {
	  function LooseParser(input, options) {
	    _classCallCheck(this, LooseParser);

	    this.toks = _.tokenizer(input, options);
	    this.options = this.toks.options;
	    this.input = this.toks.input;
	    this.tok = this.last = { type: _.tokTypes.eof, start: 0, end: 0 };
	    if (this.options.locations) {
	      var here = this.toks.curPosition();
	      this.tok.loc = new _.SourceLocation(this.toks, here, here);
	    }
	    this.ahead = []; // Tokens ahead
	    this.context = []; // Indentation contexted
	    this.curIndent = 0;
	    this.curLineStart = 0;
	    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
	    // Load plugins
	    this.options.pluginsLoose = options.pluginsLoose || {};
	    this.loadPlugins(this.options.pluginsLoose);
	  }

	  LooseParser.prototype.startNode = function startNode() {
	    return new _.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
	  };

	  LooseParser.prototype.storeCurrentPos = function storeCurrentPos() {
	    return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
	  };

	  LooseParser.prototype.startNodeAt = function startNodeAt(pos) {
	    if (this.options.locations) {
	      return new _.Node(this.toks, pos[0], pos[1]);
	    } else {
	      return new _.Node(this.toks, pos);
	    }
	  };

	  LooseParser.prototype.finishNode = function finishNode(node, type) {
	    node.type = type;
	    node.end = this.last.end;
	    if (this.options.locations) node.loc.end = this.last.loc.end;
	    if (this.options.ranges) node.range[1] = this.last.end;
	    return node;
	  };

	  LooseParser.prototype.dummyNode = function dummyNode(type) {
	    var dummy = this.startNode();
	    dummy.type = type;
	    dummy.end = dummy.start;
	    if (this.options.locations) dummy.loc.end = dummy.loc.start;
	    if (this.options.ranges) dummy.range[1] = dummy.start;
	    this.last = { type: _.tokTypes.name, start: dummy.start, end: dummy.start, loc: dummy.loc };
	    return dummy;
	  };

	  LooseParser.prototype.dummyIdent = function dummyIdent() {
	    var dummy = this.dummyNode("Identifier");
	    dummy.name = "✖";
	    return dummy;
	  };

	  LooseParser.prototype.dummyString = function dummyString() {
	    var dummy = this.dummyNode("Literal");
	    dummy.value = dummy.raw = "✖";
	    return dummy;
	  };

	  LooseParser.prototype.eat = function eat(type) {
	    if (this.tok.type === type) {
	      this.next();
	      return true;
	    } else {
	      return false;
	    }
	  };

	  LooseParser.prototype.isContextual = function isContextual(name) {
	    return this.tok.type === _.tokTypes.name && this.tok.value === name;
	  };

	  LooseParser.prototype.eatContextual = function eatContextual(name) {
	    return this.tok.value === name && this.eat(_.tokTypes.name);
	  };

	  LooseParser.prototype.canInsertSemicolon = function canInsertSemicolon() {
	    return this.tok.type === _.tokTypes.eof || this.tok.type === _.tokTypes.braceR || _.lineBreak.test(this.input.slice(this.last.end, this.tok.start));
	  };

	  LooseParser.prototype.semicolon = function semicolon() {
	    return this.eat(_.tokTypes.semi);
	  };

	  LooseParser.prototype.expect = function expect(type) {
	    if (this.eat(type)) return true;
	    for (var i = 1; i <= 2; i++) {
	      if (this.lookAhead(i).type == type) {
	        for (var j = 0; j < i; j++) {
	          this.next();
	        }return true;
	      }
	    }
	  };

	  LooseParser.prototype.pushCx = function pushCx() {
	    this.context.push(this.curIndent);
	  };

	  LooseParser.prototype.popCx = function popCx() {
	    this.curIndent = this.context.pop();
	  };

	  LooseParser.prototype.lineEnd = function lineEnd(pos) {
	    while (pos < this.input.length && !_.isNewLine(this.input.charCodeAt(pos))) ++pos;
	    return pos;
	  };

	  LooseParser.prototype.indentationAfter = function indentationAfter(pos) {
	    for (var count = 0;; ++pos) {
	      var ch = this.input.charCodeAt(pos);
	      if (ch === 32) ++count;else if (ch === 9) count += this.options.tabSize;else return count;
	    }
	  };

	  LooseParser.prototype.closes = function closes(closeTok, indent, line, blockHeuristic) {
	    if (this.tok.type === closeTok || this.tok.type === _.tokTypes.eof) return true;
	    return line != this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);
	  };

	  LooseParser.prototype.tokenStartsLine = function tokenStartsLine() {
	    for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
	      var ch = this.input.charCodeAt(p);
	      if (ch !== 9 && ch !== 32) return false;
	    }
	    return true;
	  };

	  LooseParser.prototype.extend = function extend(name, f) {
	    this[name] = f(this[name]);
	  };

	  LooseParser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {
	    for (var _name in pluginConfigs) {
	      var plugin = pluginsLoose[_name];
	      if (!plugin) throw new Error("Plugin '" + _name + "' not found");
	      plugin(this, pluginConfigs[_name]);
	    }
	  };

	  return LooseParser;
	})();

	exports.LooseParser = LooseParser;

	},{"..":1}],6:[function(_dereq_,module,exports){
	"use strict";

	var _state = _dereq_("./state");

	var _parseutil = _dereq_("./parseutil");

	var _ = _dereq_("..");

	var lp = _state.LooseParser.prototype;

	lp.parseTopLevel = function () {
	  var node = this.startNodeAt(this.options.locations ? [0, _.getLineInfo(this.input, 0)] : 0);
	  node.body = [];
	  while (this.tok.type !== _.tokTypes.eof) node.body.push(this.parseStatement());
	  this.last = this.tok;
	  if (this.options.ecmaVersion >= 6) {
	    node.sourceType = this.options.sourceType;
	  }
	  return this.finishNode(node, "Program");
	};

	lp.parseStatement = function () {
	  var starttype = this.tok.type,
	      node = this.startNode();

	  switch (starttype) {
	    case _.tokTypes._break:case _.tokTypes._continue:
	      this.next();
	      var isBreak = starttype === _.tokTypes._break;
	      if (this.semicolon() || this.canInsertSemicolon()) {
	        node.label = null;
	      } else {
	        node.label = this.tok.type === _.tokTypes.name ? this.parseIdent() : null;
	        this.semicolon();
	      }
	      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

	    case _.tokTypes._debugger:
	      this.next();
	      this.semicolon();
	      return this.finishNode(node, "DebuggerStatement");

	    case _.tokTypes._do:
	      this.next();
	      node.body = this.parseStatement();
	      node.test = this.eat(_.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();
	      this.semicolon();
	      return this.finishNode(node, "DoWhileStatement");

	    case _.tokTypes._for:
	      this.next();
	      this.pushCx();
	      this.expect(_.tokTypes.parenL);
	      if (this.tok.type === _.tokTypes.semi) return this.parseFor(node, null);
	      if (this.tok.type === _.tokTypes._var || this.tok.type === _.tokTypes._let || this.tok.type === _.tokTypes._const) {
	        var _init = this.parseVar(true);
	        if (_init.declarations.length === 1 && (this.tok.type === _.tokTypes._in || this.isContextual("of"))) {
	          return this.parseForIn(node, _init);
	        }
	        return this.parseFor(node, _init);
	      }
	      var init = this.parseExpression(true);
	      if (this.tok.type === _.tokTypes._in || this.isContextual("of")) return this.parseForIn(node, this.toAssignable(init));
	      return this.parseFor(node, init);

	    case _.tokTypes._function:
	      this.next();
	      return this.parseFunction(node, true);

	    case _.tokTypes._if:
	      this.next();
	      node.test = this.parseParenExpression();
	      node.consequent = this.parseStatement();
	      node.alternate = this.eat(_.tokTypes._else) ? this.parseStatement() : null;
	      return this.finishNode(node, "IfStatement");

	    case _.tokTypes._return:
	      this.next();
	      if (this.eat(_.tokTypes.semi) || this.canInsertSemicolon()) node.argument = null;else {
	        node.argument = this.parseExpression();this.semicolon();
	      }
	      return this.finishNode(node, "ReturnStatement");

	    case _.tokTypes._switch:
	      var blockIndent = this.curIndent,
	          line = this.curLineStart;
	      this.next();
	      node.discriminant = this.parseParenExpression();
	      node.cases = [];
	      this.pushCx();
	      this.expect(_.tokTypes.braceL);

	      var cur = undefined;
	      while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) {
	        if (this.tok.type === _.tokTypes._case || this.tok.type === _.tokTypes._default) {
	          var isCase = this.tok.type === _.tokTypes._case;
	          if (cur) this.finishNode(cur, "SwitchCase");
	          node.cases.push(cur = this.startNode());
	          cur.consequent = [];
	          this.next();
	          if (isCase) cur.test = this.parseExpression();else cur.test = null;
	          this.expect(_.tokTypes.colon);
	        } else {
	          if (!cur) {
	            node.cases.push(cur = this.startNode());
	            cur.consequent = [];
	            cur.test = null;
	          }
	          cur.consequent.push(this.parseStatement());
	        }
	      }
	      if (cur) this.finishNode(cur, "SwitchCase");
	      this.popCx();
	      this.eat(_.tokTypes.braceR);
	      return this.finishNode(node, "SwitchStatement");

	    case _.tokTypes._throw:
	      this.next();
	      node.argument = this.parseExpression();
	      this.semicolon();
	      return this.finishNode(node, "ThrowStatement");

	    case _.tokTypes._try:
	      this.next();
	      node.block = this.parseBlock();
	      node.handler = null;
	      if (this.tok.type === _.tokTypes._catch) {
	        var clause = this.startNode();
	        this.next();
	        this.expect(_.tokTypes.parenL);
	        clause.param = this.toAssignable(this.parseExprAtom(), true);
	        this.expect(_.tokTypes.parenR);
	        clause.body = this.parseBlock();
	        node.handler = this.finishNode(clause, "CatchClause");
	      }
	      node.finalizer = this.eat(_.tokTypes._finally) ? this.parseBlock() : null;
	      if (!node.handler && !node.finalizer) return node.block;
	      return this.finishNode(node, "TryStatement");

	    case _.tokTypes._var:
	    case _.tokTypes._let:
	    case _.tokTypes._const:
	      return this.parseVar();

	    case _.tokTypes._while:
	      this.next();
	      node.test = this.parseParenExpression();
	      node.body = this.parseStatement();
	      return this.finishNode(node, "WhileStatement");

	    case _.tokTypes._with:
	      this.next();
	      node.object = this.parseParenExpression();
	      node.body = this.parseStatement();
	      return this.finishNode(node, "WithStatement");

	    case _.tokTypes.braceL:
	      return this.parseBlock();

	    case _.tokTypes.semi:
	      this.next();
	      return this.finishNode(node, "EmptyStatement");

	    case _.tokTypes._class:
	      return this.parseClass(true);

	    case _.tokTypes._import:
	      return this.parseImport();

	    case _.tokTypes._export:
	      return this.parseExport();

	    default:
	      var expr = this.parseExpression();
	      if (_parseutil.isDummy(expr)) {
	        this.next();
	        if (this.tok.type === _.tokTypes.eof) return this.finishNode(node, "EmptyStatement");
	        return this.parseStatement();
	      } else if (starttype === _.tokTypes.name && expr.type === "Identifier" && this.eat(_.tokTypes.colon)) {
	        node.body = this.parseStatement();
	        node.label = expr;
	        return this.finishNode(node, "LabeledStatement");
	      } else {
	        node.expression = expr;
	        this.semicolon();
	        return this.finishNode(node, "ExpressionStatement");
	      }
	  }
	};

	lp.parseBlock = function () {
	  var node = this.startNode();
	  this.pushCx();
	  this.expect(_.tokTypes.braceL);
	  var blockIndent = this.curIndent,
	      line = this.curLineStart;
	  node.body = [];
	  while (!this.closes(_.tokTypes.braceR, blockIndent, line, true)) node.body.push(this.parseStatement());
	  this.popCx();
	  this.eat(_.tokTypes.braceR);
	  return this.finishNode(node, "BlockStatement");
	};

	lp.parseFor = function (node, init) {
	  node.init = init;
	  node.test = node.update = null;
	  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.semi) node.test = this.parseExpression();
	  if (this.eat(_.tokTypes.semi) && this.tok.type !== _.tokTypes.parenR) node.update = this.parseExpression();
	  this.popCx();
	  this.expect(_.tokTypes.parenR);
	  node.body = this.parseStatement();
	  return this.finishNode(node, "ForStatement");
	};

	lp.parseForIn = function (node, init) {
	  var type = this.tok.type === _.tokTypes._in ? "ForInStatement" : "ForOfStatement";
	  this.next();
	  node.left = init;
	  node.right = this.parseExpression();
	  this.popCx();
	  this.expect(_.tokTypes.parenR);
	  node.body = this.parseStatement();
	  return this.finishNode(node, type);
	};

	lp.parseVar = function (noIn) {
	  var node = this.startNode();
	  node.kind = this.tok.type.keyword;
	  this.next();
	  node.declarations = [];
	  do {
	    var decl = this.startNode();
	    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();
	    decl.init = this.eat(_.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	  } while (this.eat(_.tokTypes.comma));
	  if (!node.declarations.length) {
	    var decl = this.startNode();
	    decl.id = this.dummyIdent();
	    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
	  }
	  if (!noIn) this.semicolon();
	  return this.finishNode(node, "VariableDeclaration");
	};

	lp.parseClass = function (isStatement) {
	  var node = this.startNode();
	  this.next();
	  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();else node.id = null;
	  node.superClass = this.eat(_.tokTypes._extends) ? this.parseExpression() : null;
	  node.body = this.startNode();
	  node.body.body = [];
	  this.pushCx();
	  var indent = this.curIndent + 1,
	      line = this.curLineStart;
	  this.eat(_.tokTypes.braceL);
	  if (this.curIndent + 1 < indent) {
	    indent = this.curIndent;line = this.curLineStart;
	  }
	  while (!this.closes(_.tokTypes.braceR, indent, line)) {
	    if (this.semicolon()) continue;
	    var method = this.startNode(),
	        isGenerator = undefined;
	    if (this.options.ecmaVersion >= 6) {
	      method["static"] = false;
	      isGenerator = this.eat(_.tokTypes.star);
	    }
	    this.parsePropertyName(method);
	    if (_parseutil.isDummy(method.key)) {
	      if (_parseutil.isDummy(this.parseMaybeAssign())) this.next();this.eat(_.tokTypes.comma);continue;
	    }
	    if (method.key.type === "Identifier" && !method.computed && method.key.name === "static" && (this.tok.type != _.tokTypes.parenL && this.tok.type != _.tokTypes.braceL)) {
	      method["static"] = true;
	      isGenerator = this.eat(_.tokTypes.star);
	      this.parsePropertyName(method);
	    } else {
	      method["static"] = false;
	    }
	    if (this.options.ecmaVersion >= 5 && method.key.type === "Identifier" && !method.computed && (method.key.name === "get" || method.key.name === "set") && this.tok.type !== _.tokTypes.parenL && this.tok.type !== _.tokTypes.braceL) {
	      method.kind = method.key.name;
	      this.parsePropertyName(method);
	      method.value = this.parseMethod(false);
	    } else {
	      if (!method.computed && !method["static"] && !isGenerator && (method.key.type === "Identifier" && method.key.name === "constructor" || method.key.type === "Literal" && method.key.value === "constructor")) {
	        method.kind = "constructor";
	      } else {
	        method.kind = "method";
	      }
	      method.value = this.parseMethod(isGenerator);
	    }
	    node.body.body.push(this.finishNode(method, "MethodDefinition"));
	  }
	  this.popCx();
	  if (!this.eat(_.tokTypes.braceR)) {
	    // If there is no closing brace, make the node span to the start
	    // of the next token (this is useful for Tern)
	    this.last.end = this.tok.start;
	    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
	  }
	  this.semicolon();
	  this.finishNode(node.body, "ClassBody");
	  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
	};

	lp.parseFunction = function (node, isStatement) {
	  this.initFunction(node);
	  if (this.options.ecmaVersion >= 6) {
	    node.generator = this.eat(_.tokTypes.star);
	  }
	  if (this.tok.type === _.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();
	  node.params = this.parseFunctionParams();
	  node.body = this.parseBlock();
	  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
	};

	lp.parseExport = function () {
	  var node = this.startNode();
	  this.next();
	  if (this.eat(_.tokTypes.star)) {
	    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
	    return this.finishNode(node, "ExportAllDeclaration");
	  }
	  if (this.eat(_.tokTypes._default)) {
	    var expr = this.parseMaybeAssign();
	    if (expr.id) {
	      switch (expr.type) {
	        case "FunctionExpression":
	          expr.type = "FunctionDeclaration";break;
	        case "ClassExpression":
	          expr.type = "ClassDeclaration";break;
	      }
	    }
	    node.declaration = expr;
	    this.semicolon();
	    return this.finishNode(node, "ExportDefaultDeclaration");
	  }
	  if (this.tok.type.keyword) {
	    node.declaration = this.parseStatement();
	    node.specifiers = [];
	    node.source = null;
	  } else {
	    node.declaration = null;
	    node.specifiers = this.parseExportSpecifierList();
	    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
	    this.semicolon();
	  }
	  return this.finishNode(node, "ExportNamedDeclaration");
	};

	lp.parseImport = function () {
	  var node = this.startNode();
	  this.next();
	  if (this.tok.type === _.tokTypes.string) {
	    node.specifiers = [];
	    node.source = this.parseExprAtom();
	    node.kind = '';
	  } else {
	    var elt = undefined;
	    if (this.tok.type === _.tokTypes.name && this.tok.value !== "from") {
	      elt = this.startNode();
	      elt.local = this.parseIdent();
	      this.finishNode(elt, "ImportDefaultSpecifier");
	      this.eat(_.tokTypes.comma);
	    }
	    node.specifiers = this.parseImportSpecifierList();
	    node.source = this.eatContextual("from") && this.tok.type == _.tokTypes.string ? this.parseExprAtom() : this.dummyString();
	    if (elt) node.specifiers.unshift(elt);
	  }
	  this.semicolon();
	  return this.finishNode(node, "ImportDeclaration");
	};

	lp.parseImportSpecifierList = function () {
	  var elts = [];
	  if (this.tok.type === _.tokTypes.star) {
	    var elt = this.startNode();
	    this.next();
	    if (this.eatContextual("as")) elt.local = this.parseIdent();
	    elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
	  } else {
	    var indent = this.curIndent,
	        line = this.curLineStart,
	        continuedLine = this.nextLineStart;
	    this.pushCx();
	    this.eat(_.tokTypes.braceL);
	    if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
	    while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
	      var elt = this.startNode();
	      if (this.eat(_.tokTypes.star)) {
	        if (this.eatContextual("as")) elt.local = this.parseIdent();
	        this.finishNode(elt, "ImportNamespaceSpecifier");
	      } else {
	        if (this.isContextual("from")) break;
	        elt.imported = this.parseIdent();
	        if (_parseutil.isDummy(elt.imported)) break;
	        elt.local = this.eatContextual("as") ? this.parseIdent() : elt.imported;
	        this.finishNode(elt, "ImportSpecifier");
	      }
	      elts.push(elt);
	      this.eat(_.tokTypes.comma);
	    }
	    this.eat(_.tokTypes.braceR);
	    this.popCx();
	  }
	  return elts;
	};

	lp.parseExportSpecifierList = function () {
	  var elts = [];
	  var indent = this.curIndent,
	      line = this.curLineStart,
	      continuedLine = this.nextLineStart;
	  this.pushCx();
	  this.eat(_.tokTypes.braceL);
	  if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;
	  while (!this.closes(_.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
	    if (this.isContextual("from")) break;
	    var elt = this.startNode();
	    elt.local = this.parseIdent();
	    if (_parseutil.isDummy(elt.local)) break;
	    elt.exported = this.eatContextual("as") ? this.parseIdent() : elt.local;
	    this.finishNode(elt, "ExportSpecifier");
	    elts.push(elt);
	    this.eat(_.tokTypes.comma);
	  }
	  this.eat(_.tokTypes.braceR);
	  this.popCx();
	  return elts;
	};

	},{"..":1,"./parseutil":4,"./state":5}],7:[function(_dereq_,module,exports){
	"use strict";

	var _ = _dereq_("..");

	var _state = _dereq_("./state");

	var lp = _state.LooseParser.prototype;

	function isSpace(ch) {
	  return ch < 14 && ch > 8 || ch === 32 || ch === 160 || _.isNewLine(ch);
	}

	lp.next = function () {
	  this.last = this.tok;
	  if (this.ahead.length) this.tok = this.ahead.shift();else this.tok = this.readToken();

	  if (this.tok.start >= this.nextLineStart) {
	    while (this.tok.start >= this.nextLineStart) {
	      this.curLineStart = this.nextLineStart;
	      this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
	    }
	    this.curIndent = this.indentationAfter(this.curLineStart);
	  }
	};

	lp.readToken = function () {
	  for (;;) {
	    try {
	      this.toks.next();
	      if (this.toks.type === _.tokTypes.dot && this.input.substr(this.toks.end, 1) === "." && this.options.ecmaVersion >= 6) {
	        this.toks.end++;
	        this.toks.type = _.tokTypes.ellipsis;
	      }
	      return new _.Token(this.toks);
	    } catch (e) {
	      if (!(e instanceof SyntaxError)) throw e;

	      // Try to skip some text, based on the error message, and then continue
	      var msg = e.message,
	          pos = e.raisedAt,
	          replace = true;
	      if (/unterminated/i.test(msg)) {
	        pos = this.lineEnd(e.pos + 1);
	        if (/string/.test(msg)) {
	          replace = { start: e.pos, end: pos, type: _.tokTypes.string, value: this.input.slice(e.pos + 1, pos) };
	        } else if (/regular expr/i.test(msg)) {
	          var re = this.input.slice(e.pos, pos);
	          try {
	            re = new RegExp(re);
	          } catch (e) {}
	          replace = { start: e.pos, end: pos, type: _.tokTypes.regexp, value: re };
	        } else if (/template/.test(msg)) {
	          replace = { start: e.pos, end: pos,
	            type: _.tokTypes.template,
	            value: this.input.slice(e.pos, pos) };
	        } else {
	          replace = false;
	        }
	      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {
	        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos;
	      } else if (/character escape|expected hexadecimal/i.test(msg)) {
	        while (pos < this.input.length) {
	          var ch = this.input.charCodeAt(pos++);
	          if (ch === 34 || ch === 39 || _.isNewLine(ch)) break;
	        }
	      } else if (/unexpected character/i.test(msg)) {
	        pos++;
	        replace = false;
	      } else if (/regular expression/i.test(msg)) {
	        replace = true;
	      } else {
	        throw e;
	      }
	      this.resetTo(pos);
	      if (replace === true) replace = { start: pos, end: pos, type: _.tokTypes.name, value: "✖" };
	      if (replace) {
	        if (this.options.locations) replace.loc = new _.SourceLocation(this.toks, _.getLineInfo(this.input, replace.start), _.getLineInfo(this.input, replace.end));
	        return replace;
	      }
	    }
	  }
	};

	lp.resetTo = function (pos) {
	  this.toks.pos = pos;
	  var ch = this.input.charAt(pos - 1);
	  this.toks.exprAllowed = !ch || /[\[\{\(,;:?\/*=+\-~!|&%^<>]/.test(ch) || /[enwfd]/.test(ch) && /\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos));

	  if (this.options.locations) {
	    this.toks.curLine = 1;
	    this.toks.lineStart = _.lineBreakG.lastIndex = 0;
	    var match = undefined;
	    while ((match = _.lineBreakG.exec(this.input)) && match.index < pos) {
	      ++this.toks.curLine;
	      this.toks.lineStart = match.index + match[0].length;
	    }
	  }
	};

	lp.lookAhead = function (n) {
	  while (n > this.ahead.length) this.ahead.push(this.readToken());
	  return this.ahead[n - 1];
	};

	},{"..":1,"./state":5}]},{},[3])(3)
	});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.acorn || (g.acorn = {})).walk = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&!(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	// AST walker module for Mozilla Parser API compatible trees

	// A simple walk is one where you simply specify callbacks to be
	// called on specific nodes. The last two arguments are optional. A
	// simple use would be
	//
	//     walk.simple(myTree, {
	//         Expression: function(node) { ... }
	//     });
	//
	// to do something with all expressions. All Parser API node types
	// can be used to identify node types, as well as Expression,
	// Statement, and ScopeBody, which denote categories of nodes.
	//
	// The base argument can be used to pass a custom (recursive)
	// walker, and state can be used to give this walked an initial
	// state.

	"use strict";

	exports.__esModule = true;
	exports.simple = simple;
	exports.ancestor = ancestor;
	exports.recursive = recursive;
	exports.findNodeAt = findNodeAt;
	exports.findNodeAround = findNodeAround;
	exports.findNodeAfter = findNodeAfter;
	exports.findNodeBefore = findNodeBefore;
	exports.make = make;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function simple(node, visitors, base, state, override) {
	  if (!base) base = exports.base;(function c(node, st, override) {
	    var type = override || node.type,
	        found = visitors[type];
	    base[type](node, st, c);
	    if (found) found(node, st);
	  })(node, state, override);
	}

	// An ancestor walk builds up an array of ancestor nodes (including
	// the current node) and passes them to the callback as the state parameter.

	function ancestor(node, visitors, base, state) {
	  if (!base) base = exports.base;
	  if (!state) state = [];(function c(node, st, override) {
	    var type = override || node.type,
	        found = visitors[type];
	    if (node != st[st.length - 1]) {
	      st = st.slice();
	      st.push(node);
	    }
	    base[type](node, st, c);
	    if (found) found(node, st);
	  })(node, state);
	}

	// A recursive walk is one where your functions override the default
	// walkers. They can modify and replace the state parameter that's
	// threaded through the walk, and can opt how and whether to walk
	// their child nodes (by calling their third argument on these
	// nodes).

	function recursive(node, state, funcs, base, override) {
	  var visitor = funcs ? exports.make(funcs, base) : base;(function c(node, st, override) {
	    visitor[override || node.type](node, st, c);
	  })(node, state, override);
	}

	function makeTest(test) {
	  if (typeof test == "string") return function (type) {
	    return type == test;
	  };else if (!test) return function () {
	    return true;
	  };else return test;
	}

	var Found = function Found(node, state) {
	  _classCallCheck(this, Found);

	  this.node = node;this.state = state;
	}

	// Find a node with a given start, end, and type (all are optional,
	// null can be used as wildcard). Returns a {node, state} object, or
	// undefined when it doesn't find a matching node.
	;

	function findNodeAt(node, start, end, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      var type = override || node.type;
	      if ((start == null || node.start <= start) && (end == null || node.end >= end)) base[type](node, st, c);
	      if ((start == null || node.start == start) && (end == null || node.end == end) && test(type, node)) throw new Found(node, st);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) return e;
	    throw e;
	  }
	}

	// Find the innermost node of a given type that contains the given
	// position. Interface similar to findNodeAt.

	function findNodeAround(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      var type = override || node.type;
	      if (node.start > pos || node.end < pos) return;
	      base[type](node, st, c);
	      if (test(type, node)) throw new Found(node, st);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) return e;
	    throw e;
	  }
	}

	// Find the outermost matching node after a given position.

	function findNodeAfter(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  try {
	    ;(function c(node, st, override) {
	      if (node.end < pos) return;
	      var type = override || node.type;
	      if (node.start >= pos && test(type, node)) throw new Found(node, st);
	      base[type](node, st, c);
	    })(node, state);
	  } catch (e) {
	    if (e instanceof Found) return e;
	    throw e;
	  }
	}

	// Find the outermost matching node before a given position.

	function findNodeBefore(node, pos, test, base, state) {
	  test = makeTest(test);
	  if (!base) base = exports.base;
	  var max = undefined;(function c(node, st, override) {
	    if (node.start > pos) return;
	    var type = override || node.type;
	    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) max = new Found(node, st);
	    base[type](node, st, c);
	  })(node, state);
	  return max;
	}

	// Used to create a custom walker. Will fill in all missing node
	// type properties with the defaults.

	function make(funcs, base) {
	  if (!base) base = exports.base;
	  var visitor = {};
	  for (var type in base) visitor[type] = base[type];
	  for (var type in funcs) visitor[type] = funcs[type];
	  return visitor;
	}

	function skipThrough(node, st, c) {
	  c(node, st);
	}
	function ignore(_node, _st, _c) {}

	// Node walkers.

	var base = {};

	exports.base = base;
	base.Program = base.BlockStatement = function (node, st, c) {
	  for (var i = 0; i < node.body.length; ++i) {
	    c(node.body[i], st, "Statement");
	  }
	};
	base.Statement = skipThrough;
	base.EmptyStatement = ignore;
	base.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {
	  return c(node.expression, st, "Expression");
	};
	base.IfStatement = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.consequent, st, "Statement");
	  if (node.alternate) c(node.alternate, st, "Statement");
	};
	base.LabeledStatement = function (node, st, c) {
	  return c(node.body, st, "Statement");
	};
	base.BreakStatement = base.ContinueStatement = ignore;
	base.WithStatement = function (node, st, c) {
	  c(node.object, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.SwitchStatement = function (node, st, c) {
	  c(node.discriminant, st, "Expression");
	  for (var i = 0; i < node.cases.length; ++i) {
	    var cs = node.cases[i];
	    if (cs.test) c(cs.test, st, "Expression");
	    for (var j = 0; j < cs.consequent.length; ++j) {
	      c(cs.consequent[j], st, "Statement");
	    }
	  }
	};
	base.ReturnStatement = base.YieldExpression = function (node, st, c) {
	  if (node.argument) c(node.argument, st, "Expression");
	};
	base.ThrowStatement = base.SpreadElement = function (node, st, c) {
	  return c(node.argument, st, "Expression");
	};
	base.TryStatement = function (node, st, c) {
	  c(node.block, st, "Statement");
	  if (node.handler) {
	    c(node.handler.param, st, "Pattern");
	    c(node.handler.body, st, "ScopeBody");
	  }
	  if (node.finalizer) c(node.finalizer, st, "Statement");
	};
	base.WhileStatement = base.DoWhileStatement = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForStatement = function (node, st, c) {
	  if (node.init) c(node.init, st, "ForInit");
	  if (node.test) c(node.test, st, "Expression");
	  if (node.update) c(node.update, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForInStatement = base.ForOfStatement = function (node, st, c) {
	  c(node.left, st, "ForInit");
	  c(node.right, st, "Expression");
	  c(node.body, st, "Statement");
	};
	base.ForInit = function (node, st, c) {
	  if (node.type == "VariableDeclaration") c(node, st);else c(node, st, "Expression");
	};
	base.DebuggerStatement = ignore;

	base.FunctionDeclaration = function (node, st, c) {
	  return c(node, st, "Function");
	};
	base.VariableDeclaration = function (node, st, c) {
	  for (var i = 0; i < node.declarations.length; ++i) {
	    c(node.declarations[i], st);
	  }
	};
	base.VariableDeclarator = function (node, st, c) {
	  c(node.id, st, "Pattern");
	  if (node.init) c(node.init, st, "Expression");
	};

	base.Function = function (node, st, c) {
	  if (node.id) c(node.id, st, "Pattern");
	  for (var i = 0; i < node.params.length; i++) {
	    c(node.params[i], st, "Pattern");
	  }c(node.body, st, node.expression ? "ScopeExpression" : "ScopeBody");
	};
	// FIXME drop these node types in next major version
	// (They are awkward, and in ES6 every block can be a scope.)
	base.ScopeBody = function (node, st, c) {
	  return c(node, st, "Statement");
	};
	base.ScopeExpression = function (node, st, c) {
	  return c(node, st, "Expression");
	};

	base.Pattern = function (node, st, c) {
	  if (node.type == "Identifier") c(node, st, "VariablePattern");else if (node.type == "MemberExpression") c(node, st, "MemberPattern");else c(node, st);
	};
	base.VariablePattern = ignore;
	base.MemberPattern = skipThrough;
	base.RestElement = function (node, st, c) {
	  return c(node.argument, st, "Pattern");
	};
	base.ArrayPattern = function (node, st, c) {
	  for (var i = 0; i < node.elements.length; ++i) {
	    var elt = node.elements[i];
	    if (elt) c(elt, st, "Pattern");
	  }
	};
	base.ObjectPattern = function (node, st, c) {
	  for (var i = 0; i < node.properties.length; ++i) {
	    c(node.properties[i].value, st, "Pattern");
	  }
	};

	base.Expression = skipThrough;
	base.ThisExpression = base.Super = base.MetaProperty = ignore;
	base.ArrayExpression = function (node, st, c) {
	  for (var i = 0; i < node.elements.length; ++i) {
	    var elt = node.elements[i];
	    if (elt) c(elt, st, "Expression");
	  }
	};
	base.ObjectExpression = function (node, st, c) {
	  for (var i = 0; i < node.properties.length; ++i) {
	    c(node.properties[i], st);
	  }
	};
	base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
	base.SequenceExpression = base.TemplateLiteral = function (node, st, c) {
	  for (var i = 0; i < node.expressions.length; ++i) {
	    c(node.expressions[i], st, "Expression");
	  }
	};
	base.UnaryExpression = base.UpdateExpression = function (node, st, c) {
	  c(node.argument, st, "Expression");
	};
	base.BinaryExpression = base.LogicalExpression = function (node, st, c) {
	  c(node.left, st, "Expression");
	  c(node.right, st, "Expression");
	};
	base.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {
	  c(node.left, st, "Pattern");
	  c(node.right, st, "Expression");
	};
	base.ConditionalExpression = function (node, st, c) {
	  c(node.test, st, "Expression");
	  c(node.consequent, st, "Expression");
	  c(node.alternate, st, "Expression");
	};
	base.NewExpression = base.CallExpression = function (node, st, c) {
	  c(node.callee, st, "Expression");
	  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i) {
	    c(node.arguments[i], st, "Expression");
	  }
	};
	base.MemberExpression = function (node, st, c) {
	  c(node.object, st, "Expression");
	  if (node.computed) c(node.property, st, "Expression");
	};
	base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {
	  if (node.declaration) c(node.declaration, st, node.type == "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
	  if (node.source) c(node.source, st, "Expression");
	};
	base.ExportAllDeclaration = function (node, st, c) {
	  c(node.source, st, "Expression");
	};
	base.ImportDeclaration = function (node, st, c) {
	  for (var i = 0; i < node.specifiers.length; i++) {
	    c(node.specifiers[i], st);
	  }c(node.source, st, "Expression");
	};
	base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;

	base.TaggedTemplateExpression = function (node, st, c) {
	  c(node.tag, st, "Expression");
	  c(node.quasi, st);
	};
	base.ClassDeclaration = base.ClassExpression = function (node, st, c) {
	  return c(node, st, "Class");
	};
	base.Class = function (node, st, c) {
	  if (node.id) c(node.id, st, "Pattern");
	  if (node.superClass) c(node.superClass, st, "Expression");
	  for (var i = 0; i < node.body.body.length; i++) {
	    c(node.body.body[i], st);
	  }
	};
	base.MethodDefinition = base.Property = function (node, st, c) {
	  if (node.computed) c(node.key, st, "Expression");
	  c(node.value, st, "Expression");
	};
	base.ComprehensionExpression = function (node, st, c) {
	  for (var i = 0; i < node.blocks.length; i++) {
	    c(node.blocks[i].right, st, "Expression");
	  }c(node.body, st, "Expression");
	};

	},{}]},{},[1])(1)
	});

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	// Type description parser
	//
	// Type description JSON files (such as ecma5.json and browser.json)
	// are used to
	//
	// A) describe types that come from native code
	//
	// B) to cheaply load the types for big libraries, or libraries that
	//    can't be inferred well

	(function(mod) {
	  if (true) // CommonJS
	    return exports.init = mod;
	  if (true) // AMD
	    return !(module.exports = {init: mod});
	  tern.def = {init: mod};
	})(function(exports, infer) {
	  "use strict";

	  function hop(obj, prop) {
	    return Object.prototype.hasOwnProperty.call(obj, prop);
	  }

	  var TypeParser = exports.TypeParser = function(spec, start, base, forceNew) {
	    this.pos = start || 0;
	    this.spec = spec;
	    this.base = base;
	    this.forceNew = forceNew;
	  };

	  function unwrapType(type, self, args) {
	    return type.call ? type(self, args) : type;
	  }

	  function extractProp(type, prop) {
	    if (prop == "!ret") {
	      if (type.retval) return type.retval;
	      var rv = new infer.AVal;
	      type.propagate(new infer.IsCallee(infer.ANull, [], null, rv));
	      return rv;
	    } else {
	      return type.getProp(prop);
	    }
	  }

	  function computedFunc(name, args, retType, generator) {
	    return function(self, cArgs) {
	      var realArgs = [];
	      for (var i = 0; i < args.length; i++) realArgs.push(unwrapType(args[i], self, cArgs));
	      return new infer.Fn(name, infer.ANull, realArgs, unwrapType(retType, self, cArgs), generator);
	    };
	  }
	  function computedUnion(types) {
	    return function(self, args) {
	      var union = new infer.AVal;
	      for (var i = 0; i < types.length; i++) unwrapType(types[i], self, args).propagate(union);
	      union.maxWeight = 1e5;
	      return union;
	    };
	  }
	  function computedArray(inner) {
	    return function(self, args) {
	      return new infer.Arr(inner(self, args));
	    };
	  }
	  function computedTuple(types) {
	    return function(self, args) {
	      return new infer.Arr(types.map(function(tp) { return unwrapType(tp, self, args) }))
	    }
	  }

	  TypeParser.prototype = {
	    eat: function(str) {
	      if (str.length == 1 ? this.spec.charAt(this.pos) == str : this.spec.indexOf(str, this.pos) == this.pos) {
	        this.pos += str.length;
	        return true;
	      }
	    },
	    word: function(re) {
	      var word = "", ch, re = re || /[\w$]/;
	      while ((ch = this.spec.charAt(this.pos)) && re.test(ch)) { word += ch; ++this.pos; }
	      return word;
	    },
	    error: function() {
	      throw new Error("Unrecognized type spec: " + this.spec + " (at " + this.pos + ")");
	    },
	    parseFnType: function(comp, name, top, generator) {
	      var args = [], names = [], computed = false;
	      if (!this.eat(")")) for (var i = 0; ; ++i) {
	        var colon = this.spec.indexOf(": ", this.pos), argname;
	        if (colon != -1) {
	          argname = this.spec.slice(this.pos, colon);
	          if (/^[$\w?]+$/.test(argname))
	            this.pos = colon + 2;
	          else
	            argname = null;
	        }
	        names.push(argname);
	        var argType = this.parseType(comp);
	        if (argType.call) computed = true;
	        args.push(argType);
	        if (!this.eat(", ")) {
	          this.eat(")") || this.error();
	          break;
	        }
	      }
	      var retType, computeRet, computeRetStart, fn;
	      if (this.eat(" -> ")) {
	        var retStart = this.pos;
	        retType = this.parseType(true);
	        if (retType.call && !computed) {
	          computeRet = retType;
	          retType = infer.ANull;
	          computeRetStart = retStart;
	        }
	      } else {
	        retType = infer.ANull;
	      }
	      if (computed) return computedFunc(name, args, retType, generator);

	      if (top && (fn = this.base))
	        infer.Fn.call(this.base, name, infer.ANull, args, names, retType, generator);
	      else
	        fn = new infer.Fn(name, infer.ANull, args, names, retType, generator);
	      if (computeRet) fn.computeRet = computeRet;
	      if (computeRetStart != null) fn.computeRetSource = this.spec.slice(computeRetStart, this.pos);
	      return fn;
	    },
	    parseType: function(comp, name, top) {
	      var main = this.parseTypeMaybeProp(comp, name, top);
	      if (!this.eat("|")) return main;
	      var types = [main], computed = main.call;
	      for (;;) {
	        var next = this.parseTypeMaybeProp(comp, name, top);
	        types.push(next);
	        if (next.call) computed = true;
	        if (!this.eat("|")) break;
	      }
	      if (computed) return computedUnion(types);
	      var union = new infer.AVal;
	      for (var i = 0; i < types.length; i++) types[i].propagate(union);
	      union.maxWeight = 1e5;
	      return union;
	    },
	    parseTypeMaybeProp: function(comp, name, top) {
	      var result = this.parseTypeInner(comp, name, top);
	      while (comp && this.eat(".")) result = this.extendWithProp(result);
	      return result;
	    },
	    extendWithProp: function(base) {
	      var propName = this.word(/[\w<>$!:]/) || this.error();
	      if (base.apply) return function(self, args) {
	        return extractProp(base(self, args), propName);
	      };
	      return extractProp(base, propName);
	    },
	    parseTypeInner: function(comp, name, top) {
	      var gen
	      if (this.eat("fn(") || (gen = this.eat("fn*("))) {
	        return this.parseFnType(comp, name, top, gen);
	      } else if (this.eat("[")) {
	        var inner = this.parseType(comp), types, computed = inner.call
	        while (this.eat(", ")) {
	          if (!types) types = [inner]
	          var next = this.parseType(comp)
	          types.push(next)
	          computed = computed || next.call
	        }
	        this.eat("]") || this.error()
	        if (computed) return types ? computedTuple(types) : computedArray(inner)
	        if (top && this.base) {
	          infer.Arr.call(this.base, types || inner)
	          return this.base
	        }
	        return new infer.Arr(types || inner)
	      } else if (this.eat("+")) {
	        var path = this.word(/[\w$<>\.:!]/)
	        var base = infer.cx().localDefs[path + ".prototype"]
	        if (!base) {
	          var base = parsePath(path);
	          if (!(base instanceof infer.Obj)) return base;
	          var proto = descendProps(base, ["prototype"])
	          if (proto && (proto = proto.getObjType()))
	            base = proto
	        }
	        if (comp && this.eat("[")) return this.parsePoly(base);
	        if (top && this.forceNew) return new infer.Obj(base);
	        return infer.getInstance(base);
	      } else if (this.eat(":")) {
	        var name = this.word(/[\w$\.]/)
	        return infer.getSymbol(name)
	      } else if (comp && this.eat("!")) {
	        var arg = this.word(/\d/);
	        if (arg) {
	          arg = Number(arg);
	          return function(_self, args) {return args[arg] || infer.ANull;};
	        } else if (this.eat("this")) {
	          return function(self) {return self;};
	        } else if (this.eat("custom:")) {
	          var fname = this.word(/[\w$]/);
	          return customFunctions[fname] || function() { return infer.ANull; };
	        } else {
	          return this.fromWord("!" + this.word(/[\w$<>\.!:]/));
	        }
	      } else if (this.eat("?")) {
	        return infer.ANull;
	      } else {
	        return this.fromWord(this.word(/[\w$<>\.!:`]/));
	      }
	    },
	    fromWord: function(spec) {
	      var cx = infer.cx();
	      switch (spec) {
	      case "number": return cx.num;
	      case "string": return cx.str;
	      case "bool": return cx.bool;
	      case "<top>": return cx.topScope;
	      }
	      if (cx.localDefs && spec in cx.localDefs) return cx.localDefs[spec];
	      return parsePath(spec);
	    },
	    parsePoly: function(base) {
	      var propName = "<i>", match;
	      if (match = this.spec.slice(this.pos).match(/^\s*([\w$:]+)\s*=\s*/)) {
	        propName = match[1];
	        this.pos += match[0].length;
	      }
	      var value = this.parseType(true);
	      if (!this.eat("]")) this.error();
	      if (value.call) return function(self, args) {
	        var instance = new infer.Obj(base);
	        value(self, args).propagate(instance.defProp(propName));
	        return instance;
	      };
	      var instance = new infer.Obj(base);
	      value.propagate(instance.defProp(propName));
	      return instance;
	    }
	  };

	  function parseType(spec, name, base, forceNew) {
	    var type = new TypeParser(spec, null, base, forceNew).parseType(false, name, true);
	    if (/^fn\(/.test(spec)) for (var i = 0; i < type.args.length; ++i) (function(i) {
	      var arg = type.args[i];
	      if (arg instanceof infer.Fn && arg.args && arg.args.length) addEffect(type, function(_self, fArgs) {
	        var fArg = fArgs[i];
	        if (fArg) fArg.propagate(new infer.IsCallee(infer.cx().topScope, arg.args, null, infer.ANull));
	      });
	    })(i);
	    return type;
	  }

	  function addEffect(fn, handler, replaceRet) {
	    var oldCmp = fn.computeRet, rv = fn.retval;
	    fn.computeRet = function(self, args, argNodes) {
	      var handled = handler(self, args, argNodes);
	      var old = oldCmp ? oldCmp(self, args, argNodes) : rv;
	      return replaceRet ? handled : old;
	    };
	  }

	  var parseEffect = exports.parseEffect = function(effect, fn) {
	    var m;
	    if (effect.indexOf("propagate ") == 0) {
	      var p = new TypeParser(effect, 10);
	      var origin = p.parseType(true);
	      if (!p.eat(" ")) p.error();
	      var target = p.parseType(true);
	      addEffect(fn, function(self, args) {
	        unwrapType(origin, self, args).propagate(unwrapType(target, self, args));
	      });
	    } else if (effect.indexOf("call ") == 0) {
	      var andRet = effect.indexOf("and return ", 5) == 5;
	      var p = new TypeParser(effect, andRet ? 16 : 5);
	      var getCallee = p.parseType(true), getSelf = null, getArgs = [];
	      if (p.eat(" this=")) getSelf = p.parseType(true);
	      while (p.eat(" ")) getArgs.push(p.parseType(true));
	      addEffect(fn, function(self, args) {
	        var callee = unwrapType(getCallee, self, args);
	        var slf = getSelf ? unwrapType(getSelf, self, args) : infer.ANull, as = [];
	        for (var i = 0; i < getArgs.length; ++i) as.push(unwrapType(getArgs[i], self, args));
	        var result = andRet ? new infer.AVal : infer.ANull;
	        callee.propagate(new infer.IsCallee(slf, as, null, result));
	        return result;
	      }, andRet);
	    } else if (m = effect.match(/^custom (\S+)\s*(.*)/)) {
	      var customFunc = customFunctions[m[1]];
	      if (customFunc) addEffect(fn, m[2] ? customFunc(m[2]) : customFunc);
	    } else if (effect.indexOf("copy ") == 0) {
	      var p = new TypeParser(effect, 5);
	      var getFrom = p.parseType(true);
	      p.eat(" ");
	      var getTo = p.parseType(true);
	      addEffect(fn, function(self, args) {
	        var from = unwrapType(getFrom, self, args), to = unwrapType(getTo, self, args);
	        from.forAllProps(function(prop, val, local) {
	          if (local && prop != "<i>")
	            to.propagate(new infer.DefProp(prop, val));
	        });
	      });
	    } else {
	      throw new Error("Unknown effect type: " + effect);
	    }
	  };

	  var currentTopScope;

	  var parsePath = exports.parsePath = function(path, scope) {
	    var cx = infer.cx(), cached = cx.paths[path], origPath = path;
	    if (cached != null) return cached;
	    cx.paths[path] = infer.ANull;

	    var base = scope || currentTopScope || cx.topScope;

	    if (cx.localDefs) for (var name in cx.localDefs) {
	      if (path.indexOf(name) == 0) {
	        if (path == name) return cx.paths[path] = cx.localDefs[path];
	        if (path.charAt(name.length) == ".") {
	          base = cx.localDefs[name];
	          path = path.slice(name.length + 1);
	          break;
	        }
	      }
	    }

	    var result = descendProps(base, path.split("."))
	    // Uncomment this to get feedback on your poorly written .json files
	    // if (result == infer.ANull) console.error("bad path: " + origPath + " (" + cx.curOrigin + ")")
	    cx.paths[origPath] = result == infer.ANull ? null : result
	    return result
	  }

	  function descendProps(base, parts) {
	    for (var i = 0; i < parts.length && base != infer.ANull; ++i) {
	      var prop = parts[i];
	      if (prop.charAt(0) == "!") {
	        if (prop == "!proto") {
	          base = (base instanceof infer.Obj && base.proto) || infer.ANull;
	        } else {
	          var fn = base.getFunctionType();
	          if (!fn) {
	            base = infer.ANull;
	          } else if (prop == "!ret") {
	            base = fn.retval && fn.retval.getType(false) || infer.ANull;
	          } else {
	            var arg = fn.args && fn.args[Number(prop.slice(1))];
	            base = (arg && arg.getType(false)) || infer.ANull;
	          }
	        }
	      } else if (base instanceof infer.Obj) {
	        var propVal = (prop == "prototype" && base instanceof infer.Fn) ? base.getProp(prop) : base.props[prop];
	        if (!propVal || propVal.isEmpty())
	          base = infer.ANull;
	        else
	          base = propVal.types[0];
	      }
	    }
	    return base;
	  }

	  function emptyObj(ctor) {
	    var empty = Object.create(ctor.prototype);
	    empty.props = Object.create(null);
	    empty.isShell = true;
	    return empty;
	  }

	  function isSimpleAnnotation(spec) {
	    if (!spec["!type"] || /^(fn\(|\[)/.test(spec["!type"])) return false;
	    for (var prop in spec)
	      if (prop != "!type" && prop != "!doc" && prop != "!url" && prop != "!span" && prop != "!data")
	        return false;
	    return true;
	  }

	  function passOne(base, spec, path) {
	    if (!base) {
	      var tp = spec["!type"];
	      if (tp) {
	        if (/^fn\(/.test(tp)) base = emptyObj(infer.Fn);
	        else if (tp.charAt(0) == "[") base = emptyObj(infer.Arr);
	        else throw new Error("Invalid !type spec: " + tp);
	      } else if (spec["!stdProto"]) {
	        base = infer.cx().protos[spec["!stdProto"]];
	      } else {
	        base = emptyObj(infer.Obj);
	      }
	      base.name = path;
	    }

	    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
	      var inner = spec[name];
	      if (typeof inner == "string" || isSimpleAnnotation(inner)) continue;
	      var prop = base.defProp(name);
	      passOne(prop.getObjType(), inner, path ? path + "." + name : name).propagate(prop);
	    }
	    return base;
	  }

	  function passTwo(base, spec, path) {
	    if (base.isShell) {
	      delete base.isShell;
	      var tp = spec["!type"];
	      if (tp) {
	        parseType(tp, path, base);
	      } else {
	        var proto = spec["!proto"] && parseType(spec["!proto"]);
	        infer.Obj.call(base, proto instanceof infer.Obj ? proto : true, path);
	      }
	    }

	    var effects = spec["!effects"];
	    if (effects && base instanceof infer.Fn) for (var i = 0; i < effects.length; ++i)
	      parseEffect(effects[i], base);
	    copyInfo(spec, base);

	    for (var name in spec) if (hop(spec, name) && name.charCodeAt(0) != 33) {
	      var inner = spec[name], known = base.defProp(name), innerPath = path ? path + "." + name : name;
	      if (typeof inner == "string") {
	        if (known.isEmpty()) parseType(inner, innerPath).propagate(known);
	      } else {
	        if (!isSimpleAnnotation(inner))
	          passTwo(known.getObjType(), inner, innerPath);
	        else if (known.isEmpty())
	          parseType(inner["!type"], innerPath, null, true).propagate(known);
	        else
	          continue;
	        if (inner["!doc"]) known.doc = inner["!doc"];
	        if (inner["!url"]) known.url = inner["!url"];
	        if (inner["!span"]) known.span = inner["!span"];
	      }
	    }
	    return base;
	  }

	  function copyInfo(spec, type) {
	    if (spec["!doc"]) type.doc = spec["!doc"];
	    if (spec["!url"]) type.url = spec["!url"];
	    if (spec["!span"]) type.span = spec["!span"];
	    if (spec["!data"]) type.metaData = spec["!data"];
	  }

	  function doLoadEnvironment(data, scope) {
	    var cx = infer.cx(), server = cx.parent

	    infer.addOrigin(cx.curOrigin = data["!name"] || "env#" + cx.origins.length);
	    cx.localDefs = cx.definitions[cx.curOrigin] = Object.create(null);

	    if (server) server.signal("preLoadDef", data)

	    passOne(scope, data);

	    var def = data["!define"];
	    if (def) {
	      for (var name in def) {
	        var spec = def[name];
	        cx.localDefs[name] = typeof spec == "string" ? parsePath(spec) : passOne(null, spec, name);
	      }
	      for (var name in def) {
	        var spec = def[name];
	        if (typeof spec != "string") passTwo(cx.localDefs[name], def[name], name);
	      }
	    }

	    passTwo(scope, data);

	    if (server) server.signal("postLoadDef", data)

	    cx.curOrigin = cx.localDefs = null;
	  }

	  exports.load = function(data, scope) {
	    if (!scope) scope = infer.cx().topScope;
	    var oldScope = currentTopScope;
	    currentTopScope = scope;
	    try {
	      doLoadEnvironment(data, scope);
	    } finally {
	      currentTopScope = oldScope;
	    }
	  };

	  exports.parse = function(data, origin, path) {
	    var cx = infer.cx();
	    if (origin) {
	      cx.origin = origin;
	      cx.localDefs = cx.definitions[origin];
	    }

	    try {
	      if (typeof data == "string")
	        return parseType(data, path);
	      else
	        return passTwo(passOne(null, data, path), data, path);
	    } finally {
	      if (origin) cx.origin = cx.localDefs = null;
	    }
	  };

	  // Used to register custom logic for more involved effect or type
	  // computation.
	  var customFunctions = Object.create(null);
	  infer.registerFunction = function(name, f) { customFunctions[name] = f; };

	  var IsCreated = infer.constraint({
	    construct: function(created, target, spec) {
	      this.created = created;
	      this.target = target;
	      this.spec = spec;
	    },
	    addType: function(tp) {
	      if (tp instanceof infer.Obj && this.created++ < 5) {
	        var derived = new infer.Obj(tp), spec = this.spec;
	        if (spec instanceof infer.AVal) spec = spec.getObjType(false);
	        if (spec instanceof infer.Obj) for (var prop in spec.props) {
	          var cur = spec.props[prop].types[0];
	          var p = derived.defProp(prop);
	          if (cur && cur instanceof infer.Obj && cur.props.value) {
	            var vtp = cur.props.value.getType(false);
	            if (vtp) p.addType(vtp);
	          }
	        }
	        this.target.addType(derived);
	      }
	    }
	  });

	  infer.registerFunction("Object_create", function(_self, args, argNodes) {
	    if (argNodes && argNodes.length && argNodes[0].type == "Literal" && argNodes[0].value == null)
	      return new infer.Obj();

	    var result = new infer.AVal;
	    if (args[0]) args[0].propagate(new IsCreated(0, result, args[1]));
	    return result;
	  });

	  var PropSpec = infer.constraint({
	    construct: function(target) { this.target = target; },
	    addType: function(tp) {
	      if (!(tp instanceof infer.Obj)) return;
	      if (tp.hasProp("value"))
	        tp.getProp("value").propagate(this.target);
	      else if (tp.hasProp("get"))
	        tp.getProp("get").propagate(new infer.IsCallee(infer.ANull, [], null, this.target));
	    }
	  });

	  infer.registerFunction("Object_defineProperty", function(_self, args, argNodes) {
	    if (argNodes && argNodes.length >= 3 && argNodes[1].type == "Literal" &&
	        typeof argNodes[1].value == "string") {
	      var obj = args[0], connect = new infer.AVal;
	      obj.propagate(new infer.DefProp(argNodes[1].value, connect, argNodes[1]));
	      args[2].propagate(new PropSpec(connect));
	    }
	    return infer.ANull;
	  });

	  infer.registerFunction("Object_defineProperties", function(_self, args, argNodes) {
	    if (args.length >= 2) {
	      var obj = args[0];
	      args[1].forAllProps(function(prop, val, local) {
	        if (!local) return;
	        var connect = new infer.AVal;
	        obj.propagate(new infer.DefProp(prop, connect, argNodes && argNodes[1]));
	        val.propagate(new PropSpec(connect));
	      });
	    }
	    return infer.ANull;
	  });

	  var IsBound = infer.constraint({
	    construct: function(self, args, target) {
	      this.self = self; this.args = args; this.target = target;
	    },
	    addType: function(tp) {
	      if (!(tp instanceof infer.Fn)) return;
	      this.target.addType(new infer.Fn(tp.name, infer.ANull, tp.args.slice(this.args.length),
	                                       tp.argNames.slice(this.args.length), tp.retval, tp.generator));
	      this.self.propagate(tp.self);
	      for (var i = 0; i < Math.min(tp.args.length, this.args.length); ++i)
	        this.args[i].propagate(tp.args[i]);
	    }
	  });

	  infer.registerFunction("Function_bind", function(self, args) {
	    if (!args.length) return infer.ANull;
	    var result = new infer.AVal;
	    self.propagate(new IsBound(args[0], args.slice(1), result));
	    return result;
	  });

	  infer.registerFunction("Array_ctor", function(_self, args) {
	    var arr = new infer.Arr;
	    if (args.length != 1 || !args[0].hasType(infer.cx().num)) {
	      var content = arr.getProp("<i>");
	      for (var i = 0; i < args.length; ++i) args[i].propagate(content);
	    }
	    return arr;
	  });

	  infer.registerFunction("Promise_ctor", function(_self, args, argNodes) {
	    var defs6 = infer.cx().definitions.ecma6
	    if (!defs6 || args.length < 1) return infer.ANull;
	    var self = new infer.Obj(defs6["Promise.prototype"]);
	    var valProp = self.defProp(":t", argNodes && argNodes[0]);
	    var valArg = new infer.AVal;
	    valArg.propagate(valProp);
	    var exec = new infer.Fn("execute", infer.ANull, [valArg], ["value"], infer.ANull);
	    var reject = defs6.Promise_reject;
	    args[0].propagate(new infer.IsCallee(infer.ANull, [exec, reject], null, infer.ANull));
	    return self;
	  });

	  var PromiseResolvesTo = infer.constraint({
	    construct: function(output) { this.output = output; },
	    addType: function(tp) {
	      if (tp.constructor == infer.Obj && tp.name == "Promise" && tp.hasProp(":t"))
	        tp.getProp(":t").propagate(this.output);
	      else
	        tp.propagate(this.output);
	    }
	  });

	  var WG_PROMISE_KEEP_VALUE = 50;

	  infer.registerFunction("Promise_then", function(self, args, argNodes) {
	    var fn = args.length && args[0].getFunctionType();
	    var defs6 = infer.cx().definitions.ecma6
	    if (!fn || !defs6) return self;

	    var result = new infer.Obj(defs6["Promise.prototype"]);
	    var value = result.defProp(":t", argNodes && argNodes[0]), ty;
	    if (fn.retval.isEmpty() && (ty = self.getType()) instanceof infer.Obj && ty.hasProp(":t"))
	      ty.getProp(":t").propagate(value, WG_PROMISE_KEEP_VALUE);
	    fn.retval.propagate(new PromiseResolvesTo(value));
	    return result;
	  });

	  infer.registerFunction("getOwnPropertySymbols", function(_self, args) {
	    if (!args.length) return infer.ANull
	    var result = new infer.AVal
	    args[0].forAllProps(function(prop, _val, local) {
	      if (local && prop.charAt(0) == ":") result.addType(infer.getSymbol(prop.slice(1)))
	    })
	    return result
	  })

	  infer.registerFunction("getSymbol", function(_self, _args, argNodes) {
	    if (argNodes.length && argNodes[0].type == "Literal" && typeof argNodes[0].value == "string")
	      return infer.getSymbol(argNodes[0].value)
	    else
	      return infer.ANull
	  })

	  return exports;
	});


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, mod) {
	  if (true) // CommonJS
	    return mod(exports);
	  if (true) // AMD
	    return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (mod), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  mod((root.tern || (root.tern = {})).signal = {}); // Plain browser env
	})(this, function(exports) {

	  function on(type, f) {
	    var handlers = this._handlers || (this._handlers = Object.create(null));
	    (handlers[type] || (handlers[type] = [])).push(f);
	  }

	  function off(type, f) {
	    var arr = this._handlers && this._handlers[type];
	    if (arr) for (var i = 0; i < arr.length; ++i)
	      if (arr[i] == f) { arr.splice(i, 1); break; }
	  }

	  var noHandlers = []
	  function getHandlers(emitter, type) {
	    var arr = emitter._handlers && emitter._handlers[type];
	    return arr && arr.length ? arr.slice() : noHandlers
	  }

	  function signal(type, a1, a2, a3, a4) {
	    var arr = getHandlers(this, type)
	    for (var i = 0; i < arr.length; ++i) arr[i].call(this, a1, a2, a3, a4)
	  }

	  function signalReturnFirst(type, a1, a2, a3, a4) {
	    var arr = getHandlers(this, type)
	    for (var i = 0; i < arr.length; ++i) {
	      var result = arr[i].call(this, a1, a2, a3, a4)
	      if (result) return result
	    }
	  }

	  function hasHandler(type) {
	    var arr = this._handlers && this._handlers[type]
	    return arr && arr.length > 0 && arr
	  }

	  exports.mixin = function(obj) {
	    obj.on = on; obj.off = off;
	    obj.signal = signal;
	    obj.signalReturnFirst = signalReturnFirst;
	    obj.hasHandler = hasHandler;
	    return obj;
	  };
	});


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	const {LocalizationHelper} = __webpack_require__(56);
	const L10N = new LocalizationHelper("devtools/locale/inspector.properties");

	const Editor = __webpack_require__(219);
	const beautify = __webpack_require__(233);

	const XHTML_NS = "http://www.w3.org/1999/xhtml";
	const CONTAINER_WIDTH = 500;

	/**
	 * Set the content of a provided HTMLTooltip instance to display a list of event
	 * listeners, with their event type, capturing argument and a link to the code
	 * of the event handler.
	 *
	 * @param {HTMLTooltip} tooltip
	 *        The tooltip instance on which the event details content should be set
	 * @param {Array} eventListenerInfos
	 *        A list of event listeners
	 * @param {Toolbox} toolbox
	 *        Toolbox used to select debugger panel
	 */
	function setEventTooltip(tooltip, eventListenerInfos, toolbox) {
	  let eventTooltip = new EventTooltip(tooltip, eventListenerInfos, toolbox);
	  eventTooltip.init();
	}

	function EventTooltip(tooltip, eventListenerInfos, toolbox) {
	  this._tooltip = tooltip;
	  this._eventListenerInfos = eventListenerInfos;
	  this._toolbox = toolbox;
	  this._eventEditors = new WeakMap();

	  // Used in tests: add a reference to the EventTooltip instance on the HTMLTooltip.
	  this._tooltip.eventTooltip = this;

	  this._headerClicked = this._headerClicked.bind(this);
	  this._debugClicked = this._debugClicked.bind(this);
	  this.destroy = this.destroy.bind(this);
	}

	EventTooltip.prototype = {
	  init: function () {
	    let config = {
	      mode: Editor.modes.js,
	      lineNumbers: false,
	      lineWrapping: true,
	      readOnly: true,
	      styleActiveLine: true,
	      extraKeys: {},
	      theme: "mozilla markup-view"
	    };

	    let doc = this._tooltip.doc;
	    this.container = doc.createElementNS(XHTML_NS, "div");
	    this.container.className = "devtools-tooltip-events-container";

	    for (let listener of this._eventListenerInfos) {
	      let phase = listener.capturing ? "Capturing" : "Bubbling";
	      let level = listener.DOM0 ? "DOM0" : "DOM2";

	      // Header
	      let header = doc.createElementNS(XHTML_NS, "div");
	      header.className = "event-header devtools-toolbar";
	      this.container.appendChild(header);

	      if (!listener.hide.debugger) {
	        let debuggerIcon = doc.createElementNS(XHTML_NS, "img");
	        debuggerIcon.className = "event-tooltip-debugger-icon";
	        debuggerIcon.setAttribute("src",
	          "chrome://devtools/skin/images/tool-debugger.svg");
	        let openInDebugger = L10N.getStr("eventsTooltip.openInDebugger");
	        debuggerIcon.setAttribute("title", openInDebugger);
	        header.appendChild(debuggerIcon);
	      }

	      if (!listener.hide.type) {
	        let eventTypeLabel = doc.createElementNS(XHTML_NS, "span");
	        eventTypeLabel.className = "event-tooltip-event-type";
	        eventTypeLabel.textContent = listener.type;
	        eventTypeLabel.setAttribute("title", listener.type);
	        header.appendChild(eventTypeLabel);
	      }

	      if (!listener.hide.filename) {
	        let filename = doc.createElementNS(XHTML_NS, "span");
	        filename.className = "event-tooltip-filename devtools-monospace";
	        filename.textContent = listener.origin;
	        filename.setAttribute("title", listener.origin);
	        header.appendChild(filename);
	      }

	      let attributesContainer = doc.createElementNS(XHTML_NS, "div");
	      attributesContainer.className = "event-tooltip-attributes-container";
	      header.appendChild(attributesContainer);

	      if (!listener.hide.capturing) {
	        let attributesBox = doc.createElementNS(XHTML_NS, "div");
	        attributesBox.className = "event-tooltip-attributes-box";
	        attributesContainer.appendChild(attributesBox);

	        let capturing = doc.createElementNS(XHTML_NS, "span");
	        capturing.className = "event-tooltip-attributes";
	        capturing.textContent = phase;
	        capturing.setAttribute("title", phase);
	        attributesBox.appendChild(capturing);
	      }

	      if (listener.tags) {
	        for (let tag of listener.tags.split(",")) {
	          let attributesBox = doc.createElementNS(XHTML_NS, "div");
	          attributesBox.className = "event-tooltip-attributes-box";
	          attributesContainer.appendChild(attributesBox);

	          let tagBox = doc.createElementNS(XHTML_NS, "span");
	          tagBox.className = "event-tooltip-attributes";
	          tagBox.textContent = tag;
	          tagBox.setAttribute("title", tag);
	          attributesBox.appendChild(tagBox);
	        }
	      }

	      if (!listener.hide.dom0) {
	        let attributesBox = doc.createElementNS(XHTML_NS, "div");
	        attributesBox.className = "event-tooltip-attributes-box";
	        attributesContainer.appendChild(attributesBox);

	        let dom0 = doc.createElementNS(XHTML_NS, "span");
	        dom0.className = "event-tooltip-attributes";
	        dom0.textContent = level;
	        dom0.setAttribute("title", level);
	        attributesBox.appendChild(dom0);
	      }

	      // Content
	      let content = doc.createElementNS(XHTML_NS, "div");
	      let editor = new Editor(config);
	      this._eventEditors.set(content, {
	        editor: editor,
	        handler: listener.handler,
	        searchString: listener.searchString,
	        uri: listener.origin,
	        dom0: listener.DOM0,
	        appended: false
	      });

	      content.className = "event-tooltip-content-box";
	      this.container.appendChild(content);

	      this._addContentListeners(header);
	    }

	    this._tooltip.setContent(this.container, {width: CONTAINER_WIDTH});
	    this._tooltip.on("hidden", this.destroy);
	  },

	  _addContentListeners: function (header) {
	    header.addEventListener("click", this._headerClicked);
	  },

	  _headerClicked: function (event) {
	    if (event.target.classList.contains("event-tooltip-debugger-icon")) {
	      this._debugClicked(event);
	      event.stopPropagation();
	      return;
	    }

	    let doc = this._tooltip.doc;
	    let header = event.currentTarget;
	    let content = header.nextElementSibling;

	    if (content.hasAttribute("open")) {
	      content.removeAttribute("open");
	    } else {
	      let contentNodes = doc.querySelectorAll(".event-tooltip-content-box");

	      for (let node of contentNodes) {
	        if (node !== content) {
	          node.removeAttribute("open");
	        }
	      }

	      content.setAttribute("open", "");

	      let eventEditor = this._eventEditors.get(content);

	      if (eventEditor.appended) {
	        return;
	      }

	      let {editor, handler} = eventEditor;

	      let iframe = doc.createElementNS(XHTML_NS, "iframe");
	      iframe.setAttribute("style", "width: 100%; height: 100%; border-style: none;");

	      editor.appendTo(content, iframe).then(() => {
	        let tidied = beautify.js(handler, { "indent_size": 2 });
	        editor.setText(tidied);

	        eventEditor.appended = true;

	        let container = header.parentElement.getBoundingClientRect();
	        if (header.getBoundingClientRect().top < container.top) {
	          header.scrollIntoView(true);
	        } else if (content.getBoundingClientRect().bottom > container.bottom) {
	          content.scrollIntoView(false);
	        }

	        this._tooltip.emit("event-tooltip-ready");
	      });
	    }
	  },

	  _debugClicked: function (event) {
	    let header = event.currentTarget;
	    let content = header.nextElementSibling;

	    let {uri, searchString, dom0} = this._eventEditors.get(content);

	    if (uri && uri !== "?") {
	      // Save a copy of toolbox as it will be set to null when we hide the tooltip.
	      let toolbox = this._toolbox;

	      this._tooltip.hide();

	      uri = uri.replace(/"/g, "");

	      let showSource = ({ DebuggerView }) => {
	        let matches = uri.match(/(.*):(\d+$)/);
	        let line = 1;

	        if (matches) {
	          uri = matches[1];
	          line = matches[2];
	        }

	        let item = DebuggerView.Sources.getItemForAttachment(a => a.source.url === uri);
	        if (item) {
	          let actor = item.attachment.source.actor;
	          DebuggerView.setEditorLocation(
	            actor, line, {noDebug: true}
	          ).then(() => {
	            if (dom0) {
	              let text = DebuggerView.editor.getText();
	              let index = text.indexOf(searchString);
	              let lastIndex = text.lastIndexOf(searchString);

	              // To avoid confusion we only search for DOM0 event handlers when
	              // there is only one possible match in the file.
	              if (index !== -1 && index === lastIndex) {
	                text = text.substr(0, index);
	                let newlineMatches = text.match(/\n/g);

	                if (newlineMatches) {
	                  DebuggerView.editor.setCursor({
	                    line: newlineMatches.length
	                  });
	                }
	              }
	            }
	          });
	        }
	      };

	      let debuggerAlreadyOpen = toolbox.getPanel("jsdebugger");
	      toolbox.selectTool("jsdebugger").then(({ panelWin: dbg }) => {
	        if (debuggerAlreadyOpen) {
	          showSource(dbg);
	        } else {
	          dbg.once(dbg.EVENTS.SOURCES_ADDED, () => showSource(dbg));
	        }
	      });
	    }
	  },

	  destroy: function () {
	    if (this._tooltip) {
	      this._tooltip.off("hidden", this.destroy);

	      let boxes = this.container.querySelectorAll(".event-tooltip-content-box");

	      for (let box of boxes) {
	        let {editor} = this._eventEditors.get(box);
	        editor.destroy();
	      }

	      this._eventEditors = null;
	      this._tooltip.eventTooltip = null;
	    }

	    let headerNodes = this.container.querySelectorAll(".event-header");

	    for (let node of headerNodes) {
	      node.removeEventListener("click", this._headerClicked);
	    }

	    let sourceNodes = this.container.querySelectorAll(".event-tooltip-debugger-icon");
	    for (let node of sourceNodes) {
	      node.removeEventListener("click", this._debugClicked);
	    }

	    this._eventListenerInfos = this._toolbox = this._tooltip = null;
	  }
	};

	module.exports.setEventTooltip = setEventTooltip;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var { cssBeautify } = __webpack_require__(234);
	var { htmlBeautify } = __webpack_require__(235);
	var { jsBeautify } = __webpack_require__(236);

	exports.css = cssBeautify;
	exports.html = htmlBeautify;
	exports.js = jsBeautify;


/***/ },
/* 234 */
/***/ function(module, exports) {

	/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 CSS Beautifier
	---------------

	    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

	    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	        http://jsbeautifier.org/

	    Usage:
	        css_beautify(source_text);
	        css_beautify(source_text, options);

	    The options are (default in brackets):
	        indent_size (4)                   — indentation size,
	        indent_char (space)               — character to indent with,
	        selector_separator_newline (true) - separate selectors with newline or
	                                            not (e.g. "a,\nbr" or "a, br")
	        end_with_newline (false)          - end with a newline

	    e.g

	    css_beautify(css_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t',
	      'selector_separator': ' ',
	      'end_with_newline': false,
	    });
	*/

	// http://www.w3.org/TR/CSS21/syndata.html#tokenization
	// http://www.w3.org/TR/css3-syntax/

	(function () {
	    function css_beautify(source_text, options) {
	        options = options || {};
	        var indentSize = options.indent_size || 4;
	        var indentCharacter = options.indent_char || ' ';
	        var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;
	        var endWithNewline = (options.end_with_newline === undefined) ? false : options.end_with_newline;

	        // compatibility
	        if (typeof indentSize === "string") {
	            indentSize = parseInt(indentSize, 10);
	        }


	        // tokenizer
	        var whiteRe = /^\s+$/;
	        var wordRe = /[\w$\-_]/;

	        var pos = -1,
	            ch;

	        function next() {
	            ch = source_text.charAt(++pos);
	            return ch;
	        }

	        function peek() {
	            return source_text.charAt(pos + 1);
	        }

	        function eatString(endChar) {
	            var start = pos;
	            while (next()) {
	                if (ch === "\\") {
	                    next();
	                    next();
	                } else if (ch === endChar) {
	                    break;
	                } else if (ch === "\n") {
	                    break;
	                }
	            }
	            return source_text.substring(start, pos + 1);
	        }

	        function eatWhitespace() {
	            var start = pos;
	            while (whiteRe.test(peek())) {
	                pos++;
	            }
	            return pos !== start;
	        }

	        function skipWhitespace() {
	            var start = pos;
	            do {} while (whiteRe.test(next()));
	            return pos !== start + 1;
	        }

	        function eatComment(singleLine) {
	            var start = pos;
	            next();
	            while (next()) {
	                if (ch === "*" && peek() === "/") {
	                    pos++;
	                    break;
	                } else if (singleLine && ch === "\n") {
	                    break;
	                }
	            }

	            return source_text.substring(start, pos + 1);
	        }


	        function lookBack(str) {
	            return source_text.substring(pos - str.length, pos).toLowerCase() ===
	                str;
	        }

	        function isCommentOnLine() {
	            var endOfLine = source_text.indexOf('\n', pos);
	            if (endOfLine === -1) {
	                return false;
	            }
	            var restOfLine = source_text.substring(pos, endOfLine);
	            return restOfLine.indexOf('//') !== -1;
	        }

	        // printer
	        var indentString = source_text.match(/^[\r\n]*[\t ]*/)[0];
	        var singleIndent = new Array(indentSize + 1).join(indentCharacter);
	        var indentLevel = 0;
	        var nestedLevel = 0;

	        function indent() {
	            indentLevel++;
	            indentString += singleIndent;
	        }

	        function outdent() {
	            indentLevel--;
	            indentString = indentString.slice(0, -indentSize);
	        }

	        var print = {};
	        print["{"] = function (ch) {
	            print.singleSpace();
	            output.push(ch);
	            print.newLine();
	        };
	        print["}"] = function (ch) {
	            print.newLine();
	            output.push(ch);
	            print.newLine();
	        };

	        print._lastCharWhitespace = function () {
	            return whiteRe.test(output[output.length - 1]);
	        };

	        print.newLine = function (keepWhitespace) {
	            if (!keepWhitespace) {
	                while (print._lastCharWhitespace()) {
	                    output.pop();
	                }
	            }

	            if (output.length) {
	                output.push('\n');
	            }
	            if (indentString) {
	                output.push(indentString);
	            }
	        };
	        print.singleSpace = function () {
	            if (output.length && !print._lastCharWhitespace()) {
	                output.push(' ');
	            }
	        };
	        var output = [];
	        if (indentString) {
	            output.push(indentString);
	        }
	        /*_____________________--------------------_____________________*/

	        var insideRule = false;
	        var enteringConditionalGroup = false;

	        while (true) {
	            var isAfterSpace = skipWhitespace();

	            if (!ch) {
	                break;
	            } else if (ch === '/' && peek() === '*') { /* css comment */
	                print.newLine();
	                output.push(eatComment(), "\n", indentString);
	                var header = lookBack("");
	                if (header) {
	                    print.newLine();
	                }
	            } else if (ch === '/' && peek() === '/') { // single line comment
	                output.push(eatComment(true), indentString);
	            } else if (ch === '@') {
	                // strip trailing space, if present, for hash property checks
	                var atRule = eatString(" ").replace(/ $/, '');

	                // pass along the space we found as a separate item
	                output.push(atRule, ch);

	                // might be a nesting at-rule
	                if (atRule in css_beautify.NESTED_AT_RULE) {
	                    nestedLevel += 1;
	                    if (atRule in css_beautify.CONDITIONAL_GROUP_RULE) {
	                        enteringConditionalGroup = true;
	                    }
	                }
	            } else if (ch === '{') {
	                eatWhitespace();
	                if (peek() === '}') {
	                    next();
	                    output.push(" {}");
	                } else {
	                    indent();
	                    print["{"](ch);
	                    // when entering conditional groups, only rulesets are allowed
	                    if (enteringConditionalGroup) {
	                        enteringConditionalGroup = false;
	                        insideRule = (indentLevel > nestedLevel);
	                    } else {
	                        // otherwise, declarations are also allowed
	                        insideRule = (indentLevel >= nestedLevel);
	                    }
	                }
	            } else if (ch === '}') {
	                outdent();
	                print["}"](ch);
	                insideRule = false;
	                if (nestedLevel) {
	                    nestedLevel--;
	                }
	            } else if (ch === ":") {
	                eatWhitespace();
	                if (insideRule || enteringConditionalGroup) {
	                    // 'property: value' delimiter
	                    // which could be in a conditional group query
	                    output.push(ch, " ");
	                } else {
	                    if (peek() === ":") {
	                        // pseudo-element
	                        next();
	                        output.push("::");
	                    } else {
	                        // pseudo-class
	                        output.push(ch);
	                    }
	                }
	            } else if (ch === '"' || ch === '\'') {
	                output.push(eatString(ch));
	            } else if (ch === ';') {
	                if (isCommentOnLine()) {
	                    var beforeComment = eatString('/');
	                    var comment = eatComment(true);
	                    output.push(beforeComment, comment.substring(1, comment.length - 1), '\n', indentString);
	                } else {
	                    output.push(ch, '\n', indentString);
	                }
	            } else if (ch === '(') { // may be a url
	                if (lookBack("url")) {
	                    output.push(ch);
	                    eatWhitespace();
	                    if (next()) {
	                        if (ch !== ')' && ch !== '"' && ch !== '\'') {
	                            output.push(eatString(')'));
	                        } else {
	                            pos--;
	                        }
	                    }
	                } else {
	                    if (isAfterSpace) {
	                        print.singleSpace();
	                    }
	                    output.push(ch);
	                    eatWhitespace();
	                }
	            } else if (ch === ')') {
	                output.push(ch);
	            } else if (ch === ',') {
	                eatWhitespace();
	                output.push(ch);
	                if (!insideRule && selectorSeparatorNewline) {
	                    print.newLine();
	                } else {
	                    print.singleSpace();
	                }
	            } else if (ch === ']') {
	                output.push(ch);
	            } else if (ch === '[') {
	                if (isAfterSpace) {
	                    print.singleSpace();
	                }
	                output.push(ch);
	            } else if (ch === '=') { // no whitespace before or after
	                eatWhitespace();
	                output.push(ch);
	            } else {
	                if (isAfterSpace) {
	                    print.singleSpace();
	                }

	                output.push(ch);
	            }
	        }


	        var sweetCode = output.join('').replace(/[\n ]+$/, '');

	        // establish end_with_newline
	        var should = endWithNewline;
	        var actually = /\n$/.test(sweetCode);
	        if (should && !actually) {
	            sweetCode += "\n";
	        } else if (!should && actually) {
	            sweetCode = sweetCode.slice(0, -1);
	        }

	        return sweetCode;
	    }

	    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
	    css_beautify.NESTED_AT_RULE = {
	        "@page": true,
	        "@font-face": true,
	        "@keyframes": true,
	        // also in CONDITIONAL_GROUP_RULE below
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };
	    css_beautify.CONDITIONAL_GROUP_RULE = {
	        "@media": true,
	        "@supports": true,
	        "@document": true
	    };

	    exports.cssBeautify = css_beautify;
	}());


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */
	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.


	 Style HTML
	---------------

	  Written by Nochum Sossonko, (nsossonko@hotmail.com)

	  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>
	    http://jsbeautifier.org/

	  Usage:
	    style_html(html_source);

	    style_html(html_source, options);

	  The options are:
	    indent_inner_html (default false)  — indent <head> and <body> sections,
	    indent_size (default 4)          — indentation size,
	    indent_char (default space)      — character to indent with,
	    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.
	    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
	    indent_scripts (default normal)  - "keep"|"separate"|"normal"
	    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
	                                        Only works before elements, not inside tags or for text.
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
	    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}

	    e.g.

	    style_html(html_source, {
	      'indent_inner_html': false,
	      'indent_size': 2,
	      'indent_char': ' ',
	      'wrap_line_length': 78,
	      'brace_style': 'expand',
	      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u'],
	      'preserve_newlines': true,
	      'max_preserve_newlines': 5,
	      'indent_handlebars': false
	    });
	*/

	(function() {

	    function trim(s) {
	        return s.replace(/^\s+|\s+$/g, '');
	    }

	    function ltrim(s) {
	        return s.replace(/^\s+/g, '');
	    }

	    function style_html(html_source, options, js_beautify, css_beautify) {
	        //Wrapper function to invoke all the necessary constructors and deal with the output.

	        var multi_parser,
	            indent_inner_html,
	            indent_size,
	            indent_character,
	            wrap_line_length,
	            brace_style,
	            unformatted,
	            preserve_newlines,
	            max_preserve_newlines,
	            indent_handlebars;

	        options = options || {};

	        // backwards compatibility to 1.3.4
	        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&
	                (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {
	            options.wrap_line_length = options.max_char;
	        }

	        indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;
	        indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);
	        indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;
	        brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;
	        wrap_line_length =  parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);
	        unformatted = options.unformatted || ['a', 'span', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	        preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
	        max_preserve_newlines = preserve_newlines ?
	            (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10))
	            : 0;
	        indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;

	        function Parser() {

	            this.pos = 0; //Parser position
	            this.token = '';
	            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT
	            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values
	                parent: 'parent1',
	                parentcount: 1,
	                parent1: ''
	            };
	            this.tag_type = '';
	            this.token_text = this.last_token = this.last_text = this.token_type = '';
	            this.newlines = 0;
	            this.indent_content = indent_inner_html;

	            this.Utils = { //Uilities made available to the various functions
	                whitespace: "\n\r\t ".split(''),
	                single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML
	                extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them
	                in_array: function(what, arr) {
	                    for (var i = 0; i < arr.length; i++) {
	                        if (what === arr[i]) {
	                            return true;
	                        }
	                    }
	                    return false;
	                }
	            };

	            this.traverse_whitespace = function() {
	                var input_char = '';

	                input_char = this.input.charAt(this.pos);
	                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                    this.newlines = 0;
	                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (preserve_newlines && input_char === '\n' && this.newlines <= max_preserve_newlines) {
	                            this.newlines += 1;
	                        }

	                        this.pos++;
	                        input_char = this.input.charAt(this.pos);
	                    }
	                    return true;
	                }
	                return false;
	            };

	            this.get_content = function() { //function to capture regular content between tags

	                var input_char = '',
	                    content = [],
	                    space = false; //if a space is needed

	                while (this.input.charAt(this.pos) !== '<') {
	                    if (this.pos >= this.input.length) {
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    if (this.traverse_whitespace()) {
	                        if (content.length) {
	                            space = true;
	                        }
	                        continue; //don't want to insert unnecessary space
	                    }

	                    if (indent_handlebars) {
	                        // Handlebars parsing is complicated.
	                        // {{#foo}} and {{/foo}} are formatted tags.
	                        // {{something}} should get treated as content, except:
	                        // {{else}} specifically behaves like {{#if}} and {{/if}}
	                        var peek3 = this.input.substr(this.pos, 3);
	                        if (peek3 === '{{#' || peek3 === '{{/') {
	                            // These are tags and not content.
	                            break;
	                        } else if (this.input.substr(this.pos, 2) === '{{') {
	                            if (this.get_tag(true) === '{{else}}') {
	                                break;
	                            }
	                        }
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (space) {
	                        if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached
	                            this.print_newline(false, content);
	                            this.print_indentation(content);
	                        } else {
	                            this.line_char_count++;
	                            content.push(' ');
	                        }
	                        space = false;
	                    }
	                    this.line_char_count++;
	                    content.push(input_char); //letter at-a-time (or string) inserted to an array
	                }
	                return content.length ? content.join('') : '';
	            };

	            this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify
	                if (this.pos === this.input.length) {
	                    return ['', 'TK_EOF'];
	                }
	                var input_char = '';
	                var content = '';
	                var reg_match = new RegExp('</' + name + '\\s*>', 'igm');
	                reg_match.lastIndex = this.pos;
	                var reg_array = reg_match.exec(this.input);
	                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script
	                if (this.pos < end_script) { //get everything in between the script tags
	                    content = this.input.substring(this.pos, end_script);
	                    this.pos = end_script;
	                }
	                return content;
	            };

	            this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object
	                if (this.tags[tag + 'count']) { //check for the existence of this tag type
	                    this.tags[tag + 'count']++;
	                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                } else { //otherwise initialize this tag type
	                    this.tags[tag + 'count'] = 1;
	                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level
	                }
	                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)
	                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')
	            };

	            this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer
	                if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it
	                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.
	                    while (temp_parent) { //till we reach '' (the initial value);
	                        if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it
	                            break;
	                        }
	                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree
	                    }
	                    if (temp_parent) { //if we caught something
	                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly
	                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent
	                    }
	                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...
	                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself
	                    if (this.tags[tag + 'count'] === 1) {
	                        delete this.tags[tag + 'count'];
	                    } else {
	                        this.tags[tag + 'count']--;
	                    }
	                }
	            };

	            this.indent_to_tag = function(tag) {
	                // Match the indentation level to the last use of this tag, but don't remove it.
	                if (!this.tags[tag + 'count']) {
	                    return;
	                }
	                var temp_parent = this.tags.parent;
	                while (temp_parent) {
	                    if (tag + this.tags[tag + 'count'] === temp_parent) {
	                        break;
	                    }
	                    temp_parent = this.tags[temp_parent + 'parent'];
	                }
	                if (temp_parent) {
	                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];
	                }
	            };

	            this.get_tag = function(peek) { //function to get a full tag and parse its type
	                var input_char = '',
	                    content = [],
	                    comment = '',
	                    space = false,
	                    tag_start, tag_end,
	                    tag_start_char,
	                    orig_pos = this.pos,
	                    orig_line_char_count = this.line_char_count;

	                peek = peek !== undefined ? peek : false;

	                do {
	                    if (this.pos >= this.input.length) {
	                        if (peek) {
	                            this.pos = orig_pos;
	                            this.line_char_count = orig_line_char_count;
	                        }
	                        return content.length ? content.join('') : ['', 'TK_EOF'];
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space
	                        space = true;
	                        continue;
	                    }

	                    if (input_char === "'" || input_char === '"') {
	                        input_char += this.get_unformatted(input_char);
	                        space = true;

	                    }

	                    if (input_char === '=') { //no space before =
	                        space = false;
	                    }

	                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {
	                        //no space after = or before >
	                        if (this.line_char_count >= this.wrap_line_length) {
	                            this.print_newline(false, content);
	                            this.print_indentation(content);
	                        } else {
	                            content.push(' ');
	                            this.line_char_count++;
	                        }
	                        space = false;
	                    }

	                    if (indent_handlebars && tag_start_char === '<') {
	                        // When inside an angle-bracket tag, put spaces around
	                        // handlebars not inside of strings.
	                        if ((input_char + this.input.charAt(this.pos)) === '{{') {
	                            input_char += this.get_unformatted('}}');
	                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {
	                                input_char = ' ' + input_char;
	                            }
	                            space = true;
	                        }
	                    }

	                    if (input_char === '<' && !tag_start_char) {
	                        tag_start = this.pos - 1;
	                        tag_start_char = '<';
	                    }

	                    if (indent_handlebars && !tag_start_char) {
	                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] == '{') {
	                            if (input_char === '#' || input_char === '/') {
	                                tag_start = this.pos - 3;
	                            } else {
	                                tag_start = this.pos - 2;
	                            }
	                            tag_start_char = '{';
	                        }
	                    }

	                    this.line_char_count++;
	                    content.push(input_char); //inserts character at-a-time (or string)

	                    if (content[1] && content[1] === '!') { //if we're in a comment, do something special
	                        // We treat all comments as literals, even more than preformatted tags
	                        // we just look for the appropriate close tag
	                        content = [this.get_comment(tag_start)];
	                        break;
	                    }

	                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {
	                        break;
	                    }
	                } while (input_char !== '>');

	                var tag_complete = content.join('');
	                var tag_index;
	                var tag_offset;

	                if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends
	                    tag_index = tag_complete.indexOf(' ');
	                } else if (tag_complete[0] === '{') {
	                    tag_index = tag_complete.indexOf('}');
	                } else { //otherwise go with the tag ending
	                    tag_index = tag_complete.indexOf('>');
	                }
	                if (tag_complete[0] === '<' || !indent_handlebars) {
	                    tag_offset = 1;
	                } else {
	                    tag_offset = tag_complete[2] === '#' ? 3 : 2;
	                }
	                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();
	                if (tag_complete.charAt(tag_complete.length - 2) === '/' ||
	                    this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                    }
	                } else if (indent_handlebars && tag_complete[0] === '{' && tag_check === 'else') {
	                    if (!peek) {
	                        this.indent_to_tag('if');
	                        this.tag_type = 'HANDLEBARS_ELSE';
	                        this.indent_content = true;
	                        this.traverse_whitespace();
	                    }
	                } else if (tag_check === 'script' &&
	                    (tag_complete.search('type') === -1 ||
	                    (tag_complete.search('type') > -1 &&
	                    tag_complete.search(/\b(text|application)\/(x-)?(javascript|ecmascript|jscript|livescript)/) > -1))) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'SCRIPT';
	                    }
	                } else if (tag_check === 'style' &&
	                    (tag_complete.search('type') === -1 ||
	                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {
	                    if (!peek) {
	                        this.record_tag(tag_check);
	                        this.tag_type = 'STYLE';
	                    }
	                } else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the "unformatted" tags
	                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function
	                    content.push(comment);
	                    // Preserve collapsed whitespace either before or after this tag.
	                    if (tag_start > 0 && this.Utils.in_array(this.input.charAt(tag_start - 1), this.Utils.whitespace)) {
	                        content.splice(0, 0, this.input.charAt(tag_start - 1));
	                    }
	                    tag_end = this.pos - 1;
	                    if (this.Utils.in_array(this.input.charAt(tag_end + 1), this.Utils.whitespace)) {
	                        content.push(this.input.charAt(tag_end + 1));
	                    }
	                    this.tag_type = 'SINGLE';
	                } else if (tag_check.charAt(0) === '!') { //peek for <! comment
	                    // for comments content is already correct.
	                    if (!peek) {
	                        this.tag_type = 'SINGLE';
	                        this.traverse_whitespace();
	                    }
	                } else if (!peek) {
	                    if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending
	                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors
	                        this.tag_type = 'END';
	                        this.traverse_whitespace();
	                    } else { //otherwise it's a start-tag
	                        this.record_tag(tag_check); //push it on the tag stack
	                        if (tag_check.toLowerCase() !== 'html') {
	                            this.indent_content = true;
	                        }
	                        this.tag_type = 'START';

	                        // Allow preserving of newlines after a start tag
	                        this.traverse_whitespace();
	                    }
	                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line
	                        this.print_newline(false, this.output);
	                        if (this.output.length && this.output[this.output.length - 2] !== '\n') {
	                            this.print_newline(true, this.output);
	                        }
	                    }
	                }

	                if (peek) {
	                    this.pos = orig_pos;
	                    this.line_char_count = orig_line_char_count;
	                }

	                return content.join(''); //returns fully formatted tag
	            };

	            this.get_comment = function(start_pos) { //function to return comment content in its entirety
	                // this is will have very poor perf, but will work for now.
	                var comment = '',
	                    delimiter = '>',
	                    matched = false;

	                this.pos = start_pos;
	                input_char = this.input.charAt(this.pos);
	                this.pos++;

	                while (this.pos <= this.input.length) {
	                    comment += input_char;

	                    // only need to check for the delimiter if the last chars match
	                    if (comment[comment.length - 1] === delimiter[delimiter.length - 1] &&
	                        comment.indexOf(delimiter) !== -1) {
	                        break;
	                    }

	                    // only need to search for custom delimiter for the first few characters
	                    if (!matched && comment.length < 10) {
	                        if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment
	                            delimiter = '<![endif]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...
	                            delimiter = ']]>';
	                            matched = true;
	                        } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...
	                            delimiter = ']>';
	                            matched = true;
	                        } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...
	                            delimiter = '-->';
	                            matched = true;
	                        }
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;
	                }

	                return comment;
	            };

	            this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety

	                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {
	                    return '';
	                }
	                var input_char = '';
	                var content = '';
	                var min_index = 0;
	                var space = true;
	                do {

	                    if (this.pos >= this.input.length) {
	                        return content;
	                    }

	                    input_char = this.input.charAt(this.pos);
	                    this.pos++;

	                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {
	                        if (!space) {
	                            this.line_char_count--;
	                            continue;
	                        }
	                        if (input_char === '\n' || input_char === '\r') {
	                            content += '\n';
	                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'
	                for (var i=0; i<this.indent_level; i++) {
	                  content += this.indent_string;
	                }
	                space = false; //...and make sure other indentation is erased
	                */
	                            this.line_char_count = 0;
	                            continue;
	                        }
	                    }
	                    content += input_char;
	                    this.line_char_count++;
	                    space = true;

	                    if (indent_handlebars && input_char === '{' && content.length && content[content.length - 2] === '{') {
	                        // Handlebars expressions in strings should also be unformatted.
	                        content += this.get_unformatted('}}');
	                        // These expressions are opaque.  Ignore delimiters found in them.
	                        min_index = content.length;
	                    }
	                } while (content.toLowerCase().indexOf(delimiter, min_index) === -1);
	                return content;
	            };

	            this.get_token = function() { //initial handler for token-retrieval
	                var token;

	                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript
	                    var type = this.last_token.substr(7);
	                    token = this.get_contents_to(type);
	                    if (typeof token !== 'string') {
	                        return token;
	                    }
	                    return [token, 'TK_' + type];
	                }
	                if (this.current_mode === 'CONTENT') {
	                    token = this.get_content();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        return [token, 'TK_CONTENT'];
	                    }
	                }

	                if (this.current_mode === 'TAG') {
	                    token = this.get_tag();
	                    if (typeof token !== 'string') {
	                        return token;
	                    } else {
	                        var tag_name_type = 'TK_TAG_' + this.tag_type;
	                        return [token, tag_name_type];
	                    }
	                }
	            };

	            this.get_full_indent = function(level) {
	                level = this.indent_level + level || 0;
	                if (level < 1) {
	                    return '';
	                }

	                return Array(level + 1).join(this.indent_string);
	            };

	            this.is_unformatted = function(tag_check, unformatted) {
	                //is this an HTML5 block-level link?
	                if (!this.Utils.in_array(tag_check, unformatted)) {
	                    return false;
	                }

	                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {
	                    return true;
	                }

	                //at this point we have an  tag; is its first child something we want to remain
	                //unformatted?
	                var next_tag = this.get_tag(true /* peek. */ );

	                // test next_tag to see if it is just html tag (no external content)
	                var tag = (next_tag || "").match(/^\s*<\s*\/?([a-z]*)\s*[^>]*>\s*$/);

	                // if next_tag comes back but is not an isolated tag, then
	                // let's treat the 'a' tag as having content
	                // and respect the unformatted option
	                if (!tag || this.Utils.in_array(tag, unformatted)) {
	                    return true;
	                } else {
	                    return false;
	                }
	            };

	            this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions

	                this.input = js_source || ''; //gets the input for the Parser
	                this.output = [];
	                this.indent_character = indent_character;
	                this.indent_string = '';
	                this.indent_size = indent_size;
	                this.brace_style = brace_style;
	                this.indent_level = 0;
	                this.wrap_line_length = wrap_line_length;
	                this.line_char_count = 0; //count to see if wrap_line_length was exceeded

	                for (var i = 0; i < this.indent_size; i++) {
	                    this.indent_string += this.indent_character;
	                }

	                this.print_newline = function(force, arr) {
	                    this.line_char_count = 0;
	                    if (!arr || !arr.length) {
	                        return;
	                    }
	                    if (force || (arr[arr.length - 1] !== '\n')) { //we might want the extra line
	                        arr.push('\n');
	                    }
	                };

	                this.print_indentation = function(arr) {
	                    for (var i = 0; i < this.indent_level; i++) {
	                        arr.push(this.indent_string);
	                        this.line_char_count += this.indent_string.length;
	                    }
	                };

	                this.print_token = function(text) {
	                    if (text || text !== '') {
	                        if (this.output.length && this.output[this.output.length - 1] === '\n') {
	                            this.print_indentation(this.output);
	                            text = ltrim(text);
	                        }
	                    }
	                    this.print_token_raw(text);
	                };

	                this.print_token_raw = function(text) {
	                    if (text && text !== '') {
	                        if (text.length > 1 && text[text.length - 1] === '\n') {
	                            // unformatted tags can grab newlines as their last character
	                            this.output.push(text.slice(0, -1));
	                            this.print_newline(false, this.output);
	                        } else {
	                            this.output.push(text);
	                        }
	                    }

	                    for (var n = 0; n < this.newlines; n++) {
	                        this.print_newline(n > 0, this.output);
	                    }
	                    this.newlines = 0;
	                };

	                this.indent = function() {
	                    this.indent_level++;
	                };

	                this.unindent = function() {
	                    if (this.indent_level > 0) {
	                        this.indent_level--;
	                    }
	                };
	            };
	            return this;
	        }

	        /*_____________________--------------------_____________________*/

	        multi_parser = new Parser(); //wrapping functions Parser
	        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values

	        while (true) {
	            var t = multi_parser.get_token();
	            multi_parser.token_text = t[0];
	            multi_parser.token_type = t[1];

	            if (multi_parser.token_type === 'TK_EOF') {
	                break;
	            }

	            switch (multi_parser.token_type) {
	                case 'TK_TAG_START':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        multi_parser.indent();
	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_STYLE':
	                case 'TK_TAG_SCRIPT':
	                    multi_parser.print_newline(false, multi_parser.output);
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_END':
	                    //Print new line only if the tag has no content and has child
	                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {
	                        var tag_name = multi_parser.token_text.match(/\w+/)[0];
	                        var tag_extracted_from_last_output = null;
	                        if (multi_parser.output.length) {
	                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\s*(\w+)/);
	                        }
	                        if (tag_extracted_from_last_output === null ||
	                            tag_extracted_from_last_output[1] !== tag_name) {
	                            multi_parser.print_newline(false, multi_parser.output);
	                        }
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_SINGLE':
	                    // Don't add a newline before elements that should remain unformatted.
	                    var tag_check = multi_parser.token_text.match(/^\s*<([a-z]+)/i);
	                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {
	                        multi_parser.print_newline(false, multi_parser.output);
	                    }
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_TAG_HANDLEBARS_ELSE':
	                    multi_parser.print_token(multi_parser.token_text);
	                    if (multi_parser.indent_content) {
	                        multi_parser.indent();
	                        multi_parser.indent_content = false;
	                    }
	                    multi_parser.current_mode = 'CONTENT';
	                    break;
	                case 'TK_CONTENT':
	                    multi_parser.print_token(multi_parser.token_text);
	                    multi_parser.current_mode = 'TAG';
	                    break;
	                case 'TK_STYLE':
	                case 'TK_SCRIPT':
	                    if (multi_parser.token_text !== '') {
	                        multi_parser.print_newline(false, multi_parser.output);
	                        var text = multi_parser.token_text,
	                            _beautifier,
	                            script_indent_level = 1;
	                        if (multi_parser.token_type === 'TK_SCRIPT') {
	                            _beautifier = typeof js_beautify === 'function' && js_beautify;
	                        } else if (multi_parser.token_type === 'TK_STYLE') {
	                            _beautifier = typeof css_beautify === 'function' && css_beautify;
	                        }

	                        if (options.indent_scripts === "keep") {
	                            script_indent_level = 0;
	                        } else if (options.indent_scripts === "separate") {
	                            script_indent_level = -multi_parser.indent_level;
	                        }

	                        var indentation = multi_parser.get_full_indent(script_indent_level);
	                        if (_beautifier) {
	                            // call the Beautifier if avaliable
	                            text = _beautifier(text.replace(/^\s*/, indentation), options);
	                        } else {
	                            // simply indent the string otherwise
	                            var white = text.match(/^\s*/)[0];
	                            var _level = white.match(/[^\n\r]*$/)[0].split(multi_parser.indent_string).length - 1;
	                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);
	                            text = text.replace(/^\s*/, indentation)
	                                .replace(/\r\n|\r|\n/g, '\n' + reindent)
	                                .replace(/\s+$/, '');
	                        }
	                        if (text) {
	                            multi_parser.print_token_raw(indentation + trim(text));
	                            multi_parser.print_newline(false, multi_parser.output);
	                        }
	                    }
	                    multi_parser.current_mode = 'TAG';
	                    break;
	            }
	            multi_parser.last_token = multi_parser.token_type;
	            multi_parser.last_text = multi_parser.token_text;
	        }
	        return multi_parser.output.join('');
	    }

	    var beautify = __webpack_require__(233);

	    exports.htmlBeautify = function(html_source, options) {
	        return style_html(html_source, options, beautify.js, beautify.css);
	    };
	}());


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */

	"use strict";

	const acorn = __webpack_require__(226);

	/*

	  The MIT License (MIT)

	  Copyright (c) 2007-2013 Einar Lielmanis and contributors.

	  Permission is hereby granted, free of charge, to any person
	  obtaining a copy of this software and associated documentation files
	  (the "Software"), to deal in the Software without restriction,
	  including without limitation the rights to use, copy, modify, merge,
	  publish, distribute, sublicense, and/or sell copies of the Software,
	  and to permit persons to whom the Software is furnished to do so,
	  subject to the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	  SOFTWARE.

	 JS Beautifier
	---------------


	  Written by Einar Lielmanis, <einar@jsbeautifier.org>
	      http://jsbeautifier.org/

	  Originally converted to javascript by Vital, <vital76@gmail.com>
	  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
	  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>


	  Usage:
	    js_beautify(js_source_text);
	    js_beautify(js_source_text, options);

	  The options are:
	    indent_size (default 4)          - indentation size,
	    indent_char (default space)      - character to indent with,
	    preserve_newlines (default true) - whether existing line breaks should be preserved,
	    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

	    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

	            jslint_happy       !jslint_happy
	            ---------------------------------
	            function ()        function()

	    brace_style (default "collapse") - "collapse" | "expand" | "end-expand"
	            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line.

	    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

	    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

	    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
	          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
	                be preserved if it were present.

	    e.g

	    js_beautify(js_source_text, {
	      'indent_size': 1,
	      'indent_char': '\t'
	    });

	*/

	var js_beautify = function js_beautify(js_source_text, options) {
	    var beautifier = new Beautifier(js_source_text, options);
	    return beautifier.beautify();
	};

	exports.jsBeautify = js_beautify;

	function Beautifier(js_source_text, options) {
	    var input, output_lines;
	    var token_text, token_type, last_type, last_last_text, indent_string;
	    var flags, previous_flags, flag_store;
	    var whitespace, wordchar, punct, parser_pos, line_starters, reserved_words, digits;
	    var prefix;
	    var input_wanted_newline;
	    var output_space_before_token;
	    var input_length, n_newlines, whitespace_before_token;
	    var handlers, MODE, opt;
	    var preindent_string = '';



	    whitespace = "\n\r\t ".split('');
	    wordchar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'.split('');
	    digits = '0123456789'.split('');

	    punct = '+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>';
	    punct += ' <%= <% %> <?= <? ?>'; // try to be a good boy and try not to break the markup language identifiers
	    punct = punct.split(' ');

	    // words which should always start on new line.
	    line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,yield'.split(',');
	    reserved_words = line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof']);


	    MODE = {
	        BlockStatement: 'BlockStatement', // 'BLOCK'
	        Statement: 'Statement', // 'STATEMENT'
	        ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
	        ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
	        ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
	        Conditional: 'Conditional', //'(COND-EXPRESSION)',
	        Expression: 'Expression' //'(EXPRESSION)'
	    };

	    handlers = {
	        'TK_START_EXPR': handle_start_expr,
	        'TK_END_EXPR': handle_end_expr,
	        'TK_START_BLOCK': handle_start_block,
	        'TK_END_BLOCK': handle_end_block,
	        'TK_WORD': handle_word,
	        'TK_RESERVED': handle_word,
	        'TK_SEMICOLON': handle_semicolon,
	        'TK_STRING': handle_string,
	        'TK_EQUALS': handle_equals,
	        'TK_OPERATOR': handle_operator,
	        'TK_COMMA': handle_comma,
	        'TK_BLOCK_COMMENT': handle_block_comment,
	        'TK_INLINE_COMMENT': handle_inline_comment,
	        'TK_COMMENT': handle_comment,
	        'TK_DOT': handle_dot,
	        'TK_UNKNOWN': handle_unknown
	    };

	    function create_flags(flags_base, mode) {
	        var next_indent_level = 0;
	        if (flags_base) {
	            next_indent_level = flags_base.indentation_level;
	            if (!just_added_newline() &&
	                flags_base.line_indent_level > next_indent_level) {
	                next_indent_level = flags_base.line_indent_level;
	            }
	        }

	        var next_flags = {
	            mode: mode,
	            parent: flags_base,
	            last_text: flags_base ? flags_base.last_text : '', // last token text
	            last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed
	            declaration_statement: false,
	            declaration_assignment: false,
	            in_html_comment: false,
	            multiline_frame: false,
	            if_block: false,
	            else_block: false,
	            do_block: false,
	            do_while: false,
	            in_case_statement: false, // switch(..){ INSIDE HERE }
	            in_case: false, // we're on the exact line with "case 0:"
	            case_body: false, // the indented case-action block
	            indentation_level: next_indent_level,
	            line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
	            start_line_index: output_lines.length,
	            had_comment: false,
	            ternary_depth: 0
	        };
	        return next_flags;
	    }

	    // Using object instead of string to allow for later expansion of info about each line

	    function create_output_line() {
	        return {
	            text: []
	        };
	    }

	    // Some interpreters have unexpected results with foo = baz || bar;
	    options = options ? options : {};
	    opt = {};

	    // compatibility
	    if (options.space_after_anon_function !== undefined && options.jslint_happy === undefined) {
	        options.jslint_happy = options.space_after_anon_function;
	    }
	    if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
	        opt.brace_style = options.braces_on_own_line ? "expand" : "collapse";
	    }
	    opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : "collapse");

	    // graceful handling of deprecated option
	    if (opt.brace_style === "expand-strict") {
	        opt.brace_style = "expand";
	    }


	    opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;
	    opt.indent_char = options.indent_char ? options.indent_char : ' ';
	    opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;
	    opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;
	    opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);
	    opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;
	    opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;
	    opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;
	    opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;
	    opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;
	    opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;
	    opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);
	    opt.e4x = (options.e4x === undefined) ? false : options.e4x;

	    if(options.indent_with_tabs){
	        opt.indent_char = '\t';
	        opt.indent_size = 1;
	    }

	    //----------------------------------
	    indent_string = '';
	    while (opt.indent_size > 0) {
	        indent_string += opt.indent_char;
	        opt.indent_size -= 1;
	    }

	    while (js_source_text && (js_source_text.charAt(0) === ' ' || js_source_text.charAt(0) === '\t')) {
	        preindent_string += js_source_text.charAt(0);
	        js_source_text = js_source_text.substring(1);
	    }
	    input = js_source_text;
	    // cache the source's length.
	    input_length = js_source_text.length;

	    last_type = 'TK_START_BLOCK'; // last token type
	    last_last_text = ''; // pre-last token text
	    output_lines = [create_output_line()];
	    output_space_before_token = false;
	    whitespace_before_token = [];

	    // Stack of parsing/formatting states, including MODE.
	    // We tokenize, parse, and output in an almost purely a forward-only stream of token input
	    // and formatted output.  This makes the beautifier less accurate than full parsers
	    // but also far more tolerant of syntax errors.
	    //
	    // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
	    // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
	    // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
	    // most full parsers would die, but the beautifier gracefully falls back to
	    // MODE.BlockStatement and continues on.
	    flag_store = [];
	    set_mode(MODE.BlockStatement);

	    parser_pos = 0;

	    this.beautify = function() {
	        /*jshint onevar:true */
	        var t, i, keep_whitespace, sweet_code;

	        while (true) {
	            t = get_next_token();
	            token_text = t[0];
	            token_type = t[1];

	            if (token_type === 'TK_EOF') {
	                // Unwind any open statements
	                while (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }
	                break;
	            }

	            keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);
	            input_wanted_newline = n_newlines > 0;

	            if (keep_whitespace) {
	                for (i = 0; i < n_newlines; i += 1) {
	                    print_newline(i > 0);
	                }
	            } else {
	                if (opt.max_preserve_newlines && n_newlines > opt.max_preserve_newlines) {
	                    n_newlines = opt.max_preserve_newlines;
	                }

	                if (opt.preserve_newlines) {
	                    if (n_newlines > 1) {
	                        print_newline();
	                        for (i = 1; i < n_newlines; i += 1) {
	                            print_newline(true);
	                        }
	                    }
	                }
	            }

	            handlers[token_type]();

	            // The cleanest handling of inline comments is to treat them as though they aren't there.
	            // Just continue formatting and the behavior should be logical.
	            // Also ignore unknown tokens.  Again, this should result in better behavior.
	            if (token_type !== 'TK_INLINE_COMMENT' && token_type !== 'TK_COMMENT' &&
	                token_type !== 'TK_BLOCK_COMMENT' && token_type !== 'TK_UNKNOWN') {
	                last_last_text = flags.last_text;
	                last_type = token_type;
	                flags.last_text = token_text;
	            }
	            flags.had_comment = (token_type === 'TK_INLINE_COMMENT' || token_type === 'TK_COMMENT'
	                || token_type === 'TK_BLOCK_COMMENT');
	        }


	        sweet_code = output_lines[0].text.join('');
	        for (var line_index = 1; line_index < output_lines.length; line_index++) {
	            sweet_code += '\n' + output_lines[line_index].text.join('');
	        }
	        sweet_code = sweet_code.replace(/[\r\n ]+$/, '');
	        return sweet_code;
	    };

	    function trim_output(eat_newlines) {
	        eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

	        if (output_lines.length) {
	            trim_output_line(output_lines[output_lines.length - 1], eat_newlines);

	            while (eat_newlines && output_lines.length > 1 &&
	                output_lines[output_lines.length - 1].text.length === 0) {
	                output_lines.pop();
	                trim_output_line(output_lines[output_lines.length - 1], eat_newlines);
	            }
	        }
	    }

	    function trim_output_line(line) {
	        while (line.text.length &&
	            (line.text[line.text.length - 1] === ' ' ||
	                line.text[line.text.length - 1] === indent_string ||
	                line.text[line.text.length - 1] === preindent_string)) {
	            line.text.pop();
	        }
	    }

	    function trim(s) {
	        return s.replace(/^\s+|\s+$/g, '');
	    }

	    // we could use just string.split, but
	    // IE doesn't like returning empty strings

	    function split_newlines(s) {
	        //return s.split(/\x0d\x0a|\x0a/);

	        s = s.replace(/\x0d/g, '');
	        var out = [],
	            idx = s.indexOf("\n");
	        while (idx !== -1) {
	            out.push(s.substring(0, idx));
	            s = s.substring(idx + 1);
	            idx = s.indexOf("\n");
	        }
	        if (s.length) {
	            out.push(s);
	        }
	        return out;
	    }

	    function just_added_newline() {
	        var line = output_lines[output_lines.length - 1];
	        return line.text.length === 0;
	    }

	    function just_added_blankline() {
	        if (just_added_newline()) {
	            if (output_lines.length === 1) {
	                return true; // start of the file and newline = blank
	            }

	            var line = output_lines[output_lines.length - 2];
	            return line.text.length === 0;
	        }
	        return false;
	    }

	    function allow_wrap_or_preserved_newline(force_linewrap) {
	        force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;
	        if (opt.wrap_line_length && !force_linewrap) {
	            var line = output_lines[output_lines.length - 1];
	            var proposed_line_length = 0;
	            // never wrap the first token of a line.
	            if (line.text.length > 0) {
	                proposed_line_length = line.text.join('').length + token_text.length +
	                    (output_space_before_token ? 1 : 0);
	                if (proposed_line_length >= opt.wrap_line_length) {
	                    force_linewrap = true;
	                }
	            }
	        }
	        if (((opt.preserve_newlines && input_wanted_newline) || force_linewrap) && !just_added_newline()) {
	            print_newline(false, true);

	        }
	    }

	    function print_newline(force_newline, preserve_statement_flags) {
	        output_space_before_token = false;

	        if (!preserve_statement_flags) {
	            if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {
	                while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
	                    restore_mode();
	                }
	            }
	        }

	        if (output_lines.length === 1 && just_added_newline()) {
	            return; // no newline on start of file
	        }

	        if (force_newline || !just_added_newline()) {
	            flags.multiline_frame = true;
	            output_lines.push(create_output_line());
	        }
	    }

	    function print_token_line_indentation() {
	        if (just_added_newline()) {
	            var line = output_lines[output_lines.length - 1];
	            if (opt.keep_array_indentation && is_array(flags.mode) && input_wanted_newline) {
	                // prevent removing of this whitespace as redundant
	                line.text.push('');
	                for (var i = 0; i < whitespace_before_token.length; i += 1) {
	                    line.text.push(whitespace_before_token[i]);
	                }
	            } else {
	                if (preindent_string) {
	                    line.text.push(preindent_string);
	                }

	                print_indent_string(flags.indentation_level);
	            }
	        }
	    }

	    function print_indent_string(level) {
	        // Never indent your first output indent at the start of the file
	        if (output_lines.length > 1) {
	            var line = output_lines[output_lines.length - 1];

	            flags.line_indent_level = level;
	            for (var i = 0; i < level; i += 1) {
	                line.text.push(indent_string);
	            }
	        }
	    }

	    function print_token_space_before() {
	        var line = output_lines[output_lines.length - 1];
	        if (output_space_before_token && line.text.length) {
	            var last_output = line.text[line.text.length - 1];
	            if (last_output !== ' ' && last_output !== indent_string) { // prevent occassional duplicate space
	                line.text.push(' ');
	            }
	        }
	    }

	    function print_token(printable_token) {
	        printable_token = printable_token || token_text;
	        print_token_line_indentation();
	        print_token_space_before();
	        output_space_before_token = false;
	        output_lines[output_lines.length - 1].text.push(printable_token);
	    }

	    function indent() {
	        flags.indentation_level += 1;
	    }

	    function deindent() {
	        if (flags.indentation_level > 0 &&
	            ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))
	            flags.indentation_level -= 1;
	    }

	    function remove_redundant_indentation(frame) {
	        // This implementation is effective but has some issues:
	        //     - less than great performance due to array splicing
	        //     - can cause line wrap to happen too soon due to indent removal
	        //           after wrap points are calculated
	        // These issues are minor compared to ugly indentation.

	        if (frame.multiline_frame) return;

	        // remove one indent from each line inside this section
	        var index = frame.start_line_index;
	        var splice_index = 0;
	        var line;

	        while (index < output_lines.length) {
	            line = output_lines[index];
	            index++;

	            // skip empty lines
	            if (line.text.length === 0) {
	                continue;
	            }

	            // skip the preindent string if present
	            if (preindent_string && line.text[0] === preindent_string) {
	                splice_index = 1;
	            } else {
	                splice_index = 0;
	            }

	            // remove one indent, if present
	            if (line.text[splice_index] === indent_string) {
	                line.text.splice(splice_index, 1);
	            }
	        }
	    }

	    function set_mode(mode) {
	        if (flags) {
	            flag_store.push(flags);
	            previous_flags = flags;
	        } else {
	            previous_flags = create_flags(null, mode);
	        }

	        flags = create_flags(previous_flags, mode);
	    }

	    function is_array(mode) {
	        return mode === MODE.ArrayLiteral;
	    }

	    function is_expression(mode) {
	        return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
	    }

	    function restore_mode() {
	        if (flag_store.length > 0) {
	            previous_flags = flags;
	            flags = flag_store.pop();
	            if (previous_flags.mode === MODE.Statement) {
	                remove_redundant_indentation(previous_flags);
	            }
	        }
	    }

	    function start_of_object_property() {
	        return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && flags.last_text === ':' &&
	            flags.ternary_depth === 0;
	    }

	    function start_of_statement() {
	        if (
	                (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && token_type === 'TK_WORD') ||
	                (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||
	                (last_type === 'TK_RESERVED' && flags.last_text === 'return' && !input_wanted_newline) ||
	                (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(token_type === 'TK_RESERVED' && token_text === 'if')) ||
	                (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||
	                (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement
	                    && !flags.in_case
	                    && !(token_text === '--' || token_text === '++')
	                    && token_type !== 'TK_WORD' && token_type !== 'TK_RESERVED') ||
	                (flags.mode === MODE.ObjectLiteral && flags.last_text === ':' && flags.ternary_depth === 0)

	            ) {

	            set_mode(MODE.Statement);
	            indent();

	            if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && token_type === 'TK_WORD') {
	                flags.declaration_statement = true;
	            }

	            // Issue #276:
	            // If starting a new statement with [if, for, while, do], push to a new line.
	            // if (a) if (b) if(c) d(); else e(); else f();
	            if (!start_of_object_property()) {
	                allow_wrap_or_preserved_newline(
	                    token_type === 'TK_RESERVED' && in_array(token_text, ['do', 'for', 'if', 'while']));
	            }

	            return true;
	        }
	        return false;
	    }

	    function all_lines_start_with(lines, c) {
	        for (var i = 0; i < lines.length; i++) {
	            var line = trim(lines[i]);
	            if (line.charAt(0) !== c) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function each_line_matches_indent(lines, indent) {
	        var i = 0,
	            len = lines.length,
	            line;
	        for (; i < len; i++) {
	            line = lines[i];
	            // allow empty lines to pass through
	            if (line && line.indexOf(indent) !== 0) {
	                return false;
	            }
	        }
	        return true;
	    }

	    function is_special_word(word) {
	        return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);
	    }

	    function in_array(what, arr) {
	        for (var i = 0; i < arr.length; i += 1) {
	            if (arr[i] === what) {
	                return true;
	            }
	        }
	        return false;
	    }

	    function unescape_string(s) {
	        var esc = false,
	            out = '',
	            pos = 0,
	            s_hex = '',
	            escaped = 0,
	            c;

	        while (esc || pos < s.length) {

	            c = s.charAt(pos);
	            pos++;

	            if (esc) {
	                esc = false;
	                if (c === 'x') {
	                    // simple hex-escape \x24
	                    s_hex = s.substr(pos, 2);
	                    pos += 2;
	                } else if (c === 'u') {
	                    // unicode-escape, \u2134
	                    s_hex = s.substr(pos, 4);
	                    pos += 4;
	                } else {
	                    // some common escape, e.g \n
	                    out += '\\' + c;
	                    continue;
	                }
	                if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {
	                    // some weird escaping, bail out,
	                    // leaving whole string intact
	                    return s;
	                }

	                escaped = parseInt(s_hex, 16);

	                if (escaped >= 0x00 && escaped < 0x20) {
	                    // leave 0x00...0x1f escaped
	                    if (c === 'x') {
	                        out += '\\x' + s_hex;
	                    } else {
	                        out += '\\u' + s_hex;
	                    }
	                    continue;
	                } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
	                    // single-quote, apostrophe, backslash - escape these
	                    out += '\\' + String.fromCharCode(escaped);
	                } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {
	                    // we bail out on \x7f..\xff,
	                    // leaving whole string escaped,
	                    // as it's probably completely binary
	                    return s;
	                } else {
	                    out += String.fromCharCode(escaped);
	                }
	            } else if (c === '\\') {
	                esc = true;
	            } else {
	                out += c;
	            }
	        }
	        return out;
	    }

	    function is_next(find) {
	        var local_pos = parser_pos;
	        var c = input.charAt(local_pos);
	        while (in_array(c, whitespace) && c !== find) {
	            local_pos++;
	            if (local_pos >= input_length) {
	                return false;
	            }
	            c = input.charAt(local_pos);
	        }
	        return c === find;
	    }

	    function get_next_token() {
	        var i, resulting_string;

	        n_newlines = 0;

	        if (parser_pos >= input_length) {
	            return ['', 'TK_EOF'];
	        }

	        input_wanted_newline = false;
	        whitespace_before_token = [];

	        var c = input.charAt(parser_pos);
	        parser_pos += 1;

	        while (in_array(c, whitespace)) {

	            if (c === '\n') {
	                n_newlines += 1;
	                whitespace_before_token = [];
	            } else if (n_newlines) {
	                if (c === indent_string) {
	                    whitespace_before_token.push(indent_string);
	                } else if (c !== '\r') {
	                    whitespace_before_token.push(' ');
	                }
	            }

	            if (parser_pos >= input_length) {
	                return ['', 'TK_EOF'];
	            }

	            c = input.charAt(parser_pos);
	            parser_pos += 1;
	        }

	        // NOTE: because beautifier doesn't fully parse, it doesn't use acorn.isIdentifierStart.
	        // It just treats all identifiers and numbers and such the same.
	        if (acorn.isIdentifierChar(input.charCodeAt(parser_pos-1))) {
	            if (parser_pos < input_length) {
	                while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {
	                    c += input.charAt(parser_pos);
	                    parser_pos += 1;
	                    if (parser_pos === input_length) {
	                        break;
	                    }
	                }
	            }

	            // small and surprisingly unugly hack for 1E-10 representation
	            if (parser_pos !== input_length && c.match(/^[0-9]+[Ee]$/) && (input.charAt(parser_pos) === '-' || input.charAt(parser_pos) === '+')) {

	                var sign = input.charAt(parser_pos);
	                parser_pos += 1;

	                var t = get_next_token();
	                c += sign + t[0];
	                return [c, 'TK_WORD'];
	            }

	            if (!(last_type === 'TK_DOT' ||
	                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['set', 'get'])))
	                && in_array(c, reserved_words)) {
	                if (c === 'in') { // hack for 'in' operator
	                    return [c, 'TK_OPERATOR'];
	                }
	                return [c, 'TK_RESERVED'];
	            }
	            return [c, 'TK_WORD'];
	        }

	        if (c === '(' || c === '[') {
	            return [c, 'TK_START_EXPR'];
	        }

	        if (c === ')' || c === ']') {
	            return [c, 'TK_END_EXPR'];
	        }

	        if (c === '{') {
	            return [c, 'TK_START_BLOCK'];
	        }

	        if (c === '}') {
	            return [c, 'TK_END_BLOCK'];
	        }

	        if (c === ';') {
	            return [c, 'TK_SEMICOLON'];
	        }

	        if (c === '/') {
	            var comment = '';
	            // peek for comment /* ... */
	            var inline_comment = true;
	            if (input.charAt(parser_pos) === '*') {
	                parser_pos += 1;
	                if (parser_pos < input_length) {
	                    while (parser_pos < input_length && !(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {
	                        c = input.charAt(parser_pos);
	                        comment += c;
	                        if (c === "\n" || c === "\r") {
	                            inline_comment = false;
	                        }
	                        parser_pos += 1;
	                        if (parser_pos >= input_length) {
	                            break;
	                        }
	                    }
	                }
	                parser_pos += 2;
	                if (inline_comment && n_newlines === 0) {
	                    return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];
	                } else {
	                    return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];
	                }
	            }
	            // peek for comment // ...
	            if (input.charAt(parser_pos) === '/') {
	                comment = c;
	                while (input.charAt(parser_pos) !== '\r' && input.charAt(parser_pos) !== '\n') {
	                    comment += input.charAt(parser_pos);
	                    parser_pos += 1;
	                    if (parser_pos >= input_length) {
	                        break;
	                    }
	                }
	                return [comment, 'TK_COMMENT'];
	            }

	        }


	        if (c === '`' || c === "'" || c === '"' || // string
	            (
	                (c === '/') || // regexp
	                (opt.e4x && c === "<" && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*\/?\s*>/)) // xml
	            ) && ( // regex and xml can only appear in specific locations during parsing
	                (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) ||
	                (last_type === 'TK_END_EXPR' && in_array(previous_flags.mode, [MODE.Conditional, MODE.ForInitializer])) ||
	                (in_array(last_type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',
	                    'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'
	                ]))
	            )) {

	            var sep = c,
	                esc = false,
	                has_char_escapes = false;

	            resulting_string = c;

	            if (parser_pos < input_length) {
	                if (sep === '/') {
	                    //
	                    // handle regexp
	                    //
	                    var in_char_class = false;
	                    while (esc || in_char_class || input.charAt(parser_pos) !== sep) {
	                        resulting_string += input.charAt(parser_pos);
	                        if (!esc) {
	                            esc = input.charAt(parser_pos) === '\\';
	                            if (input.charAt(parser_pos) === '[') {
	                                in_char_class = true;
	                            } else if (input.charAt(parser_pos) === ']') {
	                                in_char_class = false;
	                            }
	                        } else {
	                            esc = false;
	                        }
	                        parser_pos += 1;
	                        if (parser_pos >= input_length) {
	                            // incomplete string/rexp when end-of-file reached.
	                            // bail out with what had been received so far.
	                            return [resulting_string, 'TK_STRING'];
	                        }
	                    }
	                } else if (opt.e4x && sep === '<') {
	                    //
	                    // handle e4x xml literals
	                    //
	                    var xmlRegExp = /<(\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\[CDATA\[[\s\S]*?\]\])\s*([-a-zA-Z:0-9_.]+=('[^']*'|"[^"]*"|{[^{}]*})\s*)*(\/?)\s*>/g;
	                    var xmlStr = input.slice(parser_pos - 1);
	                    var match = xmlRegExp.exec(xmlStr);
	                    if (match && match.index === 0) {
	                        var rootTag = match[2];
	                        var depth = 0;
	                        while (match) {
	                            var isEndTag = !! match[1];
	                            var tagName = match[2];
	                            var isSingletonTag = ( !! match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
	                            if (tagName === rootTag && !isSingletonTag) {
	                                if (isEndTag) {
	                                    --depth;
	                                } else {
	                                    ++depth;
	                                }
	                            }
	                            if (depth <= 0) {
	                                break;
	                            }
	                            match = xmlRegExp.exec(xmlStr);
	                        }
	                        var xmlLength = match ? match.index + match[0].length : xmlStr.length;
	                        parser_pos += xmlLength - 1;
	                        return [xmlStr.slice(0, xmlLength), "TK_STRING"];
	                    }
	                } else {
	                    //
	                    // handle string
	                    //
	                    while (esc || input.charAt(parser_pos) !== sep) {
	                        resulting_string += input.charAt(parser_pos);
	                        if (esc) {
	                            if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {
	                                has_char_escapes = true;
	                            }
	                            esc = false;
	                        } else {
	                            esc = input.charAt(parser_pos) === '\\';
	                        }
	                        parser_pos += 1;
	                        if (parser_pos >= input_length) {
	                            // incomplete string/rexp when end-of-file reached.
	                            // bail out with what had been received so far.
	                            return [resulting_string, 'TK_STRING'];
	                        }
	                    }

	                }
	            }

	            parser_pos += 1;
	            resulting_string += sep;

	            if (has_char_escapes && opt.unescape_strings) {
	                resulting_string = unescape_string(resulting_string);
	            }

	            if (sep === '/') {
	                // regexps may have modifiers /regexp/MOD , so fetch those, too
	                while (parser_pos < input_length && in_array(input.charAt(parser_pos), wordchar)) {
	                    resulting_string += input.charAt(parser_pos);
	                    parser_pos += 1;
	                }
	            }
	            return [resulting_string, 'TK_STRING'];
	        }

	        if (c === '#') {


	            if (output_lines.length === 1 && output_lines[0].text.length === 0 &&
	                input.charAt(parser_pos) === '!') {
	                // shebang
	                resulting_string = c;
	                while (parser_pos < input_length && c !== '\n') {
	                    c = input.charAt(parser_pos);
	                    resulting_string += c;
	                    parser_pos += 1;
	                }
	                return [trim(resulting_string) + '\n', 'TK_UNKNOWN'];
	            }



	            // Spidermonkey-specific sharp variables for circular references
	            // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript
	            // http://dxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935
	            var sharp = '#';
	            if (parser_pos < input_length && in_array(input.charAt(parser_pos), digits)) {
	                do {
	                    c = input.charAt(parser_pos);
	                    sharp += c;
	                    parser_pos += 1;
	                } while (parser_pos < input_length && c !== '#' && c !== '=');
	                if (c === '#') {
	                    //
	                } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {
	                    sharp += '[]';
	                    parser_pos += 2;
	                } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {
	                    sharp += '{}';
	                    parser_pos += 2;
	                }
	                return [sharp, 'TK_WORD'];
	            }
	        }

	        if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {
	            parser_pos += 3;
	            c = '<!--';
	            while (input.charAt(parser_pos) !== '\n' && parser_pos < input_length) {
	                c += input.charAt(parser_pos);
	                parser_pos++;
	            }
	            flags.in_html_comment = true;
	            return [c, 'TK_COMMENT'];
	        }

	        if (c === '-' && flags.in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {
	            flags.in_html_comment = false;
	            parser_pos += 2;
	            return ['-->', 'TK_COMMENT'];
	        }

	        if (c === '.') {
	            return [c, 'TK_DOT'];
	        }

	        if (in_array(c, punct)) {
	            while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {
	                c += input.charAt(parser_pos);
	                parser_pos += 1;
	                if (parser_pos >= input_length) {
	                    break;
	                }
	            }

	            if (c === ',') {
	                return [c, 'TK_COMMA'];
	            } else if (c === '=') {
	                return [c, 'TK_EQUALS'];
	            } else {
	                return [c, 'TK_OPERATOR'];
	            }
	        }

	        return [c, 'TK_UNKNOWN'];
	    }

	    function handle_start_expr() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        var next_mode = MODE.Expression;
	        if (token_text === '[') {

	            if (last_type === 'TK_WORD' || flags.last_text === ')') {
	                // this is array index specifier, break immediately
	                // a[x], fn()[x]
	                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, line_starters)) {
	                    output_space_before_token = true;
	                }
	                set_mode(next_mode);
	                print_token();
	                indent();
	                if (opt.space_in_paren) {
	                    output_space_before_token = true;
	                }
	                return;
	            }

	            next_mode = MODE.ArrayLiteral;
	            if (is_array(flags.mode)) {
	                if (flags.last_text === '[' ||
	                    (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {
	                    // ], [ goes to new line
	                    // }, [ goes to new line
	                    if (!opt.keep_array_indentation) {
	                        print_newline();
	                    }
	                }
	            }

	        } else {
	            if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {
	                next_mode = MODE.ForInitializer;
	            } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {
	                next_mode = MODE.Conditional;
	            } else {
	                // next_mode = MODE.Expression;
	            }
	        }

	        if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {
	            print_newline();
	        } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {
	            // TODO: Consider whether forcing this is required.  Review failing tests when removed.
	            allow_wrap_or_preserved_newline(input_wanted_newline);
	            // do nothing on (( and )( and ][ and ]( and .(
	        } else if (!(last_type === 'TK_RESERVED' && token_text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {
	            output_space_before_token = true;
	        } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||
	            (flags.last_text === '*' && last_last_text === 'function')) {
	            // function() vs function ()
	            if (opt.jslint_happy) {
	                output_space_before_token = true;
	            }
	        } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, line_starters) || flags.last_text === 'catch')) {
	            if (opt.space_before_conditional) {
	                output_space_before_token = true;
	            }
	        }

	        // Support of this kind of newline preservation.
	        // a = (b &&
	        //     (c || d));
	        if (token_text === '(') {
	            if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	                if (!start_of_object_property()) {
	                    allow_wrap_or_preserved_newline();
	                }
	            }
	        }

	        set_mode(next_mode);
	        print_token();
	        if (opt.space_in_paren) {
	            output_space_before_token = true;
	        }

	        // In all cases, if we newline while inside an expression it should be indented.
	        indent();
	    }

	    function handle_end_expr() {
	        // statements inside expressions are not valid syntax, but...
	        // statements must all be closed when their container closes
	        while (flags.mode === MODE.Statement) {
	            restore_mode();
	        }

	        if (flags.multiline_frame) {
	            allow_wrap_or_preserved_newline(token_text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);
	        }

	        if (opt.space_in_paren) {
	            if (last_type === 'TK_START_EXPR' && ! opt.space_in_empty_paren) {
	                // () [] no inner space in empty parens like these, ever, ref #320
	                trim_output();
	                output_space_before_token = false;
	            } else {
	                output_space_before_token = true;
	            }
	        }
	        if (token_text === ']' && opt.keep_array_indentation) {
	            print_token();
	            restore_mode();
	        } else {
	            restore_mode();
	            print_token();
	        }
	        remove_redundant_indentation(previous_flags);

	        // do {} while () // no statement required after
	        if (flags.do_while && previous_flags.mode === MODE.Conditional) {
	            previous_flags.mode = MODE.Expression;
	            flags.do_block = false;
	            flags.do_while = false;

	        }
	    }

	    function handle_start_block() {
	        set_mode(MODE.BlockStatement);

	        var empty_braces = is_next('}');
	        var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&
	            last_type === 'TK_END_EXPR';

	        if (opt.brace_style === "expand") {
	            if (last_type !== 'TK_OPERATOR' &&
	                (empty_anonymous_function ||
	                    last_type === 'TK_EQUALS' ||
	                    (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {
	                output_space_before_token = true;
	            } else {
	                print_newline(false, true);
	            }
	        } else { // collapse
	            if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {
	                if (last_type === 'TK_START_BLOCK') {
	                    print_newline();
	                } else {
	                    output_space_before_token = true;
	                }
	            } else {
	                // if TK_OPERATOR or TK_START_EXPR
	                if (is_array(previous_flags.mode) && flags.last_text === ',') {
	                    if (last_last_text === '}') {
	                        // }, { in array context
	                        output_space_before_token = true;
	                    } else {
	                        print_newline(); // [a, b, c, {
	                    }
	                }
	            }
	        }
	        print_token();
	        indent();
	    }

	    function handle_end_block() {
	        // statements must all be closed when their container closes
	        while (flags.mode === MODE.Statement) {
	            restore_mode();
	        }
	        var empty_braces = last_type === 'TK_START_BLOCK';

	        if (opt.brace_style === "expand") {
	            if (!empty_braces) {
	                print_newline();
	            }
	        } else {
	            // skip {}
	            if (!empty_braces) {
	                if (is_array(flags.mode) && opt.keep_array_indentation) {
	                    // we REALLY need a newline here, but newliner would skip that
	                    opt.keep_array_indentation = false;
	                    print_newline();
	                    opt.keep_array_indentation = true;

	                } else {
	                    print_newline();
	                }
	            }
	        }
	        restore_mode();
	        print_token();
	    }

	    function handle_word() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        } else if (input_wanted_newline && !is_expression(flags.mode) &&
	            (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&
	            last_type !== 'TK_EQUALS' &&
	            (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {

	            print_newline();
	        }

	        if (flags.do_block && !flags.do_while) {
	            if (token_type === 'TK_RESERVED' && token_text === 'while') {
	                // do {} ## while ()
	                output_space_before_token = true;
	                print_token();
	                output_space_before_token = true;
	                flags.do_while = true;
	                return;
	            } else {
	                // do {} should always have while as the next word.
	                // if we don't see the expected while, recover
	                print_newline();
	                flags.do_block = false;
	            }
	        }

	        // if may be followed by else, or not
	        // Bare/inline ifs are tricky
	        // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
	        if (flags.if_block) {
	            if (!flags.else_block && (token_type === 'TK_RESERVED' && token_text === 'else')) {
	                flags.else_block = true;
	            } else {
	                while (flags.mode === MODE.Statement) {
	                    restore_mode();
	                }
	                flags.if_block = false;
	                flags.else_block = false;
	            }
	        }

	        if (token_type === 'TK_RESERVED' && (token_text === 'case' || (token_text === 'default' && flags.in_case_statement))) {
	            print_newline();
	            if (flags.case_body || opt.jslint_happy) {
	                // switch cases following one another
	                deindent();
	                flags.case_body = false;
	            }
	            print_token();
	            flags.in_case = true;
	            flags.in_case_statement = true;
	            return;
	        }

	        if (token_type === 'TK_RESERVED' && token_text === 'function') {
	            if (in_array(flags.last_text, ['}', ';']) || (just_added_newline() && ! in_array(flags.last_text, ['{', ':', '=', ',']))) {
	                // make sure there is a nice clean space of at least one blank line
	                // before a new function definition
	                if ( ! just_added_blankline() && ! flags.had_comment) {
	                    print_newline();
	                    print_newline(true);
	                }
	            }
	            if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
	                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return'])) {
	                    output_space_before_token = true;
	                } else {
	                    print_newline();
	                }
	            } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {
	                // foo = function
	                output_space_before_token = true;
	            } else if (is_expression(flags.mode)) {
	                // (function
	            } else {
	                print_newline();
	            }
	        }

	        if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	            if (!start_of_object_property()) {
	                allow_wrap_or_preserved_newline();
	            }
	        }

	        if (token_type === 'TK_RESERVED' && token_text === 'function') {
	            print_token();
	            flags.last_word = token_text;
	            return;
	        }

	        prefix = 'NONE';

	        if (last_type === 'TK_END_BLOCK') {
	            if (!(token_type === 'TK_RESERVED' && in_array(token_text, ['else', 'catch', 'finally']))) {
	                prefix = 'NEWLINE';
	            } else {
	                if (opt.brace_style === "expand" || opt.brace_style === "end-expand") {
	                    prefix = 'NEWLINE';
	                } else {
	                    prefix = 'SPACE';
	                    output_space_before_token = true;
	                }
	            }
	        } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {
	            // TODO: Should this be for STATEMENT as well?
	            prefix = 'NEWLINE';
	        } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {
	            prefix = 'SPACE';
	        } else if (last_type === 'TK_STRING') {
	            prefix = 'NEWLINE';
	        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||
	            (flags.last_text === '*' && last_last_text === 'function')) {
	            prefix = 'SPACE';
	        } else if (last_type === 'TK_START_BLOCK') {
	            prefix = 'NEWLINE';
	        } else if (last_type === 'TK_END_EXPR') {
	            output_space_before_token = true;
	            prefix = 'NEWLINE';
	        }

	        if (token_type === 'TK_RESERVED' && in_array(token_text, line_starters) && flags.last_text !== ')') {
	            if (flags.last_text === 'else') {
	                prefix = 'SPACE';
	            } else {
	                prefix = 'NEWLINE';
	            }

	        }

	        if (token_type === 'TK_RESERVED' && in_array(token_text, ['else', 'catch', 'finally'])) {
	            if (last_type !== 'TK_END_BLOCK' || opt.brace_style === "expand" || opt.brace_style === "end-expand") {
	                print_newline();
	            } else {
	                trim_output(true);
	                var line = output_lines[output_lines.length - 1];
	                // If we trimmed and there's something other than a close block before us
	                // put a newline back in.  Handles '} // comment' scenario.
	                if (line.text[line.text.length - 1] !== '}') {
	                    print_newline();
	                }
	                output_space_before_token = true;
	            }
	        } else if (prefix === 'NEWLINE') {
	            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	                // no newline between 'return nnn'
	                output_space_before_token = true;
	            } else if (last_type !== 'TK_END_EXPR') {
	                if ((last_type !== 'TK_START_EXPR' || !(token_type === 'TK_RESERVED' && in_array(token_text, ['var', 'let', 'const']))) && flags.last_text !== ':') {
	                    // no need to force newline on 'var': for (var x = 0...)
	                    if (token_type === 'TK_RESERVED' && token_text === 'if' && flags.last_word === 'else' && flags.last_text !== '{') {
	                        // no newline for } else if {
	                        output_space_before_token = true;
	                    } else {
	                        print_newline();
	                    }
	                }
	            } else if (token_type === 'TK_RESERVED' && in_array(token_text, line_starters) && flags.last_text !== ')') {
	                print_newline();
	            }
	        } else if (is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {
	            print_newline(); // }, in lists get a newline treatment
	        } else if (prefix === 'SPACE') {
	            output_space_before_token = true;
	        }
	        print_token();
	        flags.last_word = token_text;

	        if (token_type === 'TK_RESERVED' && token_text === 'do') {
	            flags.do_block = true;
	        }

	        if (token_type === 'TK_RESERVED' && token_text === 'if') {
	            flags.if_block = true;
	        }
	    }

	    function handle_semicolon() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	            // Semicolon can be the start (and end) of a statement
	            output_space_before_token = false;
	        }
	        while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {
	            restore_mode();
	        }
	        print_token();
	        if (flags.mode === MODE.ObjectLiteral) {
	            // if we're in OBJECT mode and see a semicolon, its invalid syntax
	            // recover back to treating this as a BLOCK
	            flags.mode = MODE.BlockStatement;
	        }
	    }

	    function handle_string() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	            // One difference - strings want at least a space before
	            output_space_before_token = true;
	        } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {
	            output_space_before_token = true;
	        } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {
	            if (!start_of_object_property()) {
	                allow_wrap_or_preserved_newline();
	            }
	        } else {
	            print_newline();
	        }
	        print_token();
	    }

	    function handle_equals() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        if (flags.declaration_statement) {
	            // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
	            flags.declaration_assignment = true;
	        }
	        output_space_before_token = true;
	        print_token();
	        output_space_before_token = true;
	    }

	    function handle_comma() {
	        if (flags.declaration_statement) {
	            if (is_expression(flags.parent.mode)) {
	                // do not break on comma, for(var a = 1, b = 2)
	                flags.declaration_assignment = false;
	            }

	            print_token();

	            if (flags.declaration_assignment) {
	                flags.declaration_assignment = false;
	                print_newline(false, true);
	            } else {
	                output_space_before_token = true;
	            }
	            return;
	        }

	        print_token();
	        if (flags.mode === MODE.ObjectLiteral ||
	            (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {
	            if (flags.mode === MODE.Statement) {
	                restore_mode();
	            }
	            print_newline();
	        } else {
	            // EXPR or DO_BLOCK
	            output_space_before_token = true;
	        }

	    }

	    function handle_operator() {
	        // Check if this is a BlockStatement that should be treated as a ObjectLiteral
	        if (token_text === ':' && flags.mode === MODE.BlockStatement &&
	                last_last_text === '{' &&
	                (last_type === 'TK_WORD' || last_type === 'TK_RESERVED')){
	            flags.mode = MODE.ObjectLiteral;
	        }

	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        var space_before = true;
	        var space_after = true;
	        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	            // "return" had a special handling in TK_WORD. Now we need to return the favor
	            output_space_before_token = true;
	            print_token();
	            return;
	        }

	        // hack for actionscript's import .*;
	        if (token_text === '*' && last_type === 'TK_DOT' && !last_last_text.match(/^\d+$/)) {
	            print_token();
	            return;
	        }

	        if (token_text === ':' && flags.in_case) {
	            flags.case_body = true;
	            indent();
	            print_token();
	            print_newline();
	            flags.in_case = false;
	            return;
	        }

	        if (token_text === '::') {
	            // no spaces around exotic namespacing syntax operator
	            print_token();
	            return;
	        }

	        // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
	        // if there is a newline between -- or ++ and anything else we should preserve it.
	        if (input_wanted_newline && (token_text === '--' || token_text === '++')) {
	            print_newline();
	        }

	        // Allow line wrapping between operators
	        if (last_type === 'TK_OPERATOR') {
	            allow_wrap_or_preserved_newline();
	        }

	        if (in_array(token_text, ['--', '++', '!', '~']) || (in_array(token_text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, line_starters) || flags.last_text === ','))) {
	            // unary operators (and binary +/- pretending to be unary) special cases

	            space_before = false;
	            space_after = false;

	            if (flags.last_text === ';' && is_expression(flags.mode)) {
	                // for (;; ++i)
	                //        ^^^
	                space_before = true;
	            }

	            if (last_type === 'TK_RESERVED') {
	                space_before = true;
	            }

	            if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ';')) {
	                // { foo; --i }
	                // foo(); --bar;
	                print_newline();
	            }
	        } else if (token_text === ':') {
	            if (flags.ternary_depth === 0) {
	                if (flags.mode === MODE.BlockStatement) {
	                    flags.mode = MODE.ObjectLiteral;
	                }
	                space_before = false;
	            } else {
	                flags.ternary_depth -= 1;
	            }
	        } else if (token_text === '?') {
	            flags.ternary_depth += 1;
	        } else if (token_text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {
	            space_before = false;
	            space_after = false;
	        }
	        output_space_before_token = output_space_before_token || space_before;
	        print_token();
	        output_space_before_token = space_after;
	    }

	    function handle_block_comment() {
	        var lines = split_newlines(token_text);
	        var j; // iterator for this case
	        var javadoc = false;
	        var starless = false;
	        var lastIndent = whitespace_before_token.join('');
	        var lastIndentLength = lastIndent.length;

	        // block comment starts with a new line
	        print_newline(false, true);
	        if (lines.length > 1) {
	            if (all_lines_start_with(lines.slice(1), '*')) {
	                javadoc = true;
	            }
	            else if (each_line_matches_indent(lines.slice(1), lastIndent)) {
	                starless = true;
	            }
	        }

	        // first line always indented
	        print_token(lines[0]);
	        for (j = 1; j < lines.length; j++) {
	            print_newline(false, true);
	            if (javadoc) {
	                // javadoc: reformat and re-indent
	                print_token(' ' + trim(lines[j]));
	            } else if (starless && lines[j].length > lastIndentLength) {
	                // starless: re-indent non-empty content, avoiding trim
	                print_token(lines[j].substring(lastIndentLength));
	            } else {
	                // normal comments output raw
	                output_lines[output_lines.length - 1].text.push(lines[j]);
	            }
	        }

	        // for comments of more than one line, make sure there's a new line after
	        print_newline(false, true);
	    }

	    function handle_inline_comment() {
	        output_space_before_token = true;
	        print_token();
	        output_space_before_token = true;
	    }

	    function handle_comment() {
	        if (input_wanted_newline) {
	            print_newline(false, true);
	        } else {
	            trim_output(true);
	        }

	        output_space_before_token = true;
	        print_token();
	        print_newline(false, true);
	    }

	    function handle_dot() {
	        if (start_of_statement()) {
	            // The conditional starts the statement if appropriate.
	        }

	        if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {
	            output_space_before_token = true;
	        } else {
	            // allow preserved newlines before dots in general
	            // force newlines on dots after close paren when break_chained - for bar().baz()
	            allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);
	        }

	        print_token();
	    }

	    function handle_unknown() {
	        print_token();

	        if (token_text[token_text.length - 1] === '\n') {
	            print_newline();
	        }
	    }
	}


/***/ },
/* 237 */
/***/ function(module, exports) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * This module contains a small element attribute value parser. It's primary
	 * goal is to extract link information from attribute values (like the href in
	 * <a href="/some/link.html"> for example).
	 *
	 * There are several types of linkable attribute values:
	 * - TYPE_URI: a URI (e.g. <a href="uri">).
	 * - TYPE_URI_LIST: a space separated list of URIs (e.g. <a ping="uri1 uri2">).
	 * - TYPE_IDREF: a reference to an other element in the same document via its id
	 *   (e.g. <label for="input-id"> or <key command="command-id">).
	 * - TYPE_IDREF_LIST: a space separated list of IDREFs (e.g.
	 *   <output for="id1 id2">).
	 * - TYPE_JS_RESOURCE_URI: a URI to a javascript resource that can be opened in
	 *   the devtools (e.g. <script src="uri">).
	 * - TYPE_CSS_RESOURCE_URI: a URI to a css resource that can be opened in the
	 *   devtools (e.g. <link href="uri">).
	 *
	 * parseAttribute is the parser entry function, exported on this module.
	 */

	const TYPE_STRING = "string";
	const TYPE_URI = "uri";
	const TYPE_URI_LIST = "uriList";
	const TYPE_IDREF = "idref";
	const TYPE_IDREF_LIST = "idrefList";
	const TYPE_JS_RESOURCE_URI = "jsresource";
	const TYPE_CSS_RESOURCE_URI = "cssresource";

	const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
	const HTML_NS = "http://www.w3.org/1999/xhtml";

	/* eslint-disable max-len */
	const ATTRIBUTE_TYPES = [
	  {namespaceURI: HTML_NS, attributeName: "action", tagName: "form", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "background", tagName: "body", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "blockquote", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "q", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "del", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "cite", tagName: "ins", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "classid", tagName: "object", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "codebase", tagName: "object", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "codebase", tagName: "applet", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "command", tagName: "menuitem", type: TYPE_IDREF},
	  {namespaceURI: "*", attributeName: "contextmenu", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "data", tagName: "object", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "for", tagName: "label", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "for", tagName: "output", type: TYPE_IDREF_LIST},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "button", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "fieldset", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "input", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "keygen", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "label", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "object", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "output", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "select", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "form", tagName: "textarea", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "formaction", tagName: "button", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "formaction", tagName: "input", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "headers", tagName: "td", type: TYPE_IDREF_LIST},
	  {namespaceURI: HTML_NS, attributeName: "headers", tagName: "th", type: TYPE_IDREF_LIST},
	  {namespaceURI: HTML_NS, attributeName: "href", tagName: "a", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "href", tagName: "area", type: TYPE_URI},
	  {namespaceURI: "*", attributeName: "href", tagName: "link", type: TYPE_CSS_RESOURCE_URI,
	  /* eslint-enable */
	    isValid: (namespaceURI, tagName, attributes) => {
	      return getAttribute(attributes, "rel") === "stylesheet";
	    }},
	  /* eslint-disable max-len */
	  {namespaceURI: "*", attributeName: "href", tagName: "link", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "href", tagName: "base", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "icon", tagName: "menuitem", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "list", tagName: "input", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "img", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "frame", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "longdesc", tagName: "iframe", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "manifest", tagName: "html", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "menu", tagName: "button", type: TYPE_IDREF},
	  {namespaceURI: HTML_NS, attributeName: "ping", tagName: "a", type: TYPE_URI_LIST},
	  {namespaceURI: HTML_NS, attributeName: "ping", tagName: "area", type: TYPE_URI_LIST},
	  {namespaceURI: HTML_NS, attributeName: "poster", tagName: "video", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "profile", tagName: "head", type: TYPE_URI},
	  {namespaceURI: "*", attributeName: "src", tagName: "script", type: TYPE_JS_RESOURCE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "input", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "frame", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "iframe", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "img", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "audio", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "embed", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "source", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "track", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "src", tagName: "video", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "usemap", tagName: "img", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "usemap", tagName: "input", type: TYPE_URI},
	  {namespaceURI: HTML_NS, attributeName: "usemap", tagName: "object", type: TYPE_URI},
	  {namespaceURI: "*", attributeName: "xmlns", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "command", tagName: "key", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "containment", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "context", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "datasources", tagName: "*", type: TYPE_URI_LIST},
	  {namespaceURI: XUL_NS, attributeName: "insertafter", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "insertbefore", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "menu", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "observes", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "popup", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "ref", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "removeelement", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "sortResource", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "sortResource2", tagName: "*", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "src", tagName: "stringbundle", type: TYPE_URI},
	  {namespaceURI: XUL_NS, attributeName: "template", tagName: "*", type: TYPE_IDREF},
	  {namespaceURI: XUL_NS, attributeName: "tooltip", tagName: "*", type: TYPE_IDREF},
	  /* eslint-enable */
	  // SVG links aren't handled yet, see bug 1158831.
	  // {namespaceURI: SVG_NS, attributeName: "fill", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "stroke", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "markerstart", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "markermid", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "markerend", tagName: "*", type: },
	  // {namespaceURI: SVG_NS, attributeName: "xlink:href", tagName: "*", type: }
	];

	var parsers = {
	  [TYPE_URI]: function (attributeValue) {
	    return [{
	      type: TYPE_URI,
	      value: attributeValue
	    }];
	  },
	  [TYPE_URI_LIST]: function (attributeValue) {
	    let data = splitBy(attributeValue, " ");
	    for (let token of data) {
	      if (!token.type) {
	        token.type = TYPE_URI;
	      }
	    }
	    return data;
	  },
	  [TYPE_JS_RESOURCE_URI]: function (attributeValue) {
	    return [{
	      type: TYPE_JS_RESOURCE_URI,
	      value: attributeValue
	    }];
	  },
	  [TYPE_CSS_RESOURCE_URI]: function (attributeValue) {
	    return [{
	      type: TYPE_CSS_RESOURCE_URI,
	      value: attributeValue
	    }];
	  },
	  [TYPE_IDREF]: function (attributeValue) {
	    return [{
	      type: TYPE_IDREF,
	      value: attributeValue
	    }];
	  },
	  [TYPE_IDREF_LIST]: function (attributeValue) {
	    let data = splitBy(attributeValue, " ");
	    for (let token of data) {
	      if (!token.type) {
	        token.type = TYPE_IDREF;
	      }
	    }
	    return data;
	  }
	};

	/**
	 * Parse an attribute value.
	 * @param {String} namespaceURI The namespaceURI of the node that has the
	 * attribute.
	 * @param {String} tagName The tagName of the node that has the attribute.
	 * @param {Array} attributes The list of all attributes of the node. This should
	 * be an array of {name, value} objects.
	 * @param {String} attributeName The name of the attribute to parse.
	 * @return {Array} An array of tokens that represents the value. Each token is
	 * an object {type: [string|uri|jsresource|cssresource|idref], value}.
	 * For instance parsing the ping attribute in <a ping="uri1 uri2"> returns:
	 * [
	 *   {type: "uri", value: "uri2"},
	 *   {type: "string", value: " "},
	 *   {type: "uri", value: "uri1"}
	 * ]
	 */
	function parseAttribute(namespaceURI, tagName, attributes, attributeName) {
	  if (!hasAttribute(attributes, attributeName)) {
	    throw new Error(`Attribute ${attributeName} isn't part of the ` +
	                    "provided attributes");
	  }

	  let type = getType(namespaceURI, tagName, attributes, attributeName);
	  if (!type) {
	    return [{
	      type: TYPE_STRING,
	      value: getAttribute(attributes, attributeName)
	    }];
	  }

	  return parsers[type](getAttribute(attributes, attributeName));
	}

	/**
	 * Get the type for links in this attribute if any.
	 * @param {String} namespaceURI The node's namespaceURI.
	 * @param {String} tagName The node's tagName.
	 * @param {Array} attributes The node's attributes, as a list of {name, value}
	 * objects.
	 * @param {String} attributeName The name of the attribute to get the type for.
	 * @return {Object} null if no type exist for this attribute on this node, the
	 * type object otherwise.
	 */
	function getType(namespaceURI, tagName, attributes, attributeName) {
	  for (let typeData of ATTRIBUTE_TYPES) {
	    let containsAttribute = attributeName === typeData.attributeName ||
	                            typeData.attributeName === "*";
	    let hasNamespace = namespaceURI === typeData.namespaceURI ||
	                       typeData.namespaceURI === "*";
	    let hasTagName = tagName.toLowerCase() === typeData.tagName ||
	                     typeData.tagName === "*";
	    let isValid = typeData.isValid
	                  ? typeData.isValid(namespaceURI,
	                                     tagName,
	                                     attributes,
	                                     attributeName)
	                  : true;

	    if (containsAttribute && hasNamespace && hasTagName && isValid) {
	      return typeData.type;
	    }
	  }

	  return null;
	}

	function getAttribute(attributes, attributeName) {
	  for (let {name, value} of attributes) {
	    if (name === attributeName) {
	      return value;
	    }
	  }
	  return null;
	}

	function hasAttribute(attributes, attributeName) {
	  for (let {name} of attributes) {
	    if (name === attributeName) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Split a string by a given character and return an array of objects parts.
	 * The array will contain objects for the split character too, marked with
	 * TYPE_STRING type.
	 * @param {String} value The string to parse.
	 * @param {String} splitChar A 1 length split character.
	 * @return {Array}
	 */
	function splitBy(value, splitChar) {
	  let data = [], i = 0, buffer = "";
	  while (i <= value.length) {
	    if (i === value.length && buffer) {
	      data.push({value: buffer});
	    }
	    if (value[i] === splitChar) {
	      if (buffer) {
	        data.push({value: buffer});
	      }
	      data.push({
	        type: TYPE_STRING,
	        value: splitChar
	      });
	      buffer = "";
	    } else {
	      buffer += value[i];
	    }

	    i++;
	  }
	  return data;
	}

	exports.parseAttribute = parseAttribute;
	// Exported for testing only.
	exports.splitBy = splitBy;


/***/ },
/* 238 */
/***/ function(module, exports) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	/**
	 * Scroll the document so that the element "elem" appears in the viewport.
	 *
	 * @param {DOMNode} elem
	 *        The element that needs to appear in the viewport.
	 * @param {Boolean} centered
	 *        true if you want it centered, false if you want it to appear on the
	 *        top of the viewport. It is true by default, and that is usually what
	 *        you want.
	 */
	function scrollIntoViewIfNeeded(elem, centered = true) {
	  let win = elem.ownerDocument.defaultView;
	  let clientRect = elem.getBoundingClientRect();

	  // The following are always from the {top, bottom}
	  // of the viewport, to the {top, …} of the box.
	  // Think of them as geometrical vectors, it helps.
	  // The origin is at the top left.

	  let topToBottom = clientRect.bottom;
	  let bottomToTop = clientRect.top - win.innerHeight;
	  // We allow one translation on the y axis.
	  let yAllowed = true;

	  // Whatever `centered` is, the behavior is the same if the box is
	  // (even partially) visible.
	  if ((topToBottom > 0 || !centered) && topToBottom <= elem.offsetHeight) {
	    win.scrollBy(0, topToBottom - elem.offsetHeight);
	    yAllowed = false;
	  } else if ((bottomToTop < 0 || !centered) &&
	             bottomToTop >= -elem.offsetHeight) {
	    win.scrollBy(0, bottomToTop + elem.offsetHeight);
	    yAllowed = false;
	  }

	  // If we want it centered, and the box is completely hidden,
	  // then we center it explicitly.
	  if (centered) {
	    if (yAllowed && (topToBottom <= 0 || bottomToTop >= 0)) {
	      win.scroll(win.scrollX,
	                 win.scrollY + clientRect.top
	                 - (win.innerHeight - elem.offsetHeight) / 2);
	    }
	  }
	}
	exports.scrollIntoViewIfNeeded = scrollIntoViewIfNeeded;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2012, Mozilla Foundation and contributors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

	"use strict";

	/* globals document */

	/**
	 * For full documentation, see:
	 * https://github.com/mozilla/domtemplate/blob/master/README.md
	 */

	/**
	 * Begin a new templating process.
	 * @param node A DOM element or string referring to an element's id
	 * @param data Data to use in filling out the template
	 * @param options Options to customize the template processing. One of:
	 * - allowEval: boolean (default false) Basic template interpolations are
	 *   either property paths (e.g. ${a.b.c.d}), or if allowEval=true then we
	 *   allow arbitrary JavaScript
	 * - stack: string or array of strings (default empty array) The template
	 *   engine maintains a stack of tasks to help debug where it is. This allows
	 *   this stack to be prefixed with a template name
	 * - blankNullUndefined: By default DOMTemplate exports null and undefined
	 *   values using the strings 'null' and 'undefined', which can be helpful for
	 *   debugging, but can introduce unnecessary extra logic in a template to
	 *   convert null/undefined to ''. By setting blankNullUndefined:true, this
	 *   conversion is handled by DOMTemplate
	 */
	var template = function (node, data, options) {
	  let state = {
	    options: options || {},
	    // We keep a track of the nodes that we've passed through so we can keep
	    // data.__element pointing to the correct node
	    nodes: []
	  };

	  state.stack = state.options.stack;

	  if (!Array.isArray(state.stack)) {
	    if (typeof state.stack === "string") {
	      state.stack = [ options.stack ];
	    } else {
	      state.stack = [];
	    }
	  }

	  processNode(state, node, data);
	};

	if (true) {
	  exports.template = template;
	}
	this.template = template;

	/**
	 * Helper for the places where we need to act asynchronously and keep track of
	 * where we are right now
	 */
	function cloneState(state) {
	  return {
	    options: state.options,
	    stack: state.stack.slice(),
	    nodes: state.nodes.slice()
	  };
	}

	/**
	 * Regex used to find ${...} sections in some text.
	 * Performance note: This regex uses ( and ) to capture the 'script' for
	 * further processing. Not all of the uses of this regex use this feature so
	 * if use of the capturing group is a performance drain then we should split
	 * this regex in two.
	 */
	var TEMPLATE_REGION = /\$\{([^}]*)\}/g;

	/**
	 * Recursive function to walk the tree processing the attributes as it goes.
	 * @param node the node to process. If you pass a string in instead of a DOM
	 * element, it is assumed to be an id for use with document.getElementById()
	 * @param data the data to use for node processing.
	 */
	function processNode(state, node, data) {
	  if (typeof node === "string") {
	    node = document.getElementById(node);
	  }
	  if (data == null) {
	    data = {};
	  }
	  state.stack.push(node.nodeName + (node.id ? "#" + node.id : ""));
	  let pushedNode = false;
	  try {
	    // Process attributes
	    if (node.attributes && node.attributes.length) {
	      // We need to handle 'foreach' and 'if' first because they might stop
	      // some types of processing from happening, and foreach must come first
	      // because it defines new data on which 'if' might depend.
	      if (node.hasAttribute("foreach")) {
	        processForEach(state, node, data);
	        return;
	      }
	      if (node.hasAttribute("if")) {
	        if (!processIf(state, node, data)) {
	          return;
	        }
	      }
	      // Only make the node available once we know it's not going away
	      state.nodes.push(data.__element);
	      data.__element = node;
	      pushedNode = true;
	      // It's good to clean up the attributes when we've processed them,
	      // but if we do it straight away, we mess up the array index
	      let attrs = Array.prototype.slice.call(node.attributes);
	      for (let i = 0; i < attrs.length; i++) {
	        let value = attrs[i].value;
	        let name = attrs[i].name;

	        state.stack.push(name);
	        try {
	          if (name === "save") {
	            // Save attributes are a setter using the node
	            value = stripBraces(state, value);
	            property(state, value, data, node);
	            node.removeAttribute("save");
	          } else if (name.substring(0, 2) === "on") {
	            // If this attribute value contains only an expression
	            if (value.substring(0, 2) === "${" && value.slice(-1) === "}" &&
	                    value.indexOf("${", 2) === -1) {
	              value = stripBraces(state, value);
	              let func = property(state, value, data);
	              if (typeof func === "function") {
	                node.removeAttribute(name);
	                let capture = node.hasAttribute("capture" + name.substring(2));
	                node.addEventListener(name.substring(2), func, capture);
	                if (capture) {
	                  node.removeAttribute("capture" + name.substring(2));
	                }
	              } else {
	                // Attribute value is not a function - use as a DOM-L0 string
	                node.setAttribute(name, func);
	              }
	            } else {
	              // Attribute value is not a single expression use as DOM-L0
	              node.setAttribute(name, processString(state, value, data));
	            }
	          } else {
	            node.removeAttribute(name);
	            // Remove '_' prefix of attribute names so the DOM won't try
	            // to use them before we've processed the template
	            if (name.charAt(0) === "_") {
	              name = name.substring(1);
	            }

	            // Async attributes can only work if the whole attribute is async
	            let replacement;
	            if (value.indexOf("${") === 0 &&
	                value.charAt(value.length - 1) === "}") {
	              replacement = envEval(state, value.slice(2, -1), data, value);
	              if (replacement && typeof replacement.then === "function") {
	                node.setAttribute(name, "");
	                /* jshint loopfunc:true */
	                replacement.then(function (newValue) {
	                  node.setAttribute(name, newValue);
	                }).then(null, console.error);
	              } else {
	                if (state.options.blankNullUndefined && replacement == null) {
	                  replacement = "";
	                }
	                node.setAttribute(name, replacement);
	              }
	            } else {
	              node.setAttribute(name, processString(state, value, data));
	            }
	          }
	        } finally {
	          state.stack.pop();
	        }
	      }
	    }

	    // Loop through our children calling processNode. First clone them, so the
	    // set of nodes that we visit will be unaffected by additions or removals.
	    let childNodes = Array.prototype.slice.call(node.childNodes);
	    for (let j = 0; j < childNodes.length; j++) {
	      processNode(state, childNodes[j], data);
	    }

	    /* 3 === Node.TEXT_NODE */
	    if (node.nodeType === 3) {
	      processTextNode(state, node, data);
	    }
	  } finally {
	    if (pushedNode) {
	      data.__element = state.nodes.pop();
	    }
	    state.stack.pop();
	  }
	}

	/**
	 * Handle attribute values where the output can only be a string
	 */
	function processString(state, value, data) {
	  return value.replace(TEMPLATE_REGION, function (path) {
	    let insert = envEval(state, path.slice(2, -1), data, value);
	    return state.options.blankNullUndefined && insert == null ? "" : insert;
	  });
	}

	/**
	 * Handle <x if="${...}">
	 * @param node An element with an 'if' attribute
	 * @param data The data to use with envEval()
	 * @returns true if processing should continue, false otherwise
	 */
	function processIf(state, node, data) {
	  state.stack.push("if");
	  try {
	    let originalValue = node.getAttribute("if");
	    let value = stripBraces(state, originalValue);
	    let recurse = true;
	    try {
	      let reply = envEval(state, value, data, originalValue);
	      recurse = !!reply;
	    } catch (ex) {
	      handleError(state, "Error with '" + value + "'", ex);
	      recurse = false;
	    }
	    if (!recurse) {
	      node.parentNode.removeChild(node);
	    }
	    node.removeAttribute("if");
	    return recurse;
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Handle <x foreach="param in ${array}"> and the special case of
	 * <loop foreach="param in ${array}">.
	 * This function is responsible for extracting what it has to do from the
	 * attributes, and getting the data to work on (including resolving promises
	 * in getting the array). It delegates to processForEachLoop to actually
	 * unroll the data.
	 * @param node An element with a 'foreach' attribute
	 * @param data The data to use with envEval()
	 */
	function processForEach(state, node, data) {
	  state.stack.push("foreach");
	  try {
	    let originalValue = node.getAttribute("foreach");
	    let value = originalValue;

	    let paramName = "param";
	    if (value.charAt(0) === "$") {
	      // No custom loop variable name. Use the default: 'param'
	      value = stripBraces(state, value);
	    } else {
	      // Extract the loop variable name from 'NAME in ${ARRAY}'
	      let nameArr = value.split(" in ");
	      paramName = nameArr[0].trim();
	      value = stripBraces(state, nameArr[1].trim());
	    }
	    node.removeAttribute("foreach");
	    try {
	      let evaled = envEval(state, value, data, originalValue);
	      let cState = cloneState(state);
	      handleAsync(evaled, node, function (reply, siblingNode) {
	        processForEachLoop(cState, reply, node, siblingNode, data, paramName);
	      });
	      node.parentNode.removeChild(node);
	    } catch (ex) {
	      handleError(state, "Error with " + value + "'", ex);
	    }
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Called by processForEach to handle looping over the data in a foreach loop.
	 * This works with both arrays and objects.
	 * Calls processForEachMember() for each member of 'set'
	 * @param set The object containing the data to loop over
	 * @param templNode The node to copy for each set member
	 * @param sibling The sibling node to which we add things
	 * @param data the data to use for node processing
	 * @param paramName foreach loops have a name for the parameter currently being
	 * processed. The default is 'param'. e.g. <loop foreach="param in ${x}">...
	 */
	function processForEachLoop(state, set, templNode, sibling, data, paramName) {
	  if (Array.isArray(set)) {
	    set.forEach(function (member, i) {
	      processForEachMember(state, member, templNode, sibling,
	                           data, paramName, "" + i);
	    });
	  } else {
	    for (let member in set) {
	      if (set.hasOwnProperty(member)) {
	        processForEachMember(state, member, templNode, sibling,
	                             data, paramName, member);
	      }
	    }
	  }
	}

	/**
	 * Called by processForEachLoop() to resolve any promises in the array (the
	 * array itself can also be a promise, but that is resolved by
	 * processForEach()). Handle <LOOP> elements (which are taken out of the DOM),
	 * clone the template node, and pass the processing on to processNode().
	 * @param member The data item to use in templating
	 * @param templNode The node to copy for each set member
	 * @param siblingNode The parent node to which we add things
	 * @param data the data to use for node processing
	 * @param paramName The name given to 'member' by the foreach attribute
	 * @param frame A name to push on the stack for debugging
	 */
	function processForEachMember(state, member, templNode, siblingNode, data,
	                              paramName, frame) {
	  state.stack.push(frame);
	  try {
	    let cState = cloneState(state);
	    handleAsync(member, siblingNode, function (reply, node) {
	      // Clone data because we can't be sure that we can safely mutate it
	      let newData = Object.create(null);
	      Object.keys(data).forEach(function (key) {
	        newData[key] = data[key];
	      });
	      newData[paramName] = reply;
	      if (node.parentNode != null) {
	        let clone;
	        if (templNode.nodeName.toLowerCase() === "loop") {
	          for (let i = 0; i < templNode.childNodes.length; i++) {
	            clone = templNode.childNodes[i].cloneNode(true);
	            node.parentNode.insertBefore(clone, node);
	            processNode(cState, clone, newData);
	          }
	        } else {
	          clone = templNode.cloneNode(true);
	          clone.removeAttribute("foreach");
	          node.parentNode.insertBefore(clone, node);
	          processNode(cState, clone, newData);
	        }
	      }
	    });
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Take a text node and replace it with another text node with the ${...}
	 * sections parsed out. We replace the node by altering node.parentNode but
	 * we could probably use a DOM Text API to achieve the same thing.
	 * @param node The Text node to work on
	 * @param data The data to use in calls to envEval()
	 */
	function processTextNode(state, node, data) {
	  // Replace references in other attributes
	  let value = node.data;
	  // We can't use the string.replace() with function trick (see generic
	  // attribute processing in processNode()) because we need to support
	  // functions that return DOM nodes, so we can't have the conversion to a
	  // string.
	  // Instead we process the string as an array of parts. In order to split
	  // the string up, we first replace '${' with '\uF001$' and '}' with '\uF002'
	  // We can then split using \uF001 or \uF002 to get an array of strings
	  // where scripts are prefixed with $.
	  // \uF001 and \uF002 are just unicode chars reserved for private use.
	  value = value.replace(TEMPLATE_REGION, "\uF001$$$1\uF002");
	  // Split a string using the unicode chars F001 and F002.
	  let parts = value.split(/\uF001|\uF002/);
	  if (parts.length > 1) {
	    parts.forEach(function (part) {
	      if (part === null || part === undefined || part === "") {
	        return;
	      }
	      if (part.charAt(0) === "$") {
	        part = envEval(state, part.slice(1), data, node.data);
	      }
	      let cState = cloneState(state);
	      handleAsync(part, node, function (reply, siblingNode) {
	        let doc = siblingNode.ownerDocument;
	        if (reply == null) {
	          reply = cState.options.blankNullUndefined ? "" : "" + reply;
	        }
	        if (typeof reply.cloneNode === "function") {
	          // i.e. if (reply instanceof Element) { ...
	          reply = maybeImportNode(cState, reply, doc);
	          siblingNode.parentNode.insertBefore(reply, siblingNode);
	        } else if (typeof reply.item === "function" && reply.length) {
	          // NodeLists can be live, in which case maybeImportNode can
	          // remove them from the document, and thus the NodeList, which in
	          // turn breaks iteration. So first we clone the list
	          let list = Array.prototype.slice.call(reply, 0);
	          list.forEach(function (child) {
	            let imported = maybeImportNode(cState, child, doc);
	            siblingNode.parentNode.insertBefore(imported, siblingNode);
	          });
	        } else {
	          // if thing isn't a DOM element then wrap its string value in one
	          reply = doc.createTextNode(reply.toString());
	          siblingNode.parentNode.insertBefore(reply, siblingNode);
	        }
	      });
	    });
	    node.parentNode.removeChild(node);
	  }
	}

	/**
	 * Return node or a import of node, if it's not in the given document
	 * @param node The node that we want to be properly owned
	 * @param doc The document that the given node should belong to
	 * @return A node that belongs to the given document
	 */
	function maybeImportNode(state, node, doc) {
	  return node.ownerDocument === doc ? node : doc.importNode(node, true);
	}

	/**
	 * A function to handle the fact that some nodes can be promises, so we check
	 * and resolve if needed using a marker node to keep our place before calling
	 * an inserter function.
	 * @param thing The object which could be real data or a promise of real data
	 * we use it directly if it's not a promise, or resolve it if it is.
	 * @param siblingNode The element before which we insert new elements.
	 * @param inserter The function to to the insertion. If thing is not a promise
	 * then handleAsync() is just 'inserter(thing, siblingNode)'
	 */
	function handleAsync(thing, siblingNode, inserter) {
	  if (thing != null && typeof thing.then === "function") {
	    // Placeholder element to be replaced once we have the real data
	    let tempNode = siblingNode.ownerDocument.createElement("span");
	    siblingNode.parentNode.insertBefore(tempNode, siblingNode);
	    thing.then(function (delayed) {
	      inserter(delayed, tempNode);
	      if (tempNode.parentNode != null) {
	        tempNode.parentNode.removeChild(tempNode);
	      }
	    }).then(null, function (error) {
	      console.error(error.stack);
	    });
	  } else {
	    inserter(thing, siblingNode);
	  }
	}

	/**
	 * Warn of string does not begin '${' and end '}'
	 * @param str the string to check.
	 * @return The string stripped of ${ and }, or untouched if it does not match
	 */
	function stripBraces(state, str) {
	  if (!str.match(TEMPLATE_REGION)) {
	    handleError(state, "Expected " + str + " to match ${...}");
	    return str;
	  }
	  return str.slice(2, -1);
	}

	/**
	 * Combined getter and setter that works with a path through some data set.
	 * For example:
	 * <ul>
	 * <li>property(state, 'a.b', { a: { b: 99 }}); // returns 99
	 * <li>property(state, 'a', { a: { b: 99 }}); // returns { b: 99 }
	 * <li>property(state, 'a', { a: { b: 99 }}, 42); // returns 99 and alters the
	 * input data to be { a: { b: 42 }}
	 * </ul>
	 * @param path An array of strings indicating the path through the data, or
	 * a string to be cut into an array using <tt>split('.')</tt>
	 * @param data the data to use for node processing
	 * @param newValue (optional) If defined, this value will replace the
	 * original value for the data at the path specified.
	 * @return The value pointed to by <tt>path</tt> before any
	 * <tt>newValue</tt> is applied.
	 */
	function property(state, path, data, newValue) {
	  try {
	    if (typeof path === "string") {
	      path = path.split(".");
	    }
	    let value = data[path[0]];
	    if (path.length === 1) {
	      if (newValue !== undefined) {
	        data[path[0]] = newValue;
	      }
	      if (typeof value === "function") {
	        return value.bind(data);
	      }
	      return value;
	    }
	    if (!value) {
	      handleError(state, "\"" + path[0] + "\" is undefined");
	      return null;
	    }
	    return property(state, path.slice(1), value, newValue);
	  } catch (ex) {
	    handleError(state, "Path error with '" + path + "'", ex);
	    return "${" + path + "}";
	  }
	}

	/**
	 * Like eval, but that creates a context of the variables in <tt>env</tt> in
	 * which the script is evaluated.
	 * @param script The string to be evaluated.
	 * @param data The environment in which to eval the script.
	 * @param frame Optional debugging string in case of failure.
	 * @return The return value of the script, or the error message if the script
	 * execution failed.
	 */
	function envEval(state, script, data, frame) {
	  try {
	    state.stack.push(frame.replace(/\s+/g, " "));
	    // Detect if a script is capable of being interpreted using property()
	    if (/^[_a-zA-Z0-9.]*$/.test(script)) {
	      return property(state, script, data);
	    }
	    if (!state.options.allowEval) {
	      handleError(state, "allowEval is not set, however '" + script + "'" +
	                  " can not be resolved using a simple property path.");
	      return "${" + script + "}";
	    }

	    // What we're looking to do is basically:
	    //   with(data) { return eval(script); }
	    // except in strict mode where 'with' is banned.
	    // So we create a function which has a parameter list the same as the
	    // keys in 'data' and with 'script' as its function body.
	    // We then call this function with the values in 'data'
	    let keys = allKeys(data);
	    let func = Function.apply(null, keys.concat("return " + script));

	    let values = keys.map((key) => data[key]);
	    return func.apply(null, values);

	    // TODO: The 'with' method is different from the code above in the value
	    // of 'this' when calling functions. For example:
	    //   envEval(state, 'foo()', { foo: function () { return this; } }, ...);
	    // The global for 'foo' when using 'with' is the data object. However the
	    // code above, the global is null. (Using 'func.apply(data, values)'
	    // changes 'this' in the 'foo()' frame, but not in the inside the body
	    // of 'foo', so that wouldn't help)
	  } catch (ex) {
	    handleError(state, "Template error evaluating '" + script + "'", ex);
	    return "${" + script + "}";
	  } finally {
	    state.stack.pop();
	  }
	}

	/**
	 * Object.keys() that respects the prototype chain
	 */
	function allKeys(data) {
	  let keys = [];
	  for (let key in data) {
	    keys.push(key);
	  }
	  return keys;
	}

	/**
	 * A generic way of reporting errors, for easy overloading in different
	 * environments.
	 * @param message the error message to report.
	 * @param ex optional associated exception.
	 */
	function handleError(state, message, ex) {
	  logError(message + " (In: " + state.stack.join(" > ") + ")");
	  if (ex) {
	    logError(ex);
	  }
	}

	/**
	 * A generic way of reporting errors, for easy overloading in different
	 * environments.
	 * @param message the error message to report.
	 */
	function logError(message) {
	  console.error(message);
	}

	exports.template = template;


/***/ },
/* 240 */
/***/ function(module, exports) {

	"use strict";

	module.exports = {
	  FILTER_ACCEPT: 1,
	  FILTER_REJECT: 2,
	  FILTER_SKIP: 3,

	  SHOW_ALL: 0xFFFFFFFF,
	  SHOW_ELEMENT: 0x00000001,
	  SHOW_ATTRIBUTE: 0x00000002,
	  SHOW_TEXT: 0x00000004,
	  SHOW_CDATA_SECTION: 0x00000008,
	  SHOW_ENTITY_REFERENCE: 0x00000010,
	  SHOW_ENTITY: 0x00000020,
	  SHOW_PROCESSING_INSTRUCTION: 0x00000040,
	  SHOW_COMMENT: 0x00000080,
	  SHOW_DOCUMENT: 0x00000100,
	  SHOW_DOCUMENT_TYPE: 0x00000200,
	  SHOW_DOCUMENT_FRAGMENT: 0x00000400,
	  SHOW_NOTATION: 0x00000800
	};


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	/*
	 * The code below is mostly is a slight modification of intl/locale/PluralForm.jsm that
	 * removes dependencies on chrome privileged APIs. To make maintenance easier, this file
	 * is kept as close as possible to the original in terms of implementation.
	 * The modified methods here are
	 * - makeGetter (remove code adding the caller name to the log)
	 * - get ruleNum() (rely on LocalizationHelper instead of String.services)
	 * - log() (rely on console.log)
	 *
	 * Disable eslint warnings to preserve original code style.
	 */

	/* eslint-disable */

	/**
	 * This module provides the PluralForm object which contains a method to figure
	 * out which plural form of a word to use for a given number based on the
	 * current localization. There is also a makeGetter method that creates a get
	 * function for the desired plural rule. This is useful for extensions that
	 * specify their own plural rule instead of relying on the browser default.
	 * (I.e., the extension hasn't been localized to the browser's locale.)
	 *
	 * See: http://developer.mozilla.org/en/docs/Localization_and_Plurals
	 *
	 * List of methods:
	 *
	 * string pluralForm
	 * get(int aNum, string aWords)
	 *
	 * int numForms
	 * numForms()
	 *
	 * [string pluralForm get(int aNum, string aWords), int numForms numForms()]
	 * makeGetter(int aRuleNum)
	 * Note: Basically, makeGetter returns 2 functions that do "get" and "numForm"
	 */

	const {LocalizationHelper} = __webpack_require__(56);
	const L10N = new LocalizationHelper("global/locale/intl.properties");

	// These are the available plural functions that give the appropriate index
	// based on the plural rule number specified. The first element is the number
	// of plural forms and the second is the function to figure out the index.
	var gFunctions = [
	  // 0: Chinese
	  [1, (n) => 0],
	  // 1: English
	  [2, (n) => n!=1?1:0],
	  // 2: French
	  [2, (n) => n>1?1:0],
	  // 3: Latvian
	  [3, (n) => n%10==1&&n%100!=11?1:n!=0?2:0],
	  // 4: Scottish Gaelic
	  [4, (n) => n==1||n==11?0:n==2||n==12?1:n>0&&n<20?2:3],
	  // 5: Romanian
	  [3, (n) => n==1?0:n==0||n%100>0&&n%100<20?1:2],
	  // 6: Lithuanian
	  [3, (n) => n%10==1&&n%100!=11?0:n%10>=2&&(n%100<10||n%100>=20)?2:1],
	  // 7: Russian
	  [3, (n) => n%10==1&&n%100!=11?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2],
	  // 8: Slovak
	  [3, (n) => n==1?0:n>=2&&n<=4?1:2],
	  // 9: Polish
	  [3, (n) => n==1?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2],
	  // 10: Slovenian
	  [4, (n) => n%100==1?0:n%100==2?1:n%100==3||n%100==4?2:3],
	  // 11: Irish Gaeilge
	  [5, (n) => n==1?0:n==2?1:n>=3&&n<=6?2:n>=7&&n<=10?3:4],
	  // 12: Arabic
	  [6, (n) => n==0?5:n==1?0:n==2?1:n%100>=3&&n%100<=10?2:n%100>=11&&n%100<=99?3:4],
	  // 13: Maltese
	  [4, (n) => n==1?0:n==0||n%100>0&&n%100<=10?1:n%100>10&&n%100<20?2:3],
	  // 14: Macedonian
	  [3, (n) => n%10==1?0:n%10==2?1:2],
	  // 15: Icelandic
	  [2, (n) => n%10==1&&n%100!=11?0:1],
	  // 16: Breton
	  [5, (n) => n%10==1&&n%100!=11&&n%100!=71&&n%100!=91?0:n%10==2&&n%100!=12&&n%100!=72&&n%100!=92?1:(n%10==3||n%10==4||n%10==9)&&n%100!=13&&n%100!=14&&n%100!=19&&n%100!=73&&n%100!=74&&n%100!=79&&n%100!=93&&n%100!=94&&n%100!=99?2:n%1000000==0&&n!=0?3:4],
	];

	this.PluralForm = {
	  /**
	   * Get the correct plural form of a word based on the number
	   *
	   * @param aNum
	   *        The number to decide which plural form to use
	   * @param aWords
	   *        A semi-colon (;) separated string of words to pick the plural form
	   * @return The appropriate plural form of the word
	   */
	  get get()
	  {
	    // This method will lazily load to avoid perf when it is first needed and
	    // creates getPluralForm function. The function it creates is based on the
	    // value of pluralRule specified in the intl stringbundle.
	    // See: http://developer.mozilla.org/en/docs/Localization_and_Plurals

	    // Delete the getters to be overwritten
	    delete PluralForm.numForms;
	    delete PluralForm.get;

	    // Make the plural form get function and set it as the default get
	    [PluralForm.get, PluralForm.numForms] = PluralForm.makeGetter(PluralForm.ruleNum);
	    return PluralForm.get;
	  },

	  /**
	   * Create a pair of plural form functions for the given plural rule number.
	   *
	   * @param aRuleNum
	   *        The plural rule number to create functions
	   * @return A pair: [function that gets the right plural form,
	   *                  function that returns the number of plural forms]
	   */
	  makeGetter: function(aRuleNum)
	  {
	    // Default to "all plural" if the value is out of bounds or invalid
	    if (aRuleNum < 0 || aRuleNum >= gFunctions.length || isNaN(aRuleNum)) {
	      log(["Invalid rule number: ", aRuleNum, " -- defaulting to 0"]);
	      aRuleNum = 0;
	    }

	    // Get the desired pluralRule function
	    let [numForms, pluralFunc] = gFunctions[aRuleNum];

	    // Return functions that give 1) the number of forms and 2) gets the right
	    // plural form
	    return [function(aNum, aWords) {
	      // Figure out which index to use for the semi-colon separated words
	      let index = pluralFunc(aNum ? Number(aNum) : 0);
	      let words = aWords ? aWords.split(/;/) : [""];

	      // Explicitly check bounds to avoid strict warnings
	      let ret = index < words.length ? words[index] : undefined;

	      // Check for array out of bounds or empty strings
	      if ((ret == undefined) || (ret == "")) {
	        // Display a message in the error console
	        log(["Index #", index, " of '", aWords, "' for value ", aNum,
	            " is invalid -- plural rule #", aRuleNum, ";"]);

	        // Default to the first entry (which might be empty, but not undefined)
	        ret = words[0];
	      }

	      return ret;
	    }, () => numForms];
	  },

	  /**
	   * Get the number of forms for the current plural rule
	   *
	   * @return The number of forms
	   */
	  get numForms()
	  {
	    // We lazily load numForms, so trigger the init logic with get()
	    PluralForm.get();
	    return PluralForm.numForms;
	  },

	  /**
	   * Get the plural rule number from the intl stringbundle
	   *
	   * @return The plural rule number
	   */
	  get ruleNum()
	  {
	    try {
	      return parseInt(L10N.getStr("pluralRule"), 10);
	    } catch (e) {
	      // Fallback to English if the pluralRule property is not available.
	      return 1;
	    }
	  }
	};

	/**
	 * Private helper function to log errors to the error console and command line
	 *
	 * @param aMsg
	 *        Error message to log or an array of strings to concat
	 */
	function log(aMsg)
	{
	  let msg = "plural-form.js: " + (aMsg.join ? aMsg.join("") : aMsg);
	  console.log(msg + "\n");
	}

	exports.PluralForm = this.PluralForm;

	/* eslint-ensable */


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

	"use strict";

	var EventEmitter = __webpack_require__(6);
	var Telemetry = __webpack_require__(32);
	var { Task } = __webpack_require__(15);

	/**
	 * This object represents replacement for ToolSidebar
	 * implemented in devtools/client/framework/sidebar.js module
	 *
	 * This new component is part of devtools.html aimed at
	 * removing XUL and use HTML for entire DevTools UI.
	 * There are currently two implementation of the side bar since
	 * the `sidebar.js` module (mentioned above) is still used by
	 * other panels.
	 * As soon as all panels are using this HTML based
	 * implementation it can be removed.
	 */
	function ToolSidebar(tabbox, panel, uid, options = {}) {
	  EventEmitter.decorate(this);

	  this._tabbox = tabbox;
	  this._uid = uid;
	  this._panelDoc = this._tabbox.ownerDocument;
	  this._toolPanel = panel;
	  this._options = options;

	  if (!options.disableTelemetry) {
	    this._telemetry = new Telemetry();
	  }

	  this._tabs = [];

	  if (this._options.hideTabstripe) {
	    this._tabbox.setAttribute("hidetabs", "true");
	  }

	  this.render();

	  this._toolPanel.emit("sidebar-created", this);
	}

	exports.ToolSidebar = ToolSidebar;

	ToolSidebar.prototype = {
	  TABPANEL_ID_PREFIX: "sidebar-panel-",

	  // React

	  get React() {
	    return this._toolPanel.React;
	  },

	  get ReactDOM() {
	    return this._toolPanel.ReactDOM;
	  },

	  get browserRequire() {
	    return this._toolPanel.browserRequire;
	  },

	  get InspectorTabPanel() {
	    if (!this._InspectorTabPanel) {
	      this._InspectorTabPanel =
	        this.React.createFactory(this.browserRequire(
	        "devtools/client/inspector/components/inspector-tab-panel"));
	    }
	    return this._InspectorTabPanel;
	  },

	  // Rendering

	  render: function () {
	    let Tabbar = this.React.createFactory(this.browserRequire(
	      "devtools/client/shared/components/tabs/tabbar"));

	    let sidebar = Tabbar({
	      toolbox: this._toolPanel._toolbox,
	      showAllTabsMenu: true,
	      onSelect: this.handleSelectionChange.bind(this),
	    });

	    this._tabbar = this.ReactDOM.render(sidebar, this._tabbox);
	  },

	  addExistingTab: function (id, title, selected) {
	    this._tabbar.addTab(id, title, selected, this.InspectorTabPanel);

	    this.emit("new-tab-registered", id);
	  },

	  /**
	   * Register a tab. A tab is a document.
	   * The document must have a title, which will be used as the name of the tab.
	   *
	   * @param {string} tab uniq id
	   * @param {string} url
	   */
	  addFrameTab: function (id, title, url, selected) {
	    let panel = this.InspectorTabPanel({
	      id: id,
	      key: id,
	      title: title,
	      url: url,
	      onMount: this.onSidePanelMounted.bind(this),
	    });

	    this._tabbar.addTab(id, title, selected, panel);

	    this.emit("new-tab-registered", id);
	  },

	  onSidePanelMounted: function (content, props) {
	    let iframe = content.querySelector("iframe");
	    if (!iframe || iframe.getAttribute("src")) {
	      return;
	    }

	    let onIFrameLoaded = (event) => {
	      iframe.removeEventListener("load", onIFrameLoaded, true);

	      let doc = event.target;
	      let win = doc.defaultView;
	      if ("setPanel" in win) {
	        win.setPanel(this._toolPanel, iframe);
	      }
	      this.emit(props.id + "-ready");
	    };

	    iframe.addEventListener("load", onIFrameLoaded, true);
	    iframe.setAttribute("src", props.url);
	  },

	  /**
	   * Remove an existing tab.
	   * @param {String} tabId The ID of the tab that was used to register it, or
	   * the tab id attribute value if the tab existed before the sidebar
	   * got created.
	   * @param {String} tabPanelId Optional. If provided, this ID will be used
	   * instead of the tabId to retrieve and remove the corresponding <tabpanel>
	   */
	  removeTab: Task.async(function* (tabId, tabPanelId) {
	    this._tabbar.removeTab(tabId);

	    let win = this.getWindowForTab(tabId);
	    if (win && ("destroy" in win)) {
	      yield win.destroy();
	    }

	    this.emit("tab-unregistered", tabId);
	  }),

	  /**
	   * Show or hide a specific tab.
	   * @param {Boolean} isVisible True to show the tab/tabpanel, False to hide it.
	   * @param {String} id The ID of the tab to be hidden.
	   */
	  toggleTab: function (isVisible, id) {
	    this._tabbar.toggleTab(id, isVisible);
	  },

	  /**
	   * Select a specific tab.
	   */
	  select: function (id) {
	    this._tabbar.select(id);
	  },

	  /**
	   * Return the id of the selected tab.
	   */
	  getCurrentTabID: function () {
	    return this._currentTool;
	  },

	  /**
	   * Returns the requested tab panel based on the id.
	   * @param {String} id
	   * @return {DOMNode}
	   */
	  getTabPanel: function (id) {
	    // Search with and without the ID prefix as there might have been existing
	    // tabpanels by the time the sidebar got created
	    return this._panelDoc.querySelector("#" +
	      this.TABPANEL_ID_PREFIX + id + ", #" + id);
	  },

	  /**
	   * Event handler.
	   */
	  handleSelectionChange: function (id) {
	    if (this._destroyed) {
	      return;
	    }

	    let previousTool = this._currentTool;
	    if (previousTool) {
	      if (this._telemetry) {
	        this._telemetry.toolClosed(previousTool);
	      }
	      this.emit(previousTool + "-unselected");
	    }

	    this._currentTool = id;

	    if (this._telemetry) {
	      this._telemetry.toolOpened(this._currentTool);
	    }

	    this.emit(this._currentTool + "-selected");
	    this.emit("select", this._currentTool);
	  },

	  /**
	   * Show the sidebar.
	   *
	   * @param  {String} id
	   *         The sidebar tab id to select.
	   */
	  show: function (id) {
	    this._tabbox.removeAttribute("hidden");

	    // If an id is given, select the corresponding sidebar tab and record the
	    // tool opened.
	    if (id) {
	      this._currentTool = id;

	      if (this._telemetry) {
	        this._telemetry.toolOpened(this._currentTool);
	      }
	    }

	    this.emit("show");
	  },

	  /**
	   * Show the sidebar.
	   */
	  hide: function () {
	    this._tabbox.setAttribute("hidden", "true");

	    this.emit("hide");
	  },

	  /**
	   * Return the window containing the tab content.
	   */
	  getWindowForTab: function (id) {
	    // Get the tabpanel and make sure it contains an iframe
	    let panel = this.getTabPanel(id);
	    if (!panel || !panel.firstElementChild || !panel.firstElementChild.contentWindow) {
	      return null;
	    }

	    return panel.firstElementChild.contentWindow;
	  },

	  /**
	   * Clean-up.
	   */
	  destroy: Task.async(function* () {
	    if (this._destroyed) {
	      return;
	    }
	    this._destroyed = true;

	    this.emit("destroy");

	    // Note that we check for the existence of this._tabbox.tabpanels at each
	    // step as the container window may have been closed by the time one of the
	    // panel's destroy promise resolves.
	    let tabpanels = [...this._tabbox.querySelectorAll(".tab-panel-box")];
	    for (let panel of tabpanels) {
	      let iframe = panel.querySelector("iframe");
	      if (!iframe) {
	        continue;
	      }
	      let win = iframe.contentWindow;
	      if (win && ("destroy" in win)) {
	        yield win.destroy();
	      }
	      panel.remove();
	    }

	    if (this._currentTool && this._telemetry) {
	      this._telemetry.toolClosed(this._currentTool);
	    }

	    this._toolPanel.emit("sidebar-destroyed", this);

	    this._tabs = null;
	    this._tabbox = null;
	    this._panelDoc = null;
	    this._toolPanel = null;
	  })
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
	/* This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
	"use strict";

	const {KeyCodes} = __webpack_require__(14);

	const PANE_APPEARANCE_DELAY = 50;
	const PAGE_SIZE_ITEM_COUNT_RATIO = 5;
	const WIDGET_FOCUSABLE_NODES = new Set(["vbox", "hbox"]);

	var namedTimeoutsStore = new Map();

	/**
	 * Inheritance helpers from the addon SDK's core/heritage.
	 * Remove these when all devtools are loadered.
	 */
	exports.Heritage = {
	  /**
	   * @see extend in sdk/core/heritage.
	   */
	  extend: function (prototype, properties = {}) {
	    return Object.create(prototype, this.getOwnPropertyDescriptors(properties));
	  },

	  /**
	   * @see getOwnPropertyDescriptors in sdk/core/heritage.
	   */
	  getOwnPropertyDescriptors: function (object) {
	    return Object.getOwnPropertyNames(object).reduce((descriptor, name) => {
	      descriptor[name] = Object.getOwnPropertyDescriptor(object, name);
	      return descriptor;
	    }, {});
	  }
	};

	/**
	 * Helper for draining a rapid succession of events and invoking a callback
	 * once everything settles down.
	 *
	 * @param string id
	 *        A string identifier for the named timeout.
	 * @param number wait
	 *        The amount of milliseconds to wait after no more events are fired.
	 * @param function callback
	 *        Invoked when no more events are fired after the specified time.
	 */
	const setNamedTimeout = function setNamedTimeout(id, wait, callback) {
	  clearNamedTimeout(id);

	  namedTimeoutsStore.set(id, setTimeout(() =>
	    namedTimeoutsStore.delete(id) && callback(), wait));
	};
	exports.setNamedTimeout = setNamedTimeout;

	/**
	 * Clears a named timeout.
	 * @see setNamedTimeout
	 *
	 * @param string id
	 *        A string identifier for the named timeout.
	 */
	const clearNamedTimeout = function clearNamedTimeout(id) {
	  if (!namedTimeoutsStore) {
	    return;
	  }
	  clearTimeout(namedTimeoutsStore.get(id));
	  namedTimeoutsStore.delete(id);
	};
	exports.clearNamedTimeout = clearNamedTimeout;

	/**
	 * Same as `setNamedTimeout`, but invokes the callback only if the provided
	 * predicate function returns true. Otherwise, the timeout is re-triggered.
	 *
	 * @param string id
	 *        A string identifier for the conditional timeout.
	 * @param number wait
	 *        The amount of milliseconds to wait after no more events are fired.
	 * @param function predicate
	 *        The predicate function used to determine whether the timeout restarts.
	 * @param function callback
	 *        Invoked when no more events are fired after the specified time, and
	 *        the provided predicate function returns true.
	 */
	const setConditionalTimeout = function setConditionalTimeout(id, wait,
	                                                             predicate,
	                                                             callback) {
	  setNamedTimeout(id, wait, function maybeCallback() {
	    if (predicate()) {
	      callback();
	      return;
	    }
	    setConditionalTimeout(id, wait, predicate, callback);
	  });
	};
	exports.setConditionalTimeout = setConditionalTimeout;

	/**
	 * Clears a conditional timeout.
	 * @see setConditionalTimeout
	 *
	 * @param string id
	 *        A string identifier for the conditional timeout.
	 */
	const clearConditionalTimeout = function clearConditionalTimeout(id) {
	  clearNamedTimeout(id);
	};
	exports.clearConditionalTimeout = clearConditionalTimeout;

	/**
	 * Helpers for creating and messaging between UI components.
	 */
	const ViewHelpers = exports.ViewHelpers = {
	  /**
	   * Convenience method, dispatching a custom event.
	   *
	   * @param nsIDOMNode target
	   *        A custom target element to dispatch the event from.
	   * @param string type
	   *        The name of the event.
	   * @param any detail
	   *        The data passed when initializing the event.
	   * @return boolean
	   *         True if the event was cancelled or a registered handler
	   *         called preventDefault.
	   */
	  dispatchEvent: function (target, type, detail) {
	    if (!(target instanceof Node)) {
	      // Event cancelled.
	      return true;
	    }
	    let document = target.ownerDocument || target;
	    let dispatcher = target.ownerDocument ? target : document.documentElement;

	    let event = document.createEvent("CustomEvent");
	    event.initCustomEvent(type, true, true, detail);
	    return dispatcher.dispatchEvent(event);
	  },

	  /**
	   * Helper delegating some of the DOM attribute methods of a node to a widget.
	   *
	   * @param object widget
	   *        The widget to assign the methods to.
	   * @param nsIDOMNode node
	   *        A node to delegate the methods to.
	   */
	  delegateWidgetAttributeMethods: function (widget, node) {
	    widget.getAttribute =
	      widget.getAttribute || node.getAttribute.bind(node);
	    widget.setAttribute =
	      widget.setAttribute || node.setAttribute.bind(node);
	    widget.removeAttribute =
	      widget.removeAttribute || node.removeAttribute.bind(node);
	  },

	  /**
	   * Helper delegating some of the DOM event methods of a node to a widget.
	   *
	   * @param object widget
	   *        The widget to assign the methods to.
	   * @param nsIDOMNode node
	   *        A node to delegate the methods to.
	   */
	  delegateWidgetEventMethods: function (widget, node) {
	    widget.addEventListener =
	      widget.addEventListener || node.addEventListener.bind(node);
	    widget.removeEventListener =
	      widget.removeEventListener || node.removeEventListener.bind(node);
	  },

	  /**
	   * Checks if the specified object looks like it's been decorated by an
	   * event emitter.
	   *
	   * @return boolean
	   *         True if it looks, walks and quacks like an event emitter.
	   */
	  isEventEmitter: function (object) {
	    return object && object.on && object.off && object.once && object.emit;
	  },

	  /**
	   * Checks if the specified object is an instance of a DOM node.
	   *
	   * @return boolean
	   *         True if it's a node, false otherwise.
	   */
	  isNode: function (object) {
	    return object instanceof Node ||
	           object instanceof Element ||
	           object instanceof DocumentFragment;
	  },

	  /**
	   * Prevents event propagation when navigation keys are pressed.
	   *
	   * @param Event e
	   *        The event to be prevented.
	   */
	  preventScrolling: function (e) {
	    switch (e.keyCode) {
	      case KeyCodes.DOM_VK_UP:
	      case KeyCodes.DOM_VK_DOWN:
	      case KeyCodes.DOM_VK_LEFT:
	      case KeyCodes.DOM_VK_RIGHT:
	      case KeyCodes.DOM_VK_PAGE_UP:
	      case KeyCodes.DOM_VK_PAGE_DOWN:
	      case KeyCodes.DOM_VK_HOME:
	      case KeyCodes.DOM_VK_END:
	        e.preventDefault();
	        e.stopPropagation();
	    }
	  },

	  /**
	   * Check if the enter key or space was pressed
	   *
	   * @param event event
	   *        The event triggered by a keypress on an element
	   */
	  isSpaceOrReturn: function (event) {
	    return event.keyCode === KeyCodes.DOM_VK_SPACE ||
	          event.keyCode === KeyCodes.DOM_VK_RETURN;
	  },

	  /**
	   * Sets a toggled pane hidden or visible. The pane can either be displayed on
	   * the side (right or left depending on the locale) or at the bottom.
	   *
	   * @param object flags
	   *        An object containing some of the following properties:
	   *        - visible: true if the pane should be shown, false to hide
	   *        - animated: true to display an animation on toggle
	   *        - delayed: true to wait a few cycles before toggle
	   *        - callback: a function to invoke when the toggle finishes
	   * @param nsIDOMNode pane
	   *        The element representing the pane to toggle.
	   */
	  togglePane: function (flags, pane) {
	    // Make sure a pane is actually available first.
	    if (!pane) {
	      return;
	    }

	    // Hiding is always handled via margins, not the hidden attribute.
	    pane.removeAttribute("hidden");

	    // Add a class to the pane to handle min-widths, margins and animations.
	    pane.classList.add("generic-toggled-pane");

	    // Avoid useless toggles.
	    if (flags.visible == !pane.classList.contains("pane-collapsed")) {
	      if (flags.callback) {
	        flags.callback();
	      }
	      return;
	    }

	    // The "animated" attributes enables animated toggles (slide in-out).
	    if (flags.animated) {
	      pane.setAttribute("animated", "");
	    } else {
	      pane.removeAttribute("animated");
	    }

	    // Computes and sets the pane margins in order to hide or show it.
	    let doToggle = () => {
	      // Negative margins are applied to "right" and "left" to support RTL and
	      // LTR directions, as well as to "bottom" to support vertical layouts.
	      // Unnecessary negative margins are forced to 0 via CSS in widgets.css.
	      if (flags.visible) {
	        pane.style.marginLeft = "0";
	        pane.style.marginRight = "0";
	        pane.style.marginBottom = "0";
	        pane.classList.remove("pane-collapsed");
	      } else {
	        let width = Math.floor(pane.getAttribute("width")) + 1;
	        let height = Math.floor(pane.getAttribute("height")) + 1;
	        pane.style.marginLeft = -width + "px";
	        pane.style.marginRight = -width + "px";
	        pane.style.marginBottom = -height + "px";
	        pane.classList.add("pane-collapsed");
	      }

	      // Wait for the animation to end before calling afterToggle()
	      if (flags.animated) {
	        pane.addEventListener("transitionend", function onEvent() {
	          pane.removeEventListener("transitionend", onEvent, false);
	          // Prevent unwanted transitions: if the panel is hidden and the layout
	          // changes margins will be updated and the panel will pop out.
	          pane.removeAttribute("animated");
	          if (flags.callback) {
	            flags.callback();
	          }
	        }, false);
	      } else if (flags.callback) {
	        // Invoke the callback immediately since there's no transition.
	        flags.callback();
	      }
	    };

	    // Sometimes it's useful delaying the toggle a few ticks to ensure
	    // a smoother slide in-out animation.
	    if (flags.delayed) {
	      pane.ownerDocument.defaultView.setTimeout(doToggle,
	                                                PANE_APPEARANCE_DELAY);
	    } else {
	      doToggle();
	    }
	  }
	};

	/**
	 * A generic Item is used to describe children present in a Widget.
	 *
	 * This is basically a very thin wrapper around an nsIDOMNode, with a few
	 * characteristics, like a `value` and an `attachment`.
	 *
	 * The characteristics are optional, and their meaning is entirely up to you.
	 * - The `value` should be a string, passed as an argument.
	 * - The `attachment` is any kind of primitive or object, passed as an argument.
	 *
	 * Iterable via "for (let childItem of parentItem) { }".
	 *
	 * @param object ownerView
	 *        The owner view creating this item.
	 * @param nsIDOMNode element
	 *        A prebuilt node to be wrapped.
	 * @param string value
	 *        A string identifying the node.
	 * @param any attachment
	 *        Some attached primitive/object.
	 */
	function Item(ownerView, element, value, attachment) {
	  this.ownerView = ownerView;
	  this.attachment = attachment;
	  this._value = value + "";
	  this._prebuiltNode = element;
	  this._itemsByElement = new Map();
	}

	Item.prototype = {
	  get value() {
	    return this._value;
	  },
	  get target() {
	    return this._target;
	  },
	  get prebuiltNode() {
	    return this._prebuiltNode;
	  },

	  /**
	   * Immediately appends a child item to this item.
	   *
	   * @param nsIDOMNode element
	   *        An nsIDOMNode representing the child element to append.
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attachment: some attached primitive/object for the item
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function invoked when the child item is removed
	   * @return Item
	   *         The item associated with the displayed element.
	   */
	  append: function (element, options = {}) {
	    let item = new Item(this, element, "", options.attachment);

	    // Entangle the item with the newly inserted child node.
	    // Make sure this is done with the value returned by appendChild(),
	    // to avoid storing a potential DocumentFragment.
	    this._entangleItem(item, this._target.appendChild(element));

	    // Handle any additional options after entangling the item.
	    if (options.attributes) {
	      options.attributes.forEach(e => item._target.setAttribute(e[0], e[1]));
	    }
	    if (options.finalize) {
	      item.finalize = options.finalize;
	    }

	    // Return the item associated with the displayed element.
	    return item;
	  },

	  /**
	   * Immediately removes the specified child item from this item.
	   *
	   * @param Item item
	   *        The item associated with the element to remove.
	   */
	  remove: function (item) {
	    if (!item) {
	      return;
	    }
	    this._target.removeChild(item._target);
	    this._untangleItem(item);
	  },

	  /**
	   * Entangles an item (model) with a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   * @param nsIDOMNode element
	   *        The element displaying the item.
	   */
	  _entangleItem: function (item, element) {
	    this._itemsByElement.set(element, item);
	    item._target = element;
	  },

	  /**
	   * Untangles an item (model) from a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _untangleItem: function (item) {
	    if (item.finalize) {
	      item.finalize(item);
	    }
	    for (let childItem of item) {
	      item.remove(childItem);
	    }

	    this._unlinkItem(item);
	    item._target = null;
	  },

	  /**
	   * Deletes an item from the its parent's storage maps.
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _unlinkItem: function (item) {
	    this._itemsByElement.delete(item._target);
	  },

	  /**
	   * Returns a string representing the object.
	   * Avoid using `toString` to avoid accidental JSONification.
	   * @return string
	   */
	  stringify: function () {
	    return JSON.stringify({
	      value: this._value,
	      target: this._target + "",
	      prebuiltNode: this._prebuiltNode + "",
	      attachment: this.attachment
	    }, null, 2);
	  },

	  _value: "",
	  _target: null,
	  _prebuiltNode: null,
	  finalize: null,
	  attachment: null
	};

	/**
	 * Some generic Widget methods handling Item instances.
	 * Iterable via "for (let childItem of wrappedView) { }".
	 *
	 * Usage:
	 *   function MyView() {
	 *     this.widget = new MyWidget(document.querySelector(".my-node"));
	 *   }
	 *
	 *   MyView.prototype = Heritage.extend(WidgetMethods, {
	 *     myMethod: function() {},
	 *     ...
	 *   });
	 *
	 * See https://gist.github.com/victorporof/5749386 for more details.
	 * The devtools/shared/widgets/SimpleListWidget.jsm is an implementation
	 * example.
	 *
	 * Language:
	 *   - An "item" is an instance of an Item.
	 *   - An "element" or "node" is a nsIDOMNode.
	 *
	 * The supplied widget can be any object implementing the following
	 * methods:
	 *   - function:nsIDOMNode insertItemAt(aIndex:number, aNode:nsIDOMNode,
	 *                                      aValue:string)
	 *   - function:nsIDOMNode getItemAtIndex(aIndex:number)
	 *   - function removeChild(aChild:nsIDOMNode)
	 *   - function removeAllItems()
	 *   - get:nsIDOMNode selectedItem()
	 *   - set selectedItem(aChild:nsIDOMNode)
	 *   - function getAttribute(aName:string)
	 *   - function setAttribute(aName:string, aValue:string)
	 *   - function removeAttribute(aName:string)
	 *   - function addEventListener(aName:string, aCallback:function,
	 *                               aBubbleFlag:boolean)
	 *   - function removeEventListener(aName:string, aCallback:function,
	 *                                  aBubbleFlag:boolean)
	 *
	 * Optional methods that can be implemented by the widget:
	 *   - function ensureElementIsVisible(aChild:nsIDOMNode)
	 *
	 * Optional attributes that may be handled (when calling
	 * get/set/removeAttribute):
	 *   - "emptyText": label temporarily added when there are no items present
	 *   - "headerText": label permanently added as a header
	 *
	 * For automagical keyboard and mouse accessibility, the widget should be an
	 * event emitter with the following events:
	 *   - "keyPress" -> (aName:string, aEvent:KeyboardEvent)
	 *   - "mousePress" -> (aName:string, aEvent:MouseEvent)
	 */
	const WidgetMethods = exports.WidgetMethods = {
	  /**
	   * Sets the element node or widget associated with this container.
	   * @param nsIDOMNode | object widget
	   */
	  set widget(widget) {
	    this._widget = widget;

	    // Can't use a WeakMap for _itemsByValue because keys are strings, and
	    // can't use one for _itemsByElement either, since it needs to be iterable.
	    this._itemsByValue = new Map();
	    this._itemsByElement = new Map();
	    this._stagedItems = [];

	    // Handle internal events emitted by the widget if necessary.
	    if (ViewHelpers.isEventEmitter(widget)) {
	      widget.on("keyPress", this._onWidgetKeyPress.bind(this));
	      widget.on("mousePress", this._onWidgetMousePress.bind(this));
	    }
	  },

	  /**
	   * Gets the element node or widget associated with this container.
	   * @return nsIDOMNode | object
	   */
	  get widget() {
	    return this._widget;
	  },

	  /**
	   * Prepares an item to be added to this container. This allows, for example,
	   * for a large number of items to be batched up before being sorted & added.
	   *
	   * If the "staged" flag is *not* set to true, the item will be immediately
	   * inserted at the correct position in this container, so that all the items
	   * still remain sorted. This can (possibly) be much slower than batching up
	   * multiple items.
	   *
	   * By default, this container assumes that all the items should be displayed
	   * sorted by their value. This can be overridden with the "index" flag,
	   * specifying on which position should an item be appended. The "staged" and
	   * "index" flags are mutually exclusive, meaning that all staged items
	   * will always be appended.
	   *
	   * @param nsIDOMNode element
	   *        A prebuilt node to be wrapped.
	   * @param string value
	   *        A string identifying the node.
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attachment: some attached primitive/object for the item
	   *          - staged: true to stage the item to be appended later
	   *          - index: specifies on which position should the item be appended
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function invoked when the item is removed
	   * @return Item
	   *         The item associated with the displayed element if an unstaged push,
	   *         undefined if the item was staged for a later commit.
	   */
	  push: function ([element, value], options = {}) {
	    let item = new Item(this, element, value, options.attachment);

	    // Batch the item to be added later.
	    if (options.staged) {
	      // An ulterior commit operation will ignore any specified index, so
	      // no reason to keep it around.
	      options.index = undefined;
	      return void this._stagedItems.push({ item: item, options: options });
	    }
	    // Find the target position in this container and insert the item there.
	    if (!("index" in options)) {
	      return this._insertItemAt(this._findExpectedIndexFor(item), item,
	                                options);
	    }
	    // Insert the item at the specified index. If negative or out of bounds,
	    // the item will be simply appended.
	    return this._insertItemAt(options.index, item, options);
	  },

	  /**
	   * Flushes all the prepared items into this container.
	   * Any specified index on the items will be ignored. Everything is appended.
	   *
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - sorted: true to sort all the items before adding them
	   */
	  commit: function (options = {}) {
	    let stagedItems = this._stagedItems;

	    // Sort the items before adding them to this container, if preferred.
	    if (options.sorted) {
	      stagedItems.sort((a, b) => this._currentSortPredicate(a.item, b.item));
	    }
	    // Append the prepared items to this container.
	    for (let { item, opt } of stagedItems) {
	      this._insertItemAt(-1, item, opt);
	    }
	    // Recreate the temporary items list for ulterior pushes.
	    this._stagedItems.length = 0;
	  },

	  /**
	   * Immediately removes the specified item from this container.
	   *
	   * @param Item item
	   *        The item associated with the element to remove.
	   */
	  remove: function (item) {
	    if (!item) {
	      return;
	    }
	    this._widget.removeChild(item._target);
	    this._untangleItem(item);

	    if (!this._itemsByElement.size) {
	      this._preferredValue = this.selectedValue;
	      this._widget.selectedItem = null;
	      this._widget.setAttribute("emptyText", this._emptyText);
	    }
	  },

	  /**
	   * Removes the item at the specified index from this container.
	   *
	   * @param number index
	   *        The index of the item to remove.
	   */
	  removeAt: function (index) {
	    this.remove(this.getItemAtIndex(index));
	  },

	  /**
	   * Removes the items in this container based on a predicate.
	   */
	  removeForPredicate: function (predicate) {
	    let item;
	    while ((item = this.getItemForPredicate(predicate))) {
	      this.remove(item);
	    }
	  },

	  /**
	   * Removes all items from this container.
	   */
	  empty: function () {
	    this._preferredValue = this.selectedValue;
	    this._widget.selectedItem = null;
	    this._widget.removeAllItems();
	    this._widget.setAttribute("emptyText", this._emptyText);

	    for (let [, item] of this._itemsByElement) {
	      this._untangleItem(item);
	    }

	    this._itemsByValue.clear();
	    this._itemsByElement.clear();
	    this._stagedItems.length = 0;
	  },

	  /**
	   * Ensures the specified item is visible in this container.
	   *
	   * @param Item item
	   *        The item to bring into view.
	   */
	  ensureItemIsVisible: function (item) {
	    this._widget.ensureElementIsVisible(item._target);
	  },

	  /**
	   * Ensures the item at the specified index is visible in this container.
	   *
	   * @param number index
	   *        The index of the item to bring into view.
	   */
	  ensureIndexIsVisible: function (index) {
	    this.ensureItemIsVisible(this.getItemAtIndex(index));
	  },

	  /**
	   * Sugar for ensuring the selected item is visible in this container.
	   */
	  ensureSelectedItemIsVisible: function () {
	    this.ensureItemIsVisible(this.selectedItem);
	  },

	  /**
	   * If supported by the widget, the label string temporarily added to this
	   * container when there are no child items present.
	   */
	  set emptyText(value) {
	    this._emptyText = value;

	    // Apply the emptyText attribute right now if there are no child items.
	    if (!this._itemsByElement.size) {
	      this._widget.setAttribute("emptyText", value);
	    }
	  },

	  /**
	   * If supported by the widget, the label string permanently added to this
	   * container as a header.
	   * @param string value
	   */
	  set headerText(value) {
	    this._headerText = value;
	    this._widget.setAttribute("headerText", value);
	  },

	  /**
	   * Toggles all the items in this container hidden or visible.
	   *
	   * This does not change the default filtering predicate, so newly inserted
	   * items will always be visible. Use WidgetMethods.filterContents if you care.
	   *
	   * @param boolean visibleFlag
	   *        Specifies the intended visibility.
	   */
	  toggleContents: function (visibleFlag) {
	    for (let [element] of this._itemsByElement) {
	      element.hidden = !visibleFlag;
	    }
	  },

	  /**
	   * Toggles all items in this container hidden or visible based on a predicate.
	   *
	   * @param function predicate [optional]
	   *        Items are toggled according to the return value of this function,
	   *        which will become the new default filtering predicate in this
	   *        container.
	   *        If unspecified, all items will be toggled visible.
	   */
	  filterContents: function (predicate = this._currentFilterPredicate) {
	    this._currentFilterPredicate = predicate;

	    for (let [element, item] of this._itemsByElement) {
	      element.hidden = !predicate(item);
	    }
	  },

	  /**
	   * Sorts all the items in this container based on a predicate.
	   *
	   * @param function predicate [optional]
	   *        Items are sorted according to the return value of the function,
	   *        which will become the new default sorting predicate in this
	   *        container. If unspecified, all items will be sorted by their value.
	   */
	  sortContents: function (predicate = this._currentSortPredicate) {
	    let sortedItems = this.items.sort(this._currentSortPredicate = predicate);

	    for (let i = 0, len = sortedItems.length; i < len; i++) {
	      this.swapItems(this.getItemAtIndex(i), sortedItems[i]);
	    }
	  },

	  /**
	   * Visually swaps two items in this container.
	   *
	   * @param Item first
	   *        The first item to be swapped.
	   * @param Item second
	   *        The second item to be swapped.
	   */
	  swapItems: function (first, second) {
	    if (first == second) {
	      // We're just dandy, thank you.
	      return;
	    }
	    let { _prebuiltNode: firstPrebuiltTarget, _target: firstTarget } = first;
	    let { _prebuiltNode: secondPrebuiltTarget, _target: secondTarget } = second;

	    // If the two items were constructed with prebuilt nodes as
	    // DocumentFragments, then those DocumentFragments are now
	    // empty and need to be reassembled.
	    if (firstPrebuiltTarget instanceof DocumentFragment) {
	      for (let node of firstTarget.childNodes) {
	        firstPrebuiltTarget.appendChild(node.cloneNode(true));
	      }
	    }
	    if (secondPrebuiltTarget instanceof DocumentFragment) {
	      for (let node of secondTarget.childNodes) {
	        secondPrebuiltTarget.appendChild(node.cloneNode(true));
	      }
	    }

	    // 1. Get the indices of the two items to swap.
	    let i = this._indexOfElement(firstTarget);
	    let j = this._indexOfElement(secondTarget);

	    // 2. Remeber the selection index, to reselect an item, if necessary.
	    let selectedTarget = this._widget.selectedItem;
	    let selectedIndex = -1;
	    if (selectedTarget == firstTarget) {
	      selectedIndex = i;
	    } else if (selectedTarget == secondTarget) {
	      selectedIndex = j;
	    }

	    // 3. Silently nuke both items, nobody needs to know about this.
	    this._widget.removeChild(firstTarget);
	    this._widget.removeChild(secondTarget);
	    this._unlinkItem(first);
	    this._unlinkItem(second);

	    // 4. Add the items again, but reversing their indices.
	    this._insertItemAt.apply(this, i < j ? [i, second] : [j, first]);
	    this._insertItemAt.apply(this, i < j ? [j, first] : [i, second]);

	    // 5. Restore the previous selection, if necessary.
	    if (selectedIndex == i) {
	      this._widget.selectedItem = first._target;
	    } else if (selectedIndex == j) {
	      this._widget.selectedItem = second._target;
	    }

	    // 6. Let the outside world know that these two items were swapped.
	    ViewHelpers.dispatchEvent(first.target, "swap", [second, first]);
	  },

	  /**
	   * Visually swaps two items in this container at specific indices.
	   *
	   * @param number first
	   *        The index of the first item to be swapped.
	   * @param number second
	   *        The index of the second item to be swapped.
	   */
	  swapItemsAtIndices: function (first, second) {
	    this.swapItems(this.getItemAtIndex(first), this.getItemAtIndex(second));
	  },

	  /**
	   * Checks whether an item with the specified value is among the elements
	   * shown in this container.
	   *
	   * @param string value
	   *        The item's value.
	   * @return boolean
	   *         True if the value is known, false otherwise.
	   */
	  containsValue: function (value) {
	    return this._itemsByValue.has(value) ||
	           this._stagedItems.some(({ item }) => item._value == value);
	  },

	  /**
	   * Gets the "preferred value". This is the latest selected item's value,
	   * remembered just before emptying this container.
	   * @return string
	   */
	  get preferredValue() {
	    return this._preferredValue;
	  },

	  /**
	   * Retrieves the item associated with the selected element.
	   * @return Item | null
	   */
	  get selectedItem() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement);
	    }
	    return null;
	  },

	  /**
	   * Retrieves the selected element's index in this container.
	   * @return number
	   */
	  get selectedIndex() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._indexOfElement(selectedElement);
	    }
	    return -1;
	  },

	  /**
	   * Retrieves the value of the selected element.
	   * @return string
	   */
	  get selectedValue() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement)._value;
	    }
	    return "";
	  },

	  /**
	   * Retrieves the attachment of the selected element.
	   * @return object | null
	   */
	  get selectedAttachment() {
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      return this._itemsByElement.get(selectedElement).attachment;
	    }
	    return null;
	  },

	  _selectItem: function (item) {
	    // A falsy item is allowed to invalidate the current selection.
	    let targetElement = item ? item._target : null;
	    let prevElement = this._widget.selectedItem;

	    // Make sure the selected item's target element is focused and visible.
	    if (this.autoFocusOnSelection && targetElement) {
	      targetElement.focus();
	    }

	    if (targetElement != prevElement) {
	      this._widget.selectedItem = targetElement;
	    }
	  },

	  /**
	   * Selects the element with the entangled item in this container.
	   * @param Item | function item
	   */
	  set selectedItem(item) {
	    // A predicate is allowed to select a specific item.
	    // If no item is matched, then the current selection is removed.
	    if (typeof item == "function") {
	      item = this.getItemForPredicate(item);
	    }

	    let targetElement = item ? item._target : null;
	    let prevElement = this._widget.selectedItem;

	    if (this.maintainSelectionVisible && targetElement) {
	      // Some methods are optional. See the WidgetMethods object documentation
	      // for a comprehensive list.
	      if ("ensureElementIsVisible" in this._widget) {
	        this._widget.ensureElementIsVisible(targetElement);
	      }
	    }

	    this._selectItem(item);

	    // Prevent selecting the same item again and avoid dispatching
	    // a redundant selection event, so return early.
	    if (targetElement != prevElement) {
	      let dispTarget = targetElement || prevElement;
	      let dispName = this.suppressSelectionEvents ? "suppressed-select"
	                                                  : "select";
	      ViewHelpers.dispatchEvent(dispTarget, dispName, item);
	    }
	  },

	  /**
	   * Selects the element at the specified index in this container.
	   * @param number index
	   */
	  set selectedIndex(index) {
	    let targetElement = this._widget.getItemAtIndex(index);
	    if (targetElement) {
	      this.selectedItem = this._itemsByElement.get(targetElement);
	      return;
	    }
	    this.selectedItem = null;
	  },

	  /**
	   * Selects the element with the specified value in this container.
	   * @param string value
	   */
	  set selectedValue(value) {
	    this.selectedItem = this._itemsByValue.get(value);
	  },

	  /**
	   * Deselects and re-selects an item in this container.
	   *
	   * Useful when you want a "select" event to be emitted, even though
	   * the specified item was already selected.
	   *
	   * @param Item | function item
	   * @see `set selectedItem`
	   */
	  forceSelect: function (item) {
	    this.selectedItem = null;
	    this.selectedItem = item;
	  },

	  /**
	   * Specifies if this container should try to keep the selected item visible.
	   * (For example, when new items are added the selection is brought into view).
	   */
	  maintainSelectionVisible: true,

	  /**
	   * Specifies if "select" events dispatched from the elements in this container
	   * when their respective items are selected should be suppressed or not.
	   *
	   * If this flag is set to true, then consumers of this container won't
	   * be normally notified when items are selected.
	   */
	  suppressSelectionEvents: false,

	  /**
	   * Focus this container the first time an element is inserted?
	   *
	   * If this flag is set to true, then when the first item is inserted in
	   * this container (and thus it's the only item available), its corresponding
	   * target element is focused as well.
	   */
	  autoFocusOnFirstItem: true,

	  /**
	   * Focus on selection?
	   *
	   * If this flag is set to true, then whenever an item is selected in
	   * this container (e.g. via the selectedIndex or selectedItem setters),
	   * its corresponding target element is focused as well.
	   *
	   * You can disable this flag, for example, to maintain a certain node
	   * focused but visually indicate a different selection in this container.
	   */
	  autoFocusOnSelection: true,

	  /**
	   * Focus on input (e.g. mouse click)?
	   *
	   * If this flag is set to true, then whenever an item receives user input in
	   * this container, its corresponding target element is focused as well.
	   */
	  autoFocusOnInput: true,

	  /**
	   * When focusing on input, allow right clicks?
	   * @see WidgetMethods.autoFocusOnInput
	   */
	  allowFocusOnRightClick: false,

	  /**
	   * The number of elements in this container to jump when Page Up or Page Down
	   * keys are pressed. If falsy, then the page size will be based on the
	   * number of visible items in the container.
	   */
	  pageSize: 0,

	  /**
	   * Focuses the first visible item in this container.
	   */
	  focusFirstVisibleItem: function () {
	    this.focusItemAtDelta(-this.itemCount);
	  },

	  /**
	   * Focuses the last visible item in this container.
	   */
	  focusLastVisibleItem: function () {
	    this.focusItemAtDelta(+this.itemCount);
	  },

	  /**
	   * Focuses the next item in this container.
	   */
	  focusNextItem: function () {
	    this.focusItemAtDelta(+1);
	  },

	  /**
	   * Focuses the previous item in this container.
	   */
	  focusPrevItem: function () {
	    this.focusItemAtDelta(-1);
	  },

	  /**
	   * Focuses another item in this container based on the index distance
	   * from the currently focused item.
	   *
	   * @param number delta
	   *        A scalar specifying by how many items should the selection change.
	   */
	  focusItemAtDelta: function (delta) {
	    // Make sure the currently selected item is also focused, so that the
	    // command dispatcher mechanism has a relative node to work with.
	    // If there's no selection, just select an item at a corresponding index
	    // (e.g. the first item in this container if delta <= 1).
	    let selectedElement = this._widget.selectedItem;
	    if (selectedElement) {
	      selectedElement.focus();
	    } else {
	      this.selectedIndex = Math.max(0, delta - 1);
	      return;
	    }

	    let direction = delta > 0 ? "advanceFocus" : "rewindFocus";
	    let distance = Math.abs(Math[delta > 0 ? "ceil" : "floor"](delta));
	    while (distance--) {
	      if (!this._focusChange(direction)) {
	        // Out of bounds.
	        break;
	      }
	    }

	    // Synchronize the selected item as being the currently focused element.
	    this.selectedItem = this.getItemForElement(this._focusedElement);
	  },

	  /**
	   * Focuses the next or previous item in this container.
	   *
	   * @param string direction
	   *        Either "advanceFocus" or "rewindFocus".
	   * @return boolean
	   *         False if the focus went out of bounds and the first or last item
	   *         in this container was focused instead.
	   */
	  _focusChange: function (direction) {
	    let commandDispatcher = this._commandDispatcher;
	    let prevFocusedElement = commandDispatcher.focusedElement;
	    let currFocusedElement;

	    do {
	      commandDispatcher.suppressFocusScroll = true;
	      commandDispatcher[direction]();
	      currFocusedElement = commandDispatcher.focusedElement;

	      // Make sure the newly focused item is a part of this container. If the
	      // focus goes out of bounds, revert the previously focused item.
	      if (!this.getItemForElement(currFocusedElement)) {
	        prevFocusedElement.focus();
	        return false;
	      }
	    } while (!WIDGET_FOCUSABLE_NODES.has(currFocusedElement.tagName));

	    // Focus remained within bounds.
	    return true;
	  },

	  /**
	   * Gets the command dispatcher instance associated with this container's DOM.
	   * If there are no items displayed in this container, null is returned.
	   * @return nsIDOMXULCommandDispatcher | null
	   */
	  get _commandDispatcher() {
	    if (this._cachedCommandDispatcher) {
	      return this._cachedCommandDispatcher;
	    }
	    let someElement = this._widget.getItemAtIndex(0);
	    if (someElement) {
	      let commandDispatcher = someElement.ownerDocument.commandDispatcher;
	      this._cachedCommandDispatcher = commandDispatcher;
	      return commandDispatcher;
	    }
	    return null;
	  },

	  /**
	   * Gets the currently focused element in this container.
	   *
	   * @return nsIDOMNode
	   *         The focused element, or null if nothing is found.
	   */
	  get _focusedElement() {
	    let commandDispatcher = this._commandDispatcher;
	    if (commandDispatcher) {
	      return commandDispatcher.focusedElement;
	    }
	    return null;
	  },

	  /**
	   * Gets the item in the container having the specified index.
	   *
	   * @param number index
	   *        The index used to identify the element.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemAtIndex: function (index) {
	    return this.getItemForElement(this._widget.getItemAtIndex(index));
	  },

	  /**
	   * Gets the item in the container having the specified value.
	   *
	   * @param string value
	   *        The value used to identify the element.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemByValue: function (value) {
	    return this._itemsByValue.get(value);
	  },

	  /**
	   * Gets the item in the container associated with the specified element.
	   *
	   * @param nsIDOMNode element
	   *        The element used to identify the item.
	   * @param object flags [optional]
	   *        Additional options for showing the source. Supported options:
	   *          - noSiblings: if siblings shouldn't be taken into consideration
	   *                        when searching for the associated item.
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemForElement: function (element, flags = {}) {
	    while (element) {
	      let item = this._itemsByElement.get(element);

	      // Also search the siblings if allowed.
	      if (!flags.noSiblings) {
	        item = item ||
	          this._itemsByElement.get(element.nextElementSibling) ||
	          this._itemsByElement.get(element.previousElementSibling);
	      }
	      if (item) {
	        return item;
	      }
	      element = element.parentNode;
	    }
	    return null;
	  },

	  /**
	   * Gets a visible item in this container validating a specified predicate.
	   *
	   * @param function predicate
	   *        The first item which validates this predicate is returned
	   * @return Item
	   *         The matched item, or null if nothing is found.
	   */
	  getItemForPredicate: function (predicate, owner = this) {
	    // Recursively check the items in this widget for a predicate match.
	    for (let [element, item] of owner._itemsByElement) {
	      let match;
	      if (predicate(item) && !element.hidden) {
	        match = item;
	      } else {
	        match = this.getItemForPredicate(predicate, item);
	      }
	      if (match) {
	        return match;
	      }
	    }
	    // Also check the staged items. No need to do this recursively since
	    // they're not even appended to the view yet.
	    for (let { item } of this._stagedItems) {
	      if (predicate(item)) {
	        return item;
	      }
	    }
	    return null;
	  },

	  /**
	   * Shortcut function for getItemForPredicate which works on item attachments.
	   * @see getItemForPredicate
	   */
	  getItemForAttachment: function (predicate, owner = this) {
	    return this.getItemForPredicate(e => predicate(e.attachment));
	  },

	  /**
	   * Finds the index of an item in the container.
	   *
	   * @param Item item
	   *        The item get the index for.
	   * @return number
	   *         The index of the matched item, or -1 if nothing is found.
	   */
	  indexOfItem: function (item) {
	    return this._indexOfElement(item._target);
	  },

	  /**
	   * Finds the index of an element in the container.
	   *
	   * @param nsIDOMNode element
	   *        The element get the index for.
	   * @return number
	   *         The index of the matched element, or -1 if nothing is found.
	   */
	  _indexOfElement: function (element) {
	    for (let i = 0; i < this._itemsByElement.size; i++) {
	      if (this._widget.getItemAtIndex(i) == element) {
	        return i;
	      }
	    }
	    return -1;
	  },

	  /**
	   * Gets the total number of items in this container.
	   * @return number
	   */
	  get itemCount() {
	    return this._itemsByElement.size;
	  },

	  /**
	   * Returns a list of items in this container, in the displayed order.
	   * @return array
	   */
	  get items() {
	    let store = [];
	    let itemCount = this.itemCount;
	    for (let i = 0; i < itemCount; i++) {
	      store.push(this.getItemAtIndex(i));
	    }
	    return store;
	  },

	  /**
	   * Returns a list of values in this container, in the displayed order.
	   * @return array
	   */
	  get values() {
	    return this.items.map(e => e._value);
	  },

	  /**
	   * Returns a list of attachments in this container, in the displayed order.
	   * @return array
	   */
	  get attachments() {
	    return this.items.map(e => e.attachment);
	  },

	  /**
	   * Returns a list of all the visible (non-hidden) items in this container,
	   * in the displayed order
	   * @return array
	   */
	  get visibleItems() {
	    return this.items.filter(e => !e._target.hidden);
	  },

	  /**
	   * Checks if an item is unique in this container. If an item's value is an
	   * empty string, "undefined" or "null", it is considered unique.
	   *
	   * @param Item item
	   *        The item for which to verify uniqueness.
	   * @return boolean
	   *         True if the item is unique, false otherwise.
	   */
	  isUnique: function (item) {
	    let value = item._value;
	    if (value == "" || value == "undefined" || value == "null") {
	      return true;
	    }
	    return !this._itemsByValue.has(value);
	  },

	  /**
	   * Checks if an item is eligible for this container. By default, this checks
	   * whether an item is unique and has a prebuilt target node.
	   *
	   * @param Item item
	   *        The item for which to verify eligibility.
	   * @return boolean
	   *         True if the item is eligible, false otherwise.
	   */
	  isEligible: function (item) {
	    return this.isUnique(item) && item._prebuiltNode;
	  },

	  /**
	   * Finds the expected item index in this container based on the default
	   * sort predicate.
	   *
	   * @param Item item
	   *        The item for which to get the expected index.
	   * @return number
	   *         The expected item index.
	   */
	  _findExpectedIndexFor: function (item) {
	    let itemCount = this.itemCount;
	    for (let i = 0; i < itemCount; i++) {
	      if (this._currentSortPredicate(this.getItemAtIndex(i), item) > 0) {
	        return i;
	      }
	    }
	    return itemCount;
	  },

	  /**
	   * Immediately inserts an item in this container at the specified index.
	   *
	   * @param number index
	   *        The position in the container intended for this item.
	   * @param Item item
	   *        The item describing a target element.
	   * @param object options [optional]
	   *        Additional options or flags supported by this operation:
	   *          - attributes: a batch of attributes set to the displayed element
	   *          - finalize: function when the item is untangled (removed)
	   * @return Item
	   *         The item associated with the displayed element, null if rejected.
	   */
	  _insertItemAt: function (index, item, options = {}) {
	    if (!this.isEligible(item)) {
	      return null;
	    }

	    // Entangle the item with the newly inserted node.
	    // Make sure this is done with the value returned by insertItemAt(),
	    // to avoid storing a potential DocumentFragment.
	    let node = item._prebuiltNode;
	    let attachment = item.attachment;
	    this._entangleItem(item,
	                       this._widget.insertItemAt(index, node, attachment));

	    // Handle any additional options after entangling the item.
	    if (!this._currentFilterPredicate(item)) {
	      item._target.hidden = true;
	    }
	    if (this.autoFocusOnFirstItem && this._itemsByElement.size == 1) {
	      item._target.focus();
	    }
	    if (options.attributes) {
	      options.attributes.forEach(e => item._target.setAttribute(e[0], e[1]));
	    }
	    if (options.finalize) {
	      item.finalize = options.finalize;
	    }

	    // Hide the empty text if the selection wasn't lost.
	    this._widget.removeAttribute("emptyText");

	    // Return the item associated with the displayed element.
	    return item;
	  },

	  /**
	   * Entangles an item (model) with a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   * @param nsIDOMNode element
	   *        The element displaying the item.
	   */
	  _entangleItem: function (item, element) {
	    this._itemsByValue.set(item._value, item);
	    this._itemsByElement.set(element, item);
	    item._target = element;
	  },

	  /**
	   * Untangles an item (model) from a displayed node element (view).
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _untangleItem: function (item) {
	    if (item.finalize) {
	      item.finalize(item);
	    }
	    for (let childItem of item) {
	      item.remove(childItem);
	    }

	    this._unlinkItem(item);
	    item._target = null;
	  },

	  /**
	   * Deletes an item from the its parent's storage maps.
	   *
	   * @param Item item
	   *        The item describing a target element.
	   */
	  _unlinkItem: function (item) {
	    this._itemsByValue.delete(item._value);
	    this._itemsByElement.delete(item._target);
	  },

	  /**
	   * The keyPress event listener for this container.
	   * @param string name
	   * @param KeyboardEvent event
	   */
	  _onWidgetKeyPress: function (name, event) {
	    // Prevent scrolling when pressing navigation keys.
	    ViewHelpers.preventScrolling(event);

	    switch (event.keyCode) {
	      case KeyCodes.DOM_VK_UP:
	      case KeyCodes.DOM_VK_LEFT:
	        this.focusPrevItem();
	        return;
	      case KeyCodes.DOM_VK_DOWN:
	      case KeyCodes.DOM_VK_RIGHT:
	        this.focusNextItem();
	        return;
	      case KeyCodes.DOM_VK_PAGE_UP:
	        this.focusItemAtDelta(-(this.pageSize ||
	                               (this.itemCount / PAGE_SIZE_ITEM_COUNT_RATIO)));
	        return;
	      case KeyCodes.DOM_VK_PAGE_DOWN:
	        this.focusItemAtDelta(+(this.pageSize ||
	                               (this.itemCount / PAGE_SIZE_ITEM_COUNT_RATIO)));
	        return;
	      case KeyCodes.DOM_VK_HOME:
	        this.focusFirstVisibleItem();
	        return;
	      case KeyCodes.DOM_VK_END:
	        this.focusLastVisibleItem();
	        return;
	    }
	  },

	  /**
	   * The mousePress event listener for this container.
	   * @param string name
	   * @param MouseEvent event
	   */
	  _onWidgetMousePress: function (name, event) {
	    if (event.button != 0 && !this.allowFocusOnRightClick) {
	      // Only allow left-click to trigger this event.
	      return;
	    }

	    let item = this.getItemForElement(event.target);
	    if (item) {
	      // The container is not empty and we clicked on an actual item.
	      this.selectedItem = item;
	      // Make sure the current event's target element is also focused.
	      this.autoFocusOnInput && item._target.focus();
	    }
	  },

	  /**
	   * The predicate used when filtering items. By default, all items in this
	   * view are visible.
	   *
	   * @param Item item
	   *        The item passing through the filter.
	   * @return boolean
	   *         True if the item should be visible, false otherwise.
	   */
	  _currentFilterPredicate: function (item) {
	    return true;
	  },

	  /**
	   * The predicate used when sorting items. By default, items in this view
	   * are sorted by their label.
	   *
	   * @param Item first
	   *        The first item used in the comparison.
	   * @param Item second
	   *        The second item used in the comparison.
	   * @return number
	   *         -1 to sort first to a lower index than second
	   *          0 to leave first and second unchanged with respect to each other
	   *          1 to sort second to a lower index than first
	   */
	  _currentSortPredicate: function (first, second) {
	    return +(first._value.toLowerCase() > second._value.toLowerCase());
	  },

	  /**
	   * Call a method on this widget named `methodName`. Any further arguments are
	   * passed on to the method. Returns the result of the method call.
	   *
	   * @param String methodName
	   *        The name of the method you want to call.
	   * @param args
	   *        Optional. Any arguments you want to pass through to the method.
	   */
	  callMethod: function (methodName, ...args) {
	    return this._widget[methodName].apply(this._widget, args);
	  },

	  _widget: null,
	  _emptyText: "",
	  _headerText: "",
	  _preferredValue: "",
	  _cachedCommandDispatcher: null
	};

	/**
	 * A generator-iterator over all the items in this container.
	 */
	Item.prototype[Symbol.iterator] =
	WidgetMethods[Symbol.iterator] = function* () {
	  yield* this._itemsByElement.values();
	};


/***/ }
/******/ ]);